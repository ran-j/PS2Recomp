// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_140004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140004) {
        switch (ctx->pc) {
            case 0x140008: ctx->pc = 0; goto label_140008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140004: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_140008:
    // 0x140008: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14000c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x140010: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x140014: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x140018: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14001c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAbsorbButtonWkr__FP6BUTTONP3WKR
// Address: 0x140028 - 0x140048

void entry_140048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140048: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14004c: 0x12400010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140090; return;
    }
    // 0x140054: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x140058: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x14005c: 0x1440000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140090; return;
    }
    // 0x140064: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x140068: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x14006c: 0x14620008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x140090; return;
    }
    // 0x140074: 0x8e020680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x140078: 0x14400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140090; return;
    }
    // 0x140080: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x140084: 0xc04fdbe
    SET_GPR_U32(ctx, 31, 0x14008c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetButtonButtons__FP6BUTTON7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_14008c
// Address: 0x14008c - 0x1400a8

void entry_14008c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14008c) {
        switch (ctx->pc) {
            case 0x140090: ctx->pc = 0; goto label_140090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14008c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_140090:
    // 0x140090: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x140094: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140098: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14009c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1400a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitVolbtn__FP6VOLBTN
// Address: 0x1400a8 - 0x1400bc

void entry_1400bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1400bc: 0xc04fa46
    SET_GPR_U32(ctx, 31, 0x1400c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1472));
    InitBtn__FP3BTN(rdram, ctx, runtime); return;
}


// Function: entry_1400c4
// Address: 0x1400c4 - 0x1400f0

void entry_1400c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1400c4: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1400c8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1400cc: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1400d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1400d4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1400d8: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1400dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1400e0: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x1400e4: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1400e8: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1400f0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1400f0
// Address: 0x1400f0 - 0x140100

void entry_1400f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1400f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1400f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1400f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadVolbtnFromBrx__FP6VOLBTNP18CBinaryInputStream
// Address: 0x140100 - 0x140114

void entry_140114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140114: 0x260405c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1472));
    // 0x140118: 0xc04fa54
    SET_GPR_U32(ctx, 31, 0x140120);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadBtn__FP3BTNP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_140120
// Address: 0x140120 - 0x140140

void entry_140120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140120) {
        switch (ctx->pc) {
            case 0x140130: ctx->pc = 0; goto label_140130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140120: 0x8e020790
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1936)));
    // 0x140124: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_140130;
    }
    // 0x14012c: 0xae0206fc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1788), GPR_U32(ctx, 2));
label_140130:
    // 0x140130: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140134: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140138: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostVolbtnLoad__FP6VOLBTN
// Address: 0x140140 - 0x140164

void entry_140164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140164: 0xc04fa8e
    SET_GPR_U32(ctx, 31, 0x14016c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1472));
    PostBtnLoad__FP3BTN(rdram, ctx, runtime); return;
}


// Function: entry_14016c
// Address: 0x14016c - 0x140178

void entry_14016c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14016c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x140170: 0xc05008e
    SET_GPR_U32(ctx, 31, 0x140178);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVolbtnButtons__FP6VOLBTN7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_140178
// Address: 0x140178 - 0x140198

void entry_140178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140178) {
        switch (ctx->pc) {
            case 0x140188: ctx->pc = 0; goto label_140188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140178: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x14017c: 0x18400015
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1400));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1401D4; return;
    }
    // 0x140184: 0x26110554
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1364));
label_140188:
    // 0x140188: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14018c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x140190: 0xc056912
    SET_GPR_U32(ctx, 31, 0x140198);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_140198
// Address: 0x140198 - 0x140200

void entry_140198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140198) {
        switch (ctx->pc) {
            case 0x1401c0: ctx->pc = 0; goto label_1401c0;
            case 0x1401d4: ctx->pc = 0; goto label_1401d4;
            case 0x1401e4: ctx->pc = 0; goto label_1401e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140198: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14019c: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        goto label_1401c0;
    }
    // 0x1401a4: 0x8e030574
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1396)));
    // 0x1401a8: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1401ac: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1401b0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1401b4: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1401b8: 0xae030574
    WRITE32(ADD32(GPR_U32(ctx, 16), 1396), GPR_U32(ctx, 3));
    // 0x1401bc: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_1401c0:
    // 0x1401c0: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1401c4: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1401c8: 0x1440ffef
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140188; return;
    }
    // 0x1401d0: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_1401d4:
    // 0x1401d4: 0x14400003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1401e4;
    }
    // 0x1401dc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1401e0: 0xae0205bc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1468), GPR_U32(ctx, 2));
label_1401e4:
    // 0x1401e4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1401e8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1401ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1401f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1401f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1401fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140200; return;
}


// Function: CloneVolbtn__FP6VOLBTNT0
// Address: 0x140200 - 0x14021c

void entry_14021c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14021c: 0xae1106e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1760), GPR_U32(ctx, 17));
    // 0x140220: 0xae1005c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1476), GPR_U32(ctx, 16));
    // 0x140224: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140228: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14022c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetVolbtnButtons__FP6VOLBTN7BUTTONS
// Address: 0x140238 - 0x140248

void entry_140248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140248: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14024c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140254: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140258; return;
}


// Function: UpdateVolbtn__FP6VOLBTNf
// Address: 0x140258 - 0x140284

void entry_140284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140284) {
        switch (ctx->pc) {
            case 0x1402ac: ctx->pc = 0; goto label_1402ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140284: 0x8e2306ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1772)));
    // 0x140288: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14028c: 0x10620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1402ac;
    }
    // 0x140294: 0x104000a5
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14052C; return;
    }
    // 0x14029c: 0x46000a4
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x140530; return;
    }
    // 0x1402a4: 0x10000019
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1468)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14030C; return;
    }
label_1402ac:
    // 0x1402ac: 0xc62206e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1768)); ctx->f[2] = *(float*)&val; }
    // 0x1402b0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1402b4: 0x46020036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1402b8: 0x0
    // NOP
    // 0x1402bc: 0x4500009a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_140528(rdram, ctx, runtime); return;
    }
    // 0x1402c4: 0xc62106e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1764)); ctx->f[1] = *(float*)&val; }
    // 0x1402c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1402cc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1402d0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1402d4: 0x0
    // NOP
    // 0x1402d8: 0x45000094
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14052C; return;
    }
    // 0x1402e0: 0x8e22078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1932)));
    // 0x1402e4: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1402FC; return;
    }
    // 0x1402ec: 0xc05008e
    SET_GPR_U32(ctx, 31, 0x1402f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetVolbtnButtons__FP6VOLBTN7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_1402f4
// Address: 0x1402f4 - 0x140304

void entry_1402f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1402f4) {
        switch (ctx->pc) {
            case 0x1402fc: ctx->pc = 0; goto label_1402fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1402f4: 0x1000008d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14052C; return;
    }
label_1402fc:
    // 0x1402fc: 0xc05008e
    SET_GPR_U32(ctx, 31, 0x140304);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVolbtnButtons__FP6VOLBTN7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_140304
// Address: 0x140304 - 0x140320

void entry_140304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140304) {
        switch (ctx->pc) {
            case 0x14030c: ctx->pc = 0; goto label_14030c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140304: 0x10000089
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14052C; return;
    }
label_14030c:
    // 0x14030c: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x140310: 0x1040000a
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14033C; return;
    }
    // 0x140318: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x140320);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_140320
// Address: 0x140320 - 0x140388

void entry_140320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140320) {
        switch (ctx->pc) {
            case 0x140338: ctx->pc = 0; goto label_140338;
            case 0x14033c: ctx->pc = 0; goto label_14033c;
            case 0x140358: ctx->pc = 0; goto label_140358;
            case 0x140380: ctx->pc = 0; goto label_140380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140320: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x140324: 0x12000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_140338;
    }
    // 0x14032c: 0xae300578
    WRITE32(ADD32(GPR_U32(ctx, 17), 1400), GPR_U32(ctx, 16));
    // 0x140330: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 1396), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14033c;
    }
label_140338:
    // 0x140338: 0xae200574
    WRITE32(ADD32(GPR_U32(ctx, 17), 1396), GPR_U32(ctx, 0));
label_14033c:
    // 0x14033c: 0x8e220574
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
    // 0x140340: 0x18400053
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x140490; return;
    }
    // 0x140348: 0x151080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 2));
    // 0x14034c: 0x5da021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x140350: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x140354: 0x0
    // NOP
label_140358:
    // 0x140358: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x14035c: 0x8c500578
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 1400)));
    // 0x140360: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x140364: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x140368: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x14036c: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_140380;
    }
    // 0x140374: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x140378: 0x10000016
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1403d4(rdram, ctx, runtime); return;
    }
label_140380:
    // 0x140380: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x140388);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 109));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_140388
// Address: 0x140388 - 0x1403a4

void entry_140388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140388) {
        switch (ctx->pc) {
            case 0x14039c: ctx->pc = 0; goto label_14039c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140388: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14039c;
    }
    // 0x140390: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x140394: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1403d4(rdram, ctx, runtime); return;
    }
label_14039c:
    // 0x14039c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1403a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1403a4
// Address: 0x1403a4 - 0x1403b4

void entry_1403a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1403a4: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1403BC; return;
    }
    // 0x1403ac: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1403b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1403b4
// Address: 0x1403b4 - 0x1403c4

void entry_1403b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1403b4) {
        switch (ctx->pc) {
            case 0x1403bc: ctx->pc = 0; goto label_1403bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1403b4: 0x10000008
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1403D8; return;
    }
label_1403bc:
    // 0x1403bc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1403c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1403c4
// Address: 0x1403c4 - 0x1403d4

void entry_1403c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1403c4: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1403d4(rdram, ctx, runtime); return;
    }
    // 0x1403cc: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1403d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1403d4
// Address: 0x1403d4 - 0x140444

void entry_1403d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1403d4) {
        switch (ctx->pc) {
            case 0x1403d8: ctx->pc = 0; goto label_1403d8;
            case 0x140430: ctx->pc = 0; goto label_140430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1403d4: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_1403d8:
    // 0x1403d8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1403dc: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1403e0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1403e4: 0x10400012
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_140430;
    }
    // 0x1403ec: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1403f0: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1403f4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1403f8: 0xc62103cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[1] = *(float*)&val; }
    // 0x1403fc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x140400: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x140404: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x140408: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14040c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x140410: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x140414: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x140418: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14041c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x140420: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x140424: 0x0
    // NOP
    // 0x140428: 0x45030008
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x14044C; return;
    }
label_140430:
    // 0x140430: 0x8e2503f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x140434: 0x10a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14044C; return;
    }
    // 0x14043c: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x140444);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_140444
// Address: 0x140444 - 0x140468

void entry_140444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140444) {
        switch (ctx->pc) {
            case 0x14044c: ctx->pc = 0; goto label_14044c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140444: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        goto label_14044c;
    }
label_14044c:
    // 0x14044c: 0x5260000c
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
        ctx->pc = 0x140480; return;
    }
    // 0x140454: 0x8e220790
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1936)));
    // 0x140458: 0x10400030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14051c(rdram, ctx, runtime); return;
    }
    // 0x140460: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x140468);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_140468
// Address: 0x140468 - 0x140508

void entry_140468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140468) {
        switch (ctx->pc) {
            case 0x140480: ctx->pc = 0; goto label_140480;
            case 0x140490: ctx->pc = 0; goto label_140490;
            case 0x1404c8: ctx->pc = 0; goto label_1404c8;
            case 0x1404ec: ctx->pc = 0; goto label_1404ec;
            case 0x1404f0: ctx->pc = 0; goto label_1404f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140468: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
        goto label_140480;
    }
    // 0x140470: 0xae900000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 16));
    // 0x140474: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x140478: 0x26940004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4));
    // 0x14047c: 0x8e220574
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1396)));
label_140480:
    // 0x140480: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x140484: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x140488: 0x1440ffb3
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140358; return;
    }
label_140490:
    // 0x140490: 0x8e220790
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1936)));
    // 0x140494: 0x50400022
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x140520; return;
    }
    // 0x14049c: 0x8e220598
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1432)));
    // 0x1404a0: 0x14550012
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        goto label_1404ec;
    }
    // 0x1404a8: 0x1aa00011
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1404f0;
    }
    // 0x1404b0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1404b4: 0x8e22059c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x1404b8: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1404f0;
    }
    // 0x1404c0: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1404c4: 0x0
    // NOP
label_1404c8:
    // 0x1404c8: 0xd5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x1404cc: 0x10400008
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1404f0;
    }
    // 0x1404d4: 0x3a31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    // 0x1404d8: 0x2232821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1404dc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1404e0: 0x8ca3059c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 1436)));
    // 0x1404e4: 0x1083fff8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1404c8;
    }
label_1404ec:
    // 0x1404ec: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
label_1404f0:
    // 0x1404f0: 0x10e0000a
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 21), 2));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_14051c(rdram, ctx, runtime); return;
    }
    // 0x1404f8: 0xae350598
    WRITE32(ADD32(GPR_U32(ctx, 17), 1432), GPR_U32(ctx, 21));
    // 0x1404fc: 0x2624059c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1436));
    // 0x140500: 0xc063600
    SET_GPR_U32(ctx, 31, 0x140508);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_140508
// Address: 0x140508 - 0x14051c

void entry_140508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140508: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14050c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x140510: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x140514: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x14051c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_14051c
// Address: 0x14051c - 0x140528

void entry_14051c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14051c) {
        switch (ctx->pc) {
            case 0x140520: ctx->pc = 0; goto label_140520;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14051c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_140520:
    // 0x140520: 0xc05008e
    SET_GPR_U32(ctx, 31, 0x140528);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetVolbtnButtons__FP6VOLBTN7BUTTONS(rdram, ctx, runtime); return;
}


// Function: entry_140528
// Address: 0x140528 - 0x140550

void entry_140528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140528) {
        switch (ctx->pc) {
            case 0x14052c: ctx->pc = 0; goto label_14052c;
            case 0x140530: ctx->pc = 0; goto label_140530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140528: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_14052c:
    // 0x14052c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_140530:
    // 0x140530: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x140534: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x140538: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14053c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x140540: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x140544: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x140548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FGetVolbtnPushObjectsWithinList__FP6VOLBTNPv
// Address: 0x140550 - 0x14058c

void entry_14058c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14058c) {
        switch (ctx->pc) {
            case 0x14059c: ctx->pc = 0; goto label_14059c;
            case 0x1405ac: ctx->pc = 0; goto label_1405ac;
            case 0x1405b0: ctx->pc = 0; goto label_1405b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14058c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1432)));
        goto label_14059c;
    }
    // 0x140594: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1405b0;
    }
label_14059c:
    // 0x14059c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1405a0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1405a4: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140580; return;
    }
label_1405ac:
    // 0x1405ac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1405b0:
    // 0x1405b0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1405b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1405b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1405bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1405c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1405c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1405cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1405d0; return;
}


// Function: AddBtnAseg__FP3BTNP3ALO3OID
// Address: 0x1405d0 - 0x1405e4

void entry_1405e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1405e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1405e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddButtonAseg__FP6BUTTON3OID
// Address: 0x1405f0 - 0x140608

void entry_140608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140608: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14060c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140614: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140618; return;
}


// Function: AddVolbtnAseg__FP6VOLBTN3OID
// Address: 0x140618 - 0x140630

void entry_140630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140630: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140634: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14063c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140640; return;
}


// Function: AddBtnOffAseg__FP3BTNP3ALO3OID
// Address: 0x140640 - 0x140654

void entry_140654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140654: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140658: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddButtonOffAseg__FP6BUTTON3OID
// Address: 0x140660 - 0x140678

void entry_140678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140678: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14067c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140684: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140688; return;
}


// Function: AddVolbtnOffAseg__FP6VOLBTN3OID
// Address: 0x140688 - 0x1406a0

void entry_1406a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1406a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1406a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1406ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1406b0; return;
}


// Function: AddButtonPushObject__FP6BUTTON3OID
// Address: 0x1406b0 - 0x1406d0

void entry_140760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140760: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140764: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14076c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140770; return;
}


// Function: SetVolbtnRsmg__FP6VOLBTNi3OIDN22
// Address: 0x140770 - 0x140780

void entry_140780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140780: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140784: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14078c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140790; return;
}


// Function: StartupCatalog__Fv
// Address: 0x140790 - 0x1407a0

void FUN_001407A0__FPUi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1407a0: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CpchzTokenizePath__FPc
// Address: 0x1407a8 - 0x1407bc

void entry_1407bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1407bc: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1407c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1407c4
// Address: 0x1407c4 - 0x1407f4

void entry_1407c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1407c4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1407c8: 0x1080000d
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140800; return;
    }
    // 0x1407d0: 0x2403005c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 92));
    // 0x1407d4: 0x8045ffff
    SET_GPR_S32(ctx, 5, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 4294967295)));
    // 0x1407d8: 0x10a30009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 47));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x140800; return;
    }
    // 0x1407e0: 0x10a20007
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x140800; return;
    }
    // 0x1407e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1407ec: 0xc078860
    SET_GPR_U32(ctx, 31, 0x1407f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294942232));
    strcpy1(rdram, ctx, runtime); return;
}


// Function: entry_1407f4
// Address: 0x1407f4 - 0x1407fc

void entry_1407f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1407f4: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1407fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1407fc
// Address: 0x1407fc - 0x140968

void entry_1407fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1407fc) {
        switch (ctx->pc) {
            case 0x140800: ctx->pc = 0; goto label_140800;
            case 0x140848: ctx->pc = 0; goto label_140848;
            case 0x14086c: ctx->pc = 0; goto label_14086c;
            case 0x14087c: ctx->pc = 0; goto label_14087c;
            case 0x14089c: ctx->pc = 0; goto label_14089c;
            case 0x1408c0: ctx->pc = 0; goto label_1408c0;
            case 0x140900: ctx->pc = 0; goto label_140900;
            case 0x140930: ctx->pc = 0; goto label_140930;
            case 0x140938: ctx->pc = 0; goto label_140938;
            case 0x14093c: ctx->pc = 0; goto label_14093c;
            case 0x140948: ctx->pc = 0; goto label_140948;
            case 0x140958: ctx->pc = 0; goto label_140958;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1407fc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_140800:
    // 0x140800: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x140804: 0x2042021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x140808: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x14080c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x140810: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x140814: 0xa4102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x140818: 0x1040004b
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_140948;
    }
    // 0x140820: 0x2419002f
    SET_GPR_S32(ctx, 25, ADD32(GPR_U32(ctx, 0), 47));
    // 0x140824: 0x2418002e
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 46));
    // 0x140828: 0x2410003b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 59));
    // 0x14082c: 0x240f005c
    SET_GPR_S32(ctx, 15, ADD32(GPR_U32(ctx, 0), 92));
    // 0x140830: 0x240e0008
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 0), 8));
    // 0x140834: 0x248bfffe
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 4), 4294967294));
    // 0x140838: 0x240d0031
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 49));
    // 0x14083c: 0x240c005f
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 95));
    // 0x140840: 0x80e30000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x140844: 0x0
    // NOP
label_140848:
    // 0x140848: 0x1079000c
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 25)) {
        goto label_14087c;
    }
    // 0x140850: 0x28620030
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 48));
    // 0x140854: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14086c;
    }
    // 0x14085c: 0x1078000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 10)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 24)) {
        goto label_14089c;
    }
    // 0x140864: 0x10000026
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_140900;
    }
label_14086c:
    // 0x14086c: 0x10700014
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        goto label_1408c0;
    }
    // 0x140874: 0x146f0022
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 10)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 15)) {
        goto label_140900;
    }
label_14087c:
    // 0x14087c: 0x5120002f
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
        goto label_14093c;
    }
    // 0x140884: 0xa0a00000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x140888: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14088c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x140890: 0x240a0008
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 8));
    // 0x140894: 0x10000028
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_140938;
    }
label_14089c:
    // 0x14089c: 0x51200027
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
        goto label_14093c;
    }
    // 0x1408a4: 0x554e0025
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 14)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
        goto label_14093c;
    }
    // 0x1408ac: 0xa0a60000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 6));
    // 0x1408b0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1408b4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1408b8: 0x1000001f
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_140938;
    }
label_1408c0:
    // 0x1408c0: 0x1120000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 10)));
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        goto label_140900;
    }
    // 0x1408c8: 0x14eb000d
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 11)) {
        goto label_140900;
    }
    // 0x1408d0: 0x80e20001
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 7), 1)));
    // 0x1408d4: 0x144d000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 10)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 13)) {
        goto label_140900;
    }
    // 0x1408dc: 0x9082fffe
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 4294967294)));
    // 0x1408e0: 0x2487ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1408e4: 0x25290002
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 2));
    // 0x1408e8: 0xa0a20000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1408ec: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1408f0: 0x9082ffff
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 4294967295)));
    // 0x1408f4: 0xa0a20000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1408f8: 0x1000000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_140938;
    }
label_140900:
    // 0x140900: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967231));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_140938;
    }
    // 0x140908: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x14090c: 0x2c42001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 26));
    // 0x140910: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 6));
        goto label_140930;
    }
    // 0x140918: 0x24c2ffd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967248));
    // 0x14091c: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x140920: 0x2c42000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 10));
    // 0x140924: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 12));
        goto label_140930;
    }
    // 0x14092c: 0xa0a60000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 6));
label_140930:
    // 0x140930: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x140934: 0x25290001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
label_140938:
    // 0x140938: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
label_14093c:
    // 0x14093c: 0xe4102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x140940: 0x5440ffc1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
        goto label_140848;
    }
label_140948:
    // 0x140948: 0x11200003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        goto label_140958;
    }
    // 0x140950: 0xa0a00000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x140954: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
label_140958:
    // 0x140958: 0x100102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x14095c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140960: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FValidCdMmode__Fv
// Address: 0x140968 - 0x140978

void entry_140978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140978) {
        switch (ctx->pc) {
            case 0x140994: ctx->pc = 0; goto label_140994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140978: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14097c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x140980: 0x8c6213f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 5104)));
    // 0x140984: 0x10440003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_140994;
    }
    // 0x14098c: 0xaca413f0
    WRITE32(ADD32(GPR_U32(ctx, 5), 5104), GPR_U32(ctx, 4));
    // 0x140990: 0x8c6213f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 5104)));
label_140994:
    // 0x140994: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140998: 0x38420014
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 20));
    // 0x14099c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1409a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCdMmode__Fv
// Address: 0x1409a8 - 0x1409c8

void entry_1409c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1409c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1409cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1409d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1409d8; return;
}


// Function: StartupCd__Fv
// Address: 0x1409d8 - 0x1409e0

void entry_140a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140a3c: 0x10400042
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B48; return;
    }
    // 0x140a44: 0x10400041
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B4C; return;
    }
    // 0x140a4c: 0xc05025a
    SET_GPR_U32(ctx, 31, 0x140a54);
    FValidCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_140a54
// Address: 0x140a54 - 0x140a70

void entry_140a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140a54: 0x1440003d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B4C; return;
    }
    // 0x140a5c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x140a60: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x140a64: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x140a68: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x140a70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 22));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_140a70
// Address: 0x140a70 - 0x140a90

void entry_140a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140a70) {
        switch (ctx->pc) {
            case 0x140a78: ctx->pc = 0; goto label_140a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140a70: 0x10000034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B44; return;
    }
label_140a78:
    // 0x140a78: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x140a7c: 0x8c5101b8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 440)));
    // 0x140a80: 0x56230033
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x140B50; return;
    }
    // 0x140a88: 0xc05025a
    SET_GPR_U32(ctx, 31, 0x140a90);
    FValidCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_140a90
// Address: 0x140a90 - 0x140ab4

void entry_140a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140a90: 0x1040002d
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B48; return;
    }
    // 0x140a98: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x140a9c: 0x3c070024
    SET_GPR_U32(ctx, 7, ((uint32_t)36 << 16));
    // 0x140aa0: 0x8c447aa4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 31396)));
    // 0x140aa4: 0x24c6b800
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294948864));
    // 0x140aa8: 0x24e77aa0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 31392));
    // 0x140aac: 0xc04784e
    SET_GPR_U32(ctx, 31, 0x140ab4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCdRead(rdram, ctx, runtime); return;
}


// Function: entry_140ab4
// Address: 0x140ab4 - 0x140acc

void entry_140ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140ab4) {
        switch (ctx->pc) {
            case 0x140ac4: ctx->pc = 0; goto label_140ac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140ab4: 0x50500024
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 5100), GPR_U32(ctx, 17));
        ctx->pc = 0x140B48; return;
    }
    // 0x140abc: 0x10000023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B4C; return;
    }
label_140ac4:
    // 0x140ac4: 0xc05035a
    SET_GPR_U32(ctx, 31, 0x140acc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FCdCompleted__Fi(rdram, ctx, runtime); return;
}


// Function: entry_140acc
// Address: 0x140acc - 0x140b40

void entry_140acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140acc) {
        switch (ctx->pc) {
            case 0x140af0: ctx->pc = 0; goto label_140af0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140acc: 0x1040001e
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140B48; return;
    }
    // 0x140ad4: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x140ad8: 0x3c05ffff
    SET_GPR_U32(ctx, 5, ((uint32_t)65535 << 16));
    // 0x140adc: 0x244976a0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 2), 30368));
    // 0x140ae0: 0x2467b800
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 3), 4294948864));
    // 0x140ae4: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x140ae8: 0x240607ff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2047));
    // 0x140aec: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
label_140af0:
    // 0x140af0: 0x90e20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x140af4: 0x52202
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 5), 8));
    // 0x140af8: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x140afc: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x140b00: 0xa21026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x140b04: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x140b08: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x140b0c: 0x1221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x140b10: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x140b14: 0x14c8fff6
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 8)) {
        goto label_140af0;
    }
    // 0x140b1c: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x140b20: 0x8c437aa8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 31400)));
    // 0x140b24: 0x14a30007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x140B44; return;
    }
    // 0x140b2c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x140b30: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x140b34: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x140b38: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x140b40);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_140b40
// Address: 0x140b40 - 0x140b60

void entry_140b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140b40) {
        switch (ctx->pc) {
            case 0x140b44: ctx->pc = 0; goto label_140b44;
            case 0x140b48: ctx->pc = 0; goto label_140b48;
            case 0x140b4c: ctx->pc = 0; goto label_140b4c;
            case 0x140b50: ctx->pc = 0; goto label_140b50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140b40: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_140b44:
    // 0x140b44: 0xae4213ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 5100), GPR_U32(ctx, 2));
label_140b48:
    // 0x140b48: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_140b4c:
    // 0x140b4c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_140b50:
    // 0x140b50: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140b54: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140b58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CdPath__FPcT0i
// Address: 0x140b60 - 0x140b9c

void entry_140b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140b9c: 0xc0501ea
    SET_GPR_U32(ctx, 31, 0x140ba4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CpchzTokenizePath__FPc(rdram, ctx, runtime); return;
}


// Function: entry_140ba4
// Address: 0x140ba4 - 0x140bcc

void entry_140ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140ba4) {
        switch (ctx->pc) {
            case 0x140bc0: ctx->pc = 0; goto label_140bc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140ba4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x140ba8: 0x223102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 3)));
    // 0x140bac: 0x1040000a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140BD8; return;
    }
    // 0x140bb4: 0x2471ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x140bb8: 0x2412005c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 92));
    // 0x140bbc: 0x0
    // NOP
label_140bc0:
    // 0x140bc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x140bc4: 0xc078840
    SET_GPR_U32(ctx, 31, 0x140bcc);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_140bcc
// Address: 0x140bcc - 0x140c04

void entry_140bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140bcc) {
        switch (ctx->pc) {
            case 0x140bd8: ctx->pc = 0; goto label_140bd8;
            case 0x140bf0: ctx->pc = 0; goto label_140bf0;
            case 0x140bf8: ctx->pc = 0; goto label_140bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140bcc: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x140bd0: 0x1620fffb
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x140BC0; return;
    }
label_140bd8:
    // 0x140bd8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x140bdc: 0x12600004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294942248));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_140bf0;
    }
    // 0x140be4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x140be8: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294942256));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_140bf8;
    }
label_140bf0:
    // 0x140bf0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x140bf4: 0x24469e38
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294942264));
label_140bf8:
    // 0x140bf8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x140bfc: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x140c04);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_140c04
// Address: 0x140c04 - 0x140c28

void entry_140c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140c04: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x140c08: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x140c0c: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x140c10: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x140c14: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x140c18: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x140c1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140c24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140c28; return;
}


// Function: ReadCd__FUiUiPv
// Address: 0x140c28 - 0x140c7c

void entry_140c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140c7c: 0x10540007
    WRITE32(ADD32(GPR_U32(ctx, 21), 5108), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x140C9C; return;
    }
    // 0x140c84: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x140c8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_140c8c
// Address: 0x140c8c - 0x140c94

void entry_140c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140c8c: 0xc0478ba
    SET_GPR_U32(ctx, 31, 0x140c94);
    snd_StreamSafeCdGetError(rdram, ctx, runtime); return;
}


// Function: entry_140c94
// Address: 0x140c94 - 0x140cc8

void entry_140c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140c94) {
        switch (ctx->pc) {
            case 0x140c9c: ctx->pc = 0; goto label_140c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140c94: 0x1000fff4
    WRITE32(ADD32(GPR_U32(ctx, 19), 5112), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140C68; return;
    }
label_140c9c:
    // 0x140c9c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x140ca0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x140ca4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x140ca8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x140cac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x140cb0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140cb4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140cb8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140cbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140cc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140cc8; return;
}


// Function: ReadCdDirect__FUiUiPv
// Address: 0x140cc8 - 0x140d1c

void entry_140d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140d1c: 0x10540007
    WRITE32(ADD32(GPR_U32(ctx, 21), 5108), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x140D3C; return;
    }
    // 0x140d24: 0xc080cb2
    SET_GPR_U32(ctx, 31, 0x140d2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdSync(rdram, ctx, runtime); return;
}


// Function: entry_140d2c
// Address: 0x140d2c - 0x140d34

void entry_140d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140d2c: 0xc080f64
    SET_GPR_U32(ctx, 31, 0x140d34);
    sceCdGetError(rdram, ctx, runtime); return;
}


// Function: entry_140d34
// Address: 0x140d34 - 0x140d68

void entry_140d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x140d34) {
        switch (ctx->pc) {
            case 0x140d3c: ctx->pc = 0; goto label_140d3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x140d34: 0x1000fff4
    WRITE32(ADD32(GPR_U32(ctx, 19), 5112), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x140D08; return;
    }
label_140d3c:
    // 0x140d3c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x140d40: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x140d44: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x140d48: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x140d4c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x140d50: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140d54: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140d58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140d5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x140d64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x140d68; return;
}


// Function: FCdCompleted__Fi
// Address: 0x140d68 - 0x140d78

void entry_140d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140d78: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x140d7c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x140d80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00140D88
// Address: 0x140d88 - 0x140d90

void entry_140db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140db8: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x140dbc: 0xae00020c
    WRITE32(ADD32(GPR_U32(ctx, 16), 524), GPR_U32(ctx, 0));
    // 0x140dc0: 0xc4609e3c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294942268)); ctx->f[0] = *(float*)&val; }
    // 0x140dc4: 0x26040220
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 544));
    // 0x140dc8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x140dcc: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x140dd0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x140dd4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x140dd8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x140ddc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x140de0: 0x7e020210
    WRITE128(ADD32(GPR_U32(ctx, 16), 528), GPR_VEC(ctx, 2));
    // 0x140de4: 0x2406020c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 524));
    // 0x140de8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x140df0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_140df0
// Address: 0x140df0 - 0x140e10

void entry_140df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140df0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x140df4: 0xae00042c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1068), GPR_U32(ctx, 0));
    // 0x140df8: 0xae030428
    WRITE32(ADD32(GPR_U32(ctx, 16), 1064), GPR_U32(ctx, 3));
    // 0x140dfc: 0xae030424
    WRITE32(ADD32(GPR_U32(ctx, 16), 1060), GPR_U32(ctx, 3));
    // 0x140e00: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140e04: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x140e08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1
// Address: 0x140e10 - 0x140ed0

void entry_140f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x140f3c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x140f40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RestoreChkmgrFromCheckpoint__FP6CHKMGR
// Address: 0x140f48 - 0x140ff8

void entry_14112c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14112c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x141130: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x141138);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 64));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_141138
// Address: 0x141138 - 0x141150

void entry_141138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141138: 0x26060084
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 132));
    // 0x14113c: 0x26070088
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 136));
    // 0x141140: 0x2608008c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 140));
    // 0x141144: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x141148: 0xc079312
    SET_GPR_U32(ctx, 31, 0x141150);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 128));
    LoadTbspFromBrx__FP18CBinaryInputStreamPiPP5TSURFT1PP4TBSP(rdram, ctx, runtime); return;
}


// Function: entry_141150
// Address: 0x141150 - 0x14115c

void entry_141150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141150: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x141154: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x14115c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_14115c
// Address: 0x14115c - 0x141170

void entry_14115c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14115c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x141160: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141164: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141168: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckVolPoint__FP3VOLP6VECTOR
// Address: 0x141170 - 0x141188

void entry_141188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141188: 0x8e04008c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 140)));
    // 0x14118c: 0xc079370
    SET_GPR_U32(ctx, 31, 0x141194);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_141194
// Address: 0x141194 - 0x1411a8

void entry_141194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141194: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x141198: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14119c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1411a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1411a8; return;
}


// Function: InitChkpnt__FP6CHKPNT
// Address: 0x1411a8 - 0x1411bc

void entry_1411bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1411bc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1411c0: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x1411c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_1411c8
// Address: 0x1411c8 - 0x141200

void entry_1411c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1411c8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1411cc: 0xae0205b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1456), GPR_U32(ctx, 2));
    // 0x1411d0: 0xae0305a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 3));
    // 0x1411d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1411d8: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1411dc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1411e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1411e4: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1411e8: 0x8c622304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8964)));
    // 0x1411ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1411f0: 0xae0205b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1460), GPR_U32(ctx, 2));
    // 0x1411f4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1411f8: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x141200);
    WRITE32(ADD32(GPR_U32(ctx, 3), 8964), GPR_U32(ctx, 2));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_141200
// Address: 0x141200 - 0x141210

void entry_141200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141200: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141204: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadChkpntFromBrx__FP6CHKPNTP18CBinaryInputStream
// Address: 0x141210 - 0x141234

void entry_141234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141234: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x141238: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14123c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x141240: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x141248);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 5136));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_141248
// Address: 0x141248 - 0x14129c

void entry_141248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141248) {
        switch (ctx->pc) {
            case 0x141290: ctx->pc = 0; goto label_141290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141248: 0x26230034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 52));
    // 0x14124c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x141250: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x141254: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x141258: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x14125c: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x141260: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x141264: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x141268: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x14126c: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x141270: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x141274: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x141278: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x14127c: 0x12000023
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14130C; return;
    }
    // 0x141284: 0x26330590
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 1424));
    // 0x141288: 0x26320568
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1384));
    // 0x14128c: 0x0
    // NOP
label_141290:
    // 0x141290: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x141294: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14129c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 123));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14129c
// Address: 0x14129c - 0x1412c8

void entry_14129c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14129c) {
        switch (ctx->pc) {
            case 0x1412c0: ctx->pc = 0; goto label_1412c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14129c: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1412c0;
    }
    // 0x1412a4: 0x8e23058c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1420)));
    // 0x1412a8: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1412ac: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1412b0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1412b4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1412b8: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 17), 1420), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1412E8; return;
    }
label_1412c0:
    // 0x1412c0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1412c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 131));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1412c8
// Address: 0x1412c8 - 0x1412f0

void entry_1412c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1412c8) {
        switch (ctx->pc) {
            case 0x1412e8: ctx->pc = 0; goto label_1412e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1412c8: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1412F4; return;
    }
    // 0x1412d0: 0x8e230564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
    // 0x1412d4: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1412d8: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1412dc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1412e0: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1412e4: 0xae230564
    WRITE32(ADD32(GPR_U32(ctx, 17), 1380), GPR_U32(ctx, 3));
label_1412e8:
    // 0x1412e8: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1412f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1412f0
// Address: 0x1412f0 - 0x141338

void entry_1412f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1412f0) {
        switch (ctx->pc) {
            case 0x1412f4: ctx->pc = 0; goto label_1412f4;
            case 0x14130c: ctx->pc = 0; goto label_14130c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1412f0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1412f4:
    // 0x1412f4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1412f8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1412fc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x141300: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x141304: 0x1600ffe2
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141290; return;
    }
label_14130c:
    // 0x14130c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x141310: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x141314: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x141318: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14131c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x141320: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x141324: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x141328: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14132c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x141334: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141338; return;
}


// Function: BindChkpnt__FP6CHKPNT
// Address: 0x141338 - 0x14135c

void entry_14135c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14135c) {
        switch (ctx->pc) {
            case 0x141370: ctx->pc = 0; goto label_141370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14135c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x141360: 0x18400015
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1384));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1413B8; return;
    }
    // 0x141368: 0x26120554
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1364));
    // 0x14136c: 0x0
    // NOP
label_141370:
    // 0x141370: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x141374: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x141378: 0xc056912
    SET_GPR_U32(ctx, 31, 0x141380);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_141380
// Address: 0x141380 - 0x1413e0

void entry_141380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141380) {
        switch (ctx->pc) {
            case 0x1413a8: ctx->pc = 0; goto label_1413a8;
            case 0x1413b8: ctx->pc = 0; goto label_1413b8;
            case 0x1413d0: ctx->pc = 0; goto label_1413d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141380: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x141384: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        goto label_1413a8;
    }
    // 0x14138c: 0x8e030564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x141390: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x141394: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x141398: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x14139c: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1413a0: 0xae030564
    WRITE32(ADD32(GPR_U32(ctx, 16), 1380), GPR_U32(ctx, 3));
    // 0x1413a4: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_1413a8:
    // 0x1413a8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1413ac: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1413b0: 0x1440ffef
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141370; return;
    }
label_1413b8:
    // 0x1413b8: 0x8e020578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
    // 0x1413bc: 0x18400016
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x141418; return;
    }
    // 0x1413c4: 0x26130590
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x1413c8: 0x2612057c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1404));
    // 0x1413cc: 0x0
    // NOP
label_1413d0:
    // 0x1413d0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1413d4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1413d8: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1413e0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1413e0
// Address: 0x1413e0 - 0x141438

void entry_1413e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1413e0) {
        switch (ctx->pc) {
            case 0x141408: ctx->pc = 0; goto label_141408;
            case 0x141418: ctx->pc = 0; goto label_141418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1413e0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1413e4: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
        goto label_141408;
    }
    // 0x1413ec: 0x8e03058c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1420)));
    // 0x1413f0: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1413f4: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1413f8: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1413fc: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x141400: 0xae03058c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1420), GPR_U32(ctx, 3));
    // 0x141404: 0x8e020578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
label_141408:
    // 0x141408: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14140c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x141410: 0x1440ffef
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1413D0; return;
    }
label_141418:
    // 0x141418: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14141c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x141420: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x141424: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141428: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14142c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x141434: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141438; return;
}


// Function: PostChkpntLoad__FP6CHKPNT
// Address: 0x141438 - 0x14145c

void entry_14145c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14145c) {
        switch (ctx->pc) {
            case 0x141470: ctx->pc = 0; goto label_141470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14145c: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x141460: 0x5840000b
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
        ctx->pc = 0x141490; return;
    }
    // 0x141468: 0x26500568
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1384));
    // 0x14146c: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_141470:
    // 0x141470: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x141474: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x14147c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14147c
// Address: 0x14147c - 0x1414ac

void entry_14147c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14147c) {
        switch (ctx->pc) {
            case 0x141490: ctx->pc = 0; goto label_141490;
            case 0x1414a0: ctx->pc = 0; goto label_1414a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14147c: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x141480: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x141484: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x141470; return;
    }
    // 0x14148c: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
label_141490:
    // 0x141490: 0x1840000a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1414BC; return;
    }
    // 0x141498: 0x26500590
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1424));
    // 0x14149c: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1414a0:
    // 0x1414a0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1414a4: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1414ac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1414ac
// Address: 0x1414ac - 0x14151c

void entry_1414ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1414ac) {
        switch (ctx->pc) {
            case 0x1414bc: ctx->pc = 0; goto label_1414bc;
            case 0x141510: ctx->pc = 0; goto label_141510;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1414ac: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x1414b0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1414b4: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1414A0; return;
    }
label_1414bc:
    // 0x1414bc: 0x8e4505a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1440)));
    // 0x1414c0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1414c4: 0x54a20028
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x141568; return;
    }
    // 0x1414cc: 0x26430034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 52));
    // 0x1414d0: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1414d4: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1414d8: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1414dc: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1414e0: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1414e4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1414e8: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1414ec: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1414f0: 0x8e430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1414f4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1414f8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1414fc: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x141500: 0x12000016
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14155C; return;
    }
    // 0x141508: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x14150c: 0x0
    // NOP
label_141510:
    // 0x141510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x141514: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14151c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 116));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14151c
// Address: 0x14151c - 0x14152c

void entry_14151c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14151c: 0x10400009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141544; return;
    }
    // 0x141524: 0xc060d0e
    SET_GPR_U32(ctx, 31, 0x14152c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OidProxyLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14152c
// Address: 0x14152c - 0x141570

void entry_14152c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14152c) {
        switch (ctx->pc) {
            case 0x14153c: ctx->pc = 0; goto label_14153c;
            case 0x141544: ctx->pc = 0; goto label_141544;
            case 0x14155c: ctx->pc = 0; goto label_14155c;
            case 0x141568: ctx->pc = 0; goto label_141568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14152c: 0x14510003
    WRITE32(ADD32(GPR_U32(ctx, 18), 1440), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_14153c;
    }
    // 0x141534: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x141538: 0xae4205a0
    WRITE32(ADD32(GPR_U32(ctx, 18), 1440), GPR_U32(ctx, 2));
label_14153c:
    // 0x14153c: 0xae5005a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 1444), GPR_U32(ctx, 16));
    // 0x141540: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_141544:
    // 0x141544: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x141548: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14154c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x141550: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x141554: 0x1600ffee
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141510; return;
    }
label_14155c:
    // 0x14155c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x141560: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141574; return;
    }
label_141568:
    // 0x141568: 0xc056912
    SET_GPR_U32(ctx, 31, 0x141570);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_141570
// Address: 0x141570 - 0x14158c

void entry_141570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141570) {
        switch (ctx->pc) {
            case 0x141574: ctx->pc = 0; goto label_141574;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141570: 0xae4205a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 1444), GPR_U32(ctx, 2));
label_141574:
    // 0x141574: 0x8e4405a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1448)));
    // 0x141578: 0x1080000e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1350));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1415b4(rdram, ctx, runtime); return;
    }
    // 0x141580: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x141584: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x14158c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_14158c
// Address: 0x14158c - 0x1415a0

void entry_14158c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14158c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x141590: 0x8e4505b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1456)));
    // 0x141594: 0xae4205ac
    WRITE32(ADD32(GPR_U32(ctx, 18), 1452), GPR_U32(ctx, 2));
    // 0x141598: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1415a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1415a0
// Address: 0x1415a0 - 0x1415b4

void entry_1415a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1415a0: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1415B8; return;
    }
    // 0x1415a8: 0x8e4405ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1452)));
    // 0x1415ac: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1415b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1351));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1415b4
// Address: 0x1415b4 - 0x1415d0

void entry_1415b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1415b4) {
        switch (ctx->pc) {
            case 0x1415b8: ctx->pc = 0; goto label_1415b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1415b4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1415b8:
    // 0x1415b8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1415bc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1415c0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1415c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1415c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneChkpnt__FP6CHKPNTT0
// Address: 0x1415d0 - 0x1415fc

void entry_1415fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1415fc) {
        switch (ctx->pc) {
            case 0x141610: ctx->pc = 0; goto label_141610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1415fc: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x141600: 0xae5105b0
    WRITE32(ADD32(GPR_U32(ctx, 18), 1456), GPR_U32(ctx, 17));
    // 0x141604: 0x1840000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 1460), GPR_U32(ctx, 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x141638; return;
    }
    // 0x14160c: 0x26500568
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1384));
label_141610:
    // 0x141610: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x141614: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x141618: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x14161c: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x141624);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_141624
// Address: 0x141624 - 0x14165c

void entry_141624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141624) {
        switch (ctx->pc) {
            case 0x141638: ctx->pc = 0; goto label_141638;
            case 0x141648: ctx->pc = 0; goto label_141648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141624: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x141628: 0x8e420564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1380)));
    // 0x14162c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x141630: 0x1440fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141610; return;
    }
label_141638:
    // 0x141638: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x14163c: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x141670; return;
    }
    // 0x141644: 0x26500590
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1424));
label_141648:
    // 0x141648: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14164c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x141650: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x141654: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x14165c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14165c
// Address: 0x14165c - 0x141690

void entry_14165c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14165c) {
        switch (ctx->pc) {
            case 0x141670: ctx->pc = 0; goto label_141670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14165c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x141660: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x141664: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x141668: 0x1440fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141648; return;
    }
label_141670:
    // 0x141670: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x141674: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x141678: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14167c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141680: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141684: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14168c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141690; return;
}


// Function: UpdateChkpnt__FP6CHKPNTf
// Address: 0x141690 - 0x1416b8

void entry_1416b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1416b8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1416bc: 0x8c62ec58
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294962264)));
    // 0x1416c0: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1416c4: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1416E4; return;
    }
    // 0x1416cc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1416d0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1416d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1416dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1416dc
// Address: 0x1416dc - 0x1416ec

void entry_1416dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1416dc) {
        switch (ctx->pc) {
            case 0x1416e4: ctx->pc = 0; goto label_1416e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1416dc: 0x1000003c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1417D0; return;
    }
label_1416e4:
    // 0x1416e4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1416ec);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1416ec
// Address: 0x1416ec - 0x141708

void entry_1416ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1416ec: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1416f0: 0x12800036
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        entry_1417cc(rdram, ctx, runtime); return;
    }
    // 0x1416f8: 0x8e4505b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1456)));
    // 0x1416fc: 0x24501420
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 5152));
    // 0x141700: 0xc050402
    SET_GPR_U32(ctx, 31, 0x141708);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_141708
// Address: 0x141708 - 0x1417b4

void entry_141708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141708) {
        switch (ctx->pc) {
            case 0x141784: ctx->pc = 0; goto label_141784;
            case 0x141790: ctx->pc = 0; goto label_141790;
            case 0x141798: ctx->pc = 0; goto label_141798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141708: 0x1040001e
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_141784;
    }
    // 0x141710: 0x8e02020c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 524)));
    // 0x141714: 0x1040002e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1417D0; return;
    }
    // 0x14171c: 0xda010210
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x141720: 0xda820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x141724: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x141728: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x14172c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x141730: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x141734: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x141738: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14173c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x141740: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x141744: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x141748: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14174c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x141750: 0x0
    // NOP
    // 0x141754: 0x4501001f
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1417D4; return;
    }
    // 0x14175c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x141760: 0xc4609e40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294942272)); ctx->f[0] = *(float*)&val; }
    // 0x141764: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x141768: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x14176c: 0x70821488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x141770: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x141774: 0x70821389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x141778: 0x7e020210
    WRITE128(ADD32(GPR_U32(ctx, 16), 528), GPR_VEC(ctx, 2));
    // 0x14177c: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x141780: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_141784:
    // 0x141784: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x141788: 0x10000003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 1424));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_141798;
    }
label_141790:
    // 0x141790: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x141794: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_141798:
    // 0x141798: 0x8e42058c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x14179c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1417a0: 0x1040000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1417cc(rdram, ctx, runtime); return;
    }
    // 0x1417a8: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1417ac: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x1417b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1417b4
// Address: 0x1417b4 - 0x1417c4

void entry_1417b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1417b4: 0x1040fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141790; return;
    }
    // 0x1417bc: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1417c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 21), 5680));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1417c4
// Address: 0x1417c4 - 0x1417cc

void entry_1417c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1417c4: 0xc05061c
    SET_GPR_U32(ctx, 31, 0x1417cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TriggerChkpnt__FP6CHKPNT(rdram, ctx, runtime); return;
}


// Function: entry_1417cc
// Address: 0x1417cc - 0x1417f0

void entry_1417cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1417cc) {
        switch (ctx->pc) {
            case 0x1417d0: ctx->pc = 0; goto label_1417d0;
            case 0x1417d4: ctx->pc = 0; goto label_1417d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1417cc: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1417d0:
    // 0x1417d0: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1417d4:
    // 0x1417d4: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1417d8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1417dc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1417e0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1417e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1417e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001417f0
// Address: 0x1417f0 - 0x14180c

void FUN_001417f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1417f0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1417f4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1417f8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1417fc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x141800: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x141804: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14180c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14180c
// Address: 0x14180c - 0x141840

void entry_14180c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14180c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x141810: 0x1462000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x141850; return;
    }
    // 0x141818: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x14181c: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x141820: 0x14400007
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_141840(rdram, ctx, runtime); return;
    }
    // 0x141828: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x14182c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x141830: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x141834: 0x24842c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    // 0x141838: 0xc05bb0e
    SET_GPR_U32(ctx, 31, 0x141840);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    TriggerJoyRumbleRumk__FP3JOY4RUMKf(rdram, ctx, runtime); return;
}


// Function: entry_141840
// Address: 0x141840 - 0x141848

void entry_141840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141840: 0xc05061c
    SET_GPR_U32(ctx, 31, 0x141848);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    TriggerChkpnt__FP6CHKPNT(rdram, ctx, runtime); return;
}


// Function: entry_141848
// Address: 0x141848 - 0x141858

void entry_141848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141848) {
        switch (ctx->pc) {
            case 0x141850: ctx->pc = 0; goto label_141850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141848: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_141858(rdram, ctx, runtime); return;
    }
label_141850:
    // 0x141850: 0xc06f0c8
    SET_GPR_U32(ctx, 31, 0x141858);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FAbsorbSoWkr__FP2SOP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_141858
// Address: 0x141858 - 0x141870

void entry_141858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141858: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14185c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141860: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141864: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14186c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141870; return;
}


// Function: TriggerChkpnt__FP6CHKPNT
// Address: 0x141870 - 0x14189c

void entry_14189c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14189c: 0x8e0205ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1452)));
    // 0x1418a0: 0x10400007
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1418C0; return;
    }
    // 0x1418a8: 0x8e0505b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
    // 0x1418ac: 0x26441420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5152));
    // 0x1418b0: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1418b8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1352));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1418b8
// Address: 0x1418b8 - 0x1418d0

void entry_1418b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1418b8) {
        switch (ctx->pc) {
            case 0x1418c0: ctx->pc = 0; goto label_1418c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1418b8: 0x24030549
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1353));
    // 0x1418bc: 0x62980b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 3));
label_1418c0:
    // 0x1418c0: 0x8e0505b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
    // 0x1418c4: 0x26441420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5152));
    // 0x1418c8: 0xc050410
    SET_GPR_U32(ctx, 31, 0x1418d0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1418d0
// Address: 0x1418d0 - 0x1418dc

void entry_1418d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1418d0: 0x8e0405a4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1444)));
    // 0x1418d4: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1418dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1418dc
// Address: 0x1418dc - 0x141924

void entry_1418dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1418dc) {
        switch (ctx->pc) {
            case 0x1418f0: ctx->pc = 0; goto label_1418f0;
            case 0x1418f8: ctx->pc = 0; goto label_1418f8;
            case 0x141904: ctx->pc = 0; goto label_141904;
            case 0x141910: ctx->pc = 0; goto label_141910;
            case 0x141914: ctx->pc = 0; goto label_141914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1418dc: 0x5040000d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
        goto label_141914;
    }
    // 0x1418e4: 0x12000007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_141904;
    }
    // 0x1418ec: 0x8c620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
label_1418f0:
    // 0x1418f0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4)));
        goto label_1418f8;
    }
label_1418f8:
    // 0x1418f8: 0x8c630018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1418fc: 0x5460fffc
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
        goto label_1418f0;
    }
label_141904:
    // 0x141904: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x141908: 0x52220001
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_141910;
    }
label_141910:
    // 0x141910: 0x8e0505a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
label_141914:
    // 0x141914: 0x26441420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5152));
    // 0x141918: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14191c: 0xc050384
    SET_GPR_U32(ctx, 31, 0x141924);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1(rdram, ctx, runtime); return;
}


// Function: entry_141924
// Address: 0x141924 - 0x14195c

void entry_141924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141924) {
        switch (ctx->pc) {
            case 0x141938: ctx->pc = 0; goto label_141938;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141924: 0x8e020564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x141928: 0x18400010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1384));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14196C; return;
    }
    // 0x141930: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x141934: 0x0
    // NOP
label_141938:
    // 0x141938: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14193c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x141940: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x141944: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x141948: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14194c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x141950: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x141954: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x14195c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_14195c
// Address: 0x14195c - 0x141980

void entry_14195c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14195c) {
        switch (ctx->pc) {
            case 0x14196c: ctx->pc = 0; goto label_14196c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14195c: 0x8e020564
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x141960: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x141964: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x141938; return;
    }
label_14196c:
    // 0x14196c: 0x8e0405ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1452)));
    // 0x141970: 0x10800004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141984; return;
    }
    // 0x141978: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x141980);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_141980
// Address: 0x141980 - 0x1419a0

void entry_141980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141980) {
        switch (ctx->pc) {
            case 0x141984: ctx->pc = 0; goto label_141984;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141980: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_141984:
    // 0x141984: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x141988: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14198c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141990: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141994: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14199c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1419a0; return;
}


// Function: FUN_001419A0
// Address: 0x1419a0 - 0x1419c0

void FUN_001419A0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1419a0: 0x8c830578
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1400)));
    // 0x1419a4: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1419a8: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1419ac: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1419b0: 0xac45057c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1404), GPR_U32(ctx, 5));
    // 0x1419b4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1400), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1419bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1419c0; return;
}


// Function: FUN_001419C0
// Address: 0x1419c0 - 0x1419e0

void FUN_001419C0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1419c0: 0x8c830550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1360)));
    // 0x1419c4: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1419c8: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1419cc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1419d0: 0xac450554
    WRITE32(ADD32(GPR_U32(ctx, 2), 1364), GPR_U32(ctx, 5));
    // 0x1419d4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1360), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1419dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1419e0; return;
}


// Function: FUN_001419E0
// Address: 0x1419e0 - 0x1419e8

void FUN_001419E0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1419e0: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1440), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG
// Address: 0x1419e8 - 0x141a70

void entry_141a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141a70) {
        switch (ctx->pc) {
            case 0x141a94: ctx->pc = 0; goto label_141a94;
            case 0x141a98: ctx->pc = 0; goto label_141a98;
            case 0x141ad4: ctx->pc = 0; goto label_141ad4;
            case 0x141af8: ctx->pc = 0; goto label_141af8;
            case 0x141afc: ctx->pc = 0; goto label_141afc;
            case 0x141b08: ctx->pc = 0; goto label_141b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141a70: 0x18400008
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_141a94;
    }
    // 0x141a78: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x141a7c: 0x46150032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x141a80: 0x0
    // NOP
    // 0x141a84: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
        goto label_141a98;
    }
    // 0x141a8c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x141a90: 0x15180a
    if (GPR_U32(ctx, 21) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
label_141a94:
    // 0x141a94: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
label_141a98:
    // 0x141a98: 0x10400017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_141af8;
    }
    // 0x141aa0: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x141aa4: 0x642018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x141aa8: 0x9d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
    // 0x141aac: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x141ab0: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x141ab4: 0x0
    // NOP
    // 0x141ab8: 0x45020010
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
        goto label_141afc;
    }
    // 0x141ac0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x141ac4: 0x1240000c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_141af8;
    }
    // 0x141acc: 0x240182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x141ad0: 0x24440060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 96));
label_141ad4:
    // 0x141ad4: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x141ad8: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x141adc: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x141ae0: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x141ae4: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x141ae8: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_141ad4;
    }
    // 0x141af0: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x141af4: 0x7c640000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 4));
label_141af8:
    // 0x141af8: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_141afc:
    // 0x141afc: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x141b00: 0x1440ffd3
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141A50; return;
    }
label_141b08:
    // 0x141b08: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x141b0c: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x141b10: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x141b14: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x141b18: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x141b1c: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x141b20: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x141b24: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x141b28: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x141b2c: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x141b30: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x141b34: 0xc7b50188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[21] = *(float*)&val; }
    // 0x141b38: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x141b3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x141b44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141b48; return;
}


// Function: FUN_00141b48
// Address: 0x141b48 - 0x141bcc

void FUN_00141b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141b48) {
        switch (ctx->pc) {
            case 0x141ba0: ctx->pc = 0; goto label_141ba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141b48: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x141b4c: 0x7fb60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 22));
    // 0x141b50: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x141b54: 0x80b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x141b58: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x141b5c: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x141b60: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x141b64: 0x100a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x141b68: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x141b6c: 0x120982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x141b70: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x141b74: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x141b78: 0x7fbe0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 30));
    // 0x141b7c: 0x7fb70070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 23));
    // 0x141b80: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x141b84: 0x18c0001b
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    if (GPR_S32(ctx, 6) <= 0) {
        ctx->pc = 0x141BF4; return;
    }
    // 0x141b8c: 0xe0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x141b90: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x141b94: 0x341ec000
    SET_GPR_U32(ctx, 30, OR32(GPR_U32(ctx, 0), 49152));
    // 0x141b98: 0x1ef738
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 30) << 28);
    // 0x141b9c: 0x24170070
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 112));
label_141ba0:
    // 0x141ba0: 0x8e440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x141ba4: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x141ba8: 0x5e1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x141bac: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x141BEC; return;
    }
    // 0x141bb4: 0x2171018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x141bb8: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x141bbc: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x141bc0: 0x2903823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x141bc4: 0xc05070a
    SET_GPR_U32(ctx, 31, 0x141bcc);
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    ClsgClipEdgeToObject__FP2SOP6VECTORT1iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_141bcc
// Address: 0x141bcc - 0x141be4

void entry_141bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x141bcc: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x141BEC; return;
    }
    // 0x141bd4: 0x12000003
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_141be4(rdram, ctx, runtime); return;
    }
    // 0x141bdc: 0xc050a7e
    SET_GPR_U32(ctx, 31, 0x141be4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ClsgMergeAlsg__FiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_141be4
// Address: 0x141be4 - 0x141c28

void entry_141be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141be4) {
        switch (ctx->pc) {
            case 0x141bec: ctx->pc = 0; goto label_141bec;
            case 0x141bf4: ctx->pc = 0; goto label_141bf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141be4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x141be8: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_141bec:
    // 0x141bec: 0x1620ffec
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x141BA0; return;
    }
label_141bf4:
    // 0x141bf4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x141bf8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x141bfc: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x141c00: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x141c04: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x141c08: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x141c0c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x141c10: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x141c14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x141c18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x141c1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x141c20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClsgClipEdgeToObject__FP2SOP6VECTORT1iP3LSG
// Address: 0x141c28 - 0x141c4c

void entry_141c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141c4c) {
        switch (ctx->pc) {
            case 0x141c54: ctx->pc = 0; goto label_141c54;
            case 0x141c74: ctx->pc = 0; goto label_141c74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141c4c: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141C84; return;
    }
label_141c54:
    // 0x141c54: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x141c58: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x141c5c: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x141c60: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x141c64: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[12] = *(float*)&val; }
        goto label_141c74;
    }
    // 0x141c6c: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_141c80(rdram, ctx, runtime); return;
    }
label_141c74:
    // 0x141c74: 0x120402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x141c78: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x141c80);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_141c80
// Address: 0x141c80 - 0x141c90

void entry_141c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141c80) {
        switch (ctx->pc) {
            case 0x141c84: ctx->pc = 0; goto label_141c84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141c80: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_141c84:
    // 0x141c84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x141c8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141c90; return;
}


// Function: ClsgClipEdgeToObjectPruned__FP2SOP3BSPP6VECTORT2iP3LSG
// Address: 0x141c90 - 0x141cb0

void entry_141cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141cb0) {
        switch (ctx->pc) {
            case 0x141cb8: ctx->pc = 0; goto label_141cb8;
            case 0x141cd8: ctx->pc = 0; goto label_141cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141cb0: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141CF4; return;
    }
label_141cb8:
    // 0x141cb8: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x141cbc: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x141cc0: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x141cc4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x141cc8: 0x14400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_141cd8;
    }
    // 0x141cd0: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_141cf0(rdram, ctx, runtime); return;
    }
label_141cd8:
    // 0x141cd8: 0xc48c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[12] = *(float*)&val; }
    // 0x141cdc: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x141ce0: 0x24840140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    // 0x141ce4: 0x100382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x141ce8: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x141cf0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_141cf0
// Address: 0x141cf0 - 0x141d00

void entry_141cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141cf0) {
        switch (ctx->pc) {
            case 0x141cf4: ctx->pc = 0; goto label_141cf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141cf0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_141cf4:
    // 0x141cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x141cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x141d00; return;
}


// Function: ClsgClipCylinderToObject__FP2SOP6VECTORT1fiP3LSG
// Address: 0x141d00 - 0x141d3c

void entry_141d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141d3c) {
        switch (ctx->pc) {
            case 0x141d44: ctx->pc = 0; goto label_141d44;
            case 0x141d64: ctx->pc = 0; goto label_141d64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141d3c: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x141D80; return;
    }
label_141d44:
    // 0x141d44: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x141d48: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x141d4c: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x141d50: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x141d54: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[12] = *(float*)&val; }
        goto label_141d64;
    }
    // 0x141d5c: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_141d7c(rdram, ctx, runtime); return;
    }
label_141d64:
    // 0x141d64: 0x140282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x141d68: 0x160302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x141d6c: 0x180382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    // 0x141d70: 0x120402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x141d74: 0xc05085c
    SET_GPR_U32(ctx, 31, 0x141d7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    ClsgClipCylinderToSphere__FP6VECTORfT0T0fiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_141d7c
// Address: 0x141d7c - 0x141d88

void entry_141d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x141d7c) {
        switch (ctx->pc) {
            case 0x141d80: ctx->pc = 0; goto label_141d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x141d7c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_141d80:
    // 0x141d80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG
// Address: 0x141d88 - 0x141f48

void entry_1421bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1421bc: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1421c0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1421c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1421c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1421cc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1421d0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1421d4: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1421d8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1421dc: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1421e0: 0xda240000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1421e4: 0xda030000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1421e8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1421ec: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1421f0: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1421f4: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1421f8: 0x4be520c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1421fc: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x142200: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142204: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x142208: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14220c: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x142214);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_142214
// Address: 0x142214 - 0x14224c

void entry_142214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142214: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x142218: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14221c: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x142220: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x142224: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x142228: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14222c: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x142230: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142234: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x142238: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14223c: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x142240: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x142244: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x14224c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_14224c
// Address: 0x14224c - 0x142278

void entry_14224c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14224c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x142250: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x142254: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x142258: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14225c: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x142260: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x142264: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x142268: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x14226c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x142274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x142278; return;
}


// Function: ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG
// Address: 0x142278 - 0x1428e0

void entry_1428e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1428e0) {
        switch (ctx->pc) {
            case 0x142930: ctx->pc = 0; goto label_142930;
            case 0x14293c: ctx->pc = 0; goto label_14293c;
            case 0x142940: ctx->pc = 0; goto label_142940;
            case 0x14295c: ctx->pc = 0; goto label_14295c;
            case 0x142960: ctx->pc = 0; goto label_142960;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1428e0: 0xda030000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1428e4: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1428e8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1428ec: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1428f0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1428f4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1428f8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1428fc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x142900: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x142904: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142908: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14290c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x142910: 0x7bc20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x142914: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x142918: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x14291c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x142920: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_142930;
    }
    // 0x142928: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14293c;
    }
label_142930:
    // 0x142930: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x142934: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x142938: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14293c:
    // 0x14293c: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_142940:
    // 0x142940: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x142944: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x142948: 0x661ffbf
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x142848; return;
    }
    // 0x142950: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x142954: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x142958: 0xae230048
    WRITE32(ADD32(GPR_U32(ctx, 17), 72), GPR_U32(ctx, 3));
label_14295c:
    // 0x14295c: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_142960:
    // 0x142960: 0x7bbe0100
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x142964: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x142968: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x14296c: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x142970: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x142974: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x142978: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14297c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x142980: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x142984: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x142988: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00142990
// Address: 0x142990 - 0x142998

void entry_142a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142a1c: 0x24040060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 96));
    // 0x142a20: 0xc063596
    SET_GPR_U32(ctx, 31, 0x142a28);
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_142a28
// Address: 0x142a28 - 0x142ab8

void entry_142a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142a28) {
        switch (ctx->pc) {
            case 0x142a48: ctx->pc = 0; goto label_142a48;
            case 0x142a58: ctx->pc = 0; goto label_142a58;
            case 0x142a9c: ctx->pc = 0; goto label_142a9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142a28: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x142a2c: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x142a30: 0x1a20001a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_142a9c;
    }
    // 0x142a38: 0x240a0070
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 112));
    // 0x142a3c: 0x26490040
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 64));
    // 0x142a40: 0x6a1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 10); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142a44: 0x0
    // NOP
label_142a48:
    // 0x142a48: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x142a4c: 0x24680001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 1));
    // 0x142a50: 0x493021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x142a54: 0x522821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
label_142a58:
    // 0x142a58: 0xae070004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 7));
    // 0x142a5c: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x142a60: 0xc4c00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 0)); ctx->f[0] = *(float*)&val; }
    // 0x142a64: 0x28e40002
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 7), 2));
    // 0x142a68: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x142a6c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x142a70: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x142a74: 0x7e020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 2));
    // 0x142a78: 0x78a30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x142a7c: 0x24a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    // 0x142a80: 0x7e030020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 3));
    // 0x142a84: 0x1480fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_142a58;
    }
    // 0x142a8c: 0x100182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x142a90: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x142a94: 0x1440ffec
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 10); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_142a48;
    }
label_142a9c:
    // 0x142a9c: 0x3c070014
    SET_GPR_U32(ctx, 7, ((uint32_t)20 << 16));
    // 0x142aa0: 0x112840
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 1));
    // 0x142aa4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x142aa8: 0x24e72998
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 10648));
    // 0x142aac: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x142ab0: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x142ab8);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_142ab8
// Address: 0x142ab8 - 0x142b48

void entry_142ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142ab8) {
        switch (ctx->pc) {
            case 0x142ad8: ctx->pc = 0; goto label_142ad8;
            case 0x142b0c: ctx->pc = 0; goto label_142b0c;
            case 0x142b30: ctx->pc = 0; goto label_142b30;
            case 0x142b34: ctx->pc = 0; goto label_142b34;
            case 0x142b40: ctx->pc = 0; goto label_142b40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142ab8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x142abc: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x142ac0: 0x205102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 5)));
    // 0x142ac4: 0x1040001e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_142b40;
    }
    // 0x142acc: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x142ad0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x142ad4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_142ad8:
    // 0x142ad8: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
        goto label_142b0c;
    }
    // 0x142ae0: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x142ae4: 0x54870013
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 7)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
        goto label_142b34;
    }
    // 0x142aec: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x142af0: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x142af4: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x142af8: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x142afc: 0x7a030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x142b00: 0xae260048
    WRITE32(ADD32(GPR_U32(ctx, 17), 72), GPR_U32(ctx, 6));
    // 0x142b04: 0x1000000a
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_142b30;
    }
label_142b0c:
    // 0x142b0c: 0x54800009
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
        goto label_142b34;
    }
    // 0x142b14: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x142b18: 0xe6200044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    // 0x142b1c: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x142b20: 0x7e220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 2));
    // 0x142b24: 0x7a030020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x142b28: 0x7e230030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 3));
    // 0x142b2c: 0x26310070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 112));
label_142b30:
    // 0x142b30: 0x26100030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
label_142b34:
    // 0x142b34: 0x205102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 5)));
    // 0x142b38: 0x5440ffe7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_142ad8;
    }
label_142b40:
    // 0x142b40: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x142b48);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_142b48
// Address: 0x142b48 - 0x142b78

void entry_142b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142b48: 0x3c03b6db
    SET_GPR_U32(ctx, 3, ((uint32_t)46811 << 16));
    // 0x142b4c: 0x2321023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
    // 0x142b50: 0x34636db7
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 28087));
    // 0x142b54: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x142b58: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142b5c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x142b60: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x142b64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x142b68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x142b6c: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x142b70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClsgClipCylinderToBsp__FP4BSPCP4GEOMP6VECTORT2fiP3LSG
// Address: 0x142b78 - 0x142be0

void entry_142be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142be0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x142be4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x142be8: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x142bec: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x142bf0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x142bf4: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x142bf8: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x142bfc: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142c00: 0x4405a800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[21]);
    // 0x142c04: 0xd8640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x142c08: 0x48a51800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x142c0c: 0x4be4106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x142c10: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x142c14: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142c18: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x142c1c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142c20: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x142c24: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x142c28: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x142c2c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x142c30: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x142c34: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x142c38: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x142c3c: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x142c40: 0x4485a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 5);
    // 0x142c44: 0xc063596
    SET_GPR_U32(ctx, 31, 0x142c4c);
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_142c4c
// Address: 0x142c4c - 0x142c6c

void entry_142c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142c4c: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x142c50: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x142c54: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x142c58: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x142c5c: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x142c60: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x142c64: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x142c6c);
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_142c6c
// Address: 0x142c6c - 0x142cac

void entry_142c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142c6c) {
        switch (ctx->pc) {
            case 0x142c94: ctx->pc = 0; goto label_142c94;
            case 0x142c9c: ctx->pc = 0; goto label_142c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142c6c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x142c70: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x142c74: 0x10620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_142c94;
    }
    // 0x142c7c: 0x10400015
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142CD4; return;
    }
    // 0x142c84: 0x50600005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
        goto label_142c9c;
    }
    // 0x142c8c: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142CD4; return;
    }
label_142c94:
    // 0x142c94: 0x10000079
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142E7C; return;
    }
label_142c9c:
    // 0x142c9c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x142ca0: 0x24060070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 112));
    // 0x142ca4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x142cac);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_142cac
// Address: 0x142cac - 0x142d04

void entry_142cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142cac) {
        switch (ctx->pc) {
            case 0x142cd4: ctx->pc = 0; goto label_142cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142cac: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x142cb0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x142cb4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x142cb8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x142cbc: 0x7ea30000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 3));
    // 0x142cc0: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x142cc4: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x142cc8: 0xe6a00044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 68), *(uint32_t*)&val); }
    // 0x142ccc: 0x1000006b
    WRITE128(ADD32(GPR_U32(ctx, 21), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142E7C; return;
    }
label_142cd4:
    // 0x142cd4: 0x3c02aaaa
    SET_GPR_U32(ctx, 2, ((uint32_t)43690 << 16));
    // 0x142cd8: 0x3442aaab
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 43691));
    // 0x142cdc: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x142ce0: 0x971823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 23)));
    // 0x142ce4: 0x8fa60028
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x142ce8: 0x621818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142cec: 0x8fa8002c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x142cf0: 0x2484fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967284));
    // 0x142cf4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x142cf8: 0x2a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x142cfc: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x142d04);
    SET_GPR_S32(ctx, 20, SRA32(GPR_S32(ctx, 3), 2));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_142d04
// Address: 0x142d04 - 0x142dd4

void entry_142d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142d04) {
        switch (ctx->pc) {
            case 0x142d18: ctx->pc = 0; goto label_142d18;
            case 0x142d34: ctx->pc = 0; goto label_142d34;
            case 0x142d40: ctx->pc = 0; goto label_142d40;
            case 0x142d78: ctx->pc = 0; goto label_142d78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142d04: 0x1a80000b
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_142d34;
    }
    // 0x142d0c: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x142d10: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x142d14: 0x0
    // NOP
label_142d18:
    // 0x142d18: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x142d1c: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x142d20: 0x24a5000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    // 0x142d24: 0x9462001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x142d28: 0x34420100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 256));
    // 0x142d2c: 0x1480fffa
    WRITE16(ADD32(GPR_U32(ctx, 3), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_142d18;
    }
label_142d34:
    // 0x142d34: 0x1a800046
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x142E50; return;
    }
    // 0x142d3c: 0x2403000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
label_142d40:
    // 0x142d40: 0x24960001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 4), 1));
    // 0x142d44: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142d48: 0x771021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x142d4c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x142d50: 0x9464001c
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x142d54: 0x30820200
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 512));
    // 0x142d58: 0x5440003a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
        ctx->pc = 0x142E44; return;
    }
    // 0x142d60: 0x34820200
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 4), 512));
    // 0x142d64: 0x8c700014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x142d68: 0x12000035
    WRITE16(ADD32(GPR_U32(ctx, 3), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142E40; return;
    }
    // 0x142d70: 0x86020006
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 6)));
    // 0x142d74: 0x0
    // NOP
label_142d78:
    // 0x142d78: 0x8fc40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 16)));
    // 0x142d7c: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x142d80: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x142d84: 0x9483001c
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x142d88: 0x30630100
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 256));
    // 0x142d8c: 0x10600029
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142E34; return;
    }
    // 0x142d94: 0x86060000
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x142d98: 0x2721018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142d9c: 0x86070002
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x142da0: 0x8fa3002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x142da4: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x142da8: 0x73900
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 7), 4));
    // 0x142dac: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x142db0: 0x8fa50028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x142db4: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x142db8: 0x558821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x142dbc: 0x734023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x142dc0: 0x8fc20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 8)));
    // 0x142dc4: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x142dc8: 0x473821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x142dcc: 0xc05089e
    SET_GPR_U32(ctx, 31, 0x142dd4);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_142dd4
// Address: 0x142dd4 - 0x142e30

void entry_142dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142dd4) {
        switch (ctx->pc) {
            case 0x142df8: ctx->pc = 0; goto label_142df8;
            case 0x142e18: ctx->pc = 0; goto label_142e18;
            case 0x142e28: ctx->pc = 0; goto label_142e28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142dd4: 0x18400017
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x142E34; return;
    }
    // 0x142ddc: 0x522818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x142de0: 0x2622021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x142de4: 0xa91821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x142de8: 0x123102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x142dec: 0x1040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_142e28;
    }
    // 0x142df4: 0xc5210050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 80)); ctx->f[1] = *(float*)&val; }
label_142df8:
    // 0x142df8: 0xc5200054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 84)); ctx->f[0] = *(float*)&val; }
    // 0x142dfc: 0xe5210040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 9), 64), *(uint32_t*)&val); }
    // 0x142e00: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x142e04: 0x0
    // NOP
    // 0x142e08: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 9), 68), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_142e18;
    }
    // 0x142e10: 0xe5200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 9), 64), *(uint32_t*)&val); }
    // 0x142e14: 0xe5210044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 9), 68), *(uint32_t*)&val); }
label_142e18:
    // 0x142e18: 0x25290070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 112));
    // 0x142e1c: 0x123102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x142e20: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 80)); ctx->f[1] = *(float*)&val; }
        goto label_142df8;
    }
label_142e28:
    // 0x142e28: 0xc050a7e
    SET_GPR_U32(ctx, 31, 0x142e30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ClsgMergeAlsg__FiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_142e30
// Address: 0x142e30 - 0x142e84

void entry_142e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142e30) {
        switch (ctx->pc) {
            case 0x142e34: ctx->pc = 0; goto label_142e34;
            case 0x142e40: ctx->pc = 0; goto label_142e40;
            case 0x142e44: ctx->pc = 0; goto label_142e44;
            case 0x142e50: ctx->pc = 0; goto label_142e50;
            case 0x142e60: ctx->pc = 0; goto label_142e60;
            case 0x142e7c: ctx->pc = 0; goto label_142e7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142e30: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_142e34:
    // 0x142e34: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x142e38: 0x5600ffcf
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 6)));
        ctx->pc = 0x142D78; return;
    }
label_142e40:
    // 0x142e40: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_142e44:
    // 0x142e44: 0x94102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 20)));
    // 0x142e48: 0x1440ffbd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x142D40; return;
    }
label_142e50:
    // 0x142e50: 0x1a80000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_142e7c;
    }
    // 0x142e58: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x142e5c: 0x0
    // NOP
label_142e60:
    // 0x142e60: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x142e64: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x142e68: 0x24a5000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    // 0x142e6c: 0x9462001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x142e70: 0x3042fcff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64767));
    // 0x142e74: 0x1480fffa
    WRITE16(ADD32(GPR_U32(ctx, 3), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_142e60;
    }
label_142e7c:
    // 0x142e7c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x142e84);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_142e84
// Address: 0x142e84 - 0x142ec8

void entry_142e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142e84) {
        switch (ctx->pc) {
            case 0x142e88: ctx->pc = 0; goto label_142e88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142e84: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_142e88:
    // 0x142e88: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x142e8c: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x142e90: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x142e94: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x142e98: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x142e9c: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x142ea0: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x142ea4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x142ea8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x142eac: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x142eb0: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x142eb4: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x142eb8: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x142ebc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x142ec4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x142ec8; return;
}


// Function: junk_00142EC8
// Address: 0x142ec8 - 0x142ed0

void entry_142f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142f04: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x142f08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MarkClockTick__FP5CLOCK
// Address: 0x142f10 - 0x142f28

void entry_142f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x142f28: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x142f2c: 0xde020018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x142f30: 0x222202f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) - GPR_U64(ctx, 2));
    // 0x142f34: 0x4800005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) >> 1);
    if (GPR_S32(ctx, 4) < 0) {
        ctx->pc = 0x142F4C; return;
    }
    // 0x142f3c: 0xc07edac
    SET_GPR_U32(ctx, 31, 0x142f44);
    fn___floatdisf(rdram, ctx, runtime); return;
}


// Function: entry_142f44
// Address: 0x142f44 - 0x142f58

void entry_142f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142f44) {
        switch (ctx->pc) {
            case 0x142f4c: ctx->pc = 0; goto label_142f4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142f44: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x142F5C; return;
    }
label_142f4c:
    // 0x142f4c: 0x30840001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 1));
    // 0x142f50: 0xc07edac
    SET_GPR_U32(ctx, 31, 0x142f58);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    fn___floatdisf(rdram, ctx, runtime); return;
}


// Function: entry_142f58
// Address: 0x142f58 - 0x143030

void entry_142f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x142f58) {
        switch (ctx->pc) {
            case 0x142f5c: ctx->pc = 0; goto label_142f5c;
            case 0x142f98: ctx->pc = 0; goto label_142f98;
            case 0x142fa8: ctx->pc = 0; goto label_142fa8;
            case 0x142fbc: ctx->pc = 0; goto label_142fbc;
            case 0x142ff0: ctx->pc = 0; goto label_142ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x142f58: 0x46000040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
label_142f5c:
    // 0x142f5c: 0x3c013169
    SET_GPR_U32(ctx, 1, ((uint32_t)12649 << 16));
    // 0x142f60: 0x34210453
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 1107));
    // 0x142f64: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x142f68: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x142f6c: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x142f70: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x142f74: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x142f78: 0x3c013d08
    SET_GPR_U32(ctx, 1, ((uint32_t)15624 << 16));
    // 0x142f7c: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x142f80: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x142f84: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x142f88: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_142f98;
    }
    // 0x142f90: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_142fa8;
    }
label_142f98:
    // 0x142f98: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x142f9c: 0x0
    // NOP
    // 0x142fa0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_142fa8;
    }
label_142fa8:
    // 0x142fa8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x142fac: 0x44802000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 0);
    // 0x142fb0: 0x10400002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_142fbc;
    }
    // 0x142fb8: 0x46000106
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
label_142fbc:
    // 0x142fbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x142fc0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x142fc4: 0xc4401854
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6228)); ctx->f[0] = *(float*)&val; }
    // 0x142fc8: 0xc4611850
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6224)); ctx->f[1] = *(float*)&val; }
    // 0x142fcc: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x142fd0: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x142fd4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x142fd8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x142fdc: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x142fe0: 0x46041036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x142fe4: 0x0
    // NOP
    // 0x142fe8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
        goto label_142ff0;
    }
label_142ff0:
    // 0x142ff0: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x142ff4: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x142ff8: 0xc6020014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[2] = *(float*)&val; }
    // 0x142ffc: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x143000: 0xc6030008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[3] = *(float*)&val; }
    // 0x143004: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x143008: 0xfe110018
    WRITE64(ADD32(GPR_U32(ctx, 16), 24), GPR_U64(ctx, 17));
    // 0x14300c: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x143010: 0xe603000c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x143014: 0xe6040008
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x143018: 0xe6010010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x14301c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x143020: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143024: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143028: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MarkClockTickRealOnly__FP5CLOCK
// Address: 0x143030 - 0x143048

void entry_143048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143048: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14304c: 0xde020018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x143050: 0x222202f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) - GPR_U64(ctx, 2));
    // 0x143054: 0x4800005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) >> 1);
    if (GPR_S32(ctx, 4) < 0) {
        ctx->pc = 0x14306C; return;
    }
    // 0x14305c: 0xc07edac
    SET_GPR_U32(ctx, 31, 0x143064);
    fn___floatdisf(rdram, ctx, runtime); return;
}


// Function: entry_143064
// Address: 0x143064 - 0x143078

void entry_143064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143064) {
        switch (ctx->pc) {
            case 0x14306c: ctx->pc = 0; goto label_14306c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143064: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14307C; return;
    }
label_14306c:
    // 0x14306c: 0x30840001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 1));
    // 0x143070: 0xc07edac
    SET_GPR_U32(ctx, 31, 0x143078);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    fn___floatdisf(rdram, ctx, runtime); return;
}


// Function: entry_143078
// Address: 0x143078 - 0x1430b8

void entry_143078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143078) {
        switch (ctx->pc) {
            case 0x14307c: ctx->pc = 0; goto label_14307c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143078: 0x46000080
    ctx->f[2] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
label_14307c:
    // 0x14307c: 0x3c013169
    SET_GPR_U32(ctx, 1, ((uint32_t)12649 << 16));
    // 0x143080: 0x34210453
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 1107));
    // 0x143084: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x143088: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x14308c: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x143090: 0xfe110018
    WRITE64(ADD32(GPR_U32(ctx, 16), 24), GPR_U64(ctx, 17));
    // 0x143094: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x143098: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14309c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1430a0: 0xe6000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1430a4: 0xe6010010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x1430a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1430ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1430b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1430b8; return;
}


// Function: ResetClock__FP5CLOCKf
// Address: 0x1430b8 - 0x1430c0

void entry_1430e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1430e0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1430e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1430e8: 0xfc621870
    WRITE64(ADD32(GPR_U32(ctx, 3), 6256), GPR_U64(ctx, 2));
    // 0x1430ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1430f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1430f8; return;
}


// Function: TickNow__Fv
// Address: 0x1430f8 - 0x143140

void entry_143174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143174: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR
// Address: 0x143180 - 0x143208

void entry_143240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143240) {
        switch (ctx->pc) {
            case 0x143278: ctx->pc = 0; goto label_143278;
            case 0x143288: ctx->pc = 0; goto label_143288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143240: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x143244: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x143248: 0x16230044
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x14335C; return;
    }
    // 0x143250: 0x8e25268c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9868)));
    // 0x143254: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x143258: 0x10a20020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1432DC; return;
    }
    // 0x143260: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_143278;
    }
    // 0x143268: 0x10a00007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_143288;
    }
    // 0x143270: 0x1000004f
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1433B0; return;
    }
label_143278:
    // 0x143278: 0x10a2002d
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x143330; return;
    }
    // 0x143280: 0x1000004b
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1433B0; return;
    }
label_143288:
    // 0x143288: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x14328c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x143290: 0x3c01c060
    SET_GPR_U32(ctx, 1, ((uint32_t)49248 << 16));
    // 0x143294: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x143298: 0x26050250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 592));
    // 0x14329c: 0x26060260
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 608));
    // 0x1432a0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1432a4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1432a8: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x1432b0);
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1432b0
// Address: 0x1432b0 - 0x1432d4

void entry_1432b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1432b0: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1432b4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1432b8: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1432bc: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1432c0: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1432c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1432c8: 0x26050270
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 624));
    // 0x1432cc: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x1432d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 640));
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1432d4
// Address: 0x1432d4 - 0x143308

void entry_1432d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1432d4) {
        switch (ctx->pc) {
            case 0x1432dc: ctx->pc = 0; goto label_1432dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1432d4: 0x10000036
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1433B0; return;
    }
label_1432dc:
    // 0x1432dc: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x1432e0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1432e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1432e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1432ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1432f0: 0x26050250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 592));
    // 0x1432f4: 0x26060260
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 608));
    // 0x1432f8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1432fc: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x143300: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x143308);
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_143308
// Address: 0x143308 - 0x143328

void entry_143308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143308: 0x26050270
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 624));
    // 0x14330c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x143310: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x143314: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x143318: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14331c: 0x26060280
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 640));
    // 0x143320: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x143328);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_143328
// Address: 0x143328 - 0x143354

void entry_143328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143328) {
        switch (ctx->pc) {
            case 0x143330: ctx->pc = 0; goto label_143330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143328: 0x10000021
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1433B0; return;
    }
label_143330:
    // 0x143330: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x143334: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x143338: 0x3c01c060
    SET_GPR_U32(ctx, 1, ((uint32_t)49248 << 16));
    // 0x14333c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x143340: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143344: 0x26050250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 592));
    // 0x143348: 0x26060260
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 608));
    // 0x14334c: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x143354);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_143354
// Address: 0x143354 - 0x143388

void entry_143354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143354) {
        switch (ctx->pc) {
            case 0x14335c: ctx->pc = 0; goto label_14335c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143354: 0x10000016
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1433B0; return;
    }
label_14335c:
    // 0x14335c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x143360: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x143364: 0x3c01c060
    SET_GPR_U32(ctx, 1, ((uint32_t)49248 << 16));
    // 0x143368: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x14336c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143370: 0x26050250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 592));
    // 0x143374: 0x26060260
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 608));
    // 0x143378: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x14337c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x143380: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x143388);
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_143388
// Address: 0x143388 - 0x1433ac

void entry_143388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143388: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x14338c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x143390: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x143394: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x143398: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x14339c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1433a0: 0x26050270
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 624));
    // 0x1433a4: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x1433ac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 640));
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1433ac
// Address: 0x1433ac - 0x1433e0

void entry_1433ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1433ac) {
        switch (ctx->pc) {
            case 0x1433b0: ctx->pc = 0; goto label_1433b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1433ac: 0xda020250
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 592)));
label_1433b0:
    // 0x1433b0: 0xda410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1433b4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1433b8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1433bc: 0xfa410040
    WRITE128(ADD32(GPR_U32(ctx, 18), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1433c0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1433c4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1433c8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1433cc: 0xc7b60060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[22] = *(float*)&val; }
    // 0x1433d0: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x1433d4: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1433d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResetCmAdjust__FP2CMP2SOP6CPDEFI
// Address: 0x1433e0 - 0x1433f8

void entry_1433f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1433f8: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1433fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143400: 0xfa010280
    WRITE128(ADD32(GPR_U32(ctx, 16), 640), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x143404: 0xfa010260
    WRITE128(ADD32(GPR_U32(ctx, 16), 608), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x143408: 0xfa010270
    WRITE128(ADD32(GPR_U32(ctx, 16), 624), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14340c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetCmCpdefi__FP2CMP2SOfP6CPDEFI
// Address: 0x143418 - 0x143488

void entry_143488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143488: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14348c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143490: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x143494: 0xc050c52
    SET_GPR_U32(ctx, 31, 0x14349c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CalcCmAdjust__FP2CMP2SOP6CPDEFIP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14349c
// Address: 0x14349c - 0x1434c8

void entry_14349c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14349c) {
        switch (ctx->pc) {
            case 0x1434ac: ctx->pc = 0; goto label_1434ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14349c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1434a0: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1434a4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1434a8: 0xfa210040
    WRITE128(ADD32(GPR_U32(ctx, 17), 64), _mm_castps_si128(ctx->vu0_vf[1]));
label_1434ac:
    // 0x1434ac: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1434b0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1434b4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1434b8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1434bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1434c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1434c8; return;
}


// Function: BuildCmFgfn__FP2CMfP4FGFN
// Address: 0x1434c8 - 0x14351c

void entry_14351c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14351c: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x143520: 0x3c014b00
    SET_GPR_U32(ctx, 1, ((uint32_t)19200 << 16));
    // 0x143524: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x143528: 0x3c014710
    SET_GPR_U32(ctx, 1, ((uint32_t)18192 << 16));
    // 0x14352c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x143530: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x143534: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x143538: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x14353c: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x143540: 0xc62101f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 504)); ctx->f[1] = *(float*)&val; }
    // 0x143544: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143548: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x14354c: 0xe6010008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x143550: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143554: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14355c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143560; return;
}


// Function: RecalcCmFrustrum__FP2CM
// Address: 0x143560 - 0x143590

void entry_143590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143590: 0xc60201c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 452)); ctx->f[2] = *(float*)&val; }
    // 0x143594: 0xc60c01e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 480)); ctx->f[12] = *(float*)&val; }
    // 0x143598: 0x4602a083
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[2] = ctx->f[20] / ctx->f[2];
    // 0x14359c: 0xc60101c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 448)); ctx->f[1] = *(float*)&val; }
    // 0x1435a0: 0x460c60c2
    ctx->f[3] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
    // 0x1435a4: 0xe60001f4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 500), *(uint32_t*)&val); }
    // 0x1435a8: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x1435ac: 0x461418c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[20]);
    // 0x1435b0: 0xe60c01f0
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 16), 496), *(uint32_t*)&val); }
    // 0x1435b4: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1435b8: 0x4601a068
    ctx->f[1] = std::max(ctx->f[20], ctx->f[1]);
    // 0x1435bc: 0xe60100b0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x1435c0: 0x46030084
    ctx->f[2] = FPU_SQRT_S(ctx->f[0]);
    // 0x1435c4: 0x3c014580
    SET_GPR_U32(ctx, 1, ((uint32_t)17792 << 16));
    // 0x1435c8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1435cc: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1435d0: 0xc60301e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 484)); ctx->f[3] = *(float*)&val; }
    // 0x1435d4: 0x260400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 192));
    // 0x1435d8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1435dc: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1435e0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1435e4: 0x46016302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x1435e8: 0x3c014360
    SET_GPR_U32(ctx, 1, ((uint32_t)17248 << 16));
    // 0x1435ec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1435f0: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1435f4: 0xc61101e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 488)); ctx->f[17] = *(float*)&val; }
    // 0x1435f8: 0x46006b43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
    // 0x1435fc: 0x46001c06
    ctx->f[16] = FPU_MOV_S(ctx->f[3]);
    // 0x143600: 0x460c2303
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[4] * 0.0f); } else ctx->f[12] = ctx->f[4] / ctx->f[12];
    // 0x143604: 0x46141080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[20]);
    // 0x143608: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x14360c: 0xe60201ec
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 492), *(uint32_t*)&val); }
    // 0x143610: 0xc0627d6
    SET_GPR_U32(ctx, 31, 0x143618);
    ctx->f[15] = FPU_MOV_S(ctx->f[14]);
    BuildSimpleProjectionMatrix__FffffffP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_143618
// Address: 0x143618 - 0x143628

void entry_143618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143618: 0x26050208
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 520));
    // 0x14361c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x143620: 0xc050d32
    SET_GPR_U32(ctx, 31, 0x143628);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildCmFgfn__FP2CMfP4FGFN(rdram, ctx, runtime); return;
}


// Function: entry_143628
// Address: 0x143628 - 0x143630

void entry_143628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143628: 0xc051150
    SET_GPR_U32(ctx, 31, 0x143630);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateCmMat4(rdram, ctx, runtime); return;
}


// Function: entry_143630
// Address: 0x143630 - 0x143648

void entry_143630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143630: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143634: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143638: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x14363c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143648; return;
}


// Function: InitCm__FP2CM
// Address: 0x143648 - 0x14365c

void entry_14365c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14365c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x143660: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x143664: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x143668: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x14366c: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x143670: 0xe60001c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 456), *(uint32_t*)&val); }
    // 0x143674: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x143678: 0xe60001c0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 448), *(uint32_t*)&val); }
    // 0x14367c: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x143680: 0xe60001c4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 452), *(uint32_t*)&val); }
    // 0x143684: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x143688: 0x244b18b8
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 2), 6328));
    // 0x14368c: 0x69640007
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x143690: 0x6d640000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x143694: 0x6969000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x143698: 0x6d690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x14369c: 0xb20401d7
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 471); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1436a0: 0xb60401d0
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 464); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1436a4: 0xb20901df
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 479); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1436a8: 0xb60901d8
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 472); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1436ac: 0x24a583d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935504));
    // 0x1436b0: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x1436b4: 0x34213bd8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 15320));
    // 0x1436b8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1436bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1436c0: 0xc46518a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6312)); ctx->f[5] = *(float*)&val; }
    // 0x1436c4: 0xc4c318a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 6304)); ctx->f[3] = *(float*)&val; }
    // 0x1436c8: 0xc4e418a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 6308)); ctx->f[4] = *(float*)&val; }
    // 0x1436cc: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1436d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1436d4: 0x3c01469c
    SET_GPR_U32(ctx, 1, ((uint32_t)18076 << 16));
    // 0x1436d8: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1436dc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1436e0: 0xe60201e0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 480), *(uint32_t*)&val); }
    // 0x1436e4: 0xe60001e4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 484), *(uint32_t*)&val); }
    // 0x1436e8: 0xe60101e8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 488), *(uint32_t*)&val); }
    // 0x1436ec: 0xe60301f8
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 504), *(uint32_t*)&val); }
    // 0x1436f0: 0xe60401fc
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 508), *(uint32_t*)&val); }
    // 0x1436f4: 0xe6050200
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 512), *(uint32_t*)&val); }
    // 0x1436f8: 0x250718b0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 8), 6320));
    // 0x1436fc: 0x88e20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x143700: 0x98e20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x143704: 0xaa020207
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 519); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x143708: 0xba020204
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 516); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x14370c: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x143710: 0x7e020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    // 0x143714: 0x78a30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x143718: 0x7e030090
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 3));
    // 0x14371c: 0x78a20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x143720: 0xc050d58
    SET_GPR_U32(ctx, 31, 0x143728);
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 2));
    RecalcCmFrustrum__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_143728
// Address: 0x143728 - 0x143740

void entry_143728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143728: 0x3c020021
    SET_GPR_U32(ctx, 2, ((uint32_t)33 << 16));
    // 0x14372c: 0x26040454
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1108));
    // 0x143730: 0x24427398
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 29592));
    // 0x143734: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143738: 0xc0524e6
    SET_GPR_U32(ctx, 31, 0x143740);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1108), GPR_U32(ctx, 2));
    InitCplcy(rdram, ctx, runtime); return;
}


// Function: entry_143740
// Address: 0x143740 - 0x143758

void entry_143740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143740: 0x3c020021
    SET_GPR_U32(ctx, 2, ((uint32_t)33 << 16));
    // 0x143744: 0x26040460
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1120));
    // 0x143748: 0x244273b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 29616));
    // 0x14374c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143750: 0xc052598
    SET_GPR_U32(ctx, 31, 0x143758);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1120), GPR_U32(ctx, 2));
    InitCplook(rdram, ctx, runtime); return;
}


// Function: entry_143758
// Address: 0x143758 - 0x143770

void entry_143758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143758: 0x3c020021
    SET_GPR_U32(ctx, 2, ((uint32_t)33 << 16));
    // 0x14375c: 0x260404c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1216));
    // 0x143760: 0x244273c8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 29640));
    // 0x143764: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143768: 0xc052a22
    SET_GPR_U32(ctx, 31, 0x143770);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1216), GPR_U32(ctx, 2));
    InitCpalign(rdram, ctx, runtime); return;
}


// Function: entry_143770
// Address: 0x143770 - 0x143788

void entry_143770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143770: 0x3c020021
    SET_GPR_U32(ctx, 2, ((uint32_t)33 << 16));
    // 0x143774: 0x26040510
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1296));
    // 0x143778: 0x244273e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 29664));
    // 0x14377c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143780: 0xc0524e6
    SET_GPR_U32(ctx, 31, 0x143788);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1296), GPR_U32(ctx, 2));
    InitCplcy(rdram, ctx, runtime); return;
}


// Function: entry_143788
// Address: 0x143788 - 0x1437a0

void entry_143788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143788: 0x3c020021
    SET_GPR_U32(ctx, 2, ((uint32_t)33 << 16));
    // 0x14378c: 0x26040520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1312));
    // 0x143790: 0x244273f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 29688));
    // 0x143794: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143798: 0xc0524e6
    SET_GPR_U32(ctx, 31, 0x1437a0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1312), GPR_U32(ctx, 2));
    InitCplcy(rdram, ctx, runtime); return;
}


// Function: entry_1437a0
// Address: 0x1437a0 - 0x1437ac

void entry_1437a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1437a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1437a4: 0xc050e98
    SET_GPR_U32(ctx, 31, 0x1437ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ResetCm(rdram, ctx, runtime); return;
}


// Function: entry_1437ac
// Address: 0x1437ac - 0x1437c0

void entry_1437ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1437ac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1437b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1437b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1437bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1437c0; return;
}


// Function: SetSwCameraFov__Ff
// Address: 0x1437c0 - 0x1437d8

void entry_1437d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1437d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1437dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1437e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1437e8; return;
}


// Function: FUN_001437e8
// Address: 0x1437e8 - 0x143800

void FUN_001437e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1437e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1437ec: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1437f0: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1437f4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1437f8: 0xc050e5a
    SET_GPR_U32(ctx, 31, 0x143800);
    SetCmNearClip__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_143800
// Address: 0x143800 - 0x143810

void entry_143800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143800: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143804: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14380c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143810; return;
}


// Function: SetSwCameraFarClip__Ff
// Address: 0x143810 - 0x143828

void entry_143828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143828: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14382c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143838; return;
}


// Function: FUN_00143838
// Address: 0x143838 - 0x143850

void FUN_00143838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143838: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14383c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x143840: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x143844: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x143848: 0xc050e6a
    SET_GPR_U32(ctx, 31, 0x143850);
    SetCmSProgress__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_143850
// Address: 0x143850 - 0x143860

void entry_143850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143850: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143854: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14385c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143860; return;
}


// Function: FUN_00143860
// Address: 0x143860 - 0x143878

void FUN_00143860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143860: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x143864: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x143868: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x14386c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x143870: 0xc050e72
    SET_GPR_U32(ctx, 31, 0x143878);
    FUN_001439c8__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_143878
// Address: 0x143878 - 0x143888

void entry_143878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143878: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14387c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143888; return;
}


// Function: FUN_00143888
// Address: 0x143888 - 0x1438a0

void FUN_00143888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143888: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14388c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x143890: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x143894: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x143898: 0xc050e7a
    SET_GPR_U32(ctx, 31, 0x1438a0);
    FUN_001439e8__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1438a0
// Address: 0x1438a0 - 0x1438b0

void entry_1438a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1438a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1438a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1438ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1438b0; return;
}


// Function: SetSwCameraRgbaFog__FP2SWP4RGBA
// Address: 0x1438b0 - 0x1438c8

void entry_1438c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1438c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1438cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1438d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1438d8; return;
}


// Function: FUN_001438d8
// Address: 0x1438d8 - 0x1438f0

void FUN_001438d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1438d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1438dc: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1438e0: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1438e4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1438e8: 0xc050e8e
    SET_GPR_U32(ctx, 31, 0x1438f0);
    SetCmMrdRatio__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1438f0
// Address: 0x1438f0 - 0x143900

void entry_1438f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1438f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1438f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1438fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143900; return;
}


// Function: SetCmPos__FP2CMP6VECTOR
// Address: 0x143900 - 0x143910

void entry_143910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143910: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14391c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143920; return;
}


// Function: SetCmMat__FP2CMP7MATRIX3
// Address: 0x143920 - 0x143934

void entry_143934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143934: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143938: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmFov__FP2CMf
// Address: 0x143940 - 0x14395c

void entry_14395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14395c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143960: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmNearClip__FP2CMf
// Address: 0x143968 - 0x143978

void entry_143978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143978: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14397c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143984: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143988; return;
}


// Function: SetCmFarClip__FP2CMf
// Address: 0x143988 - 0x143998

void entry_143998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143998: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14399c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1439a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1439a8; return;
}


// Function: SetCmSProgress__FP2CMf
// Address: 0x1439a8 - 0x1439b8

void entry_1439b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1439b8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1439bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1439c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1439c8; return;
}


// Function: FUN_001439c8__FP2CMf
// Address: 0x1439c8 - 0x1439d8

void FUN_001439c8__FP2CMf(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1439c8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1439cc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1439d0: 0xc050d58
    SET_GPR_U32(ctx, 31, 0x1439d8);
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 508), *(uint32_t*)&val); }
    RecalcCmFrustrum__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1439d8
// Address: 0x1439d8 - 0x1439e8

void entry_1439d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1439d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1439dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1439e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1439e8; return;
}


// Function: FUN_001439e8__FP2CMf
// Address: 0x1439e8 - 0x1439f8

void FUN_001439e8__FP2CMf(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1439e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1439ec: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1439f0: 0xc050d58
    SET_GPR_U32(ctx, 31, 0x1439f8);
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 512), *(uint32_t*)&val); }
    RecalcCmFrustrum__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1439f8
// Address: 0x1439f8 - 0x143a08

void entry_1439f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1439f8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1439fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143a04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143a08; return;
}


// Function: SetCmRgbaFog__FP2CMP4RGBA
// Address: 0x143a08 - 0x143a2c

void entry_143a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143a2c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143a30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmMrdRatio__FP2CMf
// Address: 0x143a38 - 0x143a50

void entry_143a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143a50: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143a54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143a5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143a60; return;
}


// Function: ResetCm
// Address: 0x143a60 - 0x143a8c

void entry_143a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143a8c: 0x26300454
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 1108));
    // 0x143a90: 0xae2003d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 976), GPR_U32(ctx, 0));
    // 0x143a94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143a98: 0xc0524ee
    SET_GPR_U32(ctx, 31, 0x143aa0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCpmanCpmt(rdram, ctx, runtime); return;
}


// Function: entry_143aa0
// Address: 0x143aa0 - 0x143ab8

void entry_143aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143aa0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143aa4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x143aa8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x143aac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x143ab0: 0xc051422
    SET_GPR_U32(ctx, 31, 0x143ab8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_143ab8
// Address: 0x143ab8 - 0x143ac4

void entry_143ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143ab8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x143abc: 0xc051570
    SET_GPR_U32(ctx, 31, 0x143ac4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_143ac4
// Address: 0x143ac4 - 0x143af0

void entry_143ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143ac4: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x143ac8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x143acc: 0x3c020fff
    SET_GPR_U32(ctx, 2, ((uint32_t)4095 << 16));
    // 0x143ad0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x143ad4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x143ad8: 0xe6200218
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 536), *(uint32_t*)&val); }
    // 0x143adc: 0xae22021c
    WRITE32(ADD32(GPR_U32(ctx, 17), 540), GPR_U32(ctx, 2));
    // 0x143ae0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143ae4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143ae8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearCmFadeObjects__FP2CM
// Address: 0x143af0 - 0x143af8

void entry_143b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143b6c) {
        switch (ctx->pc) {
            case 0x143b7c: ctx->pc = 0; goto label_143b7c;
            case 0x143b94: ctx->pc = 0; goto label_143b94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143b6c: 0x8e020340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 832)));
    // 0x143b70: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x143b74: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 832), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_143b94;
    }
label_143b7c:
    // 0x143b7c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x143b80: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x143b84: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x143b88: 0xc7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 7)));
    // 0x143b8c: 0x1440fff0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x143B50; return;
    }
label_143b94:
    // 0x143b94: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143b98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x143b9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143ba4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143ba8; return;
}


// Function: FUN_00143BA8
// Address: 0x143ba8 - 0x143be0

void FUN_00143BA8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143ba8) {
        switch (ctx->pc) {
            case 0x143bd4: ctx->pc = 0; goto label_143bd4;
            case 0x143bd8: ctx->pc = 0; goto label_143bd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143ba8: 0xdca30538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 1336)));
    // 0x143bac: 0x3402f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61440));
    // 0x143bb0: 0x21538
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 20);
    // 0x143bb4: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x143bb8: 0x42478
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 17);
    // 0x143bbc: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x143bc0: 0x10640004
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_143bd4;
    }
    // 0x143bc8: 0x8ca20404
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1028)));
    // 0x143bcc: 0x10400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_143bd8;
    }
label_143bd4:
    // 0x143bd4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_143bd8:
    // 0x143bd8: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCmFade
// Address: 0x143be0 - 0x143c10

void entry_143c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143c10) {
        switch (ctx->pc) {
            case 0x143c40: ctx->pc = 0; goto label_143c40;
            case 0x143c70: ctx->pc = 0; goto label_143c70;
            case 0x143c7c: ctx->pc = 0; goto label_143c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143c10: 0x7a420040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x143c14: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x143c18: 0x8e430340
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 832)));
    // 0x143c1c: 0x27aa0e20
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 3616));
    // 0x143c20: 0x27ab0e24
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 3620));
    // 0x143c24: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x143c28: 0x18600014
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_143c7c;
    }
    // 0x143c30: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x143c34: 0x34068000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32768));
    // 0x143c38: 0x635b8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 22);
    // 0x143c3c: 0x26440344
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 836));
label_143c40:
    // 0x143c40: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x143c44: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x143c48: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x143c4c: 0x10400008
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_143c70;
    }
    // 0x143c54: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x143c58: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x143c5c: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143c60: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x143c64: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x143c68: 0x4bc218eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x143c6c: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
label_143c70:
    // 0x143c70: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x143c74: 0x14a0fff2
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_143c40;
    }
label_143c7c:
    // 0x143c7c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x143c80: 0x3c080014
    SET_GPR_U32(ctx, 8, ((uint32_t)20 << 16));
    // 0x143c84: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x143c88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x143c8c: 0x25083ba8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 15272));
    // 0x143c90: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x143c94: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x143c9c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_143c9c
// Address: 0x143c9c - 0x143d1c

void entry_143c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143c9c) {
        switch (ctx->pc) {
            case 0x143cb0: ctx->pc = 0; goto label_143cb0;
            case 0x143ce8: ctx->pc = 0; goto label_143ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143c9c: 0x8fa20e20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 3616)));
    // 0x143ca0: 0x18400059
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x143E08; return;
    }
    // 0x143ca8: 0x8fa20e24
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 3620)));
    // 0x143cac: 0x0
    // NOP
label_143cb0:
    // 0x143cb0: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x143cb4: 0x24b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 5), 1));
    // 0x143cb8: 0x8e440340
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 832)));
    // 0x143cbc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x143cc0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x143cc4: 0x1880004b
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x143DF4; return;
    }
    // 0x143ccc: 0x26540344
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 18), 836));
    // 0x143cd0: 0x34178000
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 32768));
    // 0x143cd4: 0x17bdb8
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 23) << 22);
    // 0x143cd8: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x143cdc: 0x24160070
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 112));
    // 0x143ce0: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x143ce4: 0x0
    // NOP
label_143ce8:
    // 0x143ce8: 0x2831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 3)));
    // 0x143cec: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x143cf0: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x143cf4: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x143cf8: 0x10400039
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x143DE0; return;
    }
    // 0x143d00: 0x8e0403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x143d04: 0x24660140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 320));
    // 0x143d08: 0x8e070404
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1028)));
    // 0x143d0c: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x143d10: 0x26450040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 64));
    // 0x143d14: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x143d1c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_143d1c
// Address: 0x143d1c - 0x143e10

void entry_143d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143d1c) {
        switch (ctx->pc) {
            case 0x143d40: ctx->pc = 0; goto label_143d40;
            case 0x143d80: ctx->pc = 0; goto label_143d80;
            case 0x143dd0: ctx->pc = 0; goto label_143dd0;
            case 0x143dd4: ctx->pc = 0; goto label_143dd4;
            case 0x143de0: ctx->pc = 0; goto label_143de0;
            case 0x143de4: ctx->pc = 0; goto label_143de4;
            case 0x143df4: ctx->pc = 0; goto label_143df4;
            case 0x143e08: ctx->pc = 0; goto label_143e08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143d1c: 0x561818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x143d20: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x143d24: 0x714021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x143d28: 0xc8102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x143d2c: 0x5040002d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 832)));
        goto label_143de4;
    }
    // 0x143d34: 0x3c0b0026
    SET_GPR_U32(ctx, 11, ((uint32_t)38 << 16));
    // 0x143d38: 0x8cc3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x143d3c: 0x0
    // NOP
label_143d40:
    // 0x143d40: 0x4600023
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 112));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_143dd0;
    }
    // 0x143d48: 0x8e0203fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1020)));
    // 0x143d4c: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x143d50: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x143d54: 0x1040001e
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_143dd0;
    }
    // 0x143d5c: 0x8e030400
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1024)));
    // 0x143d60: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x143d64: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x143d68: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x143d6c: 0x240a0028
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 40));
    // 0x143d70: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x143d74: 0x25691858
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 11), 6232));
    // 0x143d78: 0x8c630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x143d7c: 0x0
    // NOP
label_143d80:
    // 0x143d80: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x143d84: 0xc5200010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 16)); ctx->f[0] = *(float*)&val; }
    // 0x143d88: 0x6a1818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 10); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x143d8c: 0x8e020240
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 576)));
    // 0x143d90: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x143d94: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x143d98: 0xe4600014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 20), *(uint32_t*)&val); }
    // 0x143d9c: 0x8e0203fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1020)));
    // 0x143da0: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x143da4: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
        goto label_143dd4;
    }
    // 0x143dac: 0x8e020400
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1024)));
    // 0x143db0: 0x518c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 3));
    // 0x143db4: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x143db8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x143dbc: 0x482fff0
    if (GPR_S32(ctx, 4) < 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_143d80;
    }
    // 0x143dc4: 0x8cc2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 76)));
    // 0x143dc8: 0x50a2ffed
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
        goto label_143d80;
    }
label_143dd0:
    // 0x143dd0: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
label_143dd4:
    // 0x143dd4: 0xc8102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x143dd8: 0x5440ffd9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 76)));
        goto label_143d40;
    }
label_143de0:
    // 0x143de0: 0x8e420340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 832)));
label_143de4:
    // 0x143de4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x143de8: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x143dec: 0x1440ffbe
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x143CE8; return;
    }
label_143df4:
    // 0x143df4: 0x8fa20e20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 3616)));
    // 0x143df8: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x143dfc: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x143e00: 0x1440ffab
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 3620)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x143CB0; return;
    }
label_143e08:
    // 0x143e08: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x143e10);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_143e10
// Address: 0x143e10 - 0x143e40

void entry_143e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143e10: 0x7bbf0eb0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 3760)));
    // 0x143e14: 0x7bb70ea0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 3744)));
    // 0x143e18: 0x7bb60e90
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 3728)));
    // 0x143e1c: 0x7bb50e80
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 3712)));
    // 0x143e20: 0x7bb40e70
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 3696)));
    // 0x143e24: 0x7bb30e60
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 3680)));
    // 0x143e28: 0x7bb20e50
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 3664)));
    // 0x143e2c: 0x7bb10e40
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 3648)));
    // 0x143e30: 0x7bb00e30
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 3632)));
    // 0x143e34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 3776));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x143e3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x143e40; return;
}


// Function: UpdateCmLast
// Address: 0x143e40 - 0x143ee8

void entry_143ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143ee8) {
        switch (ctx->pc) {
            case 0x143efc: ctx->pc = 0; goto label_143efc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143ee8: 0x16800004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_143efc;
    }
    // 0x143ef0: 0x8e2202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 736)));
    // 0x143ef4: 0x12020006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x143F10; return;
    }
label_143efc:
    // 0x143efc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143f00: 0xc050cf8
    SET_GPR_U32(ctx, 31, 0x143f08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ResetCmAdjust__FP2CMP2SOP6CPDEFI(rdram, ctx, runtime); return;
}


// Function: entry_143f08
// Address: 0x143f08 - 0x143f1c

void entry_143f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143f08) {
        switch (ctx->pc) {
            case 0x143f10: ctx->pc = 0; goto label_143f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143f08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x143f0c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_143f10:
    // 0x143f10: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x143f14: 0xc050c82
    SET_GPR_U32(ctx, 31, 0x143f1c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AdjustCmCpdefi__FP2CMP2SOfP6CPDEFI(rdram, ctx, runtime); return;
}


// Function: entry_143f1c
// Address: 0x143f1c - 0x143f58

void entry_143f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143f1c) {
        switch (ctx->pc) {
            case 0x143f24: ctx->pc = 0; goto label_143f24;
            case 0x143f44: ctx->pc = 0; goto label_143f44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143f1c: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x143f20: 0xae3002e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 736), GPR_U32(ctx, 16));
label_143f24:
    // 0x143f24: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x143f28: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x143f2c: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 11368)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_143f58(rdram, ctx, runtime); return;
    }
    // 0x143f34: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x143f38: 0x14400002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 23), 11376));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_143f44;
    }
    // 0x143f40: 0x26c62d38
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 22), 11576));
label_143f44:
    // 0x143f44: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x143f48: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x143f4c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x143f50: 0x40f809
    SET_GPR_U32(ctx, 31, 0x143f58);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_143f58
// Address: 0x143f58 - 0x143f88

void entry_143f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143f58) {
        switch (ctx->pc) {
            case 0x143f70: ctx->pc = 0; goto label_143f70;
            case 0x143f74: ctx->pc = 0; goto label_143f74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143f58: 0x8e2203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 976)));
    // 0x143f5c: 0x18400004
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_143f70;
    }
    // 0x143f64: 0x8e3303d8
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 984)));
    // 0x143f68: 0x5674ffd5
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 988)));
        ctx->pc = 0x143EC0; return;
    }
label_143f70:
    // 0x143f70: 0x8e220224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 548)));
label_143f74:
    // 0x143f74: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 452)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x143F90; return;
    }
    // 0x143f7c: 0xc62c01c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 456)); ctx->f[12] = *(float*)&val; }
    // 0x143f80: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x143f88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_143f88
// Address: 0x143f88 - 0x143fb8

void entry_143f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143f88) {
        switch (ctx->pc) {
            case 0x143f90: ctx->pc = 0; goto label_143f90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143f88: 0x1000000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x143FC8; return;
    }
label_143f90:
    // 0x143f90: 0xc62e01c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 456)); ctx->f[14] = *(float*)&val; }
    // 0x143f94: 0x460e6032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x143f98: 0x0
    // NOP
    // 0x143f9c: 0x4501000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x143FC8; return;
    }
    // 0x143fa4: 0xc62d01cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 460)); ctx->f[13] = *(float*)&val; }
    // 0x143fa8: 0x262401d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 464));
    // 0x143fac: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x143fb0: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x143fb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 460));
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_143fb8
// Address: 0x143fb8 - 0x143fc4

void entry_143fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x143fb8: 0xe62001c4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 452), *(uint32_t*)&val); }
    // 0x143fbc: 0xc050d58
    SET_GPR_U32(ctx, 31, 0x143fc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RecalcCmFrustrum__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_143fc4
// Address: 0x143fc4 - 0x144008

void entry_143fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x143fc4) {
        switch (ctx->pc) {
            case 0x143fc8: ctx->pc = 0; goto label_143fc8;
            case 0x143fd8: ctx->pc = 0; goto label_143fd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x143fc4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_143fc8:
    // 0x143fc8: 0x10400003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_143fd8;
    }
    // 0x143fd0: 0xae200224
    WRITE32(ADD32(GPR_U32(ctx, 17), 548), GPR_U32(ctx, 0));
    // 0x143fd4: 0xae200228
    WRITE32(ADD32(GPR_U32(ctx, 17), 552), GPR_U32(ctx, 0));
label_143fd8:
    // 0x143fd8: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x143fdc: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x143fe0: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x143fe4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x143fe8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x143fec: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x143ff0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x143ff4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x143ff8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x143ffc: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x144000: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupCmRotateToCam
// Address: 0x144008 - 0x144128

void entry_144284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144284: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x144288: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x14428c: 0x10600009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1442B4; return;
    }
    // 0x144294: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x144298: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14429c: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1442a0: 0xc07baec
    SET_GPR_U32(ctx, 31, 0x1442a8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7876)));
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime); return;
}


// Function: entry_1442a8
// Address: 0x1442a8 - 0x1442c8

void entry_1442a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1442a8) {
        switch (ctx->pc) {
            case 0x1442b4: ctx->pc = 0; goto label_1442b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1442a8: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1442ac: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 540), GPR_U32(ctx, 2));
        goto label_1442b4;
    }
label_1442b4:
    // 0x1442b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1442b8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1442bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1442c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1442c8; return;
}


// Function: CombineEyeLookAtProj
// Address: 0x1442c8 - 0x144300

void entry_144300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x144300) {
        switch (ctx->pc) {
            case 0x144320: ctx->pc = 0; goto label_144320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x144300: 0x27b30040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 64));
    // 0x144304: 0x27b40080
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 128));
    // 0x144308: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x14430c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x144310: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x144314: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x144318: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14431c: 0x0
    // NOP
label_144320:
    // 0x144320: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x144324: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x144328: 0xc6200020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[0] = *(float*)&val; }
    // 0x14432c: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x144330: 0xc6220000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[2] = *(float*)&val; }
    // 0x144334: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x144338: 0xc6030000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14433c: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x144340: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x144344: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x144348: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x14434c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x144350: 0xe4820000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x144354: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x144358: 0xe4a30000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 5), 0), *(uint32_t*)&val); }
    // 0x14435c: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x144360: 0x4c1ffef
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_144320;
    }
    // 0x144368: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14436c: 0xc0626bc
    SET_GPR_U32(ctx, 31, 0x144374);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FInvertMatrix4__FP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_144374
// Address: 0x144374 - 0x144384

void entry_144374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144374: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x144378: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x14437c: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x144384);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_144384
// Address: 0x144384 - 0x1443c8

void entry_144384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144384: 0x7ba30080
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x144388: 0x7ba40090
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14438c: 0x7ba500a0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x144390: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x144394: 0x7e430000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 3));
    // 0x144398: 0x7e420030
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 2));
    // 0x14439c: 0x7e440010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 4));
    // 0x1443a0: 0x7e450020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 5));
    // 0x1443a4: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1443a8: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1443ac: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1443b0: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1443b4: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1443b8: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1443bc: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1443c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildFrustrum
// Address: 0x1443c8 - 0x144540

void entry_1445a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1445a8) {
        switch (ctx->pc) {
            case 0x1445b4: ctx->pc = 0; goto label_1445b4;
            case 0x144600: ctx->pc = 0; goto label_144600;
            case 0x144614: ctx->pc = 0; goto label_144614;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1445a8: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1445ac: 0x1000007f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1447AC; return;
    }
label_1445b4:
    // 0x1445b4: 0x46033083
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[6] * 0.0f); } else ctx->f[2] = ctx->f[6] / ctx->f[3];
    // 0x1445b8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1445bc: 0x244418d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 6352));
    // 0x1445c0: 0xc44318d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6352)); ctx->f[3] = *(float*)&val; }
    // 0x1445c4: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1445c8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1445cc: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1445d0: 0x24435c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1445d4: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1445d8: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1445dc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1445e0: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1445e4: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1445e8: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1445ec: 0x0
    // NOP
    // 0x1445f0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144600;
    }
    // 0x1445f8: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_144614;
    }
label_144600:
    // 0x144600: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144604: 0x0
    // NOP
    // 0x144608: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144614;
    }
    // 0x144610: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_144614:
    // 0x144614: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x144618: 0x26900080
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 128));
    // 0x14461c: 0xc44c18cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6348)); ctx->f[12] = *(float*)&val; }
    // 0x144620: 0x26930100
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 20), 256));
    // 0x144624: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x144628: 0xc081500
    SET_GPR_U32(ctx, 31, 0x144630);
    ctx->f[12] = FPU_MUL_S(ctx->f[6], ctx->f[12]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_144630
// Address: 0x144630 - 0x14469c

void entry_144630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144630: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x144634: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x144638: 0x244218e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6368));
    // 0x14463c: 0xda060010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x144640: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x144644: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x144648: 0xda040020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x14464c: 0x246318f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6384));
    // 0x144650: 0xda810080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 128)));
    // 0x144654: 0x27b20020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 32));
    // 0x144658: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x14465c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x144660: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144664: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x144668: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x14466c: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x144670: 0xda810040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x144674: 0x4be51098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x144678: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14467c: 0x4be51848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144680: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x144684: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x144688: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14468c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x144690: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x144694: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x14469c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14469c
// Address: 0x14469c - 0x144794

void entry_14469c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14469c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1446a0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1446a4: 0x24428d40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937920));
    // 0x1446a8: 0x24631900
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6400));
    // 0x1446ac: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1446b0: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1446b4: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1446b8: 0x24a51910
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6416));
    // 0x1446bc: 0xdba500c0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1446c0: 0x27b10070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1446c4: 0xda070010
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1446c8: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1446cc: 0x4be51048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1446d0: 0xda060020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1446d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1446d8: 0xc69001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 484)); ctx->f[16] = *(float*)&val; }
    // 0x1446dc: 0xc69101e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 488)); ctx->f[17] = *(float*)&val; }
    // 0x1446e0: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1446e4: 0x3c014580
    SET_GPR_U32(ctx, 1, ((uint32_t)17792 << 16));
    // 0x1446e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1446ec: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1446f0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1446f4: 0xc68101f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 496)); ctx->f[1] = *(float*)&val; }
    // 0x1446f8: 0xc68d01f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 500)); ctx->f[13] = *(float*)&val; }
    // 0x1446fc: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x144700: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x144704: 0xc7a20054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[2] = *(float*)&val; }
    // 0x144708: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x14470c: 0x3c014360
    SET_GPR_U32(ctx, 1, ((uint32_t)17248 << 16));
    // 0x144710: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x144714: 0x46036302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[3]);
    // 0x144718: 0xda840080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 128)));
    // 0x14471c: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x144720: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x144724: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x144728: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x14472c: 0x4bc338bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x144730: 0x4bc330ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144734: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x144738: 0x4be50858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14473c: 0x46016303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    // 0x144740: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x144744: 0x460d1343
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[13] = ctx->f[2] / ctx->f[13];
    // 0x144748: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14474c: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x144750: 0x4bc238bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x144754: 0x4bc2308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144758: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14475c: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x144760: 0x4bc138bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144764: 0x4bc1310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144768: 0xc7ae0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[14] = *(float*)&val; }
    // 0x14476c: 0xc7af0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[15] = *(float*)&val; }
    // 0x144770: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x144774: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x144778: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14477c: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x144780: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x144784: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x144788: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14478c: 0xc0627d6
    SET_GPR_U32(ctx, 31, 0x144794);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    BuildSimpleProjectionMatrix__FffffffP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_144794
// Address: 0x144794 - 0x1447a8

void entry_144794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144794: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x144798: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14479c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1447a0: 0xc0510b2
    SET_GPR_U32(ctx, 31, 0x1447a8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    CombineEyeLookAtProj(rdram, ctx, runtime); return;
}


// Function: entry_1447a8
// Address: 0x1447a8 - 0x1447b8

void entry_1447a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1447a8) {
        switch (ctx->pc) {
            case 0x1447ac: ctx->pc = 0; goto label_1447ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1447a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1447ac:
    // 0x1447ac: 0x26850140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 320));
    // 0x1447b0: 0xc0626bc
    SET_GPR_U32(ctx, 31, 0x1447b8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 384));
    FInvertMatrix4__FP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1447b8
// Address: 0x1447b8 - 0x1447cc

void entry_1447b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1447b8: 0xc68c01f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 496)); ctx->f[12] = *(float*)&val; }
    // 0x1447bc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1447c0: 0xc68d01f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 500)); ctx->f[13] = *(float*)&val; }
    // 0x1447c4: 0xc0510f2
    SET_GPR_U32(ctx, 31, 0x1447cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildFrustrum(rdram, ctx, runtime); return;
}


// Function: entry_1447cc
// Address: 0x1447cc - 0x144848

void entry_1447cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1447cc) {
        switch (ctx->pc) {
            case 0x1447e0: ctx->pc = 0; goto label_1447e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1447cc: 0x26850190
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 400));
    // 0x1447d0: 0x268301b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 432));
    // 0x1447d4: 0x26820050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 80));
    // 0x1447d8: 0x268401a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 416));
    // 0x1447dc: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
label_1447e0:
    // 0x1447e0: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1447e4: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x1447e8: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1447ec: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1447f0: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1447f4: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1447f8: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1447fc: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x144800: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x144804: 0xe4410008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x144808: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x14480c: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x144810: 0xe440000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x144814: 0x4c1fff2
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_1447e0;
    }
    // 0x14481c: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x144820: 0x7bb50120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x144824: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x144828: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x14482c: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x144830: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x144834: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x144838: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x14483c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x144844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x144848; return;
}


// Function: DrawCm__FP2CM
// Address: 0x144848 - 0x14486c

void entry_14486c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14486c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x144870: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x144874: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x14487c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_14487c
// Address: 0x14487c - 0x144894

void entry_14487c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14487c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x144880: 0x26270100
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 256));
    // 0x144884: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x144888: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x14488c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x144894);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_144894
// Address: 0x144894 - 0x1448ac

void entry_144894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144894: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x144898: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14489c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1448a0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1448a4: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x1448ac);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_1448ac
// Address: 0x1448ac - 0x1448b4

void entry_1448ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1448ac: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1448b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1448b4
// Address: 0x1448b4 - 0x1448c8

void entry_1448b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1448b4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1448b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1448bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1448c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmPosMat__FP2CMP6VECTORP7MATRIX3
// Address: 0x1448c8 - 0x14490c

void entry_14490c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14490c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x144910: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x144914: 0xe60002b8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 696), *(uint32_t*)&val); }
    // 0x144918: 0xe60002c0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 704), *(uint32_t*)&val); }
    // 0x14491c: 0xe60002bc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 700), *(uint32_t*)&val); }
    // 0x144920: 0xe60002b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 692), *(uint32_t*)&val); }
    // 0x144924: 0xe60002b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 688), *(uint32_t*)&val); }
    // 0x144928: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14492c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x144934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x144938; return;
}


// Function: SetCmLookAt
// Address: 0x144938 - 0x14496c

void entry_14496c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14496c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x144970: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertWorldToCylindVelocity
// Address: 0x144978 - 0x1449bc

void entry_1449bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1449bc) {
        switch (ctx->pc) {
            case 0x144a14: ctx->pc = 0; goto label_144a14;
            case 0x144a60: ctx->pc = 0; goto label_144a60;
            case 0x144a80: ctx->pc = 0; goto label_144a80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1449bc: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1449c0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1449c4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1449c8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1449cc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1449d0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1449d4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1449d8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1449dc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1449e0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1449e4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1449e8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1449ec: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1449f0: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1449f4: 0x0
    // NOP
    // 0x1449f8: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_144a14;
    }
    // 0x144a00: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x144a04: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x144a08: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x144a0c: 0x1000001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_144a80;
    }
label_144a14:
    // 0x144a14: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x144a18: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144a1c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x144a20: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144a24: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x144a28: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x144a2c: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x144a30: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x144a34: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x144a38: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144a3c: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x144a40: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144a44: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x144a48: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144a4c: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x144a50: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144a54: 0x45000002
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144a60;
    }
    // 0x144a5c: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
label_144a60:
    // 0x144a60: 0xc7a00044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[0] = *(float*)&val; }
    // 0x144a64: 0xc7a10048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[1] = *(float*)&val; }
    // 0x144a68: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x144a6c: 0xc7a20040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[2] = *(float*)&val; }
    // 0x144a70: 0x46030843
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[3];
    // 0x144a74: 0xe6220000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x144a78: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x144a7c: 0xe6410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_144a80:
    // 0x144a80: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x144a84: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x144a88: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x144a8c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x144a90: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x144a94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x144a9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x144aa0; return;
}


// Function: ConvertCylindToWorldVelocity
// Address: 0x144aa0 - 0x144ae4

void entry_144ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144ae4: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x144ae8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144aec: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x144af0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144af4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144af8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x144afc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144b00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x144b04: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x144b08: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x144b0c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x144b10: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x144b14: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x144b18: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x144b1c: 0x46140502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x144b20: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x144b24: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x144b28: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x144b2c: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x144b30: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x144b34: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x144b38: 0xc7b60090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[22] = *(float*)&val; }
    // 0x144b3c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x144b40: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x144b44: 0x4bc111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x144b48: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144b4c: 0x4bc1188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x144b50: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x144b54: 0xfa020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x144b58: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x144b5c: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x144b60: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x144b64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x144b6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x144b70; return;
}


// Function: ResetCmLookAtSmooth
// Address: 0x144b70 - 0x144bac

void entry_144bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144bac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x144bb0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x144bb4: 0x260702b0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 688));
    // 0x144bb8: 0x260802b4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 692));
    // 0x144bbc: 0x260902b8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 696));
    // 0x144bc0: 0xc05125e
    SET_GPR_U32(ctx, 31, 0x144bc8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertWorldToCylindVelocity(rdram, ctx, runtime); return;
}


// Function: entry_144bc8
// Address: 0x144bc8 - 0x144be8

void entry_144bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144bc8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x144bcc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x144bd0: 0x7e0202d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 720), GPR_VEC(ctx, 2));
    // 0x144bd4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x144bd8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x144bdc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x144be0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmLookAtSmooth
// Address: 0x144be8 - 0x144c60

void entry_144c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144c60: 0xc60101c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 452)); ctx->f[1] = *(float*)&val; }
    // 0x144c64: 0x27a6005c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 92));
    // 0x144c68: 0xc60601e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 480)); ctx->f[6] = *(float*)&val; }
    // 0x144c6c: 0x26040040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 64));
    // 0x144c70: 0x4601a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x144c74: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x144c78: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x144c7c: 0x4601b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[1]);
    // 0x144c80: 0xc7a40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[4] = *(float*)&val; }
    // 0x144c84: 0xc7a20054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[2] = *(float*)&val; }
    // 0x144c88: 0x260502d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 720));
    // 0x144c8c: 0x46060002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[6]);
    // 0x144c90: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x144c94: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x144c98: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x144c9c: 0x46050842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
    // 0x144ca0: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x144ca4: 0x46032100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[3]);
    // 0x144ca8: 0x27a80064
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 100));
    // 0x144cac: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x144cb0: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x144cb4: 0x46002580
    ctx->f[22] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x144cb8: 0xc051538
    SET_GPR_U32(ctx, 31, 0x144cc0);
    ctx->f[24] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    DecomposeSphere(rdram, ctx, runtime); return;
}


// Function: entry_144cc0
// Address: 0x144cc0 - 0x144cd0

void entry_144cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144cc0: 0x26040080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 128));
    // 0x144cc4: 0x27a50068
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 104));
    // 0x144cc8: 0xc06248c
    SET_GPR_U32(ctx, 31, 0x144cd0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 108));
    DecomposeRotateMatrixPanTilt__FP7MATRIX3PfT1(rdram, ctx, runtime); return;
}


// Function: entry_144cd0
// Address: 0x144cd0 - 0x144d00

void entry_144cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x144cd0) {
        switch (ctx->pc) {
            case 0x144cf4: ctx->pc = 0; goto label_144cf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x144cd0: 0x32220001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 1));
    // 0x144cd4: 0x14400007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_144cf4;
    }
    // 0x144cdc: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    // 0x144ce0: 0x4600c546
    ctx->f[21] = FPU_MOV_S(ctx->f[24]);
    // 0x144ce4: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x144ce8: 0xc7ad0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[13] = *(float*)&val; }
    // 0x144cec: 0x1000009e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[14] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x144F68; return;
    }
label_144cf4:
    // 0x144cf4: 0xc7ac005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 92)); ctx->f[12] = *(float*)&val; }
    // 0x144cf8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x144d00);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_144d00
// Address: 0x144d00 - 0x144d28

void entry_144d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144d00: 0xc7ac0068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[12] = *(float*)&val; }
    // 0x144d04: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x144d08: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x144d0c: 0xc7a20058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[2] = *(float*)&val; }
    // 0x144d10: 0x460cb301
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[12]);
    // 0x144d14: 0xc7a30054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[3] = *(float*)&val; }
    // 0x144d18: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x144d1c: 0x46011d81
    ctx->f[22] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x144d20: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x144d28);
    ctx->f[23] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_144d28
// Address: 0x144d28 - 0x144f70

void entry_144d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x144d28) {
        switch (ctx->pc) {
            case 0x144da4: ctx->pc = 0; goto label_144da4;
            case 0x144db8: ctx->pc = 0; goto label_144db8;
            case 0x144dd8: ctx->pc = 0; goto label_144dd8;
            case 0x144de8: ctx->pc = 0; goto label_144de8;
            case 0x144dec: ctx->pc = 0; goto label_144dec;
            case 0x144e14: ctx->pc = 0; goto label_144e14;
            case 0x144e38: ctx->pc = 0; goto label_144e38;
            case 0x144e5c: ctx->pc = 0; goto label_144e5c;
            case 0x144e74: ctx->pc = 0; goto label_144e74;
            case 0x144e8c: ctx->pc = 0; goto label_144e8c;
            case 0x144f68: ctx->pc = 0; goto label_144f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x144d28: 0x4600a105
    ctx->f[4] = FPU_ABS_S(ctx->f[20]);
    // 0x144d2c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x144d30: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x144d34: 0xc7a1006c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 108)); ctx->f[1] = *(float*)&val; }
    // 0x144d38: 0x460001c6
    ctx->f[7] = FPU_MOV_S(ctx->f[0]);
    // 0x144d3c: 0x46042834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144d40: 0x0
    // NOP
    // 0x144d44: 0x45000028
    ctx->f[2] = FPU_SUB_S(ctx->f[24], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144de8;
    }
    // 0x144d4c: 0x460038c5
    ctx->f[3] = FPU_ABS_S(ctx->f[7]);
    // 0x144d50: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144d54: 0x0
    // NOP
    // 0x144d58: 0x45020024
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ABS_S(ctx->f[20]);
        goto label_144dec;
    }
    // 0x144d60: 0x4607a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[7]);
    // 0x144d64: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x144d68: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144d6c: 0x0
    // NOP
    // 0x144d70: 0x4502001e
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ABS_S(ctx->f[20]);
        goto label_144dec;
    }
    // 0x144d78: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144d7c: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144db8;
    }
    // 0x144d84: 0x46013834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[7], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144d88: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144da4;
    }
    // 0x144d90: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x144d94: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x144d98: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144d9c: 0x10000012
    ctx->f[7] = FPU_ADD_S(ctx->f[7], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_144de8;
    }
label_144da4:
    // 0x144da4: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x144da8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x144dac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144db0: 0x1000000d
    ctx->f[7] = FPU_SUB_S(ctx->f[7], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_144de8;
    }
label_144db8:
    // 0x144db8: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144dbc: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_144dd8;
    }
    // 0x144dc4: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x144dc8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x144dcc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144dd0: 0x10000005
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_144de8;
    }
label_144dd8:
    // 0x144dd8: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x144ddc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x144de0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144de4: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
label_144de8:
    // 0x144de8: 0x4600a005
    ctx->f[0] = FPU_ABS_S(ctx->f[20]);
label_144dec:
    // 0x144dec: 0x3c013f2a
    SET_GPR_U32(ctx, 1, ((uint32_t)16170 << 16));
    // 0x144df0: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x144df4: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x144df8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x144dfc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x144e00: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x144e04: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144e08: 0x0
    // NOP
    // 0x144e0c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[0]);
        goto label_144e14;
    }
label_144e14:
    // 0x144e14: 0x4600b005
    ctx->f[0] = FPU_ABS_S(ctx->f[22]);
    // 0x144e18: 0x3c013faa
    SET_GPR_U32(ctx, 1, ((uint32_t)16298 << 16));
    // 0x144e1c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x144e20: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x144e24: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x144e28: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144e2c: 0x0
    // NOP
    // 0x144e30: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[0]);
        goto label_144e38;
    }
label_144e38:
    // 0x144e38: 0x4600b845
    ctx->f[1] = FPU_ABS_S(ctx->f[23]);
    // 0x144e3c: 0x3c013b03
    SET_GPR_U32(ctx, 1, ((uint32_t)15107 << 16));
    // 0x144e40: 0x3421126f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4719));
    // 0x144e44: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x144e48: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x144e4c: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144e50: 0x0
    // NOP
    // 0x144e54: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[0]);
        goto label_144e5c;
    }
label_144e5c:
    // 0x144e5c: 0x46003805
    ctx->f[0] = FPU_ABS_S(ctx->f[7]);
    // 0x144e60: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x144e64: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144e68: 0x0
    // NOP
    // 0x144e6c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[0]);
        goto label_144e74;
    }
label_144e74:
    // 0x144e74: 0x46001005
    ctx->f[0] = FPU_ABS_S(ctx->f[2]);
    // 0x144e78: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x144e7c: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x144e80: 0x0
    // NOP
    // 0x144e84: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[0]);
        goto label_144e8c;
    }
label_144e8c:
    // 0x144e8c: 0x46031083
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[3];
    // 0x144e90: 0xc60a02b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 688)); ctx->f[10] = *(float*)&val; }
    // 0x144e94: 0x460339c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[7] = copysignf(INFINITY, ctx->f[7] * 0.0f); } else ctx->f[7] = ctx->f[7] / ctx->f[3];
    // 0x144e98: 0xc60602b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 692)); ctx->f[6] = *(float*)&val; }
    // 0x144e9c: 0x4603a503
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[3];
    // 0x144ea0: 0xc60502b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 696)); ctx->f[5] = *(float*)&val; }
    // 0x144ea4: 0x4603b583
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[22] * 0.0f); } else ctx->f[22] = ctx->f[22] / ctx->f[3];
    // 0x144ea8: 0xc60402bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 700)); ctx->f[4] = *(float*)&val; }
    // 0x144eac: 0x4603bdc3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[23] = copysignf(INFINITY, ctx->f[23] * 0.0f); } else ctx->f[23] = ctx->f[23] / ctx->f[3];
    // 0x144eb0: 0xc60c02c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 704)); ctx->f[12] = *(float*)&val; }
    // 0x144eb4: 0x461a5382
    ctx->f[14] = FPU_MUL_S(ctx->f[10], ctx->f[26]);
    // 0x144eb8: 0xc7b3005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 92)); ctx->f[19] = *(float*)&val; }
    // 0x144ebc: 0x461912c2
    ctx->f[11] = FPU_MUL_S(ctx->f[2], ctx->f[25]);
    // 0x144ec0: 0xc7b20060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[18] = *(float*)&val; }
    // 0x144ec4: 0x46193802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[25]);
    // 0x144ec8: 0xc7b10064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[17] = *(float*)&val; }
    // 0x144ecc: 0x4619a0c2
    ctx->f[3] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x144ed0: 0xc7b00068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[16] = *(float*)&val; }
    // 0x144ed4: 0x461a31c2
    ctx->f[7] = FPU_MUL_S(ctx->f[6], ctx->f[26]);
    // 0x144ed8: 0xc7af006c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 108)); ctx->f[15] = *(float*)&val; }
    // 0x144edc: 0x461a2a02
    ctx->f[8] = FPU_MUL_S(ctx->f[5], ctx->f[26]);
    // 0x144ee0: 0x461a2242
    ctx->f[9] = FPU_MUL_S(ctx->f[4], ctx->f[26]);
    // 0x144ee4: 0x4619b082
    ctx->f[2] = FPU_MUL_S(ctx->f[22], ctx->f[25]);
    // 0x144ee8: 0x4619b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[25]);
    // 0x144eec: 0x461a6342
    ctx->f[13] = FPU_MUL_S(ctx->f[12], ctx->f[26]);
    // 0x144ef0: 0x460e18c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[14]);
    // 0x144ef4: 0x46071080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[7]);
    // 0x144ef8: 0x46080840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[8]);
    // 0x144efc: 0x46090000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[9]);
    // 0x144f00: 0x460d5ac0
    ctx->f[11] = FPU_ADD_S(ctx->f[11], ctx->f[13]);
    // 0x144f04: 0x461518c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[21]);
    // 0x144f08: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x144f0c: 0x46151082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[21]);
    // 0x144f10: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x144f14: 0x46155ac2
    ctx->f[11] = FPU_MUL_S(ctx->f[11], ctx->f[21]);
    // 0x144f18: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x144f1c: 0x46035280
    ctx->f[10] = FPU_ADD_S(ctx->f[10], ctx->f[3]);
    // 0x144f20: 0x46023180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[2]);
    // 0x144f24: 0x46012940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x144f28: 0xe60402bc
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 700), *(uint32_t*)&val); }
    // 0x144f2c: 0x460b6300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[11]);
    // 0x144f30: 0xe60a02b0
    { float val = ctx->f[10]; WRITE32(ADD32(GPR_U32(ctx, 16), 688), *(uint32_t*)&val); }
    // 0x144f34: 0xe60602b4
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 692), *(uint32_t*)&val); }
    // 0x144f38: 0x46155282
    ctx->f[10] = FPU_MUL_S(ctx->f[10], ctx->f[21]);
    // 0x144f3c: 0xe60502b8
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 696), *(uint32_t*)&val); }
    // 0x144f40: 0x46153182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[21]);
    // 0x144f44: 0x46156002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[21]);
    // 0x144f48: 0xe60c02c0
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 16), 704), *(uint32_t*)&val); }
    // 0x144f4c: 0x46152942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[21]);
    // 0x144f50: 0x46152102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[21]);
    // 0x144f54: 0x460a9b00
    ctx->f[12] = FPU_ADD_S(ctx->f[19], ctx->f[10]);
    // 0x144f58: 0x46069340
    ctx->f[13] = FPU_ADD_S(ctx->f[18], ctx->f[6]);
    // 0x144f5c: 0x46058b80
    ctx->f[14] = FPU_ADD_S(ctx->f[17], ctx->f[5]);
    // 0x144f60: 0x46048500
    ctx->f[20] = FPU_ADD_S(ctx->f[16], ctx->f[4]);
    // 0x144f64: 0x46007d40
    ctx->f[21] = FPU_ADD_S(ctx->f[15], ctx->f[0]);
label_144f68:
    // 0x144f68: 0xc07b5ac
    SET_GPR_U32(ctx, 31, 0x144f70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVectorSphere__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_144f70
// Address: 0x144f70 - 0x144f90

void entry_144f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144f70: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x144f74: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x144f78: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x144f7c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x144f80: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x144f84: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x144f88: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x144f90);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_144f90
// Address: 0x144f90 - 0x144fb8

void entry_144f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144f90: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x144f94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x144f98: 0x7ba60010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x144f9c: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x144fa0: 0x7ba50040
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x144fa4: 0x7e060040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 6));
    // 0x144fa8: 0x7e020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 2));
    // 0x144fac: 0x7e030090
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 3));
    // 0x144fb0: 0xc051150
    SET_GPR_U32(ctx, 31, 0x144fb8);
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), GPR_VEC(ctx, 5));
    UpdateCmMat4(rdram, ctx, runtime); return;
}


// Function: entry_144fb8
// Address: 0x144fb8 - 0x144ff8

void entry_144fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x144fb8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x144fbc: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x144fc0: 0x7e0202d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 720), GPR_VEC(ctx, 2));
    // 0x144fc4: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x144fc8: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x144fcc: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x144fd0: 0xc7ba00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[26] = *(float*)&val; }
    // 0x144fd4: 0xc7b900d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[25] = *(float*)&val; }
    // 0x144fd8: 0xc7b800d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[24] = *(float*)&val; }
    // 0x144fdc: 0xc7b700c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[23] = *(float*)&val; }
    // 0x144fe0: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x144fe4: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x144fe8: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x144fec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x144ff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x144ff8; return;
}


// Function: AdjustCmJoy__FP2CMP3JOY5JOYIDPf
// Address: 0x144ff8 - 0x145044

void entry_145044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145044) {
        switch (ctx->pc) {
            case 0x14504c: ctx->pc = 0; goto label_14504c;
            case 0x145050: ctx->pc = 0; goto label_145050;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145044: 0x10000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_145050;
    }
label_14504c:
    // 0x14504c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
label_145050:
    // 0x145050: 0xc60d0080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[13] = *(float*)&val; }
    // 0x145054: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x14505c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 132)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_14505c
// Address: 0x14505c - 0x145064

void entry_14505c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14505c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x145064);
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_145064
// Address: 0x145064 - 0x145080

void entry_145064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145064: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x145068: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14506c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x145070: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145074: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x145078: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00145080
// Address: 0x145080 - 0x145088

void entry_145128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145128: 0x2301821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x14512c: 0xac7303d4
    WRITE32(ADD32(GPR_U32(ctx, 3), 980), GPR_U32(ctx, 19));
    // 0x145130: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x145134: 0xac5403d8
    WRITE32(ADD32(GPR_U32(ctx, 2), 984), GPR_U32(ctx, 20));
    // 0x145138: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14513c: 0xac9603dc
    WRITE32(ADD32(GPR_U32(ctx, 4), 988), GPR_U32(ctx, 22));
    // 0x145140: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x145144: 0xae1503e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 992), GPR_U32(ctx, 21));
    // 0x145148: 0x8e2203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 976)));
    // 0x14514c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x145150: 0xae2203d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 976), GPR_U32(ctx, 2));
    // 0x145154: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x145158: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x14515c: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14516c(rdram, ctx, runtime); return;
    }
    // 0x145164: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14516c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14516c
// Address: 0x14516c - 0x1451a0

void entry_14516c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14516c: 0x16400016
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1451C8; return;
    }
    // 0x145174: 0x8e2203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 976)));
    // 0x145178: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x14517c: 0x14400009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1451A4; return;
    }
    // 0x145184: 0x8e2403e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1000)));
    // 0x145188: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14518c: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x145190: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        ctx->pc = 0x1451A4; return;
    }
    // 0x145198: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1451a0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1008)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1451a0
// Address: 0x1451a0 - 0x1451c4

void entry_1451a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1451a0) {
        switch (ctx->pc) {
            case 0x1451a4: ctx->pc = 0; goto label_1451a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1451a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1451a4:
    // 0x1451a4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1451a8: 0xe6200364
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 868), *(uint32_t*)&val); }
    // 0x1451ac: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1451b0: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1451b4: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1451c4(rdram, ctx, runtime); return;
    }
    // 0x1451bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1451c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1451c4
// Address: 0x1451c4 - 0x1451f0

void entry_1451c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1451c4) {
        switch (ctx->pc) {
            case 0x1451c8: ctx->pc = 0; goto label_1451c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1451c4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1451c8:
    // 0x1451c8: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1451cc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1451d0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1451d4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1451d8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1451dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1451e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1451e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1451ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1451f0; return;
}


// Function: RevokeCmPolicy
// Address: 0x1451f0 - 0x1452e4

void entry_1452e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1452e4) {
        switch (ctx->pc) {
            case 0x1452ec: ctx->pc = 0; goto label_1452ec;
            case 0x145314: ctx->pc = 0; goto label_145314;
            case 0x145324: ctx->pc = 0; goto label_145324;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1452e4: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 976)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_145314;
    }
label_1452ec:
    // 0x1452ec: 0x6a020007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1452f0: 0x6e020000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1452f4: 0x6a03000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1452f8: 0x6e030008
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1452fc: 0xb2220007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x145300: 0xb6220000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x145304: 0xb223000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x145308: 0xb6230008
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x14530c: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x145310: 0x8e4203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 976)));
label_145314:
    // 0x145314: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x145318: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x14531c: 0x1440ffd2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x145268; return;
    }
label_145324:
    // 0x145324: 0x2622fc2c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294966316));
    // 0x145328: 0x521023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x14532c: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x145330: 0x12800013
    WRITE32(ADD32(GPR_U32(ctx, 18), 976), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        entry_145380(rdram, ctx, runtime); return;
    }
    // 0x145338: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x14533c: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x145340: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_145350(rdram, ctx, runtime); return;
    }
    // 0x145348: 0x40f809
    SET_GPR_U32(ctx, 31, 0x145350);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_145350
// Address: 0x145350 - 0x145380

void entry_145350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145350: 0x8e4203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 976)));
    // 0x145354: 0x1840000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_145380(rdram, ctx, runtime); return;
    }
    // 0x14535c: 0x8e4403d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 984)));
    // 0x145360: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x145364: 0xe6400364
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 868), *(uint32_t*)&val); }
    // 0x145368: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14536c: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x145370: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x145384; return;
    }
    // 0x145378: 0x40f809
    SET_GPR_U32(ctx, 31, 0x145380);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 992)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_145380
// Address: 0x145380 - 0x1453b0

void entry_145380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145380) {
        switch (ctx->pc) {
            case 0x145384: ctx->pc = 0; goto label_145384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145380: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_145384:
    // 0x145384: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x145388: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14538c: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x145390: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x145394: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x145398: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14539c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1453a0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1453a4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1453a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FInsideCmMrd
// Address: 0x1453b0 - 0x145438

void entry_14548c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14548c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x145494);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_145494
// Address: 0x145494 - 0x1454e0

void entry_145494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145494) {
        switch (ctx->pc) {
            case 0x145498: ctx->pc = 0; goto label_145498;
            case 0x1454bc: ctx->pc = 0; goto label_1454bc;
            case 0x1454c8: ctx->pc = 0; goto label_1454c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145494: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_145498:
    // 0x145498: 0x12200008
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1454bc;
    }
    // 0x1454a0: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1454a4: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1454a8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1454ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1454b0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1454b4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1454b8: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_1454bc:
    // 0x1454bc: 0x12400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1454c8;
    }
    // 0x1454c4: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_1454c8:
    // 0x1454c8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1454cc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1454d0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1454d4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1454d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DecomposeSphere
// Address: 0x1454e0 - 0x145534

void entry_145534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145534: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14553c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14553c
// Address: 0x14553c - 0x145570

void entry_14553c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14553c) {
        switch (ctx->pc) {
            case 0x145540: ctx->pc = 0; goto label_145540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14553c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_145540:
    // 0x145540: 0x1220000e
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14557C; return;
    }
    // 0x145548: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14554c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145550: 0xc7ac0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[12] = *(float*)&val; }
    // 0x145554: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145558: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14555c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x145560: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x145564: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x145568: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x145570);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_145570
// Address: 0x145570 - 0x145578

void entry_145570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145570: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x145578);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_145578
// Address: 0x145578 - 0x1455c0

void entry_145578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145578) {
        switch (ctx->pc) {
            case 0x14557c: ctx->pc = 0; goto label_14557c;
            case 0x1455a8: ctx->pc = 0; goto label_1455a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145578: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_14557c:
    // 0x14557c: 0x1240000a
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1455a8;
    }
    // 0x145584: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145588: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14558c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145590: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145594: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145598: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14559c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1455a0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1455a4: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_1455a8:
    // 0x1455a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1455ac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1455b0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1455b4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1455b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCmCut__FP2CMPf
// Address: 0x1455c0 - 0x1455e0

void entry_145600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145600: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145604: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14560c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145610; return;
}


// Function: AdaptCm
// Address: 0x145610 - 0x1456c0

void entry_1456c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1456c0: 0xc7a00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1456c4: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1456c8: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1456cc: 0xda020040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1456d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1456d4: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1456d8: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1456dc: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1456e0: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1456e4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1456e8: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1456ec: 0x4be52088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1456f0: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1456f4: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1456f8: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1456fc: 0xfa010230
    WRITE128(ADD32(GPR_U32(ctx, 16), 560), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x145700: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x145704: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x145708: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x14570c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x145710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetCm
// Address: 0x145718 - 0x145780

void entry_145780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145780: 0xda020230
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 560)));
    // 0x145784: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x145788: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14578c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x145790: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145794: 0x27a80018
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 24));
    // 0x145798: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14579c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1457a0: 0xc051538
    SET_GPR_U32(ctx, 31, 0x1457a8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 20));
    DecomposeSphere(rdram, ctx, runtime); return;
}


// Function: entry_1457a8
// Address: 0x1457a8 - 0x1457b4

void entry_1457a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1457a8: 0xc60c01f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 496)); ctx->f[12] = *(float*)&val; }
    // 0x1457ac: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x1457b4);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_1457b4
// Address: 0x1457b4 - 0x1457cc

void entry_1457b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1457b4: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1457b8: 0xc60c01f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 500)); ctx->f[12] = *(float*)&val; }
    // 0x1457bc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1457c0: 0x460cab02
    ctx->f[12] = FPU_MUL_S(ctx->f[21], ctx->f[12]);
    // 0x1457c4: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x1457cc);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_1457cc
// Address: 0x1457cc - 0x1457e8

void entry_1457cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1457cc: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1457d0: 0x26040080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 128));
    // 0x1457d4: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1457d8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1457dc: 0x46000b46
    ctx->f[13] = FPU_MOV_S(ctx->f[1]);
    // 0x1457e0: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1457e8);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1457e8
// Address: 0x1457e8 - 0x1457f0

void entry_1457e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1457e8: 0xc051150
    SET_GPR_U32(ctx, 31, 0x1457f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateCmMat4(rdram, ctx, runtime); return;
}


// Function: entry_1457f0
// Address: 0x1457f0 - 0x145810

void entry_1457f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1457f0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1457f4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1457f8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1457fc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x145800: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x145804: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x145808: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsoEnemyStepguard
// Address: 0x145810 - 0x14589c

void entry_14589c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14589c) {
        switch (ctx->pc) {
            case 0x1458a4: ctx->pc = 0; goto label_1458a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14589c: 0x1620fff4
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x145870; return;
    }
label_1458a4:
    // 0x1458a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1458a8: 0xc050a7e
    SET_GPR_U32(ctx, 31, 0x1458b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ClsgMergeAlsg__FiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1458b0
// Address: 0x1458b0 - 0x145950

void entry_1458b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1458b0) {
        switch (ctx->pc) {
            case 0x1458c0: ctx->pc = 0; goto label_1458c0;
            case 0x1458c4: ctx->pc = 0; goto label_1458c4;
            case 0x1458dc: ctx->pc = 0; goto label_1458dc;
            case 0x1458f0: ctx->pc = 0; goto label_1458f0;
            case 0x14590c: ctx->pc = 0; goto label_14590c;
            case 0x145914: ctx->pc = 0; goto label_145914;
            case 0x145918: ctx->pc = 0; goto label_145918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1458b0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1458b4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1458b8: 0x10000002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1458c4;
    }
label_1458c0:
    // 0x1458c0: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1458c4:
    // 0x1458c4: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x1458c8: 0x14400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_145918;
    }
    // 0x1458d0: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1458d4: 0x5c800001
    if (GPR_S32(ctx, 4) > 0) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294967188)); ctx->f[2] = *(float*)&val; }
        goto label_1458dc;
    }
label_1458dc:
    // 0x1458dc: 0x90102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    // 0x1458e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1458e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1458e8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
        goto label_1458f0;
    }
label_1458f0:
    // 0x1458f0: 0x46020801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1458f4: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1458f8: 0x0
    // NOP
    // 0x1458fc: 0x4500fff0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 112));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1458c0;
    }
    // 0x145904: 0x56e00001
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
        goto label_14590c;
    }
label_14590c:
    // 0x14590c: 0x57c00001
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 30), 0), *(uint32_t*)&val); }
        goto label_145914;
    }
label_145914:
    // 0x145914: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_145918:
    // 0x145918: 0x7bbf1c90
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 7312)));
    // 0x14591c: 0x7bbe1c80
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 7296)));
    // 0x145920: 0x7bb71c70
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 7280)));
    // 0x145924: 0x7bb61c60
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 7264)));
    // 0x145928: 0x7bb51c50
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 7248)));
    // 0x14592c: 0x7bb41c40
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 7232)));
    // 0x145930: 0x7bb31c30
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 7216)));
    // 0x145934: 0x7bb21c20
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 7200)));
    // 0x145938: 0x7bb11c10
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 7184)));
    // 0x14593c: 0x7bb01c00
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 7168)));
    // 0x145940: 0xc7b41ca0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 7328)); ctx->f[20] = *(float*)&val; }
    // 0x145944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 7344));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14594c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145950; return;
}


// Function: FUN_00145950
// Address: 0x145950 - 0x145a54

void FUN_00145950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145950) {
        switch (ctx->pc) {
            case 0x1459f0: ctx->pc = 0; goto label_1459f0;
            case 0x145a40: ctx->pc = 0; goto label_145a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145950: 0x27bdfee0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967008));
    // 0x145954: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x145958: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14595c: 0xe7b800f0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 240), *(uint32_t*)&val); }
    // 0x145960: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x145964: 0xe7b500d8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 216), *(uint32_t*)&val); }
    // 0x145968: 0x46006606
    ctx->f[24] = FPU_MOV_S(ctx->f[12]);
    // 0x14596c: 0x7fb600b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 22));
    // 0x145970: 0x46180543
    if (ctx->f[24] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[21] = ctx->f[0] / ctx->f[24];
    // 0x145974: 0x7fb500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 21));
    // 0x145978: 0x24761928
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 3), 6440));
    // 0x14597c: 0x7fb40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 20));
    // 0x145980: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x145984: 0x7fb30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 19));
    // 0x145988: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14598c: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x145990: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x145994: 0xe7bd0118
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 280), *(uint32_t*)&val); }
    // 0x145998: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x14599c: 0xe7bc0110
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 272), *(uint32_t*)&val); }
    // 0x1459a0: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1459a4: 0xe7b600e0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    // 0x1459a8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1459ac: 0x7fbf00c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 31));
    // 0x1459b0: 0x7fb20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 18));
    // 0x1459b4: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x1459b8: 0xe7bb0108
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 264), *(uint32_t*)&val); }
    // 0x1459bc: 0xe7ba0100
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1459c0: 0xe7b900f8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    // 0x1459c4: 0xe7b700e8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 232), *(uint32_t*)&val); }
    // 0x1459c8: 0xe7b400d0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 208), *(uint32_t*)&val); }
    // 0x1459cc: 0xc4d69e4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4294942284)); ctx->f[22] = *(float*)&val; }
    // 0x1459d0: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1459d4: 0x3c013ec9
    SET_GPR_U32(ctx, 1, ((uint32_t)16073 << 16));
    // 0x1459d8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1459dc: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x1459e0: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1459e4: 0x4480e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 0);
    // 0x1459e8: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1459ec: 0x0
    // NOP
label_1459f0:
    // 0x1459f0: 0x2483fffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 4294967292));
    // 0x1459f4: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1459f8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1459fc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x145a00: 0xc4540000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[20] = *(float*)&val; }
    // 0x145a04: 0x4600e306
    ctx->f[12] = FPU_MOV_S(ctx->f[28]);
    // 0x145a08: 0x24920001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 4), 1));
    // 0x145a0c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x145a10: 0x46146034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x145a14: 0x0
    // NOP
    // 0x145a18: 0x45000039
    ctx->f[23] = FPU_MUL_S(ctx->f[0], ctx->f[29]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x145B00; return;
    }
    // 0x145a20: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x145a24: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x145a28: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x145a2c: 0x4480d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 0);
    // 0x145a30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x145a34: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x145a38: 0x461b6302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[27]);
    // 0x145a3c: 0x0
    // NOP
label_145a40:
    // 0x145a40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x145a44: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x145a48: 0x4600c386
    ctx->f[14] = FPU_MOV_S(ctx->f[24]);
    // 0x145a4c: 0xc07b5ac
    SET_GPR_U32(ctx, 31, 0x145a54);
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[20];
    SetVectorSphere__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_145a54
// Address: 0x145a54 - 0x145a84

void entry_145a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145a54: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x145a58: 0x4615ab00
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[21]);
    // 0x145a5c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145a60: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x145a64: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145a68: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x145a6c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x145a70: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x145a74: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x145a78: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x145a7c: 0xc051604
    SET_GPR_U32(ctx, 31, 0x145a84);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 68));
    PsoEnemyStepguard(rdram, ctx, runtime); return;
}


// Function: entry_145a84
// Address: 0x145a84 - 0x145b68

void entry_145a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145a84) {
        switch (ctx->pc) {
            case 0x145aa4: ctx->pc = 0; goto label_145aa4;
            case 0x145ae4: ctx->pc = 0; goto label_145ae4;
            case 0x145b00: ctx->pc = 0; goto label_145b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145a84: 0x10400017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_145ae4;
    }
    // 0x145a8c: 0x4600d034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[26], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x145a90: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_145aa4;
    }
    // 0x145a98: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x145a9c: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x145aa0: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
label_145aa4:
    // 0x145aa4: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x145aa8: 0x0
    // NOP
    // 0x145aac: 0x4500000d
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_145ae4;
    }
    // 0x145ab4: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x145ab8: 0xda030000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x145abc: 0x4616c801
    ctx->f[0] = FPU_SUB_S(ctx->f[25], ctx->f[22]);
    // 0x145ac0: 0x4402b000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[22]);
    // 0x145ac4: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x145ac8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x145acc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x145ad0: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x145ad4: 0x4be408c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145ad8: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x145adc: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x145ae0: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
label_145ae4:
    // 0x145ae4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x145ae8: 0x44916000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 17);
    // 0x145aec: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x145af0: 0x46146034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x145af4: 0x0
    // NOP
    // 0x145af8: 0x4503ffd1
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[27]);
        ctx->pc = 0x145A40; return;
    }
label_145b00:
    // 0x145b00: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x145b04: 0x28820009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 9));
    // 0x145b08: 0x1440ffb9
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1459F0; return;
    }
    // 0x145b10: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x145b14: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x145b18: 0x7ea20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
    // 0x145b1c: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x145b20: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x145b24: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x145b28: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x145b2c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x145b30: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x145b34: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x145b38: 0xc7bd0118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[29] = *(float*)&val; }
    // 0x145b3c: 0xc7bc0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[28] = *(float*)&val; }
    // 0x145b40: 0xc7bb0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[27] = *(float*)&val; }
    // 0x145b44: 0xc7ba0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[26] = *(float*)&val; }
    // 0x145b48: 0xc7b900f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[25] = *(float*)&val; }
    // 0x145b4c: 0xc7b800f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[24] = *(float*)&val; }
    // 0x145b50: 0xc7b700e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[23] = *(float*)&val; }
    // 0x145b54: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x145b58: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x145b5c: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x145b60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00145b68
// Address: 0x145b68 - 0x145c00

void FUN_00145b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145b68) {
        switch (ctx->pc) {
            case 0x145bd0: ctx->pc = 0; goto label_145bd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145b68: 0x27bdf320
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294964000));
    // 0x145b6c: 0x7fb50c80
    WRITE128(ADD32(GPR_U32(ctx, 29), 3200), GPR_VEC(ctx, 21));
    // 0x145b70: 0x7fb40c70
    WRITE128(ADD32(GPR_U32(ctx, 29), 3184), GPR_VEC(ctx, 20));
    // 0x145b74: 0x120a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x145b78: 0x7fb30c60
    WRITE128(ADD32(GPR_U32(ctx, 29), 3168), GPR_VEC(ctx, 19));
    // 0x145b7c: 0x100a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x145b80: 0xe7b50cd8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 3288), *(uint32_t*)&val); }
    // 0x145b84: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x145b88: 0xe7b40cd0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 3280), *(uint32_t*)&val); }
    // 0x145b8c: 0x46006d46
    ctx->f[21] = FPU_MOV_S(ctx->f[13]);
    // 0x145b90: 0x7fbf0cc0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3264), GPR_VEC(ctx, 31));
    // 0x145b94: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x145b98: 0x7fbe0cb0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3248), GPR_VEC(ctx, 30));
    // 0x145b9c: 0x7fb70ca0
    WRITE128(ADD32(GPR_U32(ctx, 29), 3232), GPR_VEC(ctx, 23));
    // 0x145ba0: 0x7fb60c90
    WRITE128(ADD32(GPR_U32(ctx, 29), 3216), GPR_VEC(ctx, 22));
    // 0x145ba4: 0x7fb20c50
    WRITE128(ADD32(GPR_U32(ctx, 29), 3152), GPR_VEC(ctx, 18));
    // 0x145ba8: 0x7fb10c40
    WRITE128(ADD32(GPR_U32(ctx, 29), 3136), GPR_VEC(ctx, 17));
    // 0x145bac: 0x7fb00c30
    WRITE128(ADD32(GPR_U32(ctx, 29), 3120), GPR_VEC(ctx, 16));
    // 0x145bb0: 0xafa40c20
    WRITE32(ADD32(GPR_U32(ctx, 29), 3104), GPR_U32(ctx, 4));
    // 0x145bb4: 0xafa70c24
    WRITE32(ADD32(GPR_U32(ctx, 29), 3108), GPR_U32(ctx, 7));
    // 0x145bb8: 0x18a00015
    WRITE32(ADD32(GPR_U32(ctx, 29), 3112), GPR_U32(ctx, 10));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x145C10; return;
    }
    // 0x145bc0: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x145bc4: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x145bc8: 0x24160040
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 64));
    // 0x145bcc: 0x24120030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 48));
label_145bd0:
    // 0x145bd0: 0x8e280000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x145bd4: 0x8d060538
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 1336)));
    // 0x145bd8: 0x10c0000a
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x145C04; return;
    }
    // 0x145be0: 0x8d050534
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 1332)));
    // 0x145be4: 0x2d34823
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 22), GPR_U32(ctx, 19)));
    // 0x145be8: 0x2508050c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1292));
    // 0x145bec: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x145bf0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x145bf4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x145bf8: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x145c00);
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_145c00
// Address: 0x145c00 - 0x145c2c

void entry_145c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145c00) {
        switch (ctx->pc) {
            case 0x145c04: ctx->pc = 0; goto label_145c04;
            case 0x145c10: ctx->pc = 0; goto label_145c10;
            case 0x145c24: ctx->pc = 0; goto label_145c24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145c00: 0x2629821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
label_145c04:
    // 0x145c04: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x145c08: 0x1600fff1
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x145BD0; return;
    }
label_145c10:
    // 0x145c10: 0x16600004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 3112)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_145c24;
    }
    // 0x145c18: 0x7aa20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x145c1c: 0x10000060
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x145DA0; return;
    }
label_145c24:
    // 0x145c24: 0xc063582
    SET_GPR_U32(ctx, 31, 0x145c2c);
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 19), 2));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_145c2c
// Address: 0x145c2c - 0x145c3c

void entry_145c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145c2c: 0x2732018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x145c30: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x145c34: 0xc063596
    SET_GPR_U32(ctx, 31, 0x145c3c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_145c3c
// Address: 0x145c3c - 0x145c48

void entry_145c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145c3c: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x145c40: 0xc063596
    SET_GPR_U32(ctx, 31, 0x145c48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_145c48
// Address: 0x145c48 - 0x145c58

void entry_145c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145c48: 0x3c0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x145c4c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x145c50: 0xc063596
    SET_GPR_U32(ctx, 31, 0x145c58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_145c58
// Address: 0x145c58 - 0x145cfc

void entry_145c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145c58) {
        switch (ctx->pc) {
            case 0x145c70: ctx->pc = 0; goto label_145c70;
            case 0x145c90: ctx->pc = 0; goto label_145c90;
            case 0x145cc0: ctx->pc = 0; goto label_145cc0;
            case 0x145cd0: ctx->pc = 0; goto label_145cd0;
            case 0x145ce0: ctx->pc = 0; goto label_145ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145c58: 0x27a70c00
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 3072));
    // 0x145c5c: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x145c60: 0x1a60001b
    WRITE32(ADD32(GPR_U32(ctx, 29), 3116), GPR_U32(ctx, 7));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_145cd0;
    }
    // 0x145c68: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x145c6c: 0x0
    // NOP
label_145c70:
    // 0x145c70: 0x1a600013
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_145cc0;
    }
    // 0x145c78: 0x2261818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x145c7c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x145c80: 0x7d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 29)));
    // 0x145c84: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x145c88: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x145c8c: 0x0
    // NOP
label_145c90:
    // 0x145c90: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x145c94: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x145c98: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x145c9c: 0x24840030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 48));
    // 0x145ca0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x145ca4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x145ca8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x145cac: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145cb0: 0x48271000
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x145cb4: 0xae470000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 7));
    // 0x145cb8: 0x1460fff5
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_145c90;
    }
label_145cc0:
    // 0x145cc0: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x145cc4: 0x233102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    // 0x145cc8: 0x1440ffe9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_145c70;
    }
label_145cd0:
    // 0x145cd0: 0x1a60000e
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x145D0C; return;
    }
    // 0x145cd8: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x145cdc: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_145ce0:
    // 0x145ce0: 0x8fa40c20
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 3104)));
    // 0x145ce4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x145ce8: 0x8fa20c24
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 3108)));
    // 0x145cec: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x145cf0: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x145cf4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x145cfc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_145cfc
// Address: 0x145cfc - 0x145d20

void entry_145cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145cfc) {
        switch (ctx->pc) {
            case 0x145d0c: ctx->pc = 0; goto label_145d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145cfc: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x145d00: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x145d04: 0x1620fff6
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x145CE0; return;
    }
label_145d0c:
    // 0x145d0c: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x145d10: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x145d14: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x145d18: 0xc055220
    SET_GPR_U32(ctx, 31, 0x145d20);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SolveInequalities__FiPfN21(rdram, ctx, runtime); return;
}


// Function: entry_145d20
// Address: 0x145d20 - 0x145d84

void entry_145d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145d20) {
        switch (ctx->pc) {
            case 0x145d40: ctx->pc = 0; goto label_145d40;
            case 0x145d74: ctx->pc = 0; goto label_145d74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145d20: 0x2e0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x145d24: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x145d28: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x145d2c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x145d30: 0x1a600010
    WRITE128(ADD32(GPR_U32(ctx, 29), 3072), GPR_VEC(ctx, 3));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_145d74;
    }
    // 0x145d38: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x145d3c: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
label_145d40:
    // 0x145d40: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x145d44: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x145d48: 0xdba20c00
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3072)));
    // 0x145d4c: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x145d50: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x145d54: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x145d58: 0xfba30c10
    WRITE128(ADD32(GPR_U32(ctx, 29), 3088), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x145d5c: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x145d60: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x145d64: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145d68: 0x24420030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 48));
    // 0x145d6c: 0x1620fff4
    WRITE128(ADD32(GPR_U32(ctx, 29), 3072), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_145d40;
    }
label_145d74:
    // 0x145d74: 0x8fa40c2c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 3116)));
    // 0x145d78: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x145d7c: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x145d84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_145d84
// Address: 0x145d84 - 0x145d8c

void entry_145d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145d84: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x145d8c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_145d8c
// Address: 0x145d8c - 0x145dd8

void entry_145d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x145d8c) {
        switch (ctx->pc) {
            case 0x145da0: ctx->pc = 0; goto label_145da0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x145d8c: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x145d90: 0xdba20c00
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 3072)));
    // 0x145d94: 0x8fa70c28
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 3112)));
    // 0x145d98: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145d9c: 0xf8e10000
    WRITE128(ADD32(GPR_U32(ctx, 7), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_145da0:
    // 0x145da0: 0x7bbf0cc0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 3264)));
    // 0x145da4: 0x7bbe0cb0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 3248)));
    // 0x145da8: 0x7bb70ca0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 3232)));
    // 0x145dac: 0x7bb60c90
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 3216)));
    // 0x145db0: 0x7bb50c80
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 3200)));
    // 0x145db4: 0x7bb40c70
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 3184)));
    // 0x145db8: 0x7bb30c60
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 3168)));
    // 0x145dbc: 0x7bb20c50
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 3152)));
    // 0x145dc0: 0x7bb10c40
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 3136)));
    // 0x145dc4: 0x7bb00c30
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 3120)));
    // 0x145dc8: 0xc7b50cd8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3288)); ctx->f[21] = *(float*)&val; }
    // 0x145dcc: 0xc7b40cd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 3280)); ctx->f[20] = *(float*)&val; }
    // 0x145dd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 3296));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00145DD8
// Address: 0x145dd8 - 0x145de8

void FUN_00145DD8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145dd8: 0x8ca20538
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1336)));
    // 0x145ddc: 0x3e00008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x145de4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145de8; return;
}


// Function: FUN_00145de8
// Address: 0x145de8 - 0x145e2c

void FUN_00145de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145de8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x145dec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x145df0: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x145df4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x145df8: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x145dfc: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x145e00: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x145e04: 0xc44d194c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6476)); ctx->f[13] = *(float*)&val; }
    // 0x145e08: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x145e0c: 0xc48001ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 492)); ctx->f[0] = *(float*)&val; }
    // 0x145e10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x145e14: 0xc44e186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[14] = *(float*)&val; }
    // 0x145e18: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x145e1c: 0x460d0341
    ctx->f[13] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x145e20: 0xc62c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[12] = *(float*)&val; }
    // 0x145e24: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x145e2c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6488));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_145e2c
// Address: 0x145e2c - 0x145e68

void entry_145e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145e2c: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x145e30: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x145e34: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x145e38: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x145e3c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x145e40: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145e44: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x145e48: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x145e4c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x145e50: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x145e54: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x145e58: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x145e5c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x145e60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00145e68
// Address: 0x145e68 - 0x145ee8

void FUN_00145e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145e68: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x145e6c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x145e70: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x145e74: 0x24631980
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6528));
    // 0x145e78: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x145e7c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x145e80: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x145e84: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x145e88: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x145e8c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x145e90: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x145e94: 0x24421970
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6512));
    // 0x145e98: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x145e9c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x145ea0: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x145ea4: 0xe0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x145ea8: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x145eac: 0xd8c30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x145eb0: 0x4be208a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145eb4: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x145eb8: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x145ebc: 0xd8440000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x145ec0: 0x48a52800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x145ec4: 0x4a6503bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x145ec8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x145ecc: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x145ed0: 0x4be40868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145ed4: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x145ed8: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x145edc: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x145ee0: 0xc063582
    SET_GPR_U32(ctx, 31, 0x145ee8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_145ee8
// Address: 0x145ee8 - 0x145f14

void entry_145ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145ee8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x145eec: 0x3c080014
    SET_GPR_U32(ctx, 8, ((uint32_t)20 << 16));
    // 0x145ef0: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x145ef4: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x145ef8: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x145efc: 0x27aa0050
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 80));
    // 0x145f00: 0x27ab0054
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 84));
    // 0x145f04: 0x25085dd8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 24024));
    // 0x145f08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x145f0c: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x145f14);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_145f14
// Address: 0x145f14 - 0x145f74

void entry_145f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145f14: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145f18: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x145f1c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145f20: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x145f24: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145f28: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145f2c: 0xc4401950
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6480)); ctx->f[0] = *(float*)&val; }
    // 0x145f30: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x145f34: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x145f38: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x145f3c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x145f40: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x145f44: 0xc44c194c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6476)); ctx->f[12] = *(float*)&val; }
    // 0x145f48: 0x44836800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 3);
    // 0x145f4c: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x145f50: 0x46006b40
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[0]);
    // 0x145f54: 0x8fa60054
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x145f58: 0x3c070014
    SET_GPR_U32(ctx, 7, ((uint32_t)20 << 16));
    // 0x145f5c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x145f60: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x145f64: 0x24e75de8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 24040));
    // 0x145f68: 0x3a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x145f6c: 0xc0516da
    SET_GPR_U32(ctx, 31, 0x145f74);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 16));
    FUN_00145b68(rdram, ctx, runtime); return;
}


// Function: entry_145f74
// Address: 0x145f74 - 0x145f98

void entry_145f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145f74: 0x8e100014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x145f78: 0x48b01800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x145f7c: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x145f80: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x145f84: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x145f88: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x145f8c: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x145f90: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x145f98);
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_145f98
// Address: 0x145f98 - 0x145fb8

void entry_145f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145f98: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x145f9c: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x145fa0: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x145fa4: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x145fa8: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x145fac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x145fb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145fb8; return;
}


// Function: PushLookkCm__FP2CM5LOOKK
// Address: 0x145fb8 - 0x145fc8

void entry_145fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145fc8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145fcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x145fd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145fd8; return;
}


// Function: LookkPopCm__FP2CM
// Address: 0x145fd8 - 0x145fe8

void entry_145fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x145fe8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x145fec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x145ff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x145ff8; return;
}


// Function: LookkCurCm__FP2CM
// Address: 0x145ff8 - 0x146008

void entry_146008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146008: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14600c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x146014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x146018; return;
}


// Function: SetCmSniperFocus__FP2CMP3PNTff
// Address: 0x146018 - 0x146028

void FUN_00146028__FP2CM(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146028: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14602c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x146030: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 536), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00146038
// Address: 0x146038 - 0x1460a4

void FUN_00146038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146038: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x14603c: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x146040: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x146044: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x146048: 0x4be00153
    // Unhandled VU0 Special1 function: 0x13
    // 0x14604c: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146050: 0xd8a20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x146054: 0xd8810040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x146058: 0x4be111ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14605c: 0xd8830050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 80)));
    // 0x146060: 0xd8820060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 96)));
    // 0x146064: 0xd8810070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 112)));
    // 0x146068: 0x4be619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x14606c: 0x4be610bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x146070: 0x4be608be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x146074: 0x4be428fc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x146078: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14607c: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146080: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146084: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146088: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x14608c: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x146090: 0x14400005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1460A8; return;
    }
    // 0x146098: 0x48253000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x14609c: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x1460a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_1460a4
// Address: 0x1460a4 - 0x1460b8

void entry_1460a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1460a4) {
        switch (ctx->pc) {
            case 0x1460a8: ctx->pc = 0; goto label_1460a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1460a4: 0x2182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1460a8:
    // 0x1460a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1460ac: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1460b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: cm__static_initialization_and_destruction_0__Fii
// Address: 0x1460b8 - 0x1460e0

void FUN_001460e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1460e0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1460e4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1460e8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1460ec: 0xc05182e
    SET_GPR_U32(ctx, 31, 0x1460f4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    cm__static_initialization_and_destruction_0__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1460f4
// Address: 0x1460f4 - 0x146100

void entry_1460f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1460f4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1460f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCnvo__FP4CNVO
// Address: 0x146100 - 0x146114

void entry_146114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146114: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x146118: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14611c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146120: 0xe6000550
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1360), *(uint32_t*)&val); }
    // 0x146124: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146128: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadCnvoFromBrx__FP4CNVOP18CBinaryInputStream
// Address: 0x146130 - 0x14614c

void entry_14614c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14614c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x146154);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_146154
// Address: 0x146154 - 0x146160

void entry_146154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146154: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x146158: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x146160);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1364), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_146160
// Address: 0x146160 - 0x146178

void entry_146160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146160: 0xe6200558
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
    // 0x146164: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x146168: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14616c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostCnvoLoad__FP4CNVO
// Address: 0x146178 - 0x14618c

void entry_14618c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14618c: 0xc0518a6
    SET_GPR_U32(ctx, 31, 0x146194);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MatchCnvoScrollerToBeltSpeed__FP4CNVO(rdram, ctx, runtime); return;
}


// Function: entry_146194
// Address: 0x146194 - 0x1461a8

void entry_146194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146194: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146198: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14619c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1461a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1461a8; return;
}


// Function: AdjustCnvoXpVelocity__FP4CNVOP2XPi
// Address: 0x1461a8 - 0x146240

void entry_146278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146278: 0xc0518a6
    SET_GPR_U32(ctx, 31, 0x146280);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MatchCnvoScrollerToBeltSpeed__FP4CNVO(rdram, ctx, runtime); return;
}


// Function: entry_146280
// Address: 0x146280 - 0x146288

void entry_146280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146280: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x146288);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_146288
// Address: 0x146288 - 0x146298

void entry_146288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146288) {
        switch (ctx->pc) {
            case 0x14628c: ctx->pc = 0; goto label_14628c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146288: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14628c:
    // 0x14628c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146290: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MatchCnvoScrollerToBeltSpeed__FP4CNVO
// Address: 0x146298 - 0x146340

void entry_146370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146370: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x146374: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x146378: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x146380);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7252));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_146380
// Address: 0x146380 - 0x14638c

void entry_146380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146380: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x146384: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x14638c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_14638c
// Address: 0x14638c - 0x1463c0

void entry_14638c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14638c: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x146390: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x146394: 0xae030340
    WRITE32(ADD32(GPR_U32(ctx, 16), 832), GPR_U32(ctx, 3));
    // 0x146398: 0xae02037c
    WRITE32(ADD32(GPR_U32(ctx, 16), 892), GPR_U32(ctx, 2));
    // 0x14639c: 0xa20402b3
    WRITE8(ADD32(GPR_U32(ctx, 16), 691), (uint8_t)GPR_U32(ctx, 4));
    // 0x1463a0: 0xa20402b2
    WRITE8(ADD32(GPR_U32(ctx, 16), 690), (uint8_t)GPR_U32(ctx, 4));
    // 0x1463a4: 0xa20402b1
    WRITE8(ADD32(GPR_U32(ctx, 16), 689), (uint8_t)GPR_U32(ctx, 4));
    // 0x1463a8: 0xa20402b0
    WRITE8(ADD32(GPR_U32(ctx, 16), 688), (uint8_t)GPR_U32(ctx, 4));
    // 0x1463ac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1463b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1463b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1463bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1463c0; return;
}


// Function: LoadDprizeFromBrx__FP6DPRIZEP18CBinaryInputStream
// Address: 0x1463c0 - 0x1463e0

void entry_1463e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1463e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1463e4: 0xc04a270
    SET_GPR_U32(ctx, 31, 0x1463ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadAloFromBrx__FP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1463ec
// Address: 0x1463ec - 0x146400

void entry_1463ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1463ec: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1463f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1463f4: 0x24c619a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 6560));
    // 0x1463f8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x146400);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_146400
// Address: 0x146400 - 0x146418

void entry_146400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146400: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x146404: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146408: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14640c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x146414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x146418; return;
}


// Function: CloneDprize__FP6DPRIZET0
// Address: 0x146418 - 0x146448

void entry_146448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146448: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x14644c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x146450: 0xb202037b
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 891); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x146454: 0xb6020374
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 884); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x146458: 0xae11037c
    WRITE32(ADD32(GPR_U32(ctx, 16), 892), GPR_U32(ctx, 17));
    // 0x14645c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x146460: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x146464: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146468: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostDprizeLoad__FP6DPRIZE
// Address: 0x146470 - 0x146484

void entry_146484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146484: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x146488: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14648c: 0x24060075
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 117));
    // 0x146490: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x146498);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_146498
// Address: 0x146498 - 0x1464b4

void entry_146498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146498: 0x10400006
    WRITE32(ADD32(GPR_U32(ctx, 16), 748), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1464b4(rdram, ctx, runtime); return;
    }
    // 0x1464a0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1464a4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1464a8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1464ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1464b4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1464b4
// Address: 0x1464b4 - 0x1464e4

void entry_1464b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1464b4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1464b8: 0x24050308
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 776));
    // 0x1464bc: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1464c0: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1464c4: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1464c8: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1464cc: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1464d0: 0x10450007
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x1464F0; return;
    }
    // 0x1464d8: 0x8e05037c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 892)));
    // 0x1464dc: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1464e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1464e4
// Address: 0x1464e4 - 0x146504

void entry_1464e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1464e4) {
        switch (ctx->pc) {
            case 0x1464f0: ctx->pc = 0; goto label_1464f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1464e4: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1464f0;
    }
    // 0x1464ec: 0xae0202d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 2));
label_1464f0:
    // 0x1464f0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1464f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1464f8: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1464fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x146504);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 728)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_146504
// Address: 0x146504 - 0x146518

void entry_146504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146504: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146508: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14650c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x146514: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x146518; return;
}


// Function: ProjectDprizeTransform__FP6DPRIZEfi
// Address: 0x146518 - 0x14659c

void entry_14659c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14659c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1465a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1465a4: 0x24421a00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6656));
    // 0x1465a8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1465ac: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1465b0: 0x8ec20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x1465b4: 0xc44c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 276)); ctx->f[12] = *(float*)&val; }
    // 0x1465b8: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1465c0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1465c0
// Address: 0x1465c0 - 0x1465c8

void entry_1465c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1465c0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1465c8);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1465c8
// Address: 0x1465c8 - 0x146674

void entry_1465c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1465c8) {
        switch (ctx->pc) {
            case 0x146610: ctx->pc = 0; goto label_146610;
            case 0x146650: ctx->pc = 0; goto label_146650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1465c8: 0x3c01417b
    SET_GPR_U32(ctx, 1, ((uint32_t)16763 << 16));
    // 0x1465cc: 0x342153d2
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 21458));
    // 0x1465d0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1465d4: 0xc66102f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 752)); ctx->f[1] = *(float*)&val; }
    // 0x1465d8: 0x46020080
    ctx->f[2] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1465dc: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1465e0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1465e4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1465e8: 0x46011041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1465ec: 0x46030800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1465f0: 0x46000845
    ctx->f[1] = FPU_ABS_S(ctx->f[1]);
    // 0x1465f4: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1465f8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1465fc: 0x0
    // NOP
    // 0x146600: 0x45000003
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_146610;
    }
    // 0x146608: 0x46031000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x14660c: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
label_146610:
    // 0x146610: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x146614: 0x27a30050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 80));
    // 0x146618: 0x24551a20
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 6688));
    // 0x14661c: 0x26640360
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 864));
    // 0x146620: 0x27a20020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 32));
    // 0x146624: 0xafa30120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 3));
    // 0x146628: 0xafa2011c
    WRITE32(ADD32(GPR_U32(ctx, 29), 284), GPR_U32(ctx, 2));
    // 0x14662c: 0x27b70010
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 16));
    // 0x146630: 0x27a20080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 128));
    // 0x146634: 0xafa40124
    WRITE32(ADD32(GPR_U32(ctx, 29), 292), GPR_U32(ctx, 4));
    // 0x146638: 0xafa20118
    WRITE32(ADD32(GPR_U32(ctx, 29), 280), GPR_U32(ctx, 2));
    // 0x14663c: 0x267e0034
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 52));
    // 0x146640: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x146644: 0x26710300
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 768));
    // 0x146648: 0x267002f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 752));
    // 0x14664c: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
label_146650:
    // 0x146650: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x146654: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x146658: 0xc62d0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[13] = *(float*)&val; }
    // 0x14665c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x146660: 0xc64e0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[14] = *(float*)&val; }
    // 0x146664: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x146668: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x14666c: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x146674);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_146674
// Address: 0x146674 - 0x1466b0

void entry_146674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146674: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x146678: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x14667c: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x146680: 0x681fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x146650; return;
    }
    // 0x146688: 0x7bb10000
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14668c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146690: 0x7a7002f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 19), 752)));
    // 0x146694: 0x44916000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 17);
    // 0x146698: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14669c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1466a0: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1466a4: 0x44906800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 16);
    // 0x1466a8: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1466b0);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1466b0
// Address: 0x1466b0 - 0x1466dc

void entry_1466b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1466b0: 0x10400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14670C; return;
    }
    // 0x1466b8: 0x70111fc9
    SET_GPR_VEC(ctx, 3, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1466bc: 0x701027c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x1466c0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1466c4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1466c8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1466cc: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x1466d0: 0x44846800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 4);
    // 0x1466d4: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1466dc);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1466dc
// Address: 0x1466dc - 0x146708

void entry_1466dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1466dc: 0x1040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14670C; return;
    }
    // 0x1466e4: 0x701114a8
    SET_GPR_VEC(ctx, 2, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    // 0x1466e8: 0x70101ca8
    SET_GPR_VEC(ctx, 3, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    // 0x1466ec: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1466f0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1466f4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1466f8: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1466fc: 0x44836800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 3);
    // 0x146700: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x146708);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_146708
// Address: 0x146708 - 0x14672c

void entry_146708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146708) {
        switch (ctx->pc) {
            case 0x14670c: ctx->pc = 0; goto label_14670c;
            case 0x146718: ctx->pc = 0; goto label_146718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146708: 0x2902b
    SET_GPR_U32(ctx, 18, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_14670c:
    // 0x14670c: 0x12400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_146718;
    }
    // 0x146714: 0xae620370
    WRITE32(ADD32(GPR_U32(ctx, 19), 880), GPR_U32(ctx, 2));
label_146718:
    // 0x146718: 0xc66d02f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 756)); ctx->f[13] = *(float*)&val; }
    // 0x14671c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x146720: 0xc66e02f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 760)); ctx->f[14] = *(float*)&val; }
    // 0x146724: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x14672c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 752)); ctx->f[12] = *(float*)&val; }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_14672c
// Address: 0x14672c - 0x146780

void entry_14672c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14672c: 0x8ec20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x146730: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x146734: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146738: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x14673c: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x146740: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x146744: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x146748: 0x8fa5011c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x14674c: 0xc44119e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6624)); ctx->f[1] = *(float*)&val; }
    // 0x146750: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x146754: 0xfa620100
    WRITE128(ADD32(GPR_U32(ctx, 19), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x146758: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x14675c: 0x7e620150
    WRITE128(ADD32(GPR_U32(ctx, 19), 336), GPR_VEC(ctx, 2));
    // 0x146760: 0x8ec30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x146764: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x146768: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14676c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146770: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x146774: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x146778: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x146780);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_146780
// Address: 0x146780 - 0x146798

void entry_146780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146780: 0x8fa50120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x146784: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x146788: 0x3c01c020
    SET_GPR_U32(ctx, 1, ((uint32_t)49184 << 16));
    // 0x14678c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x146790: 0xc062214
    SET_GPR_U32(ctx, 31, 0x146798);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937856));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_146798
// Address: 0x146798 - 0x146814

void entry_146798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146798: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14679c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1467a0: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1467a4: 0x24841a10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6672));
    // 0x1467a8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1467ac: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1467b0: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1467b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1467b8: 0xdba50060
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1467bc: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1467c0: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1467c4: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1467c8: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1467cc: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1467d0: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1467d4: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1467d8: 0xc66c035c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 860)); ctx->f[12] = *(float*)&val; }
    // 0x1467dc: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1467e0: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1467e4: 0x4bc4088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1467e8: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1467ec: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1467f0: 0xfba50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1467f4: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1467f8: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1467fc: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146800: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146804: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146808: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14680c: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x146814);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_146814
// Address: 0x146814 - 0x146828

void entry_146814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146814: 0x8fa40124
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x146818: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x14681c: 0x8fa50118
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x146820: 0xc062214
    SET_GPR_U32(ctx, 31, 0x146828);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 860), *(uint32_t*)&val); }
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_146828
// Address: 0x146828 - 0x146894

void entry_146828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146828) {
        switch (ctx->pc) {
            case 0x14688c: ctx->pc = 0; goto label_14688c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146828: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14682c: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x146830: 0xdba200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x146834: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x146838: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14683c: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x146840: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x146844: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146848: 0xdba60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14684c: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x146850: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x146854: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146858: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x14685c: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x146860: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146864: 0xfa6300d0
    WRITE128(ADD32(GPR_U32(ctx, 19), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146868: 0xfa6500e0
    WRITE128(ADD32(GPR_U32(ctx, 19), 224), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14686c: 0xfa6100f0
    WRITE128(ADD32(GPR_U32(ctx, 19), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146870: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146874: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146878: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14687c: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146880: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146884: 0x1000008c
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146AB8; return;
    }
label_14688c:
    // 0x14688c: 0xc064a7e
    SET_GPR_U32(ctx, 31, 0x146894);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 208));
    PpziCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_146894
// Address: 0x146894 - 0x1468d8

void entry_146894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146894: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x146898: 0xc67402d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 724)); ctx->f[20] = *(float*)&val; }
    // 0x14689c: 0xc48019e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 6632)); ctx->f[0] = *(float*)&val; }
    // 0x1468a0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1468a4: 0xc461185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1468a8: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1468ac: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1468b0: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1468b4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1468b8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1468bc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1468c0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1468c4: 0x4601a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1468c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1468cc: 0x267e0034
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 52));
    // 0x1468d0: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1468d8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1468d8
// Address: 0x1468d8 - 0x1468ec

void entry_1468d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1468d8: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1468dc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1468e0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1468e4: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1468ec);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1468ec
// Address: 0x1468ec - 0x146900

void entry_1468ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1468ec: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1468f0: 0x27a50110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1468f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1468f8: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x146900);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_146900
// Address: 0x146900 - 0x14691c

void entry_146900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146900: 0x4615a528
    ctx->f[20] = std::max(ctx->f[20], ctx->f[21]);
    // 0x146904: 0xc7ac0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[12] = *(float*)&val; }
    // 0x146908: 0x4614ad03
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[20] = ctx->f[21] / ctx->f[20];
    // 0x14690c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x146910: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x146914: 0xc062214
    SET_GPR_U32(ctx, 31, 0x14691c);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14691c
// Address: 0x14691c - 0x1469fc

void entry_14691c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14691c) {
        switch (ctx->pc) {
            case 0x1469b8: ctx->pc = 0; goto label_1469b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14691c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x146920: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x146924: 0xda6500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 208)));
    // 0x146928: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14692c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x146930: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x146934: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x146938: 0xda460020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x14693c: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x146940: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x146944: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146948: 0xda470010
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x14694c: 0x4bc611bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x146950: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x146954: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146958: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14695c: 0x4bc711bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x146960: 0x4bc720bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x146964: 0x4bc7088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146968: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x14696c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x146970: 0x48a44000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x146974: 0xda630100
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 256)));
    // 0x146978: 0x48a24800
    ctx->vu0_vf[9] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x14697c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146980: 0xfba80080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x146984: 0x4be809bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x146988: 0x4be91848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14698c: 0xfa6500d0
    WRITE128(ADD32(GPR_U32(ctx, 19), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146990: 0xfa6200e0
    WRITE128(ADD32(GPR_U32(ctx, 19), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x146994: 0xfa6600f0
    WRITE128(ADD32(GPR_U32(ctx, 19), 240), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x146998: 0xfa610100
    WRITE128(ADD32(GPR_U32(ctx, 19), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14699c: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1469a0: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1469a4: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1469a8: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1469ac: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1469b0: 0x10000041
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[9]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146AB8; return;
    }
label_1469b8:
    // 0x1469b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1469bc: 0x8c492e10
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1469c0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1469c4: 0xc461185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1469c8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1469cc: 0xc52c2424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 9252)); ctx->f[12] = *(float*)&val; }
    // 0x1469d0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1469d4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1469d8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1469dc: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x1469e0: 0x8d2423d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 9172)));
    // 0x1469e4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1469e8: 0x267e0034
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 52));
    // 0x1469ec: 0x46006328
    ctx->f[12] = std::max(ctx->f[12], ctx->f[0]);
    // 0x1469f0: 0x46156500
    ctx->f[20] = FPU_ADD_S(ctx->f[12], ctx->f[21]);
    // 0x1469f4: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1469fc);
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[20] = ctx->f[21] / ctx->f[20];
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1469fc
// Address: 0x1469fc - 0x146b0c

void entry_1469fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1469fc) {
        switch (ctx->pc) {
            case 0x146a38: ctx->pc = 0; goto label_146a38;
            case 0x146a48: ctx->pc = 0; goto label_146a48;
            case 0x146a64: ctx->pc = 0; goto label_146a64;
            case 0x146a6c: ctx->pc = 0; goto label_146a6c;
            case 0x146ab8: ctx->pc = 0; goto label_146ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1469fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x146a00: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x146a04: 0xda640100
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 256)));
    // 0x146a08: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146a0c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x146a10: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x146a14: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x146a18: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x146a1c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x146a20: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x146a24: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x146a28: 0x4be12088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146a2c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146a30: 0x10000021
    WRITE128(ADD32(GPR_U32(ctx, 19), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_146ab8;
    }
label_146a38:
    // 0x146a38: 0x10600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_146a48;
    }
    // 0x146a40: 0x14620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_146a64;
    }
label_146a48:
    // 0x146a48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x146a4c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x146a50: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x146a54: 0xc44019dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6620)); ctx->f[0] = *(float*)&val; }
    // 0x146a58: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x146a5c: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_146a6c;
    }
label_146a64:
    // 0x146a64: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x146a68: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_146a6c:
    // 0x146a6c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x146a70: 0x267e0034
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 52));
    // 0x146a74: 0xda620300
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 768)));
    // 0x146a78: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x146a7c: 0xda610310
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 784)));
    // 0x146a80: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x146a84: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x146a88: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x146a8c: 0x4be411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x146a90: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146a94: 0xda6102f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 752)));
    // 0x146a98: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146a9c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x146aa0: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146aa4: 0xfa610100
    WRITE128(ADD32(GPR_U32(ctx, 19), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146aa8: 0xfa620150
    WRITE128(ADD32(GPR_U32(ctx, 19), 336), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x146aac: 0xfa620300
    WRITE128(ADD32(GPR_U32(ctx, 19), 768), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x146ab0: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146ab4: 0xfa6102f0
    WRITE128(ADD32(GPR_U32(ctx, 19), 752), _mm_castps_si128(ctx->vu0_vf[1]));
label_146ab8:
    // 0x146ab8: 0x8e6202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 744)));
    // 0x146abc: 0x50400060
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 30));
        ctx->pc = 0x146C40; return;
    }
    // 0x146ac4: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x146ac8: 0x5040005d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 30));
        ctx->pc = 0x146C40; return;
    }
    // 0x146ad0: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x146ad4: 0x8c43009c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 156)));
    // 0x146ad8: 0x10600058
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146C3C; return;
    }
    // 0x146ae0: 0xda620100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 256)));
    // 0x146ae4: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x146ae8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x146aec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x146af0: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x146af4: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x146af8: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x146afc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146b00: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146b04: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x146b0c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_146b0c
// Address: 0x146b0c - 0x146b48

void entry_146b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146b0c: 0x8e6202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 744)));
    // 0x146b10: 0x8c470024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x146b14: 0x8ce30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x146b18: 0x8c62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 156)));
    // 0x146b1c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x146b20: 0x1080001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146B8C; return;
    }
    // 0x146b28: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x146b2c: 0xc4ed0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[13] = *(float*)&val; }
    // 0x146b30: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146b34: 0xc4ec0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[12] = *(float*)&val; }
    // 0x146b38: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x146b3c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x146b40: 0x60f809
    SET_GPR_U32(ctx, 31, 0x146b48);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_146b48
// Address: 0x146b48 - 0x146bc8

void entry_146b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146b48) {
        switch (ctx->pc) {
            case 0x146b8c: ctx->pc = 0; goto label_146b8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146b48: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x146b4c: 0xdba60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x146b50: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x146b54: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146b58: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x146b5c: 0x4bc331bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x146b60: 0x4bc328bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x146b64: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146b68: 0x4bc431bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x146b6c: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x146b70: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146b74: 0xda610100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 256)));
    // 0x146b78: 0xda620150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 336)));
    // 0x146b7c: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146b80: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x146b84: 0xfa610100
    WRITE128(ADD32(GPR_U32(ctx, 19), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146b88: 0xfa620150
    WRITE128(ADD32(GPR_U32(ctx, 19), 336), _mm_castps_si128(ctx->vu0_vf[2]));
label_146b8c:
    // 0x146b8c: 0x8e6202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 744)));
    // 0x146b90: 0x8c470024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x146b94: 0x8ce30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x146b98: 0x8c62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 156)));
    // 0x146b9c: 0x8c440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x146ba0: 0x10800026
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146C3C; return;
    }
    // 0x146ba8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x146bac: 0xc4ed0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[13] = *(float*)&val; }
    // 0x146bb0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146bb4: 0xc4ec0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[12] = *(float*)&val; }
    // 0x146bb8: 0x27a80030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 48));
    // 0x146bbc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x146bc0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x146bc8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_146bc8
// Address: 0x146bc8 - 0x146c90

void entry_146bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146bc8) {
        switch (ctx->pc) {
            case 0x146c3c: ctx->pc = 0; goto label_146c3c;
            case 0x146c40: ctx->pc = 0; goto label_146c40;
            case 0x146c70: ctx->pc = 0; goto label_146c70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146bc8: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x146bcc: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x146bd0: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x146bd4: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x146bd8: 0xdba60080
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x146bdc: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x146be0: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x146be4: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146be8: 0xdba70090
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x146bec: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x146bf0: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x146bf4: 0x4bc6118a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146bf8: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x146bfc: 0x4bc721bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x146c00: 0x4bc718bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x146c04: 0x4bc711ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146c08: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x146c0c: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146c10: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146c14: 0xfa6500d0
    WRITE128(ADD32(GPR_U32(ctx, 19), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146c18: 0xfa6600e0
    WRITE128(ADD32(GPR_U32(ctx, 19), 224), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x146c1c: 0xfa6700f0
    WRITE128(ADD32(GPR_U32(ctx, 19), 240), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x146c20: 0xfa610160
    WRITE128(ADD32(GPR_U32(ctx, 19), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146c24: 0xfba500d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146c28: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x146c2c: 0xfba600e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x146c30: 0xfba600b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x146c34: 0xfba700f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x146c38: 0xfba700c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[7]));
label_146c3c:
    // 0x146c3c: 0xafbe0004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 30));
label_146c40:
    // 0x146c40: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x146c44: 0xafbe0000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 30));
    // 0x146c48: 0x8fc20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 8)));
    // 0x146c4c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x146c50: 0x8c83b314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x146c54: 0xafa3000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 3));
    // 0x146c58: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x146c5c: 0x8e630034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    // 0x146c60: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x146c64: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x146c68: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146CA8; return;
    }
label_146c70:
    // 0x146c70: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x146c74: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x146c78: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x146c7c: 0x10400004
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_146c90(rdram, ctx, runtime); return;
    }
    // 0x146c84: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x146c88: 0x40f809
    SET_GPR_U32(ctx, 31, 0x146c90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_146c90
// Address: 0x146c90 - 0x146ccc

void entry_146c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146c90) {
        switch (ctx->pc) {
            case 0x146ca8: ctx->pc = 0; goto label_146ca8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146c90: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x146c94: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x146c98: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x146c9c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x146ca0: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146C70; return;
    }
label_146ca8:
    // 0x146ca8: 0x8fa20114
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x146cac: 0x14400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146CD0; return;
    }
    // 0x146cb4: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x146cb8: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x146cbc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
        ctx->pc = 0x146CD0; return;
    }
    // 0x146cc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x146ccc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_146ccc
// Address: 0x146ccc - 0x146d10

void entry_146ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146ccc) {
        switch (ctx->pc) {
            case 0x146cd0: ctx->pc = 0; goto label_146cd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146ccc: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_146cd0:
    // 0x146cd0: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x146cd4: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x146cd8: 0x7bbe01b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x146cdc: 0x7bb701a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x146ce0: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x146ce4: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x146ce8: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x146cec: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x146cf0: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x146cf4: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x146cf8: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x146cfc: 0xc7b501d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[21] = *(float*)&val; }
    // 0x146d00: 0xc7b401d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[20] = *(float*)&val; }
    // 0x146d04: 0xac62b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 2));
    // 0x146d08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFilterDprizeObjects__FP6DPRIZEP2SO
// Address: 0x146d10 - 0x146d44

void entry_146d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146d44: 0x14400016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146DA0; return;
    }
    // 0x146d4c: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x146d50: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x146d58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 39));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_146d58
// Address: 0x146d58 - 0x146d6c

void entry_146d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146d58: 0x14400011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146DA0; return;
    }
    // 0x146d60: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x146d64: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x146d6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 59));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_146d6c
// Address: 0x146d6c - 0x146d80

void entry_146d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146d6c: 0x1440000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146DA0; return;
    }
    // 0x146d74: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x146d78: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x146d80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_146d80
// Address: 0x146d80 - 0x146d94

void entry_146d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146d80: 0x14400007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146DA0; return;
    }
    // 0x146d88: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x146d8c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x146d94);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 46));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_146d94
// Address: 0x146d94 - 0x146db0

void entry_146d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146d94) {
        switch (ctx->pc) {
            case 0x146da0: ctx->pc = 0; goto label_146da0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146d94: 0x14400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_146da0;
    }
    // 0x146d9c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_146da0:
    // 0x146da0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x146da4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x146da8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CheckDprizeBounce__FP6DPRIZE
// Address: 0x146db0 - 0x146dd4

void entry_146dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x146dd4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x146dd8: 0xc600034c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 844)); ctx->f[0] = *(float*)&val; }
    // 0x146ddc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x146de0: 0x24428d40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937920));
    // 0x146de4: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x146de8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x146dec: 0x3c080014
    SET_GPR_U32(ctx, 8, ((uint32_t)20 << 16));
    // 0x146df0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x146df4: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x146df8: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x146dfc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146e00: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x146e04: 0x4be51108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146e08: 0x25086d10
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 27920));
    // 0x146e0c: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x146e10: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x146e14: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x146e18: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x146e1c: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146e20: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x146e24: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146e28: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x146e2c: 0x27aa0200
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 512));
    // 0x146e30: 0x27ab0204
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 516));
    // 0x146e34: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x146e38: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146e3c: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x146e40: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x146e48);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_146e48
// Address: 0x146e48 - 0x146f98

void entry_146e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146e48) {
        switch (ctx->pc) {
            case 0x146e60: ctx->pc = 0; goto label_146e60;
            case 0x146f24: ctx->pc = 0; goto label_146f24;
            case 0x146f30: ctx->pc = 0; goto label_146f30;
            case 0x146f70: ctx->pc = 0; goto label_146f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146e48: 0x8fa20200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x146e4c: 0x18400070
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x147010; return;
    }
    // 0x146e54: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x146e58: 0x24528d00
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x146e5c: 0x8fa20204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 516)));
label_146e60:
    // 0x146e60: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x146e64: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x146e68: 0x42678
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 25);
    // 0x146e6c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x146e70: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x146e74: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x146e78: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x146e7c: 0x1040003c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_146f70;
    }
    // 0x146e84: 0xd8630140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x146e88: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x146e8c: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x146e90: 0xc46203cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 972)); ctx->f[2] = *(float*)&val; }
    // 0x146e94: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146e98: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x146e9c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146ea0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146ea4: 0xc601034c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 844)); ctx->f[1] = *(float*)&val; }
    // 0x146ea8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146eac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146eb0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x146eb4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146eb8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x146ebc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x146ec0: 0x46010081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x146ec4: 0x46141034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x146ec8: 0x0
    // NOP
    // 0x146ecc: 0x4500004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 512)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x147000; return;
    }
    // 0x146ed4: 0xda0102f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 752)));
    // 0x146ed8: 0x4be308ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146edc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x146ee0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x146ee4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x146ee8: 0x4bc318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x146eec: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x146ef0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x146ef4: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146ef8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x146efc: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x146f00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146f04: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x146f08: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146f0c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x146f10: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x146f14: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_146f24;
    }
    // 0x146f1c: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_146f30;
    }
label_146f24:
    // 0x146f24: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x146f28: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x146f2c: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_146f30:
    // 0x146f30: 0xda010300
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 768)));
    // 0x146f34: 0x24b10001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 5), 1));
    // 0x146f38: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146f3c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x146f40: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146f44: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146f48: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x146f4c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146f50: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x146f54: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x146f58: 0x0
    // NOP
    // 0x146f5c: 0x45000027
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x146FFC; return;
    }
    // 0x146f64: 0x46001506
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    // 0x146f68: 0x10000024
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146FFC; return;
    }
label_146f70:
    // 0x146f70: 0x8c6603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 1016)));
    // 0x146f74: 0x10c00021
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 932));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x146FFC; return;
    }
    // 0x146f7c: 0x8c6503f0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 1008)));
    // 0x146f80: 0xc60c034c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 844)); ctx->f[12] = *(float*)&val; }
    // 0x146f84: 0x26040140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    // 0x146f88: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x146f8c: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x146f90: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x146f98);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 64));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_146f98
// Address: 0x146f98 - 0x147064

void entry_146f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x146f98) {
        switch (ctx->pc) {
            case 0x146fa8: ctx->pc = 0; goto label_146fa8;
            case 0x146ff4: ctx->pc = 0; goto label_146ff4;
            case 0x146ffc: ctx->pc = 0; goto label_146ffc;
            case 0x147000: ctx->pc = 0; goto label_147000;
            case 0x147010: ctx->pc = 0; goto label_147010;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x146f98: 0x18400018
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_146ffc;
    }
    // 0x146fa0: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x146fa4: 0x0
    // NOP
label_146fa8:
    // 0x146fa8: 0xc4610020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 32)); ctx->f[1] = *(float*)&val; }
    // 0x146fac: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x146fb0: 0x0
    // NOP
    // 0x146fb4: 0x4502000f
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
        goto label_146ff4;
    }
    // 0x146fbc: 0xda010300
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 768)));
    // 0x146fc0: 0xd8630010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x146fc4: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146fc8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x146fcc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x146fd0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x146fd4: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x146fd8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x146fdc: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x146fe0: 0x0
    // NOP
    // 0x146fe4: 0x45000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_146ff4;
    }
    // 0x146fec: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x146ff0: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
label_146ff4:
    // 0x146ff4: 0x1440ffec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 48));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_146fa8;
    }
label_146ffc:
    // 0x146ffc: 0x8fa20200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 512)));
label_147000:
    // 0x147000: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147004: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x147008: 0x1440ff95
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 516)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x146E60; return;
    }
label_147010:
    // 0x147010: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x147014: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147018: 0x0
    // NOP
    // 0x14701c: 0x45000059
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x147184; return;
    }
    // 0x147024: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x147028: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x14702c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x147030: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147034: 0x0
    // NOP
    // 0x147038: 0x45000035
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x147110; return;
    }
    // 0x147040: 0x8e0302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x147044: 0x14620033
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 768));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x147114; return;
    }
    // 0x14704c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x147050: 0x24518d20
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x147054: 0x27a601c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 448));
    // 0x147058: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14705c: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x147064);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 464));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_147064
// Address: 0x147064 - 0x147124

void entry_147064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147064) {
        switch (ctx->pc) {
            case 0x1470d4: ctx->pc = 0; goto label_1470d4;
            case 0x147110: ctx->pc = 0; goto label_147110;
            case 0x147114: ctx->pc = 0; goto label_147114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147064: 0xc6010354
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 852)); ctx->f[1] = *(float*)&val; }
    // 0x147068: 0x8e020358
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 856)));
    // 0x14706c: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x147070: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x147074: 0x8e02033c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 828)));
    // 0x147078: 0xdba301c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x14707c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x147080: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x147084: 0xdba201d0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x147088: 0x4be119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14708c: 0x4be41088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147090: 0xfba101f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147094: 0xfba401f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x147098: 0x1440002f
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x147158; return;
    }
    // 0x1470a0: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1470a4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1470a8: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1470ac: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1470b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1470b4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1470b8: 0xc6010348
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 840)); ctx->f[1] = *(float*)&val; }
    // 0x1470bc: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1470c0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1470c4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1470c8: 0x0
    // NOP
    // 0x1470cc: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1470d4;
    }
label_1470d4:
    // 0x1470d4: 0x10400020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147158; return;
    }
    // 0x1470dc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1470e0: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1470e4: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1470e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1470ec: 0xae02033c
    WRITE32(ADD32(GPR_U32(ctx, 16), 828), GPR_U32(ctx, 2));
    // 0x1470f0: 0x4600a828
    ctx->f[0] = std::max(ctx->f[21], ctx->f[0]);
    // 0x1470f4: 0xe7a001d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 472), *(uint32_t*)&val); }
    // 0x1470f8: 0xfba201f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1470fc: 0xdba101d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x147100: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x147104: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147108: 0x10000013
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147158; return;
    }
label_147110:
    // 0x147110: 0x26040300
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 768));
label_147114:
    // 0x147114: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x147118: 0x27a601c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 448));
    // 0x14711c: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x147124);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 464));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_147124
// Address: 0x147124 - 0x14718c

void entry_147124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147124) {
        switch (ctx->pc) {
            case 0x147158: ctx->pc = 0; goto label_147158;
            case 0x147184: ctx->pc = 0; goto label_147184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147124: 0xc6010354
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 852)); ctx->f[1] = *(float*)&val; }
    // 0x147128: 0x8e030358
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 856)));
    // 0x14712c: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x147130: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x147134: 0xdba201c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x147138: 0xdba301d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x14713c: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x147140: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x147144: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x147148: 0x4be41888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14714c: 0xfba101f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147150: 0xfba201e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x147154: 0xfba401f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[4]));
label_147158:
    // 0x147158: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
    // 0x14715c: 0xda0102f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 752)));
    // 0x147160: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x147164: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x147168: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x14716c: 0x7ba201e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x147170: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x147174: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147178: 0xfa0102f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 752), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14717c: 0x7e020300
    WRITE128(ADD32(GPR_U32(ctx, 16), 768), GPR_VEC(ctx, 2));
    // 0x147180: 0xfba301f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[3]));
label_147184:
    // 0x147184: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x14718c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14718c
// Address: 0x14718c - 0x1471b0

void entry_14718c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14718c: 0x7bbf0240
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x147190: 0x7bb20230
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x147194: 0x7bb10220
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x147198: 0x7bb00210
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x14719c: 0xc7b50258
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 600)); ctx->f[21] = *(float*)&val; }
    // 0x1471a0: 0xc7b40250
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 592)); ctx->f[20] = *(float*)&val; }
    // 0x1471a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 608));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1471ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1471b0; return;
}


// Function: CheckDprizeCollect__FP6DPRIZE
// Address: 0x1471b0 - 0x1471dc

void entry_1471dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1471dc: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1471e0: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1471e4: 0x10400078
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1473C8; return;
    }
    // 0x1471ec: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1471f0: 0x10600075
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1473C8; return;
    }
    // 0x1471f8: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1471fc: 0xc4401a50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6736)); ctx->f[0] = *(float*)&val; }
    // 0x147200: 0x26120140
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 320));
    // 0x147204: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x147208: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14720c: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x147210: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147214: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x147218: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14721c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147220: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147224: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x147228: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14722c: 0x0
    // NOP
    // 0x147230: 0x45030066
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
        ctx->pc = 0x1473CC; return;
    }
    // 0x147238: 0xc6200014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20)); ctx->f[0] = *(float*)&val; }
    // 0x14723c: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x147240: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147244: 0x0
    // NOP
    // 0x147248: 0x45030042
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x147354; return;
    }
    // 0x147250: 0xc058344
    SET_GPR_U32(ctx, 31, 0x147258);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_147258
// Address: 0x147258 - 0x14726c

void entry_147258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147258: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x14725c: 0x10400043
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14736C; return;
    }
    // 0x147264: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14726c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 88));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14726c
// Address: 0x14726c - 0x147290

void entry_14726c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14726c: 0x1040003f
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14736C; return;
    }
    // 0x147274: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x147278: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14727c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x147280: 0x24860140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 320));
    // 0x147284: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x147288: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x147290);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_147290
// Address: 0x147290 - 0x1472b0

void entry_147290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147290: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x147294: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x147298: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14729c: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1472a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1472a4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1472a8: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1472b0);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1472b0
// Address: 0x1472b0 - 0x147364

void entry_1472b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1472b0) {
        switch (ctx->pc) {
            case 0x147320: ctx->pc = 0; goto label_147320;
            case 0x147354: ctx->pc = 0; goto label_147354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1472b0: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1472b4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1472b8: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1472bc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1472c0: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1472c4: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1472c8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1472cc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1472d0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1472d4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1472d8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1472dc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1472e0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1472e4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1472e8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1472ec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1472f0: 0x4b000120
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1472f4: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1472f8: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1472fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x147300: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x147304: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147308: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14730c: 0x45010004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_147320;
    }
    // 0x147314: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x147318: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14731c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_147320:
    // 0x147320: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x147324: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x147328: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14732c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147330: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x147334: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x147338: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14733c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x147340: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147344: 0x0
    // NOP
    // 0x147348: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x147370; return;
    }
    // 0x147350: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_147354:
    // 0x147354: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x147358: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x14735c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147364);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147364
// Address: 0x147364 - 0x1473ac

void entry_147364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147364) {
        switch (ctx->pc) {
            case 0x14736c: ctx->pc = 0; goto label_14736c;
            case 0x147370: ctx->pc = 0; goto label_147370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147364: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1473C8; return;
    }
label_14736c:
    // 0x14736c: 0x8e280018
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 24)));
label_147370:
    // 0x147370: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x147374: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x147378: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x14737c: 0x10400012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1473C8; return;
    }
    // 0x147384: 0x8d0603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 1016)));
    // 0x147388: 0x10c0000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1473C8; return;
    }
    // 0x147390: 0x8d0503f0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 1008)));
    // 0x147394: 0xc60c0350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 848)); ctx->f[12] = *(float*)&val; }
    // 0x147398: 0x250803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 932));
    // 0x14739c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1473a0: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1473a4: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x1473ac);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_1473ac
// Address: 0x1473ac - 0x1473c4

void entry_1473ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1473ac: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1473c4(rdram, ctx, runtime); return;
    }
    // 0x1473b4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1473b8: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1473bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1473c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1473c4
// Address: 0x1473c4 - 0x1473e0

void entry_1473c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1473c4) {
        switch (ctx->pc) {
            case 0x1473c8: ctx->pc = 0; goto label_1473c8;
            case 0x1473cc: ctx->pc = 0; goto label_1473cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1473c4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1473c8:
    // 0x1473c8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1473cc:
    // 0x1473cc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1473d0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1473d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1473dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1473e0; return;
}


// Function: FAbsorbDprizeWkr__FP6DPRIZEP3WKR
// Address: 0x1473e0 - 0x147414

void entry_147414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147414) {
        switch (ctx->pc) {
            case 0x147418: ctx->pc = 0; goto label_147418;
            case 0x14741c: ctx->pc = 0; goto label_14741c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147414: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_147418:
    // 0x147418: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_14741c:
    // 0x14741c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x147424: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x147428; return;
}


// Function: UpdateDprize__FP6DPRIZEf
// Address: 0x147428 - 0x147460

void entry_147460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147460: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x147464: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x147468: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14746c: 0x24c61a60
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 6752));
    // 0x147470: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x147474: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x14747c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_14747c
// Address: 0x14747c - 0x1474cc

void entry_14747c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14747c) {
        switch (ctx->pc) {
            case 0x1474b0: ctx->pc = 0; goto label_1474b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14747c: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x147480: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x147484: 0xd8420090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x147488: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14748c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x147490: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147494: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147498: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14749c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1474a0: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1474a4: 0x0
    // NOP
    // 0x1474a8: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1474b0;
    }
label_1474b0:
    // 0x1474b0: 0x8e22032c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 812)));
    // 0x1474b4: 0x5262003e
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x1475B0; return;
    }
    // 0x1474bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1474c0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1474c4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1474cc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1474cc
// Address: 0x1474cc - 0x147550

void entry_1474cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1474cc) {
        switch (ctx->pc) {
            case 0x147540: ctx->pc = 0; goto label_147540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1474cc: 0xc6210320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[1] = *(float*)&val; }
    // 0x1474d0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1474d4: 0x0
    // NOP
    // 0x1474d8: 0x45000033
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1475A8; return;
    }
    // 0x1474e0: 0xc6220330
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 816)); ctx->f[2] = *(float*)&val; }
    // 0x1474e4: 0x24821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1474e8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1474ec: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1474f0: 0xc4611a54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6740)); ctx->f[1] = *(float*)&val; }
    // 0x1474f4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1474f8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1474fc: 0x0
    // NOP
    // 0x147500: 0x45000029
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1475A8; return;
    }
    // 0x147508: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x14750c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x147510: 0xd8420080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x147514: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147518: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14751c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147520: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147524: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147528: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x14752c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147530: 0x0
    // NOP
    // 0x147534: 0x45020002
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 808)));
        goto label_147540;
    }
    // 0x14753c: 0x8e300324
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 804)));
label_147540:
    // 0x147540: 0x12000019
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 25));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1475A8; return;
    }
    // 0x147548: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x147550);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_147550
// Address: 0x147550 - 0x147588

void entry_147550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147550: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x147554: 0x12400014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1475A8; return;
    }
    // 0x14755c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x147560: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x147564: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x147568: 0x26050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 64));
    // 0x14756c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x147570: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x147574: 0xe6200330
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 816), *(uint32_t*)&val); }
    // 0x147578: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14757c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x147580: 0x60f809
    SET_GPR_U32(ctx, 31, 0x147588);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_147588
// Address: 0x147588 - 0x147618

void entry_147588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147588) {
        switch (ctx->pc) {
            case 0x1475a8: ctx->pc = 0; goto label_1475a8;
            case 0x1475b0: ctx->pc = 0; goto label_1475b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147588: 0xae510120
    WRITE32(ADD32(GPR_U32(ctx, 18), 288), GPR_U32(ctx, 17));
    // 0x14758c: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x147590: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x147594: 0xc6200168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 360)); ctx->f[0] = *(float*)&val; }
    // 0x147598: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x14759c: 0x4600a528
    ctx->f[20] = std::max(ctx->f[20], ctx->f[0]);
    // 0x1475a0: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x1475a4: 0xe641001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 28), *(uint32_t*)&val); }
label_1475a8:
    // 0x1475a8: 0xae33032c
    WRITE32(ADD32(GPR_U32(ctx, 17), 812), GPR_U32(ctx, 19));
    // 0x1475ac: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
label_1475b0:
    // 0x1475b0: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1475b4: 0x54620020
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x147638; return;
    }
    // 0x1475bc: 0x8e230384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 900)));
    // 0x1475c0: 0x5060001d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
        ctx->pc = 0x147638; return;
    }
    // 0x1475c8: 0xc6200388
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 904)); ctx->f[0] = *(float*)&val; }
    // 0x1475cc: 0xc622038c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 908)); ctx->f[2] = *(float*)&val; }
    // 0x1475d0: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1475d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1475d8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1475dc: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1475e0: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1475e4: 0x0
    // NOP
    // 0x1475e8: 0x45000012
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 908), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x147634; return;
    }
    // 0x1475f0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1475f4: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1475f8: 0x24020081
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 129));
    // 0x1475fc: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x147600: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x147604: 0xafb10014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 17));
    // 0x147608: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x14760c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x147610: 0x60f809
    SET_GPR_U32(ctx, 31, 0x147618);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_147618
// Address: 0x147618 - 0x147698

void entry_147618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147618) {
        switch (ctx->pc) {
            case 0x147634: ctx->pc = 0; goto label_147634;
            case 0x147638: ctx->pc = 0; goto label_147638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147618: 0xc620038c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 908)); ctx->f[0] = *(float*)&val; }
    // 0x14761c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x147620: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x147624: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x147628: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x14762c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x147630: 0xe620038c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 908), *(uint32_t*)&val); }
label_147634:
    // 0x147634: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
label_147638:
    // 0x147638: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x14763c: 0x1040009f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147644: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x147648: 0x24429e50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942288));
    // 0x14764c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x147650: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x147654: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x14765c: 0xda210300
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x147660: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147664: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x147668: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14766c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147670: 0x3c01461c
    SET_GPR_U32(ctx, 1, ((uint32_t)17948 << 16));
    // 0x147674: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x147678: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14767c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147680: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x147684: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147688: 0x45000032
    if (!(ctx->fcr31 & 0x800000)) {
        entry_147754(rdram, ctx, runtime); return;
    }
    // 0x147690: 0xc051b6c
    SET_GPR_U32(ctx, 31, 0x147698);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CheckDprizeBounce__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_147698
// Address: 0x147698 - 0x14771c

void entry_147698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147698) {
        switch (ctx->pc) {
            case 0x1476dc: ctx->pc = 0; goto label_1476dc;
            case 0x147714: ctx->pc = 0; goto label_147714;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147698: 0x1000002e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_147754(rdram, ctx, runtime); return;
    }
    // 0x1476a0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1476a4: 0xc62202d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 724)); ctx->f[2] = *(float*)&val; }
    // 0x1476a8: 0x24821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1476ac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1476b0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1476b4: 0xc46119ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6636)); ctx->f[1] = *(float*)&val; }
    // 0x1476b8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1476bc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1476c0: 0x0
    // NOP
    // 0x1476c4: 0x45000005
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1476dc;
    }
    // 0x1476cc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1476d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1476d4: 0x10000051
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14781C; return;
    }
label_1476dc:
    // 0x1476dc: 0x8e22033c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 828)));
    // 0x1476e0: 0x1040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_147714;
    }
    // 0x1476e8: 0xc6210308
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 776)); ctx->f[1] = *(float*)&val; }
    // 0x1476ec: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x1476f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1476f4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1476f8: 0x0
    // NOP
    // 0x1476fc: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_147714;
    }
    // 0x147704: 0xae20033c
    WRITE32(ADD32(GPR_U32(ctx, 17), 828), GPR_U32(ctx, 0));
    // 0x147708: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14770c: 0x10000043
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14781C; return;
    }
label_147714:
    // 0x147714: 0xc051b6c
    SET_GPR_U32(ctx, 31, 0x14771c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CheckDprizeBounce__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_14771c
// Address: 0x14771c - 0x147754

void entry_14771c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14771c: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x147720: 0xc62202d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 724)); ctx->f[2] = *(float*)&val; }
    // 0x147724: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x147728: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14772c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x147730: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x147734: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147738: 0x45000060
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147740: 0x8e2402ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 748)));
    // 0x147744: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x147748: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x14774c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147754);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147754
// Address: 0x147754 - 0x14775c

void entry_147754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147754: 0xc051c6c
    SET_GPR_U32(ctx, 31, 0x14775c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CheckDprizeCollect__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_14775c
// Address: 0x14775c - 0x14776c

void entry_14775c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14775c: 0x10000057
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147764: 0xc064a7e
    SET_GPR_U32(ctx, 31, 0x14776c);
    PpziCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14776c
// Address: 0x14776c - 0x147798

void entry_14776c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14776c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x147770: 0x50600028
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x147814; return;
    }
    // 0x147778: 0x8e220370
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 880)));
    // 0x14777c: 0x1040004f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147784: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x147788: 0x10000024
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14781C; return;
    }
    // 0x147790: 0xc064a7e
    SET_GPR_U32(ctx, 31, 0x147798);
    PpziCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_147798
// Address: 0x147798 - 0x1477b0

void entry_147798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147798: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14779c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1477a0: 0x10400007
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1477C0; return;
    }
    // 0x1477a8: 0xc058366
    SET_GPR_U32(ctx, 31, 0x1477b0);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 9152)));
    CcharmMost__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1477b0
// Address: 0x1477b0 - 0x147810

void entry_1477b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1477b0) {
        switch (ctx->pc) {
            case 0x1477c0: ctx->pc = 0; goto label_1477c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1477b0: 0x8e0319e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6628)));
    // 0x1477b4: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1477b8: 0x1460001d
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x147830; return;
    }
label_1477c0:
    // 0x1477c0: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1477c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1477c8: 0x24421a70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6768));
    // 0x1477cc: 0x8e270000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1477d0: 0x246600d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 208));
    // 0x1477d4: 0xd86500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x1477d8: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1477dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1477e0: 0xd8c40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x1477e4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1477e8: 0xd8c20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x1477ec: 0xd8610150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1477f0: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1477f4: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1477f8: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1477fc: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147800: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147804: 0x8ce20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 144)));
    // 0x147808: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147810);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147810
// Address: 0x147810 - 0x147828

void entry_147810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147810) {
        switch (ctx->pc) {
            case 0x147814: ctx->pc = 0; goto label_147814;
            case 0x14781c: ctx->pc = 0; goto label_14781c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147810: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_147814:
    // 0x147814: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147818: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
label_14781c:
    // 0x14781c: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x147820: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147828);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147828
// Address: 0x147828 - 0x147874

void entry_147828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147828) {
        switch (ctx->pc) {
            case 0x147830: ctx->pc = 0; goto label_147830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147828: 0x10000024
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
label_147830:
    // 0x147830: 0xc62202d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 724)); ctx->f[2] = *(float*)&val; }
    // 0x147834: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x147838: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14783c: 0xc44119e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6632)); ctx->f[1] = *(float*)&val; }
    // 0x147840: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x147844: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147848: 0x0
    // NOP
    // 0x14784c: 0x4500001b
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 9152)));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147854: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147858: 0x8cc219e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6628)));
    // 0x14785c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x147860: 0xacc219e4
    WRITE32(ADD32(GPR_U32(ctx, 6), 6628), GPR_U32(ctx, 2));
    // 0x147864: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x147868: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x14786c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147874);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147874
// Address: 0x147874 - 0x147880

void entry_147874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147874: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x147878: 0xc052338
    SET_GPR_U32(ctx, 31, 0x147880);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    RemoveSwExtraneousCharms__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_147880
// Address: 0x147880 - 0x1478bc

void entry_147880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147880: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x147888: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14788c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x147890: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x147894: 0xc461185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x147898: 0xc4802424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 9252)); ctx->f[0] = *(float*)&val; }
    // 0x14789c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1478a0: 0x0
    // NOP
    // 0x1478a4: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1478bc(rdram, ctx, runtime); return;
    }
    // 0x1478ac: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1478b0: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1478b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1478bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1478bc
// Address: 0x1478bc - 0x1478c4

void entry_1478bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1478bc: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1478c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1478c4
// Address: 0x1478c4 - 0x1478f0

void entry_1478c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1478c4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1478c8: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1478cc: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1478d0: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1478d4: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1478d8: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1478dc: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1478e0: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1478e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1478ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1478f0; return;
}


// Function: RenderDprizeAll__FP6DPRIZEP2CMP2RO
// Address: 0x1478f0 - 0x147a40

void entry_147a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147a40: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x147a44: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x147a48: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x147a50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_147a50
// Address: 0x147a50 - 0x147a60

void entry_147a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147a50: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x147a54: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x147a58: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x147a60);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_147a60
// Address: 0x147a60 - 0x147a94

void entry_147a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147a60) {
        switch (ctx->pc) {
            case 0x147a84: ctx->pc = 0; goto label_147a84;
            case 0x147a88: ctx->pc = 0; goto label_147a88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147a60: 0x7ba500a0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x147a64: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x147a68: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x147a6c: 0x7ba300c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x147a70: 0x7ba400d0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x147a74: 0x7fa50000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 5));
    // 0x147a78: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x147a7c: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x147a80: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
label_147a84:
    // 0x147a84: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_147a88:
    // 0x147a88: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x147a8c: 0xc049724
    SET_GPR_U32(ctx, 31, 0x147a94);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_147a94
// Address: 0x147a94 - 0x147ab0

void entry_147a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147a94: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x147a98: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x147a9c: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x147aa0: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x147aa4: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x147aa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetDprizeDprizes__FP6DPRIZE7DPRIZES
// Address: 0x147ab0 - 0x147ae8

void entry_147ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147ae8: 0x12600008
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_147b0c(rdram, ctx, runtime); return;
    }
    // 0x147af0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x147af4: 0x12620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        entry_147b0c(rdram, ctx, runtime); return;
    }
    // 0x147afc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x147b00: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x147b04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147b0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147b0c
// Address: 0x147b0c - 0x147be0

void entry_147b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147b0c) {
        switch (ctx->pc) {
            case 0x147b34: ctx->pc = 0; goto label_147b34;
            case 0x147b48: ctx->pc = 0; goto label_147b48;
            case 0x147b58: ctx->pc = 0; goto label_147b58;
            case 0x147b5c: ctx->pc = 0; goto label_147b5c;
            case 0x147bd4: ctx->pc = 0; goto label_147bd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147b0c: 0x8e4302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    // 0x147b10: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x147b14: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_147b48;
    }
    // 0x147b1c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_147b34;
    }
    // 0x147b24: 0x10620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_147b48;
    }
    // 0x147b2c: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_147b5c;
    }
label_147b34:
    // 0x147b34: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x147b38: 0x10400007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_147b58;
    }
    // 0x147b40: 0x14400006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_147b5c;
    }
label_147b48:
    // 0x147b48: 0x7a420100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x147b4c: 0x7a430150
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x147b50: 0x7e4202f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 752), GPR_VEC(ctx, 2));
    // 0x147b54: 0x7e430300
    WRITE128(ADD32(GPR_U32(ctx, 18), 768), GPR_VEC(ctx, 3));
label_147b58:
    // 0x147b58: 0x2e620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 8));
label_147b5c:
    // 0x147b5c: 0x10400077
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D3C; return;
    }
    // 0x147b64: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x147b68: 0x24429e70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942320));
    // 0x147b6c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x147b70: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x147b74: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x147b7c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x147b80: 0x8e4502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x147b84: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x147b88: 0x24140261
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 609));
    // 0x147b8c: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x147b90: 0x51827
    SET_GPR_U32(ctx, 3, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
    // 0x147b94: 0xa3a00b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 5));
    // 0x147b98: 0x10000068
    WRITE128(ADD32(GPR_U32(ctx, 18), 784), GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D3C; return;
    }
    // 0x147ba0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x147ba4: 0x10000062
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 610));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D30; return;
    }
    // 0x147bac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x147bb0: 0x24140260
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 608));
    // 0x147bb4: 0x1000005f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6640));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D34; return;
    }
    // 0x147bbc: 0x8e420334
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 820)));
    // 0x147bc0: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_147bd4;
    }
    // 0x147bc8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x147bcc: 0xae420338
    WRITE32(ADD32(GPR_U32(ctx, 18), 824), GPR_U32(ctx, 2));
    // 0x147bd0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_147bd4:
    // 0x147bd4: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x147bd8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147be0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147be0
// Address: 0x147be0 - 0x147c04

void entry_147be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147be0: 0x10000056
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D3C; return;
    }
    // 0x147be8: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x147bec: 0x264702f4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 756));
    // 0x147bf0: 0x264802f8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 760));
    // 0x147bf4: 0x264602f0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 752));
    // 0x147bf8: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x147bfc: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x147c04);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 320));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_147c04
// Address: 0x147c04 - 0x147c5c

void entry_147c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147c04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x147c08: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x147c0c: 0x24421aa0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6816));
    // 0x147c10: 0x24c68d30
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937904));
    // 0x147c14: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x147c18: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x147c1c: 0xc4a119e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 6624)); ctx->f[1] = *(float*)&val; }
    // 0x147c20: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x147c24: 0x7e430300
    WRITE128(ADD32(GPR_U32(ctx, 18), 768), GPR_VEC(ctx, 3));
    // 0x147c28: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x147c2c: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x147c30: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147c34: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x147c38: 0x7e420310
    WRITE128(ADD32(GPR_U32(ctx, 18), 784), GPR_VEC(ctx, 2));
    // 0x147c3c: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x147c40: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x147c44: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147c48: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147c4c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x147c50: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x147c54: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x147c5c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_147c5c
// Address: 0x147c5c - 0x147c78

void entry_147c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147c5c: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x147c60: 0x3c01c020
    SET_GPR_U32(ctx, 1, ((uint32_t)49184 << 16));
    // 0x147c64: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x147c68: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x147c6c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x147c70: 0xc062214
    SET_GPR_U32(ctx, 31, 0x147c78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937856));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_147c78
// Address: 0x147c78 - 0x147ce8

void entry_147c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147c78: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x147c7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147c80: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x147c84: 0x26450110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 272));
    // 0x147c88: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x147c8c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x147c90: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x147c94: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x147c98: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x147c9c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x147ca0: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147ca4: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x147ca8: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x147cac: 0x4bc4190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147cb0: 0xdba50060
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x147cb4: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x147cb8: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x147cbc: 0x4bc5184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x147cc0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x147cc4: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x147cc8: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147ccc: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x147cd0: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x147cd4: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x147cd8: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x147cdc: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147ce0: 0xc062454
    SET_GPR_U32(ctx, 31, 0x147ce8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_147ce8
// Address: 0x147ce8 - 0x147cf8

void entry_147ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147ce8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x147cec: 0x2645035c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 860));
    // 0x147cf0: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x147cf8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 864));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_147cf8
// Address: 0x147cf8 - 0x147d64

void entry_147cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147cf8) {
        switch (ctx->pc) {
            case 0x147d30: ctx->pc = 0; goto label_147d30;
            case 0x147d34: ctx->pc = 0; goto label_147d34;
            case 0x147d38: ctx->pc = 0; goto label_147d38;
            case 0x147d3c: ctx->pc = 0; goto label_147d3c;
            case 0x147d4c: ctx->pc = 0; goto label_147d4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147cf8: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 18), 880), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_147d3c;
    }
    // 0x147d00: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x147d04: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x147d08: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x147d0c: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x147d10: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x147d14: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x147d18: 0xfa4102f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 752), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x147d1c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x147d20: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 18), 768), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_147d38;
    }
    // 0x147d28: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x147d2c: 0x24140263
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 611));
label_147d30:
    // 0x147d30: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
label_147d34:
    // 0x147d34: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
label_147d38:
    // 0x147d38: 0x7e420310
    WRITE128(ADD32(GPR_U32(ctx, 18), 784), GPR_VEC(ctx, 2));
label_147d3c:
    // 0x147d3c: 0x12600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_147d4c;
    }
    // 0x147d44: 0x5662000e
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 748)));
        ctx->pc = 0x147D80; return;
    }
label_147d4c:
    // 0x147d4c: 0x8e4402ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 748)));
    // 0x147d50: 0x10800006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D6C; return;
    }
    // 0x147d58: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x147d5c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147d64);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147d64
// Address: 0x147d64 - 0x147d78

void entry_147d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147d64) {
        switch (ctx->pc) {
            case 0x147d6c: ctx->pc = 0; goto label_147d6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147d64: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 18), 720), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D9C; return;
    }
label_147d6c:
    // 0x147d6c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x147d70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147d78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147d78
// Address: 0x147d78 - 0x147d98

void entry_147d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147d78) {
        switch (ctx->pc) {
            case 0x147d80: ctx->pc = 0; goto label_147d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147d78: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 18), 720), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147D9C; return;
    }
label_147d80:
    // 0x147d80: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 720), GPR_U32(ctx, 19));
        ctx->pc = 0x147D9C; return;
    }
    // 0x147d88: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x147d8c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x147d90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147d98);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147d98
// Address: 0x147d98 - 0x147dcc

void entry_147d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147d98) {
        switch (ctx->pc) {
            case 0x147d9c: ctx->pc = 0; goto label_147d9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147d98: 0xae5302d0
    WRITE32(ADD32(GPR_U32(ctx, 18), 720), GPR_U32(ctx, 19));
label_147d9c:
    // 0x147d9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x147da0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x147da4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x147da8: 0x12830016
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 724), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x147E04; return;
    }
    // 0x147db0: 0x8e4402e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x147db4: 0x1480000f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x147DF4; return;
    }
    // 0x147dbc: 0x8e4402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 740)));
    // 0x147dc0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x147dc4: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x147dcc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_147dcc
// Address: 0x147dcc - 0x147dec

void entry_147dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147dcc: 0xc64c02e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 736)); ctx->f[12] = *(float*)&val; }
    // 0x147dd0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x147dd4: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x147dd8: 0x0
    // NOP
    // 0x147ddc: 0x4500000f
    WRITE32(ADD32(GPR_U32(ctx, 18), 744), GPR_U32(ctx, 2));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x147E1C; return;
    }
    // 0x147de4: 0xc06db3c
    SET_GPR_U32(ctx, 31, 0x147dec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SkipSma__FP3SMAf(rdram, ctx, runtime); return;
}


// Function: entry_147dec
// Address: 0x147dec - 0x147dfc

void entry_147dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147dec) {
        switch (ctx->pc) {
            case 0x147df4: ctx->pc = 0; goto label_147df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147dec: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147E20; return;
    }
label_147df4:
    // 0x147df4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x147dfc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_147dfc
// Address: 0x147dfc - 0x147e18

void entry_147dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147dfc) {
        switch (ctx->pc) {
            case 0x147e04: ctx->pc = 0; goto label_147e04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147dfc: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147E20; return;
    }
label_147e04:
    // 0x147e04: 0x8e4402e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x147e08: 0x10800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x147E20; return;
    }
    // 0x147e10: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x147e18);
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_147e18
// Address: 0x147e18 - 0x147e40

void entry_147e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147e18) {
        switch (ctx->pc) {
            case 0x147e1c: ctx->pc = 0; goto label_147e1c;
            case 0x147e20: ctx->pc = 0; goto label_147e20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147e18: 0xae4002e8
    WRITE32(ADD32(GPR_U32(ctx, 18), 744), GPR_U32(ctx, 0));
label_147e1c:
    // 0x147e1c: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_147e20:
    // 0x147e20: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x147e24: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x147e28: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x147e2c: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x147e30: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x147e34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x147e3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x147e40; return;
}


// Function: InitCoin__FP4COIN
// Address: 0x147e40 - 0x147e54

void entry_147e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147e54: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x147e58: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x147e5c: 0x3c014234
    SET_GPR_U32(ctx, 1, ((uint32_t)16948 << 16));
    // 0x147e60: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x147e64: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x147e68: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x147e6c: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x147e70: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x147e74: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x147e78: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x147e7c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x147e80: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x147e84: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x147e88: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x147e8c: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x147e90: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x147e94: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x147e98: 0xe601034c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x147e9c: 0xe6000394
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 916), *(uint32_t*)&val); }
    // 0x147ea0: 0xe6020344
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x147ea4: 0xe6070348
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 16), 840), *(uint32_t*)&val); }
    // 0x147ea8: 0xe6030358
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x147eac: 0xe6040354
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    // 0x147eb0: 0xe6050320
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x147eb4: 0xe6060390
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 912), *(uint32_t*)&val); }
    // 0x147eb8: 0xe6070350
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x147ebc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x147ec0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x147ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x147ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x147ed0; return;
}


// Function: FUN_00147ed0
// Address: 0x147ed0 - 0x147ee8

void FUN_00147ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147ed0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x147ed4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x147ed8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x147edc: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x147ee0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x147ee8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_147ee8
// Address: 0x147ee8 - 0x147ef8

void entry_147ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147ee8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x147eec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x147ef4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x147ef8; return;
}


// Function: FUN_00147ef8
// Address: 0x147ef8 - 0x147f1c

void FUN_00147ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147ef8: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x147efc: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x147f00: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x147f04: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x147f08: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x147f0c: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x147f10: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x147f14: 0xc049cde
    SET_GPR_U32(ctx, 31, 0x147f1c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    HandleAloMessage__FP3ALO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_147f1c
// Address: 0x147f1c - 0x147f40

void entry_147f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147f1c: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x147f20: 0x1602001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x147F9C; return;
    }
    // 0x147f28: 0x8e4202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x147f2c: 0x5622001c
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
        ctx->pc = 0x147FA0; return;
    }
    // 0x147f34: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x147f38: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x147f40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_147f40
// Address: 0x147f40 - 0x147f7c

void entry_147f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147f40: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x147f44: 0x24020263
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 611));
    // 0x147f48: 0x14620014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x147F9C; return;
    }
    // 0x147f50: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x147f54: 0x8c431d60
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7520)));
    // 0x147f58: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_147f7c(rdram, ctx, runtime); return;
    }
    // 0x147f60: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x147f64: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x147f68: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x147f6c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x147f70: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x147f74: 0x60f809
    SET_GPR_U32(ctx, 31, 0x147f7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_147f7c
// Address: 0x147f7c - 0x147f98

void entry_147f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x147f7c: 0x3c050014
    SET_GPR_U32(ctx, 5, ((uint32_t)20 << 16));
    // 0x147f80: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x147f84: 0x24a57ed0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32464));
    // 0x147f88: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x147f8c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x147f90: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x147f98);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_147f98
// Address: 0x147f98 - 0x147fb0

void entry_147f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147f98) {
        switch (ctx->pc) {
            case 0x147f9c: ctx->pc = 0; goto label_147f9c;
            case 0x147fa0: ctx->pc = 0; goto label_147fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147f98: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_147f9c:
    // 0x147f9c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_147fa0:
    // 0x147fa0: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x147fa4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x147fa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCoin__FP4COINf
// Address: 0x147fb0 - 0x147fc4

void entry_147fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x147fc4) {
        switch (ctx->pc) {
            case 0x147ffc: ctx->pc = 0; goto label_147ffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x147fc4: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x147fc8: 0x14400017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x148028; return;
    }
    // 0x147fd0: 0x8e020338
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 824)));
    // 0x147fd4: 0x10400014
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148028; return;
    }
    // 0x147fdc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x147fe0: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x147fe4: 0x10640005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_147ffc;
    }
    // 0x147fec: 0xc6000398
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 920)); ctx->f[0] = *(float*)&val; }
    // 0x147ff0: 0xc4411860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[1] = *(float*)&val; }
    // 0x147ff4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x147ff8: 0xe6000398
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 920), *(uint32_t*)&val); }
label_147ffc:
    // 0x147ffc: 0xc6010398
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 920)); ctx->f[1] = *(float*)&val; }
    // 0x148000: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x148004: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x148008: 0x0
    // NOP
    // 0x14800c: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_148024(rdram, ctx, runtime); return;
    }
    // 0x148014: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148018: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x14801c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148024);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148024
// Address: 0x148024 - 0x148038

void entry_148024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148024) {
        switch (ctx->pc) {
            case 0x148028: ctx->pc = 0; goto label_148028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148024: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_148028:
    // 0x148028: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14802c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148034: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148038; return;
}


// Function: CreateSwCharm__FP2SW
// Address: 0x148038 - 0x14805c

void entry_14805c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14805c: 0x1440000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14808C; return;
    }
    // 0x148064: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x148068: 0xc058366
    SET_GPR_U32(ctx, 31, 0x148070);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    CcharmMost__Fv(rdram, ctx, runtime); return;
}


// Function: entry_148070
// Address: 0x148070 - 0x14809c

void entry_148070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148070) {
        switch (ctx->pc) {
            case 0x14808c: ctx->pc = 0; goto label_14808c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148070: 0x8e0319e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6628)));
    // 0x148074: 0x8e2523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    // 0x148078: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x14807c: 0x62202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x148080: 0x44180a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 2));
    // 0x148084: 0x10000036
    WRITE32(ADD32(GPR_U32(ctx, 5), 6628), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_148160(rdram, ctx, runtime); return;
    }
label_14808c:
    // 0x14808c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148090: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x148094: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14809c);
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14809c
// Address: 0x14809c - 0x1480b0

void entry_14809c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14809c: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1480a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1480a4: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1480a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1480b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1480b0
// Address: 0x1480b0 - 0x1480c8

void entry_1480b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1480b0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1480b4: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1480b8: 0x8c641990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x1480bc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1480c0: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1480c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6832));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1480c8
// Address: 0x1480c8 - 0x1480dc

void entry_1480c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1480c8: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1480cc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1480d0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1480d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1480dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1480dc
// Address: 0x1480dc - 0x1480f4

void entry_1480dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1480dc: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1480e0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1480e4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1480e8: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1480ec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1480f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935504));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1480f4
// Address: 0x1480f4 - 0x14810c

void entry_1480f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1480f4: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1480f8: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1480fc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148100: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x148104: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14810c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14810c
// Address: 0x14810c - 0x148120

void entry_14810c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14810c: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148110: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148114: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x148118: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148120);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148120
// Address: 0x148120 - 0x148134

void entry_148120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148120: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148124: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148128: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x14812c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148134);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148134
// Address: 0x148134 - 0x148160

void entry_148134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148134: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x148138: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14813c: 0x24631ac0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6848));
    // 0x148140: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x148144: 0x7c820300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 2));
    // 0x148148: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14814c: 0x8e241ec4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7876)));
    // 0x148150: 0xc4ac02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 680)); ctx->f[12] = *(float*)&val; }
    // 0x148154: 0x24a60088
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 5), 136));
    // 0x148158: 0xc07bad8
    SET_GPR_U32(ctx, 31, 0x148160);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_148160
// Address: 0x148160 - 0x148178

void entry_148160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148160: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x148164: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x148168: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14816c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148174: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148178; return;
}


// Function: AddLife__FPv
// Address: 0x148178 - 0x1481a0

void entry_1481dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1481dc) {
        switch (ctx->pc) {
            case 0x148224: ctx->pc = 0; goto label_148224;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1481dc: 0x8e0319e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6628)));
    // 0x1481e0: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1481e4: 0x1060000f
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_148224;
    }
    // 0x1481ec: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1481f0: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x1481f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1481f8: 0x2484ce48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    // 0x1481fc: 0xac6019e8
    WRITE32(ADD32(GPR_U32(ctx, 3), 6632), GPR_U32(ctx, 0));
    // 0x148200: 0x3c020015
    SET_GPR_U32(ctx, 2, ((uint32_t)21 << 16));
    // 0x148204: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x148208: 0x24428038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294934584));
    // 0x14820c: 0xa883026f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 623); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x148210: 0xb883026c
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 620); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x148214: 0xac820274
    WRITE32(ADD32(GPR_U32(ctx, 4), 628), GPR_U32(ctx, 2));
    // 0x148218: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x14821c: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 4), 632), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14827C; return;
    }
label_148224:
    // 0x148224: 0x8c6219e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
    // 0x148228: 0x28420063
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 99));
    // 0x14822c: 0x10400011
    SET_GPR_U32(ctx, 2, ((uint32_t)21 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148274; return;
    }
    // 0x148234: 0xac6019e8
    WRITE32(ADD32(GPR_U32(ctx, 3), 6632), GPR_U32(ctx, 0));
    // 0x148238: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x14823c: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x148240: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x148244: 0x2463ce48
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294954568));
    // 0x148248: 0x24428178
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294934904));
    // 0x14824c: 0xe460026c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 620), *(uint32_t*)&val); }
    // 0x148250: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x148254: 0xac600278
    WRITE32(ADD32(GPR_U32(ctx, 3), 632), GPR_U32(ctx, 0));
    // 0x148258: 0xac620274
    WRITE32(ADD32(GPR_U32(ctx, 3), 628), GPR_U32(ctx, 2));
    // 0x14825c: 0x8ca2c6c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4294952648)));
    // 0x148260: 0x8c430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x148264: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14826c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294952648));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14826c
// Address: 0x14826c - 0x148298

void entry_14826c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14826c) {
        switch (ctx->pc) {
            case 0x148274: ctx->pc = 0; goto label_148274;
            case 0x14827c: ctx->pc = 0; goto label_14827c;
            case 0x148280: ctx->pc = 0; goto label_148280;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14826c: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_148280;
    }
label_148274:
    // 0x148274: 0x24020063
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 99));
    // 0x148278: 0xac6219e8
    WRITE32(ADD32(GPR_U32(ctx, 3), 6632), GPR_U32(ctx, 2));
label_14827c:
    // 0x14827c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_148280:
    // 0x148280: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x148284: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148288: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14828c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148294: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148298; return;
}


// Function: SetCoinDprizes__FP4COIN7DPRIZES
// Address: 0x148298 - 0x1482ec

void entry_1482ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1482ec) {
        switch (ctx->pc) {
            case 0x1482f4: ctx->pc = 0; goto label_1482f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1482ec: 0x1000003c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 920), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1483E0; return;
    }
label_1482f4:
    // 0x1482f4: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1482f8: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x148300);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_148300
// Address: 0x148300 - 0x148338

void entry_148300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148300: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x148304: 0x12000014
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148358; return;
    }
    // 0x14830c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148310: 0x24421ad0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6864));
    // 0x148314: 0xae110134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 17));
    // 0x148318: 0xae020130
    WRITE32(ADD32(GPR_U32(ctx, 16), 304), GPR_U32(ctx, 2));
    // 0x14831c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148320: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x148324: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x148328: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x14832c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x148330: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148338);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148338
// Address: 0x148338 - 0x148360

void entry_148338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148338) {
        switch (ctx->pc) {
            case 0x148358: ctx->pc = 0; goto label_148358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148338: 0xae110020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 17));
    // 0x14833c: 0x7a220110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x148340: 0x7e020050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 2));
    // 0x148344: 0x7a230120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x148348: 0x7e030060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), GPR_VEC(ctx, 3));
    // 0x14834c: 0x7a220130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x148350: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_148360(rdram, ctx, runtime); return;
    }
label_148358:
    // 0x148358: 0xc052068
    SET_GPR_U32(ctx, 31, 0x148360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    OnCoinSmack__FP4COIN(rdram, ctx, runtime); return;
}


// Function: entry_148360
// Address: 0x148360 - 0x148374

void entry_148360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148360: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x148364: 0x8c83ce48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294954568)));
    // 0x148368: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x14836c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148374);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148374
// Address: 0x148374 - 0x1483b4

void entry_148374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148374: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x148378: 0x24040078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 120));
    // 0x14837c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x148380: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x148384: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x148388: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14838c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x148390: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x148394: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148398: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14839c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1483a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1483a4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1483a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1483ac: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1483b4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1483b4
// Address: 0x1483b4 - 0x1483dc

void entry_1483b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1483b4: 0x8e230380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x1483b8: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1483dc(rdram, ctx, runtime); return;
    }
    // 0x1483c0: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x1483c4: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1483c8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1483cc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1483d0: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1483d4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1483dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1483dc
// Address: 0x1483dc - 0x1483ec

void entry_1483dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1483dc) {
        switch (ctx->pc) {
            case 0x1483e0: ctx->pc = 0; goto label_1483e0;
            case 0x1483e4: ctx->pc = 0; goto label_1483e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1483dc: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
label_1483e0:
    // 0x1483e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1483e4:
    // 0x1483e4: 0xc051eac
    SET_GPR_U32(ctx, 31, 0x1483ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDprizeDprizes__FP6DPRIZE7DPRIZES(rdram, ctx, runtime); return;
}


// Function: entry_1483ec
// Address: 0x1483ec - 0x148400

void entry_1483ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1483ec) {
        switch (ctx->pc) {
            case 0x1483f0: ctx->pc = 0; goto label_1483f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1483ec: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1483f0:
    // 0x1483f0: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1483f4: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1483f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCharm__FP5CHARM
// Address: 0x148400 - 0x148414

void entry_148414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148414: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x148418: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x14841c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x148420: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x148424: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x148428: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14842c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x148430: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x148434: 0x3c013eb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16051 << 16));
    // 0x148438: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x14843c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x148440: 0xe6040350
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x148444: 0xe6000320
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x148448: 0xe6010344
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x14844c: 0xe6020358
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x148450: 0xe6030354
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    // 0x148454: 0xe604034c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x148458: 0xae000348
    WRITE32(ADD32(GPR_U32(ctx, 16), 840), GPR_U32(ctx, 0));
    // 0x14845c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148460: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148464: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14846c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148470; return;
}


// Function: SetCharmDprizes__FP5CHARM7DPRIZES
// Address: 0x148470 - 0x1484dc

void entry_1484dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1484dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1484e0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1484e4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1484e8: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1484f0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1484f0
// Address: 0x1484f0 - 0x1484fc

void entry_1484f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1484f0) {
        switch (ctx->pc) {
            case 0x1484f4: ctx->pc = 0; goto label_1484f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1484f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1484f4:
    // 0x1484f4: 0xc051eac
    SET_GPR_U32(ctx, 31, 0x1484fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDprizeDprizes__FP6DPRIZE7DPRIZES(rdram, ctx, runtime); return;
}


// Function: entry_1484fc
// Address: 0x1484fc - 0x148510

void entry_1484fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1484fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x148500: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148504: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitKey__FP3KEY
// Address: 0x148510 - 0x148524

void entry_148524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148524) {
        switch (ctx->pc) {
            case 0x148588: ctx->pc = 0; goto label_148588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148524: 0x3c01420c
    SET_GPR_U32(ctx, 1, ((uint32_t)16908 << 16));
    // 0x148528: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x14852c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148530: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x148534: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x148538: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14853c: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x148540: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x148544: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x148548: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14854c: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x148550: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x148554: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x148558: 0xe6040350
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x14855c: 0xe6000344
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x148560: 0xe6010348
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 840), *(uint32_t*)&val); }
    // 0x148564: 0xe6030354
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    // 0x148568: 0xe6020320
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x14856c: 0xe604034c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x148570: 0xe6030358
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x148574: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x148578: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x14857c: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_148588;
    }
    // 0x148584: 0xae0202d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 2));
label_148588:
    // 0x148588: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14858c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetKeyDprizes__FP3KEY7DPRIZES
// Address: 0x148598 - 0x14861c

void entry_14861c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14861c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x148624);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_148624
// Address: 0x148624 - 0x148644

void entry_148624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148624: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x148648; return;
    }
    // 0x14862c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x148630: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x148634: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148638: 0x8c620148
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 328)));
    // 0x14863c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148644);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148644
// Address: 0x148644 - 0x148658

void entry_148644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148644) {
        switch (ctx->pc) {
            case 0x148648: ctx->pc = 0; goto label_148648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148644: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_148648:
    // 0x148648: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14864c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148650: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x148658);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_148658
// Address: 0x148658 - 0x148668

void entry_148658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148658: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14865c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x148660: 0xc0547f2
    SET_GPR_U32(ctx, 31, 0x148668);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyCollectKey__FP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_148668
// Address: 0x148668 - 0x148674

void entry_148668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148668: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x14866c: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x148674);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_148674
// Address: 0x148674 - 0x148680

void entry_148674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148674) {
        switch (ctx->pc) {
            case 0x148678: ctx->pc = 0; goto label_148678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148674: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_148678:
    // 0x148678: 0xc051eac
    SET_GPR_U32(ctx, 31, 0x148680);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDprizeDprizes__FP6DPRIZE7DPRIZES(rdram, ctx, runtime); return;
}


// Function: entry_148680
// Address: 0x148680 - 0x148698

void entry_148680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148680: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x148684: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148688: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14868c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148694: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148698; return;
}


// Function: FUN_00148698
// Address: 0x148698 - 0x1486ac

void FUN_00148698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148698: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14869c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1486a0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1486a4: 0xc0518d0
    SET_GPR_U32(ctx, 31, 0x1486ac);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitDprize__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_1486ac
// Address: 0x1486ac - 0x148718

void entry_1486ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1486ac) {
        switch (ctx->pc) {
            case 0x14870c: ctx->pc = 0; goto label_14870c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1486ac: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x1486b0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1486b4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1486b8: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1486bc: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1486c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1486c4: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1486c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1486cc: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x1486d0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1486d4: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x1486d8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1486dc: 0xe6040350
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x1486e0: 0xe6000344
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x1486e4: 0xe6010348
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 840), *(uint32_t*)&val); }
    // 0x1486e8: 0xe6030354
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    // 0x1486ec: 0xe6020320
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x1486f0: 0xe604034c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x1486f4: 0xe6030358
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x1486f8: 0x8c62ec60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294962272)));
    // 0x1486fc: 0x14400003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14870c;
    }
    // 0x148704: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x148708: 0xae0202d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 2));
label_14870c:
    // 0x14870c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148710: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00148718
// Address: 0x148718 - 0x14872c

void FUN_00148718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148718: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14871c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x148720: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x148724: 0xc05191c
    SET_GPR_U32(ctx, 31, 0x14872c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostDprizeLoad__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_14872c
// Address: 0x14872c - 0x148748

void entry_14872c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14872c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x148730: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148734: 0xac50ec68
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294962280), GPR_U32(ctx, 16));
    // 0x148738: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14873c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148744: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148748; return;
}


// Function: FUN_00148748
// Address: 0x148748 - 0x148760

void FUN_00148748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148748: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x14874c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148750: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x148754: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148758: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148760);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148760
// Address: 0x148760 - 0x148770

void entry_148760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148760: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148764: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14876c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148770; return;
}


// Function: FUN_00148770
// Address: 0x148770 - 0x148794

void FUN_00148770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148770: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x148774: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x148778: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x14877c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x148780: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x148784: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x148788: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x14878c: 0xc049cde
    SET_GPR_U32(ctx, 31, 0x148794);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    HandleAloMessage__FP3ALO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_148794
// Address: 0x148794 - 0x1487b8

void entry_148794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148794: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x148798: 0x1602001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x148814; return;
    }
    // 0x1487a0: 0x8e4202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x1487a4: 0x5622001c
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
        ctx->pc = 0x148818; return;
    }
    // 0x1487ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1487b0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1487b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1487b8
// Address: 0x1487b8 - 0x1487f4

void entry_1487b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1487b8: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1487bc: 0x24020263
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 611));
    // 0x1487c0: 0x14620014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x148814; return;
    }
    // 0x1487c8: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1487cc: 0x8c431d60
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7520)));
    // 0x1487d0: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1487f4(rdram, ctx, runtime); return;
    }
    // 0x1487d8: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x1487dc: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1487e0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1487e4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1487e8: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1487ec: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1487f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1487f4
// Address: 0x1487f4 - 0x148810

void entry_1487f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1487f4: 0x3c050015
    SET_GPR_U32(ctx, 5, ((uint32_t)21 << 16));
    // 0x1487f8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1487fc: 0x24a58748
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294936392));
    // 0x148800: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x148804: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148808: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x148810);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_148810
// Address: 0x148810 - 0x148828

void entry_148810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148810) {
        switch (ctx->pc) {
            case 0x148814: ctx->pc = 0; goto label_148814;
            case 0x148818: ctx->pc = 0; goto label_148818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148810: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_148814:
    // 0x148814: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_148818:
    // 0x148818: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14881c: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x148820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00148828
// Address: 0x148828 - 0x14883c

void FUN_00148828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148828: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14882c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x148830: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x148834: 0xc051d0a
    SET_GPR_U32(ctx, 31, 0x14883c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UpdateDprize__FP6DPRIZEf(rdram, ctx, runtime); return;
}


// Function: entry_14883c
// Address: 0x14883c - 0x148878

void entry_14883c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14883c: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x148840: 0x1440000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14887C; return;
    }
    // 0x148848: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14884c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148850: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x148854: 0xc4602308
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8968)); ctx->f[0] = *(float*)&val; }
    // 0x148858: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14885c: 0x0
    // NOP
    // 0x148860: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14887C; return;
    }
    // 0x148868: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14886c: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148870: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148878);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148878
// Address: 0x148878 - 0x148888

void entry_148878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148878) {
        switch (ctx->pc) {
            case 0x14887c: ctx->pc = 0; goto label_14887c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148878: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14887c:
    // 0x14887c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148880: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00148888
// Address: 0x148888 - 0x1488c4

void FUN_00148888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148888: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x14888c: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x148890: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x148894: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x148898: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x14889c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1488a0: 0x8e2202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x1488a4: 0x10500014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        entry_1488f8(rdram, ctx, runtime); return;
    }
    // 0x1488ac: 0x56020010
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1488F0; return;
    }
    // 0x1488b4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1488b8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1488bc: 0xc0780b2
    SET_GPR_U32(ctx, 31, 0x1488c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961656));
    gui_set_widget_modeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_1488c4
// Address: 0x1488c4 - 0x1488e8

void entry_1488c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1488c4: 0x8e220380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x1488c8: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1488e8(rdram, ctx, runtime); return;
    }
    // 0x1488d0: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1488d4: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x1488d8: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1488dc: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1488e0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1488e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1488e8
// Address: 0x1488e8 - 0x1488f8

void entry_1488e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1488e8) {
        switch (ctx->pc) {
            case 0x1488f0: ctx->pc = 0; goto label_1488f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1488e8: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1488ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1488f0:
    // 0x1488f0: 0xc051eac
    SET_GPR_U32(ctx, 31, 0x1488f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDprizeDprizes__FP6DPRIZE7DPRIZES(rdram, ctx, runtime); return;
}


// Function: entry_1488f8
// Address: 0x1488f8 - 0x148910

void entry_1488f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1488f8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1488fc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x148900: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x148904: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14890c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148910; return;
}


// Function: FUN_00148910__FPfT0
// Address: 0x148910 - 0x148938

void FUN_00148910__FPfT0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148910) {
        switch (ctx->pc) {
            case 0x14892c: ctx->pc = 0; goto label_14892c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148910: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x148914: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x148918: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14891c: 0x0
    // NOP
    // 0x148920: 0x45000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14892c;
    }
    // 0x148928: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_14892c:
    // 0x14892c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148938; return;
}


// Function: FUN_00148938
// Address: 0x148938 - 0x14897c

void FUN_00148938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148938) {
        switch (ctx->pc) {
            case 0x148974: ctx->pc = 0; goto label_148974;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148938: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x14893c: 0x7fb50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 21));
    // 0x148940: 0x7fb40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 20));
    // 0x148944: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x148948: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x14894c: 0xa0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x148950: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x148954: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x148958: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x14895c: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x148960: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x148964: 0x16000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_148974;
    }
    // 0x14896c: 0x1000004a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148A98; return;
    }
label_148974:
    // 0x148974: 0xc063582
    SET_GPR_U32(ctx, 31, 0x14897c);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14897c
// Address: 0x14897c - 0x148984

void entry_14897c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14897c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x148984);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_148984
// Address: 0x148984 - 0x1489ac

void entry_148984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148984) {
        switch (ctx->pc) {
            case 0x148998: ctx->pc = 0; goto label_148998;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148984: 0x14400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 320));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_148998;
    }
    // 0x14898c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148990: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x148994: 0x24620040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 64));
label_148998:
    // 0x148998: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14899c: 0x26641c54
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 7252));
    // 0x1489a0: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1489a4: 0xc0549f6
    SET_GPR_U32(ctx, 31, 0x1489ac);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    CPvDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_1489ac
// Address: 0x1489ac - 0x1489b4

void entry_1489ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1489ac: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1489b4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1489b4
// Address: 0x1489b4 - 0x148a58

void entry_1489b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1489b4) {
        switch (ctx->pc) {
            case 0x1489d8: ctx->pc = 0; goto label_1489d8;
            case 0x148a10: ctx->pc = 0; goto label_148a10;
            case 0x148a34: ctx->pc = 0; goto label_148a34;
            case 0x148a38: ctx->pc = 0; goto label_148a38;
            case 0x148a40: ctx->pc = 0; goto label_148a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1489b4: 0x8e641c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 7252)));
    // 0x1489b8: 0x10800021
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_148a40;
    }
    // 0x1489c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1489c4: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1489c8: 0xc4409e90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942352)); ctx->f[0] = *(float*)&val; }
    // 0x1489cc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1489d0: 0x8c820338
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 824)));
    // 0x1489d4: 0x0
    // NOP
label_1489d8:
    // 0x1489d8: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 884)));
        goto label_148a38;
    }
    // 0x1489e0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1489e4: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1489e8: 0x54740013
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 884)));
        goto label_148a38;
    }
    // 0x1489f0: 0xa0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1489f4: 0x24650008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1489f8: 0xaca4fffc
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294967292), GPR_U32(ctx, 4));
    // 0x1489fc: 0x8c8202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    // 0x148a00: 0x14460003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        goto label_148a10;
    }
    // 0x148a08: 0x1000000a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 4294967288), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_148a34;
    }
label_148a10:
    // 0x148a10: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148a14: 0xd8820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x148a18: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x148a1c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x148a20: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x148a24: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x148a28: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x148a2c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x148a30: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_148a34:
    // 0x148a34: 0x8c840374
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 884)));
label_148a38:
    // 0x148a38: 0x5480ffe7
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 824)));
        goto label_1489d8;
    }
label_148a40:
    // 0x148a40: 0x3c070015
    SET_GPR_U32(ctx, 7, ((uint32_t)21 << 16));
    // 0x148a44: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x148a48: 0x24e78910
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294936848));
    // 0x148a4c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x148a50: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x148a58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_148a58
// Address: 0x148a58 - 0x148a94

void entry_148a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148a58) {
        switch (ctx->pc) {
            case 0x148a70: ctx->pc = 0; goto label_148a70;
            case 0x148a8c: ctx->pc = 0; goto label_148a8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148a58: 0x230102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 16)));
    // 0x148a5c: 0x222800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 17));
    // 0x148a60: 0x1a00000a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_148a8c;
    }
    // 0x148a68: 0x26440004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4));
    // 0x148a6c: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_148a70:
    // 0x148a70: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148a74: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x148a78: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x148a7c: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x148a80: 0x0
    // NOP
    // 0x148a84: 0x1460fffa
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_148a70;
    }
label_148a8c:
    // 0x148a8c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x148a94);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_148a94
// Address: 0x148a94 - 0x148ac0

void entry_148a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148a94) {
        switch (ctx->pc) {
            case 0x148a98: ctx->pc = 0; goto label_148a98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148a94: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_148a98:
    // 0x148a98: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x148a9c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x148aa0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x148aa4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x148aa8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x148aac: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x148ab0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148ab4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148abc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148ac0; return;
}


// Function: CpdprizeAttractSwDprizes__FP2SW3CIDP6VECTORiPP6DPRIZE
// Address: 0x148ac0 - 0x148b10

void entry_148b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148b10: 0x16000005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x148B28; return;
    }
    // 0x148b18: 0xc063596
    SET_GPR_U32(ctx, 31, 0x148b20);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 17), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_148b20
// Address: 0x148b20 - 0x148b38

void entry_148b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148b20) {
        switch (ctx->pc) {
            case 0x148b28: ctx->pc = 0; goto label_148b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148b20: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x148b24: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_148b28:
    // 0x148b28: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x148b2c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x148b30: 0xc05224e
    SET_GPR_U32(ctx, 31, 0x148b38);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00148938(rdram, ctx, runtime); return;
}


// Function: entry_148b38
// Address: 0x148b38 - 0x148b60

void entry_148b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148b38: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148b3c: 0x44910000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 17);
    // 0x148b40: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x148b44: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x148b48: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x148b4c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x148b50: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x148b54: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x148b58: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x148b60);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[22] = ctx->f[13] / ctx->f[0];
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_148b60
// Address: 0x148b60 - 0x148b98

void entry_148b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148b60) {
        switch (ctx->pc) {
            case 0x148b80: ctx->pc = 0; goto label_148b80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148b60: 0x1a80004d
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x148C98; return;
    }
    // 0x148b68: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x148b6c: 0x3c1e0026
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    // 0x148b70: 0x24568d30
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x148b74: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x148b78: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148b7c: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_148b80:
    // 0x148b80: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x148b84: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148b88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148b8c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x148b90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148b98);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 768));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148b98
// Address: 0x148b98 - 0x148bac

void entry_148b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148b98: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148b9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148ba0: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x148ba4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148bac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148bac
// Address: 0x148bac - 0x148bc0

void entry_148bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148bac: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148bb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148bb4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x148bb8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148bc0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148bc0
// Address: 0x148bc0 - 0x148bd8

void entry_148bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148bc0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148bc4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x148bc8: 0x244583d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x148bcc: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x148bd0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148bd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148bd8
// Address: 0x148bd8 - 0x148bec

void entry_148bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148bd8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148bdc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148be0: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x148be4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148bec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148bec
// Address: 0x148bec - 0x148c00

void entry_148bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148bec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148bf0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148bf4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x148bf8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148c00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148c00
// Address: 0x148c00 - 0x148c34

void entry_148c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148c00: 0x44920000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 18);
    // 0x148c04: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x148c08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148c0c: 0xc4411b40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6976)); ctx->f[1] = *(float*)&val; }
    // 0x148c10: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x148c14: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148c18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x148c1c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x148c20: 0xae00033c
    WRITE32(ADD32(GPR_U32(ctx, 16), 828), GPR_U32(ctx, 0));
    // 0x148c24: 0xe60002e0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 736), *(uint32_t*)&val); }
    // 0x148c28: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148c2c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148c34);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148c34
// Address: 0x148c34 - 0x148c48

void entry_148c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148c34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148c38: 0xc7cc1b48
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 6984)); ctx->f[12] = *(float*)&val; }
    // 0x148c3c: 0x24421b48
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6984));
    // 0x148c40: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x148c48);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_148c48
// Address: 0x148c48 - 0x148c60

void entry_148c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148c48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x148c4c: 0xc6ec1b50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 6992)); ctx->f[12] = *(float*)&val; }
    // 0x148c50: 0x24421b50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6992));
    // 0x148c54: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x148c58: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x148c60);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_148c60
// Address: 0x148c60 - 0x148c74

void entry_148c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148c60: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x148c64: 0x46000386
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    // 0x148c68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x148c6c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x148c74);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_148c74
// Address: 0x148c74 - 0x148c8c

void entry_148c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148c74: 0x4616ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[22]);
    // 0x148c78: 0x8ea41ec4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 7876)));
    // 0x148c7c: 0x26060088
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 136));
    // 0x148c80: 0xc60c02a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 680)); ctx->f[12] = *(float*)&val; }
    // 0x148c84: 0xc07bad8
    SET_GPR_U32(ctx, 31, 0x148c8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_148c8c
// Address: 0x148c8c - 0x148ca0

void entry_148c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148c8c) {
        switch (ctx->pc) {
            case 0x148c98: ctx->pc = 0; goto label_148c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148c8c: 0x254102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 20)));
    // 0x148c90: 0x5440ffbb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x148B80; return;
    }
label_148c98:
    // 0x148c98: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x148ca0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_148ca0
// Address: 0x148ca0 - 0x148ce0

void entry_148ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148ca0: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x148ca4: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x148ca8: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x148cac: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x148cb0: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x148cb4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x148cb8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x148cbc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x148cc0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x148cc4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x148cc8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148ccc: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x148cd0: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x148cd4: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x148cd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveSwExtraneousCharms__FP2SW
// Address: 0x148ce0 - 0x148d20

void entry_148d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148d20) {
        switch (ctx->pc) {
            case 0x148d40: ctx->pc = 0; goto label_148d40;
            case 0x148d50: ctx->pc = 0; goto label_148d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148d20: 0x8e0319e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6628)));
    // 0x148d24: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x148d28: 0x10600005
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_148d40;
    }
    // 0x148d30: 0x8c62ec58
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294962264)));
    // 0x148d34: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x148d38: 0x14400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x148D80; return;
    }
label_148d40:
    // 0x148d40: 0x8e301c54
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 7252)));
    // 0x148d44: 0x1200000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148D80; return;
    }
    // 0x148d4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_148d50:
    // 0x148d50: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x148d58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 86));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_148d58
// Address: 0x148d58 - 0x148d70

void entry_148d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148d58: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_148d70(rdram, ctx, runtime); return;
    }
    // 0x148d60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148d64: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148d68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148d70);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148d70
// Address: 0x148d70 - 0x148d90

void entry_148d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148d70) {
        switch (ctx->pc) {
            case 0x148d80: ctx->pc = 0; goto label_148d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148d70: 0x8e100374
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 884)));
    // 0x148d74: 0x1600fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x148D50; return;
    }
    // 0x148d7c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_148d80:
    // 0x148d80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148d84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148d88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00148d90
// Address: 0x148d90 - 0x148da4

void FUN_00148d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148d90: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x148d94: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x148d98: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x148d9c: 0xc0518d0
    SET_GPR_U32(ctx, 31, 0x148da4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitDprize__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_148da4
// Address: 0x148da4 - 0x148e18

void entry_148da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148da4: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x148da8: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x148dac: 0x3c014234
    SET_GPR_U32(ctx, 1, ((uint32_t)16948 << 16));
    // 0x148db0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x148db4: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x148db8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x148dbc: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x148dc0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x148dc4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x148dc8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x148dcc: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x148dd0: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x148dd4: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x148dd8: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x148ddc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x148de0: 0xe601034c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 844), *(uint32_t*)&val); }
    // 0x148de4: 0xe6000394
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 916), *(uint32_t*)&val); }
    // 0x148de8: 0xe6020344
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 836), *(uint32_t*)&val); }
    // 0x148dec: 0xe6060348
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 840), *(uint32_t*)&val); }
    // 0x148df0: 0xe6030358
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x148df4: 0xe6040354
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    // 0x148df8: 0xe6050390
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 912), *(uint32_t*)&val); }
    // 0x148dfc: 0xe6060350
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x148e00: 0xae000320
    WRITE32(ADD32(GPR_U32(ctx, 16), 800), GPR_U32(ctx, 0));
    // 0x148e04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148e08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148e0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148e14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148e18; return;
}


// Function: FUN_00148e18
// Address: 0x148e18 - 0x148e30

void FUN_00148e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148e18: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x148e1c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x148e20: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x148e24: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148e28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148e30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148e30
// Address: 0x148e30 - 0x148e40

void entry_148e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148e30: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148e34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148e3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148e40; return;
}


// Function: FUN_00148e40
// Address: 0x148e40 - 0x148e64

void FUN_00148e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148e40: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x148e44: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x148e48: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x148e4c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x148e50: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x148e54: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x148e58: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x148e5c: 0xc049cde
    SET_GPR_U32(ctx, 31, 0x148e64);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    HandleAloMessage__FP3ALO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_148e64
// Address: 0x148e64 - 0x148e88

void entry_148e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148e64: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x148e68: 0x1602001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x148EE4; return;
    }
    // 0x148e70: 0x8e4202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x148e74: 0x5622001c
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
        ctx->pc = 0x148EE8; return;
    }
    // 0x148e7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x148e80: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x148e88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_148e88
// Address: 0x148e88 - 0x148ec4

void entry_148e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148e88: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x148e8c: 0x24020263
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 611));
    // 0x148e90: 0x14620014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x148EE4; return;
    }
    // 0x148e98: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x148e9c: 0x8c431d60
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7520)));
    // 0x148ea0: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_148ec4(rdram, ctx, runtime); return;
    }
    // 0x148ea8: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x148eac: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x148eb0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x148eb4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x148eb8: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x148ebc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x148ec4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_148ec4
// Address: 0x148ec4 - 0x148ee0

void entry_148ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148ec4: 0x3c050015
    SET_GPR_U32(ctx, 5, ((uint32_t)21 << 16));
    // 0x148ec8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x148ecc: 0x24a58e18
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294938136));
    // 0x148ed0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x148ed4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x148ed8: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x148ee0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_148ee0
// Address: 0x148ee0 - 0x148ef8

void entry_148ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148ee0) {
        switch (ctx->pc) {
            case 0x148ee4: ctx->pc = 0; goto label_148ee4;
            case 0x148ee8: ctx->pc = 0; goto label_148ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148ee0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_148ee4:
    // 0x148ee4: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_148ee8:
    // 0x148ee8: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x148eec: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x148ef0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00148ef8
// Address: 0x148ef8 - 0x148f0c

void FUN_00148ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x148ef8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x148efc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x148f00: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x148f04: 0xc051d0a
    SET_GPR_U32(ctx, 31, 0x148f0c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UpdateDprize__FP6DPRIZEf(rdram, ctx, runtime); return;
}


// Function: entry_148f0c
// Address: 0x148f0c - 0x148f6c

void entry_148f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148f0c) {
        switch (ctx->pc) {
            case 0x148f44: ctx->pc = 0; goto label_148f44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148f0c: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x148f10: 0x14400017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x148F70; return;
    }
    // 0x148f18: 0x8e020338
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 824)));
    // 0x148f1c: 0x10400014
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x148F70; return;
    }
    // 0x148f24: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x148f28: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x148f2c: 0x10640005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_148f44;
    }
    // 0x148f34: 0xc6000398
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 920)); ctx->f[0] = *(float*)&val; }
    // 0x148f38: 0xc4411860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[1] = *(float*)&val; }
    // 0x148f3c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x148f40: 0xe6000398
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 920), *(uint32_t*)&val); }
label_148f44:
    // 0x148f44: 0xc6010398
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 920)); ctx->f[1] = *(float*)&val; }
    // 0x148f48: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x148f4c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x148f50: 0x0
    // NOP
    // 0x148f54: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_148f6c(rdram, ctx, runtime); return;
    }
    // 0x148f5c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x148f60: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x148f64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x148f6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_148f6c
// Address: 0x148f6c - 0x148f80

void entry_148f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148f6c) {
        switch (ctx->pc) {
            case 0x148f70: ctx->pc = 0; goto label_148f70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148f6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_148f70:
    // 0x148f70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148f74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x148f7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x148f80; return;
}


// Function: increment_and_show_life_count
// Address: 0x148f80 - 0x148fa4

void entry_148fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x148fa4) {
        switch (ctx->pc) {
            case 0x148fd8: ctx->pc = 0; goto label_148fd8;
            case 0x148fe0: ctx->pc = 0; goto label_148fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x148fa4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x148fa8: 0x8c6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x148fac: 0x8c6419e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
    // 0x148fb0: 0x28820063
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 99));
    // 0x148fb4: 0x10400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_148fd8;
    }
    // 0x148fbc: 0x3c01437a
    SET_GPR_U32(ctx, 1, ((uint32_t)17274 << 16));
    // 0x148fc0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x148fc4: 0xac6219e0
    WRITE32(ADD32(GPR_U32(ctx, 3), 6624), GPR_U32(ctx, 2));
    // 0x148fc8: 0xe600026c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 620), *(uint32_t*)&val); }
    // 0x148fcc: 0xae000278
    WRITE32(ADD32(GPR_U32(ctx, 16), 632), GPR_U32(ctx, 0));
    // 0x148fd0: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_148fe0;
    }
label_148fd8:
    // 0x148fd8: 0x24020063
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 99));
    // 0x148fdc: 0xac6219e0
    WRITE32(ADD32(GPR_U32(ctx, 3), 6624), GPR_U32(ctx, 2));
label_148fe0:
    // 0x148fe0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x148fe4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x148fe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CollectLifetkn__FP7LIFETKN
// Address: 0x148ff0 - 0x149044

void entry_149044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149044) {
        switch (ctx->pc) {
            case 0x14904c: ctx->pc = 0; goto label_14904c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149044: 0x10000040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 920), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149148; return;
    }
label_14904c:
    // 0x14904c: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x149050: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x149058);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_149058
// Address: 0x149058 - 0x149090

void entry_149058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149058: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14905c: 0x12000014
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1490B0; return;
    }
    // 0x149064: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x149068: 0x24421b60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7008));
    // 0x14906c: 0xae110134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 17));
    // 0x149070: 0xae020130
    WRITE32(ADD32(GPR_U32(ctx, 16), 304), GPR_U32(ctx, 2));
    // 0x149074: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149078: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14907c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x149080: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x149084: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x149088: 0x40f809
    SET_GPR_U32(ctx, 31, 0x149090);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_149090
// Address: 0x149090 - 0x1490b8

void entry_149090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149090) {
        switch (ctx->pc) {
            case 0x1490b0: ctx->pc = 0; goto label_1490b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149090: 0xae110020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 17));
    // 0x149094: 0x7a220110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x149098: 0x7e020050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 2));
    // 0x14909c: 0x7a230120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x1490a0: 0x7e030060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), GPR_VEC(ctx, 3));
    // 0x1490a4: 0x7a220130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x1490a8: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1490b8(rdram, ctx, runtime); return;
    }
label_1490b0:
    // 0x1490b0: 0xc0523e0
    SET_GPR_U32(ctx, 31, 0x1490b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    increment_and_show_life_count(rdram, ctx, runtime); return;
}


// Function: entry_1490b8
// Address: 0x1490b8 - 0x1490cc

void entry_1490b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1490b8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1490bc: 0x8c83c6c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294952648)));
    // 0x1490c0: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1490c4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1490cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952648));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1490cc
// Address: 0x1490cc - 0x1490dc

void entry_1490cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1490cc: 0x8e25037c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 892)));
    // 0x1490d0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1490d4: 0xc050410
    SET_GPR_U32(ctx, 31, 0x1490dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1490dc
// Address: 0x1490dc - 0x14911c

void entry_1490dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1490dc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1490e0: 0x24040069
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 105));
    // 0x1490e4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1490e8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1490ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1490f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1490f4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1490f8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1490fc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149100: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149104: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x149108: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14910c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x149110: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149114: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x14911c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_14911c
// Address: 0x14911c - 0x149144

void entry_14911c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14911c: 0x8e230380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x149120: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_149144(rdram, ctx, runtime); return;
    }
    // 0x149128: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x14912c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x149130: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x149134: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x149138: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x14913c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x149144);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_149144
// Address: 0x149144 - 0x149154

void entry_149144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149144) {
        switch (ctx->pc) {
            case 0x149148: ctx->pc = 0; goto label_149148;
            case 0x14914c: ctx->pc = 0; goto label_14914c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149144: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
label_149148:
    // 0x149148: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_14914c:
    // 0x14914c: 0xc051eac
    SET_GPR_U32(ctx, 31, 0x149154);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDprizeDprizes__FP6DPRIZE7DPRIZES(rdram, ctx, runtime); return;
}


// Function: entry_149154
// Address: 0x149154 - 0x149168

void entry_149154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149154) {
        switch (ctx->pc) {
            case 0x149158: ctx->pc = 0; goto label_149158;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149154: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_149158:
    // 0x149158: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14915c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x149160: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00149168
// Address: 0x149168 - 0x14917c

void FUN_00149168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149168: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14916c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x149170: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x149174: 0xc0518d0
    SET_GPR_U32(ctx, 31, 0x14917c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitDprize__FP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_14917c
// Address: 0x14917c - 0x149190

void entry_14917c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14917c: 0xae000340
    WRITE32(ADD32(GPR_U32(ctx, 16), 832), GPR_U32(ctx, 0));
    // 0x149180: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x149184: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x149188: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: break_bottle
// Address: 0x149190 - 0x1491b8

void entry_1491b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1491b8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1491bc: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1491c0: 0x24421bd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7120));
    // 0x1491c4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1491c8: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1491cc: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1491d0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1491d4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1491d8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1491dc: 0x24060019
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 25));
    // 0x1491e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1491e4: 0x24080006
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1491e8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1491f0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1491f0
// Address: 0x1491f0 - 0x149274

void entry_1491f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1491f0) {
        switch (ctx->pc) {
            case 0x149208: ctx->pc = 0; goto label_149208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1491f0: 0x18400060
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x149374; return;
    }
    // 0x1491f8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1491fc: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x149200: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x149204: 0x0
    // NOP
label_149208:
    // 0x149208: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x14920c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x149210: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x149214: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149218: 0x3c014874
    SET_GPR_U32(ctx, 1, ((uint32_t)18548 << 16));
    // 0x14921c: 0x34212400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 9216));
    // 0x149220: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x149224: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149228: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14922c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149230: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x149234: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x149238: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14923c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149240: 0x0
    // NOP
    // 0x149244: 0x45030049
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
        ctx->pc = 0x14936C; return;
    }
    // 0x14924c: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x149250: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x149254: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x149258: 0x8e0503f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1012)));
    // 0x14925c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149260: 0x8e0603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x149264: 0x260803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 932));
    // 0x149268: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14926c: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x149274);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_149274
// Address: 0x149274 - 0x149284

void entry_149274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149274: 0x5840003d
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
        ctx->pc = 0x14936C; return;
    }
    // 0x14927c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x149284);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_149284
// Address: 0x149284 - 0x1492e8

void entry_149284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149284) {
        switch (ctx->pc) {
            case 0x1492ac: ctx->pc = 0; goto label_1492ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149284: 0x16020009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1492ac;
    }
    // 0x14928c: 0x8e020858
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2136)));
    // 0x149290: 0x24030062
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 98));
    // 0x149294: 0x24040063
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 99));
    // 0x149298: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x14929c: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1492a0: 0x43200a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1492a4: 0xae040858
    WRITE32(ADD32(GPR_U32(ctx, 16), 2136), GPR_U32(ctx, 4));
    // 0x1492a8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1492ac:
    // 0x1492ac: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1492b0: 0x8c421be0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 7136)));
    // 0x1492b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1492b8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1492bc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1492c0: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1492c4: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1492c8: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1492cc: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1492d0: 0xc7a00068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[0] = *(float*)&val; }
    // 0x1492d4: 0x4600a028
    ctx->f[0] = std::max(ctx->f[20], ctx->f[0]);
    // 0x1492d8: 0xe7a00068
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x1492dc: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1492e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1492e8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1492e8
// Address: 0x1492e8 - 0x149310

void entry_1492e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1492e8: 0x8e230380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x1492ec: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_149310(rdram, ctx, runtime); return;
    }
    // 0x1492f4: 0xafb10084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 17));
    // 0x1492f8: 0xafa20080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 2));
    // 0x1492fc: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x149300: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x149304: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x149308: 0x60f809
    SET_GPR_U32(ctx, 31, 0x149310);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_149310
// Address: 0x149310 - 0x149354

void entry_149310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149310: 0x3c0145ea
    SET_GPR_U32(ctx, 1, ((uint32_t)17898 << 16));
    // 0x149314: 0x34216000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 24576));
    // 0x149318: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14931c: 0x2404002c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 44));
    // 0x149320: 0x3c01451c
    SET_GPR_U32(ctx, 1, ((uint32_t)17692 << 16));
    // 0x149324: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x149328: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14932c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149330: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x149334: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x149338: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14933c: 0xc68f1be4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 7140)); ctx->f[15] = *(float*)&val; }
    // 0x149340: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x149344: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x149348: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14934c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x149354);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_149354
// Address: 0x149354 - 0x149368

void entry_149354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149354: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x149358: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14935c: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x149360: 0x40f809
    SET_GPR_U32(ctx, 31, 0x149368);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_149368
// Address: 0x149368 - 0x149398

void entry_149368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149368) {
        switch (ctx->pc) {
            case 0x14936c: ctx->pc = 0; goto label_14936c;
            case 0x149374: ctx->pc = 0; goto label_149374;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149368: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
label_14936c:
    // 0x14936c: 0x1640ffa6
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x149208; return;
    }
label_149374:
    // 0x149374: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x149378: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x14937c: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x149380: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x149384: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x149388: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14938c: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x149390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCplcy
// Address: 0x149398 - 0x1493a0

void FUN_001493c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1493c0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PosCplookAnchor
// Address: 0x1493c8 - 0x1493ec

void entry_1493ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1493ec) {
        switch (ctx->pc) {
            case 0x1493f4: ctx->pc = 0; goto label_1493f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1493ec: 0x10000013
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14943C; return;
    }
label_1493f4:
    // 0x1493f4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1493fc);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1493fc
// Address: 0x1493fc - 0x14940c

void entry_1493fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1493fc: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14942C; return;
    }
    // 0x149404: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14940c);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14940c
// Address: 0x14940c - 0x149458

void entry_14940c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14940c) {
        switch (ctx->pc) {
            case 0x14942c: ctx->pc = 0; goto label_14942c;
            case 0x149438: ctx->pc = 0; goto label_149438;
            case 0x14943c: ctx->pc = 0; goto label_14943c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14940c: 0x78430140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x149410: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149414: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x149418: 0xc4411bf8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7160)); ctx->f[1] = *(float*)&val; }
    // 0x14941c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x149420: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x149424: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149438;
    }
label_14942c:
    // 0x14942c: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x149430: 0x78830040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x149434: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
label_149438:
    // 0x149438: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_14943c:
    // 0x14943c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149440: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x149444: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
    // 0x149448: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14944c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x149454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x149458; return;
}


// Function: FUN_00149458
// Address: 0x149458 - 0x1494b4

void FUN_00149458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149458) {
        switch (ctx->pc) {
            case 0x14949c: ctx->pc = 0; goto label_14949c;
            case 0x1494a0: ctx->pc = 0; goto label_1494a0;
            case 0x1494a4: ctx->pc = 0; goto label_1494a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149458: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x14945c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149460: 0x7fb20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 18));
    // 0x149464: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x149468: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14946c: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x149470: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x149474: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x149478: 0x10400008
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14949c;
    }
    // 0x149480: 0x8c432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8744)));
    // 0x149484: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    // 0x149488: 0x14620005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1494a0;
    }
    // 0x149490: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149494: 0x10000003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 7200));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1494a4;
    }
label_14949c:
    // 0x14949c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1494a0:
    // 0x1494a0: 0x24511c10
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 7184));
label_1494a4:
    // 0x1494a4: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1494a8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1494ac: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1494b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[13] = *(float*)&val; }
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1494b4
// Address: 0x1494b4 - 0x1494c0

void entry_1494b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1494b4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1494b8: 0xc0524f2
    SET_GPR_U32(ctx, 31, 0x1494c0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    PosCplookAnchor(rdram, ctx, runtime); return;
}


// Function: entry_1494c0
// Address: 0x1494c0 - 0x149508

void entry_1494c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1494c0: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1494c4: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1494c8: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1494cc: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1494d0: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1494d4: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1494d8: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1494dc: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1494e0: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1494e4: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1494e8: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1494ec: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1494f0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1494f4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1494f8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1494fc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x149500: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: plays_binoc_sfx
// Address: 0x149508 - 0x149578

void entry_149578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149578: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x14957c: 0x10400004
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149590; return;
    }
    // 0x149584: 0xc047590
    SET_GPR_U32(ctx, 31, 0x14958c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    snd_PauseSound(rdram, ctx, runtime); return;
}


// Function: entry_14958c
// Address: 0x14958c - 0x1495bc

void entry_14958c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14958c) {
        switch (ctx->pc) {
            case 0x149590: ctx->pc = 0; goto label_149590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14958c: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
label_149590:
    // 0x149590: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x149594: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x149598: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x14959c: 0x2605004c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 76));
    // 0x1495a0: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1495a4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1495a8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1495ac: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1495b0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1495b4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1495bc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1495bc
// Address: 0x1495bc - 0x1495e8

void entry_1495bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1495bc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1495c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1495c4: 0xae020044
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 2));
    // 0x1495c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1495cc: 0xc7b70038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[23] = *(float*)&val; }
    // 0x1495d0: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x1495d4: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1495d8: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1495dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1495e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1495e8; return;
}


// Function: PushCplookLookk__FP6CPLOOK5LOOKK
// Address: 0x1495e8 - 0x149610

void entry_149674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149674: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x149678: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14967c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149680: 0xae000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 0));
    // 0x149684: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149688: 0xc05257a
    SET_GPR_U32(ctx, 31, 0x149690);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    PushCplookLookk__FP6CPLOOK5LOOKK(rdram, ctx, runtime); return;
}


// Function: entry_149690
// Address: 0x149690 - 0x1496c0

void entry_149690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149690: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x149694: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x149698: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x14969c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1496a0: 0xe6000054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
    // 0x1496a4: 0xe6010058
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x1496a8: 0xae000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 0));
    // 0x1496ac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1496b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1496b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1496bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1496c0; return;
}


// Function: FUN_001496c0
// Address: 0x1496c0 - 0x1496e8

void FUN_001496c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1496c0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1496c4: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1496c8: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1496cc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1496d0: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1496d4: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1496d8: 0x26060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1496dc: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1496e0: 0xc06248c
    SET_GPR_U32(ctx, 31, 0x1496e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 128));
    DecomposeRotateMatrixPanTilt__FP7MATRIX3PfT1(rdram, ctx, runtime); return;
}


// Function: entry_1496e8
// Address: 0x1496e8 - 0x149724

void entry_1496e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1496e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1496ec: 0xc6010020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1496f0: 0xc4401bf0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7152)); ctx->f[0] = *(float*)&val; }
    // 0x1496f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1496f8: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1496fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149700: 0xe6000010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x149704: 0xae000014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 0));
    // 0x149708: 0xae000018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
    // 0x14970c: 0xae00001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 0));
    // 0x149710: 0xc62001c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 456)); ctx->f[0] = *(float*)&val; }
    // 0x149714: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x149718: 0xe6000028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x14971c: 0xc0524f2
    SET_GPR_U32(ctx, 31, 0x149724);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    PosCplookAnchor(rdram, ctx, runtime); return;
}


// Function: entry_149724
// Address: 0x149724 - 0x149730

void entry_149724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149724: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x149728: 0xc0512dc
    SET_GPR_U32(ctx, 31, 0x149730);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ResetCmLookAtSmooth(rdram, ctx, runtime); return;
}


// Function: entry_149730
// Address: 0x149730 - 0x149748

void entry_149730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149730: 0xc62001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 484)); ctx->f[0] = *(float*)&val; }
    // 0x149734: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x149738: 0x3c014244
    SET_GPR_U32(ctx, 1, ((uint32_t)16964 << 16));
    // 0x14973c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x149740: 0xc050e5a
    SET_GPR_U32(ctx, 31, 0x149748);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    SetCmNearClip__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_149748
// Address: 0x149748 - 0x149760

void entry_149748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149748: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14974c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x149750: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x149754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14975c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x149760; return;
}


// Function: UpdateCplook
// Address: 0x149760 - 0x1497c0

void entry_1497c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1497c0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1497c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1497c8: 0x8e550004
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1497cc: 0x4600b832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1497d0: 0x0
    // NOP
    // 0x1497d4: 0x450103e5
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7156)); ctx->f[27] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        entry_14a76c(rdram, ctx, runtime); return;
    }
    // 0x1497dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1497e0: 0xc05258e
    SET_GPR_U32(ctx, 31, 0x1497e8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 36));
    LookkCurCplook__FP6CPLOOK(rdram, ctx, runtime); return;
}


// Function: entry_1497e8
// Address: 0x1497e8 - 0x149900

void entry_1497e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1497e8) {
        switch (ctx->pc) {
            case 0x149874: ctx->pc = 0; goto label_149874;
            case 0x149884: ctx->pc = 0; goto label_149884;
            case 0x1498b8: ctx->pc = 0; goto label_1498b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1497e8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1497ec: 0x2e620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    // 0x1497f0: 0x1040014b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149D20; return;
    }
    // 0x1497f8: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x1497fc: 0x24429eb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942384));
    // 0x149800: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x149804: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x149808: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x149810: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149814: 0xc6430018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[3] = *(float*)&val; }
    // 0x149818: 0x24431c30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 7216));
    // 0x14981c: 0xc4401c30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7216)); ctx->f[0] = *(float*)&val; }
    // 0x149820: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x149824: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x149828: 0x46021882
    ctx->f[2] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x14982c: 0xc6840078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 120)); ctx->f[4] = *(float*)&val; }
    // 0x149830: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x149834: 0x46002145
    ctx->f[5] = FPU_ABS_S(ctx->f[4]);
    // 0x149838: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14983c: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x149840: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x149844: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x149848: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14984c: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x149850: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x149854: 0x46170042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x149858: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x14985c: 0x46061834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149860: 0x0
    // NOP
    // 0x149864: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 28), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149874;
    }
    // 0x14986c: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149884;
    }
label_149874:
    // 0x149874: 0x46033834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[7], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149878: 0x0
    // NOP
    // 0x14987c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[7]);
        goto label_149884;
    }
label_149884:
    // 0x149884: 0xe6430018
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 24), *(uint32_t*)&val); }
    // 0x149888: 0x10000125
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 36));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149D20; return;
    }
    // 0x149890: 0x8e510050
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x149894: 0x12200097
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149AF4; return;
    }
    // 0x14989c: 0xc6400058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 88)); ctx->f[0] = *(float*)&val; }
    // 0x1498a0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1498a4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1498a8: 0x0
    // NOP
    // 0x1498ac: 0x45010002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1498b8;
    }
    // 0x1498b4: 0xc63402a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 680)); ctx->f[20] = *(float*)&val; }
label_1498b8:
    // 0x1498b8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1498bc: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1498c0: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1498c4: 0xc64c0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 84)); ctx->f[12] = *(float*)&val; }
    // 0x1498c8: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1498cc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1498d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1498d4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1498d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1498dc: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1498e0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1498e4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1498e8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1498ec: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1498f0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1498f4: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1498f8: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x149900);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[12] = ctx->f[20] / ctx->f[12];
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_149900
// Address: 0x149900 - 0x149934

void entry_149900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149900: 0x46000540
    ctx->f[21] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x149904: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x149908: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x14990c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x149910: 0xc6400024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 36)); ctx->f[0] = *(float*)&val; }
    // 0x149914: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x149918: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14991c: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x149920: 0x46150568
    ctx->f[21] = std::max(ctx->f[0], ctx->f[21]);
    // 0x149924: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x149928: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14992c: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x149934);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_149934
// Address: 0x149934 - 0x149a28

void entry_149934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149934: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x149938: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14993c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149940: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x149944: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x149948: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14994c: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x149950: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x149954: 0x8e031990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x149958: 0xda240140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x14995c: 0x4be208d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149960: 0x4be32128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x149964: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x149968: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14996c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149970: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x149974: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149978: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14997c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x149980: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x149984: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x149988: 0x24620080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 128));
    // 0x14998c: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x149990: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x149994: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x149998: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14999c: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1499a0: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1499a4: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1499a8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1499ac: 0xfba40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1499b0: 0x4600a580
    ctx->f[22] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1499b4: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1499b8: 0xd8620080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1499bc: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1499c0: 0x4be4122a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1499c4: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1499c8: 0x4be409ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1499cc: 0x4be419aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1499d0: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1499d4: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1499d8: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1499dc: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1499e0: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1499e4: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1499e8: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1499ec: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x1499f0: 0xc7a30050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[3] = *(float*)&val; }
    // 0x1499f4: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1499f8: 0xc7a10058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[1] = *(float*)&val; }
    // 0x1499fc: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149a00: 0xe7a30068
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x149a04: 0xe7a10064
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 100), *(uint32_t*)&val); }
    // 0x149a08: 0x45000013
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x149A58; return;
    }
    // 0x149a10: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x149a14: 0xc46c01e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 480)); ctx->f[12] = *(float*)&val; }
    // 0x149a18: 0x460c1b02
    ctx->f[12] = FPU_MUL_S(ctx->f[3], ctx->f[12]);
    // 0x149a1c: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x149a20: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x149a28);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[12];
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_149a28
// Address: 0x149a28 - 0x149a44

void entry_149a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149a28: 0xc7ac0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[12] = *(float*)&val; }
    // 0x149a2c: 0x46000500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x149a30: 0xc7a00068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[0] = *(float*)&val; }
    // 0x149a34: 0x46006305
    ctx->f[12] = FPU_ABS_S(ctx->f[12]);
    // 0x149a38: 0x46166300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[22]);
    // 0x149a3c: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x149a44);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_149a44
// Address: 0x149a44 - 0x149c4c

void entry_149a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149a44) {
        switch (ctx->pc) {
            case 0x149a58: ctx->pc = 0; goto label_149a58;
            case 0x149a5c: ctx->pc = 0; goto label_149a5c;
            case 0x149a88: ctx->pc = 0; goto label_149a88;
            case 0x149a94: ctx->pc = 0; goto label_149a94;
            case 0x149ab8: ctx->pc = 0; goto label_149ab8;
            case 0x149ac8: ctx->pc = 0; goto label_149ac8;
            case 0x149af4: ctx->pc = 0; goto label_149af4;
            case 0x149b00: ctx->pc = 0; goto label_149b00;
            case 0x149b04: ctx->pc = 0; goto label_149b04;
            case 0x149b58: ctx->pc = 0; goto label_149b58;
            case 0x149b94: ctx->pc = 0; goto label_149b94;
            case 0x149c34: ctx->pc = 0; goto label_149c34;
            case 0x149c38: ctx->pc = 0; goto label_149c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149a44: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x149a48: 0xc6410028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 40)); ctx->f[1] = *(float*)&val; }
    // 0x149a4c: 0x46140028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[20]);
    // 0x149a50: 0x10000002
    ctx->f[3] = std::min(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149a5c;
    }
label_149a58:
    // 0x149a58: 0xc6430028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 40)); ctx->f[3] = *(float*)&val; }
label_149a5c:
    // 0x149a5c: 0x26420024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 36));
    // 0x149a60: 0xc6400024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 36)); ctx->f[0] = *(float*)&val; }
    // 0x149a64: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x149a68: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x149a6c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149a70: 0x0
    // NOP
    // 0x149a74: 0x45000004
    ctx->f[2] = std::max(ctx->f[21], ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149a88;
    }
    // 0x149a7c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x149a80: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149a94;
    }
label_149a88:
    // 0x149a88: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x149a8c: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x149a90: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
label_149a94:
    // 0x149a94: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149a98: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x149a9c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x149aa0: 0x46001381
    ctx->f[14] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x149aa4: 0x46017034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149aa8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149ab8;
    }
    // 0x149ab0: 0x10000005
    ctx->f[14] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149ac8;
    }
label_149ab8:
    // 0x149ab8: 0x460e1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149abc: 0x0
    // NOP
    // 0x149ac0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[14] = FPU_MOV_S(ctx->f[2]);
        goto label_149ac8;
    }
label_149ac8:
    // 0x149ac8: 0x4603a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149acc: 0x0
    // NOP
    // 0x149ad0: 0x4500000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149b00;
    }
    // 0x149ad8: 0xc6400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
    // 0x149adc: 0x46007034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149ae0: 0x0
    // NOP
    // 0x149ae4: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
        goto label_149b00;
    }
    // 0x149aec: 0x10000005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149b04;
    }
label_149af4:
    // 0x149af4: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x149af8: 0x26500024
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 36));
    // 0x149afc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_149b00:
    // 0x149b00: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
label_149b04:
    // 0x149b04: 0x8c430518
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1304)));
    // 0x149b08: 0x50640013
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[2] = *(float*)&val; }
        goto label_149b58;
    }
    // 0x149b10: 0x56c00048
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        goto label_149c34;
    }
    // 0x149b18: 0xc6420018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[2] = *(float*)&val; }
    // 0x149b1c: 0x46027034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b20: 0x4500000d
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149b58;
    }
    // 0x149b28: 0xc641001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[1] = *(float*)&val; }
    // 0x149b2c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x149b30: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b34: 0x45010017
    if ((ctx->fcr31 & 0x800000)) {
        goto label_149b94;
    }
    // 0x149b3c: 0x460e1041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[14]);
    // 0x149b40: 0x3c013ccc
    SET_GPR_U32(ctx, 1, ((uint32_t)15564 << 16));
    // 0x149b44: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x149b48: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x149b4c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b50: 0x45010010
    if ((ctx->fcr31 & 0x800000)) {
        goto label_149b94;
    }
label_149b58:
    // 0x149b58: 0x460e1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b5c: 0x4500003d
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x149C54; return;
    }
    // 0x149b64: 0xc641001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[1] = *(float*)&val; }
    // 0x149b68: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x149b6c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b70: 0x45010008
    if ((ctx->fcr31 & 0x800000)) {
        goto label_149b94;
    }
    // 0x149b78: 0x46027041
    ctx->f[1] = FPU_SUB_S(ctx->f[14], ctx->f[2]);
    // 0x149b7c: 0x3c013d0f
    SET_GPR_U32(ctx, 1, ((uint32_t)15631 << 16));
    // 0x149b80: 0x34215c29
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 23593));
    // 0x149b84: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x149b88: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149b8c: 0x45000031
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x149C54; return;
    }
label_149b94:
    // 0x149b94: 0x16c00027
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        goto label_149c34;
    }
    // 0x149b9c: 0xc6410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[1] = *(float*)&val; }
    // 0x149ba0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x149ba4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149ba8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x149bac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x149bb0: 0x46017041
    ctx->f[1] = FPU_SUB_S(ctx->f[14], ctx->f[1]);
    // 0x149bb4: 0x24459ea0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294942368));
    // 0x149bb8: 0x68a60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x149bbc: 0x6ca60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x149bc0: 0xb3a60037
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bc4: 0xb7a60030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bc8: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x149bcc: 0xc7a20034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[2] = *(float*)&val; }
    // 0x149bd0: 0x46000845
    ctx->f[1] = FPU_ABS_S(ctx->f[1]);
    // 0x149bd4: 0xc7a50030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[5] = *(float*)&val; }
    // 0x149bd8: 0x24651c40
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 7232));
    // 0x149bdc: 0x68a60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x149be0: 0x6ca60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x149be4: 0x68a7000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x149be8: 0x6ca70008
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x149bec: 0xb3a60027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bf0: 0xb7a60020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bf4: 0xb3a7002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bf8: 0xb7a70028
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x149bfc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x149c00: 0xc7a4002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 44)); ctx->f[4] = *(float*)&val; }
    // 0x149c04: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x149c08: 0xc7a30020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[3] = *(float*)&val; }
    // 0x149c0c: 0xc7a20024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[2] = *(float*)&val; }
    // 0x149c10: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x149c14: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x149c18: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x149c1c: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x149c20: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x149c24: 0xe7a20024
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x149c28: 0xe7a4002c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 44), *(uint32_t*)&val); }
    // 0x149c2c: 0x10000002
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149c38;
    }
label_149c34:
    // 0x149c34: 0x24441c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 7248));
label_149c38:
    // 0x149c38: 0xc64c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[12] = *(float*)&val; }
    // 0x149c3c: 0x4600bbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[23]);
    // 0x149c40: 0xc64d001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[13] = *(float*)&val; }
    // 0x149c44: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x149c4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 28));
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_149c4c
// Address: 0x149c4c - 0x149c74

void entry_149c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149c4c) {
        switch (ctx->pc) {
            case 0x149c54: ctx->pc = 0; goto label_149c54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149c4c: 0x10000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 24), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149D20; return;
    }
label_149c54:
    // 0x149c54: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x149c58: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x149c5c: 0xc64c001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[12] = *(float*)&val; }
    // 0x149c60: 0x24841c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7264));
    // 0x149c64: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x149c68: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x149c6c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x149c74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_149c74
// Address: 0x149c74 - 0x149cd8

void entry_149c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149c74) {
        switch (ctx->pc) {
            case 0x149ca0: ctx->pc = 0; goto label_149ca0;
            case 0x149cb0: ctx->pc = 0; goto label_149cb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149c74: 0x46170082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x149c78: 0xc6410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[1] = *(float*)&val; }
    // 0x149c7c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149c80: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x149c84: 0x46020b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x149c88: 0x46146834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149c8c: 0x0
    // NOP
    // 0x149c90: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 28), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149ca0;
    }
    // 0x149c98: 0x10000005
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149cb0;
    }
label_149ca0:
    // 0x149ca0: 0x460d1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149ca4: 0x0
    // NOP
    // 0x149ca8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[13] = FPU_MOV_S(ctx->f[3]);
        goto label_149cb0;
    }
label_149cb0:
    // 0x149cb0: 0x1000001b
    { float val = ctx->f[13]; WRITE32(ADD32(GPR_U32(ctx, 18), 24), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149D20; return;
    }
    // 0x149cb8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x149cbc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x149cc0: 0xc44d04f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1272)); ctx->f[13] = *(float*)&val; }
    // 0x149cc4: 0x24841c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7280));
    // 0x149cc8: 0xc64c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[12] = *(float*)&val; }
    // 0x149ccc: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x149cd0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x149cd8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_149cd8
// Address: 0x149cd8 - 0x149d54

void entry_149cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149cd8) {
        switch (ctx->pc) {
            case 0x149d08: ctx->pc = 0; goto label_149d08;
            case 0x149d0c: ctx->pc = 0; goto label_149d0c;
            case 0x149d20: ctx->pc = 0; goto label_149d20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149cd8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x149cdc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149ce0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x149ce4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149ce8: 0x0
    // NOP
    // 0x149cec: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
        goto label_149d0c;
    }
    // 0x149cf4: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149cf8: 0x0
    // NOP
    // 0x149cfc: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149d08;
    }
    // 0x149d04: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_149d08:
    // 0x149d08: 0xc6400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
label_149d0c:
    // 0x149d0c: 0x26500024
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 36));
    // 0x149d10: 0xe6410018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 24), *(uint32_t*)&val); }
    // 0x149d14: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x149d18: 0x46170003
    if (ctx->f[23] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[23];
    // 0x149d1c: 0xe640001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 28), *(uint32_t*)&val); }
label_149d20:
    // 0x149d20: 0x8e430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x149d24: 0x10600039
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149E0C; return;
    }
    // 0x149d2c: 0xc641001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[1] = *(float*)&val; }
    // 0x149d30: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x149d34: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149d38: 0x0
    // NOP
    // 0x149d3c: 0x4501002d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 68)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x149DF4; return;
    }
    // 0x149d44: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x149D5C; return;
    }
    // 0x149d4c: 0xc04759c
    SET_GPR_U32(ctx, 31, 0x149d54);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    snd_ContinueSound(rdram, ctx, runtime); return;
}


// Function: entry_149d54
// Address: 0x149d54 - 0x149d9c

void entry_149d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149d54) {
        switch (ctx->pc) {
            case 0x149d5c: ctx->pc = 0; goto label_149d5c;
            case 0x149d84: ctx->pc = 0; goto label_149d84;
            case 0x149d94: ctx->pc = 0; goto label_149d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149d54: 0xae400044
    WRITE32(ADD32(GPR_U32(ctx, 18), 68), GPR_U32(ctx, 0));
    // 0x149d58: 0xc640001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[0] = *(float*)&val; }
label_149d5c:
    // 0x149d5c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x149d60: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x149d64: 0x46000305
    ctx->f[12] = FPU_ABS_S(ctx->f[0]);
    // 0x149d68: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149d6c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x149d70: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149d74: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149d84;
    }
    // 0x149d7c: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149d94;
    }
label_149d84:
    // 0x149d84: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149d88: 0x0
    // NOP
    // 0x149d8c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[0]);
        goto label_149d94;
    }
label_149d94:
    // 0x149d94: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x149d9c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_149d9c
// Address: 0x149d9c - 0x149dec

void entry_149d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149d9c) {
        switch (ctx->pc) {
            case 0x149dd4: ctx->pc = 0; goto label_149dd4;
            case 0x149de4: ctx->pc = 0; goto label_149de4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149d9c: 0xc640001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 28)); ctx->f[0] = *(float*)&val; }
    // 0x149da0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x149da4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x149da8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x149dac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149db0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x149db4: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x149db8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x149dbc: 0x46010300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x149dc0: 0x46026034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149dc4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_149dd4;
    }
    // 0x149dcc: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_149de4;
    }
label_149dd4:
    // 0x149dd4: 0x460c1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149dd8: 0x0
    // NOP
    // 0x149ddc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[3]);
        goto label_149de4;
    }
label_149de4:
    // 0x149de4: 0xc06fe3a
    SET_GPR_U32(ctx, 31, 0x149dec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    SetPambVol__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_149dec
// Address: 0x149dec - 0x149e04

void entry_149dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149dec) {
        switch (ctx->pc) {
            case 0x149df4: ctx->pc = 0; goto label_149df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149dec: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149E0C; return;
    }
label_149df4:
    // 0x149df4: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x149E0C; return;
    }
    // 0x149dfc: 0xc047590
    SET_GPR_U32(ctx, 31, 0x149e04);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    snd_PauseSound(rdram, ctx, runtime); return;
}


// Function: entry_149e04
// Address: 0x149e04 - 0x149e4c

void entry_149e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149e04) {
        switch (ctx->pc) {
            case 0x149e0c: ctx->pc = 0; goto label_149e0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149e04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x149e08: 0xae420044
    WRITE32(ADD32(GPR_U32(ctx, 18), 68), GPR_U32(ctx, 2));
label_149e0c:
    // 0x149e0c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149e10: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x149e14: 0xc6400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 24)); ctx->f[0] = *(float*)&val; }
    // 0x149e18: 0xc6030004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[3] = *(float*)&val; }
    // 0x149e1c: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x149e20: 0xc6420024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 36)); ctx->f[2] = *(float*)&val; }
    // 0x149e24: 0xc6ac01c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 452)); ctx->f[12] = *(float*)&val; }
    // 0x149e28: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x149e2c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x149e30: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x149e34: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x149e38: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x149e3c: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x149e40: 0x46000d00
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x149e44: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x149e4c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_149e4c
// Address: 0x149e4c - 0x149e60

void entry_149e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149e4c: 0x14400005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x149E64; return;
    }
    // 0x149e54: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x149e58: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x149e60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_149e60
// Address: 0x149e60 - 0x149ea0

void entry_149e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149e60) {
        switch (ctx->pc) {
            case 0x149e64: ctx->pc = 0; goto label_149e64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149e60: 0x2e620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
label_149e64:
    // 0x149e64: 0x10400227
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A704; return;
    }
    // 0x149e6c: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x149e70: 0x24429ed0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942416));
    // 0x149e74: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x149e78: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x149e7c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x149e84: 0xc6800040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[0] = *(float*)&val; }
    // 0x149e88: 0xc68c0074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 116)); ctx->f[12] = *(float*)&val; }
    // 0x149e8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149e90: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x149e94: 0x460c0300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    // 0x149e98: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x149ea0);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_149ea0
// Address: 0x149ea0 - 0x149eb0

void entry_149ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149ea0: 0xc68c0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 68)); ctx->f[12] = *(float*)&val; }
    // 0x149ea4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x149ea8: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x149eb0);
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_149eb0
// Address: 0x149eb0 - 0x149ecc

void entry_149eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149eb0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x149eb4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x149eb8: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x149ebc: 0x1040000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x149EF0; return;
    }
    // 0x149ec4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x149ecc);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_149ecc
// Address: 0x149ecc - 0x149ff4

void entry_149ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x149ecc) {
        switch (ctx->pc) {
            case 0x149ef0: ctx->pc = 0; goto label_149ef0;
            case 0x149ef4: ctx->pc = 0; goto label_149ef4;
            case 0x149f30: ctx->pc = 0; goto label_149f30;
            case 0x149f68: ctx->pc = 0; goto label_149f68;
            case 0x149f90: ctx->pc = 0; goto label_149f90;
            case 0x149fb8: ctx->pc = 0; goto label_149fb8;
            case 0x149fbc: ctx->pc = 0; goto label_149fbc;
            case 0x149fd4: ctx->pc = 0; goto label_149fd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x149ecc: 0x8e232e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x149ed0: 0x14620008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_149ef4;
    }
    // 0x149ed8: 0x8c632228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8744)));
    // 0x149edc: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    // 0x149ee0: 0x10620004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_149ef4;
    }
    // 0x149ee8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x149eec: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
label_149ef0:
    // 0x149ef0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_149ef4:
    // 0x149ef4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x149ef8: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x149efc: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x149f00: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x149f04: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x149f08: 0xc46101c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 452)); ctx->f[1] = *(float*)&val; }
    // 0x149f0c: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x149f10: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x149f14: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x149f18: 0x46012001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x149f1c: 0x46020e02
    ctx->f[24] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x149f20: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x149f24: 0x16600002
    ctx->f[3] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_149f30;
    }
    // 0x149f2c: 0x460020c6
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
label_149f30:
    // 0x149f30: 0x4600a807
    ctx->f[0] = FPU_NEG_S(ctx->f[21]);
    // 0x149f34: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x149f38: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x149f3c: 0xc641000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[1] = *(float*)&val; }
    // 0x149f40: 0x46021882
    ctx->f[2] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x149f44: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x149f48: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x149f4c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x149f50: 0x46020582
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x149f54: 0x4601b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[1]);
    // 0x149f58: 0x46030836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149f5c: 0x0
    // NOP
    // 0x149f60: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
        goto label_149f68;
    }
label_149f68:
    // 0x149f68: 0x4614a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x149f6c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x149f70: 0x16600007
    ctx->f[21] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_149f90;
    }
    // 0x149f78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149f7c: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x149f80: 0x8c8319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x149f84: 0x30630200
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 512));
    // 0x149f88: 0x5060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_NEG_S(ctx->f[21]);
        goto label_149fb8;
    }
label_149f90:
    // 0x149f90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x149f94: 0x56620009
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
        goto label_149fbc;
    }
    // 0x149f9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x149fa0: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x149fa4: 0x8c8319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x149fa8: 0x30630400
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1024));
    // 0x149fac: 0x54600003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
        goto label_149fbc;
    }
    // 0x149fb4: 0x4600ad47
    ctx->f[21] = FPU_NEG_S(ctx->f[21]);
label_149fb8:
    // 0x149fb8: 0xc6400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
label_149fbc:
    // 0x149fbc: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x149fc0: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x149fc4: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x149fc8: 0x0
    // NOP
    // 0x149fcc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
        goto label_149fd4;
    }
label_149fd4:
    // 0x149fd4: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x149fd8: 0xc64c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[12] = *(float*)&val; }
    // 0x149fdc: 0x26101c80
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 7296));
    // 0x149fe0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x149fe4: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x149fe8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149fec: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x149ff4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_149ff4
// Address: 0x149ff4 - 0x14a010

void entry_149ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x149ff4: 0xc64c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[12] = *(float*)&val; }
    // 0x149ff8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x149ffc: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x14a000: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14a004: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x14a008: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x14a010);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_14a010
// Address: 0x14a010 - 0x14a034

void entry_14a010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a010: 0x4617b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[23]);
    // 0x14a014: 0xc64c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[12] = *(float*)&val; }
    // 0x14a018: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x14a01c: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x14a020: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14a024: 0xe6400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
    // 0x14a028: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x14a02c: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x14a034);
    ctx->f[13] = FPU_MUL_S(ctx->f[24], ctx->f[13]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14a034
// Address: 0x14a034 - 0x14a058

void entry_14a034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a034: 0x4617a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[23]);
    // 0x14a038: 0xc64c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[12] = *(float*)&val; }
    // 0x14a03c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x14a040: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x14a044: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14a048: 0xe640000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    // 0x14a04c: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x14a050: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x14a058);
    ctx->f[13] = FPU_MUL_S(ctx->f[24], ctx->f[13]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14a058
// Address: 0x14a058 - 0x14a070

void entry_14a058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a058: 0xc64c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[12] = *(float*)&val; }
    // 0x14a05c: 0xc6410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14a060: 0x46176302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[23]);
    // 0x14a064: 0xe6400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
    // 0x14a068: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14a070);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14a070
// Address: 0x14a070 - 0x14a0c8

void entry_14a070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a070) {
        switch (ctx->pc) {
            case 0x14a0a8: ctx->pc = 0; goto label_14a0a8;
            case 0x14a0b8: ctx->pc = 0; goto label_14a0b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a070: 0xc6410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[1] = *(float*)&val; }
    // 0x14a074: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14a078: 0xc6420010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[2] = *(float*)&val; }
    // 0x14a07c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14a080: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x14a084: 0xc4631bfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 7164)); ctx->f[3] = *(float*)&val; }
    // 0x14a088: 0xc4441c00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7168)); ctx->f[4] = *(float*)&val; }
    // 0x14a08c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x14a090: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14a094: 0x0
    // NOP
    // 0x14a098: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14a0a8;
    }
    // 0x14a0a0: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14a0b8;
    }
label_14a0a8:
    // 0x14a0a8: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14a0ac: 0x0
    // NOP
    // 0x14a0b0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[4]);
        goto label_14a0b8;
    }
label_14a0b8:
    // 0x14a0b8: 0xe6420010
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    // 0x14a0bc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14a0c0: 0xc052516
    SET_GPR_U32(ctx, 31, 0x14a0c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    FUN_00149458(rdram, ctx, runtime); return;
}


// Function: entry_14a0c8
// Address: 0x14a0c8 - 0x14a164

void entry_14a0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a0c8) {
        switch (ctx->pc) {
            case 0x14a114: ctx->pc = 0; goto label_14a114;
            case 0x14a138: ctx->pc = 0; goto label_14a138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a0c8: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a0cc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14a0d0: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x14a0d4: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x14a0d8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x14a0dc: 0xc6a10364
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 868)); ctx->f[1] = *(float*)&val; }
    // 0x14a0e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14a0e4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14a0e8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14a0ec: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x14a0f0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14a0f4: 0x0
    // NOP
    // 0x14a0f8: 0x45010006
    ctx->f[24] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14a114;
    }
    // 0x14a100: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14a104: 0x0
    // NOP
    // 0x14a108: 0x45000002
    ctx->f[24] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14a114;
    }
    // 0x14a110: 0x46001e06
    ctx->f[24] = FPU_MOV_S(ctx->f[3]);
label_14a114:
    // 0x14a114: 0x8e232e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x14a118: 0x10600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_14a138;
    }
    // 0x14a120: 0x8c632228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8744)));
    // 0x14a124: 0x14620004
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_14a138;
    }
    // 0x14a12c: 0x4480c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 0);
    // 0x14a130: 0x10000174
    ctx->f[26] = FPU_MOV_S(ctx->f[25]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A704; return;
    }
label_14a138:
    // 0x14a138: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x14a13c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x14a140: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x14a144: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x14a148: 0x1000016e
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A704; return;
    }
    // 0x14a150: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x14a154: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14a158: 0x4480d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 0);
    // 0x14a15c: 0xc0524f2
    SET_GPR_U32(ctx, 31, 0x14a164);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PosCplookAnchor(rdram, ctx, runtime); return;
}


// Function: entry_14a164
// Address: 0x14a164 - 0x14a170

void entry_14a164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a164: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14a168: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14a170);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14a170
// Address: 0x14a170 - 0x14a1f8

void entry_14a170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a170) {
        switch (ctx->pc) {
            case 0x14a190: ctx->pc = 0; goto label_14a190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a170: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14a174: 0x8e620634
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1588)));
    // 0x14a178: 0x10400005
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14a190;
    }
    // 0x14a180: 0x8e420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x14a184: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a188: 0x10000039
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A270; return;
    }
label_14a190:
    // 0x14a190: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x14a194: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14a198: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x14a19c: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x14a1a0: 0x26a30080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 128));
    // 0x14a1a4: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x14a1a8: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x14a1ac: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14a1b0: 0x48a63000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x14a1b4: 0xd8650020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x14a1b8: 0x4be61098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a1bc: 0xd8630010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x14a1c0: 0x27b00070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 112));
    // 0x14a1c4: 0xdaa40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 128)));
    // 0x14a1c8: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x14a1cc: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14a1d0: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a1d4: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a1d8: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a1dc: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a1e0: 0x8e241990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    // 0x14a1e4: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a1e8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14a1ec: 0xfba600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x14a1f0: 0xc051070
    SET_GPR_U32(ctx, 31, 0x14a1f8);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_14a1f8
// Address: 0x14a1f8 - 0x14a268

void entry_14a1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a1f8) {
        switch (ctx->pc) {
            case 0x14a220: ctx->pc = 0; goto label_14a220;
            case 0x14a228: ctx->pc = 0; goto label_14a228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a1f8: 0xc6800040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[0] = *(float*)&val; }
    // 0x14a1fc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x14a200: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x14a204: 0xe7a000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x14a208: 0x8c6219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x14a20c: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x14a210: 0x10400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 68)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14a220;
    }
    // 0x14a218: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14a228;
    }
label_14a220:
    // 0x14a220: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x14a224: 0xe7a000b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
label_14a228:
    // 0x14a228: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14a22c: 0xafa000b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 0));
    // 0x14a230: 0xc4401c8c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7308)); ctx->f[0] = *(float*)&val; }
    // 0x14a234: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x14a238: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14a23c: 0x27a600a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    // 0x14a240: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x14a244: 0xdba300b0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14a248: 0x8e241990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    // 0x14a24c: 0x44070000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[0]);
    // 0x14a250: 0x48a71000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 7));
    // 0x14a254: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14a258: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a25c: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14a260: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x14a268);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_14a268
// Address: 0x14a268 - 0x14a284

void entry_14a268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a268) {
        switch (ctx->pc) {
            case 0x14a270: ctx->pc = 0; goto label_14a270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a268: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14a26c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_14a270:
    // 0x14a270: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a274: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a278: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x14a27c: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x14a284);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14a284
// Address: 0x14a284 - 0x14a29c

void entry_14a284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a284: 0x26700658
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1624));
    // 0x14a288: 0x27a50190
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 400));
    // 0x14a28c: 0x27a60194
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 404));
    // 0x14a290: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x14a294: 0xc06248c
    SET_GPR_U32(ctx, 31, 0x14a29c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 1616));
    DecomposeRotateMatrixPanTilt__FP7MATRIX3PfT1(rdram, ctx, runtime); return;
}


// Function: entry_14a29c
// Address: 0x14a29c - 0x14a2c4

void entry_14a29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a29c: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14a2a0: 0xc7a00190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[0] = *(float*)&val; }
    // 0x14a2a4: 0xc66c0648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1608)); ctx->f[12] = *(float*)&val; }
    // 0x14a2a8: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x14a2ac: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x14a2b0: 0x3c01c0e0
    SET_GPR_U32(ctx, 1, ((uint32_t)49376 << 16));
    // 0x14a2b4: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x14a2b8: 0x4480c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 0);
    // 0x14a2bc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14a2c4);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14a2c4
// Address: 0x14a2c4 - 0x14a2d0

void entry_14a2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a2c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14a2c8: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x14a2d0);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_14a2d0
// Address: 0x14a2d0 - 0x14a2e4

void entry_14a2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a2d0: 0xc7a10194
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 404)); ctx->f[1] = *(float*)&val; }
    // 0x14a2d4: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x14a2d8: 0xc66c064c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1612)); ctx->f[12] = *(float*)&val; }
    // 0x14a2dc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14a2e4);
    ctx->f[12] = FPU_SUB_S(ctx->f[1], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14a2e4
// Address: 0x14a2e4 - 0x14a2f0

void entry_14a2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a2e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14a2e8: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x14a2f0);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_14a2f0
// Address: 0x14a2f0 - 0x14a300

void entry_14a2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a2f0: 0xc66c0648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1608)); ctx->f[12] = *(float*)&val; }
    // 0x14a2f4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x14a2f8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14a300);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[21]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14a300
// Address: 0x14a300 - 0x14a310

void entry_14a300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a300: 0xe6400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    // 0x14a304: 0xc66c064c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1612)); ctx->f[12] = *(float*)&val; }
    // 0x14a308: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14a310);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[20]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14a310
// Address: 0x14a310 - 0x14a320

void entry_14a310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a310: 0xe6400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    // 0x14a314: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x14a318: 0xc052516
    SET_GPR_U32(ctx, 31, 0x14a320);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00149458(rdram, ctx, runtime); return;
}


// Function: entry_14a320
// Address: 0x14a320 - 0x14a37c

void entry_14a320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a320: 0x7ba20070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14a324: 0x100000f7
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A704; return;
    }
    // 0x14a32c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x14a330: 0x8c4204f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1268)));
    // 0x14a334: 0x10400028
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A3D8; return;
    }
    // 0x14a33c: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x14a340: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a344: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a348: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14a34c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a350: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a354: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a358: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a35c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14a360: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14a364: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a368: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x14a36c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14a370: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x14a374: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x14a37c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_14a37c
// Address: 0x14a37c - 0x14a3e4

void entry_14a37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a37c) {
        switch (ctx->pc) {
            case 0x14a3d8: ctx->pc = 0; goto label_14a3d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a37c: 0xe6400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    // 0x14a380: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14a384: 0x24421c20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7200));
    // 0x14a388: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14a38c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a390: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14a394: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a398: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a39c: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a3a0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a3a4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a3a8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14a3ac: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14a3b0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a3b4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14a3b8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x14a3bc: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x14a3c0: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14a3c4: 0x4be118d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14a3c8: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a3cc: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a3d0: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A3EC; return;
    }
label_14a3d8:
    // 0x14a3d8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14a3dc: 0xc052516
    SET_GPR_U32(ctx, 31, 0x14a3e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    FUN_00149458(rdram, ctx, runtime); return;
}


// Function: entry_14a3e4
// Address: 0x14a3e4 - 0x14a4c8

void entry_14a3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a3e4) {
        switch (ctx->pc) {
            case 0x14a3ec: ctx->pc = 0; goto label_14a3ec;
            case 0x14a42c: ctx->pc = 0; goto label_14a42c;
            case 0x14a440: ctx->pc = 0; goto label_14a440;
            case 0x14a45c: ctx->pc = 0; goto label_14a45c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a3e4: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a3e8: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
label_14a3ec:
    // 0x14a3ec: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x14a3f0: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x14a3f4: 0x3c01c0e0
    SET_GPR_U32(ctx, 1, ((uint32_t)49376 << 16));
    // 0x14a3f8: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x14a3fc: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x14a400: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x14a404: 0x100000bf
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A704; return;
    }
    // 0x14a40c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x14a410: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14a414: 0x244208e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2272));
    // 0x14a418: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x14a41c: 0x14640003
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_14a42c;
    }
    // 0x14a424: 0x10000006
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14a440;
    }
label_14a42c:
    // 0x14a42c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14a430: 0x24631558
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 5464));
    // 0x14a434: 0x8c620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 608)));
    // 0x14a438: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x14a43c: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
label_14a440:
    // 0x14a440: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x14a444: 0x8c4304f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1268)));
    // 0x14a448: 0x14600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_14a45c;
    }
    // 0x14a450: 0x120000c7
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A770; return;
    }
    // 0x14a458: 0x8e030278
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 632)));
label_14a45c:
    // 0x14a45c: 0x120000c4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A770; return;
    }
    // 0x14a464: 0x8e020270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 624)));
    // 0x14a468: 0x104000c2
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A774; return;
    }
    // 0x14a470: 0x106000c1
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A778; return;
    }
    // 0x14a478: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14a47c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14a480: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14a484: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x14a488: 0x3c013e63
    SET_GPR_U32(ctx, 1, ((uint32_t)15971 << 16));
    // 0x14a48c: 0x34218e39
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 36409));
    // 0x14a490: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x14a494: 0x8e020270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 624)));
    // 0x14a498: 0x8e44005c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x14a49c: 0xc4400324
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 804)); ctx->f[0] = *(float*)&val; }
    // 0x14a4a0: 0xc4410320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 800)); ctx->f[1] = *(float*)&val; }
    // 0x14a4a4: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x14a4a8: 0xc44202d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 728)); ctx->f[2] = *(float*)&val; }
    // 0x14a4ac: 0x46010840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    // 0x14a4b0: 0x46041502
    ctx->f[20] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x14a4b4: 0x46030581
    ctx->f[22] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x14a4b8: 0x10800012
    ctx->f[21] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14A504; return;
    }
    // 0x14a4c0: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x14a4c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14a4c8
// Address: 0x14a4c8 - 0x14a594

void entry_14a4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a4c8) {
        switch (ctx->pc) {
            case 0x14a504: ctx->pc = 0; goto label_14a504;
            case 0x14a54c: ctx->pc = 0; goto label_14a54c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a4c8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14a4cc: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a4d0: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a4d4: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a4d8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14a4dc: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a4e0: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a4e4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a4e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a4ec: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14a4f0: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14a4f4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a4f8: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x14a4fc: 0x10000013
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14a54c;
    }
label_14a504:
    // 0x14a504: 0x4404a800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[21]);
    // 0x14a508: 0xd8620110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 272)));
    // 0x14a50c: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x14a510: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14a514: 0xd8630120
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 288)));
    // 0x14a518: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14a51c: 0x4be41888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a520: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a524: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14a528: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a52c: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a530: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a534: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a538: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14a53c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14a540: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14a544: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x14a548: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_14a54c:
    // 0x14a54c: 0x4614a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[20]);
    // 0x14a550: 0x8e020270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 624)));
    // 0x14a554: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14a558: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14a55c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a560: 0x27a60198
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 408));
    // 0x14a564: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x14a568: 0x27a7019c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 412));
    // 0x14a56c: 0x48a51800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x14a570: 0x27a801a0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 416));
    // 0x14a574: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14a578: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x14a57c: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a580: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a584: 0xd8420310
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 784)));
    // 0x14a588: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a58c: 0xc051538
    SET_GPR_U32(ctx, 31, 0x14a594);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    DecomposeSphere(rdram, ctx, runtime); return;
}


// Function: entry_14a594
// Address: 0x14a594 - 0x14a5f0

void entry_14a594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a594: 0xc6a101c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 452)); ctx->f[1] = *(float*)&val; }
    // 0x14a598: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x14a59c: 0xc6a401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 480)); ctx->f[4] = *(float*)&val; }
    // 0x14a5a0: 0x4601a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x14a5a4: 0xc7b40198
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 408)); ctx->f[20] = *(float*)&val; }
    // 0x14a5a8: 0xc7b5019c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 412)); ctx->f[21] = *(float*)&val; }
    // 0x14a5ac: 0x4601b042
    ctx->f[1] = FPU_MUL_S(ctx->f[22], ctx->f[1]);
    // 0x14a5b0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x14a5b4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14a5b8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x14a5bc: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x14a5c0: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x14a5c4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x14a5c8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14a5cc: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x14a5d0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14a5d4: 0x4602a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[2]);
    // 0x14a5d8: 0xc7ae01a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[14] = *(float*)&val; }
    // 0x14a5dc: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14a5e0: 0x4600ad47
    ctx->f[21] = FPU_NEG_S(ctx->f[21]);
    // 0x14a5e4: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x14a5e8: 0xc07b5ac
    SET_GPR_U32(ctx, 31, 0x14a5f0);
    ctx->f[21] = FPU_SUB_S(ctx->f[21], ctx->f[1]);
    SetVectorSphere__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_14a5f0
// Address: 0x14a5f0 - 0x14a614

void entry_14a5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a5f0: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14a5f4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x14a5f8: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a5fc: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x14a600: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a604: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x14a608: 0xfaa10040
    WRITE128(ADD32(GPR_U32(ctx, 21), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a60c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x14a614);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14a614
// Address: 0x14a614 - 0x14a628

void entry_14a614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a614: 0x4600ab07
    ctx->f[12] = FPU_NEG_S(ctx->f[21]);
    // 0x14a618: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x14a61c: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x14a620: 0xc062214
    SET_GPR_U32(ctx, 31, 0x14a628);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937872));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14a628
// Address: 0x14a628 - 0x14a640

void entry_14a628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a628: 0x8e020270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 624)));
    // 0x14a62c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x14a630: 0x24848d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937856));
    // 0x14a634: 0x27a500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    // 0x14a638: 0xc062214
    SET_GPR_U32(ctx, 31, 0x14a640);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 808)); ctx->f[12] = *(float*)&val; }
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14a640
// Address: 0x14a640 - 0x14a6f8

void entry_14a640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a640: 0xdba50060
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14a644: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x14a648: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14a64c: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14a650: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14a654: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14a658: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14a65c: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14a660: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a664: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14a668: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14a66c: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a670: 0xdba600a0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14a674: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x14a678: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x14a67c: 0x4bc6190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a680: 0xdba700d0
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14a684: 0xdba500e0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x14a688: 0x4bc709bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x14a68c: 0x4bc710bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x14a690: 0x4bc721ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a694: 0xdba300f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x14a698: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x14a69c: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x14a6a0: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a6a4: 0xfba10160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a6a8: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x14a6ac: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14a6b0: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14a6b4: 0xfba20170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14a6b8: 0xfba40180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14a6bc: 0xfba50110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14a6c0: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14a6c4: 0xfba10130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14a6c8: 0xfba20140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14a6cc: 0xfba40150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14a6d0: 0xfba70160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x14a6d4: 0xfba70100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x14a6d8: 0xfba50170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14a6dc: 0xfba30180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14a6e0: 0xfaa70080
    WRITE128(ADD32(GPR_U32(ctx, 21), 128), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x14a6e4: 0x7ba20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x14a6e8: 0x7ea20090
    WRITE128(ADD32(GPR_U32(ctx, 21), 144), GPR_VEC(ctx, 2));
    // 0x14a6ec: 0x7ba30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x14a6f0: 0xc051150
    SET_GPR_U32(ctx, 31, 0x14a6f8);
    WRITE128(ADD32(GPR_U32(ctx, 21), 160), GPR_VEC(ctx, 3));
    UpdateCmMat4(rdram, ctx, runtime); return;
}


// Function: entry_14a6f8
// Address: 0x14a6f8 - 0x14a76c

void entry_14a6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a6f8) {
        switch (ctx->pc) {
            case 0x14a704: ctx->pc = 0; goto label_14a704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a6f8: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a6fc: 0x1000001b
    WRITE128(ADD32(GPR_U32(ctx, 21), 720), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_14a76c(rdram, ctx, runtime); return;
    }
label_14a704:
    // 0x14a704: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14a708: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14a70c: 0x461ac042
    ctx->f[1] = FPU_MUL_S(ctx->f[24], ctx->f[26]);
    // 0x14a710: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x14a714: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14a718: 0x4619c082
    ctx->f[2] = FPU_MUL_S(ctx->f[24], ctx->f[25]);
    // 0x14a71c: 0x46180001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[24]);
    // 0x14a720: 0x3c01c0e0
    SET_GPR_U32(ctx, 1, ((uint32_t)49376 << 16));
    // 0x14a724: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14a728: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x14a72c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x14a730: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x14a734: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x14a738: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x14a73c: 0x460ec382
    ctx->f[14] = FPU_MUL_S(ctx->f[24], ctx->f[14]);
    // 0x14a740: 0x4600dc06
    ctx->f[16] = FPU_MOV_S(ctx->f[27]);
    // 0x14a744: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x14a748: 0x4600bc46
    ctx->f[17] = FPU_MOV_S(ctx->f[23]);
    // 0x14a74c: 0x460d0342
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[13]);
    // 0x14a750: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14a754: 0x460e0380
    ctx->f[14] = FPU_ADD_S(ctx->f[0], ctx->f[14]);
    // 0x14a758: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14a75c: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x14a760: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14a764: 0xc0512fa
    SET_GPR_U32(ctx, 31, 0x14a76c);
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[2]);
    SetCmLookAtSmooth(rdram, ctx, runtime); return;
}


// Function: entry_14a76c
// Address: 0x14a76c - 0x14a7b8

void entry_14a76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a76c) {
        switch (ctx->pc) {
            case 0x14a770: ctx->pc = 0; goto label_14a770;
            case 0x14a774: ctx->pc = 0; goto label_14a774;
            case 0x14a778: ctx->pc = 0; goto label_14a778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a76c: 0x7bbf0230
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
label_14a770:
    // 0x14a770: 0x7bb70220
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 544)));
label_14a774:
    // 0x14a774: 0x7bb60210
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 528)));
label_14a778:
    // 0x14a778: 0x7bb50200
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x14a77c: 0x7bb401f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x14a780: 0x7bb301e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x14a784: 0x7bb201d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x14a788: 0x7bb101c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x14a78c: 0x7bb001b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x14a790: 0xc7bb0278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 632)); ctx->f[27] = *(float*)&val; }
    // 0x14a794: 0xc7ba0270
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 624)); ctx->f[26] = *(float*)&val; }
    // 0x14a798: 0xc7b90268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 616)); ctx->f[25] = *(float*)&val; }
    // 0x14a79c: 0xc7b80260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 608)); ctx->f[24] = *(float*)&val; }
    // 0x14a7a0: 0xc7b70258
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 600)); ctx->f[23] = *(float*)&val; }
    // 0x14a7a4: 0xc7b60250
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 592)); ctx->f[22] = *(float*)&val; }
    // 0x14a7a8: 0xc7b50248
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 584)); ctx->f[21] = *(float*)&val; }
    // 0x14a7ac: 0xc7b40240
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 576)); ctx->f[20] = *(float*)&val; }
    // 0x14a7b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 640));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014a7b8
// Address: 0x14a7b8 - 0x14a7dc

void FUN_0014a7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a7b8: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x14a7bc: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x14a7c0: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14a7c4: 0x7fb20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 18));
    // 0x14a7c8: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x14a7cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14a7d0: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x14a7d4: 0xc0524f2
    SET_GPR_U32(ctx, 31, 0x14a7dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PosCplookAnchor(rdram, ctx, runtime); return;
}


// Function: entry_14a7dc
// Address: 0x14a7dc - 0x14a7ec

void entry_14a7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a7dc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14a7e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14a7e4: 0xc052516
    SET_GPR_U32(ctx, 31, 0x14a7ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00149458(rdram, ctx, runtime); return;
}


// Function: entry_14a7ec
// Address: 0x14a7ec - 0x14a7fc

void entry_14a7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a7ec: 0x8e240048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x14a7f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14a7f4: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x14a7fc);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_14a7fc
// Address: 0x14a7fc - 0x14a808

void entry_14a7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a7fc: 0x8e24004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x14a800: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x14a808);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 500));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_14a808
// Address: 0x14a808 - 0x14a818

void entry_14a808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a808: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14a80c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14a810: 0xc05124e
    SET_GPR_U32(ctx, 31, 0x14a818);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetCmLookAt(rdram, ctx, runtime); return;
}


// Function: entry_14a818
// Address: 0x14a818 - 0x14a830

void entry_14a818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a818: 0xc64c01c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 452)); ctx->f[12] = *(float*)&val; }
    // 0x14a81c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14a820: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14a824: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x14a828: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x14a830);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 40)); ctx->f[13] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_14a830
// Address: 0x14a830 - 0x14a844

void entry_14a830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a830: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 92), GPR_U32(ctx, 0));
        ctx->pc = 0x14A848; return;
    }
    // 0x14a838: 0xc62c0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 40)); ctx->f[12] = *(float*)&val; }
    // 0x14a83c: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x14a844);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_14a844
// Address: 0x14a844 - 0x14a870

void entry_14a844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a844) {
        switch (ctx->pc) {
            case 0x14a848: ctx->pc = 0; goto label_14a848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a844: 0xae20005c
    WRITE32(ADD32(GPR_U32(ctx, 17), 92), GPR_U32(ctx, 0));
label_14a848:
    // 0x14a848: 0x3c014244
    SET_GPR_U32(ctx, 1, ((uint32_t)16964 << 16));
    // 0x14a84c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14a850: 0xc64001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 484)); ctx->f[0] = *(float*)&val; }
    // 0x14a854: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14a858: 0x0
    // NOP
    // 0x14a85c: 0x45000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14A874; return;
    }
    // 0x14a864: 0xc62c002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[12] = *(float*)&val; }
    // 0x14a868: 0xc050e5a
    SET_GPR_U32(ctx, 31, 0x14a870);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetCmNearClip__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_14a870
// Address: 0x14a870 - 0x14a888

void entry_14a870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14a870) {
        switch (ctx->pc) {
            case 0x14a874: ctx->pc = 0; goto label_14a874;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14a870: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_14a874:
    // 0x14a874: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14a878: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14a87c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14a880: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCpalign
// Address: 0x14a888 - 0x14a89c

void entry_14a89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a89c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x14a8a0: 0x26050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 32));
    // 0x14a8a4: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x14a8a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14a8ac: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14a8b0: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x14a8b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14a8b8: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x14a8bc: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x14a8c0: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x14a8c4: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x14a8c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014a8d0
// Address: 0x14a8d0 - 0x14a8e8

void FUN_0014a8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a8d0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x14a8d4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x14a8d8: 0x8c840004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x14a8dc: 0x8c8503dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 988)));
    // 0x14a8e0: 0xc0512dc
    SET_GPR_U32(ctx, 31, 0x14a8e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 880));
    ResetCmLookAtSmooth(rdram, ctx, runtime); return;
}


// Function: entry_14a8e8
// Address: 0x14a8e8 - 0x14a8f8

void entry_14a8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14a8e8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14a8ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14a8f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14a8f8; return;
}


// Function: UpdateCpalign
// Address: 0x14a8f8 - 0x14aa80

void entry_14aa80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14aa80: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14aa84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14aa8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14aa90; return;
}


// Function: FUN_0014aa90
// Address: 0x14aa90 - 0x14aa98

void FUN_0014aa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14aa90: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014aa98
// Address: 0x14aa98 - 0x14aaa0

void FUN_0014aa98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14aa98: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCpaseg
// Address: 0x14aaa0 - 0x14aad0

void entry_14aad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14aad0) {
        switch (ctx->pc) {
            case 0x14aaf8: ctx->pc = 0; goto label_14aaf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14aad0: 0x8e2202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x14aad4: 0x10400008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14aaf8;
    }
    // 0x14aadc: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x14aae0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14aae4: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x14aae8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14aaec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14aaf0: 0x1000000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14AB28; return;
    }
label_14aaf8:
    // 0x14aaf8: 0x8e2402d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 724)));
    // 0x14aafc: 0x5080000e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 752));
        ctx->pc = 0x14AB38; return;
    }
    // 0x14ab04: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x14ab0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14ab0c
// Address: 0x14ab0c - 0x14ab30

void entry_14ab0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ab0c) {
        switch (ctx->pc) {
            case 0x14ab28: ctx->pc = 0; goto label_14ab28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ab0c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ab10: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14ab14: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ab18: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x14ab1c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ab20: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ab24: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_14ab28:
    // 0x14ab28: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x14ab30);
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14ab30
// Address: 0x14ab30 - 0x14ab44

void entry_14ab30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ab30) {
        switch (ctx->pc) {
            case 0x14ab38: ctx->pc = 0; goto label_14ab38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ab30: 0x1000001e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14ABAC; return;
    }
label_14ab38:
    // 0x14ab38: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ab3c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x14ab44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 768));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14ab44
// Address: 0x14ab44 - 0x14abb8

void entry_14ab44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ab44) {
        switch (ctx->pc) {
            case 0x14abac: ctx->pc = 0; goto label_14abac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ab44: 0x26220110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 272));
    // 0x14ab48: 0xda210110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x14ab4c: 0xd8450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x14ab50: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ab54: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14ab58: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ab5c: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ab60: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x14ab64: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14ab68: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14ab6c: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x14ab70: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x14ab74: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14ab78: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ab7c: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x14ab80: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x14ab84: 0x4bc6284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14ab88: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14ab8c: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14ab90: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14ab94: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14ab98: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14ab9c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14aba0: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14aba4: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14aba8: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
label_14abac:
    // 0x14abac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14abb0: 0xc051232
    SET_GPR_U32(ctx, 31, 0x14abb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    SetCmPosMat__FP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14abb8
// Address: 0x14abb8 - 0x14abd0

void entry_14abb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14abb8: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x14abbc: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x14abc0: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14abc4: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14abc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCredit__FP6CREDIT5BLOTK
// Address: 0x14abd0 - 0x14abfc

void entry_14abfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14abfc) {
        switch (ctx->pc) {
            case 0x14ac08: ctx->pc = 0; goto label_14ac08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14abfc: 0x26100264
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 612));
    // 0x14ac00: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ac04: 0xae130000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 19));
label_14ac08:
    // 0x14ac08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ac0c: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x14ac10: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14ac14: 0x8e438330
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4294935344)));
    // 0x14ac18: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14ac20);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 608));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14ac20
// Address: 0x14ac20 - 0x14ac48

void entry_14ac20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ac20: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x14ac24: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 19));
        ctx->pc = 0x14AC08; return;
    }
    // 0x14ac2c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ac30: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ac34: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ac38: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ac3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ac40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostCreditLoad__FP6CREDIT
// Address: 0x14ac48 - 0x14ac7c

void entry_14ac7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ac7c) {
        switch (ctx->pc) {
            case 0x14ac88: ctx->pc = 0; goto label_14ac88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ac7c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14ac80: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x14ac84: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_14ac88:
    // 0x14ac88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ac8c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x14ac90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ac98);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ac98
// Address: 0x14ac98 - 0x14acb8

void entry_14ac98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ac98: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x14ac9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14aca0: 0xae000210
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 0));
    // 0x14aca4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x14aca8: 0xe4750044
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 3), 68), *(uint32_t*)&val); }
    // 0x14acac: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x14acb0: 0xc06aa2c
    SET_GPR_U32(ctx, 31, 0x14acb8);
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 72), *(uint32_t*)&val); }
    SetBlotDtAppear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_14acb8
// Address: 0x14acb8 - 0x14acc4

void entry_14acb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14acb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14acbc: 0xc06aa30
    SET_GPR_U32(ctx, 31, 0x14acc4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetBlotDtDisappear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_14acc4
// Address: 0x14acc4 - 0x14acd4

void entry_14acc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14acc4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14acc8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14accc: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x14acd4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 608));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_14acd4
// Address: 0x14acd4 - 0x14ad00

void entry_14acd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14acd4: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x14acd8: 0x5440ffeb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x14AC88; return;
    }
    // 0x14ace0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ace4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ace8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14acec: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x14acf0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x14acf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14acfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ad00; return;
}


// Function: SetCreditClock__FP6CREDITPf
// Address: 0x14ad00 - 0x14ad24

void entry_14ad24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ad24) {
        switch (ctx->pc) {
            case 0x14ad30: ctx->pc = 0; goto label_14ad30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ad24: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ad28: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ad2c: 0x0
    // NOP
label_14ad30:
    // 0x14ad30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ad34: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14ad38: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14ad3c: 0x8c430044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    // 0x14ad40: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14ad48);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 608));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14ad48
// Address: 0x14ad48 - 0x14ad70

void entry_14ad48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ad48: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x14ad4c: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x14AD30; return;
    }
    // 0x14ad54: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ad58: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ad5c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ad60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ad64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14ad6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ad70; return;
}


// Function: UpdateCredit__FP6CREDIT
// Address: 0x14ad70 - 0x14ad90

void entry_14ad90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ad90) {
        switch (ctx->pc) {
            case 0x14ada0: ctx->pc = 0; goto label_14ada0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ad90: 0x8e420260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x14ad94: 0x1840000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 612));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14ADC4; return;
    }
    // 0x14ad9c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_14ada0:
    // 0x14ada0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ada4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14ada8: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x14adac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14adb4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 608));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14adb4
// Address: 0x14adb4 - 0x14ade0

void entry_14adb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14adb4) {
        switch (ctx->pc) {
            case 0x14adc4: ctx->pc = 0; goto label_14adc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14adb4: 0x8e420260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x14adb8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x14adbc: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x14ADA0; return;
    }
label_14adc4:
    // 0x14adc4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14adc8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14adcc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14add0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14add4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14addc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ade0; return;
}


// Function: DrawCredit__FP6CREDIT
// Address: 0x14ade0 - 0x14ae60

void entry_14ae60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ae60) {
        switch (ctx->pc) {
            case 0x14ae7c: ctx->pc = 0; goto label_14ae7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ae60: 0xe614023c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 572), *(uint32_t*)&val); }
    // 0x14ae64: 0xc6000238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 568)); ctx->f[0] = *(float*)&val; }
    // 0x14ae68: 0x8e220260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x14ae6c: 0x26100260
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 608));
    // 0x14ae70: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x14ae74: 0x1440ffee
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14AE30; return;
    }
label_14ae7c:
    // 0x14ae7c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ae80: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ae84: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ae88: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ae8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ae90: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x14ae94: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x14ae98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PlaceCredit__FP6CREDITffi
// Address: 0x14aea0 - 0x14aeec

void entry_14aeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14aeec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14aef0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14aef4: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x14aef8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14af00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14af00
// Address: 0x14af00 - 0x14af10

void entry_14af00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14af00: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14af04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14af08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: VacateCredit__FP6CREDIT
// Address: 0x14af10 - 0x14af28

void entry_14af28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14af28: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14af2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14af34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14af38; return;
}


// Function: SetCreditLine__FP6CREDITiPcf
// Address: 0x14af38 - 0x14afbc

void entry_14afbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14afbc) {
        switch (ctx->pc) {
            case 0x14afd0: ctx->pc = 0; goto label_14afd0;
            case 0x14afec: ctx->pc = 0; goto label_14afec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14afbc: 0x8e220260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x14afc0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14afc4: 0x18400009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_14afec;
    }
    // 0x14afcc: 0x26220498
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1176));
label_14afd0:
    // 0x14afd0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x14afd4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x14afd8: 0x24420260
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 608));
    // 0x14afdc: 0x0
    // NOP
    // 0x14afe0: 0x0
    // NOP
    // 0x14afe4: 0x1460fffa
    ctx->f[12] = std::max(ctx->f[0], ctx->f[12]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_14afd0;
    }
label_14afec:
    // 0x14afec: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x14aff0: 0xc6210260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 608)); ctx->f[1] = *(float*)&val; }
    // 0x14aff4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x14aff8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14affc: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x14b000: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x14b004: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x14b008: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x14b00c: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x14b010: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x14b018);
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[1]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_14b018
// Address: 0x14b018 - 0x14b048

void entry_14b018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b018: 0x4616a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b01c: 0x0
    // NOP
    // 0x14b020: 0x4501001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14B09C; return;
    }
    // 0x14b028: 0x24020260
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 608));
    // 0x14b02c: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x14b030: 0x24420264
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 612));
    // 0x14b034: 0x2228021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x14b038: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14b03c: 0x8c62002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 44)));
    // 0x14b040: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14b048);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14b048
// Address: 0x14b048 - 0x14b05c

void entry_14b048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b048: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14b04c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x14b050: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x14b054: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14b05c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14b05c
// Address: 0x14b05c - 0x14b088

void entry_14b05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14b05c) {
        switch (ctx->pc) {
            case 0x14b080: ctx->pc = 0; goto label_14b080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14b05c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x14b060: 0x4614ad41
    ctx->f[21] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
    // 0x14b064: 0x4616a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b068: 0x0
    // NOP
    // 0x14b06c: 0x45000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b080;
    }
    // 0x14b074: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x14b078: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x14b07c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
label_14b080:
    // 0x14b080: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x14b088);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_14b088
// Address: 0x14b088 - 0x14b098

void entry_14b088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b088: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14b08c: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x14b090: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14b098);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14b098
// Address: 0x14b098 - 0x14b0c0

void entry_14b098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14b098) {
        switch (ctx->pc) {
            case 0x14b09c: ctx->pc = 0; goto label_14b09c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14b098: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14b09c:
    // 0x14b09c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14b0a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b0a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b0a8: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x14b0ac: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x14b0b0: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x14b0b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14b0bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14b0c0; return;
}


// Function: CroutDecomp__FiPfT1
// Address: 0x14b0c0 - 0x14b3e0

void entry_14b564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b564: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14b568: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14b56c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x14b574);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7372));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_14b574
// Address: 0x14b574 - 0x14b588

void entry_14b574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b574: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b578: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b57c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14b584: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14b588; return;
}


// Function: OnCrfodRemove__FP5CRFOD
// Address: 0x14b588 - 0x14b59c

void entry_14b59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b59c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14b5a0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14b5a4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x14b5ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7372));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_14b5ac
// Address: 0x14b5ac - 0x14b5c0

void entry_14b5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b5ac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b5b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b5b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14b5bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14b5c0; return;
}


// Function: CloneCrfod__FP5CRFODT0
// Address: 0x14b5c0 - 0x14b5e8

void entry_14b5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b5e8: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x14b5ec: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x14b5f0: 0xb2020c17
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 3095); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x14b5f4: 0xb6020c10
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 3088); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x14b5f8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14b5fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCrfodb__FP6CRFODB
// Address: 0x14b608 - 0x14b61c

void entry_14b61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b61c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14b620: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x14b624: 0xae020c24
    WRITE32(ADD32(GPR_U32(ctx, 16), 3108), GPR_U32(ctx, 2));
    // 0x14b628: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b62c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b630: 0xac60c008
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294950920), GPR_U32(ctx, 0));
    // 0x14b634: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14b63c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14b640; return;
}


// Function: PostCrfodbLoad__FP6CRFODB
// Address: 0x14b640 - 0x14b654

void entry_14b654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b654: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x14b658: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b65c: 0x8c62c008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294950920)));
    // 0x14b660: 0xae020c2c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3116), GPR_U32(ctx, 2));
    // 0x14b664: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x14b668: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b66c: 0xac62c008
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294950920), GPR_U32(ctx, 2));
    // 0x14b670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalcHeadingVector__FfP6VECTOR
// Address: 0x14b678 - 0x14b694

void entry_14b694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b694: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
    // 0x14b698: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14b69c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14b6a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCrfodbGoal__FP6CRFODBi
// Address: 0x14b6a8 - 0x14b7a4

void entry_14b7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b7a4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x14b7a8: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x14b7ac: 0x48b61800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 22));
    // 0x14b7b0: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14b7b4: 0x8e220928
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2344)));
    // 0x14b7b8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14b7bc: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14b7c0: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14b7c4: 0x10400036
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14B8A0; return;
    }
    // 0x14b7cc: 0x8c440054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x14b7d0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14b7d4: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14b7d8: 0x24070008
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 8));
    // 0x14b7dc: 0xc06427c
    SET_GPR_U32(ctx, 31, 0x14b7e4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_14b7e4
// Address: 0x14b7e4 - 0x14b8b0

void entry_14b7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14b7e4) {
        switch (ctx->pc) {
            case 0x14b800: ctx->pc = 0; goto label_14b800;
            case 0x14b810: ctx->pc = 0; goto label_14b810;
            case 0x14b834: ctx->pc = 0; goto label_14b834;
            case 0x14b840: ctx->pc = 0; goto label_14b840;
            case 0x14b87c: ctx->pc = 0; goto label_14b87c;
            case 0x14b890: ctx->pc = 0; goto label_14b890;
            case 0x14b8a0: ctx->pc = 0; goto label_14b8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14b7e4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14b7e8: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_14b800;
    }
    // 0x14b7f0: 0x10620007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_14b810;
    }
    // 0x14b7f8: 0x10000011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[26] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14b840;
    }
label_14b800:
    // 0x14b800: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14b804: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x14b808: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14b840;
    }
label_14b810:
    // 0x14b810: 0x46140832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b814: 0x0
    // NOP
    // 0x14b818: 0x45000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b834;
    }
    // 0x14b820: 0x461d0032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[29])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b824: 0x45010006
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14b840;
    }
    // 0x14b82c: 0x46140832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b830: 0x0
    // NOP
label_14b834:
    // 0x14b834: 0x45000002
    ctx->f[26] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b840;
    }
    // 0x14b83c: 0xc7ba0084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[26] = *(float*)&val; }
label_14b840:
    // 0x14b840: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x14b844: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14b848: 0x3c013faa
    SET_GPR_U32(ctx, 1, ((uint32_t)16298 << 16));
    // 0x14b84c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x14b850: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14b854: 0x461a0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[26]);
    // 0x14b858: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14b85c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14b860: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x14b864: 0x461c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[28])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b868: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b87c;
    }
    // 0x14b870: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x14b874: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14b890;
    }
label_14b87c:
    // 0x14b87c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b880: 0x0
    // NOP
    // 0x14b884: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b890;
    }
    // 0x14b88c: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_14b890:
    // 0x14b890: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x14b894: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14b898: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x14b89c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_14b8a0:
    // 0x14b8a0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14b8a4: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x14b8a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14b8b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14b8b0
// Address: 0x14b8b0 - 0x14b8f8

void entry_14b8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14b8b0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14b8b4: 0x12000027
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14B954; return;
    }
    // 0x14b8bc: 0x4402d800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[27]);
    // 0x14b8c0: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x14b8c4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x14b8c8: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14b8cc: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14b8d0: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x14b8d4: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x14b8d8: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x14b8dc: 0x27a903c4
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 964));
    // 0x14b8e0: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x14b8e4: 0x27aa0050
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 80));
    // 0x14b8e8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14b8ec: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14b8f0: 0xc07b702
    SET_GPR_U32(ctx, 31, 0x14b8f8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    FindClosestPointBetweenLineSegments__FP6VECTORN40PfT0(rdram, ctx, runtime); return;
}


// Function: entry_14b8f8
// Address: 0x14b8f8 - 0x14b9c4

void entry_14b8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14b8f8) {
        switch (ctx->pc) {
            case 0x14b938: ctx->pc = 0; goto label_14b938;
            case 0x14b948: ctx->pc = 0; goto label_14b948;
            case 0x14b94c: ctx->pc = 0; goto label_14b94c;
            case 0x14b954: ctx->pc = 0; goto label_14b954;
            case 0x14b980: ctx->pc = 0; goto label_14b980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14b8f8: 0xc60003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[0] = *(float*)&val; }
    // 0x14b8fc: 0xc62103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 976)); ctx->f[1] = *(float*)&val; }
    // 0x14b900: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x14b904: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14b908: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14b90c: 0xc7a203c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 964)); ctx->f[2] = *(float*)&val; }
    // 0x14b910: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14b914: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x14b918: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14b91c: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x14b920: 0x461c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[28])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b924: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b938;
    }
    // 0x14b92c: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x14b930: 0x10000006
    ctx->f[0] = FPU_SUB_S(ctx->f[29], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14b94c;
    }
label_14b938:
    // 0x14b938: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b93c: 0x0
    // NOP
    // 0x14b940: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[4]);
        goto label_14b948;
    }
label_14b948:
    // 0x14b948: 0x4602e801
    ctx->f[0] = FPU_SUB_S(ctx->f[29], ctx->f[2]);
label_14b94c:
    // 0x14b94c: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x14b950: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
label_14b954:
    // 0x14b954: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14b958: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x14b95c: 0x8c501ccc
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 7372)));
    // 0x14b960: 0x12000030
    ctx->f[22] = FPU_ADD_S(ctx->f[21], ctx->f[31]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BA24; return;
    }
    // 0x14b968: 0x3c144040
    SET_GPR_U32(ctx, 20, ((uint32_t)16448 << 16));
    // 0x14b96c: 0x4480c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 0);
    // 0x14b970: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14b974: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x14b978: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x14b97c: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
label_14b980:
    // 0x14b980: 0x52110026
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 3088)));
        ctx->pc = 0x14BA1C; return;
    }
    // 0x14b988: 0xda030140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x14b98c: 0x48b41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 20));
    // 0x14b990: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14b994: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14b998: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14b99c: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x14b9a0: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x14b9a4: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x14b9a8: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x14b9ac: 0x27a903c8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 968));
    // 0x14b9b0: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x14b9b4: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14b9b8: 0x27aa0050
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 80));
    // 0x14b9bc: 0xc07b702
    SET_GPR_U32(ctx, 31, 0x14b9c4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    FindClosestPointBetweenLineSegments__FP6VECTORN40PfT0(rdram, ctx, runtime); return;
}


// Function: entry_14b9c4
// Address: 0x14b9c4 - 0x14ba30

void entry_14b9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14b9c4) {
        switch (ctx->pc) {
            case 0x14b9fc: ctx->pc = 0; goto label_14b9fc;
            case 0x14ba0c: ctx->pc = 0; goto label_14ba0c;
            case 0x14ba10: ctx->pc = 0; goto label_14ba10;
            case 0x14ba1c: ctx->pc = 0; goto label_14ba1c;
            case 0x14ba24: ctx->pc = 0; goto label_14ba24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14b9c4: 0xc60003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[0] = *(float*)&val; }
    // 0x14b9c8: 0xc62103d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 976)); ctx->f[1] = *(float*)&val; }
    // 0x14b9cc: 0xc7a203c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 968)); ctx->f[2] = *(float*)&val; }
    // 0x14b9d0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14b9d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14b9d8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14b9dc: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x14b9e0: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x14b9e4: 0x46191034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[25])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14b9e8: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14b9fc;
    }
    // 0x14b9f0: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x14b9f4: 0x10000006
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14ba10;
    }
label_14b9fc:
    // 0x14b9fc: 0x46021834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14ba00: 0x0
    // NOP
    // 0x14ba04: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[3]);
        goto label_14ba0c;
    }
label_14ba0c:
    // 0x14ba0c: 0x4602c001
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[2]);
label_14ba10:
    // 0x14ba10: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x14ba14: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x14ba18: 0x8e100c10
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 3088)));
label_14ba1c:
    // 0x14ba1c: 0x1600ffd8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14B980; return;
    }
label_14ba24:
    // 0x14ba24: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x14ba28: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14ba30);
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14ba30
// Address: 0x14ba30 - 0x14ba6c

void entry_14ba30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ba30) {
        switch (ctx->pc) {
            case 0x14ba64: ctx->pc = 0; goto label_14ba64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ba30: 0x3c013ea2
    SET_GPR_U32(ctx, 1, ((uint32_t)16034 << 16));
    // 0x14ba34: 0x3421f983
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63875));
    // 0x14ba38: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14ba3c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x14ba40: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x14ba44: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x14ba48: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x14ba4c: 0x461ea034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[30])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14ba50: 0x0
    // NOP
    // 0x14ba54: 0x45000003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14ba64;
    }
    // 0x14ba5c: 0x4600a786
    ctx->f[30] = FPU_MOV_S(ctx->f[20]);
    // 0x14ba60: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_14ba64:
    // 0x14ba64: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x14ba6c);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_14ba6c
// Address: 0x14ba6c - 0x14ba84

void entry_14ba6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ba6c: 0x2a620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 16));
    // 0x14ba70: 0x1440ff49
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14B798; return;
    }
    // 0x14ba78: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ba7c: 0xc072106
    SET_GPR_U32(ctx, 31, 0x14ba84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14ba84
// Address: 0x14ba84 - 0x14baa0

void entry_14ba84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ba84) {
        switch (ctx->pc) {
            case 0x14ba8c: ctx->pc = 0; goto label_14ba8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ba84: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BAB4; return;
    }
label_14ba8c:
    // 0x14ba8c: 0x10a00009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BAB4; return;
    }
    // 0x14ba94: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ba98: 0xc072106
    SET_GPR_U32(ctx, 31, 0x14baa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14baa0
// Address: 0x14baa0 - 0x14bab0

void entry_14baa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14baa0) {
        switch (ctx->pc) {
            case 0x14baa8: ctx->pc = 0; goto label_14baa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14baa0: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BAB4; return;
    }
label_14baa8:
    // 0x14baa8: 0xc072302
    SET_GPR_U32(ctx, 31, 0x14bab0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_14bab0
// Address: 0x14bab0 - 0x14bb08

void entry_14bab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bab0) {
        switch (ctx->pc) {
            case 0x14bab4: ctx->pc = 0; goto label_14bab4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bab0: 0x7bbf0440
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
label_14bab4:
    // 0x14bab4: 0x7bb60430
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x14bab8: 0x7bb50420
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x14babc: 0x7bb40410
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x14bac0: 0x7bb30400
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x14bac4: 0x7bb203f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1008)));
    // 0x14bac8: 0x7bb103e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 992)));
    // 0x14bacc: 0x7bb003d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 976)));
    // 0x14bad0: 0xc7bf04a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1192)); ctx->f[31] = *(float*)&val; }
    // 0x14bad4: 0xc7be04a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1184)); ctx->f[30] = *(float*)&val; }
    // 0x14bad8: 0xc7bd0498
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1176)); ctx->f[29] = *(float*)&val; }
    // 0x14badc: 0xc7bc0490
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1168)); ctx->f[28] = *(float*)&val; }
    // 0x14bae0: 0xc7bb0488
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1160)); ctx->f[27] = *(float*)&val; }
    // 0x14bae4: 0xc7ba0480
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1152)); ctx->f[26] = *(float*)&val; }
    // 0x14bae8: 0xc7b90478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1144)); ctx->f[25] = *(float*)&val; }
    // 0x14baec: 0xc7b80470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1136)); ctx->f[24] = *(float*)&val; }
    // 0x14baf0: 0xc7b70468
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1128)); ctx->f[23] = *(float*)&val; }
    // 0x14baf4: 0xc7b60460
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1120)); ctx->f[22] = *(float*)&val; }
    // 0x14baf8: 0xc7b50458
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1112)); ctx->f[21] = *(float*)&val; }
    // 0x14bafc: 0xc7b40450
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1104)); ctx->f[20] = *(float*)&val; }
    // 0x14bb00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1200));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FDetectCrfodb__FP6CRFODB
// Address: 0x14bb08 - 0x14bb20

void entry_14bb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bb20) {
        switch (ctx->pc) {
            case 0x14bb44: ctx->pc = 0; goto label_14bb44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bb20: 0x1440006d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BCD8; return;
    }
    // 0x14bb28: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x14bb2c: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14bb30: 0x1062000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BB68; return;
    }
    // 0x14bb38: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14bb44;
    }
    // 0x14bb40: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
label_14bb44:
    // 0x14bb44: 0x10620064
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BCD8; return;
    }
    // 0x14bb4c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14bb50: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x14bb54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14bb5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14bb5c
// Address: 0x14bb5c - 0x14bce8

void entry_14bb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bb5c) {
        switch (ctx->pc) {
            case 0x14bb68: ctx->pc = 0; goto label_14bb68;
            case 0x14bb70: ctx->pc = 0; goto label_14bb70;
            case 0x14bbc8: ctx->pc = 0; goto label_14bbc8;
            case 0x14bc34: ctx->pc = 0; goto label_14bc34;
            case 0x14bc40: ctx->pc = 0; goto label_14bc40;
            case 0x14bc90: ctx->pc = 0; goto label_14bc90;
            case 0x14bc9c: ctx->pc = 0; goto label_14bc9c;
            case 0x14bcd4: ctx->pc = 0; goto label_14bcd4;
            case 0x14bcd8: ctx->pc = 0; goto label_14bcd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bb5c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14bb60: 0x54600003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
        goto label_14bb70;
    }
label_14bb68:
    // 0x14bb68: 0x1000005b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14bcd8;
    }
label_14bb70:
    // 0x14bb70: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14bb74: 0x4be1116c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14bb78: 0x8e020c20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x14bb7c: 0x4bc5286a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x14bb80: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14bb84: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bb88: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14bb8c: 0x4be42b3c
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x14bb90: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bb94: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14bb98: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14bb9c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14bba0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x14bba4: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14bbc8;
    }
    // 0x14bbac: 0xc4401c98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7320)); ctx->f[0] = *(float*)&val; }
    // 0x14bbb0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14bbb4: 0x0
    // NOP
    // 0x14bbb8: 0x45030046
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
        goto label_14bcd4;
    }
    // 0x14bbc0: 0x10000045
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14bcd8;
    }
label_14bbc8:
    // 0x14bbc8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14bbcc: 0xc4401c94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7316)); ctx->f[0] = *(float*)&val; }
    // 0x14bbd0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14bbd4: 0x0
    // NOP
    // 0x14bbd8: 0x4500003e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14bcd4;
    }
    // 0x14bbe0: 0xd8630150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x14bbe4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14bbe8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14bbec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bbf0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14bbf4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14bbf8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14bbfc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14bc00: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bc04: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14bc08: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14bc0c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14bc10: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14bc14: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x14bc18: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x14bc1c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14bc20: 0x0
    // NOP
    // 0x14bc24: 0x45000003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14bc34;
    }
    // 0x14bc2c: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14bc40;
    }
label_14bc34:
    // 0x14bc34: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14bc38: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14bc3c: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14bc40:
    // 0x14bc40: 0x4bc4206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x14bc44: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14bc48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bc4c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14bc50: 0x24628d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x14bc54: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bc58: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14bc5c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14bc60: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14bc64: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14bc68: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14bc6c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14bc70: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14bc74: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x14bc78: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14bc7c: 0x0
    // NOP
    // 0x14bc80: 0x45000003
    ctx->vu0_i = (float)ctx->vi[2];
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14bc90;
    }
    // 0x14bc88: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14bc9c;
    }
label_14bc90:
    // 0x14bc90: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14bc94: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14bc98: 0x4be0285c
    ctx->vu0_vf[5] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14bc9c:
    // 0x14bc9c: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14bca0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14bca4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14bca8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14bcac: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x14bcb0: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x14bcb4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14bcb8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14bcbc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x14bcc0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14bcc4: 0x0
    // NOP
    // 0x14bcc8: 0x45000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14bcd4;
    }
    // 0x14bcd0: 0xae020c20
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 2));
label_14bcd4:
    // 0x14bcd4: 0x8e020c20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
label_14bcd8:
    // 0x14bcd8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14bcdc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14bce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAbsorbCrfodbWkr__FP6CRFODBP3WKR
// Address: 0x14bce8 - 0x14bd18

void entry_14bd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bd18) {
        switch (ctx->pc) {
            case 0x14bd24: ctx->pc = 0; goto label_14bd24;
            case 0x14bd28: ctx->pc = 0; goto label_14bd28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bd18: 0x10400003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14bd28;
    }
    // 0x14bd20: 0xae000c20
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
label_14bd24:
    // 0x14bd24: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_14bd28:
    // 0x14bd28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14bd2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14bd30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014bd38
// Address: 0x14bd38 - 0x14bd4c

void FUN_0014bd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bd38: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14bd3c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x14bd40: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x14bd44: 0xc072472
    SET_GPR_U32(ctx, 31, 0x14bd4c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_14bd4c
// Address: 0x14bd4c - 0x14bd7c

void entry_14bd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bd4c) {
        switch (ctx->pc) {
            case 0x14bd6c: ctx->pc = 0; goto label_14bd6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bd4c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x14bd50: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14bd54: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_14bd6c;
    }
    // 0x14bd5c: 0x1062000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BD94; return;
    }
    // 0x14bd64: 0x10000016
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BDC0; return;
    }
label_14bd6c:
    // 0x14bd6c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x14bd70: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14bd74: 0xc053372
    SET_GPR_U32(ctx, 31, 0x14bd7c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294950924)));
    FUN_0014cdc8(rdram, ctx, runtime); return;
}


// Function: entry_14bd7c
// Address: 0x14bd7c - 0x14bdb8

void entry_14bd7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bd7c) {
        switch (ctx->pc) {
            case 0x14bd94: ctx->pc = 0; goto label_14bd94;
            case 0x14bda8: ctx->pc = 0; goto label_14bda8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bd7c: 0x8e020c28
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3112)));
    // 0x14bd80: 0x1040000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BDBC; return;
    }
    // 0x14bd88: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
    // 0x14bd8c: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 16), 3112), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BDBC; return;
    }
label_14bd94:
    // 0x14bd94: 0x8e020c28
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3112)));
    // 0x14bd98: 0x10400003
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14bda8;
    }
    // 0x14bda0: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
    // 0x14bda4: 0xae000c28
    WRITE32(ADD32(GPR_U32(ctx, 16), 3112), GPR_U32(ctx, 0));
label_14bda8:
    // 0x14bda8: 0x8e0407e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x14bdac: 0x8c62c00c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294950924)));
    // 0x14bdb0: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x14bdb8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1096)); ctx->f[12] = *(float*)&val; }
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_14bdb8
// Address: 0x14bdb8 - 0x14bdc8

void entry_14bdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bdb8) {
        switch (ctx->pc) {
            case 0x14bdbc: ctx->pc = 0; goto label_14bdbc;
            case 0x14bdc0: ctx->pc = 0; goto label_14bdc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bdb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14bdbc:
    // 0x14bdbc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_14bdc0:
    // 0x14bdc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SgsNextCrfodkAI__FP6CRFODK
// Address: 0x14bdc8 - 0x14bde4

void entry_14bde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bde4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14bde8: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14bdec: 0x12420029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BE94; return;
    }
    // 0x14bdf4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14bdfc);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14bdfc
// Address: 0x14bdfc - 0x14be10

void entry_14bdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bdfc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14be00: 0x1200000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_14be3c(rdram, ctx, runtime); return;
    }
    // 0x14be08: 0xc06e7ec
    SET_GPR_U32(ctx, 31, 0x14be10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsSoTouching__FP2SOT0(rdram, ctx, runtime); return;
}


// Function: entry_14be10
// Address: 0x14be10 - 0x14be28

void entry_14be10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14be10: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14be3c(rdram, ctx, runtime); return;
    }
    // 0x14be18: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14be1c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14be20: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x14be28);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 11));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14be28
// Address: 0x14be28 - 0x14be3c

void entry_14be28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14be28: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14be2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14be30: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14be34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14be3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14be3c
// Address: 0x14be3c - 0x14be60

void entry_14be3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14be3c) {
        switch (ctx->pc) {
            case 0x14be50: ctx->pc = 0; goto label_14be50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14be3c: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14be40: 0x8c501ccc
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 7372)));
    // 0x14be44: 0x12000012
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BE90; return;
    }
    // 0x14be4c: 0x0
    // NOP
label_14be50:
    // 0x14be50: 0x1211000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        entry_14be84(rdram, ctx, runtime); return;
    }
    // 0x14be58: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14be60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14be60
// Address: 0x14be60 - 0x14be70

void entry_14be60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14be60: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14be84(rdram, ctx, runtime); return;
    }
    // 0x14be68: 0xc06e7ec
    SET_GPR_U32(ctx, 31, 0x14be70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsSoTouching__FP2SOT0(rdram, ctx, runtime); return;
}


// Function: entry_14be70
// Address: 0x14be70 - 0x14be84

void entry_14be70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14be70: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14be84(rdram, ctx, runtime); return;
    }
    // 0x14be78: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14be7c: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x14be84);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_14be84
// Address: 0x14be84 - 0x14bea8

void entry_14be84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14be84) {
        switch (ctx->pc) {
            case 0x14be90: ctx->pc = 0; goto label_14be90;
            case 0x14be94: ctx->pc = 0; goto label_14be94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14be84: 0x8e100c10
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 3088)));
    // 0x14be88: 0x1600fff1
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BE50; return;
    }
label_14be90:
    // 0x14be90: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_14be94:
    // 0x14be94: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14be98: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14be9c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14bea0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FDetectCrfodk__FP6CRFODK
// Address: 0x14bea8 - 0x14bec0

void entry_14bec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bec0) {
        switch (ctx->pc) {
            case 0x14bee0: ctx->pc = 0; goto label_14bee0;
            case 0x14bee4: ctx->pc = 0; goto label_14bee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bec0: 0x14400008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14bee4;
    }
    // 0x14bec8: 0x8e040724
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x14becc: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14bed0: 0x10820003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_14bee0;
    }
    // 0x14bed8: 0x14820002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_14bee4;
    }
label_14bee0:
    // 0x14bee0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_14bee4:
    // 0x14bee4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14bee8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14beec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14bef4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14bef8; return;
}


// Function: FAbsorbCrfodkWkr__FP6CRFODKP3WKR
// Address: 0x14bef8 - 0x14bf30

void entry_14bf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bf30: 0x10400010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14BF74; return;
    }
    // 0x14bf38: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14bf40);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14bf40
// Address: 0x14bf40 - 0x14bf5c

void entry_14bf40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bf40: 0x8e100000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14bf44: 0x1602000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BF74; return;
    }
    // 0x14bf4c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14bf50: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14bf54: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x14bf5c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14bf5c
// Address: 0x14bf5c - 0x14bf70

void entry_14bf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bf5c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14bf60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14bf64: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14bf68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14bf70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14bf70
// Address: 0x14bf70 - 0x14bf88

void entry_14bf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bf70) {
        switch (ctx->pc) {
            case 0x14bf74: ctx->pc = 0; goto label_14bf74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bf70: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_14bf74:
    // 0x14bf74: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14bf78: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14bf7c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14bf80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014bf88
// Address: 0x14bf88 - 0x14bf9c

void FUN_0014bf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14bf88: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14bf8c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x14bf90: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x14bf94: 0xc072472
    SET_GPR_U32(ctx, 31, 0x14bf9c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_14bf9c
// Address: 0x14bf9c - 0x14bfcc

void entry_14bf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bf9c) {
        switch (ctx->pc) {
            case 0x14bfbc: ctx->pc = 0; goto label_14bfbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bf9c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x14bfa0: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14bfa4: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_14bfbc;
    }
    // 0x14bfac: 0x1062000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14BFE4; return;
    }
    // 0x14bfb4: 0x10000015
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C00C; return;
    }
label_14bfbc:
    // 0x14bfbc: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x14bfc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14bfc4: 0xc05335c
    SET_GPR_U32(ctx, 31, 0x14bfcc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294950924)));
    FUN_0014cd70(rdram, ctx, runtime); return;
}


// Function: entry_14bfcc
// Address: 0x14bfcc - 0x14c004

void entry_14bfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14bfcc) {
        switch (ctx->pc) {
            case 0x14bfe4: ctx->pc = 0; goto label_14bfe4;
            case 0x14bffc: ctx->pc = 0; goto label_14bffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14bfcc: 0x8e020c20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x14bfd0: 0x1040000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C008; return;
    }
    // 0x14bfd8: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
    // 0x14bfdc: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C008; return;
    }
label_14bfe4:
    // 0x14bfe4: 0x8e020c20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x14bfe8: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3108)); ctx->f[12] = *(float*)&val; }
        goto label_14bffc;
    }
    // 0x14bff0: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
    // 0x14bff4: 0xae000c20
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
    // 0x14bff8: 0xc60c0c24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3108)); ctx->f[12] = *(float*)&val; }
label_14bffc:
    // 0x14bffc: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x14c004);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_14c004
// Address: 0x14c004 - 0x14c018

void entry_14c004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c004) {
        switch (ctx->pc) {
            case 0x14c008: ctx->pc = 0; goto label_14c008;
            case 0x14c00c: ctx->pc = 0; goto label_14c00c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c004: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14c008:
    // 0x14c008: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_14c00c:
    // 0x14c00c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14c014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14c018; return;
}


// Function: InitCrbrain__FP7CRBRAIN
// Address: 0x14c018 - 0x14c02c

void entry_14c02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c02c) {
        switch (ctx->pc) {
            case 0x14c054: ctx->pc = 0; goto label_14c054;
            case 0x14c090: ctx->pc = 0; goto label_14c090;
            case 0x14c0b8: ctx->pc = 0; goto label_14c0b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c02c: 0x3c0142b4
    SET_GPR_U32(ctx, 1, ((uint32_t)17076 << 16));
    // 0x14c030: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c034: 0x24030032
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 50));
    // 0x14c038: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x14c03c: 0xae0302d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 3));
    // 0x14c040: 0x24429f00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942464));
    // 0x14c044: 0xe60002d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 728), *(uint32_t*)&val); }
    // 0x14c048: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x14c04c: 0x244400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 160));
    // 0x14c050: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_14c054:
    // 0x14c054: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c058: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14c05c: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x14c060: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x14c064: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x14c068: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_14c054;
    }
    // 0x14c070: 0x784a0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c074: 0x26070574
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1396));
    // 0x14c078: 0x7c6a0000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 10));
    // 0x14c07c: 0x2608057c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 1404));
    // 0x14c080: 0x26030480
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 1152));
    // 0x14c084: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14c088: 0x26040530
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1328));
    // 0x14c08c: 0x26060470
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 1136));
label_14c090:
    // 0x14c090: 0x78490000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c094: 0x784a0010
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14c098: 0x7c690000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 9));
    // 0x14c09c: 0x7c6a0010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 10));
    // 0x14c0a0: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x14c0a4: 0x1445fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_14c090;
    }
    // 0x14c0ac: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x14c0b0: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x14c0b4: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_14c0b8:
    // 0x14c0b8: 0x784c0000
    SET_GPR_VEC(ctx, 12, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c0bc: 0x78430010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14c0c0: 0x7c8c0000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 12));
    // 0x14c0c4: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x14c0c8: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x14c0cc: 0x1445fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_14c0b8;
    }
    // 0x14c0d4: 0x784b0000
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c0d8: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14c0dc: 0x3c014140
    SET_GPR_U32(ctx, 1, ((uint32_t)16704 << 16));
    // 0x14c0e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c0e4: 0x7c8b0000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 11));
    // 0x14c0e8: 0xe6000574
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1396), *(uint32_t*)&val); }
    // 0x14c0ec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x14c0f0: 0xe4e00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 4), *(uint32_t*)&val); }
    // 0x14c0f4: 0xe600057c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1404), *(uint32_t*)&val); }
    // 0x14c0f8: 0xe5000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 8), 4), *(uint32_t*)&val); }
    // 0x14c0fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c100: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14c104: 0xae000470
    WRITE32(ADD32(GPR_U32(ctx, 16), 1136), GPR_U32(ctx, 0));
    // 0x14c108: 0xc4409fb0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942640)); ctx->f[0] = *(float*)&val; }
    // 0x14c10c: 0xe4c10004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 6), 4), *(uint32_t*)&val); }
    // 0x14c110: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x14c114: 0xacc00008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 0));
    // 0x14c118: 0xe600045c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1116), *(uint32_t*)&val); }
    // 0x14c11c: 0xae030450
    WRITE32(ADD32(GPR_U32(ctx, 16), 1104), GPR_U32(ctx, 3));
    // 0x14c120: 0xae000464
    WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 0));
    // 0x14c124: 0xac50c00c
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294950924), GPR_U32(ctx, 16));
    // 0x14c128: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14c12c: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14c130: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: post_load_crbrain
// Address: 0x14c138 - 0x14c164

void entry_14c164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c164: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x14c168: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14c16c: 0x24c61ca0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 7328));
    // 0x14c170: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x14c178);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_14c178
// Address: 0x14c178 - 0x14c18c

void entry_14c178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c178: 0x8e440428
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1064)));
    // 0x14c17c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14c180: 0x240603fb
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1019));
    // 0x14c184: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x14c18c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_14c18c
// Address: 0x14c18c - 0x14c19c

void entry_14c18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c18c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14c190: 0xae42042c
    WRITE32(ADD32(GPR_U32(ctx, 18), 1068), GPR_U32(ctx, 2));
    // 0x14c194: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14c19c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1072));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c19c
// Address: 0x14c19c - 0x14c1a8

void entry_14c19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c19c: 0x8e44042c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1068)));
    // 0x14c1a0: 0xc06db7e
    SET_GPR_U32(ctx, 31, 0x14c1a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001b6df8(rdram, ctx, runtime); return;
}


// Function: entry_14c1a8
// Address: 0x14c1a8 - 0x14c1cc

void entry_14c1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c1a8) {
        switch (ctx->pc) {
            case 0x14c1b8: ctx->pc = 0; goto label_14c1b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c1a8: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x14c1ac: 0x18400018
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14C210; return;
    }
    // 0x14c1b4: 0x265102e0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 736));
label_14c1b8:
    // 0x14c1b8: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14c1bc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14c1c0: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x14c1c4: 0xc056912
    SET_GPR_U32(ctx, 31, 0x14c1cc);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14c1cc
// Address: 0x14c1cc - 0x14c1e4

void entry_14c1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c1cc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14c1d0: 0x240503f7
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1015));
    // 0x14c1d4: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x14c1d8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14c1dc: 0xc056920
    SET_GPR_U32(ctx, 31, 0x14c1e4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14c1e4
// Address: 0x14c1e4 - 0x14c1f8

void entry_14c1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c1e4: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x14c1e8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14c1ec: 0x240503f6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1014));
    // 0x14c1f0: 0xc056920
    SET_GPR_U32(ctx, 31, 0x14c1f8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14c1f8
// Address: 0x14c1f8 - 0x14c2cc

void entry_14c1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c1f8) {
        switch (ctx->pc) {
            case 0x14c210: ctx->pc = 0; goto label_14c210;
            case 0x14c258: ctx->pc = 0; goto label_14c258;
            case 0x14c26c: ctx->pc = 0; goto label_14c26c;
            case 0x14c288: ctx->pc = 0; goto label_14c288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c1f8: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x14c1fc: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x14c200: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x14c204: 0x1440ffec
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C1B8; return;
    }
    // 0x14c20c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_14c210:
    // 0x14c210: 0x26430470
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1136));
    // 0x14c214: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x14c218: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x14c21c: 0x26825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 23648));
    // 0x14c220: 0xc481000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[1] = *(float*)&val; }
    // 0x14c224: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c228: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14c22c: 0xc6430470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1136)); ctx->f[3] = *(float*)&val; }
    // 0x14c230: 0xc6845c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x14c234: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x14c238: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x14c23c: 0x46011840
    ctx->f[1] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x14c240: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c244: 0x0
    // NOP
    // 0x14c248: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c258;
    }
    // 0x14c250: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14c26c;
    }
label_14c258:
    // 0x14c258: 0x46012834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c25c: 0x0
    // NOP
    // 0x14c260: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c26c;
    }
    // 0x14c268: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_14c26c:
    // 0x14c26c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c270: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c274: 0x26450480
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1152));
    // 0x14c278: 0x26440530
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1328));
    // 0x14c27c: 0x264305e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1504));
    // 0x14c280: 0x46030081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x14c284: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_14c288:
    // 0x14c288: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x14c28c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x14c290: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14c294: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x14c298: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x14c29c: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x14c2a0: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x14c2a4: 0x2cc2002c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 44));
    // 0x14c2a8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c2ac: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x14c2b0: 0x1440fff5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14c288;
    }
    // 0x14c2b8: 0xc64005e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1504)); ctx->f[0] = *(float*)&val; }
    // 0x14c2bc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x14c2c0: 0xe641044c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 1100), *(uint32_t*)&val); }
    // 0x14c2c4: 0xc0530bc
    SET_GPR_U32(ctx, 31, 0x14c2cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0014c2f0(rdram, ctx, runtime); return;
}


// Function: entry_14c2cc
// Address: 0x14c2cc - 0x14c2f0

void entry_14c2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c2cc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14c2d0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14c2d4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14c2d8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14c2dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14c2e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14c2e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14c2ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14c2f0; return;
}


// Function: FUN_0014c2f0
// Address: 0x14c2f0 - 0x14c5e8

void FUN_0014c2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c2f0) {
        switch (ctx->pc) {
            case 0x14c334: ctx->pc = 0; goto label_14c334;
            case 0x14c380: ctx->pc = 0; goto label_14c380;
            case 0x14c394: ctx->pc = 0; goto label_14c394;
            case 0x14c410: ctx->pc = 0; goto label_14c410;
            case 0x14c424: ctx->pc = 0; goto label_14c424;
            case 0x14c4ac: ctx->pc = 0; goto label_14c4ac;
            case 0x14c51c: ctx->pc = 0; goto label_14c51c;
            case 0x14c58c: ctx->pc = 0; goto label_14c58c;
            case 0x14c5e0: ctx->pc = 0; goto label_14c5e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c2f0: 0xc48102d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 720)); ctx->f[1] = *(float*)&val; }
    // 0x14c2f4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x14c2f8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c2fc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x14c300: 0xc48002d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 724)); ctx->f[0] = *(float*)&val; }
    // 0x14c304: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x14c308: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x14c30c: 0x46000803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
    // 0x14c310: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c314: 0x0
    // NOP
    // 0x14c318: 0x45010006
    ctx->f[6] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14c334;
    }
    // 0x14c320: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c324: 0x0
    // NOP
    // 0x14c328: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c334;
    }
    // 0x14c330: 0x46001986
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
label_14c334:
    // 0x14c334: 0x24830610
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1552));
    // 0x14c338: 0xc4820610
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1552)); ctx->f[2] = *(float*)&val; }
    // 0x14c33c: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14c340: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x14c344: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c348: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14c34c: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x14c350: 0xc4435c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x14c354: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x14c358: 0x248505e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1504));
    // 0x14c35c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c360: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x14c364: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c368: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c36c: 0x0
    // NOP
    // 0x14c370: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c380;
    }
    // 0x14c378: 0x10000006
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14c394;
    }
label_14c380:
    // 0x14c380: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c384: 0x0
    // NOP
    // 0x14c388: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c394;
    }
    // 0x14c390: 0x46002906
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
label_14c394:
    // 0x14c394: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c398: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14c39c: 0x24a20060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 96));
    // 0x14c3a0: 0xc4a20020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 32)); ctx->f[2] = *(float*)&val; }
    // 0x14c3a4: 0x24c35c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 23648));
    // 0x14c3a8: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x14c3ac: 0xc4a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 40)); ctx->f[0] = *(float*)&val; }
    // 0x14c3b0: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x14c3b4: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14c3b8: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c3bc: 0xe4820434
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 4), 1076), *(uint32_t*)&val); }
    // 0x14c3c0: 0xc4a30024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 36)); ctx->f[3] = *(float*)&val; }
    // 0x14c3c4: 0xc4a0002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 44)); ctx->f[0] = *(float*)&val; }
    // 0x14c3c8: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14c3cc: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x14c3d0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14c3d4: 0xe4810438
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 1080), *(uint32_t*)&val); }
    // 0x14c3d8: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14c3dc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c3e0: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x14c3e4: 0xc4a20060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 96)); ctx->f[2] = *(float*)&val; }
    // 0x14c3e8: 0xc4c35c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x14c3ec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c3f0: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x14c3f4: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c3f8: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c3fc: 0x0
    // NOP
    // 0x14c400: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c410;
    }
    // 0x14c408: 0x10000006
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14c424;
    }
label_14c410:
    // 0x14c410: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c414: 0x0
    // NOP
    // 0x14c418: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c424;
    }
    // 0x14c420: 0x46002906
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
label_14c424:
    // 0x14c424: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c428: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14c42c: 0x24a20080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 128));
    // 0x14c430: 0xc4a20044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 68)); ctx->f[2] = *(float*)&val; }
    // 0x14c434: 0x24c35c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 23648));
    // 0x14c438: 0x46040841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x14c43c: 0xc4a0004c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 76)); ctx->f[0] = *(float*)&val; }
    // 0x14c440: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x14c444: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14c448: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c44c: 0xe482043c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 4), 1084), *(uint32_t*)&val); }
    // 0x14c450: 0xc4a30048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 72)); ctx->f[3] = *(float*)&val; }
    // 0x14c454: 0xc4a00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 80)); ctx->f[0] = *(float*)&val; }
    // 0x14c458: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14c45c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x14c460: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14c464: 0xe4810440
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 1088), *(uint32_t*)&val); }
    // 0x14c468: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14c46c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c470: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x14c474: 0xc4a20080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 128)); ctx->f[2] = *(float*)&val; }
    // 0x14c478: 0xc4c35c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x14c47c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c480: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x14c484: 0x46001040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c488: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c48c: 0x0
    // NOP
    // 0x14c490: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14c4ac;
    }
    // 0x14c498: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c49c: 0x0
    // NOP
    // 0x14c4a0: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c4ac;
    }
    // 0x14c4a8: 0x460020c6
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
label_14c4ac:
    // 0x14c4ac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c4b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c4b4: 0x24a300a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 160));
    // 0x14c4b8: 0xc4a20070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 112)); ctx->f[2] = *(float*)&val; }
    // 0x14c4bc: 0x24c25c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 23648));
    // 0x14c4c0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x14c4c4: 0xc4a10074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 116)); ctx->f[1] = *(float*)&val; }
    // 0x14c4c8: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x14c4cc: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14c4d0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c4d4: 0xe4800444
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 1092), *(uint32_t*)&val); }
    // 0x14c4d8: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14c4dc: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c4e0: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x14c4e4: 0xc4a200a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 160)); ctx->f[2] = *(float*)&val; }
    // 0x14c4e8: 0xc4c35c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x14c4ec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c4f0: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x14c4f4: 0x46001040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c4f8: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c4fc: 0x0
    // NOP
    // 0x14c500: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14c51c;
    }
    // 0x14c508: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c50c: 0x0
    // NOP
    // 0x14c510: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c51c;
    }
    // 0x14c518: 0x460020c6
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
label_14c51c:
    // 0x14c51c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c520: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c524: 0x24a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 16));
    // 0x14c528: 0xc4a20090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 144)); ctx->f[2] = *(float*)&val; }
    // 0x14c52c: 0x24c35c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 23648));
    // 0x14c530: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x14c534: 0xc4a10094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 148)); ctx->f[1] = *(float*)&val; }
    // 0x14c538: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x14c53c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14c540: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c544: 0xe4800448
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 1096), *(uint32_t*)&val); }
    // 0x14c548: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14c54c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c550: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x14c554: 0xc4a20010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[2] = *(float*)&val; }
    // 0x14c558: 0xc4c35c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x14c55c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c560: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x14c564: 0x46001040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x14c568: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c56c: 0x0
    // NOP
    // 0x14c570: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14c58c;
    }
    // 0x14c578: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c57c: 0x0
    // NOP
    // 0x14c580: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c58c;
    }
    // 0x14c588: 0x460020c6
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
label_14c58c:
    // 0x14c58c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c590: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c594: 0xc4a20000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[2] = *(float*)&val; }
    // 0x14c598: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x14c59c: 0xc4a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[1] = *(float*)&val; }
    // 0x14c5a0: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x14c5a4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14c5a8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14c5ac: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x14c5b0: 0xe481044c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 1100), *(uint32_t*)&val); }
    // 0x14c5b4: 0xc4a10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 64)); ctx->f[1] = *(float*)&val; }
    // 0x14c5b8: 0x46060834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c5bc: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c5e0;
    }
    // 0x14c5c4: 0x8c820464
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1124)));
    // 0x14c5c8: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14c5e0;
    }
    // 0x14c5d0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14c5d4: 0xac820464
    WRITE32(ADD32(GPR_U32(ctx, 4), 1124), GPR_U32(ctx, 2));
    // 0x14c5d8: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x14c5dc: 0xe480045c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 1116), *(uint32_t*)&val); }
label_14c5e0:
    // 0x14c5e0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014c5e8
// Address: 0x14c5e8 - 0x14c65c

void FUN_0014c5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c5e8) {
        switch (ctx->pc) {
            case 0x14c634: ctx->pc = 0; goto label_14c634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c5e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x14c5ec: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14c5f0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x14c5f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c5f8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14c5fc: 0xc48102d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 724)); ctx->f[1] = *(float*)&val; }
    // 0x14c600: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x14c604: 0xc48002d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 720)); ctx->f[0] = *(float*)&val; }
    // 0x14c608: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x14c60c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x14c610: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c614: 0x0
    // NOP
    // 0x14c618: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[12]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14c634;
    }
    // 0x14c620: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c624: 0x0
    // NOP
    // 0x14c628: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14c634;
    }
    // 0x14c630: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_14c634:
    // 0x14c634: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x14c638: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x14c63c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14c640: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x14c644: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c648: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14c64c: 0x24841ef0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    // 0x14c650: 0x460c0b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    // 0x14c654: 0xc054788
    SET_GPR_U32(ctx, 31, 0x14c65c);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_14c65c
// Address: 0x14c65c - 0x14c668

void entry_14c65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c65c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14c660: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014c668
// Address: 0x14c668 - 0x14c690

void FUN_0014c668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c668: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x14c66c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14c670: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x14c674: 0x14a20015
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        entry_14c6cc(rdram, ctx, runtime); return;
    }
    // 0x14c67c: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x14c680: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14c684: 0x8e02c00c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294950924)));
    // 0x14c688: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x14c690);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1068)));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c690
// Address: 0x14c690 - 0x14c6a0

void entry_14c690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c690: 0x8e02c00c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294950924)));
    // 0x14c694: 0x37a50004
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    // 0x14c698: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14c6a0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1068)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c6a0
// Address: 0x14c6a0 - 0x14c6c4

void entry_14c6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c6a0: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14c6a4: 0x240303fe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1022));
    // 0x14c6a8: 0x10430008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_14c6cc(rdram, ctx, runtime); return;
    }
    // 0x14c6b0: 0x10430006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294950924)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_14c6cc(rdram, ctx, runtime); return;
    }
    // 0x14c6b8: 0x240503ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1023));
    // 0x14c6bc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x14c6c4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1068)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c6c4
// Address: 0x14c6c4 - 0x14c6cc

void entry_14c6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c6c4: 0xc05317a
    SET_GPR_U32(ctx, 31, 0x14c6cc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294950924)));
    FUN_0014c5e8(rdram, ctx, runtime); return;
}


// Function: entry_14c6cc
// Address: 0x14c6cc - 0x14c6e0

void entry_14c6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c6cc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14c6d0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14c6d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14c6dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14c6e0; return;
}


// Function: update_crbrain
// Address: 0x14c6e0 - 0x14c6f8

void entry_14c6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c6f8: 0x8e04042c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1068)));
    // 0x14c6fc: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14c704);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c704
// Address: 0x14c704 - 0x14c73c

void entry_14c704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c704: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14c708: 0x240203fd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1021));
    // 0x14c70c: 0x1462001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14C778; return;
    }
    // 0x14c714: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14c718: 0xc601045c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1116)); ctx->f[1] = *(float*)&val; }
    // 0x14c71c: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x14c720: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14c724: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c728: 0x0
    // NOP
    // 0x14c72c: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x14C740; return;
    }
    // 0x14c734: 0xc053216
    SET_GPR_U32(ctx, 31, 0x14c73c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0014c858(rdram, ctx, runtime); return;
}


// Function: entry_14c73c
// Address: 0x14c73c - 0x14c758

void entry_14c73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c73c) {
        switch (ctx->pc) {
            case 0x14c740: ctx->pc = 0; goto label_14c740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c73c: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
label_14c740:
    // 0x14c740: 0xc6000460
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1120)); ctx->f[0] = *(float*)&val; }
    // 0x14c744: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c748: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        entry_14c758(rdram, ctx, runtime); return;
    }
    // 0x14c750: 0xc0532ea
    SET_GPR_U32(ctx, 31, 0x14c758);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0014cba8(rdram, ctx, runtime); return;
}


// Function: entry_14c758
// Address: 0x14c758 - 0x14c760

void entry_14c758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c758: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14c760);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14c760
// Address: 0x14c760 - 0x14c774

void entry_14c760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c760: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14c764: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14c768: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x14c76c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14c774);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14c774
// Address: 0x14c774 - 0x14c788

void entry_14c774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c774) {
        switch (ctx->pc) {
            case 0x14c778: ctx->pc = 0; goto label_14c778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c774: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14c778:
    // 0x14c778: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14c77c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14c780: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014c788
// Address: 0x14c788 - 0x14c79c

void FUN_0014c788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c788: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14c78c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x14c790: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14c794: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14c79c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 1068)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14c79c
// Address: 0x14c79c - 0x14c7b4

void entry_14c79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c79c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14c7a0: 0x240203fd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1021));
    // 0x14c7a4: 0x14620004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14C7B8; return;
    }
    // 0x14c7ac: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x14c7b4);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14c7b4
// Address: 0x14c7b4 - 0x14c7d0

void entry_14c7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c7b4) {
        switch (ctx->pc) {
            case 0x14c7b8: ctx->pc = 0; goto label_14c7b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c7b4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_14c7b8:
    // 0x14c7b8: 0x1080000c
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C7EC; return;
    }
    // 0x14c7c0: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x14c7c4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x14c7c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14c7d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14c7d0
// Address: 0x14c7d0 - 0x14c7e4

void entry_14c7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c7d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x14c7d4: 0x8c83e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960992)));
    // 0x14c7d8: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x14c7dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14c7e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14c7e4
// Address: 0x14c7e4 - 0x14c7fc

void entry_14c7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c7e4) {
        switch (ctx->pc) {
            case 0x14c7ec: ctx->pc = 0; goto label_14c7ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c7e4: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C814; return;
    }
label_14c7ec:
    // 0x14c7ec: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x14c7f0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x14c7f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14c7fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14c7fc
// Address: 0x14c7fc - 0x14c810

void entry_14c7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c7fc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x14c800: 0x8c83e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960992)));
    // 0x14c804: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x14c808: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14c810);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14c810
// Address: 0x14c810 - 0x14c820

void entry_14c810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c810) {
        switch (ctx->pc) {
            case 0x14c814: ctx->pc = 0; goto label_14c814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c810: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14c814:
    // 0x14c814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14c81c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14c820; return;
}


// Function: FUN_0014c820
// Address: 0x14c820 - 0x14c838

void FUN_0014c820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c820: 0x8c820690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1680)));
    // 0x14c824: 0x240300b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 176));
    // 0x14c828: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x14c82c: 0x24420480
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1152));
    // 0x14c830: 0x3e00008
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014c838
// Address: 0x14c838 - 0x14c858

void FUN_0014c838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c838: 0x8c8202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 732)));
    // 0x14c83c: 0x24030014
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 20));
    // 0x14c840: 0x433018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x14c844: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x14c848: 0xac8202dc
    WRITE32(ADD32(GPR_U32(ctx, 4), 732), GPR_U32(ctx, 2));
    // 0x14c84c: 0xc41821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x14c850: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 3), 736), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014c858
// Address: 0x14c858 - 0x14c8d8

void FUN_0014c858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c858) {
        switch (ctx->pc) {
            case 0x14c8b8: ctx->pc = 0; goto label_14c8b8;
            case 0x14c8d0: ctx->pc = 0; goto label_14c8d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c858: 0x27bdfee0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967008));
    // 0x14c85c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x14c860: 0x7fb20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 18));
    // 0x14c864: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14c868: 0xe7b50118
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 280), *(uint32_t*)&val); }
    // 0x14c86c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14c870: 0xc4559fb4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942644)); ctx->f[21] = *(float*)&val; }
    // 0x14c874: 0x2642043c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1084));
    // 0x14c878: 0x7fb700e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 23));
    // 0x14c87c: 0xafa20068
    WRITE32(ADD32(GPR_U32(ctx, 29), 104), GPR_U32(ctx, 2));
    // 0x14c880: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14c884: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x14c888: 0x7fbf0100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 31));
    // 0x14c88c: 0x7fbe00f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 30));
    // 0x14c890: 0x7fb600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 22));
    // 0x14c894: 0x7fb500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 21));
    // 0x14c898: 0x7fb400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 20));
    // 0x14c89c: 0x7fb300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 19));
    // 0x14c8a0: 0x7fb10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 17));
    // 0x14c8a4: 0x7fb00070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 16));
    // 0x14c8a8: 0xe7b40110
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 272), *(uint32_t*)&val); }
    // 0x14c8ac: 0xafa30060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 3));
    // 0x14c8b0: 0xafa20064
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 2));
    // 0x14c8b4: 0x0
    // NOP
label_14c8b8:
    // 0x14c8b8: 0x8e420458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1112)));
    // 0x14c8bc: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x14c8c0: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14c8d0;
    }
    // 0x14c8c8: 0x100000a9
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 18), 1116), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14CB70; return;
    }
label_14c8d0:
    // 0x14c8d0: 0xc06a2be
    SET_GPR_U32(ctx, 31, 0x14c8d8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1056)));
    ReloadRwm__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_14c8d8
// Address: 0x14c8d8 - 0x14c8f0

void entry_14c8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c8d8: 0x8e420420
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1056)));
    // 0x14c8dc: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x14c8e0: 0x106000a4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14CB74; return;
    }
    // 0x14c8e8: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14c8f0);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4294967295));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14c8f0
// Address: 0x14c8f0 - 0x14c93c

void entry_14c8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c8f0) {
        switch (ctx->pc) {
            case 0x14c900: ctx->pc = 0; goto label_14c900;
            case 0x14c918: ctx->pc = 0; goto label_14c918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c8f0: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x14c8f4: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14c8f8: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14c8fc: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
label_14c900:
    // 0x14c900: 0x1840004e
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14CA3C; return;
    }
    // 0x14c908: 0x3c1e0026
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    // 0x14c90c: 0x24160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14c910: 0x265002e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 736));
    // 0x14c914: 0x0
    // NOP
label_14c918:
    // 0x14c918: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x14c91c: 0x54400043
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        ctx->pc = 0x14CA2C; return;
    }
    // 0x14c924: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x14c928: 0x54400040
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        ctx->pc = 0x14CA2C; return;
    }
    // 0x14c930: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x14c934: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x14c93c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14c93c
// Address: 0x14c93c - 0x14c958

void entry_14c93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14c93c: 0x5660001d
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 320)));
        ctx->pc = 0x14C9B4; return;
    }
    // 0x14c944: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14c948: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x14c94c: 0x8fc41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 6544)));
    // 0x14c950: 0xc051070
    SET_GPR_U32(ctx, 31, 0x14c958);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_14c958
// Address: 0x14c958 - 0x14ca78

void entry_14c958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14c958) {
        switch (ctx->pc) {
            case 0x14c9b4: ctx->pc = 0; goto label_14c9b4;
            case 0x14ca14: ctx->pc = 0; goto label_14ca14;
            case 0x14ca2c: ctx->pc = 0; goto label_14ca2c;
            case 0x14ca3c: ctx->pc = 0; goto label_14ca3c;
            case 0x14ca58: ctx->pc = 0; goto label_14ca58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14c958: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x14c95c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x14c960: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14c964: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c968: 0x0
    // NOP
    // 0x14c96c: 0x4503002f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        goto label_14ca2c;
    }
    // 0x14c974: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14c978: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14c97c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c980: 0x0
    // NOP
    // 0x14c984: 0x45030029
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        goto label_14ca2c;
    }
    // 0x14c98c: 0xc7a00024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[0] = *(float*)&val; }
    // 0x14c990: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c994: 0x0
    // NOP
    // 0x14c998: 0x45030024
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        goto label_14ca2c;
    }
    // 0x14c9a0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14c9a4: 0x0
    // NOP
    // 0x14c9a8: 0x45030020
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        goto label_14ca2c;
    }
    // 0x14c9b0: 0xdaa10140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 320)));
label_14c9b4:
    // 0x14c9b4: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14c9b8: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9bc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14c9c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14c9cc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14c9d4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14c9d8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14c9dc: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x14c9e0: 0x16f6000c
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 22)) {
        goto label_14ca14;
    }
    // 0x14c9e8: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9ec: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9f0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14c9f4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14c9f8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14c9fc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ca00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14ca04: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14ca08: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14ca0c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14ca10: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_14ca14:
    // 0x14ca14: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14ca18: 0x0
    // NOP
    // 0x14ca1c: 0x45000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14ca2c;
    }
    // 0x14ca24: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    // 0x14ca28: 0x220a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_14ca2c:
    // 0x14ca2c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14ca30: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x14ca34: 0x1440ffb8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C918; return;
    }
label_14ca3c:
    // 0x14ca3c: 0x6810006
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_S32(ctx, 20) >= 0) {
        goto label_14ca58;
    }
    // 0x14ca44: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x14ca48: 0x5440ffad
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        ctx->pc = 0x14C900; return;
    }
    // 0x14ca50: 0x10000048
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14CB74; return;
    }
label_14ca58:
    // 0x14ca58: 0x24030014
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 20));
    // 0x14ca5c: 0x8e440420
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1056)));
    // 0x14ca60: 0x2831018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x14ca64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ca68: 0x8c900048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 72)));
    // 0x14ca6c: 0x244202e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 736));
    // 0x14ca70: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x14ca78);
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_14ca78
// Address: 0x14ca78 - 0x14ca84

void entry_14ca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ca78: 0x8fa50060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14ca7c: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x14ca84);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14ca84
// Address: 0x14ca84 - 0x14ca90

void entry_14ca84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ca84: 0x8fa50064
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    // 0x14ca88: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x14ca90);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14ca90
// Address: 0x14ca90 - 0x14caa4

void entry_14ca90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ca90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ca94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ca98: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x14ca9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14caa4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14caa4
// Address: 0x14caa4 - 0x14cab8

void entry_14caa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14caa4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14caa8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14caac: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14cab0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14cab8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14cab8
// Address: 0x14cab8 - 0x14cad0

void entry_14cab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cab8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14cabc: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x14cac0: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x14cac4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x14cac8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14cad0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14cad0
// Address: 0x14cad0 - 0x14cae8

void entry_14cad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cad0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14cad4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x14cad8: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x14cadc: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x14cae0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14cae8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14cae8
// Address: 0x14cae8 - 0x14cb18

void entry_14cae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cae8) {
        switch (ctx->pc) {
            case 0x14caf4: ctx->pc = 0; goto label_14caf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cae8: 0x16e00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_14caf4;
    }
    // 0x14caf0: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_14caf4:
    // 0x14caf4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14caf8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14cafc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14cb00: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14cb04: 0x2627000c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 12));
    // 0x14cb08: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x14cb0c: 0x26f70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    // 0x14cb10: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x14cb18);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_14cb18
// Address: 0x14cb18 - 0x14cb24

void entry_14cb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cb18: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14cb1c: 0xc04be04
    SET_GPR_U32(ctx, 31, 0x14cb24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SubscribeAsegaObject__FP5ASEGAP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14cb24
// Address: 0x14cb24 - 0x14cb40

void entry_14cb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cb24: 0x8e420458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1112)));
    // 0x14cb28: 0xc64c043c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1084)); ctx->f[12] = *(float*)&val; }
    // 0x14cb2c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x14cb30: 0xae420458
    WRITE32(ADD32(GPR_U32(ctx, 18), 1112), GPR_U32(ctx, 2));
    // 0x14cb34: 0x8fa20068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 104)));
    // 0x14cb38: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x14cb40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14cb40
// Address: 0x14cb40 - 0x14cba8

void entry_14cb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cb40) {
        switch (ctx->pc) {
            case 0x14cb70: ctx->pc = 0; goto label_14cb70;
            case 0x14cb74: ctx->pc = 0; goto label_14cb74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cb40: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14cb44: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14cb48: 0x24631858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x14cb4c: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x14cb50: 0x2ae30002
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 23), 2));
    // 0x14cb54: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14cb58: 0xe641045c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 1116), *(uint32_t*)&val); }
    // 0x14cb5c: 0xae110c20
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 17));
    // 0x14cb60: 0xae220010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    // 0x14cb64: 0xc6400444
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1092)); ctx->f[0] = *(float*)&val; }
    // 0x14cb68: 0x1460ff53
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3108), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14C8B8; return;
    }
label_14cb70:
    // 0x14cb70: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_14cb74:
    // 0x14cb74: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x14cb78: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x14cb7c: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14cb80: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14cb84: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14cb88: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14cb8c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14cb90: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14cb94: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14cb98: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x14cb9c: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x14cba0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014cba8
// Address: 0x14cba8 - 0x14cbf0

void FUN_0014cba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cba8) {
        switch (ctx->pc) {
            case 0x14cbe8: ctx->pc = 0; goto label_14cbe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cba8: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x14cbac: 0x7fb400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 20));
    // 0x14cbb0: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x14cbb4: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14cbb8: 0x7fb300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 19));
    // 0x14cbbc: 0x7fb200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 18));
    // 0x14cbc0: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x14cbc4: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x14cbc8: 0x8e820454
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1108)));
    // 0x14cbcc: 0x8e83044c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1100)));
    // 0x14cbd0: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x14cbd4: 0x14400004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14cbe8;
    }
    // 0x14cbdc: 0xc4409fb8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294942648)); ctx->f[0] = *(float*)&val; }
    // 0x14cbe0: 0x1000005a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1120), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14CD4C; return;
    }
label_14cbe8:
    // 0x14cbe8: 0xc06a2be
    SET_GPR_U32(ctx, 31, 0x14cbf0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1060)));
    ReloadRwm__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_14cbf0
// Address: 0x14cbf0 - 0x14cc54

void entry_14cbf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cbf0) {
        switch (ctx->pc) {
            case 0x14cc18: ctx->pc = 0; goto label_14cc18;
            case 0x14cc3c: ctx->pc = 0; goto label_14cc3c;
            case 0x14cc44: ctx->pc = 0; goto label_14cc44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cbf0: 0x8e820424
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1060)));
    // 0x14cbf4: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x14cbf8: 0x10600055
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14CD50; return;
    }
    // 0x14cc00: 0x8e8202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 732)));
    // 0x14cc04: 0x1840000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_14cc44;
    }
    // 0x14cc0c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14cc10: 0x268302e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 736));
    // 0x14cc14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_14cc18:
    // 0x14cc18: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x14cc1c: 0x14400007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14cc3c;
    }
    // 0x14cc24: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x14cc28: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14cc3c;
    }
    // 0x14cc30: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x14cc34: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x14cc38: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
label_14cc3c:
    // 0x14cc3c: 0x14c0fff6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 20));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_14cc18;
    }
label_14cc44:
    // 0x14cc44: 0x18a00041
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x14CD4C; return;
    }
    // 0x14cc4c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x14cc54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_14cc54
// Address: 0x14cc54 - 0x14cc74

void entry_14cc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cc54: 0x8e860424
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 1060)));
    // 0x14cc58: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14cc5c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x14cc60: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14cc64: 0x8cd10048
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 6), 72)));
    // 0x14cc68: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x14cc6c: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x14cc74);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_14cc74
// Address: 0x14cc74 - 0x14cc84

void entry_14cc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cc74: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x14cc78: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x14cc7c: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x14cc84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14cc84
// Address: 0x14cc84 - 0x14cc94

void entry_14cc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cc84: 0x27b30050
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 80));
    // 0x14cc88: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x14cc8c: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x14cc94);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14cc94
// Address: 0x14cc94 - 0x14cca8

void entry_14cc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cc94: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14cc98: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14cc9c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x14cca0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14cca8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14cca8
// Address: 0x14cca8 - 0x14ccbc

void entry_14cca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cca8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14ccac: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14ccb0: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14ccb4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ccbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ccbc
// Address: 0x14ccbc - 0x14ccd8

void entry_14ccbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ccbc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14ccc0: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x14ccc4: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x14ccc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14cccc: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x14ccd0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ccd8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ccd8
// Address: 0x14ccd8 - 0x14ccec

void entry_14ccd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ccd8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14ccdc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14cce0: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x14cce4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ccec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ccec
// Address: 0x14ccec - 0x14cd0c

void entry_14ccec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ccec: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14ccf0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ccf4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14ccf8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14ccfc: 0x2647000c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 12));
    // 0x14cd00: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x14cd04: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x14cd0c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_14cd0c
// Address: 0x14cd0c - 0x14cd18

void entry_14cd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cd0c: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x14cd10: 0xc04be04
    SET_GPR_U32(ctx, 31, 0x14cd18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SubscribeAsegaObject__FP5ASEGAP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14cd18
// Address: 0x14cd18 - 0x14cd30

void entry_14cd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cd18: 0x8e820454
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1108)));
    // 0x14cd1c: 0xc68c0434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1076)); ctx->f[12] = *(float*)&val; }
    // 0x14cd20: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x14cd24: 0xc68d0438
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1080)); ctx->f[13] = *(float*)&val; }
    // 0x14cd28: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x14cd30);
    WRITE32(ADD32(GPR_U32(ctx, 20), 1108), GPR_U32(ctx, 2));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14cd30
// Address: 0x14cd30 - 0x14cd70

void entry_14cd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cd30) {
        switch (ctx->pc) {
            case 0x14cd4c: ctx->pc = 0; goto label_14cd4c;
            case 0x14cd50: ctx->pc = 0; goto label_14cd50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cd30: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14cd34: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14cd38: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x14cd3c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14cd40: 0xe6810460
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 1120), *(uint32_t*)&val); }
    // 0x14cd44: 0xae320c28
    WRITE32(ADD32(GPR_U32(ctx, 17), 3112), GPR_U32(ctx, 18));
    // 0x14cd48: 0xae430010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 3));
label_14cd4c:
    // 0x14cd4c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_14cd50:
    // 0x14cd50: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14cd54: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14cd58: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14cd5c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14cd60: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14cd64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14cd6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14cd70; return;
}


// Function: FUN_0014cd70
// Address: 0x14cd70 - 0x14cd9c

void FUN_0014cd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cd70: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x14cd74: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x14cd78: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x14cd7c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14cd80: 0x8e030458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1112)));
    // 0x14cd84: 0x8e020450
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1104)));
    // 0x14cd88: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1112)));
        ctx->pc = 0x14CDB0; return;
    }
    // 0x14cd90: 0xc60c043c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1084)); ctx->f[12] = *(float*)&val; }
    // 0x14cd94: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x14cd9c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1088)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14cd9c
// Address: 0x14cd9c - 0x14cdc8

void entry_14cd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cd9c) {
        switch (ctx->pc) {
            case 0x14cdb0: ctx->pc = 0; goto label_14cdb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cd9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14cda0: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x14cda4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14cda8: 0xe601045c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1116), *(uint32_t*)&val); }
    // 0x14cdac: 0x8e020458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1112)));
label_14cdb0:
    // 0x14cdb0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14cdb4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x14cdb8: 0xae020458
    WRITE32(ADD32(GPR_U32(ctx, 16), 1112), GPR_U32(ctx, 2));
    // 0x14cdbc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14cdc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014cdc8
// Address: 0x14cdc8 - 0x14ce28

void FUN_0014cdc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cdc8) {
        switch (ctx->pc) {
            case 0x14ce00: ctx->pc = 0; goto label_14ce00;
            case 0x14ce08: ctx->pc = 0; goto label_14ce08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cdc8: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x14cdcc: 0x7fb200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 18));
    // 0x14cdd0: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x14cdd4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14cdd8: 0x7fb300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 19));
    // 0x14cddc: 0x7fb100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 17));
    // 0x14cde0: 0x7fb00090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 16));
    // 0x14cde4: 0x8ca30c24
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 3108)));
    // 0x14cde8: 0x8e4202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    // 0x14cdec: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14cdf0: 0x4610003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_14ce00;
    }
    // 0x14cdf8: 0x10000003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14ce08;
    }
label_14ce00:
    // 0x14ce00: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x14ce04: 0x82180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
label_14ce08:
    // 0x14ce08: 0x8e4202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    // 0x14ce0c: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x14ce10: 0x14400030
    WRITE32(ADD32(GPR_U32(ctx, 18), 720), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_14ced4(rdram, ctx, runtime); return;
    }
    // 0x14ce18: 0x8e44042c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1068)));
    // 0x14ce1c: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x14ce20: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14ce28);
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14ce28
// Address: 0x14ce28 - 0x14ce34

void entry_14ce28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ce28: 0x8e44042c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1068)));
    // 0x14ce2c: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x14ce34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 132));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14ce34
// Address: 0x14ce34 - 0x14ce3c

void entry_14ce34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ce34: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x14ce3c);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_14ce3c
// Address: 0x14ce3c - 0x14ce50

void entry_14ce3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ce3c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14ce40: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14ce44: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x14ce48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ce50);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ce50
// Address: 0x14ce50 - 0x14ce80

void entry_14ce50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ce50: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14ce54: 0x240303ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1023));
    // 0x14ce58: 0x8fa20080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14ce5c: 0x1043001b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x14CECC; return;
    }
    // 0x14ce64: 0x10430019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x14CECC; return;
    }
    // 0x14ce6c: 0x10820017
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14CECC; return;
    }
    // 0x14ce74: 0x8e44042c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1068)));
    // 0x14ce78: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x14ce80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1022));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_14ce80
// Address: 0x14ce80 - 0x14ce9c

void entry_14ce80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ce80: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x14ce84: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x14ce88: 0x24060012
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 18));
    // 0x14ce8c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ce90: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x14ce94: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x14ce9c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14ce9c
// Address: 0x14ce9c - 0x14cec0

void entry_14ce9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ce9c) {
        switch (ctx->pc) {
            case 0x14ceb0: ctx->pc = 0; goto label_14ceb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ce9c: 0x1840000b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14CECC; return;
    }
    // 0x14cea4: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14cea8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ceac: 0x0
    // NOP
label_14ceb0:
    // 0x14ceb0: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x14ceb4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ceb8: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x14cec0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_14cec0
// Address: 0x14cec0 - 0x14ced4

void entry_14cec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cec0) {
        switch (ctx->pc) {
            case 0x14cecc: ctx->pc = 0; goto label_14cecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cec0: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x14cec4: 0x5620fffa
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x14CEB0; return;
    }
label_14cecc:
    // 0x14cecc: 0xc06ae56
    SET_GPR_U32(ctx, 31, 0x14ced4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294960992));
    StopTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_14ced4
// Address: 0x14ced4 - 0x14cedc

void entry_14ced4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ced4: 0xc0530bc
    SET_GPR_U32(ctx, 31, 0x14cedc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0014c2f0(rdram, ctx, runtime); return;
}


// Function: entry_14cedc
// Address: 0x14cedc - 0x14cef8

void entry_14cedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cedc: 0x8e430454
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1108)));
    // 0x14cee0: 0x8e42044c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1100)));
    // 0x14cee4: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1108)));
        ctx->pc = 0x14CF0C; return;
    }
    // 0x14ceec: 0xc64c0434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1076)); ctx->f[12] = *(float*)&val; }
    // 0x14cef0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x14cef8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1080)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_14cef8
// Address: 0x14cef8 - 0x14cf30

void entry_14cef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cef8) {
        switch (ctx->pc) {
            case 0x14cf0c: ctx->pc = 0; goto label_14cf0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cef8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14cefc: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x14cf00: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14cf04: 0xe6410460
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 1120), *(uint32_t*)&val); }
    // 0x14cf08: 0x8e420454
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1108)));
label_14cf0c:
    // 0x14cf0c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14cf10: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x14cf14: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14cf18: 0xae420454
    WRITE32(ADD32(GPR_U32(ctx, 18), 1108), GPR_U32(ctx, 2));
    // 0x14cf1c: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14cf20: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14cf24: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14cf28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: handle_crbrain_message
// Address: 0x14cf30 - 0x14cf54

void entry_14cf54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14cf54) {
        switch (ctx->pc) {
            case 0x14cf70: ctx->pc = 0; goto label_14cf70;
            case 0x14cf98: ctx->pc = 0; goto label_14cf98;
            case 0x14cfb4: ctx->pc = 0; goto label_14cfb4;
            case 0x14cfcc: ctx->pc = 0; goto label_14cfcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14cf54: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x14cf58: 0x12020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_14cf70;
    }
    // 0x14cf60: 0x1202001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_14cfcc;
    }
    // 0x14cf68: 0x1000004b
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D098; return;
    }
label_14cf70:
    // 0x14cf70: 0x8e2202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 732)));
    // 0x14cf74: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14cf78: 0x18400045
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14D090; return;
    }
    // 0x14cf80: 0x8e2202ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 748)));
    // 0x14cf84: 0x1052000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        goto label_14cfb4;
    }
    // 0x14cf8c: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x14cf90: 0x262302ec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 748));
    // 0x14cf94: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_14cf98:
    // 0x14cf98: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x14cf9c: 0x1040003c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D090; return;
    }
    // 0x14cfa4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x14cfa8: 0x5452fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_14cf98;
    }
    // 0x14cfb0: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
label_14cfb4:
    // 0x14cfb4: 0x10400036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D090; return;
    }
    // 0x14cfbc: 0x821818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x14cfc0: 0x711021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x14cfc4: 0x10000032
    WRITE32(ADD32(GPR_U32(ctx, 2), 748), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D090; return;
    }
label_14cfcc:
    // 0x14cfcc: 0x8e22042c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1068)));
    // 0x14cfd0: 0x56420031
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x14D098; return;
    }
    // 0x14cfd8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14cfdc: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14cfe4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14cfe4
// Address: 0x14cfe4 - 0x14d018

void entry_14cfe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14cfe4: 0x241203fd
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1021));
    // 0x14cfe8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14cfec: 0x54520017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1072)));
        ctx->pc = 0x14D04C; return;
    }
    // 0x14cff4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x14cff8: 0x262202d4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 724));
    // 0x14cffc: 0x2463d348
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294955848));
    // 0x14d000: 0x262402d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 720));
    // 0x14d004: 0xac620268
    WRITE32(ADD32(GPR_U32(ctx, 3), 616), GPR_U32(ctx, 2));
    // 0x14d008: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14d00c: 0xac640264
    WRITE32(ADD32(GPR_U32(ctx, 3), 612), GPR_U32(ctx, 4));
    // 0x14d010: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x14d018);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_14d018
// Address: 0x14d018 - 0x14d02c

void entry_14d018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d018: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x14d01c: 0xc62c02d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 728)); ctx->f[12] = *(float*)&val; }
    // 0x14d020: 0x2610e760
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x14d024: 0xc06ae24
    SET_GPR_U32(ctx, 31, 0x14d02c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTimer__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_14d02c
// Address: 0x14d02c - 0x14d040

void entry_14d02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d02c: 0x3c050015
    SET_GPR_U32(ctx, 5, ((uint32_t)21 << 16));
    // 0x14d030: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14d034: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14d038: 0xc06ae4a
    SET_GPR_U32(ctx, 31, 0x14d040);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952552));
    SetTimerExpire__FP5TIMERfPv(rdram, ctx, runtime); return;
}


// Function: entry_14d040
// Address: 0x14d040 - 0x14d048

void entry_14d040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d040: 0xc06ae4e
    SET_GPR_U32(ctx, 31, 0x14d048);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StartTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_14d048
// Address: 0x14d048 - 0x14d068

void entry_14d048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d048) {
        switch (ctx->pc) {
            case 0x14d04c: ctx->pc = 0; goto label_14d04c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d048: 0x8e220430
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1072)));
label_14d04c:
    // 0x14d04c: 0x1452000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x14D08C; return;
    }
    // 0x14d054: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x14d058: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x14d05c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x14d060: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14d068);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14d068
// Address: 0x14d068 - 0x14d07c

void entry_14d068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d068: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x14d06c: 0x8c83e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960992)));
    // 0x14d070: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x14d074: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14d07c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14d07c
// Address: 0x14d07c - 0x14d088

void entry_14d07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d07c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14d080: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x14d088);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_14d088
// Address: 0x14d088 - 0x14d0a8

void entry_14d088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d088) {
        switch (ctx->pc) {
            case 0x14d08c: ctx->pc = 0; goto label_14d08c;
            case 0x14d090: ctx->pc = 0; goto label_14d090;
            case 0x14d098: ctx->pc = 0; goto label_14d098;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d088: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_14d08c:
    // 0x14d08c: 0xae220430
    WRITE32(ADD32(GPR_U32(ctx, 17), 1072), GPR_U32(ctx, 2));
label_14d090:
    // 0x14d090: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14d094: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14d098:
    // 0x14d098: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14d09c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14d0a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SMeasureApos__FiP6VECTORPf
// Address: 0x14d0a8 - 0x14d138

void entry_14d1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d1cc) {
        switch (ctx->pc) {
            case 0x14d1f8: ctx->pc = 0; goto label_14d1f8;
            case 0x14d218: ctx->pc = 0; goto label_14d218;
            case 0x14d21c: ctx->pc = 0; goto label_14d21c;
            case 0x14d240: ctx->pc = 0; goto label_14d240;
            case 0x14d25c: ctx->pc = 0; goto label_14d25c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d1cc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14d1d0: 0xd0102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 16)));
    // 0x14d1d4: 0x10400010
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14d218;
    }
    // 0x14d1dc: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14d1e0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d1e4: 0x0
    // NOP
    // 0x14d1e8: 0x4501000c
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 16)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_14d21c;
    }
    // 0x14d1f0: 0x26230004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4));
    // 0x14d1f4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_14d1f8:
    // 0x14d1f8: 0xd0102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 16)));
    // 0x14d1fc: 0x10400006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14d218;
    }
    // 0x14d204: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x14d208: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d20c: 0x0
    // NOP
    // 0x14d210: 0x4502fff9
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
        goto label_14d1f8;
    }
label_14d218:
    // 0x14d218: 0xd0182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 16)));
label_14d21c:
    // 0x14d21c: 0x24c2ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x14d220: 0x43300a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x14d224: 0x12400006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_14d240;
    }
    // 0x14d22c: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x14d230: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x14d234: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x14d238: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x14d23c: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_14d240:
    // 0x14d240: 0x12600006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_14d25c;
    }
    // 0x14d248: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x14d24c: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14d250: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14d254: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14d258: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
label_14d25c:
    // 0x14d25c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14d260: 0xc0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x14d264: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14d268: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14d26c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14d270: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14d274: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14d27c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14d280; return;
}


// Function: EvaluateAposG__FfiP6VECTORPfiT2T2
// Address: 0x14d280 - 0x14d2b4

void entry_14d2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d2b4) {
        switch (ctx->pc) {
            case 0x14d308: ctx->pc = 0; goto label_14d308;
            case 0x14d37c: ctx->pc = 0; goto label_14d37c;
            case 0x14d388: ctx->pc = 0; goto label_14d388;
            case 0x14d38c: ctx->pc = 0; goto label_14d38c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d2b4: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x14d2b8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14d2bc: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x14d2c0: 0x12400011
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_14d308;
    }
    // 0x14d2c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14d2cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14d2d0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x14d2d4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14d2d8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x14d2dc: 0x31100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    // 0x14d2e0: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x14d2e4: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x14d2e8: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14d2ec: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x14d2f0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14d2f4: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14d2f8: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d2fc: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14d300: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d304: 0xfa420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_14d308:
    // 0x14d308: 0x12200020
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_14d38c;
    }
    // 0x14d310: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14d314: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14d318: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14d31c: 0x502021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x14d320: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x14d324: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14d328: 0xd8820000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14d32c: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d330: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x14d334: 0x4be2192c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14d338: 0x4be1233c
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d33c: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d340: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d344: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d348: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d34c: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d350: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d354: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d358: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14d35c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d360: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14d364: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d368: 0x0
    // NOP
    // 0x14d36c: 0x45000003
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14d37c;
    }
    // 0x14d374: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14d388;
    }
label_14d37c:
    // 0x14d37c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d380: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d384: 0x4be0205c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14d388:
    // 0x14d388: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_14d38c:
    // 0x14d38c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14d390: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14d394: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14d398: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14d39c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14d3a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14d3a8; return;
}


// Function: FindAposClosestPointAll__FP6VECTORP6CONSTRiT0N20PiPf
// Address: 0x14d3a8 - 0x14d460

void entry_14d460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d460: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14d464: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14d468: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14d46c: 0xc06e90c
    SET_GPR_U32(ctx, 31, 0x14d474);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_14d474
// Address: 0x14d474 - 0x14d680

void entry_14d474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d474) {
        switch (ctx->pc) {
            case 0x14d4e4: ctx->pc = 0; goto label_14d4e4;
            case 0x14d4f4: ctx->pc = 0; goto label_14d4f4;
            case 0x14d4f8: ctx->pc = 0; goto label_14d4f8;
            case 0x14d550: ctx->pc = 0; goto label_14d550;
            case 0x14d55c: ctx->pc = 0; goto label_14d55c;
            case 0x14d564: ctx->pc = 0; goto label_14d564;
            case 0x14d570: ctx->pc = 0; goto label_14d570;
            case 0x14d5bc: ctx->pc = 0; goto label_14d5bc;
            case 0x14d630: ctx->pc = 0; goto label_14d630;
            case 0x14d63c: ctx->pc = 0; goto label_14d63c;
            case 0x14d640: ctx->pc = 0; goto label_14d640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d474: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14d478: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d47c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d480: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d484: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d488: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14d48c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d490: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d494: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14d498: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d49c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d4a0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d4a4: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x14d4a8: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14d4ac: 0x4bc308ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d4b0: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d4b4: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14d4b8: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d4bc: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x14d4c0: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14d4c4: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x14d4c8: 0x46160834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d4cc: 0x0
    // NOP
    // 0x14d4d0: 0x45000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14d4e4;
    }
    // 0x14d4d8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x14d4dc: 0x10000006
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14d4f8;
    }
label_14d4e4:
    // 0x14d4e4: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d4e8: 0x0
    // NOP
    // 0x14d4ec: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[2]);
        goto label_14d4f4;
    }
label_14d4f4:
    // 0x14d4f4: 0x46000807
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
label_14d4f8:
    // 0x14d4f8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14d4fc: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14d500: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x14d504: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14d508: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d50c: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d510: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14d514: 0x4bc1092a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d518: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d51c: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x14d520: 0x4b04110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d524: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d528: 0x48222000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14d52c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14d530: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d534: 0x0
    // NOP
    // 0x14d538: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_14d550;
    }
    // 0x14d540: 0x46020d03
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[20] = ctx->f[1] / ctx->f[2];
    // 0x14d544: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x14d548: 0x220b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14d54c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_14d550:
    // 0x14d550: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x14d554: 0x1440ffb4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D428; return;
    }
label_14d55c:
    // 0x14d55c: 0x57c00001
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 22));
        goto label_14d564;
    }
label_14d564:
    // 0x14d564: 0x8fa30048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x14d568: 0x54600001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
        goto label_14d570;
    }
label_14d570:
    // 0x14d570: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x14d574: 0x10400011
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14d5bc;
    }
    // 0x14d57c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14d580: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14d584: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x14d588: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x14d58c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x14d590: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14d594: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14d598: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x14d59c: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14d5a0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14d5a4: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14d5a8: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d5ac: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x14d5b0: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14d5b4: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d5b8: 0xf8420000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_14d5bc:
    // 0x14d5bc: 0x12e00020
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 4));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_14d640;
    }
    // 0x14d5c4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14d5c8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14d5cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14d5d0: 0x552021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x14d5d4: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x14d5d8: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14d5dc: 0xd8820000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14d5e0: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d5e4: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x14d5e8: 0x4be2192c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14d5ec: 0x4be1233c
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d5f0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d5f4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d5f8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d5fc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d600: 0xfae10000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d604: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d608: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d60c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14d610: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d614: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14d618: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d61c: 0x0
    // NOP
    // 0x14d620: 0x45000003
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14d630;
    }
    // 0x14d628: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14d63c;
    }
label_14d630:
    // 0x14d630: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d634: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d638: 0x4be0205c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14d63c:
    // 0x14d63c: 0xfae10000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_14d640:
    // 0x14d640: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x14d644: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14d648: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14d64c: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14d650: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14d654: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14d658: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14d65c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14d660: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14d664: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14d668: 0xc7b60100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[22] = *(float*)&val; }
    // 0x14d66c: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x14d670: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x14d674: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14d67c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14d680; return;
}


// Function: FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf
// Address: 0x14d680 - 0x14d784

void entry_14d784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14d784: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14d788: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14d78c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14d790: 0xc06e90c
    SET_GPR_U32(ctx, 31, 0x14d798);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_14d798
// Address: 0x14d798 - 0x14d938

void entry_14d798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d798) {
        switch (ctx->pc) {
            case 0x14d808: ctx->pc = 0; goto label_14d808;
            case 0x14d80c: ctx->pc = 0; goto label_14d80c;
            case 0x14d814: ctx->pc = 0; goto label_14d814;
            case 0x14d820: ctx->pc = 0; goto label_14d820;
            case 0x14d868: ctx->pc = 0; goto label_14d868;
            case 0x14d8e0: ctx->pc = 0; goto label_14d8e0;
            case 0x14d8f0: ctx->pc = 0; goto label_14d8f0;
            case 0x14d8fc: ctx->pc = 0; goto label_14d8fc;
            case 0x14d904: ctx->pc = 0; goto label_14d904;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d798: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14d79c: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d7a0: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d7a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d7a8: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d7ac: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14d7b0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d7b4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d7b8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14d7bc: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x14d7c0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d7c4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d7c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d7cc: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x14d7d0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x14d7d4: 0x4bc308ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d7d8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d7dc: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14d7e0: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d7e4: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14d7e8: 0x48231800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x14d7ec: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x14d7f0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d7f4: 0x0
    // NOP
    // 0x14d7f8: 0x4500ffc2
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14D704; return;
    }
    // 0x14d800: 0x12e0ffb7
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D6E0; return;
    }
label_14d808:
    // 0x14d808: 0x8fa200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
label_14d80c:
    // 0x14d80c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
        goto label_14d814;
    }
label_14d814:
    // 0x14d814: 0x8fa300e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 232)));
    // 0x14d818: 0x54600001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
        goto label_14d820;
    }
label_14d820:
    // 0x14d820: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x14d824: 0x10400010
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14d868;
    }
    // 0x14d82c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14d830: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14d834: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x14d838: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14d83c: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14d840: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14d844: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x14d848: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14d84c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d850: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x14d854: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d858: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x14d85c: 0x4be119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d860: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d864: 0xf8410000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_14d868:
    // 0x14d868: 0x8fa30038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x14d86c: 0x10600025
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_14d904;
    }
    // 0x14d874: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14d878: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14d87c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14d880: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x14d884: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14d888: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x14d88c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x14d890: 0x4be1112c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d894: 0x8fa20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x14d898: 0x4be1233c
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d89c: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x14d8a0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14d8a4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14d8a8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d8ac: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14d8b0: 0xf8410000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d8b4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14d8b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d8bc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14d8c0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14d8c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14d8c8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14d8cc: 0x0
    // NOP
    // 0x14d8d0: 0x45000007
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14d8f0;
    }
    // 0x14d8d8: 0x10000008
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14d8fc;
    }
label_14d8e0:
    // 0x14d8e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14d8e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14d8e8: 0x1000ffc8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14d80c;
    }
label_14d8f0:
    // 0x14d8f0: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14d8f4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14d8f8: 0x4be0205c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14d8fc:
    // 0x14d8fc: 0x8fa30038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x14d900: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_14d904:
    // 0x14d904: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x14d908: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x14d90c: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x14d910: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14d914: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14d918: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14d91c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14d920: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14d924: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14d928: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14d92c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14d934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14d938; return;
}


// Function: ConvertApos__FiP6VECTORP7MATRIX4T2
// Address: 0x14d938 - 0x14d960

void entry_14d960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d960) {
        switch (ctx->pc) {
            case 0x14d968: ctx->pc = 0; goto label_14d968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d960: 0x1a20000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x14D998; return;
    }
label_14d968:
    // 0x14d968: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14d96c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14d970: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14d974: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14d978: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x14d980);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_14d980
// Address: 0x14d980 - 0x14d9a8

void entry_14d980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d980) {
        switch (ctx->pc) {
            case 0x14d998: ctx->pc = 0; goto label_14d998;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d980: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x14d984: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14d988: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x14d98c: 0x1620fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D968; return;
    }
    // 0x14d994: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_14d998:
    // 0x14d998: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14d99c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14d9a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PcrvNew__F4CRVK
// Address: 0x14d9a8 - 0x14d9d8

void entry_14d9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d9d8) {
        switch (ctx->pc) {
            case 0x14d9e8: ctx->pc = 0; goto label_14d9e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d9d8: 0x3c030021
    SET_GPR_U32(ctx, 3, ((uint32_t)33 << 16));
    // 0x14d9dc: 0x246376d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 30416));
    // 0x14d9e0: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14D9FC; return;
    }
label_14d9e8:
    // 0x14d9e8: 0xc063570
    SET_GPR_U32(ctx, 31, 0x14d9f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 464));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14d9f0
// Address: 0x14d9f0 - 0x14da18

void entry_14d9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14d9f0) {
        switch (ctx->pc) {
            case 0x14d9fc: ctx->pc = 0; goto label_14d9fc;
            case 0x14da04: ctx->pc = 0; goto label_14da04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14d9f0: 0x3c030021
    SET_GPR_U32(ctx, 3, ((uint32_t)33 << 16));
    // 0x14d9f4: 0x24637708
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 30472));
    // 0x14d9f8: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_14d9fc:
    // 0x14d9fc: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
        goto label_14da04;
    }
label_14da04:
    // 0x14da04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14da08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14da0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14da14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14da18; return;
}


// Function: SFromCrvU__FP3CRVf
// Address: 0x14da18 - 0x14da28

void entry_14da5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14da5c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14da60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IcvFindCrvS__FP3CRVfPfT2
// Address: 0x14da68 - 0x14da8c

void entry_14da8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14da8c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14da90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GMeasureCrvU__FP5CRVMCf
// Address: 0x14da98 - 0x14dac4

void entry_14dac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14dac4) {
        switch (ctx->pc) {
            case 0x14daf4: ctx->pc = 0; goto label_14daf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14dac4: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x14dac8: 0x1480000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_14daf4;
    }
    // 0x14dad0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14dad4: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14dad8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14dadc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14dae0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14dae4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14dae8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14daec: 0x1000000f
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14DB2C; return;
    }
label_14daf4:
    // 0x14daf4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14daf8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14dafc: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x14db00: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14db04: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14db08: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14db0c: 0xc06e90c
    SET_GPR_U32(ctx, 31, 0x14db14);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    ApplyConstr__FP6CONSTRP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_14db14
// Address: 0x14db14 - 0x14db40

void entry_14db14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14db14) {
        switch (ctx->pc) {
            case 0x14db2c: ctx->pc = 0; goto label_14db2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14db14: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14db18: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14db1c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14db20: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14db24: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14db28: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
label_14db2c:
    // 0x14db2c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14db30: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14db34: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14db38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UMaxCrv__FP3CRV
// Address: 0x14db40 - 0x14db58

void entry_14dba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dba4: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x14dba8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14dbac: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x14dbb0: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14dbb4: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x14dbbc);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 20));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_14dbbc
// Address: 0x14dbbc - 0x14dbd0

void entry_14dbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dbbc: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x14dbc0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14dbc4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14dbc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6
// Address: 0x14dbd0 - 0x14dc7c

void entry_14dc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14dc7c) {
        switch (ctx->pc) {
            case 0x14dc90: ctx->pc = 0; goto label_14dc90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14dc7c: 0x56400004
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_14dc90;
    }
    // 0x14dc84: 0x12200009
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_14dcac(rdram, ctx, runtime); return;
    }
    // 0x14dc8c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_14dc90:
    // 0x14dc90: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x14dc94: 0x10400005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14dcac(rdram, ctx, runtime); return;
    }
    // 0x14dc9c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14dca0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14dca4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14dcac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14dcac
// Address: 0x14dcac - 0x14dcd0

void entry_14dcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14dcac) {
        switch (ctx->pc) {
            case 0x14dcb8: ctx->pc = 0; goto label_14dcb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14dcac: 0x12600002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_14dcb8;
    }
    // 0x14dcb4: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
label_14dcb8:
    // 0x14dcb8: 0x12800006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14DCD4; return;
    }
    // 0x14dcc0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14dcc4: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x14dcc8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14dcd0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14dcd0
// Address: 0x14dcd0 - 0x14dcf8

void entry_14dcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14dcd0) {
        switch (ctx->pc) {
            case 0x14dcd4: ctx->pc = 0; goto label_14dcd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14dcd0: 0xe6800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
label_14dcd4:
    // 0x14dcd4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14dcd8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14dcdc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14dce0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14dce4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14dce8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14dcec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14dcf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14dcf8; return;
}


// Function: junk_0014DCF8
// Address: 0x14dcf8 - 0x14dd00

void entry_14dd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dd4c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14dd50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14dd54: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x14dd5c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_14dd5c
// Address: 0x14dd5c - 0x14dd68

void entry_14dd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dd5c: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14dd60: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14dd68);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14dd68
// Address: 0x14dd68 - 0x14dd78

void entry_14dd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dd68: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x14dd6c: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x14dd70: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14dd78);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14dd78
// Address: 0x14dd78 - 0x14dd88

void entry_14dd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dd78: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x14dd7c: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x14dd80: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14dd88);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14dd88
// Address: 0x14dd88 - 0x14dda0

void entry_14dd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14dd88) {
        switch (ctx->pc) {
            case 0x14dd98: ctx->pc = 0; goto label_14dd98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14dd88: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x14dd8c: 0x18600012
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x14DDD8; return;
    }
    // 0x14dd94: 0x0
    // NOP
label_14dd98:
    // 0x14dd98: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x14dda0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_14dda0
// Address: 0x14dda0 - 0x14ddc8

void entry_14dda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dda0: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x14dda4: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x14dda8: 0x113100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 17), 4));
    // 0x14ddac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14ddb0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14ddb4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x14ddb8: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x14ddbc: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x14ddc0: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x14ddc8);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14ddc8
// Address: 0x14ddc8 - 0x14ddf0

void entry_14ddc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ddc8) {
        switch (ctx->pc) {
            case 0x14ddd8: ctx->pc = 0; goto label_14ddd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ddc8: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x14ddcc: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x14ddd0: 0x1440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14DD98; return;
    }
label_14ddd8:
    // 0x14ddd8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14dddc: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x14dde0: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14DDF4; return;
    }
    // 0x14dde8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ddf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ddf0
// Address: 0x14ddf0 - 0x14de08

void entry_14ddf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ddf0) {
        switch (ctx->pc) {
            case 0x14ddf4: ctx->pc = 0; goto label_14ddf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ddf0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14ddf4:
    // 0x14ddf4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ddf8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ddfc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14de00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateCrvlFromU__FP4CRVLfP6VECTORT2
// Address: 0x14de08 - 0x14de30

void entry_14de30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14de30: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14de34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14de3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14de40; return;
}


// Function: EvaluateCrvlFromS__FP4CRVLfP6VECTORT2
// Address: 0x14de40 - 0x14de68

void entry_14de68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14de68: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14de6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14de74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14de78; return;
}


// Function: RenderCrvlSegment__FP4CRVLiP7MATRIX4P2CMG4RGBAi
// Address: 0x14de78 - 0x14def8

void entry_14def8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14def8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x14defc: 0x122900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 18), 4));
    // 0x14df00: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14df04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14df08: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x14df0c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14df10: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x14df18);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_14df18
// Address: 0x14df18 - 0x14df40

void entry_14df18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14df18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14df1c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x14df20: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14df24: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14df28: 0x8aa20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x14df2c: 0x9aa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x14df30: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x14df34: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x14df38: 0xc0774f8
    SET_GPR_U32(ctx, 31, 0x14df40);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    DrawLineWorld__FP6VECTORT0G4RGBAP2CMi(rdram, ctx, runtime); return;
}


// Function: entry_14df40
// Address: 0x14df40 - 0x14df68

void entry_14df40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14df40: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14df44: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14df48: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14df4c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14df50: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14df54: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14df58: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14df5c: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x14df60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertCrvl__FP4CRVLP7MATRIX4T1
// Address: 0x14df68 - 0x14df88

void entry_14df88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14df88: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14df8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14df94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14df98; return;
}


// Function: SFromCrvlU__FP4CRVLf
// Address: 0x14df98 - 0x14dfb4

void entry_14dfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14dfb4: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14dfb8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14dfbc: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14dfc0: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14dfc4: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x14dfc8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14dfcc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14dfd0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14dfd4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14dfd8: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14dfdc: 0xc4430000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14dfe0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14dfe4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14dfe8: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14dfec: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14dff0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14dff4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14dffc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e000; return;
}


// Function: UFromCrvlS__FP4CRVLf
// Address: 0x14e000 - 0x14e01c

void entry_14e01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e01c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x14e020: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e024: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14e028: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x14e02c: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x14e030: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e034: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e038: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e03c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e040: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14e044: 0xc4430000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14e048: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e04c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e050: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14e054: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14e058: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e05c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e068; return;
}


// Function: MeasureCrvl__FP4CRVL
// Address: 0x14e068 - 0x14e084

void entry_14e084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e084: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14e088: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindCrvlClosestPointAll__FP4CRVLP6VECTORP6CONSTRT1T1PfT5
// Address: 0x14e090 - 0x14e0dc

void entry_14e0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e0dc) {
        switch (ctx->pc) {
            case 0x14e118: ctx->pc = 0; goto label_14e118;
            case 0x14e154: ctx->pc = 0; goto label_14e154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e0dc: 0x1220000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_14e118;
    }
    // 0x14e0e4: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x14e0e8: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14e0ec: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e0f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e0f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e0f8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e0fc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e100: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14e104: 0xc4430000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14e108: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14e10c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14e110: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e114: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_14e118:
    // 0x14e118: 0x1240000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_14e154;
    }
    // 0x14e120: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x14e124: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x14e128: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e12c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e130: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e134: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e138: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e13c: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x14e140: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x14e144: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14e148: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14e14c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e150: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_14e154:
    // 0x14e154: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e158: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e15c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e160: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e164: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e16c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e170; return;
}


// Function: FindCrvlClosestPointFromU__FP4CRVLP6VECTORfP6CONSTRT1T1PfT6
// Address: 0x14e170 - 0x14e1c8

void entry_14e1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e1c8: 0x27ab0014
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 20));
    // 0x14e1cc: 0x8e86000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x14e1d0: 0x8e870018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x14e1d4: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14e1d8: 0x8e890008
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x14e1dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14e1e0: 0xafab0008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 11));
    // 0x14e1e4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14e1e8: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14e1ec: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x14e1f0: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14e1f4: 0xc0535a0
    SET_GPR_U32(ctx, 31, 0x14e1fc);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime); return;
}


// Function: entry_14e1fc
// Address: 0x14e1fc - 0x14e2a0

void entry_14e1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e1fc) {
        switch (ctx->pc) {
            case 0x14e238: ctx->pc = 0; goto label_14e238;
            case 0x14e274: ctx->pc = 0; goto label_14e274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e1fc: 0x12a0000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_14e238;
    }
    // 0x14e204: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x14e208: 0x8e830014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x14e20c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e210: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e214: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e218: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e21c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e220: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14e224: 0xc4430000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14e228: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14e22c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14e230: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e234: 0xe6a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
label_14e238:
    // 0x14e238: 0x12c0000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_14e274;
    }
    // 0x14e240: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x14e244: 0x8e830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x14e248: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e24c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e250: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e254: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e258: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e25c: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x14e260: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x14e264: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14e268: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14e26c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e270: 0xe6c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 22), 0), *(uint32_t*)&val); }
label_14e274:
    // 0x14e274: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14e278: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14e27c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14e280: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14e284: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14e288: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e28c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e290: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e294: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e29c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e2a0; return;
}


// Function: FindCrvlClosestPointFromS__FP4CRVLP6VECTORfP6CONSTRT1T1PfT6
// Address: 0x14e2a0 - 0x14e2f8

void entry_14e2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e2f8: 0x27ab0014
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 20));
    // 0x14e2fc: 0x8e86000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x14e300: 0x8e870018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x14e304: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14e308: 0x8e890008
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x14e30c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14e310: 0xafab0008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 11));
    // 0x14e314: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14e318: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14e31c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x14e320: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14e324: 0xc0535a0
    SET_GPR_U32(ctx, 31, 0x14e32c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime); return;
}


// Function: entry_14e32c
// Address: 0x14e32c - 0x14e3d0

void entry_14e32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e32c) {
        switch (ctx->pc) {
            case 0x14e368: ctx->pc = 0; goto label_14e368;
            case 0x14e3a4: ctx->pc = 0; goto label_14e3a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e32c: 0x12a0000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_14e368;
    }
    // 0x14e334: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x14e338: 0x8e830014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x14e33c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e340: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e344: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e348: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e34c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e350: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14e354: 0xc4430000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[3] = *(float*)&val; }
    // 0x14e358: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x14e35c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14e360: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e364: 0xe6a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
label_14e368:
    // 0x14e368: 0x12c0000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_14e3a4;
    }
    // 0x14e370: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x14e374: 0x8e830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x14e378: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e37c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e380: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x14e384: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e388: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x14e38c: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x14e390: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x14e394: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x14e398: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x14e39c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e3a0: 0xe6c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 22), 0), *(uint32_t*)&val); }
label_14e3a4:
    // 0x14e3a4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14e3a8: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14e3ac: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14e3b0: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14e3b4: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14e3b8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e3bc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e3c0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e3c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e3cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e3d0; return;
}


// Function: LoadCrvcFromBrx__FP4CRVCP18CBinaryInputStream
// Address: 0x14e3d0 - 0x14e3fc

void entry_14e3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e3fc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14e400: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x14e408);
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_14e408
// Address: 0x14e408 - 0x14e414

void entry_14e408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e408: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x14e40c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14e414);
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14e414
// Address: 0x14e414 - 0x14e424

void entry_14e414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e414: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e418: 0xae220010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    // 0x14e41c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14e424);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14e424
// Address: 0x14e424 - 0x14e434

void entry_14e424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e424: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e428: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    // 0x14e42c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14e434);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14e434
// Address: 0x14e434 - 0x14e444

void entry_14e434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e434: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e438: 0xae220018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    // 0x14e43c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14e444);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14e444
// Address: 0x14e444 - 0x14e454

void entry_14e444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e444: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e448: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x14e44c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x14e454);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_14e454
// Address: 0x14e454 - 0x14e470

void entry_14e454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e454) {
        switch (ctx->pc) {
            case 0x14e468: ctx->pc = 0; goto label_14e468;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e454: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e458: 0x1860001a
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x14E4C4; return;
    }
    // 0x14e460: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14e464: 0x0
    // NOP
label_14e468:
    // 0x14e468: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x14e470);
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 18), 4));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_14e470
// Address: 0x14e470 - 0x14e494

void entry_14e470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e470: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x14e474: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x14e478: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14e47c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x14e480: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14e484: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x14e488: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x14e48c: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x14e494);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14e494
// Address: 0x14e494 - 0x14e4a4

void entry_14e494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e494: 0x8e25001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x14e498: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14e49c: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x14e4a4);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14e4a4
// Address: 0x14e4a4 - 0x14e4b4

void entry_14e4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e4a4: 0x8e250020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x14e4a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14e4ac: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x14e4b4);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14e4b4
// Address: 0x14e4b4 - 0x14e4dc

void entry_14e4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e4b4) {
        switch (ctx->pc) {
            case 0x14e4c4: ctx->pc = 0; goto label_14e4c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e4b4: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x14e4b8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x14e4bc: 0x1440ffea
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14E468; return;
    }
label_14e4c4:
    // 0x14e4c4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14e4c8: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x14e4cc: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14e4dc(rdram, ctx, runtime); return;
    }
    // 0x14e4d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14e4dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14e4dc
// Address: 0x14e4dc - 0x14e4e4

void entry_14e4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e4dc: 0xc053940
    SET_GPR_U32(ctx, 31, 0x14e4e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InvalidateCrvcCache__FP4CRVC(rdram, ctx, runtime); return;
}


// Function: entry_14e4e4
// Address: 0x14e4e4 - 0x14e500

void entry_14e4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e4e4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e4e8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e4ec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e4f0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e4f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14e4f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InvalidateCrvcCache__FP4CRVC
// Address: 0x14e500 - 0x14e510

void entry_14e588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e588: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14e58c: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x14e590: 0xc05342a
    SET_GPR_U32(ctx, 31, 0x14e598);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 368));
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_14e598
// Address: 0x14e598 - 0x14e5b8

void entry_14e598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e598) {
        switch (ctx->pc) {
            case 0x14e59c: ctx->pc = 0; goto label_14e59c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e598: 0xae3201c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 448), GPR_U32(ctx, 18));
label_14e59c:
    // 0x14e59c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e5a0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e5a4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e5a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14e5ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e5b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e5b8; return;
}


// Function: EvaluateCrvcFromU__FP4CRVCfP6VECTORT2
// Address: 0x14e5b8 - 0x14e5e4

void entry_14e5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e5e4: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x14e5e8: 0x8e07001c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x14e5ec: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x14e5f0: 0x24460010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 16));
    // 0x14e5f4: 0xe63821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x14e5f8: 0x8e050020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x14e5fc: 0x863021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x14e600: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x14e604: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    // 0x14e608: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x14e60c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e610: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x14e614: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14e618: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x14e61c: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14e620: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x14e628);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_14e628
// Address: 0x14e628 - 0x14e6a8

void entry_14e628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e628) {
        switch (ctx->pc) {
            case 0x14e680: ctx->pc = 0; goto label_14e680;
            case 0x14e68c: ctx->pc = 0; goto label_14e68c;
            case 0x14e690: ctx->pc = 0; goto label_14e690;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e628: 0x12400019
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_14e690;
    }
    // 0x14e630: 0xda430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14e634: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x14e638: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14e63c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14e640: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14e644: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14e648: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14e64c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14e650: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14e654: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14e658: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14e65c: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x14e660: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14e664: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14e668: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x14e66c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14e670: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14e680;
    }
    // 0x14e678: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14e68c;
    }
label_14e680:
    // 0x14e680: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14e684: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14e688: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14e68c:
    // 0x14e68c: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_14e690:
    // 0x14e690: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e694: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e698: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e69c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e6a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateCrvcFromS__FP4CRVCfP6VECTORT2
// Address: 0x14e6a8 - 0x14e6d4

void entry_14e6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e6d4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14e6d8: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x14e6dc: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14e6f4(rdram, ctx, runtime); return;
    }
    // 0x14e6e4: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x14e6e8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14e6ec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14e6f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14e6f4
// Address: 0x14e6f4 - 0x14e710

void entry_14e6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e6f4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e6f8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e6fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e700: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14e704: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e70c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e710; return;
}


// Function: RenderCrvcSegment__FP4CRVCiP7MATRIX4P2CMG4RGBAi
// Address: 0x14e710 - 0x14e81c

void entry_14e81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e81c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14e820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertCrvc__FP4CRVCP7MATRIX4T1
// Address: 0x14e828 - 0x14e854

void entry_14e854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e854) {
        switch (ctx->pc) {
            case 0x14e868: ctx->pc = 0; goto label_14e868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e854: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x14e858: 0x18400023
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14E8E8; return;
    }
    // 0x14e860: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x14e864: 0x0
    // NOP
label_14e868:
    // 0x14e868: 0x138100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 19), 4));
    // 0x14e86c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14e870: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14e874: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14e878: 0xb02821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    // 0x14e87c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x14e880: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x14e888);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_14e888
// Address: 0x14e888 - 0x14e8f0

void entry_14e888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14e888) {
        switch (ctx->pc) {
            case 0x14e8e8: ctx->pc = 0; goto label_14e8e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14e888: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x14e88c: 0xda240000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14e890: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x14e894: 0xda230010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x14e898: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14e89c: 0xda220020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x14e8a0: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14e8a4: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14e8a8: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14e8ac: 0xf8410000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14e8b0: 0x8e430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x14e8b4: 0xda240000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x14e8b8: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x14e8bc: 0xda230010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x14e8c0: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14e8c4: 0xda220020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x14e8c8: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x14e8cc: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14e8d0: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14e8d4: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14e8d8: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x14e8dc: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x14e8e0: 0x5440ffe1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
        ctx->pc = 0x14E868; return;
    }
label_14e8e8:
    // 0x14e8e8: 0xc053940
    SET_GPR_U32(ctx, 31, 0x14e8f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    InvalidateCrvcCache__FP4CRVC(rdram, ctx, runtime); return;
}


// Function: entry_14e8f0
// Address: 0x14e8f0 - 0x14e910

void entry_14e8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e8f0: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14e8f4: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14e8f8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14e8fc: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14e900: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14e904: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e90c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e910; return;
}


// Function: SFromCrvcU__FP4CRVCf
// Address: 0x14e910 - 0x14e930

void entry_14e930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e930: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14e934: 0x8e250020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x14e938: 0x102100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 4));
    // 0x14e93c: 0x8e27001c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x14e940: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x14e944: 0x24860010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 16));
    // 0x14e948: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x14e94c: 0xe63821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x14e950: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x14e954: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x14e958: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    // 0x14e95c: 0xc04c308
    SET_GPR_U32(ctx, 31, 0x14e964);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    SBezierPosLength__FffP6VECTORN32(rdram, ctx, runtime); return;
}


// Function: entry_14e964
// Address: 0x14e964 - 0x14e990

void entry_14e964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e964: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14e968: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x14e96c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14e970: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x14e974: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14e978: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14e97c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14e980: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14e984: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14e98c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14e990; return;
}


// Function: UFromCrvcS__FP4CRVCf
// Address: 0x14e990 - 0x14e9b0

void entry_14e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e9b0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14e9b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14e9b8: 0xc053944
    SET_GPR_U32(ctx, 31, 0x14e9c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FillCrvcCache__FP4CRVCi(rdram, ctx, runtime); return;
}


// Function: entry_14e9c0
// Address: 0x14e9c0 - 0x14e9dc

void entry_14e9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e9c0: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x14e9c4: 0x26250170
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 368));
    // 0x14e9c8: 0x24040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    // 0x14e9cc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14e9d0: 0x37a70004
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 29), 4));
    // 0x14e9d4: 0xc053468
    SET_GPR_U32(ctx, 31, 0x14e9dc);
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 29), 8));
    IposFindAposG__FfiPfiT2T2(rdram, ctx, runtime); return;
}


// Function: entry_14e9dc
// Address: 0x14e9dc - 0x14ea48

void entry_14e9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14e9dc: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x14e9e0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14e9e4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x14e9e8: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x14e9ec: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x14e9f0: 0x3c013d57
    SET_GPR_U32(ctx, 1, ((uint32_t)15703 << 16));
    // 0x14e9f4: 0x34219436
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 37942));
    // 0x14e9f8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x14e9fc: 0x46011083
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[1];
    // 0x14ea00: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x14ea04: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14ea08: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14ea0c: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x14ea10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ea14: 0xc6030004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[3] = *(float*)&val; }
    // 0x14ea18: 0xc6040000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[4] = *(float*)&val; }
    // 0x14ea1c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ea20: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x14ea24: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ea28: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x14ea2c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x14ea30: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x14ea34: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x14ea38: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14ea3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14ea44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ea48; return;
}


// Function: MeasureCrvc__FP4CRVC
// Address: 0x14ea48 - 0x14ead0

void entry_14ead0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ead0) {
        switch (ctx->pc) {
            case 0x14eaec: ctx->pc = 0; goto label_14eaec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ead0: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14ead4: 0x254182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 20)));
    // 0x14ead8: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x14eadc: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x14eae0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x14eae4: 0x1460ffe8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14EA88; return;
    }
label_14eaec:
    // 0x14eaec: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14eaf0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14eaf4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14eaf8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14eafc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14eb00: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14eb04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14eb0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14eb10; return;
}


// Function: FindCrvcClosestPointAll__FP4CRVCP6VECTORP6CONSTRT1T1PfT5
// Address: 0x14eb10 - 0x14ebac

void entry_14ebac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ebac) {
        switch (ctx->pc) {
            case 0x14ebc8: ctx->pc = 0; goto label_14ebc8;
            case 0x14ebf0: ctx->pc = 0; goto label_14ebf0;
            case 0x14ec10: ctx->pc = 0; goto label_14ec10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ebac: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ebb0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ebb4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14ebb8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ebbc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14ebc0: 0x1000000b
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14ebf0;
    }
label_14ebc8:
    // 0x14ebc8: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x14ebcc: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14ebd0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14ebd4: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14ebd8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ebdc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ebe0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14ebe4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14ebe8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14ebec: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
label_14ebf0:
    // 0x14ebf0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14ebf4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14ebf8: 0x0
    // NOP
    // 0x14ebfc: 0x4502ffdc
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        ctx->pc = 0x14EB70; return;
    }
    // 0x14ec04: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x14ec08: 0x1000ffd8
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14EB6C; return;
    }
label_14ec10:
    // 0x14ec10: 0x141080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 20), 2));
    // 0x14ec14: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ec18: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14ec1c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x14ec20: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14ec24: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x14ec28: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x14ec2c: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x14ec30: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x14ec34: 0xc053b1c
    SET_GPR_U32(ctx, 31, 0x14ec3c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6(rdram, ctx, runtime); return;
}


// Function: entry_14ec3c
// Address: 0x14ec3c - 0x14ec70

void entry_14ec3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ec3c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x14ec40: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14ec44: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14ec48: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14ec4c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14ec50: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14ec54: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ec58: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ec5c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ec60: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ec64: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x14ec68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6
// Address: 0x14ec70 - 0x14ed1c

void entry_14ed1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ed1c) {
        switch (ctx->pc) {
            case 0x14ed30: ctx->pc = 0; goto label_14ed30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ed1c: 0x56400004
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_14ed30;
    }
    // 0x14ed24: 0x12200009
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_14ed4c(rdram, ctx, runtime); return;
    }
    // 0x14ed2c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_14ed30:
    // 0x14ed30: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x14ed34: 0x10400005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14ed4c(rdram, ctx, runtime); return;
    }
    // 0x14ed3c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14ed40: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ed44: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ed4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ed4c
// Address: 0x14ed4c - 0x14ed70

void entry_14ed4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ed4c) {
        switch (ctx->pc) {
            case 0x14ed58: ctx->pc = 0; goto label_14ed58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ed4c: 0x12600002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_14ed58;
    }
    // 0x14ed54: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
label_14ed58:
    // 0x14ed58: 0x12800006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14ED74; return;
    }
    // 0x14ed60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ed64: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x14ed68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ed70);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ed70
// Address: 0x14ed70 - 0x14ed98

void entry_14ed70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ed70) {
        switch (ctx->pc) {
            case 0x14ed74: ctx->pc = 0; goto label_14ed74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ed70: 0xe6800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
label_14ed74:
    // 0x14ed74: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14ed78: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14ed7c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14ed80: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ed84: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ed88: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ed8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14ed94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ed98; return;
}


// Function: FindCrvcClosestPointFromS__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6
// Address: 0x14ed98 - 0x14ede4

void entry_14ede4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ede4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ede8: 0x8c42002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    // 0x14edec: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14ee14(rdram, ctx, runtime); return;
    }
    // 0x14edf4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x14edf8: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x14edfc: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x14ee00: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x14ee04: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x14ee08: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ee0c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ee14);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ee14
// Address: 0x14ee14 - 0x14ee40

void entry_14ee14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ee14: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14ee18: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14ee1c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14ee20: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14ee24: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14ee28: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ee2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ee30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ee34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14ee3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14ee40; return;
}


// Function: InitDart__FP4DART
// Address: 0x14ee40 - 0x14ee54

void entry_14ee54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ee54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ee58: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14ee60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14ee60
// Address: 0x14ee60 - 0x14ee70

void entry_14ee60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ee60: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ee64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ee68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnDartAdd__FP4DART
// Address: 0x14ee70 - 0x14ee84

void entry_14ee84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ee84: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14ee88: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ee8c: 0xc0549b4
    SET_GPR_U32(ctx, 31, 0x14ee94);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7288));
    FFindDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_14ee94
// Address: 0x14ee94 - 0x14eea8

void entry_14ee94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ee94: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14eea8(rdram, ctx, runtime); return;
    }
    // 0x14ee9c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14eea0: 0xc054980
    SET_GPR_U32(ctx, 31, 0x14eea8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7288));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_14eea8
// Address: 0x14eea8 - 0x14eebc

void entry_14eea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14eea8: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x14eeac: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x14EED4; return;
    }
    // 0x14eeb4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14eebc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 58));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14eebc
// Address: 0x14eebc - 0x14ef00

void entry_14eebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14eebc) {
        switch (ctx->pc) {
            case 0x14eed4: ctx->pc = 0; goto label_14eed4;
            case 0x14eeec: ctx->pc = 0; goto label_14eeec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14eebc: 0x10400005
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14eed4;
    }
    // 0x14eec4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x14eec8: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x14eecc: 0x10000007
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14eeec;
    }
label_14eed4:
    // 0x14eed4: 0x2403f7ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294965247));
    // 0x14eed8: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x14eedc: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x14eee0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x14eee4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x14eee8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_14eeec:
    // 0x14eeec: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x14eef0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14eef4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14eef8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveDart__FP4DART
// Address: 0x14ef00 - 0x14ef14

void entry_14ef14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ef14: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x14ef18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ef1c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x14ef24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7288));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_14ef24
// Address: 0x14ef24 - 0x14ef30

void entry_14ef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ef24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ef28: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14ef30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14ef30
// Address: 0x14ef30 - 0x14ef40

void entry_14ef30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ef30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ef34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14ef38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneDart__FP4DARTT0
// Address: 0x14ef40 - 0x14ef68

void entry_14ef68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ef68: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x14ef6c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x14ef70: 0xb2020573
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1395); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x14ef74: 0xb602056c
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1388); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x14ef78: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14ef7c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14ef80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadDartFromBrx__FP4DARTP18CBinaryInputStream
// Address: 0x14ef88 - 0x14ef9c

void entry_14ef9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ef9c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14efa0: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x14efa8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1420));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14efa8
// Address: 0x14efa8 - 0x14efb8

void entry_14efa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14efa8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14efac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14efb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleDartMessage__FP4DART5MSGIDPv
// Address: 0x14efb8 - 0x14efdc

void entry_14efdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14efdc: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x14efe0: 0x16020009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F008; return;
    }
    // 0x14efe8: 0x8e220578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1400)));
    // 0x14efec: 0x16420007
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F00C; return;
    }
    // 0x14eff4: 0xae200578
    WRITE32(ADD32(GPR_U32(ctx, 17), 1400), GPR_U32(ctx, 0));
    // 0x14eff8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14effc: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14f004);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14f004
// Address: 0x14f004 - 0x14f020

void entry_14f004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f004) {
        switch (ctx->pc) {
            case 0x14f008: ctx->pc = 0; goto label_14f008;
            case 0x14f00c: ctx->pc = 0; goto label_14f00c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f004: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14f008:
    // 0x14f008: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_14f00c:
    // 0x14f00c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14f010: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f014: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14f01c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14f020; return;
}


// Function: PostDartLoad__FP4DART
// Address: 0x14f020 - 0x14f034

void entry_14f034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f034: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x14f038: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f03c: 0x24c61cc8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 7368));
    // 0x14f040: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x14f048);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_14f048
// Address: 0x14f048 - 0x14f058

void entry_14f048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f048: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14f04c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f050: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateDart__FP4DARTf
// Address: 0x14f058 - 0x14f074

void entry_14f074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f074: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x14f078: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x14f07c: 0x1040001e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14f0f8(rdram, ctx, runtime); return;
    }
    // 0x14f084: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x14f088: 0x24429fe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942688));
    // 0x14f08c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x14f090: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x14f094: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x14f09c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f0a0: 0xc053c9c
    SET_GPR_U32(ctx, 31, 0x14f0a8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateDartAirborne__FP4DARTf(rdram, ctx, runtime); return;
}


// Function: entry_14f0a8
// Address: 0x14f0a8 - 0x14f0f8

void entry_14f0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f0a8) {
        switch (ctx->pc) {
            case 0x14f0f0: ctx->pc = 0; goto label_14f0f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f0a8: 0x10000014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F0FC; return;
    }
    // 0x14f0b0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14f0b4: 0xc6020554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1364)); ctx->f[2] = *(float*)&val; }
    // 0x14f0b8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x14f0bc: 0xc6010568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1384)); ctx->f[1] = *(float*)&val; }
    // 0x14f0c0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x14f0c4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14f0c8: 0x0
    // NOP
    // 0x14f0cc: 0x4500000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_14f0f8(rdram, ctx, runtime); return;
    }
    // 0x14f0d4: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x14f0d8: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14f0f0;
    }
    // 0x14f0e0: 0x8c4323b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9136)));
    // 0x14f0e4: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x14f0e8: 0x10430004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x14F0FC; return;
    }
label_14f0f0:
    // 0x14f0f0: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14f0f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14f0f8
// Address: 0x14f0f8 - 0x14f110

void entry_14f0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f0f8) {
        switch (ctx->pc) {
            case 0x14f0fc: ctx->pc = 0; goto label_14f0fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f0f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_14f0fc:
    // 0x14f0fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f100: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x14f104: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14f10c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14f110; return;
}


// Function: SetDartDarts__FP4DART5DARTS
// Address: 0x14f110 - 0x14f15c

void entry_14f15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f15c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f160: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyDartThrow__FP4DARTP2PO
// Address: 0x14f168 - 0x14f23c

void entry_14f23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f23c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f240: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14f248);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14f248
// Address: 0x14f248 - 0x14f25c

void entry_14f248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f248: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14f25c(rdram, ctx, runtime); return;
    }
    // 0x14f250: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x14f254: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x14f25c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_14f25c
// Address: 0x14f25c - 0x14f270

void entry_14f25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f25c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14f260: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14f264: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14f26c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14f270; return;
}


// Function: UpdateDartAirborne__FP4DARTf
// Address: 0x14f270 - 0x14f290

void entry_14f290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f290) {
        switch (ctx->pc) {
            case 0x14f2cc: ctx->pc = 0; goto label_14f2cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f290: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14f294: 0x120000c1
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F59C; return;
    }
    // 0x14f29c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14f2a0: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x14f2a4: 0x16020017
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F304; return;
    }
    // 0x14f2ac: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x14f2b0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x14f2b4: 0x14620005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_14f2cc;
    }
    // 0x14f2bc: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x14f2c0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x14f2c4: 0x50620010
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x14F308; return;
    }
label_14f2cc:
    // 0x14f2cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f2d0: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x14f2d8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14f2d8
// Address: 0x14f2d8 - 0x14f2fc

void entry_14f2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f2d8: 0x3c020015
    SET_GPR_U32(ctx, 2, ((uint32_t)21 << 16));
    // 0x14f2dc: 0x8e662e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x14f2e0: 0x2442f168
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963560));
    // 0x14f2e4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14f2e8: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x14f2ec: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x14f2f0: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14f2f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f2fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f2fc
// Address: 0x14f2fc - 0x14f310

void entry_14f2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f2fc) {
        switch (ctx->pc) {
            case 0x14f304: ctx->pc = 0; goto label_14f304;
            case 0x14f308: ctx->pc = 0; goto label_14f308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f2fc: 0x1000007b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
label_14f304:
    // 0x14f304: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_14f308:
    // 0x14f308: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14f310);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 58));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14f310
// Address: 0x14f310 - 0x14f354

void entry_14f310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f310: 0x10400052
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F45C; return;
    }
    // 0x14f318: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x14f31c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x14f320: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x14f324: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14f328: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f32c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x14f330: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14f334: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f338: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14f33c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x14f340: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f344: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x14f348: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f34c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x14f354);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_14f354
// Address: 0x14f354 - 0x14f380

void entry_14f354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f354: 0x8e632e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x14f358: 0x10600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_14f380(rdram, ctx, runtime); return;
    }
    // 0x14f360: 0x8c6223b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9136)));
    // 0x14f364: 0x14500006
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        entry_14f380(rdram, ctx, runtime); return;
    }
    // 0x14f36c: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x14f370: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14f374: 0x24842c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    // 0x14f378: 0xc05bb0e
    SET_GPR_U32(ctx, 31, 0x14f380);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    TriggerJoyRumbleRumk__FP3JOY4RUMKf(rdram, ctx, runtime); return;
}


// Function: entry_14f380
// Address: 0x14f380 - 0x14f388

void entry_14f380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f380: 0xc05a9d6
    SET_GPR_U32(ctx, 31, 0x14f388);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CdartStuckHbsk__FP4HBSK(rdram, ctx, runtime); return;
}


// Function: entry_14f388
// Address: 0x14f388 - 0x14f3a0

void entry_14f388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f388: 0x8e030564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x14f38c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x14f390: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x14F3B8; return;
    }
    // 0x14f398: 0xc05aa08
    SET_GPR_U32(ctx, 31, 0x14f3a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdartOldestHbskStuck__FP4HBSK(rdram, ctx, runtime); return;
}


// Function: entry_14f3a0
// Address: 0x14f3a0 - 0x14f3b4

void entry_14f3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f3a0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x14F3B8; return;
    }
    // 0x14f3a8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14f3ac: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14f3b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14f3b4
// Address: 0x14f3b4 - 0x14f3c8

void entry_14f3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f3b4) {
        switch (ctx->pc) {
            case 0x14f3b8: ctx->pc = 0; goto label_14f3b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f3b4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_14f3b8:
    // 0x14f3b8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f3bc: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x14f3c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f3c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f3c8
// Address: 0x14f3c8 - 0x14f3e4

void entry_14f3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f3c8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14f3cc: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x14f3d0: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x14f3d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f3d8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x14f3dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f3e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f3e4
// Address: 0x14f3e4 - 0x14f3f8

void entry_14f3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f3e4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14f3e8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f3ec: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x14f3f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f3f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f3f8
// Address: 0x14f3f8 - 0x14f410

void entry_14f3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f3f8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f3fc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x14f400: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f404: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x14f408: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x14f410);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_14f410
// Address: 0x14f410 - 0x14f41c

void entry_14f410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f410: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f414: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14f41c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14f41c
// Address: 0x14f41c - 0x14f440

void entry_14f41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f41c: 0x8e440574
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1396)));
    // 0x14f420: 0x1080000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_14f454(rdram, ctx, runtime); return;
    }
    // 0x14f428: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x14f42c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14f430: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14f434: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f438: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x14f440);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 1400));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_14f440
// Address: 0x14f440 - 0x14f454

void entry_14f440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f440: 0x8e420578
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1400)));
    // 0x14f444: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14f454(rdram, ctx, runtime); return;
    }
    // 0x14f44c: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14f454);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14f454
// Address: 0x14f454 - 0x14f468

void entry_14f454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f454) {
        switch (ctx->pc) {
            case 0x14f45c: ctx->pc = 0; goto label_14f45c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f454: 0x10000025
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
label_14f45c:
    // 0x14f45c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f460: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14f468);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 70));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14f468
// Address: 0x14f468 - 0x14f4a0

void entry_14f468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f468: 0x10400013
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F4B8; return;
    }
    // 0x14f470: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x14f474: 0x460001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_S32(ctx, 3) < 0) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
    // 0x14f47c: 0x1440001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
    // 0x14f484: 0x10400019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
    // 0x14f48c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14f490: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f494: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x14f498: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f4a0);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f4a0
// Address: 0x14f4a0 - 0x14f4b0

void entry_14f4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f4a0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14f4a4: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x14f4a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f4b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f4b0
// Address: 0x14f4b0 - 0x14f4c4

void entry_14f4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f4b0) {
        switch (ctx->pc) {
            case 0x14f4b8: ctx->pc = 0; goto label_14f4b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f4b0: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_14f4ec(rdram, ctx, runtime); return;
    }
label_14f4b8:
    // 0x14f4b8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f4bc: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x14f4c4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_14f4c4
// Address: 0x14f4c4 - 0x14f4ec

void entry_14f4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f4c4: 0x7a430140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x14f4c8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14f4cc: 0x7a420150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x14f4d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f4d4: 0xafb00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 16));
    // 0x14f4d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f4dc: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x14f4e0: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x14f4e4: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x14f4ec);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 18));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14f4ec
// Address: 0x14f4ec - 0x14f530

void entry_14f4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f4ec: 0x1220008d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_14f724(rdram, ctx, runtime); return;
    }
    // 0x14f4f4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x14f4f8: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x14f4fc: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x14f500: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x14f504: 0x24040033
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 51));
    // 0x14f508: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x14f50c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x14f510: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f514: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x14f518: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x14f51c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f520: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x14f524: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f528: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x14f530);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_14f530
// Address: 0x14f530 - 0x14f55c

void entry_14f530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f530: 0x8e46058c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 1420)));
    // 0x14f534: 0x10c0000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F564; return;
    }
    // 0x14f53c: 0x7a430140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x14f540: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x14f544: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x14f548: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x14f54c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x14f550: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x14f554: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14f55c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14f55c
// Address: 0x14f55c - 0x14f570

void entry_14f55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f55c) {
        switch (ctx->pc) {
            case 0x14f564: ctx->pc = 0; goto label_14f564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f55c: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F574; return;
    }
label_14f564:
    // 0x14f564: 0xc64c0560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1376)); ctx->f[12] = *(float*)&val; }
    // 0x14f568: 0xc0559b2
    SET_GPR_U32(ctx, 31, 0x14f570);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 320));
    StandardSmokeCloud__FP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_14f570
// Address: 0x14f570 - 0x14f584

void entry_14f570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f570) {
        switch (ctx->pc) {
            case 0x14f574: ctx->pc = 0; goto label_14f574;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f570: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_14f574:
    // 0x14f574: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f578: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x14f57c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f584);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f584
// Address: 0x14f584 - 0x14f594

void entry_14f584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f584: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14f588: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x14f58c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f594);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f594
// Address: 0x14f594 - 0x14f65c

void entry_14f594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f594) {
        switch (ctx->pc) {
            case 0x14f59c: ctx->pc = 0; goto label_14f59c;
            case 0x14f5c0: ctx->pc = 0; goto label_14f5c0;
            case 0x14f630: ctx->pc = 0; goto label_14f630;
            case 0x14f640: ctx->pc = 0; goto label_14f640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f594: 0x10000064
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F728; return;
    }
label_14f59c:
    // 0x14f59c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14f5a0: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x14f5a4: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1404)));
        goto label_14f5c0;
    }
    // 0x14f5ac: 0x8c432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8736)));
    // 0x14f5b0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x14f5b4: 0x1062005c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F728; return;
    }
    // 0x14f5bc: 0x8e43057c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1404)));
label_14f5c0:
    // 0x14f5c0: 0xc6410584
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1412)); ctx->f[1] = *(float*)&val; }
    // 0x14f5c4: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x14f5c8: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x14f5cc: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x14f5d0: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x14f5d4: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x14f5d8: 0xc6420558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1368)); ctx->f[2] = *(float*)&val; }
    // 0x14f5dc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14f5e0: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x14f5e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x14f5e8: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x14f5ec: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f5f0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f5f4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f5f8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14f5fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f600: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14f604: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f608: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14f60c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14f610: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14f614: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x14f618: 0x46020303
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[2];
    // 0x14f61c: 0x46036034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14f620: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14f630;
    }
    // 0x14f628: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14f640;
    }
label_14f630:
    // 0x14f630: 0x460c0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14f634: 0x0
    // NOP
    // 0x14f638: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[1]);
        goto label_14f640;
    }
label_14f640:
    // 0x14f640: 0x8e44057c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1404)));
    // 0x14f644: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f648: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x14f64c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f650: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14f654: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x14f65c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_14f65c
// Address: 0x14f65c - 0x14f700

void entry_14f65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f65c) {
        switch (ctx->pc) {
            case 0x14f6d4: ctx->pc = 0; goto label_14f6d4;
            case 0x14f6e0: ctx->pc = 0; goto label_14f6e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f65c: 0xc6410584
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1412)); ctx->f[1] = *(float*)&val; }
    // 0x14f660: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x14f664: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x14f668: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x14f66c: 0x8e430558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1368)));
    // 0x14f670: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x14f674: 0xda430140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x14f678: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x14f67c: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x14f680: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x14f684: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x14f688: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x14f68c: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x14f690: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x14f694: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f698: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f69c: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f6a0: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x14f6a4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14f6a8: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x14f6ac: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x14f6b0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14f6b4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x14f6b8: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x14f6bc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x14f6c0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14f6c4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_14f6d4;
    }
    // 0x14f6cc: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_14f6e0;
    }
label_14f6d4:
    // 0x14f6d4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x14f6d8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x14f6dc: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_14f6e0:
    // 0x14f6e0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14f6e4: 0x4be50858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x14f6e8: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x14f6ec: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x14f6f0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f6f4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x14f6f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f700);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f700
// Address: 0x14f700 - 0x14f710

void entry_14f700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f700: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x14f704: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f708: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x14f710);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_14f710
// Address: 0x14f710 - 0x14f724

void entry_14f710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f710: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14f714: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f718: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14f71c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f724);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f724
// Address: 0x14f724 - 0x14f740

void entry_14f724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f724) {
        switch (ctx->pc) {
            case 0x14f728: ctx->pc = 0; goto label_14f728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f724: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_14f728:
    // 0x14f728: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x14f72c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x14f730: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x14f734: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x14f738: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitDartgun__FP7DARTGUN
// Address: 0x14f740 - 0x14f754

void entry_14f754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f754: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x14f758: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14f75c: 0xae0206c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1728), GPR_U32(ctx, 2));
    // 0x14f760: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f764: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14f76c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14f770; return;
}


// Function: HandleDartgunMessage__FP7DARTGUN5MSGIDPv
// Address: 0x14f770 - 0x14f794

void entry_14f794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f794: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x14f798: 0x16020028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F83C; return;
    }
    // 0x14f7a0: 0x8e420740
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1856)));
    // 0x14f7a4: 0x56220026
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x14F840; return;
    }
    // 0x14f7ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14f7b0: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x14f7b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14f7b8
// Address: 0x14f7b8 - 0x14f7dc

void entry_14f7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f7b8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f7bc: 0x240202b7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 695));
    // 0x14f7c0: 0x1462001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14F83C; return;
    }
    // 0x14f7c8: 0x8e420680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1664)));
    // 0x14f7cc: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
        ctx->pc = 0x14F7E4; return;
    }
    // 0x14f7d4: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x14f7dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1856)));
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_14f7dc
// Address: 0x14f7dc - 0x14f810

void entry_14f7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f7dc) {
        switch (ctx->pc) {
            case 0x14f7e4: ctx->pc = 0; goto label_14f7e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f7dc: 0x10000016
    WRITE32(ADD32(GPR_U32(ctx, 18), 1856), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_14f838(rdram, ctx, runtime); return;
    }
label_14f7e4:
    // 0x14f7e4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14f7e8: 0x8c620200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 512)));
    // 0x14f7ec: 0xac44004c
    WRITE32(ADD32(GPR_U32(ctx, 2), 76), GPR_U32(ctx, 4));
    // 0x14f7f0: 0x8e430734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
    // 0x14f7f4: 0x8c620200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 512)));
    // 0x14f7f8: 0xac40001c
    WRITE32(ADD32(GPR_U32(ctx, 2), 28), GPR_U32(ctx, 0));
    // 0x14f7fc: 0x8e440734
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
    // 0x14f800: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14f804: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x14f808: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f810);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 400));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f810
// Address: 0x14f810 - 0x14f824

void entry_14f810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f810: 0x8e440734
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1844)));
    // 0x14f814: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14f818: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14f81c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f824);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 416));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f824
// Address: 0x14f824 - 0x14f838

void entry_14f824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f824: 0x8e440738
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1848)));
    // 0x14f828: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14f82c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14f830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f838);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 416));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f838
// Address: 0x14f838 - 0x14f850

void entry_14f838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f838) {
        switch (ctx->pc) {
            case 0x14f83c: ctx->pc = 0; goto label_14f83c;
            case 0x14f840: ctx->pc = 0; goto label_14f840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f838: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_14f83c:
    // 0x14f83c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14f840:
    // 0x14f840: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14f844: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14f848: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BindDartgun__FP7DARTGUN
// Address: 0x14f850 - 0x14f878

void entry_14f878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f878) {
        switch (ctx->pc) {
            case 0x14f888: ctx->pc = 0; goto label_14f888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f878: 0x8e220744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1860)));
    // 0x14f87c: 0x18400018
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 1900));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14F8E0; return;
    }
    // 0x14f884: 0x26320748
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1864));
label_14f888:
    // 0x14f888: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14f88c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14f890: 0xc056912
    SET_GPR_U32(ctx, 31, 0x14f898);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14f898
// Address: 0x14f898 - 0x14f8ac

void entry_14f898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f898: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14f89c: 0x1200000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F8CC; return;
    }
    // 0x14f8a4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x14f8ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_14f8ac
// Address: 0x14f8ac - 0x14f900

void entry_14f8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f8ac) {
        switch (ctx->pc) {
            case 0x14f8cc: ctx->pc = 0; goto label_14f8cc;
            case 0x14f8d0: ctx->pc = 0; goto label_14f8d0;
            case 0x14f8e0: ctx->pc = 0; goto label_14f8e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f8ac: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1860)));
        goto label_14f8d0;
    }
    // 0x14f8b4: 0x8e230768
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1896)));
    // 0x14f8b8: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x14f8bc: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x14f8c0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x14f8c4: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x14f8c8: 0xae230768
    WRITE32(ADD32(GPR_U32(ctx, 17), 1896), GPR_U32(ctx, 3));
label_14f8cc:
    // 0x14f8cc: 0x8e220744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1860)));
label_14f8d0:
    // 0x14f8d0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x14f8d4: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x14f8d8: 0x1440ffeb
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14F888; return;
    }
label_14f8e0:
    // 0x14f8e0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x14f8e4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14f8e8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14f8ec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14f8f0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14f8f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14f8f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0014f900
// Address: 0x14f900 - 0x14f920

void FUN_0014f900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f900) {
        switch (ctx->pc) {
            case 0x14f918: ctx->pc = 0; goto label_14f918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f900: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14f904: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x14f908: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14f918;
    }
    // 0x14f910: 0x8c4224f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 9464)));
    // 0x14f914: 0xac8206dc
    WRITE32(ADD32(GPR_U32(ctx, 4), 1756), GPR_U32(ctx, 2));
label_14f918:
    // 0x14f918: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostDartgunLoad__FP7DARTGUN
// Address: 0x14f920 - 0x14f944

void entry_14f944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f944: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x14f948: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14f94c: 0x24c61ce0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 7392));
    // 0x14f950: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x14f958);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_14f958
// Address: 0x14f958 - 0x14f978

void entry_14f958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f958: 0x8e230734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1844)));
    // 0x14f95c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14f960: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14f964: 0x8c620200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 512)));
    // 0x14f968: 0xac44004c
    WRITE32(ADD32(GPR_U32(ctx, 2), 76), GPR_U32(ctx, 4));
    // 0x14f96c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14f970: 0xc056920
    SET_GPR_U32(ctx, 31, 0x14f978);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1728)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14f978
// Address: 0x14f978 - 0x14f9c4

void entry_14f978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f978) {
        switch (ctx->pc) {
            case 0x14f9b8: ctx->pc = 0; goto label_14f9b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f978: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14f97c: 0x8e2406c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1732)));
    // 0x14f980: 0x7a430190
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 400)));
    // 0x14f984: 0x264202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 4)));
    // 0x14f988: 0x7e2306f0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1776), GPR_VEC(ctx, 3));
    // 0x14f98c: 0x7a4201a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 416)));
    // 0x14f990: 0x7e220700
    WRITE128(ADD32(GPR_U32(ctx, 17), 1792), GPR_VEC(ctx, 2));
    // 0x14f994: 0x7a4301b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 432)));
    // 0x14f998: 0x7e230710
    WRITE128(ADD32(GPR_U32(ctx, 17), 1808), GPR_VEC(ctx, 3));
    // 0x14f99c: 0x7a4201c0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 448)));
    // 0x14f9a0: 0x7e220720
    WRITE128(ADD32(GPR_U32(ctx, 17), 1824), GPR_VEC(ctx, 2));
    // 0x14f9a4: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x14f9a8: 0x1080001a
    WRITE32(ADD32(GPR_U32(ctx, 17), 1840), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FA14; return;
    }
    // 0x14f9b0: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x14f9b4: 0x0
    // NOP
label_14f9b8:
    // 0x14f9b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x14f9bc: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x14f9c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_14f9c4
// Address: 0x14f9c4 - 0x14f9e0

void entry_14f9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f9c4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x14f9c8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14f9cc: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x14f9d0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x14F9E4; return;
    }
    // 0x14f9d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f9e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f9e0
// Address: 0x14f9e0 - 0x14f9f4

void entry_14f9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14f9e0) {
        switch (ctx->pc) {
            case 0x14f9e4: ctx->pc = 0; goto label_14f9e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14f9e0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_14f9e4:
    // 0x14f9e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14f9e8: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x14f9ec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14f9f4);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14f9f4
// Address: 0x14f9f4 - 0x14fa04

void entry_14f9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14f9f4: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14f9f8: 0x8ca3001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 28)));
    // 0x14f9fc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14fa04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14fa04
// Address: 0x14fa04 - 0x14fa28

void entry_14fa04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fa04) {
        switch (ctx->pc) {
            case 0x14fa14: ctx->pc = 0; goto label_14fa14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fa04: 0x8e2206c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1732)));
    // 0x14fa08: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x14fa0c: 0x5440ffea
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x14F9B8; return;
    }
label_14fa14:
    // 0x14fa14: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14fa18: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14fa1c: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x14fa20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14fa28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14fa28
// Address: 0x14fa28 - 0x14fa38

void entry_14fa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fa28: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x14fa2c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x14fa30: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14fa38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14fa38
// Address: 0x14fa38 - 0x14fa54

void entry_14fa38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fa38: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x14fa3c: 0x3c050015
    SET_GPR_U32(ctx, 5, ((uint32_t)21 << 16));
    // 0x14fa40: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14fa44: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14fa48: 0x24a5f900
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294965504));
    // 0x14fa4c: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x14fa54);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_14fa54
// Address: 0x14fa54 - 0x14fa68

void entry_14fa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fa54: 0x8e24073c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1852)));
    // 0x14fa58: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14fa5c: 0x240602b7
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 695));
    // 0x14fa60: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x14fa68);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_14fa68
// Address: 0x14fa68 - 0x14fa88

void entry_14fa68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fa68: 0xae220740
    WRITE32(ADD32(GPR_U32(ctx, 17), 1856), GPR_U32(ctx, 2));
    // 0x14fa6c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x14fa70: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14fa74: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14fa78: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fa7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fa80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateDartgun__FP7DARTGUNf
// Address: 0x14fa88 - 0x14faa0

void entry_14faa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14faa0: 0x8e220680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
    // 0x14faa4: 0x1440004a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBD0; return;
    }
    // 0x14faac: 0x8e2206dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1756)));
    // 0x14fab0: 0x50400048
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x14FBD4; return;
    }
    // 0x14fab8: 0x8e240740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1856)));
    // 0x14fabc: 0x50800045
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x14FBD4; return;
    }
    // 0x14fac4: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14facc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14facc
// Address: 0x14facc - 0x14fadc

void entry_14facc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14facc: 0x27b00004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 4));
    // 0x14fad0: 0x8e240740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1856)));
    // 0x14fad4: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x14fadc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fadc
// Address: 0x14fadc - 0x14fb8c

void entry_14fadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fadc) {
        switch (ctx->pc) {
            case 0x14faf4: ctx->pc = 0; goto label_14faf4;
            case 0x14fb84: ctx->pc = 0; goto label_14fb84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fadc: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x14fae0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x14fae4: 0x14620003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_14faf4;
    }
    // 0x14faec: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14faf0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
label_14faf4:
    // 0x14faf4: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14faf8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x14fafc: 0x14620034
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14FBD0; return;
    }
    // 0x14fb04: 0x2463fd49
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294966601));
    // 0x14fb08: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x14fb0c: 0x10400029
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB4; return;
    }
    // 0x14fb14: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x14fb18: 0x2442a000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942720));
    // 0x14fb1c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x14fb20: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x14fb24: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x14fb2c: 0x8e2207b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1968)));
    // 0x14fb30: 0x1440001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 696));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB0; return;
    }
    // 0x14fb38: 0x8e22078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1932)));
    // 0x14fb3c: 0x1840001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 697));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14FBB4; return;
    }
    // 0x14fb44: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB4; return;
    }
    // 0x14fb4c: 0x8e2207b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1968)));
    // 0x14fb50: 0x1440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14fb84;
    }
    // 0x14fb58: 0x8e22078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1932)));
    // 0x14fb5c: 0x1c400014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 697));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x14FBB0; return;
    }
    // 0x14fb64: 0x10000012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 695));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB0; return;
    }
    // 0x14fb6c: 0x8e2207b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1968)));
    // 0x14fb70: 0x1440000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 696));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB0; return;
    }
    // 0x14fb78: 0x8e22078c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1932)));
    // 0x14fb7c: 0x1840000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 695));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x14FBB0; return;
    }
label_14fb84:
    // 0x14fb84: 0xc053f6a
    SET_GPR_U32(ctx, 31, 0x14fb8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    TrackDartgun__FP7DARTGUNP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fb8c
// Address: 0x14fb8c - 0x14fb9c

void entry_14fb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fb8c: 0x1000000a
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB8; return;
    }
    // 0x14fb94: 0xc054002
    SET_GPR_U32(ctx, 31, 0x14fb9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FireDartgun__FP7DARTGUN(rdram, ctx, runtime); return;
}


// Function: entry_14fb9c
// Address: 0x14fb9c - 0x14fbac

void entry_14fb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fb9c: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 696));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FBB0; return;
    }
    // 0x14fba4: 0xc054002
    SET_GPR_U32(ctx, 31, 0x14fbac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FireDartgun__FP7DARTGUN(rdram, ctx, runtime); return;
}


// Function: entry_14fbac
// Address: 0x14fbac - 0x14fbcc

void entry_14fbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fbac) {
        switch (ctx->pc) {
            case 0x14fbb0: ctx->pc = 0; goto label_14fbb0;
            case 0x14fbb4: ctx->pc = 0; goto label_14fbb4;
            case 0x14fbb8: ctx->pc = 0; goto label_14fbb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fbac: 0x240202b9
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 697));
label_14fbb0:
    // 0x14fbb0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
label_14fbb4:
    // 0x14fbb4: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_14fbb8:
    // 0x14fbb8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fbbc: 0x10a20004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x14FBD0; return;
    }
    // 0x14fbc4: 0xc053f3a
    SET_GPR_U32(ctx, 31, 0x14fbcc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetDartgunGoalState__FP7DARTGUN3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fbcc
// Address: 0x14fbcc - 0x14fbe0

void entry_14fbcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fbcc) {
        switch (ctx->pc) {
            case 0x14fbd0: ctx->pc = 0; goto label_14fbd0;
            case 0x14fbd4: ctx->pc = 0; goto label_14fbd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fbcc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_14fbd0:
    // 0x14fbd0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_14fbd4:
    // 0x14fbd4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fbd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreDartgunIntersection__FP7DARTGUNP2SO
// Address: 0x14fbe0 - 0x14fc04

void entry_14fc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fc04) {
        switch (ctx->pc) {
            case 0x14fc18: ctx->pc = 0; goto label_14fc18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fc04: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14fc18;
    }
    // 0x14fc0c: 0x8e020588
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1416)));
    // 0x14fc10: 0x10510003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        entry_14fc20(rdram, ctx, runtime); return;
    }
label_14fc18:
    // 0x14fc18: 0xc06e282
    SET_GPR_U32(ctx, 31, 0x14fc20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIgnoreSoIntersection__FP2SOT0(rdram, ctx, runtime); return;
}


// Function: entry_14fc20
// Address: 0x14fc20 - 0x14fc38

void entry_14fc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fc20: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14fc24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fc28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fc2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14fc34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14fc38; return;
}


// Function: BreakDartgun__FP7DARTGUN
// Address: 0x14fc38 - 0x14fc64

void entry_14fc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fc64: 0x8e0406c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
    // 0x14fc68: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14fc6c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x14fc70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14fc78);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14fc78
// Address: 0x14fc78 - 0x14fc8c

void entry_14fc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fc78) {
        switch (ctx->pc) {
            case 0x14fc7c: ctx->pc = 0; goto label_14fc7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fc78: 0x8e040740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
label_14fc7c:
    // 0x14fc7c: 0x5080000e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
        ctx->pc = 0x14FCB8; return;
    }
    // 0x14fc84: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x14fc8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 695));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fc8c
// Address: 0x14fc8c - 0x14fc98

void entry_14fc8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fc8c: 0x8e040740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
    // 0x14fc90: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14fc98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fc98
// Address: 0x14fc98 - 0x14fcb0

void entry_14fc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fc98: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fc9c: 0x240202b7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 695));
    // 0x14fca0: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
        ctx->pc = 0x14FCB8; return;
    }
    // 0x14fca8: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x14fcb0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_14fcb0
// Address: 0x14fcb0 - 0x14fccc

void entry_14fcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fcb0) {
        switch (ctx->pc) {
            case 0x14fcb8: ctx->pc = 0; goto label_14fcb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fcb0: 0xae000740
    WRITE32(ADD32(GPR_U32(ctx, 16), 1856), GPR_U32(ctx, 0));
    // 0x14fcb4: 0x8e020734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
label_14fcb8:
    // 0x14fcb8: 0x8c440200
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 512)));
    // 0x14fcbc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x14fcc0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x14fcc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14fccc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14fccc
// Address: 0x14fccc - 0x14fcd4

void entry_14fccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fccc: 0xc04f49e
    SET_GPR_U32(ctx, 31, 0x14fcd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BreakBrk__FP3BRK(rdram, ctx, runtime); return;
}


// Function: entry_14fcd4
// Address: 0x14fcd4 - 0x14fce8

void entry_14fcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fcd4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14fcd8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fcdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14fce4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14fce8; return;
}


// Function: SetDartgunGoalState__FP7DARTGUN3OID
// Address: 0x14fce8 - 0x14fd0c

void entry_14fd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fd0c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fd10: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x14fd14: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x14FD2C; return;
    }
    // 0x14fd1c: 0x8e040740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
    // 0x14fd20: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x14fd28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fd28
// Address: 0x14fd28 - 0x14fd90

void entry_14fd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fd28) {
        switch (ctx->pc) {
            case 0x14fd2c: ctx->pc = 0; goto label_14fd2c;
            case 0x14fd4c: ctx->pc = 0; goto label_14fd4c;
            case 0x14fd84: ctx->pc = 0; goto label_14fd84;
            case 0x14fd88: ctx->pc = 0; goto label_14fd88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fd28: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_14fd2c:
    // 0x14fd2c: 0x12230018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 695));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        entry_14fd90(rdram, ctx, runtime); return;
    }
    // 0x14fd34: 0x14620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 698));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_14fd4c;
    }
    // 0x14fd3c: 0x8e020734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
    // 0x14fd40: 0x8c430200
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 512)));
    // 0x14fd44: 0xac60004c
    WRITE32(ADD32(GPR_U32(ctx, 3), 76), GPR_U32(ctx, 0));
    // 0x14fd48: 0x2a2202ba
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 698));
label_14fd4c:
    // 0x14fd4c: 0x1040000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 696));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14fd84;
    }
    // 0x14fd54: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
        goto label_14fd88;
    }
    // 0x14fd5c: 0x8e020734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
    // 0x14fd60: 0x3a2302b9
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 17), 697));
    // 0x14fd64: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x14fd68: 0x8c440200
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 512)));
    // 0x14fd6c: 0xac83001c
    WRITE32(ADD32(GPR_U32(ctx, 4), 28), GPR_U32(ctx, 3));
    // 0x14fd70: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fd74: 0x2442fd46
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966598));
    // 0x14fd78: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x14fd7c: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1752), GPR_U32(ctx, 0));
        goto label_14fd84;
    }
label_14fd84:
    // 0x14fd84: 0x8e040740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1856)));
label_14fd88:
    // 0x14fd88: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x14fd90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_14fd90
// Address: 0x14fd90 - 0x14fda8

void entry_14fd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fd90: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14fd94: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14fd98: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fd9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14fda4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14fda8; return;
}


// Function: TrackDartgun__FP7DARTGUNP3OID
// Address: 0x14fda8 - 0x14fe04

void entry_14fe04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fe04) {
        switch (ctx->pc) {
            case 0x14fe14: ctx->pc = 0; goto label_14fe14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fe04: 0x10400028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 698));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FEA8; return;
    }
    // 0x14fe0c: 0x10000026
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FEA8; return;
    }
label_14fe14:
    // 0x14fe14: 0x8e0406e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1760)));
    // 0x14fe18: 0x1080000b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FE48; return;
    }
    // 0x14fe20: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x14fe28);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_14fe28
// Address: 0x14fe28 - 0x14fe50

void entry_14fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fe28) {
        switch (ctx->pc) {
            case 0x14fe48: ctx->pc = 0; goto label_14fe48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fe28: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14fe48;
    }
    // 0x14fe30: 0x8e0206e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1760)));
    // 0x14fe34: 0x8c440550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1360)));
    // 0x14fe38: 0x10830003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_14fe48;
    }
    // 0x14fe40: 0x54820005
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1760)));
        ctx->pc = 0x14FE58; return;
    }
label_14fe48:
    // 0x14fe48: 0xc0540ce
    SET_GPR_U32(ctx, 31, 0x14fe50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PratGetDartgunRatTarget__FP7DARTGUN(rdram, ctx, runtime); return;
}


// Function: entry_14fe50
// Address: 0x14fe50 - 0x14fe70

void entry_14fe50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fe50) {
        switch (ctx->pc) {
            case 0x14fe58: ctx->pc = 0; goto label_14fe58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fe50: 0xae0206e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1760), GPR_U32(ctx, 2));
    // 0x14fe54: 0x8e0506e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1760)));
label_14fe58:
    // 0x14fe58: 0x10a00013
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FEA8; return;
    }
    // 0x14fe60: 0x8e020734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1844)));
    // 0x14fe64: 0x24c68d30
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937904));
    // 0x14fe68: 0xc0614fc
    SET_GPR_U32(ctx, 31, 0x14fe70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 512)));
    SetActlaTarget__FP5ACTLAP3ALOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_14fe70
// Address: 0x14fe70 - 0x14fe9c

void entry_14fe70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14fe70: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x14fe74: 0xc60206d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1752)); ctx->f[2] = *(float*)&val; }
    // 0x14fe78: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x14fe7c: 0xc60106d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1744)); ctx->f[1] = *(float*)&val; }
    // 0x14fe80: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x14fe84: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x14fe88: 0x0
    // NOP
    // 0x14fe8c: 0x45000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x14FEAC; return;
    }
    // 0x14fe94: 0xc053fb0
    SET_GPR_U32(ctx, 31, 0x14fe9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FPrepareDartgunToFire__FP7DARTGUN(rdram, ctx, runtime); return;
}


// Function: entry_14fe9c
// Address: 0x14fe9c - 0x14fec0

void entry_14fe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14fe9c) {
        switch (ctx->pc) {
            case 0x14fea8: ctx->pc = 0; goto label_14fea8;
            case 0x14feac: ctx->pc = 0; goto label_14feac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14fe9c: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 699));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_14fea8;
    }
    // 0x14fea4: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_14fea8:
    // 0x14fea8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_14feac:
    // 0x14feac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14feb0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14feb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x14febc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x14fec0; return;
}


// Function: FPrepareDartgunToFire__FP7DARTGUN
// Address: 0x14fec0 - 0x14ff0c

void entry_14ff0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ff0c) {
        switch (ctx->pc) {
            case 0x14ff20: ctx->pc = 0; goto label_14ff20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ff0c: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_14ff20;
    }
    // 0x14ff14: 0x8e4206cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1740)));
    // 0x14ff18: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x14FF30; return;
    }
label_14ff20:
    // 0x14ff20: 0xc0540a6
    SET_GPR_U32(ctx, 31, 0x14ff28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AgeDartgunStuckDart__FP7DARTGUN(rdram, ctx, runtime); return;
}


// Function: entry_14ff28
// Address: 0x14ff28 - 0x14ff48

void entry_14ff28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ff28) {
        switch (ctx->pc) {
            case 0x14ff30: ctx->pc = 0; goto label_14ff30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ff28: 0x10000030
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x14FFEC; return;
    }
label_14ff30:
    // 0x14ff30: 0x8c501c78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 7288)));
    // 0x14ff34: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ff38: 0xae120588
    WRITE32(ADD32(GPR_U32(ctx, 16), 1416), GPR_U32(ctx, 18));
    // 0x14ff3c: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x14ff40: 0x60f809
    SET_GPR_U32(ctx, 31, 0x14ff48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_14ff48
// Address: 0x14ff48 - 0x14ff5c

void entry_14ff48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ff48: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ff4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ff50: 0x8cc20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 100)));
    // 0x14ff54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ff5c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1840)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ff5c
// Address: 0x14ff5c - 0x14ff74

void entry_14ff5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ff5c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ff60: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x14ff64: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x14ff68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ff6c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x14ff74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_14ff74
// Address: 0x14ff74 - 0x14ff88

void entry_14ff74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ff74: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ff78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ff7c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x14ff80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ff88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1776));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ff88
// Address: 0x14ff88 - 0x14ff9c

void entry_14ff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ff88: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ff8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ff90: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x14ff94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ff9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1792));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ff9c
// Address: 0x14ff9c - 0x14ffb8

void entry_14ff9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ff9c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ffa0: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    // 0x14ffa4: 0x26318d30
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294937904));
    // 0x14ffa8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ffac: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x14ffb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ffb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ffb8
// Address: 0x14ffb8 - 0x14ffcc

void entry_14ffb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ffb8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x14ffbc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x14ffc0: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x14ffc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x14ffcc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_14ffcc
// Address: 0x14ffcc - 0x14ffd8

void entry_14ffcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x14ffcc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x14ffd0: 0xc053c44
    SET_GPR_U32(ctx, 31, 0x14ffd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime); return;
}


// Function: entry_14ffd8
// Address: 0x14ffd8 - 0x150008

void entry_14ffd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x14ffd8) {
        switch (ctx->pc) {
            case 0x14ffec: ctx->pc = 0; goto label_14ffec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x14ffd8: 0xae5006c8
    WRITE32(ADD32(GPR_U32(ctx, 18), 1736), GPR_U32(ctx, 16));
    // 0x14ffdc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x14ffe0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x14ffe4: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x14ffe8: 0xe64006d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1752), *(uint32_t*)&val); }
label_14ffec:
    // 0x14ffec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x14fff0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x14fff4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x14fff8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x14fffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x150004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x150008; return;
}


// Function: FireDartgun__FP7DARTGUN
// Address: 0x150008 - 0x15004c

void entry_140008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140008 inside entry_140004 (0x140004 - 0x140028)
    ctx->pc = 0x140008;
    entry_140004(rdram, ctx, runtime);
}

void entry_140090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140090 inside entry_14008c (0x14008c - 0x1400a8)
    ctx->pc = 0x140090;
    entry_14008c(rdram, ctx, runtime);
}

void entry_140130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140130 inside entry_140120 (0x140120 - 0x140140)
    ctx->pc = 0x140130;
    entry_140120(rdram, ctx, runtime);
}

void entry_140188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140188 inside entry_140178 (0x140178 - 0x140198)
    ctx->pc = 0x140188;
    entry_140178(rdram, ctx, runtime);
}

void entry_1401c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1401c0 inside entry_140198 (0x140198 - 0x140200)
    ctx->pc = 0x1401c0;
    entry_140198(rdram, ctx, runtime);
}

void entry_1401d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1401d4 inside entry_140198 (0x140198 - 0x140200)
    ctx->pc = 0x1401d4;
    entry_140198(rdram, ctx, runtime);
}

void entry_1401e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1401e4 inside entry_140198 (0x140198 - 0x140200)
    ctx->pc = 0x1401e4;
    entry_140198(rdram, ctx, runtime);
}

void entry_1402ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1402ac inside entry_140284 (0x140284 - 0x1402f4)
    ctx->pc = 0x1402ac;
    entry_140284(rdram, ctx, runtime);
}

void entry_1402fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1402fc inside entry_1402f4 (0x1402f4 - 0x140304)
    ctx->pc = 0x1402fc;
    entry_1402f4(rdram, ctx, runtime);
}

void entry_14030c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14030c inside entry_140304 (0x140304 - 0x140320)
    ctx->pc = 0x14030c;
    entry_140304(rdram, ctx, runtime);
}

void entry_140338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140338 inside entry_140320 (0x140320 - 0x140388)
    ctx->pc = 0x140338;
    entry_140320(rdram, ctx, runtime);
}

void entry_14033c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14033c inside entry_140320 (0x140320 - 0x140388)
    ctx->pc = 0x14033c;
    entry_140320(rdram, ctx, runtime);
}

void entry_140358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140358 inside entry_140320 (0x140320 - 0x140388)
    ctx->pc = 0x140358;
    entry_140320(rdram, ctx, runtime);
}

void entry_140380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140380 inside entry_140320 (0x140320 - 0x140388)
    ctx->pc = 0x140380;
    entry_140320(rdram, ctx, runtime);
}

void entry_14039c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14039c inside entry_140388 (0x140388 - 0x1403a4)
    ctx->pc = 0x14039c;
    entry_140388(rdram, ctx, runtime);
}

void entry_1403bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1403bc inside entry_1403b4 (0x1403b4 - 0x1403c4)
    ctx->pc = 0x1403bc;
    entry_1403b4(rdram, ctx, runtime);
}

void entry_1403d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1403d8 inside entry_1403d4 (0x1403d4 - 0x140444)
    ctx->pc = 0x1403d8;
    entry_1403d4(rdram, ctx, runtime);
}

void entry_140430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140430 inside entry_1403d4 (0x1403d4 - 0x140444)
    ctx->pc = 0x140430;
    entry_1403d4(rdram, ctx, runtime);
}

void entry_14044c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14044c inside entry_140444 (0x140444 - 0x140468)
    ctx->pc = 0x14044c;
    entry_140444(rdram, ctx, runtime);
}

void entry_140480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140480 inside entry_140468 (0x140468 - 0x140508)
    ctx->pc = 0x140480;
    entry_140468(rdram, ctx, runtime);
}

void entry_140490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140490 inside entry_140468 (0x140468 - 0x140508)
    ctx->pc = 0x140490;
    entry_140468(rdram, ctx, runtime);
}

void entry_1404c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1404c8 inside entry_140468 (0x140468 - 0x140508)
    ctx->pc = 0x1404c8;
    entry_140468(rdram, ctx, runtime);
}

void entry_1404ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1404ec inside entry_140468 (0x140468 - 0x140508)
    ctx->pc = 0x1404ec;
    entry_140468(rdram, ctx, runtime);
}

void entry_1404f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1404f0 inside entry_140468 (0x140468 - 0x140508)
    ctx->pc = 0x1404f0;
    entry_140468(rdram, ctx, runtime);
}

void entry_140520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140520 inside entry_14051c (0x14051c - 0x140528)
    ctx->pc = 0x140520;
    entry_14051c(rdram, ctx, runtime);
}

void entry_14052c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14052c inside entry_140528 (0x140528 - 0x140550)
    ctx->pc = 0x14052c;
    entry_140528(rdram, ctx, runtime);
}

void entry_140530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140530 inside entry_140528 (0x140528 - 0x140550)
    ctx->pc = 0x140530;
    entry_140528(rdram, ctx, runtime);
}

void entry_140580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140580 inside FGetVolbtnPushObjectsWithinList__FP6VOLBTNPv (0x140550 - 0x14058c)
    ctx->pc = 0x140580;
    FGetVolbtnPushObjectsWithinList__FP6VOLBTNPv(rdram, ctx, runtime);
}

void entry_14059c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14059c inside entry_14058c (0x14058c - 0x1405d0)
    ctx->pc = 0x14059c;
    entry_14058c(rdram, ctx, runtime);
}

void entry_1405ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1405ac inside entry_14058c (0x14058c - 0x1405d0)
    ctx->pc = 0x1405ac;
    entry_14058c(rdram, ctx, runtime);
}

void entry_1405b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1405b0 inside entry_14058c (0x14058c - 0x1405d0)
    ctx->pc = 0x1405b0;
    entry_14058c(rdram, ctx, runtime);
}

void entry_140800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140800 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140800;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140848 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140848;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_14086c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14086c inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x14086c;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_14087c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14087c inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x14087c;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_14089c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14089c inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x14089c;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_1408c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1408c0 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x1408c0;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140900 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140900;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140930 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140930;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140938 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140938;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_14093c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14093c inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x14093c;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140948 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140948;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140958 inside entry_1407fc (0x1407fc - 0x140968)
    ctx->pc = 0x140958;
    entry_1407fc(rdram, ctx, runtime);
}

void entry_140994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140994 inside entry_140978 (0x140978 - 0x1409a8)
    ctx->pc = 0x140994;
    entry_140978(rdram, ctx, runtime);
}

void entry_140a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140a24 inside UpdateCd__Fv (0x1409e0 - 0x140a3c)
    ctx->pc = 0x140a24;
    UpdateCd__Fv(rdram, ctx, runtime);
}

void entry_140a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140a78 inside entry_140a70 (0x140a70 - 0x140a90)
    ctx->pc = 0x140a78;
    entry_140a70(rdram, ctx, runtime);
}

void entry_140ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140ac4 inside entry_140ab4 (0x140ab4 - 0x140acc)
    ctx->pc = 0x140ac4;
    entry_140ab4(rdram, ctx, runtime);
}

void entry_140af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140af0 inside entry_140acc (0x140acc - 0x140b40)
    ctx->pc = 0x140af0;
    entry_140acc(rdram, ctx, runtime);
}

void entry_140b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140b44 inside entry_140b40 (0x140b40 - 0x140b60)
    ctx->pc = 0x140b44;
    entry_140b40(rdram, ctx, runtime);
}

void entry_140b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140b48 inside entry_140b40 (0x140b40 - 0x140b60)
    ctx->pc = 0x140b48;
    entry_140b40(rdram, ctx, runtime);
}

void entry_140b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140b4c inside entry_140b40 (0x140b40 - 0x140b60)
    ctx->pc = 0x140b4c;
    entry_140b40(rdram, ctx, runtime);
}

void entry_140b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140b50 inside entry_140b40 (0x140b40 - 0x140b60)
    ctx->pc = 0x140b50;
    entry_140b40(rdram, ctx, runtime);
}

void entry_140bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140bc0 inside entry_140ba4 (0x140ba4 - 0x140bcc)
    ctx->pc = 0x140bc0;
    entry_140ba4(rdram, ctx, runtime);
}

void entry_140bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140bd8 inside entry_140bcc (0x140bcc - 0x140c04)
    ctx->pc = 0x140bd8;
    entry_140bcc(rdram, ctx, runtime);
}

void entry_140bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140bf0 inside entry_140bcc (0x140bcc - 0x140c04)
    ctx->pc = 0x140bf0;
    entry_140bcc(rdram, ctx, runtime);
}

void entry_140bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140bf8 inside entry_140bcc (0x140bcc - 0x140c04)
    ctx->pc = 0x140bf8;
    entry_140bcc(rdram, ctx, runtime);
}

void entry_140c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140c68 inside ReadCd__FUiUiPv (0x140c28 - 0x140c7c)
    ctx->pc = 0x140c68;
    ReadCd__FUiUiPv(rdram, ctx, runtime);
}

void entry_140c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140c9c inside entry_140c94 (0x140c94 - 0x140cc8)
    ctx->pc = 0x140c9c;
    entry_140c94(rdram, ctx, runtime);
}

void entry_140d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140d08 inside ReadCdDirect__FUiUiPv (0x140cc8 - 0x140d1c)
    ctx->pc = 0x140d08;
    ReadCdDirect__FUiUiPv(rdram, ctx, runtime);
}

void entry_140d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140d3c inside entry_140d34 (0x140d34 - 0x140d68)
    ctx->pc = 0x140d3c;
    entry_140d34(rdram, ctx, runtime);
}

void entry_140e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140e2c inside SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1 (0x140e10 - 0x140ed0)
    ctx->pc = 0x140e2c;
    SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1(rdram, ctx, runtime);
}

void entry_140e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140e80 inside SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1 (0x140e10 - 0x140ed0)
    ctx->pc = 0x140e80;
    SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1(rdram, ctx, runtime);
}

void entry_140e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140e84 inside SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1 (0x140e10 - 0x140ed0)
    ctx->pc = 0x140e84;
    SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1(rdram, ctx, runtime);
}

void entry_140eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140eb0 inside SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1 (0x140e10 - 0x140ed0)
    ctx->pc = 0x140eb0;
    SaveChkmgrCheckpoint__FP6CHKMGR3OIDT1(rdram, ctx, runtime);
}

void entry_140f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140f14 inside ReturnChkmgrToCheckpoint__FP6CHKMGR (0x140ed0 - 0x140f3c)
    ctx->pc = 0x140f14;
    ReturnChkmgrToCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_140f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140f28 inside ReturnChkmgrToCheckpoint__FP6CHKMGR (0x140ed0 - 0x140f3c)
    ctx->pc = 0x140f28;
    ReturnChkmgrToCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_140f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140f64 inside RestoreChkmgrFromCheckpoint__FP6CHKMGR (0x140f48 - 0x140ff8)
    ctx->pc = 0x140f64;
    RestoreChkmgrFromCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_140fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140fb8 inside RestoreChkmgrFromCheckpoint__FP6CHKMGR (0x140f48 - 0x140ff8)
    ctx->pc = 0x140fb8;
    RestoreChkmgrFromCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_140fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140fbc inside RestoreChkmgrFromCheckpoint__FP6CHKMGR (0x140f48 - 0x140ff8)
    ctx->pc = 0x140fbc;
    RestoreChkmgrFromCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_140fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x140fe8 inside RestoreChkmgrFromCheckpoint__FP6CHKMGR (0x140f48 - 0x140ff8)
    ctx->pc = 0x140fe8;
    RestoreChkmgrFromCheckpoint__FP6CHKMGR(rdram, ctx, runtime);
}

void entry_141078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141078 inside SetChkmgrIchk__FP6CHKMGRi (0x141040 - 0x1410a0)
    ctx->pc = 0x141078;
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime);
}

void entry_141098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141098 inside SetChkmgrIchk__FP6CHKMGRi (0x141040 - 0x1410a0)
    ctx->pc = 0x141098;
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime);
}

void entry_1410d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1410d8 inside ClearChkmgrIchk__FP6CHKMGRi (0x1410a0 - 0x141108)
    ctx->pc = 0x1410d8;
    ClearChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime);
}

void entry_1410fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1410fc inside ClearChkmgrIchk__FP6CHKMGRi (0x1410a0 - 0x141108)
    ctx->pc = 0x1410fc;
    ClearChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime);
}

void entry_141290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141290 inside entry_141248 (0x141248 - 0x14129c)
    ctx->pc = 0x141290;
    entry_141248(rdram, ctx, runtime);
}

void entry_1412c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1412c0 inside entry_14129c (0x14129c - 0x1412c8)
    ctx->pc = 0x1412c0;
    entry_14129c(rdram, ctx, runtime);
}

void entry_1412e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1412e8 inside entry_1412c8 (0x1412c8 - 0x1412f0)
    ctx->pc = 0x1412e8;
    entry_1412c8(rdram, ctx, runtime);
}

void entry_1412f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1412f4 inside entry_1412f0 (0x1412f0 - 0x141338)
    ctx->pc = 0x1412f4;
    entry_1412f0(rdram, ctx, runtime);
}

void entry_14130c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14130c inside entry_1412f0 (0x1412f0 - 0x141338)
    ctx->pc = 0x14130c;
    entry_1412f0(rdram, ctx, runtime);
}

void entry_141370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141370 inside entry_14135c (0x14135c - 0x141380)
    ctx->pc = 0x141370;
    entry_14135c(rdram, ctx, runtime);
}

void entry_1413a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1413a8 inside entry_141380 (0x141380 - 0x1413e0)
    ctx->pc = 0x1413a8;
    entry_141380(rdram, ctx, runtime);
}

void entry_1413b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1413b8 inside entry_141380 (0x141380 - 0x1413e0)
    ctx->pc = 0x1413b8;
    entry_141380(rdram, ctx, runtime);
}

void entry_1413d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1413d0 inside entry_141380 (0x141380 - 0x1413e0)
    ctx->pc = 0x1413d0;
    entry_141380(rdram, ctx, runtime);
}

void entry_141408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141408 inside entry_1413e0 (0x1413e0 - 0x141438)
    ctx->pc = 0x141408;
    entry_1413e0(rdram, ctx, runtime);
}

void entry_141418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141418 inside entry_1413e0 (0x1413e0 - 0x141438)
    ctx->pc = 0x141418;
    entry_1413e0(rdram, ctx, runtime);
}

void entry_141470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141470 inside entry_14145c (0x14145c - 0x14147c)
    ctx->pc = 0x141470;
    entry_14145c(rdram, ctx, runtime);
}

void entry_141490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141490 inside entry_14147c (0x14147c - 0x1414ac)
    ctx->pc = 0x141490;
    entry_14147c(rdram, ctx, runtime);
}

void entry_1414a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1414a0 inside entry_14147c (0x14147c - 0x1414ac)
    ctx->pc = 0x1414a0;
    entry_14147c(rdram, ctx, runtime);
}

void entry_1414bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1414bc inside entry_1414ac (0x1414ac - 0x14151c)
    ctx->pc = 0x1414bc;
    entry_1414ac(rdram, ctx, runtime);
}

void entry_141510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141510 inside entry_1414ac (0x1414ac - 0x14151c)
    ctx->pc = 0x141510;
    entry_1414ac(rdram, ctx, runtime);
}

void entry_14153c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14153c inside entry_14152c (0x14152c - 0x141570)
    ctx->pc = 0x14153c;
    entry_14152c(rdram, ctx, runtime);
}

void entry_141544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141544 inside entry_14152c (0x14152c - 0x141570)
    ctx->pc = 0x141544;
    entry_14152c(rdram, ctx, runtime);
}

void entry_14155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14155c inside entry_14152c (0x14152c - 0x141570)
    ctx->pc = 0x14155c;
    entry_14152c(rdram, ctx, runtime);
}

void entry_141568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141568 inside entry_14152c (0x14152c - 0x141570)
    ctx->pc = 0x141568;
    entry_14152c(rdram, ctx, runtime);
}

void entry_141574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141574 inside entry_141570 (0x141570 - 0x14158c)
    ctx->pc = 0x141574;
    entry_141570(rdram, ctx, runtime);
}

void entry_1415b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1415b8 inside entry_1415b4 (0x1415b4 - 0x1415d0)
    ctx->pc = 0x1415b8;
    entry_1415b4(rdram, ctx, runtime);
}

void entry_141610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141610 inside entry_1415fc (0x1415fc - 0x141624)
    ctx->pc = 0x141610;
    entry_1415fc(rdram, ctx, runtime);
}

void entry_141638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141638 inside entry_141624 (0x141624 - 0x14165c)
    ctx->pc = 0x141638;
    entry_141624(rdram, ctx, runtime);
}

void entry_141648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141648 inside entry_141624 (0x141624 - 0x14165c)
    ctx->pc = 0x141648;
    entry_141624(rdram, ctx, runtime);
}

void entry_141670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141670 inside entry_14165c (0x14165c - 0x141690)
    ctx->pc = 0x141670;
    entry_14165c(rdram, ctx, runtime);
}

void entry_1416e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1416e4 inside entry_1416dc (0x1416dc - 0x1416ec)
    ctx->pc = 0x1416e4;
    entry_1416dc(rdram, ctx, runtime);
}

void entry_141784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141784 inside entry_141708 (0x141708 - 0x1417b4)
    ctx->pc = 0x141784;
    entry_141708(rdram, ctx, runtime);
}

void entry_141790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141790 inside entry_141708 (0x141708 - 0x1417b4)
    ctx->pc = 0x141790;
    entry_141708(rdram, ctx, runtime);
}

void entry_141798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141798 inside entry_141708 (0x141708 - 0x1417b4)
    ctx->pc = 0x141798;
    entry_141708(rdram, ctx, runtime);
}

void entry_1417d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1417d0 inside entry_1417cc (0x1417cc - 0x1417f0)
    ctx->pc = 0x1417d0;
    entry_1417cc(rdram, ctx, runtime);
}

void entry_1417d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1417d4 inside entry_1417cc (0x1417cc - 0x1417f0)
    ctx->pc = 0x1417d4;
    entry_1417cc(rdram, ctx, runtime);
}

void entry_141850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141850 inside entry_141848 (0x141848 - 0x141858)
    ctx->pc = 0x141850;
    entry_141848(rdram, ctx, runtime);
}

void entry_1418c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1418c0 inside entry_1418b8 (0x1418b8 - 0x1418d0)
    ctx->pc = 0x1418c0;
    entry_1418b8(rdram, ctx, runtime);
}

void entry_1418f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1418f0 inside entry_1418dc (0x1418dc - 0x141924)
    ctx->pc = 0x1418f0;
    entry_1418dc(rdram, ctx, runtime);
}

void entry_1418f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1418f8 inside entry_1418dc (0x1418dc - 0x141924)
    ctx->pc = 0x1418f8;
    entry_1418dc(rdram, ctx, runtime);
}

void entry_141904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141904 inside entry_1418dc (0x1418dc - 0x141924)
    ctx->pc = 0x141904;
    entry_1418dc(rdram, ctx, runtime);
}

void entry_141910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141910 inside entry_1418dc (0x1418dc - 0x141924)
    ctx->pc = 0x141910;
    entry_1418dc(rdram, ctx, runtime);
}

void entry_141914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141914 inside entry_1418dc (0x1418dc - 0x141924)
    ctx->pc = 0x141914;
    entry_1418dc(rdram, ctx, runtime);
}

void entry_141938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141938 inside entry_141924 (0x141924 - 0x14195c)
    ctx->pc = 0x141938;
    entry_141924(rdram, ctx, runtime);
}

void entry_14196c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14196c inside entry_14195c (0x14195c - 0x141980)
    ctx->pc = 0x14196c;
    entry_14195c(rdram, ctx, runtime);
}

void entry_141984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141984 inside entry_141980 (0x141980 - 0x1419a0)
    ctx->pc = 0x141984;
    entry_141980(rdram, ctx, runtime);
}

void entry_141a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141a50 inside PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG (0x1419e8 - 0x141a70)
    ctx->pc = 0x141a50;
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime);
}

void entry_141a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141a94 inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141a94;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141a98 inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141a98;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141ad4 inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141ad4;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141af8 inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141af8;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141afc inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141afc;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141b08 inside entry_141a70 (0x141a70 - 0x141b48)
    ctx->pc = 0x141b08;
    entry_141a70(rdram, ctx, runtime);
}

void entry_141ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141ba0 inside FUN_00141b48 (0x141b48 - 0x141bcc)
    ctx->pc = 0x141ba0;
    FUN_00141b48(rdram, ctx, runtime);
}

void entry_141bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141bec inside entry_141be4 (0x141be4 - 0x141c28)
    ctx->pc = 0x141bec;
    entry_141be4(rdram, ctx, runtime);
}

void entry_141bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141bf4 inside entry_141be4 (0x141be4 - 0x141c28)
    ctx->pc = 0x141bf4;
    entry_141be4(rdram, ctx, runtime);
}

void entry_141c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141c54 inside entry_141c4c (0x141c4c - 0x141c80)
    ctx->pc = 0x141c54;
    entry_141c4c(rdram, ctx, runtime);
}

void entry_141c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141c74 inside entry_141c4c (0x141c4c - 0x141c80)
    ctx->pc = 0x141c74;
    entry_141c4c(rdram, ctx, runtime);
}

void entry_141c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141c84 inside entry_141c80 (0x141c80 - 0x141c90)
    ctx->pc = 0x141c84;
    entry_141c80(rdram, ctx, runtime);
}

void entry_141cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141cb8 inside entry_141cb0 (0x141cb0 - 0x141cf0)
    ctx->pc = 0x141cb8;
    entry_141cb0(rdram, ctx, runtime);
}

void entry_141cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141cd8 inside entry_141cb0 (0x141cb0 - 0x141cf0)
    ctx->pc = 0x141cd8;
    entry_141cb0(rdram, ctx, runtime);
}

void entry_141cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141cf4 inside entry_141cf0 (0x141cf0 - 0x141d00)
    ctx->pc = 0x141cf4;
    entry_141cf0(rdram, ctx, runtime);
}

void entry_141d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141d44 inside entry_141d3c (0x141d3c - 0x141d7c)
    ctx->pc = 0x141d44;
    entry_141d3c(rdram, ctx, runtime);
}

void entry_141d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141d64 inside entry_141d3c (0x141d3c - 0x141d7c)
    ctx->pc = 0x141d64;
    entry_141d3c(rdram, ctx, runtime);
}

void entry_141d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141d80 inside entry_141d7c (0x141d7c - 0x141d88)
    ctx->pc = 0x141d80;
    entry_141d7c(rdram, ctx, runtime);
}

void entry_141e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141e30 inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141e30;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_141e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141e38 inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141e38;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_141e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141e88 inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141e88;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_141f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141f0c inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141f0c;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_141f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141f18 inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141f18;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_141f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x141f3c inside ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG (0x141d88 - 0x141f48)
    ctx->pc = 0x141f3c;
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142034 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142034;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_14205c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14205c inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x14205c;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142064 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142064;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142068 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142068;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1420b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1420b0 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x1420b0;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142134 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142134;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142140 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142140;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142164 inside ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG (0x141f48 - 0x142170)
    ctx->pc = 0x142164;
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1423bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1423bc inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1423bc;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142410 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142410;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_14241c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14241c inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x14241c;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1424bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1424bc inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1424bc;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142568 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142568;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_14260c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14260c inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x14260c;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142678 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142678;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1426a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1426a8 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1426a8;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1426d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1426d8 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1426d8;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1426e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1426e0 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1426e0;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142754 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142754;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1427c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1427c0 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1427c0;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1427c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1427c4 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1427c4;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142814 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142814;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142820 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142820;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142848 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x142848;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1428a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1428a8 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1428a8;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_1428c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1428c0 inside ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG (0x142278 - 0x1428e0)
    ctx->pc = 0x1428c0;
    ClsgClipEdgeToCylinder__FP6VECTORT0fT0T0iP3LSG(rdram, ctx, runtime);
}

void entry_142930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142930 inside entry_1428e0 (0x1428e0 - 0x142990)
    ctx->pc = 0x142930;
    entry_1428e0(rdram, ctx, runtime);
}

void entry_14293c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14293c inside entry_1428e0 (0x1428e0 - 0x142990)
    ctx->pc = 0x14293c;
    entry_1428e0(rdram, ctx, runtime);
}

void entry_142940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142940 inside entry_1428e0 (0x1428e0 - 0x142990)
    ctx->pc = 0x142940;
    entry_1428e0(rdram, ctx, runtime);
}

void entry_14295c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14295c inside entry_1428e0 (0x1428e0 - 0x142990)
    ctx->pc = 0x14295c;
    entry_1428e0(rdram, ctx, runtime);
}

void entry_142960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142960 inside entry_1428e0 (0x1428e0 - 0x142990)
    ctx->pc = 0x142960;
    entry_1428e0(rdram, ctx, runtime);
}

void entry_1429e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1429e8 inside SgnCompareMaa__FP3MAAT0 (0x142998 - 0x1429f8)
    ctx->pc = 0x1429e8;
    SgnCompareMaa__FP3MAAT0(rdram, ctx, runtime);
}

void entry_1429f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1429f0 inside SgnCompareMaa__FP3MAAT0 (0x142998 - 0x1429f8)
    ctx->pc = 0x1429f0;
    SgnCompareMaa__FP3MAAT0(rdram, ctx, runtime);
}

void entry_142a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142a48 inside entry_142a28 (0x142a28 - 0x142ab8)
    ctx->pc = 0x142a48;
    entry_142a28(rdram, ctx, runtime);
}

void entry_142a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142a58 inside entry_142a28 (0x142a28 - 0x142ab8)
    ctx->pc = 0x142a58;
    entry_142a28(rdram, ctx, runtime);
}

void entry_142a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142a9c inside entry_142a28 (0x142a28 - 0x142ab8)
    ctx->pc = 0x142a9c;
    entry_142a28(rdram, ctx, runtime);
}

void entry_142ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142ad8 inside entry_142ab8 (0x142ab8 - 0x142b48)
    ctx->pc = 0x142ad8;
    entry_142ab8(rdram, ctx, runtime);
}

void entry_142b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142b0c inside entry_142ab8 (0x142ab8 - 0x142b48)
    ctx->pc = 0x142b0c;
    entry_142ab8(rdram, ctx, runtime);
}

void entry_142b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142b30 inside entry_142ab8 (0x142ab8 - 0x142b48)
    ctx->pc = 0x142b30;
    entry_142ab8(rdram, ctx, runtime);
}

void entry_142b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142b34 inside entry_142ab8 (0x142ab8 - 0x142b48)
    ctx->pc = 0x142b34;
    entry_142ab8(rdram, ctx, runtime);
}

void entry_142b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142b40 inside entry_142ab8 (0x142ab8 - 0x142b48)
    ctx->pc = 0x142b40;
    entry_142ab8(rdram, ctx, runtime);
}

void entry_142bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142bd8 inside ClsgClipCylinderToBsp__FP4BSPCP4GEOMP6VECTORT2fiP3LSG (0x142b78 - 0x142be0)
    ctx->pc = 0x142bd8;
    ClsgClipCylinderToBsp__FP4BSPCP4GEOMP6VECTORT2fiP3LSG(rdram, ctx, runtime);
}

void entry_142c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142c94 inside entry_142c6c (0x142c6c - 0x142cac)
    ctx->pc = 0x142c94;
    entry_142c6c(rdram, ctx, runtime);
}

void entry_142c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142c9c inside entry_142c6c (0x142c6c - 0x142cac)
    ctx->pc = 0x142c9c;
    entry_142c6c(rdram, ctx, runtime);
}

void entry_142cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142cd4 inside entry_142cac (0x142cac - 0x142d04)
    ctx->pc = 0x142cd4;
    entry_142cac(rdram, ctx, runtime);
}

void entry_142d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142d18 inside entry_142d04 (0x142d04 - 0x142dd4)
    ctx->pc = 0x142d18;
    entry_142d04(rdram, ctx, runtime);
}

void entry_142d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142d34 inside entry_142d04 (0x142d04 - 0x142dd4)
    ctx->pc = 0x142d34;
    entry_142d04(rdram, ctx, runtime);
}

void entry_142d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142d40 inside entry_142d04 (0x142d04 - 0x142dd4)
    ctx->pc = 0x142d40;
    entry_142d04(rdram, ctx, runtime);
}

void entry_142d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142d78 inside entry_142d04 (0x142d04 - 0x142dd4)
    ctx->pc = 0x142d78;
    entry_142d04(rdram, ctx, runtime);
}

void entry_142df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142df8 inside entry_142dd4 (0x142dd4 - 0x142e30)
    ctx->pc = 0x142df8;
    entry_142dd4(rdram, ctx, runtime);
}

void entry_142e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e18 inside entry_142dd4 (0x142dd4 - 0x142e30)
    ctx->pc = 0x142e18;
    entry_142dd4(rdram, ctx, runtime);
}

void entry_142e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e28 inside entry_142dd4 (0x142dd4 - 0x142e30)
    ctx->pc = 0x142e28;
    entry_142dd4(rdram, ctx, runtime);
}

void entry_142e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e34 inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e34;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e40 inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e40;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e44 inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e44;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e50 inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e50;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e60 inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e60;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e7c inside entry_142e30 (0x142e30 - 0x142e84)
    ctx->pc = 0x142e7c;
    entry_142e30(rdram, ctx, runtime);
}

void entry_142e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142e88 inside entry_142e84 (0x142e84 - 0x142ec8)
    ctx->pc = 0x142e88;
    entry_142e84(rdram, ctx, runtime);
}

void entry_142efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142efc inside SetClockRate__Ff (0x142ed0 - 0x142f04)
    ctx->pc = 0x142efc;
    SetClockRate__Ff(rdram, ctx, runtime);
}

void entry_142f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142f4c inside entry_142f44 (0x142f44 - 0x142f58)
    ctx->pc = 0x142f4c;
    entry_142f44(rdram, ctx, runtime);
}

void entry_142f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142f5c inside entry_142f58 (0x142f58 - 0x143030)
    ctx->pc = 0x142f5c;
    entry_142f58(rdram, ctx, runtime);
}

void entry_142f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142f98 inside entry_142f58 (0x142f58 - 0x143030)
    ctx->pc = 0x142f98;
    entry_142f58(rdram, ctx, runtime);
}

void entry_142fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142fa8 inside entry_142f58 (0x142f58 - 0x143030)
    ctx->pc = 0x142fa8;
    entry_142f58(rdram, ctx, runtime);
}

void entry_142fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142fbc inside entry_142f58 (0x142f58 - 0x143030)
    ctx->pc = 0x142fbc;
    entry_142f58(rdram, ctx, runtime);
}

void entry_142ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x142ff0 inside entry_142f58 (0x142f58 - 0x143030)
    ctx->pc = 0x142ff0;
    entry_142f58(rdram, ctx, runtime);
}

void entry_14306c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14306c inside entry_143064 (0x143064 - 0x143078)
    ctx->pc = 0x14306c;
    entry_143064(rdram, ctx, runtime);
}

void entry_14307c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14307c inside entry_143078 (0x143078 - 0x1430b8)
    ctx->pc = 0x14307c;
    entry_143078(rdram, ctx, runtime);
}

void entry_143128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143128 inside TickNow__Fv (0x1430f8 - 0x143140)
    ctx->pc = 0x143128;
    TickNow__Fv(rdram, ctx, runtime);
}

void entry_1431a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1431a0 inside SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR (0x143180 - 0x143208)
    ctx->pc = 0x1431a0;
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime);
}

void entry_143200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143200 inside SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR (0x143180 - 0x143208)
    ctx->pc = 0x143200;
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime);
}

void entry_143278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143278 inside entry_143240 (0x143240 - 0x1432b0)
    ctx->pc = 0x143278;
    entry_143240(rdram, ctx, runtime);
}

void entry_143288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143288 inside entry_143240 (0x143240 - 0x1432b0)
    ctx->pc = 0x143288;
    entry_143240(rdram, ctx, runtime);
}

void entry_1432dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1432dc inside entry_1432d4 (0x1432d4 - 0x143308)
    ctx->pc = 0x1432dc;
    entry_1432d4(rdram, ctx, runtime);
}

void entry_143330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143330 inside entry_143328 (0x143328 - 0x143354)
    ctx->pc = 0x143330;
    entry_143328(rdram, ctx, runtime);
}

void entry_14335c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14335c inside entry_143354 (0x143354 - 0x143388)
    ctx->pc = 0x14335c;
    entry_143354(rdram, ctx, runtime);
}

void entry_1433b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1433b0 inside entry_1433ac (0x1433ac - 0x1433e0)
    ctx->pc = 0x1433b0;
    entry_1433ac(rdram, ctx, runtime);
}

void entry_14344c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14344c inside GetCmCpdefi__FP2CMP2SOfP6CPDEFI (0x143418 - 0x143488)
    ctx->pc = 0x14344c;
    GetCmCpdefi__FP2CMP2SOfP6CPDEFI(rdram, ctx, runtime);
}

void entry_143474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143474 inside GetCmCpdefi__FP2CMP2SOfP6CPDEFI (0x143418 - 0x143488)
    ctx->pc = 0x143474;
    GetCmCpdefi__FP2CMP2SOfP6CPDEFI(rdram, ctx, runtime);
}

void entry_1434ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1434ac inside entry_14349c (0x14349c - 0x1434c8)
    ctx->pc = 0x1434ac;
    entry_14349c(rdram, ctx, runtime);
}

void entry_143b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143b18 inside AddCmFadeObject (0x143af8 - 0x143b20)
    ctx->pc = 0x143b18;
    AddCmFadeObject(rdram, ctx, runtime);
}

void entry_143b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143b50 inside RemoveCmFadeObject (0x143b20 - 0x143b6c)
    ctx->pc = 0x143b50;
    RemoveCmFadeObject(rdram, ctx, runtime);
}

void entry_143b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143b7c inside entry_143b6c (0x143b6c - 0x143ba8)
    ctx->pc = 0x143b7c;
    entry_143b6c(rdram, ctx, runtime);
}

void entry_143b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143b94 inside entry_143b6c (0x143b6c - 0x143ba8)
    ctx->pc = 0x143b94;
    entry_143b6c(rdram, ctx, runtime);
}

void entry_143bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143bd4 inside FUN_00143BA8 (0x143ba8 - 0x143be0)
    ctx->pc = 0x143bd4;
    FUN_00143BA8(rdram, ctx, runtime);
}

void entry_143bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143bd8 inside FUN_00143BA8 (0x143ba8 - 0x143be0)
    ctx->pc = 0x143bd8;
    FUN_00143BA8(rdram, ctx, runtime);
}

void entry_143c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143c40 inside entry_143c10 (0x143c10 - 0x143c9c)
    ctx->pc = 0x143c40;
    entry_143c10(rdram, ctx, runtime);
}

void entry_143c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143c70 inside entry_143c10 (0x143c10 - 0x143c9c)
    ctx->pc = 0x143c70;
    entry_143c10(rdram, ctx, runtime);
}

void entry_143c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143c7c inside entry_143c10 (0x143c10 - 0x143c9c)
    ctx->pc = 0x143c7c;
    entry_143c10(rdram, ctx, runtime);
}

void entry_143cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143cb0 inside entry_143c9c (0x143c9c - 0x143d1c)
    ctx->pc = 0x143cb0;
    entry_143c9c(rdram, ctx, runtime);
}

void entry_143ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143ce8 inside entry_143c9c (0x143c9c - 0x143d1c)
    ctx->pc = 0x143ce8;
    entry_143c9c(rdram, ctx, runtime);
}

void entry_143d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143d40 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143d40;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143d80 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143d80;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143dd0 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143dd0;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143dd4 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143dd4;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143de0 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143de0;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143de4 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143de4;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143df4 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143df4;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143e08 inside entry_143d1c (0x143d1c - 0x143e10)
    ctx->pc = 0x143e08;
    entry_143d1c(rdram, ctx, runtime);
}

void entry_143e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143e94 inside UpdateCmLast (0x143e40 - 0x143ee8)
    ctx->pc = 0x143e94;
    UpdateCmLast(rdram, ctx, runtime);
}

void entry_143ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143ec0 inside UpdateCmLast (0x143e40 - 0x143ee8)
    ctx->pc = 0x143ec0;
    UpdateCmLast(rdram, ctx, runtime);
}

void entry_143efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143efc inside entry_143ee8 (0x143ee8 - 0x143f08)
    ctx->pc = 0x143efc;
    entry_143ee8(rdram, ctx, runtime);
}

void entry_143f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f10 inside entry_143f08 (0x143f08 - 0x143f1c)
    ctx->pc = 0x143f10;
    entry_143f08(rdram, ctx, runtime);
}

void entry_143f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f24 inside entry_143f1c (0x143f1c - 0x143f58)
    ctx->pc = 0x143f24;
    entry_143f1c(rdram, ctx, runtime);
}

void entry_143f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f44 inside entry_143f1c (0x143f1c - 0x143f58)
    ctx->pc = 0x143f44;
    entry_143f1c(rdram, ctx, runtime);
}

void entry_143f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f70 inside entry_143f58 (0x143f58 - 0x143f88)
    ctx->pc = 0x143f70;
    entry_143f58(rdram, ctx, runtime);
}

void entry_143f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f74 inside entry_143f58 (0x143f58 - 0x143f88)
    ctx->pc = 0x143f74;
    entry_143f58(rdram, ctx, runtime);
}

void entry_143f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143f90 inside entry_143f88 (0x143f88 - 0x143fb8)
    ctx->pc = 0x143f90;
    entry_143f88(rdram, ctx, runtime);
}

void entry_143fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143fc8 inside entry_143fc4 (0x143fc4 - 0x144008)
    ctx->pc = 0x143fc8;
    entry_143fc4(rdram, ctx, runtime);
}

void entry_143fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x143fd8 inside entry_143fc4 (0x143fc4 - 0x144008)
    ctx->pc = 0x143fd8;
    entry_143fc4(rdram, ctx, runtime);
}

void entry_144098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144098 inside SetupCmRotateToCam (0x144008 - 0x144128)
    ctx->pc = 0x144098;
    SetupCmRotateToCam(rdram, ctx, runtime);
}

void entry_1440a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1440a4 inside SetupCmRotateToCam (0x144008 - 0x144128)
    ctx->pc = 0x1440a4;
    SetupCmRotateToCam(rdram, ctx, runtime);
}

void entry_14416c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14416c inside ConvertCmScreenToWorld (0x144128 - 0x1441c0)
    ctx->pc = 0x14416c;
    ConvertCmScreenToWorld(rdram, ctx, runtime);
}

void entry_144264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144264 inside ConvertCmWorldToScreen (0x1441c0 - 0x144270)
    ctx->pc = 0x144264;
    ConvertCmWorldToScreen(rdram, ctx, runtime);
}

void entry_1442b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1442b4 inside entry_1442a8 (0x1442a8 - 0x1442c8)
    ctx->pc = 0x1442b4;
    entry_1442a8(rdram, ctx, runtime);
}

void entry_144320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144320 inside entry_144300 (0x144300 - 0x144374)
    ctx->pc = 0x144320;
    entry_144300(rdram, ctx, runtime);
}

void entry_1445b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1445b4 inside entry_1445a8 (0x1445a8 - 0x144630)
    ctx->pc = 0x1445b4;
    entry_1445a8(rdram, ctx, runtime);
}

void entry_144600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144600 inside entry_1445a8 (0x1445a8 - 0x144630)
    ctx->pc = 0x144600;
    entry_1445a8(rdram, ctx, runtime);
}

void entry_144614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144614 inside entry_1445a8 (0x1445a8 - 0x144630)
    ctx->pc = 0x144614;
    entry_1445a8(rdram, ctx, runtime);
}

void entry_1447ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1447ac inside entry_1447a8 (0x1447a8 - 0x1447b8)
    ctx->pc = 0x1447ac;
    entry_1447a8(rdram, ctx, runtime);
}

void entry_1447e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1447e0 inside entry_1447cc (0x1447cc - 0x144848)
    ctx->pc = 0x1447e0;
    entry_1447cc(rdram, ctx, runtime);
}

void entry_1448e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1448e4 inside SetCmPosMat__FP2CMP6VECTORP7MATRIX3 (0x1448c8 - 0x14490c)
    ctx->pc = 0x1448e4;
    SetCmPosMat__FP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_144904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144904 inside SetCmPosMat__FP2CMP6VECTORP7MATRIX3 (0x1448c8 - 0x14490c)
    ctx->pc = 0x144904;
    SetCmPosMat__FP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_144a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144a14 inside entry_1449bc (0x1449bc - 0x144aa0)
    ctx->pc = 0x144a14;
    entry_1449bc(rdram, ctx, runtime);
}

void entry_144a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144a60 inside entry_1449bc (0x1449bc - 0x144aa0)
    ctx->pc = 0x144a60;
    entry_1449bc(rdram, ctx, runtime);
}

void entry_144a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144a80 inside entry_1449bc (0x1449bc - 0x144aa0)
    ctx->pc = 0x144a80;
    entry_1449bc(rdram, ctx, runtime);
}

void entry_144c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144c4c inside SetCmLookAtSmooth (0x144be8 - 0x144c60)
    ctx->pc = 0x144c4c;
    SetCmLookAtSmooth(rdram, ctx, runtime);
}

void entry_144cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144cf4 inside entry_144cd0 (0x144cd0 - 0x144d00)
    ctx->pc = 0x144cf4;
    entry_144cd0(rdram, ctx, runtime);
}

void entry_144da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144da4 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144da4;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144db8 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144db8;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144dd8 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144dd8;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144de8 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144de8;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144dec inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144dec;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144e14 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144e14;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144e38 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144e38;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144e5c inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144e5c;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144e74 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144e74;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144e8c inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144e8c;
    entry_144d28(rdram, ctx, runtime);
}

void entry_144f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x144f68 inside entry_144d28 (0x144d28 - 0x144f70)
    ctx->pc = 0x144f68;
    entry_144d28(rdram, ctx, runtime);
}

void entry_14502c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14502c inside AdjustCmJoy__FP2CMP3JOY5JOYIDPf (0x144ff8 - 0x145044)
    ctx->pc = 0x14502c;
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime);
}

void entry_145038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145038 inside AdjustCmJoy__FP2CMP3JOY5JOYIDPf (0x144ff8 - 0x145044)
    ctx->pc = 0x145038;
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime);
}

void entry_14503c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14503c inside AdjustCmJoy__FP2CMP3JOY5JOYIDPf (0x144ff8 - 0x145044)
    ctx->pc = 0x14503c;
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime);
}

void entry_14504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14504c inside entry_145044 (0x145044 - 0x14505c)
    ctx->pc = 0x14504c;
    entry_145044(rdram, ctx, runtime);
}

void entry_145050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145050 inside entry_145044 (0x145044 - 0x14505c)
    ctx->pc = 0x145050;
    entry_145044(rdram, ctx, runtime);
}

void entry_1450e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1450e8 inside SetCmPolicy (0x145088 - 0x145128)
    ctx->pc = 0x1450e8;
    SetCmPolicy(rdram, ctx, runtime);
}

void entry_145104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145104 inside SetCmPolicy (0x145088 - 0x145128)
    ctx->pc = 0x145104;
    SetCmPolicy(rdram, ctx, runtime);
}

void entry_145108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145108 inside SetCmPolicy (0x145088 - 0x145128)
    ctx->pc = 0x145108;
    SetCmPolicy(rdram, ctx, runtime);
}

void entry_1451a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1451a4 inside entry_1451a0 (0x1451a0 - 0x1451c4)
    ctx->pc = 0x1451a4;
    entry_1451a0(rdram, ctx, runtime);
}

void entry_1451c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1451c8 inside entry_1451c4 (0x1451c4 - 0x1451f0)
    ctx->pc = 0x1451c8;
    entry_1451c4(rdram, ctx, runtime);
}

void entry_145268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145268 inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x145268;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_14527c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14527c inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x14527c;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_145290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145290 inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x145290;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_1452a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1452a4 inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x1452a4;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_1452bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1452bc inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x1452bc;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_1452cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1452cc inside RevokeCmPolicy (0x1451f0 - 0x1452e4)
    ctx->pc = 0x1452cc;
    RevokeCmPolicy(rdram, ctx, runtime);
}

void entry_1452ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1452ec inside entry_1452e4 (0x1452e4 - 0x145350)
    ctx->pc = 0x1452ec;
    entry_1452e4(rdram, ctx, runtime);
}

void entry_145314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145314 inside entry_1452e4 (0x1452e4 - 0x145350)
    ctx->pc = 0x145314;
    entry_1452e4(rdram, ctx, runtime);
}

void entry_145324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145324 inside entry_1452e4 (0x1452e4 - 0x145350)
    ctx->pc = 0x145324;
    entry_1452e4(rdram, ctx, runtime);
}

void entry_145384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145384 inside entry_145380 (0x145380 - 0x1453b0)
    ctx->pc = 0x145384;
    entry_145380(rdram, ctx, runtime);
}

void entry_14541c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14541c inside FInsideCmMrd (0x1453b0 - 0x145438)
    ctx->pc = 0x14541c;
    FInsideCmMrd(rdram, ctx, runtime);
}

void entry_145424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145424 inside FInsideCmMrd (0x1453b0 - 0x145438)
    ctx->pc = 0x145424;
    FInsideCmMrd(rdram, ctx, runtime);
}

void entry_145430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145430 inside FInsideCmMrd (0x1453b0 - 0x145438)
    ctx->pc = 0x145430;
    FInsideCmMrd(rdram, ctx, runtime);
}

void entry_145470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145470 inside DecomposeCylind (0x145438 - 0x14548c)
    ctx->pc = 0x145470;
    DecomposeCylind(rdram, ctx, runtime);
}

void entry_145478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145478 inside DecomposeCylind (0x145438 - 0x14548c)
    ctx->pc = 0x145478;
    DecomposeCylind(rdram, ctx, runtime);
}

void entry_145498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145498 inside entry_145494 (0x145494 - 0x1454e0)
    ctx->pc = 0x145498;
    entry_145494(rdram, ctx, runtime);
}

void entry_1454bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1454bc inside entry_145494 (0x145494 - 0x1454e0)
    ctx->pc = 0x1454bc;
    entry_145494(rdram, ctx, runtime);
}

void entry_1454c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1454c8 inside entry_145494 (0x145494 - 0x1454e0)
    ctx->pc = 0x1454c8;
    entry_145494(rdram, ctx, runtime);
}

void entry_145518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145518 inside DecomposeSphere (0x1454e0 - 0x145534)
    ctx->pc = 0x145518;
    DecomposeSphere(rdram, ctx, runtime);
}

void entry_145520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145520 inside DecomposeSphere (0x1454e0 - 0x145534)
    ctx->pc = 0x145520;
    DecomposeSphere(rdram, ctx, runtime);
}

void entry_145540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145540 inside entry_14553c (0x14553c - 0x145570)
    ctx->pc = 0x145540;
    entry_14553c(rdram, ctx, runtime);
}

void entry_14557c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14557c inside entry_145578 (0x145578 - 0x1455c0)
    ctx->pc = 0x14557c;
    entry_145578(rdram, ctx, runtime);
}

void entry_1455a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1455a8 inside entry_145578 (0x145578 - 0x1455c0)
    ctx->pc = 0x1455a8;
    entry_145578(rdram, ctx, runtime);
}

void entry_1455d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1455d8 inside SetCmCut__FP2CMPf (0x1455c0 - 0x1455e0)
    ctx->pc = 0x1455d8;
    SetCmCut__FP2CMPf(rdram, ctx, runtime);
}

void entry_145870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145870 inside PsoEnemyStepguard (0x145810 - 0x14589c)
    ctx->pc = 0x145870;
    PsoEnemyStepguard(rdram, ctx, runtime);
}

void entry_1458a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1458a4 inside entry_14589c (0x14589c - 0x1458b0)
    ctx->pc = 0x1458a4;
    entry_14589c(rdram, ctx, runtime);
}

void entry_1458c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1458c0 inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x1458c0;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_1458c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1458c4 inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x1458c4;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_1458dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1458dc inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x1458dc;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_1458f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1458f0 inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x1458f0;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_14590c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14590c inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x14590c;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_145914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145914 inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x145914;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_145918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145918 inside entry_1458b0 (0x1458b0 - 0x145950)
    ctx->pc = 0x145918;
    entry_1458b0(rdram, ctx, runtime);
}

void entry_1459f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1459f0 inside FUN_00145950 (0x145950 - 0x145a54)
    ctx->pc = 0x1459f0;
    FUN_00145950(rdram, ctx, runtime);
}

void entry_145a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145a40 inside FUN_00145950 (0x145950 - 0x145a54)
    ctx->pc = 0x145a40;
    FUN_00145950(rdram, ctx, runtime);
}

void entry_145aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145aa4 inside entry_145a84 (0x145a84 - 0x145b68)
    ctx->pc = 0x145aa4;
    entry_145a84(rdram, ctx, runtime);
}

void entry_145ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145ae4 inside entry_145a84 (0x145a84 - 0x145b68)
    ctx->pc = 0x145ae4;
    entry_145a84(rdram, ctx, runtime);
}

void entry_145b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145b00 inside entry_145a84 (0x145a84 - 0x145b68)
    ctx->pc = 0x145b00;
    entry_145a84(rdram, ctx, runtime);
}

void entry_145bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145bd0 inside FUN_00145b68 (0x145b68 - 0x145c00)
    ctx->pc = 0x145bd0;
    FUN_00145b68(rdram, ctx, runtime);
}

void entry_145c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145c04 inside entry_145c00 (0x145c00 - 0x145c2c)
    ctx->pc = 0x145c04;
    entry_145c00(rdram, ctx, runtime);
}

void entry_145c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145c10 inside entry_145c00 (0x145c00 - 0x145c2c)
    ctx->pc = 0x145c10;
    entry_145c00(rdram, ctx, runtime);
}

void entry_145c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145c24 inside entry_145c00 (0x145c00 - 0x145c2c)
    ctx->pc = 0x145c24;
    entry_145c00(rdram, ctx, runtime);
}

void entry_145c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145c70 inside entry_145c58 (0x145c58 - 0x145cfc)
    ctx->pc = 0x145c70;
    entry_145c58(rdram, ctx, runtime);
}

void entry_145c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145c90 inside entry_145c58 (0x145c58 - 0x145cfc)
    ctx->pc = 0x145c90;
    entry_145c58(rdram, ctx, runtime);
}

void entry_145cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145cc0 inside entry_145c58 (0x145c58 - 0x145cfc)
    ctx->pc = 0x145cc0;
    entry_145c58(rdram, ctx, runtime);
}

void entry_145cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145cd0 inside entry_145c58 (0x145c58 - 0x145cfc)
    ctx->pc = 0x145cd0;
    entry_145c58(rdram, ctx, runtime);
}

void entry_145ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145ce0 inside entry_145c58 (0x145c58 - 0x145cfc)
    ctx->pc = 0x145ce0;
    entry_145c58(rdram, ctx, runtime);
}

void entry_145d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145d0c inside entry_145cfc (0x145cfc - 0x145d20)
    ctx->pc = 0x145d0c;
    entry_145cfc(rdram, ctx, runtime);
}

void entry_145d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145d40 inside entry_145d20 (0x145d20 - 0x145d84)
    ctx->pc = 0x145d40;
    entry_145d20(rdram, ctx, runtime);
}

void entry_145d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145d74 inside entry_145d20 (0x145d20 - 0x145d84)
    ctx->pc = 0x145d74;
    entry_145d20(rdram, ctx, runtime);
}

void entry_145da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x145da0 inside entry_145d8c (0x145d8c - 0x145dd8)
    ctx->pc = 0x145da0;
    entry_145d8c(rdram, ctx, runtime);
}

void entry_1460a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1460a8 inside entry_1460a4 (0x1460a4 - 0x1460b8)
    ctx->pc = 0x1460a8;
    entry_1460a4(rdram, ctx, runtime);
}

void entry_1460d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1460d8 inside cm__static_initialization_and_destruction_0__Fii (0x1460b8 - 0x1460e0)
    ctx->pc = 0x1460d8;
    cm__static_initialization_and_destruction_0__Fii(rdram, ctx, runtime);
}

void entry_146234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146234 inside AdjustCnvoXpVelocity__FP4CNVOP2XPi (0x1461a8 - 0x146240)
    ctx->pc = 0x146234;
    AdjustCnvoXpVelocity__FP4CNVOP2XPi(rdram, ctx, runtime);
}

void entry_14628c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14628c inside entry_146288 (0x146288 - 0x146298)
    ctx->pc = 0x14628c;
    entry_146288(rdram, ctx, runtime);
}

void entry_1462e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1462e8 inside MatchCnvoScrollerToBeltSpeed__FP4CNVO (0x146298 - 0x146340)
    ctx->pc = 0x1462e8;
    MatchCnvoScrollerToBeltSpeed__FP4CNVO(rdram, ctx, runtime);
}

void entry_146338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146338 inside MatchCnvoScrollerToBeltSpeed__FP4CNVO (0x146298 - 0x146340)
    ctx->pc = 0x146338;
    MatchCnvoScrollerToBeltSpeed__FP4CNVO(rdram, ctx, runtime);
}

void entry_1464f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1464f0 inside entry_1464e4 (0x1464e4 - 0x146504)
    ctx->pc = 0x1464f0;
    entry_1464e4(rdram, ctx, runtime);
}

void entry_146580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146580 inside ProjectDprizeTransform__FP6DPRIZEfi (0x146518 - 0x14659c)
    ctx->pc = 0x146580;
    ProjectDprizeTransform__FP6DPRIZEfi(rdram, ctx, runtime);
}

void entry_146594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146594 inside ProjectDprizeTransform__FP6DPRIZEfi (0x146518 - 0x14659c)
    ctx->pc = 0x146594;
    ProjectDprizeTransform__FP6DPRIZEfi(rdram, ctx, runtime);
}

void entry_146610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146610 inside entry_1465c8 (0x1465c8 - 0x146674)
    ctx->pc = 0x146610;
    entry_1465c8(rdram, ctx, runtime);
}

void entry_146650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146650 inside entry_1465c8 (0x1465c8 - 0x146674)
    ctx->pc = 0x146650;
    entry_1465c8(rdram, ctx, runtime);
}

void entry_14670c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14670c inside entry_146708 (0x146708 - 0x14672c)
    ctx->pc = 0x14670c;
    entry_146708(rdram, ctx, runtime);
}

void entry_146718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146718 inside entry_146708 (0x146708 - 0x14672c)
    ctx->pc = 0x146718;
    entry_146708(rdram, ctx, runtime);
}

void entry_14688c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14688c inside entry_146828 (0x146828 - 0x146894)
    ctx->pc = 0x14688c;
    entry_146828(rdram, ctx, runtime);
}

void entry_1469b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1469b8 inside entry_14691c (0x14691c - 0x1469fc)
    ctx->pc = 0x1469b8;
    entry_14691c(rdram, ctx, runtime);
}

void entry_146a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146a38 inside entry_1469fc (0x1469fc - 0x146b0c)
    ctx->pc = 0x146a38;
    entry_1469fc(rdram, ctx, runtime);
}

void entry_146a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146a48 inside entry_1469fc (0x1469fc - 0x146b0c)
    ctx->pc = 0x146a48;
    entry_1469fc(rdram, ctx, runtime);
}

void entry_146a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146a64 inside entry_1469fc (0x1469fc - 0x146b0c)
    ctx->pc = 0x146a64;
    entry_1469fc(rdram, ctx, runtime);
}

void entry_146a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146a6c inside entry_1469fc (0x1469fc - 0x146b0c)
    ctx->pc = 0x146a6c;
    entry_1469fc(rdram, ctx, runtime);
}

void entry_146ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146ab8 inside entry_1469fc (0x1469fc - 0x146b0c)
    ctx->pc = 0x146ab8;
    entry_1469fc(rdram, ctx, runtime);
}

void entry_146b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146b8c inside entry_146b48 (0x146b48 - 0x146bc8)
    ctx->pc = 0x146b8c;
    entry_146b48(rdram, ctx, runtime);
}

void entry_146c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146c3c inside entry_146bc8 (0x146bc8 - 0x146c90)
    ctx->pc = 0x146c3c;
    entry_146bc8(rdram, ctx, runtime);
}

void entry_146c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146c40 inside entry_146bc8 (0x146bc8 - 0x146c90)
    ctx->pc = 0x146c40;
    entry_146bc8(rdram, ctx, runtime);
}

void entry_146c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146c70 inside entry_146bc8 (0x146bc8 - 0x146c90)
    ctx->pc = 0x146c70;
    entry_146bc8(rdram, ctx, runtime);
}

void entry_146ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146ca8 inside entry_146c90 (0x146c90 - 0x146ccc)
    ctx->pc = 0x146ca8;
    entry_146c90(rdram, ctx, runtime);
}

void entry_146cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146cd0 inside entry_146ccc (0x146ccc - 0x146d10)
    ctx->pc = 0x146cd0;
    entry_146ccc(rdram, ctx, runtime);
}

void entry_146da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146da0 inside entry_146d94 (0x146d94 - 0x146db0)
    ctx->pc = 0x146da0;
    entry_146d94(rdram, ctx, runtime);
}

void entry_146e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146e60 inside entry_146e48 (0x146e48 - 0x146f98)
    ctx->pc = 0x146e60;
    entry_146e48(rdram, ctx, runtime);
}

void entry_146f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146f24 inside entry_146e48 (0x146e48 - 0x146f98)
    ctx->pc = 0x146f24;
    entry_146e48(rdram, ctx, runtime);
}

void entry_146f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146f30 inside entry_146e48 (0x146e48 - 0x146f98)
    ctx->pc = 0x146f30;
    entry_146e48(rdram, ctx, runtime);
}

void entry_146f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146f70 inside entry_146e48 (0x146e48 - 0x146f98)
    ctx->pc = 0x146f70;
    entry_146e48(rdram, ctx, runtime);
}

void entry_146fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146fa8 inside entry_146f98 (0x146f98 - 0x147064)
    ctx->pc = 0x146fa8;
    entry_146f98(rdram, ctx, runtime);
}

void entry_146ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146ff4 inside entry_146f98 (0x146f98 - 0x147064)
    ctx->pc = 0x146ff4;
    entry_146f98(rdram, ctx, runtime);
}

void entry_146ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x146ffc inside entry_146f98 (0x146f98 - 0x147064)
    ctx->pc = 0x146ffc;
    entry_146f98(rdram, ctx, runtime);
}

void entry_147000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147000 inside entry_146f98 (0x146f98 - 0x147064)
    ctx->pc = 0x147000;
    entry_146f98(rdram, ctx, runtime);
}

void entry_147010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147010 inside entry_146f98 (0x146f98 - 0x147064)
    ctx->pc = 0x147010;
    entry_146f98(rdram, ctx, runtime);
}

void entry_1470d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1470d4 inside entry_147064 (0x147064 - 0x147124)
    ctx->pc = 0x1470d4;
    entry_147064(rdram, ctx, runtime);
}

void entry_147110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147110 inside entry_147064 (0x147064 - 0x147124)
    ctx->pc = 0x147110;
    entry_147064(rdram, ctx, runtime);
}

void entry_147114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147114 inside entry_147064 (0x147064 - 0x147124)
    ctx->pc = 0x147114;
    entry_147064(rdram, ctx, runtime);
}

void entry_147158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147158 inside entry_147124 (0x147124 - 0x14718c)
    ctx->pc = 0x147158;
    entry_147124(rdram, ctx, runtime);
}

void entry_147184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147184 inside entry_147124 (0x147124 - 0x14718c)
    ctx->pc = 0x147184;
    entry_147124(rdram, ctx, runtime);
}

void entry_147320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147320 inside entry_1472b0 (0x1472b0 - 0x147364)
    ctx->pc = 0x147320;
    entry_1472b0(rdram, ctx, runtime);
}

void entry_147354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147354 inside entry_1472b0 (0x1472b0 - 0x147364)
    ctx->pc = 0x147354;
    entry_1472b0(rdram, ctx, runtime);
}

void entry_14736c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14736c inside entry_147364 (0x147364 - 0x1473ac)
    ctx->pc = 0x14736c;
    entry_147364(rdram, ctx, runtime);
}

void entry_147370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147370 inside entry_147364 (0x147364 - 0x1473ac)
    ctx->pc = 0x147370;
    entry_147364(rdram, ctx, runtime);
}

void entry_1473c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1473c8 inside entry_1473c4 (0x1473c4 - 0x1473e0)
    ctx->pc = 0x1473c8;
    entry_1473c4(rdram, ctx, runtime);
}

void entry_1473cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1473cc inside entry_1473c4 (0x1473c4 - 0x1473e0)
    ctx->pc = 0x1473cc;
    entry_1473c4(rdram, ctx, runtime);
}

void entry_147418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147418 inside entry_147414 (0x147414 - 0x147428)
    ctx->pc = 0x147418;
    entry_147414(rdram, ctx, runtime);
}

void entry_14741c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14741c inside entry_147414 (0x147414 - 0x147428)
    ctx->pc = 0x14741c;
    entry_147414(rdram, ctx, runtime);
}

void entry_1474b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1474b0 inside entry_14747c (0x14747c - 0x1474cc)
    ctx->pc = 0x1474b0;
    entry_14747c(rdram, ctx, runtime);
}

void entry_147540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147540 inside entry_1474cc (0x1474cc - 0x147550)
    ctx->pc = 0x147540;
    entry_1474cc(rdram, ctx, runtime);
}

void entry_1475a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1475a8 inside entry_147588 (0x147588 - 0x147618)
    ctx->pc = 0x1475a8;
    entry_147588(rdram, ctx, runtime);
}

void entry_1475b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1475b0 inside entry_147588 (0x147588 - 0x147618)
    ctx->pc = 0x1475b0;
    entry_147588(rdram, ctx, runtime);
}

void entry_147634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147634 inside entry_147618 (0x147618 - 0x147698)
    ctx->pc = 0x147634;
    entry_147618(rdram, ctx, runtime);
}

void entry_147638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147638 inside entry_147618 (0x147618 - 0x147698)
    ctx->pc = 0x147638;
    entry_147618(rdram, ctx, runtime);
}

void entry_1476dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1476dc inside entry_147698 (0x147698 - 0x14771c)
    ctx->pc = 0x1476dc;
    entry_147698(rdram, ctx, runtime);
}

void entry_147714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147714 inside entry_147698 (0x147698 - 0x14771c)
    ctx->pc = 0x147714;
    entry_147698(rdram, ctx, runtime);
}

void entry_1477c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1477c0 inside entry_1477b0 (0x1477b0 - 0x147810)
    ctx->pc = 0x1477c0;
    entry_1477b0(rdram, ctx, runtime);
}

void entry_147814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147814 inside entry_147810 (0x147810 - 0x147828)
    ctx->pc = 0x147814;
    entry_147810(rdram, ctx, runtime);
}

void entry_14781c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14781c inside entry_147810 (0x147810 - 0x147828)
    ctx->pc = 0x14781c;
    entry_147810(rdram, ctx, runtime);
}

void entry_147830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147830 inside entry_147828 (0x147828 - 0x147874)
    ctx->pc = 0x147830;
    entry_147828(rdram, ctx, runtime);
}

void entry_147994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147994 inside RenderDprizeAll__FP6DPRIZEP2CMP2RO (0x1478f0 - 0x147a40)
    ctx->pc = 0x147994;
    RenderDprizeAll__FP6DPRIZEP2CMP2RO(rdram, ctx, runtime);
}

void entry_1479a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1479a4 inside RenderDprizeAll__FP6DPRIZEP2CMP2RO (0x1478f0 - 0x147a40)
    ctx->pc = 0x1479a4;
    RenderDprizeAll__FP6DPRIZEP2CMP2RO(rdram, ctx, runtime);
}

void entry_1479ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1479ec inside RenderDprizeAll__FP6DPRIZEP2CMP2RO (0x1478f0 - 0x147a40)
    ctx->pc = 0x1479ec;
    RenderDprizeAll__FP6DPRIZEP2CMP2RO(rdram, ctx, runtime);
}

void entry_1479f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1479f8 inside RenderDprizeAll__FP6DPRIZEP2CMP2RO (0x1478f0 - 0x147a40)
    ctx->pc = 0x1479f8;
    RenderDprizeAll__FP6DPRIZEP2CMP2RO(rdram, ctx, runtime);
}

void entry_147a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147a84 inside entry_147a60 (0x147a60 - 0x147a94)
    ctx->pc = 0x147a84;
    entry_147a60(rdram, ctx, runtime);
}

void entry_147a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147a88 inside entry_147a60 (0x147a60 - 0x147a94)
    ctx->pc = 0x147a88;
    entry_147a60(rdram, ctx, runtime);
}

void entry_147b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147b34 inside entry_147b0c (0x147b0c - 0x147be0)
    ctx->pc = 0x147b34;
    entry_147b0c(rdram, ctx, runtime);
}

void entry_147b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147b48 inside entry_147b0c (0x147b0c - 0x147be0)
    ctx->pc = 0x147b48;
    entry_147b0c(rdram, ctx, runtime);
}

void entry_147b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147b58 inside entry_147b0c (0x147b0c - 0x147be0)
    ctx->pc = 0x147b58;
    entry_147b0c(rdram, ctx, runtime);
}

void entry_147b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147b5c inside entry_147b0c (0x147b0c - 0x147be0)
    ctx->pc = 0x147b5c;
    entry_147b0c(rdram, ctx, runtime);
}

void entry_147bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147bd4 inside entry_147b0c (0x147b0c - 0x147be0)
    ctx->pc = 0x147bd4;
    entry_147b0c(rdram, ctx, runtime);
}

void entry_147d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d30 inside entry_147cf8 (0x147cf8 - 0x147d64)
    ctx->pc = 0x147d30;
    entry_147cf8(rdram, ctx, runtime);
}

void entry_147d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d34 inside entry_147cf8 (0x147cf8 - 0x147d64)
    ctx->pc = 0x147d34;
    entry_147cf8(rdram, ctx, runtime);
}

void entry_147d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d38 inside entry_147cf8 (0x147cf8 - 0x147d64)
    ctx->pc = 0x147d38;
    entry_147cf8(rdram, ctx, runtime);
}

void entry_147d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d3c inside entry_147cf8 (0x147cf8 - 0x147d64)
    ctx->pc = 0x147d3c;
    entry_147cf8(rdram, ctx, runtime);
}

void entry_147d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d4c inside entry_147cf8 (0x147cf8 - 0x147d64)
    ctx->pc = 0x147d4c;
    entry_147cf8(rdram, ctx, runtime);
}

void entry_147d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d6c inside entry_147d64 (0x147d64 - 0x147d78)
    ctx->pc = 0x147d6c;
    entry_147d64(rdram, ctx, runtime);
}

void entry_147d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d80 inside entry_147d78 (0x147d78 - 0x147d98)
    ctx->pc = 0x147d80;
    entry_147d78(rdram, ctx, runtime);
}

void entry_147d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147d9c inside entry_147d98 (0x147d98 - 0x147dcc)
    ctx->pc = 0x147d9c;
    entry_147d98(rdram, ctx, runtime);
}

void entry_147df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147df4 inside entry_147dec (0x147dec - 0x147dfc)
    ctx->pc = 0x147df4;
    entry_147dec(rdram, ctx, runtime);
}

void entry_147e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147e04 inside entry_147dfc (0x147dfc - 0x147e18)
    ctx->pc = 0x147e04;
    entry_147dfc(rdram, ctx, runtime);
}

void entry_147e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147e1c inside entry_147e18 (0x147e18 - 0x147e40)
    ctx->pc = 0x147e1c;
    entry_147e18(rdram, ctx, runtime);
}

void entry_147e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147e20 inside entry_147e18 (0x147e18 - 0x147e40)
    ctx->pc = 0x147e20;
    entry_147e18(rdram, ctx, runtime);
}

void entry_147f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147f9c inside entry_147f98 (0x147f98 - 0x147fb0)
    ctx->pc = 0x147f9c;
    entry_147f98(rdram, ctx, runtime);
}

void entry_147fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147fa0 inside entry_147f98 (0x147f98 - 0x147fb0)
    ctx->pc = 0x147fa0;
    entry_147f98(rdram, ctx, runtime);
}

void entry_147ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x147ffc inside entry_147fc4 (0x147fc4 - 0x148024)
    ctx->pc = 0x147ffc;
    entry_147fc4(rdram, ctx, runtime);
}

void entry_148028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148028 inside entry_148024 (0x148024 - 0x148038)
    ctx->pc = 0x148028;
    entry_148024(rdram, ctx, runtime);
}

void entry_14808c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14808c inside entry_148070 (0x148070 - 0x14809c)
    ctx->pc = 0x14808c;
    entry_148070(rdram, ctx, runtime);
}

void entry_148224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148224 inside entry_1481dc (0x1481dc - 0x14826c)
    ctx->pc = 0x148224;
    entry_1481dc(rdram, ctx, runtime);
}

void entry_148274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148274 inside entry_14826c (0x14826c - 0x148298)
    ctx->pc = 0x148274;
    entry_14826c(rdram, ctx, runtime);
}

void entry_14827c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14827c inside entry_14826c (0x14826c - 0x148298)
    ctx->pc = 0x14827c;
    entry_14826c(rdram, ctx, runtime);
}

void entry_148280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148280 inside entry_14826c (0x14826c - 0x148298)
    ctx->pc = 0x148280;
    entry_14826c(rdram, ctx, runtime);
}

void entry_1482d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1482d4 inside SetCoinDprizes__FP4COIN7DPRIZES (0x148298 - 0x1482ec)
    ctx->pc = 0x1482d4;
    SetCoinDprizes__FP4COIN7DPRIZES(rdram, ctx, runtime);
}

void entry_1482f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1482f4 inside entry_1482ec (0x1482ec - 0x148300)
    ctx->pc = 0x1482f4;
    entry_1482ec(rdram, ctx, runtime);
}

void entry_148358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148358 inside entry_148338 (0x148338 - 0x148360)
    ctx->pc = 0x148358;
    entry_148338(rdram, ctx, runtime);
}

void entry_1483e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1483e0 inside entry_1483dc (0x1483dc - 0x1483ec)
    ctx->pc = 0x1483e0;
    entry_1483dc(rdram, ctx, runtime);
}

void entry_1483e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1483e4 inside entry_1483dc (0x1483dc - 0x1483ec)
    ctx->pc = 0x1483e4;
    entry_1483dc(rdram, ctx, runtime);
}

void entry_1483f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1483f0 inside entry_1483ec (0x1483ec - 0x148400)
    ctx->pc = 0x1483f0;
    entry_1483ec(rdram, ctx, runtime);
}

void entry_1484f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1484f4 inside entry_1484f0 (0x1484f0 - 0x1484fc)
    ctx->pc = 0x1484f4;
    entry_1484f0(rdram, ctx, runtime);
}

void entry_148588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148588 inside entry_148524 (0x148524 - 0x148598)
    ctx->pc = 0x148588;
    entry_148524(rdram, ctx, runtime);
}

void entry_148608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148608 inside SetKeyDprizes__FP3KEY7DPRIZES (0x148598 - 0x14861c)
    ctx->pc = 0x148608;
    SetKeyDprizes__FP3KEY7DPRIZES(rdram, ctx, runtime);
}

void entry_14860c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14860c inside SetKeyDprizes__FP3KEY7DPRIZES (0x148598 - 0x14861c)
    ctx->pc = 0x14860c;
    SetKeyDprizes__FP3KEY7DPRIZES(rdram, ctx, runtime);
}

void entry_148648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148648 inside entry_148644 (0x148644 - 0x148658)
    ctx->pc = 0x148648;
    entry_148644(rdram, ctx, runtime);
}

void entry_148678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148678 inside entry_148674 (0x148674 - 0x148680)
    ctx->pc = 0x148678;
    entry_148674(rdram, ctx, runtime);
}

void entry_14870c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14870c inside entry_1486ac (0x1486ac - 0x148718)
    ctx->pc = 0x14870c;
    entry_1486ac(rdram, ctx, runtime);
}

void entry_148814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148814 inside entry_148810 (0x148810 - 0x148828)
    ctx->pc = 0x148814;
    entry_148810(rdram, ctx, runtime);
}

void entry_148818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148818 inside entry_148810 (0x148810 - 0x148828)
    ctx->pc = 0x148818;
    entry_148810(rdram, ctx, runtime);
}

void entry_14887c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14887c inside entry_148878 (0x148878 - 0x148888)
    ctx->pc = 0x14887c;
    entry_148878(rdram, ctx, runtime);
}

void entry_1488f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1488f0 inside entry_1488e8 (0x1488e8 - 0x1488f8)
    ctx->pc = 0x1488f0;
    entry_1488e8(rdram, ctx, runtime);
}

void entry_14892c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14892c inside FUN_00148910__FPfT0 (0x148910 - 0x148938)
    ctx->pc = 0x14892c;
    FUN_00148910__FPfT0(rdram, ctx, runtime);
}

void entry_148974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148974 inside FUN_00148938 (0x148938 - 0x14897c)
    ctx->pc = 0x148974;
    FUN_00148938(rdram, ctx, runtime);
}

void entry_148998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148998 inside entry_148984 (0x148984 - 0x1489ac)
    ctx->pc = 0x148998;
    entry_148984(rdram, ctx, runtime);
}

void entry_1489d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1489d8 inside entry_1489b4 (0x1489b4 - 0x148a58)
    ctx->pc = 0x1489d8;
    entry_1489b4(rdram, ctx, runtime);
}

void entry_148a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a10 inside entry_1489b4 (0x1489b4 - 0x148a58)
    ctx->pc = 0x148a10;
    entry_1489b4(rdram, ctx, runtime);
}

void entry_148a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a34 inside entry_1489b4 (0x1489b4 - 0x148a58)
    ctx->pc = 0x148a34;
    entry_1489b4(rdram, ctx, runtime);
}

void entry_148a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a38 inside entry_1489b4 (0x1489b4 - 0x148a58)
    ctx->pc = 0x148a38;
    entry_1489b4(rdram, ctx, runtime);
}

void entry_148a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a40 inside entry_1489b4 (0x1489b4 - 0x148a58)
    ctx->pc = 0x148a40;
    entry_1489b4(rdram, ctx, runtime);
}

void entry_148a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a70 inside entry_148a58 (0x148a58 - 0x148a94)
    ctx->pc = 0x148a70;
    entry_148a58(rdram, ctx, runtime);
}

void entry_148a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a8c inside entry_148a58 (0x148a58 - 0x148a94)
    ctx->pc = 0x148a8c;
    entry_148a58(rdram, ctx, runtime);
}

void entry_148a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148a98 inside entry_148a94 (0x148a94 - 0x148ac0)
    ctx->pc = 0x148a98;
    entry_148a94(rdram, ctx, runtime);
}

void entry_148b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148b28 inside entry_148b20 (0x148b20 - 0x148b38)
    ctx->pc = 0x148b28;
    entry_148b20(rdram, ctx, runtime);
}

void entry_148b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148b80 inside entry_148b60 (0x148b60 - 0x148b98)
    ctx->pc = 0x148b80;
    entry_148b60(rdram, ctx, runtime);
}

void entry_148c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148c98 inside entry_148c8c (0x148c8c - 0x148ca0)
    ctx->pc = 0x148c98;
    entry_148c8c(rdram, ctx, runtime);
}

void entry_148d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148d40 inside entry_148d20 (0x148d20 - 0x148d58)
    ctx->pc = 0x148d40;
    entry_148d20(rdram, ctx, runtime);
}

void entry_148d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148d50 inside entry_148d20 (0x148d20 - 0x148d58)
    ctx->pc = 0x148d50;
    entry_148d20(rdram, ctx, runtime);
}

void entry_148d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148d80 inside entry_148d70 (0x148d70 - 0x148d90)
    ctx->pc = 0x148d80;
    entry_148d70(rdram, ctx, runtime);
}

void entry_148ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148ee4 inside entry_148ee0 (0x148ee0 - 0x148ef8)
    ctx->pc = 0x148ee4;
    entry_148ee0(rdram, ctx, runtime);
}

void entry_148ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148ee8 inside entry_148ee0 (0x148ee0 - 0x148ef8)
    ctx->pc = 0x148ee8;
    entry_148ee0(rdram, ctx, runtime);
}

void entry_148f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148f44 inside entry_148f0c (0x148f0c - 0x148f6c)
    ctx->pc = 0x148f44;
    entry_148f0c(rdram, ctx, runtime);
}

void entry_148f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148f70 inside entry_148f6c (0x148f6c - 0x148f80)
    ctx->pc = 0x148f70;
    entry_148f6c(rdram, ctx, runtime);
}

void entry_148fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148fd8 inside entry_148fa4 (0x148fa4 - 0x148ff0)
    ctx->pc = 0x148fd8;
    entry_148fa4(rdram, ctx, runtime);
}

void entry_148fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x148fe0 inside entry_148fa4 (0x148fa4 - 0x148ff0)
    ctx->pc = 0x148fe0;
    entry_148fa4(rdram, ctx, runtime);
}

void entry_14902c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14902c inside CollectLifetkn__FP7LIFETKN (0x148ff0 - 0x149044)
    ctx->pc = 0x14902c;
    CollectLifetkn__FP7LIFETKN(rdram, ctx, runtime);
}

void entry_14904c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14904c inside entry_149044 (0x149044 - 0x149058)
    ctx->pc = 0x14904c;
    entry_149044(rdram, ctx, runtime);
}

void entry_1490b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1490b0 inside entry_149090 (0x149090 - 0x1490b8)
    ctx->pc = 0x1490b0;
    entry_149090(rdram, ctx, runtime);
}

void entry_149148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149148 inside entry_149144 (0x149144 - 0x149154)
    ctx->pc = 0x149148;
    entry_149144(rdram, ctx, runtime);
}

void entry_14914c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14914c inside entry_149144 (0x149144 - 0x149154)
    ctx->pc = 0x14914c;
    entry_149144(rdram, ctx, runtime);
}

void entry_149158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149158 inside entry_149154 (0x149154 - 0x149168)
    ctx->pc = 0x149158;
    entry_149154(rdram, ctx, runtime);
}

void entry_149208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149208 inside entry_1491f0 (0x1491f0 - 0x149274)
    ctx->pc = 0x149208;
    entry_1491f0(rdram, ctx, runtime);
}

void entry_1492ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1492ac inside entry_149284 (0x149284 - 0x1492e8)
    ctx->pc = 0x1492ac;
    entry_149284(rdram, ctx, runtime);
}

void entry_14936c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14936c inside entry_149368 (0x149368 - 0x149398)
    ctx->pc = 0x14936c;
    entry_149368(rdram, ctx, runtime);
}

void entry_149374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149374 inside entry_149368 (0x149368 - 0x149398)
    ctx->pc = 0x149374;
    entry_149368(rdram, ctx, runtime);
}

void entry_1493f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1493f4 inside entry_1493ec (0x1493ec - 0x1493fc)
    ctx->pc = 0x1493f4;
    entry_1493ec(rdram, ctx, runtime);
}

void entry_14942c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14942c inside entry_14940c (0x14940c - 0x149458)
    ctx->pc = 0x14942c;
    entry_14940c(rdram, ctx, runtime);
}

void entry_149438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149438 inside entry_14940c (0x14940c - 0x149458)
    ctx->pc = 0x149438;
    entry_14940c(rdram, ctx, runtime);
}

void entry_14943c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14943c inside entry_14940c (0x14940c - 0x149458)
    ctx->pc = 0x14943c;
    entry_14940c(rdram, ctx, runtime);
}

void entry_14949c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14949c inside FUN_00149458 (0x149458 - 0x1494b4)
    ctx->pc = 0x14949c;
    FUN_00149458(rdram, ctx, runtime);
}

void entry_1494a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1494a0 inside FUN_00149458 (0x149458 - 0x1494b4)
    ctx->pc = 0x1494a0;
    FUN_00149458(rdram, ctx, runtime);
}

void entry_1494a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1494a4 inside FUN_00149458 (0x149458 - 0x1494b4)
    ctx->pc = 0x1494a4;
    FUN_00149458(rdram, ctx, runtime);
}

void entry_149590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149590 inside entry_14958c (0x14958c - 0x1495bc)
    ctx->pc = 0x149590;
    entry_14958c(rdram, ctx, runtime);
}

void entry_149608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149608 inside PushCplookLookk__FP6CPLOOK5LOOKK (0x1495e8 - 0x149610)
    ctx->pc = 0x149608;
    PushCplookLookk__FP6CPLOOK5LOOKK(rdram, ctx, runtime);
}

void entry_149630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149630 inside LookkPopCplook__FP6CPLOOK (0x149610 - 0x149638)
    ctx->pc = 0x149630;
    LookkPopCplook__FP6CPLOOK(rdram, ctx, runtime);
}

void entry_149654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149654 inside LookkCurCplook__FP6CPLOOK (0x149638 - 0x149660)
    ctx->pc = 0x149654;
    LookkCurCplook__FP6CPLOOK(rdram, ctx, runtime);
}

void entry_149874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149874 inside entry_1497e8 (0x1497e8 - 0x149900)
    ctx->pc = 0x149874;
    entry_1497e8(rdram, ctx, runtime);
}

void entry_149884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149884 inside entry_1497e8 (0x1497e8 - 0x149900)
    ctx->pc = 0x149884;
    entry_1497e8(rdram, ctx, runtime);
}

void entry_1498b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1498b8 inside entry_1497e8 (0x1497e8 - 0x149900)
    ctx->pc = 0x1498b8;
    entry_1497e8(rdram, ctx, runtime);
}

void entry_149a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149a58 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149a58;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149a5c inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149a5c;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149a88 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149a88;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149a94 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149a94;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149ab8 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149ab8;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149ac8 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149ac8;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149af4 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149af4;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149b00 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149b00;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149b04 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149b04;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149b58 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149b58;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149b94 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149b94;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149c34 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149c34;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149c38 inside entry_149a44 (0x149a44 - 0x149c4c)
    ctx->pc = 0x149c38;
    entry_149a44(rdram, ctx, runtime);
}

void entry_149c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149c54 inside entry_149c4c (0x149c4c - 0x149c74)
    ctx->pc = 0x149c54;
    entry_149c4c(rdram, ctx, runtime);
}

void entry_149ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149ca0 inside entry_149c74 (0x149c74 - 0x149cd8)
    ctx->pc = 0x149ca0;
    entry_149c74(rdram, ctx, runtime);
}

void entry_149cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149cb0 inside entry_149c74 (0x149c74 - 0x149cd8)
    ctx->pc = 0x149cb0;
    entry_149c74(rdram, ctx, runtime);
}

void entry_149d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d08 inside entry_149cd8 (0x149cd8 - 0x149d54)
    ctx->pc = 0x149d08;
    entry_149cd8(rdram, ctx, runtime);
}

void entry_149d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d0c inside entry_149cd8 (0x149cd8 - 0x149d54)
    ctx->pc = 0x149d0c;
    entry_149cd8(rdram, ctx, runtime);
}

void entry_149d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d20 inside entry_149cd8 (0x149cd8 - 0x149d54)
    ctx->pc = 0x149d20;
    entry_149cd8(rdram, ctx, runtime);
}

void entry_149d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d5c inside entry_149d54 (0x149d54 - 0x149d9c)
    ctx->pc = 0x149d5c;
    entry_149d54(rdram, ctx, runtime);
}

void entry_149d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d84 inside entry_149d54 (0x149d54 - 0x149d9c)
    ctx->pc = 0x149d84;
    entry_149d54(rdram, ctx, runtime);
}

void entry_149d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149d94 inside entry_149d54 (0x149d54 - 0x149d9c)
    ctx->pc = 0x149d94;
    entry_149d54(rdram, ctx, runtime);
}

void entry_149dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149dd4 inside entry_149d9c (0x149d9c - 0x149dec)
    ctx->pc = 0x149dd4;
    entry_149d9c(rdram, ctx, runtime);
}

void entry_149de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149de4 inside entry_149d9c (0x149d9c - 0x149dec)
    ctx->pc = 0x149de4;
    entry_149d9c(rdram, ctx, runtime);
}

void entry_149df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149df4 inside entry_149dec (0x149dec - 0x149e04)
    ctx->pc = 0x149df4;
    entry_149dec(rdram, ctx, runtime);
}

void entry_149e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149e0c inside entry_149e04 (0x149e04 - 0x149e4c)
    ctx->pc = 0x149e0c;
    entry_149e04(rdram, ctx, runtime);
}

void entry_149e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149e64 inside entry_149e60 (0x149e60 - 0x149ea0)
    ctx->pc = 0x149e64;
    entry_149e60(rdram, ctx, runtime);
}

void entry_149ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149ef0 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149ef0;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149ef4 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149ef4;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149f30 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149f30;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149f68 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149f68;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149f90 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149f90;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149fb8 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149fb8;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149fbc inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149fbc;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_149fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x149fd4 inside entry_149ecc (0x149ecc - 0x149ff4)
    ctx->pc = 0x149fd4;
    entry_149ecc(rdram, ctx, runtime);
}

void entry_14a0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a0a8 inside entry_14a070 (0x14a070 - 0x14a0c8)
    ctx->pc = 0x14a0a8;
    entry_14a070(rdram, ctx, runtime);
}

void entry_14a0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a0b8 inside entry_14a070 (0x14a070 - 0x14a0c8)
    ctx->pc = 0x14a0b8;
    entry_14a070(rdram, ctx, runtime);
}

void entry_14a114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a114 inside entry_14a0c8 (0x14a0c8 - 0x14a164)
    ctx->pc = 0x14a114;
    entry_14a0c8(rdram, ctx, runtime);
}

void entry_14a138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a138 inside entry_14a0c8 (0x14a0c8 - 0x14a164)
    ctx->pc = 0x14a138;
    entry_14a0c8(rdram, ctx, runtime);
}

void entry_14a190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a190 inside entry_14a170 (0x14a170 - 0x14a1f8)
    ctx->pc = 0x14a190;
    entry_14a170(rdram, ctx, runtime);
}

void entry_14a220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a220 inside entry_14a1f8 (0x14a1f8 - 0x14a268)
    ctx->pc = 0x14a220;
    entry_14a1f8(rdram, ctx, runtime);
}

void entry_14a228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a228 inside entry_14a1f8 (0x14a1f8 - 0x14a268)
    ctx->pc = 0x14a228;
    entry_14a1f8(rdram, ctx, runtime);
}

void entry_14a270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a270 inside entry_14a268 (0x14a268 - 0x14a284)
    ctx->pc = 0x14a270;
    entry_14a268(rdram, ctx, runtime);
}

void entry_14a3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a3d8 inside entry_14a37c (0x14a37c - 0x14a3e4)
    ctx->pc = 0x14a3d8;
    entry_14a37c(rdram, ctx, runtime);
}

void entry_14a3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a3ec inside entry_14a3e4 (0x14a3e4 - 0x14a4c8)
    ctx->pc = 0x14a3ec;
    entry_14a3e4(rdram, ctx, runtime);
}

void entry_14a42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a42c inside entry_14a3e4 (0x14a3e4 - 0x14a4c8)
    ctx->pc = 0x14a42c;
    entry_14a3e4(rdram, ctx, runtime);
}

void entry_14a440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a440 inside entry_14a3e4 (0x14a3e4 - 0x14a4c8)
    ctx->pc = 0x14a440;
    entry_14a3e4(rdram, ctx, runtime);
}

void entry_14a45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a45c inside entry_14a3e4 (0x14a3e4 - 0x14a4c8)
    ctx->pc = 0x14a45c;
    entry_14a3e4(rdram, ctx, runtime);
}

void entry_14a504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a504 inside entry_14a4c8 (0x14a4c8 - 0x14a594)
    ctx->pc = 0x14a504;
    entry_14a4c8(rdram, ctx, runtime);
}

void entry_14a54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a54c inside entry_14a4c8 (0x14a4c8 - 0x14a594)
    ctx->pc = 0x14a54c;
    entry_14a4c8(rdram, ctx, runtime);
}

void entry_14a704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a704 inside entry_14a6f8 (0x14a6f8 - 0x14a76c)
    ctx->pc = 0x14a704;
    entry_14a6f8(rdram, ctx, runtime);
}

void entry_14a770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a770 inside entry_14a76c (0x14a76c - 0x14a7b8)
    ctx->pc = 0x14a770;
    entry_14a76c(rdram, ctx, runtime);
}

void entry_14a774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a774 inside entry_14a76c (0x14a76c - 0x14a7b8)
    ctx->pc = 0x14a774;
    entry_14a76c(rdram, ctx, runtime);
}

void entry_14a778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a778 inside entry_14a76c (0x14a76c - 0x14a7b8)
    ctx->pc = 0x14a778;
    entry_14a76c(rdram, ctx, runtime);
}

void entry_14a848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a848 inside entry_14a844 (0x14a844 - 0x14a870)
    ctx->pc = 0x14a848;
    entry_14a844(rdram, ctx, runtime);
}

void entry_14a874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14a874 inside entry_14a870 (0x14a870 - 0x14a888)
    ctx->pc = 0x14a874;
    entry_14a870(rdram, ctx, runtime);
}

void entry_14aa08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14aa08 inside UpdateCpalign (0x14a8f8 - 0x14aa80)
    ctx->pc = 0x14aa08;
    UpdateCpalign(rdram, ctx, runtime);
}

void entry_14aaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14aaf8 inside entry_14aad0 (0x14aad0 - 0x14ab0c)
    ctx->pc = 0x14aaf8;
    entry_14aad0(rdram, ctx, runtime);
}

void entry_14ab28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ab28 inside entry_14ab0c (0x14ab0c - 0x14ab30)
    ctx->pc = 0x14ab28;
    entry_14ab0c(rdram, ctx, runtime);
}

void entry_14ab38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ab38 inside entry_14ab30 (0x14ab30 - 0x14ab44)
    ctx->pc = 0x14ab38;
    entry_14ab30(rdram, ctx, runtime);
}

void entry_14abac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14abac inside entry_14ab44 (0x14ab44 - 0x14abb8)
    ctx->pc = 0x14abac;
    entry_14ab44(rdram, ctx, runtime);
}

void entry_14ac08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ac08 inside entry_14abfc (0x14abfc - 0x14ac20)
    ctx->pc = 0x14ac08;
    entry_14abfc(rdram, ctx, runtime);
}

void entry_14ac88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ac88 inside entry_14ac7c (0x14ac7c - 0x14ac98)
    ctx->pc = 0x14ac88;
    entry_14ac7c(rdram, ctx, runtime);
}

void entry_14ad30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ad30 inside entry_14ad24 (0x14ad24 - 0x14ad48)
    ctx->pc = 0x14ad30;
    entry_14ad24(rdram, ctx, runtime);
}

void entry_14ada0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ada0 inside entry_14ad90 (0x14ad90 - 0x14adb4)
    ctx->pc = 0x14ada0;
    entry_14ad90(rdram, ctx, runtime);
}

void entry_14adc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14adc4 inside entry_14adb4 (0x14adb4 - 0x14ade0)
    ctx->pc = 0x14adc4;
    entry_14adb4(rdram, ctx, runtime);
}

void entry_14ae30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ae30 inside DrawCredit__FP6CREDIT (0x14ade0 - 0x14ae60)
    ctx->pc = 0x14ae30;
    DrawCredit__FP6CREDIT(rdram, ctx, runtime);
}

void entry_14ae7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ae7c inside entry_14ae60 (0x14ae60 - 0x14aea0)
    ctx->pc = 0x14ae7c;
    entry_14ae60(rdram, ctx, runtime);
}

void entry_14af90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14af90 inside SetCreditLine__FP6CREDITiPcf (0x14af38 - 0x14afbc)
    ctx->pc = 0x14af90;
    SetCreditLine__FP6CREDITiPcf(rdram, ctx, runtime);
}

void entry_14af9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14af9c inside SetCreditLine__FP6CREDITiPcf (0x14af38 - 0x14afbc)
    ctx->pc = 0x14af9c;
    SetCreditLine__FP6CREDITiPcf(rdram, ctx, runtime);
}

void entry_14afac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14afac inside SetCreditLine__FP6CREDITiPcf (0x14af38 - 0x14afbc)
    ctx->pc = 0x14afac;
    SetCreditLine__FP6CREDITiPcf(rdram, ctx, runtime);
}

void entry_14afd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14afd0 inside entry_14afbc (0x14afbc - 0x14b018)
    ctx->pc = 0x14afd0;
    entry_14afbc(rdram, ctx, runtime);
}

void entry_14afec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14afec inside entry_14afbc (0x14afbc - 0x14b018)
    ctx->pc = 0x14afec;
    entry_14afbc(rdram, ctx, runtime);
}

void entry_14b080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b080 inside entry_14b05c (0x14b05c - 0x14b088)
    ctx->pc = 0x14b080;
    entry_14b05c(rdram, ctx, runtime);
}

void entry_14b09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b09c inside entry_14b098 (0x14b098 - 0x14b0c0)
    ctx->pc = 0x14b09c;
    entry_14b098(rdram, ctx, runtime);
}

void entry_14b0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b0e0 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b0e0;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b0fc inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b0fc;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b130 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b130;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b154 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b154;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b170 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b170;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b190 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b190;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b194 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b194;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b1b0 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b1b0;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b1c8 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b1c8;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b1e8 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b1e8;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b208 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b208;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b230 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b230;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b278 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b278;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b29c inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b29c;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b2b8 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b2b8;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b2e0 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b2e0;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b300 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b300;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b334 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b334;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b338 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b338;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b344 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b344;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b368 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b368;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b398 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b398;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b3d8 inside CroutDecomp__FiPfT1 (0x14b0c0 - 0x14b3e0)
    ctx->pc = 0x14b3d8;
    CroutDecomp__FiPfT1(rdram, ctx, runtime);
}

void entry_14b3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b3f8 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b3f8;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b428 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b428;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b448 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b448;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b468 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b468;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b494 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b494;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b4a4 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b4a4;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b4b8 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b4b8;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b508 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b508;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b528 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b528;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b538 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b538;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b544 inside CroutSolve__FiPfN21 (0x14b3e0 - 0x14b550)
    ctx->pc = 0x14b544;
    CroutSolve__FiPfN21(rdram, ctx, runtime);
}

void entry_14b73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b73c inside UpdateCrfodbGoal__FP6CRFODBi (0x14b6a8 - 0x14b7a4)
    ctx->pc = 0x14b73c;
    UpdateCrfodbGoal__FP6CRFODBi(rdram, ctx, runtime);
}

void entry_14b798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b798 inside UpdateCrfodbGoal__FP6CRFODBi (0x14b6a8 - 0x14b7a4)
    ctx->pc = 0x14b798;
    UpdateCrfodbGoal__FP6CRFODBi(rdram, ctx, runtime);
}

void entry_14b800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b800 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b800;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b810 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b810;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b834 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b834;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b840 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b840;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b87c inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b87c;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b890 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b890;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b8a0 inside entry_14b7e4 (0x14b7e4 - 0x14b8b0)
    ctx->pc = 0x14b8a0;
    entry_14b7e4(rdram, ctx, runtime);
}

void entry_14b938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b938 inside entry_14b8f8 (0x14b8f8 - 0x14b9c4)
    ctx->pc = 0x14b938;
    entry_14b8f8(rdram, ctx, runtime);
}

void entry_14b948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b948 inside entry_14b8f8 (0x14b8f8 - 0x14b9c4)
    ctx->pc = 0x14b948;
    entry_14b8f8(rdram, ctx, runtime);
}

void entry_14b94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b94c inside entry_14b8f8 (0x14b8f8 - 0x14b9c4)
    ctx->pc = 0x14b94c;
    entry_14b8f8(rdram, ctx, runtime);
}

void entry_14b954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b954 inside entry_14b8f8 (0x14b8f8 - 0x14b9c4)
    ctx->pc = 0x14b954;
    entry_14b8f8(rdram, ctx, runtime);
}

void entry_14b980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b980 inside entry_14b8f8 (0x14b8f8 - 0x14b9c4)
    ctx->pc = 0x14b980;
    entry_14b8f8(rdram, ctx, runtime);
}

void entry_14b9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14b9fc inside entry_14b9c4 (0x14b9c4 - 0x14ba30)
    ctx->pc = 0x14b9fc;
    entry_14b9c4(rdram, ctx, runtime);
}

void entry_14ba0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba0c inside entry_14b9c4 (0x14b9c4 - 0x14ba30)
    ctx->pc = 0x14ba0c;
    entry_14b9c4(rdram, ctx, runtime);
}

void entry_14ba10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba10 inside entry_14b9c4 (0x14b9c4 - 0x14ba30)
    ctx->pc = 0x14ba10;
    entry_14b9c4(rdram, ctx, runtime);
}

void entry_14ba1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba1c inside entry_14b9c4 (0x14b9c4 - 0x14ba30)
    ctx->pc = 0x14ba1c;
    entry_14b9c4(rdram, ctx, runtime);
}

void entry_14ba24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba24 inside entry_14b9c4 (0x14b9c4 - 0x14ba30)
    ctx->pc = 0x14ba24;
    entry_14b9c4(rdram, ctx, runtime);
}

void entry_14ba64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba64 inside entry_14ba30 (0x14ba30 - 0x14ba6c)
    ctx->pc = 0x14ba64;
    entry_14ba30(rdram, ctx, runtime);
}

void entry_14ba8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ba8c inside entry_14ba84 (0x14ba84 - 0x14baa0)
    ctx->pc = 0x14ba8c;
    entry_14ba84(rdram, ctx, runtime);
}

void entry_14baa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14baa8 inside entry_14baa0 (0x14baa0 - 0x14bab0)
    ctx->pc = 0x14baa8;
    entry_14baa0(rdram, ctx, runtime);
}

void entry_14bab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bab4 inside entry_14bab0 (0x14bab0 - 0x14bb08)
    ctx->pc = 0x14bab4;
    entry_14bab0(rdram, ctx, runtime);
}

void entry_14bb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bb44 inside entry_14bb20 (0x14bb20 - 0x14bb5c)
    ctx->pc = 0x14bb44;
    entry_14bb20(rdram, ctx, runtime);
}

void entry_14bb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bb68 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bb68;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bb70 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bb70;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bbc8 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bbc8;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bc34 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bc34;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bc40 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bc40;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bc90 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bc90;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bc9c inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bc9c;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bcd4 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bcd4;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bcd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bcd8 inside entry_14bb5c (0x14bb5c - 0x14bce8)
    ctx->pc = 0x14bcd8;
    entry_14bb5c(rdram, ctx, runtime);
}

void entry_14bd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bd24 inside entry_14bd18 (0x14bd18 - 0x14bd38)
    ctx->pc = 0x14bd24;
    entry_14bd18(rdram, ctx, runtime);
}

void entry_14bd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bd28 inside entry_14bd18 (0x14bd18 - 0x14bd38)
    ctx->pc = 0x14bd28;
    entry_14bd18(rdram, ctx, runtime);
}

void entry_14bd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bd6c inside entry_14bd4c (0x14bd4c - 0x14bd7c)
    ctx->pc = 0x14bd6c;
    entry_14bd4c(rdram, ctx, runtime);
}

void entry_14bd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bd94 inside entry_14bd7c (0x14bd7c - 0x14bdb8)
    ctx->pc = 0x14bd94;
    entry_14bd7c(rdram, ctx, runtime);
}

void entry_14bda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bda8 inside entry_14bd7c (0x14bd7c - 0x14bdb8)
    ctx->pc = 0x14bda8;
    entry_14bd7c(rdram, ctx, runtime);
}

void entry_14bdbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bdbc inside entry_14bdb8 (0x14bdb8 - 0x14bdc8)
    ctx->pc = 0x14bdbc;
    entry_14bdb8(rdram, ctx, runtime);
}

void entry_14bdc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bdc0 inside entry_14bdb8 (0x14bdb8 - 0x14bdc8)
    ctx->pc = 0x14bdc0;
    entry_14bdb8(rdram, ctx, runtime);
}

void entry_14be50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14be50 inside entry_14be3c (0x14be3c - 0x14be60)
    ctx->pc = 0x14be50;
    entry_14be3c(rdram, ctx, runtime);
}

void entry_14be90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14be90 inside entry_14be84 (0x14be84 - 0x14bea8)
    ctx->pc = 0x14be90;
    entry_14be84(rdram, ctx, runtime);
}

void entry_14be94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14be94 inside entry_14be84 (0x14be84 - 0x14bea8)
    ctx->pc = 0x14be94;
    entry_14be84(rdram, ctx, runtime);
}

void entry_14bee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bee0 inside entry_14bec0 (0x14bec0 - 0x14bef8)
    ctx->pc = 0x14bee0;
    entry_14bec0(rdram, ctx, runtime);
}

void entry_14bee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bee4 inside entry_14bec0 (0x14bec0 - 0x14bef8)
    ctx->pc = 0x14bee4;
    entry_14bec0(rdram, ctx, runtime);
}

void entry_14bf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bf74 inside entry_14bf70 (0x14bf70 - 0x14bf88)
    ctx->pc = 0x14bf74;
    entry_14bf70(rdram, ctx, runtime);
}

void entry_14bfbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bfbc inside entry_14bf9c (0x14bf9c - 0x14bfcc)
    ctx->pc = 0x14bfbc;
    entry_14bf9c(rdram, ctx, runtime);
}

void entry_14bfe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bfe4 inside entry_14bfcc (0x14bfcc - 0x14c004)
    ctx->pc = 0x14bfe4;
    entry_14bfcc(rdram, ctx, runtime);
}

void entry_14bffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14bffc inside entry_14bfcc (0x14bfcc - 0x14c004)
    ctx->pc = 0x14bffc;
    entry_14bfcc(rdram, ctx, runtime);
}

void entry_14c008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c008 inside entry_14c004 (0x14c004 - 0x14c018)
    ctx->pc = 0x14c008;
    entry_14c004(rdram, ctx, runtime);
}

void entry_14c00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c00c inside entry_14c004 (0x14c004 - 0x14c018)
    ctx->pc = 0x14c00c;
    entry_14c004(rdram, ctx, runtime);
}

void entry_14c054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c054 inside entry_14c02c (0x14c02c - 0x14c138)
    ctx->pc = 0x14c054;
    entry_14c02c(rdram, ctx, runtime);
}

void entry_14c090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c090 inside entry_14c02c (0x14c02c - 0x14c138)
    ctx->pc = 0x14c090;
    entry_14c02c(rdram, ctx, runtime);
}

void entry_14c0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c0b8 inside entry_14c02c (0x14c02c - 0x14c138)
    ctx->pc = 0x14c0b8;
    entry_14c02c(rdram, ctx, runtime);
}

void entry_14c1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c1b8 inside entry_14c1a8 (0x14c1a8 - 0x14c1cc)
    ctx->pc = 0x14c1b8;
    entry_14c1a8(rdram, ctx, runtime);
}

void entry_14c210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c210 inside entry_14c1f8 (0x14c1f8 - 0x14c2cc)
    ctx->pc = 0x14c210;
    entry_14c1f8(rdram, ctx, runtime);
}

void entry_14c258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c258 inside entry_14c1f8 (0x14c1f8 - 0x14c2cc)
    ctx->pc = 0x14c258;
    entry_14c1f8(rdram, ctx, runtime);
}

void entry_14c26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c26c inside entry_14c1f8 (0x14c1f8 - 0x14c2cc)
    ctx->pc = 0x14c26c;
    entry_14c1f8(rdram, ctx, runtime);
}

void entry_14c288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c288 inside entry_14c1f8 (0x14c1f8 - 0x14c2cc)
    ctx->pc = 0x14c288;
    entry_14c1f8(rdram, ctx, runtime);
}

void entry_14c334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c334 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c334;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c380 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c380;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c394 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c394;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c410 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c410;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c424 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c424;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c4ac inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c4ac;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c51c inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c51c;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c58c inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c58c;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c5e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c5e0 inside FUN_0014c2f0 (0x14c2f0 - 0x14c5e8)
    ctx->pc = 0x14c5e0;
    FUN_0014c2f0(rdram, ctx, runtime);
}

void entry_14c634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c634 inside FUN_0014c5e8 (0x14c5e8 - 0x14c65c)
    ctx->pc = 0x14c634;
    FUN_0014c5e8(rdram, ctx, runtime);
}

void entry_14c740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c740 inside entry_14c73c (0x14c73c - 0x14c758)
    ctx->pc = 0x14c740;
    entry_14c73c(rdram, ctx, runtime);
}

void entry_14c778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c778 inside entry_14c774 (0x14c774 - 0x14c788)
    ctx->pc = 0x14c778;
    entry_14c774(rdram, ctx, runtime);
}

void entry_14c7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c7b8 inside entry_14c7b4 (0x14c7b4 - 0x14c7d0)
    ctx->pc = 0x14c7b8;
    entry_14c7b4(rdram, ctx, runtime);
}

void entry_14c7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c7ec inside entry_14c7e4 (0x14c7e4 - 0x14c7fc)
    ctx->pc = 0x14c7ec;
    entry_14c7e4(rdram, ctx, runtime);
}

void entry_14c814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c814 inside entry_14c810 (0x14c810 - 0x14c820)
    ctx->pc = 0x14c814;
    entry_14c810(rdram, ctx, runtime);
}

void entry_14c8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c8b8 inside FUN_0014c858 (0x14c858 - 0x14c8d8)
    ctx->pc = 0x14c8b8;
    FUN_0014c858(rdram, ctx, runtime);
}

void entry_14c8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c8d0 inside FUN_0014c858 (0x14c858 - 0x14c8d8)
    ctx->pc = 0x14c8d0;
    FUN_0014c858(rdram, ctx, runtime);
}

void entry_14c900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c900 inside entry_14c8f0 (0x14c8f0 - 0x14c93c)
    ctx->pc = 0x14c900;
    entry_14c8f0(rdram, ctx, runtime);
}

void entry_14c918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c918 inside entry_14c8f0 (0x14c8f0 - 0x14c93c)
    ctx->pc = 0x14c918;
    entry_14c8f0(rdram, ctx, runtime);
}

void entry_14c9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14c9b4 inside entry_14c958 (0x14c958 - 0x14ca78)
    ctx->pc = 0x14c9b4;
    entry_14c958(rdram, ctx, runtime);
}

void entry_14ca14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ca14 inside entry_14c958 (0x14c958 - 0x14ca78)
    ctx->pc = 0x14ca14;
    entry_14c958(rdram, ctx, runtime);
}

void entry_14ca2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ca2c inside entry_14c958 (0x14c958 - 0x14ca78)
    ctx->pc = 0x14ca2c;
    entry_14c958(rdram, ctx, runtime);
}

void entry_14ca3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ca3c inside entry_14c958 (0x14c958 - 0x14ca78)
    ctx->pc = 0x14ca3c;
    entry_14c958(rdram, ctx, runtime);
}

void entry_14ca58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ca58 inside entry_14c958 (0x14c958 - 0x14ca78)
    ctx->pc = 0x14ca58;
    entry_14c958(rdram, ctx, runtime);
}

void entry_14caf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14caf4 inside entry_14cae8 (0x14cae8 - 0x14cb18)
    ctx->pc = 0x14caf4;
    entry_14cae8(rdram, ctx, runtime);
}

void entry_14cb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cb70 inside entry_14cb40 (0x14cb40 - 0x14cba8)
    ctx->pc = 0x14cb70;
    entry_14cb40(rdram, ctx, runtime);
}

void entry_14cb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cb74 inside entry_14cb40 (0x14cb40 - 0x14cba8)
    ctx->pc = 0x14cb74;
    entry_14cb40(rdram, ctx, runtime);
}

void entry_14cbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cbe8 inside FUN_0014cba8 (0x14cba8 - 0x14cbf0)
    ctx->pc = 0x14cbe8;
    FUN_0014cba8(rdram, ctx, runtime);
}

void entry_14cc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cc18 inside entry_14cbf0 (0x14cbf0 - 0x14cc54)
    ctx->pc = 0x14cc18;
    entry_14cbf0(rdram, ctx, runtime);
}

void entry_14cc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cc3c inside entry_14cbf0 (0x14cbf0 - 0x14cc54)
    ctx->pc = 0x14cc3c;
    entry_14cbf0(rdram, ctx, runtime);
}

void entry_14cc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cc44 inside entry_14cbf0 (0x14cbf0 - 0x14cc54)
    ctx->pc = 0x14cc44;
    entry_14cbf0(rdram, ctx, runtime);
}

void entry_14cd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cd4c inside entry_14cd30 (0x14cd30 - 0x14cd70)
    ctx->pc = 0x14cd4c;
    entry_14cd30(rdram, ctx, runtime);
}

void entry_14cd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cd50 inside entry_14cd30 (0x14cd30 - 0x14cd70)
    ctx->pc = 0x14cd50;
    entry_14cd30(rdram, ctx, runtime);
}

void entry_14cdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cdb0 inside entry_14cd9c (0x14cd9c - 0x14cdc8)
    ctx->pc = 0x14cdb0;
    entry_14cd9c(rdram, ctx, runtime);
}

void entry_14ce00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ce00 inside FUN_0014cdc8 (0x14cdc8 - 0x14ce28)
    ctx->pc = 0x14ce00;
    FUN_0014cdc8(rdram, ctx, runtime);
}

void entry_14ce08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ce08 inside FUN_0014cdc8 (0x14cdc8 - 0x14ce28)
    ctx->pc = 0x14ce08;
    FUN_0014cdc8(rdram, ctx, runtime);
}

void entry_14ceb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ceb0 inside entry_14ce9c (0x14ce9c - 0x14cec0)
    ctx->pc = 0x14ceb0;
    entry_14ce9c(rdram, ctx, runtime);
}

void entry_14cecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cecc inside entry_14cec0 (0x14cec0 - 0x14ced4)
    ctx->pc = 0x14cecc;
    entry_14cec0(rdram, ctx, runtime);
}

void entry_14cf0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cf0c inside entry_14cef8 (0x14cef8 - 0x14cf30)
    ctx->pc = 0x14cf0c;
    entry_14cef8(rdram, ctx, runtime);
}

void entry_14cf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cf70 inside entry_14cf54 (0x14cf54 - 0x14cfe4)
    ctx->pc = 0x14cf70;
    entry_14cf54(rdram, ctx, runtime);
}

void entry_14cf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cf98 inside entry_14cf54 (0x14cf54 - 0x14cfe4)
    ctx->pc = 0x14cf98;
    entry_14cf54(rdram, ctx, runtime);
}

void entry_14cfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cfb4 inside entry_14cf54 (0x14cf54 - 0x14cfe4)
    ctx->pc = 0x14cfb4;
    entry_14cf54(rdram, ctx, runtime);
}

void entry_14cfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14cfcc inside entry_14cf54 (0x14cf54 - 0x14cfe4)
    ctx->pc = 0x14cfcc;
    entry_14cf54(rdram, ctx, runtime);
}

void entry_14d04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d04c inside entry_14d048 (0x14d048 - 0x14d068)
    ctx->pc = 0x14d04c;
    entry_14d048(rdram, ctx, runtime);
}

void entry_14d08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d08c inside entry_14d088 (0x14d088 - 0x14d0a8)
    ctx->pc = 0x14d08c;
    entry_14d088(rdram, ctx, runtime);
}

void entry_14d090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d090 inside entry_14d088 (0x14d088 - 0x14d0a8)
    ctx->pc = 0x14d090;
    entry_14d088(rdram, ctx, runtime);
}

void entry_14d098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d098 inside entry_14d088 (0x14d088 - 0x14d0a8)
    ctx->pc = 0x14d098;
    entry_14d088(rdram, ctx, runtime);
}

void entry_14d0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d0b8 inside SMeasureApos__FiP6VECTORPf (0x14d0a8 - 0x14d138)
    ctx->pc = 0x14d0b8;
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime);
}

void entry_14d0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d0d8 inside SMeasureApos__FiP6VECTORPf (0x14d0a8 - 0x14d138)
    ctx->pc = 0x14d0d8;
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime);
}

void entry_14d114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d114 inside SMeasureApos__FiP6VECTORPf (0x14d0a8 - 0x14d138)
    ctx->pc = 0x14d114;
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime);
}

void entry_14d12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d12c inside SMeasureApos__FiP6VECTORPf (0x14d0a8 - 0x14d138)
    ctx->pc = 0x14d12c;
    SMeasureApos__FiP6VECTORPf(rdram, ctx, runtime);
}

void entry_14d168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d168 inside GWrapApos__FfiPfi (0x14d138 - 0x14d1a0)
    ctx->pc = 0x14d168;
    GWrapApos__FfiPfi(rdram, ctx, runtime);
}

void entry_14d178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d178 inside GWrapApos__FfiPfi (0x14d138 - 0x14d1a0)
    ctx->pc = 0x14d178;
    GWrapApos__FfiPfi(rdram, ctx, runtime);
}

void entry_14d188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d188 inside GWrapApos__FfiPfi (0x14d138 - 0x14d1a0)
    ctx->pc = 0x14d188;
    GWrapApos__FfiPfi(rdram, ctx, runtime);
}

void entry_14d198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d198 inside GWrapApos__FfiPfi (0x14d138 - 0x14d1a0)
    ctx->pc = 0x14d198;
    GWrapApos__FfiPfi(rdram, ctx, runtime);
}

void entry_14d1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d1f8 inside entry_14d1cc (0x14d1cc - 0x14d280)
    ctx->pc = 0x14d1f8;
    entry_14d1cc(rdram, ctx, runtime);
}

void entry_14d218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d218 inside entry_14d1cc (0x14d1cc - 0x14d280)
    ctx->pc = 0x14d218;
    entry_14d1cc(rdram, ctx, runtime);
}

void entry_14d21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d21c inside entry_14d1cc (0x14d1cc - 0x14d280)
    ctx->pc = 0x14d21c;
    entry_14d1cc(rdram, ctx, runtime);
}

void entry_14d240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d240 inside entry_14d1cc (0x14d1cc - 0x14d280)
    ctx->pc = 0x14d240;
    entry_14d1cc(rdram, ctx, runtime);
}

void entry_14d25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d25c inside entry_14d1cc (0x14d1cc - 0x14d280)
    ctx->pc = 0x14d25c;
    entry_14d1cc(rdram, ctx, runtime);
}

void entry_14d308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d308 inside entry_14d2b4 (0x14d2b4 - 0x14d3a8)
    ctx->pc = 0x14d308;
    entry_14d2b4(rdram, ctx, runtime);
}

void entry_14d37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d37c inside entry_14d2b4 (0x14d2b4 - 0x14d3a8)
    ctx->pc = 0x14d37c;
    entry_14d2b4(rdram, ctx, runtime);
}

void entry_14d388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d388 inside entry_14d2b4 (0x14d2b4 - 0x14d3a8)
    ctx->pc = 0x14d388;
    entry_14d2b4(rdram, ctx, runtime);
}

void entry_14d38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d38c inside entry_14d2b4 (0x14d2b4 - 0x14d3a8)
    ctx->pc = 0x14d38c;
    entry_14d2b4(rdram, ctx, runtime);
}

void entry_14d428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d428 inside FindAposClosestPointAll__FP6VECTORP6CONSTRiT0N20PiPf (0x14d3a8 - 0x14d460)
    ctx->pc = 0x14d428;
    FindAposClosestPointAll__FP6VECTORP6CONSTRiT0N20PiPf(rdram, ctx, runtime);
}

void entry_14d4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d4e4 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d4e4;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d4f4 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d4f4;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d4f8 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d4f8;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d550 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d550;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d55c inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d55c;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d564 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d564;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d570 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d570;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d5bc inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d5bc;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d630 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d630;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d63c inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d63c;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d640 inside entry_14d474 (0x14d474 - 0x14d680)
    ctx->pc = 0x14d640;
    entry_14d474(rdram, ctx, runtime);
}

void entry_14d6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d6e0 inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d6e0;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d6f0 inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d6f0;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d6fc inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d6fc;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d704 inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d704;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d730 inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d730;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d73c inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d73c;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d740 inside FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf (0x14d680 - 0x14d784)
    ctx->pc = 0x14d740;
    FindAposClosestPointSegment__FP6VECTORP6CONSTRiT0iiT0T0PiPf(rdram, ctx, runtime);
}

void entry_14d808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d808 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d808;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d80c inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d80c;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d814 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d814;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d820 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d820;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d868 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d868;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d8e0 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d8e0;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d8f0 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d8f0;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d8fc inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d8fc;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d904 inside entry_14d798 (0x14d798 - 0x14d938)
    ctx->pc = 0x14d904;
    entry_14d798(rdram, ctx, runtime);
}

void entry_14d968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d968 inside entry_14d960 (0x14d960 - 0x14d980)
    ctx->pc = 0x14d968;
    entry_14d960(rdram, ctx, runtime);
}

void entry_14d998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d998 inside entry_14d980 (0x14d980 - 0x14d9a8)
    ctx->pc = 0x14d998;
    entry_14d980(rdram, ctx, runtime);
}

void entry_14d9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d9d0 inside PcrvNew__F4CRVK (0x14d9a8 - 0x14d9d8)
    ctx->pc = 0x14d9d0;
    PcrvNew__F4CRVK(rdram, ctx, runtime);
}

void entry_14d9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d9e8 inside entry_14d9d8 (0x14d9d8 - 0x14d9f0)
    ctx->pc = 0x14d9e8;
    entry_14d9d8(rdram, ctx, runtime);
}

void entry_14d9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14d9fc inside entry_14d9f0 (0x14d9f0 - 0x14da18)
    ctx->pc = 0x14d9fc;
    entry_14d9f0(rdram, ctx, runtime);
}

void entry_14da04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14da04 inside entry_14d9f0 (0x14d9f0 - 0x14da18)
    ctx->pc = 0x14da04;
    entry_14d9f0(rdram, ctx, runtime);
}

void entry_14daf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14daf4 inside entry_14dac4 (0x14dac4 - 0x14db14)
    ctx->pc = 0x14daf4;
    entry_14dac4(rdram, ctx, runtime);
}

void entry_14db2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14db2c inside entry_14db14 (0x14db14 - 0x14db40)
    ctx->pc = 0x14db2c;
    entry_14db14(rdram, ctx, runtime);
}

void entry_14dc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dc48 inside FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6 (0x14dbd0 - 0x14dc7c)
    ctx->pc = 0x14dc48;
    FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6(rdram, ctx, runtime);
}

void entry_14dc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dc68 inside FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6 (0x14dbd0 - 0x14dc7c)
    ctx->pc = 0x14dc68;
    FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6(rdram, ctx, runtime);
}

void entry_14dc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dc6c inside FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6 (0x14dbd0 - 0x14dc7c)
    ctx->pc = 0x14dc6c;
    FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6(rdram, ctx, runtime);
}

void entry_14dc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dc90 inside entry_14dc7c (0x14dc7c - 0x14dcac)
    ctx->pc = 0x14dc90;
    entry_14dc7c(rdram, ctx, runtime);
}

void entry_14dcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dcb8 inside entry_14dcac (0x14dcac - 0x14dcd0)
    ctx->pc = 0x14dcb8;
    entry_14dcac(rdram, ctx, runtime);
}

void entry_14dcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dcd4 inside entry_14dcd0 (0x14dcd0 - 0x14dcf8)
    ctx->pc = 0x14dcd4;
    entry_14dcd0(rdram, ctx, runtime);
}

void entry_14dd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14dd98 inside entry_14dd88 (0x14dd88 - 0x14dda0)
    ctx->pc = 0x14dd98;
    entry_14dd88(rdram, ctx, runtime);
}

void entry_14ddd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ddd8 inside entry_14ddc8 (0x14ddc8 - 0x14ddf0)
    ctx->pc = 0x14ddd8;
    entry_14ddc8(rdram, ctx, runtime);
}

void entry_14ddf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ddf4 inside entry_14ddf0 (0x14ddf0 - 0x14de08)
    ctx->pc = 0x14ddf4;
    entry_14ddf0(rdram, ctx, runtime);
}

void entry_14ded0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ded0 inside RenderCrvlSegment__FP4CRVLiP7MATRIX4P2CMG4RGBAi (0x14de78 - 0x14def8)
    ctx->pc = 0x14ded0;
    RenderCrvlSegment__FP4CRVLiP7MATRIX4P2CMG4RGBAi(rdram, ctx, runtime);
}

void entry_14ded8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ded8 inside RenderCrvlSegment__FP4CRVLiP7MATRIX4P2CMG4RGBAi (0x14de78 - 0x14def8)
    ctx->pc = 0x14ded8;
    RenderCrvlSegment__FP4CRVLiP7MATRIX4P2CMG4RGBAi(rdram, ctx, runtime);
}

void entry_14e118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e118 inside entry_14e0dc (0x14e0dc - 0x14e170)
    ctx->pc = 0x14e118;
    entry_14e0dc(rdram, ctx, runtime);
}

void entry_14e154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e154 inside entry_14e0dc (0x14e0dc - 0x14e170)
    ctx->pc = 0x14e154;
    entry_14e0dc(rdram, ctx, runtime);
}

void entry_14e238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e238 inside entry_14e1fc (0x14e1fc - 0x14e2a0)
    ctx->pc = 0x14e238;
    entry_14e1fc(rdram, ctx, runtime);
}

void entry_14e274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e274 inside entry_14e1fc (0x14e1fc - 0x14e2a0)
    ctx->pc = 0x14e274;
    entry_14e1fc(rdram, ctx, runtime);
}

void entry_14e368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e368 inside entry_14e32c (0x14e32c - 0x14e3d0)
    ctx->pc = 0x14e368;
    entry_14e32c(rdram, ctx, runtime);
}

void entry_14e3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e3a4 inside entry_14e32c (0x14e32c - 0x14e3d0)
    ctx->pc = 0x14e3a4;
    entry_14e32c(rdram, ctx, runtime);
}

void entry_14e468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e468 inside entry_14e454 (0x14e454 - 0x14e470)
    ctx->pc = 0x14e468;
    entry_14e454(rdram, ctx, runtime);
}

void entry_14e4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e4c4 inside entry_14e4b4 (0x14e4b4 - 0x14e4dc)
    ctx->pc = 0x14e4c4;
    entry_14e4b4(rdram, ctx, runtime);
}

void entry_14e59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e59c inside entry_14e598 (0x14e598 - 0x14e5b8)
    ctx->pc = 0x14e59c;
    entry_14e598(rdram, ctx, runtime);
}

void entry_14e680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e680 inside entry_14e628 (0x14e628 - 0x14e6a8)
    ctx->pc = 0x14e680;
    entry_14e628(rdram, ctx, runtime);
}

void entry_14e68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e68c inside entry_14e628 (0x14e628 - 0x14e6a8)
    ctx->pc = 0x14e68c;
    entry_14e628(rdram, ctx, runtime);
}

void entry_14e690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e690 inside entry_14e628 (0x14e628 - 0x14e6a8)
    ctx->pc = 0x14e690;
    entry_14e628(rdram, ctx, runtime);
}

void entry_14e868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e868 inside entry_14e854 (0x14e854 - 0x14e888)
    ctx->pc = 0x14e868;
    entry_14e854(rdram, ctx, runtime);
}

void entry_14e8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14e8e8 inside entry_14e888 (0x14e888 - 0x14e8f0)
    ctx->pc = 0x14e8e8;
    entry_14e888(rdram, ctx, runtime);
}

void entry_14ea88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ea88 inside MeasureCrvc__FP4CRVC (0x14ea48 - 0x14ead0)
    ctx->pc = 0x14ea88;
    MeasureCrvc__FP4CRVC(rdram, ctx, runtime);
}

void entry_14eaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14eaec inside entry_14ead0 (0x14ead0 - 0x14eb10)
    ctx->pc = 0x14eaec;
    entry_14ead0(rdram, ctx, runtime);
}

void entry_14eb6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14eb6c inside FindCrvcClosestPointAll__FP4CRVCP6VECTORP6CONSTRT1T1PfT5 (0x14eb10 - 0x14ebac)
    ctx->pc = 0x14eb6c;
    FindCrvcClosestPointAll__FP4CRVCP6VECTORP6CONSTRT1T1PfT5(rdram, ctx, runtime);
}

void entry_14eb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14eb70 inside FindCrvcClosestPointAll__FP4CRVCP6VECTORP6CONSTRT1T1PfT5 (0x14eb10 - 0x14ebac)
    ctx->pc = 0x14eb70;
    FindCrvcClosestPointAll__FP4CRVCP6VECTORP6CONSTRT1T1PfT5(rdram, ctx, runtime);
}

void entry_14ebc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ebc8 inside entry_14ebac (0x14ebac - 0x14ec3c)
    ctx->pc = 0x14ebc8;
    entry_14ebac(rdram, ctx, runtime);
}

void entry_14ebf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ebf0 inside entry_14ebac (0x14ebac - 0x14ec3c)
    ctx->pc = 0x14ebf0;
    entry_14ebac(rdram, ctx, runtime);
}

void entry_14ec10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ec10 inside entry_14ebac (0x14ebac - 0x14ec3c)
    ctx->pc = 0x14ec10;
    entry_14ebac(rdram, ctx, runtime);
}

void entry_14ece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ece8 inside FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6 (0x14ec70 - 0x14ed1c)
    ctx->pc = 0x14ece8;
    FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6(rdram, ctx, runtime);
}

void entry_14ed08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ed08 inside FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6 (0x14ec70 - 0x14ed1c)
    ctx->pc = 0x14ed08;
    FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6(rdram, ctx, runtime);
}

void entry_14ed0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ed0c inside FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6 (0x14ec70 - 0x14ed1c)
    ctx->pc = 0x14ed0c;
    FindCrvcClosestPointFromU__FP4CRVCP6VECTORfP6CONSTRT1T1PfT6(rdram, ctx, runtime);
}

void entry_14ed30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ed30 inside entry_14ed1c (0x14ed1c - 0x14ed4c)
    ctx->pc = 0x14ed30;
    entry_14ed1c(rdram, ctx, runtime);
}

void entry_14ed58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ed58 inside entry_14ed4c (0x14ed4c - 0x14ed70)
    ctx->pc = 0x14ed58;
    entry_14ed4c(rdram, ctx, runtime);
}

void entry_14ed74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ed74 inside entry_14ed70 (0x14ed70 - 0x14ed98)
    ctx->pc = 0x14ed74;
    entry_14ed70(rdram, ctx, runtime);
}

void entry_14eed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14eed4 inside entry_14eebc (0x14eebc - 0x14ef00)
    ctx->pc = 0x14eed4;
    entry_14eebc(rdram, ctx, runtime);
}

void entry_14eeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14eeec inside entry_14eebc (0x14eebc - 0x14ef00)
    ctx->pc = 0x14eeec;
    entry_14eebc(rdram, ctx, runtime);
}

void entry_14f008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f008 inside entry_14f004 (0x14f004 - 0x14f020)
    ctx->pc = 0x14f008;
    entry_14f004(rdram, ctx, runtime);
}

void entry_14f00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f00c inside entry_14f004 (0x14f004 - 0x14f020)
    ctx->pc = 0x14f00c;
    entry_14f004(rdram, ctx, runtime);
}

void entry_14f0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f0f0 inside entry_14f0a8 (0x14f0a8 - 0x14f0f8)
    ctx->pc = 0x14f0f0;
    entry_14f0a8(rdram, ctx, runtime);
}

void entry_14f0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f0fc inside entry_14f0f8 (0x14f0f8 - 0x14f110)
    ctx->pc = 0x14f0fc;
    entry_14f0f8(rdram, ctx, runtime);
}

void entry_14f140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f140 inside SetDartDarts__FP4DART5DARTS (0x14f110 - 0x14f15c)
    ctx->pc = 0x14f140;
    SetDartDarts__FP4DART5DARTS(rdram, ctx, runtime);
}

void entry_14f1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f1dc inside ApplyDartThrow__FP4DARTP2PO (0x14f168 - 0x14f23c)
    ctx->pc = 0x14f1dc;
    ApplyDartThrow__FP4DARTP2PO(rdram, ctx, runtime);
}

void entry_14f1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f1e8 inside ApplyDartThrow__FP4DARTP2PO (0x14f168 - 0x14f23c)
    ctx->pc = 0x14f1e8;
    ApplyDartThrow__FP4DARTP2PO(rdram, ctx, runtime);
}

void entry_14f2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f2cc inside entry_14f290 (0x14f290 - 0x14f2d8)
    ctx->pc = 0x14f2cc;
    entry_14f290(rdram, ctx, runtime);
}

void entry_14f304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f304 inside entry_14f2fc (0x14f2fc - 0x14f310)
    ctx->pc = 0x14f304;
    entry_14f2fc(rdram, ctx, runtime);
}

void entry_14f308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f308 inside entry_14f2fc (0x14f2fc - 0x14f310)
    ctx->pc = 0x14f308;
    entry_14f2fc(rdram, ctx, runtime);
}

void entry_14f3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f3b8 inside entry_14f3b4 (0x14f3b4 - 0x14f3c8)
    ctx->pc = 0x14f3b8;
    entry_14f3b4(rdram, ctx, runtime);
}

void entry_14f45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f45c inside entry_14f454 (0x14f454 - 0x14f468)
    ctx->pc = 0x14f45c;
    entry_14f454(rdram, ctx, runtime);
}

void entry_14f4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f4b8 inside entry_14f4b0 (0x14f4b0 - 0x14f4c4)
    ctx->pc = 0x14f4b8;
    entry_14f4b0(rdram, ctx, runtime);
}

void entry_14f564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f564 inside entry_14f55c (0x14f55c - 0x14f570)
    ctx->pc = 0x14f564;
    entry_14f55c(rdram, ctx, runtime);
}

void entry_14f574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f574 inside entry_14f570 (0x14f570 - 0x14f584)
    ctx->pc = 0x14f574;
    entry_14f570(rdram, ctx, runtime);
}

void entry_14f59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f59c inside entry_14f594 (0x14f594 - 0x14f65c)
    ctx->pc = 0x14f59c;
    entry_14f594(rdram, ctx, runtime);
}

void entry_14f5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f5c0 inside entry_14f594 (0x14f594 - 0x14f65c)
    ctx->pc = 0x14f5c0;
    entry_14f594(rdram, ctx, runtime);
}

void entry_14f630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f630 inside entry_14f594 (0x14f594 - 0x14f65c)
    ctx->pc = 0x14f630;
    entry_14f594(rdram, ctx, runtime);
}

void entry_14f640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f640 inside entry_14f594 (0x14f594 - 0x14f65c)
    ctx->pc = 0x14f640;
    entry_14f594(rdram, ctx, runtime);
}

void entry_14f6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f6d4 inside entry_14f65c (0x14f65c - 0x14f700)
    ctx->pc = 0x14f6d4;
    entry_14f65c(rdram, ctx, runtime);
}

void entry_14f6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f6e0 inside entry_14f65c (0x14f65c - 0x14f700)
    ctx->pc = 0x14f6e0;
    entry_14f65c(rdram, ctx, runtime);
}

void entry_14f728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f728 inside entry_14f724 (0x14f724 - 0x14f740)
    ctx->pc = 0x14f728;
    entry_14f724(rdram, ctx, runtime);
}

void entry_14f7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f7e4 inside entry_14f7dc (0x14f7dc - 0x14f810)
    ctx->pc = 0x14f7e4;
    entry_14f7dc(rdram, ctx, runtime);
}

void entry_14f83c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f83c inside entry_14f838 (0x14f838 - 0x14f850)
    ctx->pc = 0x14f83c;
    entry_14f838(rdram, ctx, runtime);
}

void entry_14f840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f840 inside entry_14f838 (0x14f838 - 0x14f850)
    ctx->pc = 0x14f840;
    entry_14f838(rdram, ctx, runtime);
}

void entry_14f888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f888 inside entry_14f878 (0x14f878 - 0x14f898)
    ctx->pc = 0x14f888;
    entry_14f878(rdram, ctx, runtime);
}

void entry_14f8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f8cc inside entry_14f8ac (0x14f8ac - 0x14f900)
    ctx->pc = 0x14f8cc;
    entry_14f8ac(rdram, ctx, runtime);
}

void entry_14f8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f8d0 inside entry_14f8ac (0x14f8ac - 0x14f900)
    ctx->pc = 0x14f8d0;
    entry_14f8ac(rdram, ctx, runtime);
}

void entry_14f8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f8e0 inside entry_14f8ac (0x14f8ac - 0x14f900)
    ctx->pc = 0x14f8e0;
    entry_14f8ac(rdram, ctx, runtime);
}

void entry_14f918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f918 inside FUN_0014f900 (0x14f900 - 0x14f920)
    ctx->pc = 0x14f918;
    FUN_0014f900(rdram, ctx, runtime);
}

void entry_14f9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f9b8 inside entry_14f978 (0x14f978 - 0x14f9c4)
    ctx->pc = 0x14f9b8;
    entry_14f978(rdram, ctx, runtime);
}

void entry_14f9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14f9e4 inside entry_14f9e0 (0x14f9e0 - 0x14f9f4)
    ctx->pc = 0x14f9e4;
    entry_14f9e0(rdram, ctx, runtime);
}

void entry_14fa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fa14 inside entry_14fa04 (0x14fa04 - 0x14fa28)
    ctx->pc = 0x14fa14;
    entry_14fa04(rdram, ctx, runtime);
}

void entry_14faf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14faf4 inside entry_14fadc (0x14fadc - 0x14fb8c)
    ctx->pc = 0x14faf4;
    entry_14fadc(rdram, ctx, runtime);
}

void entry_14fb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fb84 inside entry_14fadc (0x14fadc - 0x14fb8c)
    ctx->pc = 0x14fb84;
    entry_14fadc(rdram, ctx, runtime);
}

void entry_14fbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fbb0 inside entry_14fbac (0x14fbac - 0x14fbcc)
    ctx->pc = 0x14fbb0;
    entry_14fbac(rdram, ctx, runtime);
}

void entry_14fbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fbb4 inside entry_14fbac (0x14fbac - 0x14fbcc)
    ctx->pc = 0x14fbb4;
    entry_14fbac(rdram, ctx, runtime);
}

void entry_14fbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fbb8 inside entry_14fbac (0x14fbac - 0x14fbcc)
    ctx->pc = 0x14fbb8;
    entry_14fbac(rdram, ctx, runtime);
}

void entry_14fbd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fbd0 inside entry_14fbcc (0x14fbcc - 0x14fbe0)
    ctx->pc = 0x14fbd0;
    entry_14fbcc(rdram, ctx, runtime);
}

void entry_14fbd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fbd4 inside entry_14fbcc (0x14fbcc - 0x14fbe0)
    ctx->pc = 0x14fbd4;
    entry_14fbcc(rdram, ctx, runtime);
}

void entry_14fc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fc18 inside entry_14fc04 (0x14fc04 - 0x14fc20)
    ctx->pc = 0x14fc18;
    entry_14fc04(rdram, ctx, runtime);
}

void entry_14fc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fc7c inside entry_14fc78 (0x14fc78 - 0x14fc8c)
    ctx->pc = 0x14fc7c;
    entry_14fc78(rdram, ctx, runtime);
}

void entry_14fcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fcb8 inside entry_14fcb0 (0x14fcb0 - 0x14fccc)
    ctx->pc = 0x14fcb8;
    entry_14fcb0(rdram, ctx, runtime);
}

void entry_14fd2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fd2c inside entry_14fd28 (0x14fd28 - 0x14fd90)
    ctx->pc = 0x14fd2c;
    entry_14fd28(rdram, ctx, runtime);
}

void entry_14fd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fd4c inside entry_14fd28 (0x14fd28 - 0x14fd90)
    ctx->pc = 0x14fd4c;
    entry_14fd28(rdram, ctx, runtime);
}

void entry_14fd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fd84 inside entry_14fd28 (0x14fd28 - 0x14fd90)
    ctx->pc = 0x14fd84;
    entry_14fd28(rdram, ctx, runtime);
}

void entry_14fd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fd88 inside entry_14fd28 (0x14fd28 - 0x14fd90)
    ctx->pc = 0x14fd88;
    entry_14fd28(rdram, ctx, runtime);
}

void entry_14fe14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fe14 inside entry_14fe04 (0x14fe04 - 0x14fe28)
    ctx->pc = 0x14fe14;
    entry_14fe04(rdram, ctx, runtime);
}

void entry_14fe48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fe48 inside entry_14fe28 (0x14fe28 - 0x14fe50)
    ctx->pc = 0x14fe48;
    entry_14fe28(rdram, ctx, runtime);
}

void entry_14fe58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fe58 inside entry_14fe50 (0x14fe50 - 0x14fe70)
    ctx->pc = 0x14fe58;
    entry_14fe50(rdram, ctx, runtime);
}

void entry_14fea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14fea8 inside entry_14fe9c (0x14fe9c - 0x14fec0)
    ctx->pc = 0x14fea8;
    entry_14fe9c(rdram, ctx, runtime);
}

void entry_14feac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14feac inside entry_14fe9c (0x14fe9c - 0x14fec0)
    ctx->pc = 0x14feac;
    entry_14fe9c(rdram, ctx, runtime);
}

void entry_14ff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ff00 inside FPrepareDartgunToFire__FP7DARTGUN (0x14fec0 - 0x14ff0c)
    ctx->pc = 0x14ff00;
    FPrepareDartgunToFire__FP7DARTGUN(rdram, ctx, runtime);
}

void entry_14ff04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ff04 inside FPrepareDartgunToFire__FP7DARTGUN (0x14fec0 - 0x14ff0c)
    ctx->pc = 0x14ff04;
    FPrepareDartgunToFire__FP7DARTGUN(rdram, ctx, runtime);
}

void entry_14ff20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ff20 inside entry_14ff0c (0x14ff0c - 0x14ff28)
    ctx->pc = 0x14ff20;
    entry_14ff0c(rdram, ctx, runtime);
}

void entry_14ff30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ff30 inside entry_14ff28 (0x14ff28 - 0x14ff48)
    ctx->pc = 0x14ff30;
    entry_14ff28(rdram, ctx, runtime);
}

void entry_14ffec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x14ffec inside entry_14ffd8 (0x14ffd8 - 0x150008)
    ctx->pc = 0x14ffec;
    entry_14ffd8(rdram, ctx, runtime);
}

