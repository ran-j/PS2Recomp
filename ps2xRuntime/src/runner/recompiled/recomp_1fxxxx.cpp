// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1f00a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f00a4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f00a8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f00ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f00b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f00b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f00b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetWipeButtonTrans__FP4WIPEP5TRANS5WIPEK
// Address: 0x1f00c0 - 0x1f00f0

void entry_1f011c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f011c: 0x10400038
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0200; return;
    }
    // 0x1f0124: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x1f0128: 0x10400035
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0200; return;
    }
    // 0x1f0130: 0x962200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 170)));
    // 0x1f0134: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x1f0138: 0x10400030
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F01FC; return;
    }
    // 0x1f0140: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1f0148);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1f0148
// Address: 0x1f0148 - 0x1f01f4

void entry_1f0148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0148) {
        switch (ctx->pc) {
            case 0x1f01a0: ctx->pc = 0; goto label_1f01a0;
            case 0x1f01b0: ctx->pc = 0; goto label_1f01b0;
            case 0x1f01cc: ctx->pc = 0; goto label_1f01cc;
            case 0x1f01d4: ctx->pc = 0; goto label_1f01d4;
            case 0x1f01dc: ctx->pc = 0; goto label_1f01dc;
            case 0x1f01e4: ctx->pc = 0; goto label_1f01e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0148: 0x6a02002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1f014c: 0x6e020028
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1f0150: 0x6a030037
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f0154: 0x6e030030
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f0158: 0x8e040038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x1f015c: 0xb2020017
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0160: 0xb6020010
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0164: 0xb203001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0168: 0xb6030018
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f016c: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x1f0170: 0x26070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1f0174: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1f0178: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x1f017c: 0x8ce60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x1f0180: 0x50c00014
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 16)));
        goto label_1f01d4;
    }
    // 0x1f0188: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f018c: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x1f0190: 0x14c20003
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1f01a0;
    }
    // 0x1f0198: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f01cc;
    }
label_1f01a0:
    // 0x1f01a0: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_1f01b0;
    }
    // 0x1f01a8: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f01cc;
    }
label_1f01b0:
    // 0x1f01b0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1f01b4: 0x8cc50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1f01b8: 0x8cc20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1f01bc: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f01c0: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1f01c4: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f01c8: 0x2c620001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 1));
label_1f01cc:
    // 0x1f01cc: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f01dc;
    }
label_1f01d4:
    // 0x1f01d4: 0x10000003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f01e4;
    }
label_1f01dc:
    // 0x1f01dc: 0x2403fff7
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967287));
    // 0x1f01e0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_1f01e4:
    // 0x1f01e4: 0xace20010
    WRITE32(ADD32(GPR_U32(ctx, 7), 16), GPR_U32(ctx, 2));
    // 0x1f01e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f01ec: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1f01f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1f01f4
// Address: 0x1f01f4 - 0x1f0218

void entry_1f01f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f01f4) {
        switch (ctx->pc) {
            case 0x1f01fc: ctx->pc = 0; goto label_1f01fc;
            case 0x1f0200: ctx->pc = 0; goto label_1f0200;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f01f4: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0200;
    }
label_1f01fc:
    // 0x1f01fc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f0200:
    // 0x1f0200: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f0204: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0208: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f020c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f0210: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001F0218
// Address: 0x1f0218 - 0x1f0220

void entry_1f0264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0264) {
        switch (ctx->pc) {
            case 0x1f0268: ctx->pc = 0; goto label_1f0268;
            case 0x1f0288: ctx->pc = 0; goto label_1f0288;
            case 0x1f02a0: ctx->pc = 0; goto label_1f02a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0264: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1f0268:
    // 0x1f0268: 0x1222001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F02E0; return;
    }
    // 0x1f0270: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0288;
    }
    // 0x1f0278: 0x52200061
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
        ctx->pc = 0x1F0400; return;
    }
    // 0x1f0280: 0x10000060
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0404; return;
    }
label_1f0288:
    // 0x1f0288: 0x12230005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        goto label_1f02a0;
    }
    // 0x1f0290: 0x52220038
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        ctx->pc = 0x1F0374; return;
    }
    // 0x1f0298: 0x1000005a
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0404; return;
    }
label_1f02a0:
    // 0x1f02a0: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1f02a4: 0x10400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f02c8(rdram, ctx, runtime); return;
    }
    // 0x1f02ac: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f02b0: 0x8c480010
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1f02b4: 0x24845af0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23280));
    // 0x1f02b8: 0x8c450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1f02bc: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1f02c0: 0xc0793a0
    SET_GPR_U32(ctx, 31, 0x1f02c8);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    Set__11CTransitionPc3OIDT2i(rdram, ctx, runtime); return;
}


// Function: entry_1f02c8
// Address: 0x1f02c8 - 0x1f0308

void entry_1f02c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f02c8) {
        switch (ctx->pc) {
            case 0x1f02e0: ctx->pc = 0; goto label_1f02e0;
            case 0x1f0300: ctx->pc = 0; goto label_1f0300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f02c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f02cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f02d0: 0xae000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
    // 0x1f02d4: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1f02d8: 0x10000049
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0400; return;
    }
label_1f02e0:
    // 0x1f02e0: 0x8e030024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1f02e4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f02e8: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f0300;
    }
    // 0x1f02f0: 0x10620018
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F0354; return;
    }
    // 0x1f02f8: 0x1000001a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0364; return;
    }
label_1f0300:
    // 0x1f0300: 0xc058068
    SET_GPR_U32(ctx, 31, 0x1f0308);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FFindLevel(rdram, ctx, runtime); return;
}


// Function: entry_1f0308
// Address: 0x1f0308 - 0x1f0338

void entry_1f0308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0308: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f030c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f0310: 0x33a03
    SET_GPR_S32(ctx, 7, SRA32(GPR_S32(ctx, 3), 8));
    // 0x1f0314: 0x8c44fa68
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294965864)));
    // 0x1f0318: 0x1080000c
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 3), 255));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F034C; return;
    }
    // 0x1f0320: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f0324: 0x10620009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F034C; return;
    }
    // 0x1f032c: 0xc7280b
    if (GPR_U32(ctx, 7) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 6));
    // 0x1f0330: 0xc07c564
    SET_GPR_U32(ctx, 31, 0x1f0338);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    ShowWm__FP2WM10WORLDLEVEL3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f0338
// Address: 0x1f0338 - 0x1f0344

void entry_1f0338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0338: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f033c: 0xc0776d6
    SET_GPR_U32(ctx, 31, 0x1f0344);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    FUN_001ddb58(rdram, ctx, runtime); return;
}


// Function: entry_1f0344
// Address: 0x1f0344 - 0x1f036c

void entry_1f0344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0344) {
        switch (ctx->pc) {
            case 0x1f034c: ctx->pc = 0; goto label_1f034c;
            case 0x1f0354: ctx->pc = 0; goto label_1f0354;
            case 0x1f035c: ctx->pc = 0; goto label_1f035c;
            case 0x1f0360: ctx->pc = 0; goto label_1f0360;
            case 0x1f0364: ctx->pc = 0; goto label_1f0364;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0344: 0x10000006
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0360;
    }
label_1f034c:
    // 0x1f034c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f035c;
    }
label_1f0354:
    // 0x1f0354: 0x1000ffd2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F02A0; return;
    }
label_1f035c:
    // 0x1f035c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_1f0360:
    // 0x1f0360: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
label_1f0364:
    // 0x1f0364: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x1f036c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_1f036c
// Address: 0x1f036c - 0x1f03dc

void entry_1f036c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f036c) {
        switch (ctx->pc) {
            case 0x1f0374: ctx->pc = 0; goto label_1f0374;
            case 0x1f038c: ctx->pc = 0; goto label_1f038c;
            case 0x1f03bc: ctx->pc = 0; goto label_1f03bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f036c: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0404; return;
    }
label_1f0374:
    // 0x1f0374: 0x50830005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
        goto label_1f038c;
    }
    // 0x1f037c: 0x1091001b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1F03EC; return;
    }
    // 0x1f0384: 0x1000001f
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0404; return;
    }
label_1f038c:
    // 0x1f038c: 0x8c625bf0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 23536)));
    // 0x1f0390: 0x1444000a
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1f03bc;
    }
    // 0x1f0398: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f039c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f03a0: 0x8c4223cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 9164)));
    // 0x1f03a4: 0x10430005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294965256));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_1f03bc;
    }
    // 0x1f03ac: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f03b0: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1f03b4: 0x8c430264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 612)));
    // 0x1f03b8: 0xac830260
    WRITE32(ADD32(GPR_U32(ctx, 4), 608), GPR_U32(ctx, 3));
label_1f03bc:
    // 0x1f03bc: 0x24a4f808
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294965256));
    // 0x1f03c0: 0x8c830260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x1f03c4: 0x10600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F03E4; return;
    }
    // 0x1f03cc: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f03d0: 0xac6202e0
    WRITE32(ADD32(GPR_U32(ctx, 3), 736), GPR_U32(ctx, 2));
    // 0x1f03d4: 0xc07c414
    SET_GPR_U32(ctx, 31, 0x1f03dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f03dc
// Address: 0x1f03dc - 0x1f03fc

void entry_1f03dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f03dc) {
        switch (ctx->pc) {
            case 0x1f03e4: ctx->pc = 0; goto label_1f03e4;
            case 0x1f03ec: ctx->pc = 0; goto label_1f03ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f03dc: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0404; return;
    }
label_1f03e4:
    // 0x1f03e4: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0400; return;
    }
label_1f03ec:
    // 0x1f03ec: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1f03f0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f03f4: 0xc05a2da
    SET_GPR_U32(ctx, 31, 0x1f03fc);
    FadeFramesToBlack__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1f03fc
// Address: 0x1f03fc - 0x1f0428

void entry_1f03fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f03fc) {
        switch (ctx->pc) {
            case 0x1f0400: ctx->pc = 0; goto label_1f0400;
            case 0x1f0404: ctx->pc = 0; goto label_1f0404;
            case 0x1f0410: ctx->pc = 0; goto label_1f0410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f03fc: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
label_1f0400:
    // 0x1f0400: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
label_1f0404:
    // 0x1f0404: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f0408: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x1f040c: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
label_1f0410:
    // 0x1f0410: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0414: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f0418: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f041c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f0424: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f0428; return;
}


// Function: WipeToWorldWarp
// Address: 0x1f0428 - 0x1f045c

void entry_1f045c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f045c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0460: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f0468
// Address: 0x1f0468 - 0x1f0490

void FUN_001f0468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0468) {
        switch (ctx->pc) {
            case 0x1f0484: ctx->pc = 0; goto label_1f0484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0468: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f046c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0470: 0x8c435bf0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 23536)));
    // 0x1f0474: 0x14640003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1f0484;
    }
    // 0x1f047c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1f0484:
    // 0x1f0484: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1f0488: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f0490
// Address: 0x1f0490 - 0x1f0580

void FUN_001f0490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0490) {
        switch (ctx->pc) {
            case 0x1f04b0: ctx->pc = 0; goto label_1f04b0;
            case 0x1f04d0: ctx->pc = 0; goto label_1f04d0;
            case 0x1f04d4: ctx->pc = 0; goto label_1f04d4;
            case 0x1f04d8: ctx->pc = 0; goto label_1f04d8;
            case 0x1f052c: ctx->pc = 0; goto label_1f052c;
            case 0x1f0568: ctx->pc = 0; goto label_1f0568;
            case 0x1f0570: ctx->pc = 0; goto label_1f0570;
            case 0x1f0578: ctx->pc = 0; goto label_1f0578;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0490: 0xc0602d
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1f0494: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f0498: 0x14a20005
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1f04b0;
    }
    // 0x1f04a0: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f04a4: 0x24090004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f04a8: 0x1000002f
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0568;
    }
label_1f04b0:
    // 0x1f04b0: 0x8c8602f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 756)));
    // 0x1f04b4: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f04b8: 0x14c20006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1f04d4;
    }
    // 0x1f04c0: 0x10a30003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        goto label_1f04d0;
    }
    // 0x1f04c8: 0x14a20003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1f04d8;
    }
label_1f04d0:
    // 0x1f04d0: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f04d4:
    // 0x1f04d4: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
label_1f04d8:
    // 0x1f04d8: 0x14a20014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 9));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1f052c;
    }
    // 0x1f04e0: 0x10600021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1f0568;
    }
    // 0x1f04e8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f04ec: 0xc22818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f04f0: 0x8c8423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1f04f4: 0x851821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1f04f8: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1f04fc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1f0500: 0x10400019
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0568;
    }
    // 0x1f0508: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1f050c: 0x24425fc8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24520));
    // 0x1f0510: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1f0514: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f0518: 0x8c850458
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1112)));
    // 0x1f051c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f0520: 0xa24024
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1f0524: 0x10000010
    SET_GPR_U32(ctx, 8, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0568;
    }
label_1f052c:
    // 0x1f052c: 0x2409ffff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f0530: 0xa2480b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 5));
    // 0x1f0534: 0xc0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1f0538: 0x1060000b
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1f0568;
    }
    // 0x1f0540: 0x24040078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 120));
    // 0x1f0544: 0x2405044c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1f0548: 0x1242018
    { int64_t result = (int64_t)GPR_S32(ctx, 9) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f054c: 0x1652818
    { int64_t result = (int64_t)GPR_S32(ctx, 11) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0550: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1f0554: 0x8c6223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1f0558: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1f055c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f0560: 0x8c430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1f0564: 0x30680001
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 3), 1));
label_1f0568:
    // 0x1f0568: 0x55800001
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 12), 0), GPR_U32(ctx, 11));
        goto label_1f0570;
    }
label_1f0570:
    // 0x1f0570: 0x54e00001
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 9));
        goto label_1f0578;
    }
label_1f0578:
    // 0x1f0578: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f0580
// Address: 0x1f0580 - 0x1f05bc

void FUN_001f0580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0580) {
        switch (ctx->pc) {
            case 0x1f05a8: ctx->pc = 0; goto label_1f05a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0580: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1f0584: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1f0588: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1f058c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1f0590: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f0594: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1f0598: 0x16020003
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1f05a8;
    }
    // 0x1f05a0: 0x1000002a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F064C; return;
    }
label_1f05a8:
    // 0x1f05a8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f05ac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f05b0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f05b4: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f05bc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f05bc
// Address: 0x1f05bc - 0x1f0644

void entry_1f05bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f05bc) {
        switch (ctx->pc) {
            case 0x1f05f0: ctx->pc = 0; goto label_1f05f0;
            case 0x1f060c: ctx->pc = 0; goto label_1f060c;
            case 0x1f0628: ctx->pc = 0; goto label_1f0628;
            case 0x1f0638: ctx->pc = 0; goto label_1f0638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f05bc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f05c0: 0x14800022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F064C; return;
    }
    // 0x1f05c8: 0x8e2302f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 756)));
    // 0x1f05cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f05d0: 0x10620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f05f0;
    }
    // 0x1f05d8: 0x1860001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F0648; return;
    }
    // 0x1f05e0: 0x10400019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0648; return;
    }
    // 0x1f05e8: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f060c;
    }
label_1f05f0:
    // 0x1f05f0: 0x14400016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F064C; return;
    }
    // 0x1f05f8: 0x2a020006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 6));
    // 0x1f05fc: 0x1040000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0628;
    }
    // 0x1f0604: 0x1000000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0638;
    }
label_1f060c:
    // 0x1f060c: 0x1440000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F064C; return;
    }
    // 0x1f0614: 0x2a020005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 5));
    // 0x1f0618: 0x10400003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0628;
    }
    // 0x1f0620: 0x10000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0638;
    }
label_1f0628:
    // 0x1f0628: 0x2a020008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 8));
    // 0x1f062c: 0x10400006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0648; return;
    }
    // 0x1f0634: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f0638:
    // 0x1f0638: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f063c: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f0644);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f0644
// Address: 0x1f0644 - 0x1f0660

void entry_1f0644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0644) {
        switch (ctx->pc) {
            case 0x1f0648: ctx->pc = 0; goto label_1f0648;
            case 0x1f064c: ctx->pc = 0; goto label_1f064c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0644: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1f0648:
    // 0x1f0648: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1f064c:
    // 0x1f064c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0650: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f0654: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f0658: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostWmLoad__FP2WM
// Address: 0x1f0660 - 0x1f0674

void entry_1f0674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0674) {
        switch (ctx->pc) {
            case 0x1f06c0: ctx->pc = 0; goto label_1f06c0;
            case 0x1f0728: ctx->pc = 0; goto label_1f0728;
            case 0x1f0734: ctx->pc = 0; goto label_1f0734;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0674: 0xde0302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1f0678: 0x2402fcff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x1f067c: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1f0680: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1f0684: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1f0688: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1f068c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1f0690: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f0694: 0x42678
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 25);
    // 0x1f0698: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f069c: 0x8cc523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 9152)));
    // 0x1f06a0: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f06a4: 0xfe0302c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 3));
    // 0x1f06a8: 0x8ca219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6616)));
    // 0x1f06ac: 0x10400004
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f06c0;
    }
    // 0x1f06b4: 0x24e2f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 4294965256));
    // 0x1f06b8: 0xa8500263
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 611); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 16) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f06bc: 0xb8500260
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 608); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 16) & mask); WRITE32(aligned_addr, new_data); }
label_1f06c0:
    // 0x1f06c0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1f06c4: 0x2444fe3a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966842));
    // 0x1f06c8: 0x2c830005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 5));
    // 0x1f06cc: 0x10600016
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1f0728;
    }
    // 0x1f06d4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1f06d8: 0x2442e7d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961104));
    // 0x1f06dc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f06e0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f06e4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1f06ec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f06f0: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0734;
    }
    // 0x1f06f8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f06fc: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0734;
    }
    // 0x1f0704: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f0708: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0734;
    }
    // 0x1f0710: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f0714: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0734;
    }
    // 0x1f071c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f0720: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0734;
    }
label_1f0728:
    // 0x1f0728: 0x8cc223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 9152)));
    // 0x1f072c: 0x8c4319d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6616)));
    // 0x1f0730: 0xae0302f4
    WRITE32(ADD32(GPR_U32(ctx, 16), 756), GPR_U32(ctx, 3));
label_1f0734:
    // 0x1f0734: 0x8e0202f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 756)));
    // 0x1f0738: 0x24e3f808
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 4294965256));
    // 0x1f073c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f0740: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f0744: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f0748: 0xac700264
    WRITE32(ADD32(GPR_U32(ctx, 3), 612), GPR_U32(ctx, 16));
    // 0x1f074c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f0750: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BindWm__FP2WM
// Address: 0x1f0758 - 0x1f077c

void entry_1f077c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f077c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1f0780: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0784: 0x24050034
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1f0788: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1f0790);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 24544));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1f0790
// Address: 0x1f0790 - 0x1f07d8

void entry_1f0790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0790) {
        switch (ctx->pc) {
            case 0x1f07d0: ctx->pc = 0; goto label_1f07d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0790: 0x26430034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 52));
    // 0x1f0794: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1f0798: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1f079c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f07a0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1f07a4: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1f07a8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1f07ac: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1f07b0: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1f07b4: 0x8e430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1f07b8: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1f07bc: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f07c0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f07c4: 0x1080000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F07F0; return;
    }
    // 0x1f07cc: 0x0
    // NOP
label_1f07d0:
    // 0x1f07d0: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1f07d8);
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f07d8
// Address: 0x1f07d8 - 0x1f0820

void entry_1f07d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f07d8) {
        switch (ctx->pc) {
            case 0x1f07f0: ctx->pc = 0; goto label_1f07f0;
            case 0x1f0800: ctx->pc = 0; goto label_1f0800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f07d8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f07dc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1f07e0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f07e4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1f07e8: 0x1480fff9
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F07D0; return;
    }
label_1f07f0:
    // 0x1f07f0: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1f07f4: 0x265002f8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 760));
    // 0x1f07f8: 0x2411000a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f07fc: 0x0
    // NOP
label_1f0800:
    // 0x1f0800: 0xe6140028
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x1f0804: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f0808: 0xe6140024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1f080c: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1f0810: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1f0814: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f0818: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1f0820);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1f0820
// Address: 0x1f0820 - 0x1f083c

void entry_1f0820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0820: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1f0824: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f0828: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1f082c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1f0830: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f0834: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1f083c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1f083c
// Address: 0x1f083c - 0x1f0878

void entry_1f083c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f083c: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1f0840: 0x621ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1F0800; return;
    }
    // 0x1f0848: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1f084c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f0850: 0xae420534
    WRITE32(ADD32(GPR_U32(ctx, 18), 1332), GPR_U32(ctx, 2));
    // 0x1f0854: 0xae63b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 3));
    // 0x1f0858: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f085c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f0860: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f0864: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0868: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f086c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1f0870: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefreshWmMoveStats__FP2WM10WORLDLEVEL
// Address: 0x1f0878 - 0x1f08ac

void entry_1f08ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f08ac) {
        switch (ctx->pc) {
            case 0x1f08b4: ctx->pc = 0; goto label_1f08b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f08ac: 0x10000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F08D4; return;
    }
label_1f08b4:
    // 0x1f08b4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f08b8: 0x2a020009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 9));
    // 0x1f08bc: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f08c0: 0x8e2502f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 756)));
    // 0x1f08c4: 0x202300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 16));
    // 0x1f08c8: 0xc06b434
    SET_GPR_U32(ctx, 31, 0x1f08d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294963512));
    render_level_info(rdram, ctx, runtime); return;
}


// Function: entry_1f08d0
// Address: 0x1f08d0 - 0x1f08dc

void entry_1f08d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f08d0) {
        switch (ctx->pc) {
            case 0x1f08d4: ctx->pc = 0; goto label_1f08d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f08d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f08d4:
    // 0x1f08d4: 0xc07c62c
    SET_GPR_U32(ctx, 31, 0x1f08dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetWmCursor__FP2WM10WORLDLEVEL(rdram, ctx, runtime); return;
}


// Function: entry_1f08dc
// Address: 0x1f08dc - 0x1f08f0

void entry_1f08dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f08dc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f08e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f08e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f08e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ThrowWmDisplayState__FP2WM10WORLDLEVELi
// Address: 0x1f08f0 - 0x1f0908

void entry_1f0988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0988: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1f098c: 0x8e6321d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8656)));
    // 0x1f0990: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f0994: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0998: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1f099c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f09a4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294963512));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f09a4
// Address: 0x1f09a4 - 0x1f09bc

void entry_1f09a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f09a4: 0xae000260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    // 0x1f09a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f09ac: 0x8e23f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1f09b0: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1f09b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f09bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f09bc
// Address: 0x1f09bc - 0x1f09d0

void entry_1f09bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f09bc: 0x8e8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 9152)));
    // 0x1f09c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f09c4: 0x8c6619dc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1f09c8: 0xc06b434
    SET_GPR_U32(ctx, 31, 0x1f09d0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    render_level_info(rdram, ctx, runtime); return;
}


// Function: entry_1f09d0
// Address: 0x1f09d0 - 0x1f09e4

void entry_1f09d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f09d0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f09d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f09d8: 0xae020464
    WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 2));
    // 0x1f09dc: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1f09e4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f09e4
// Address: 0x1f09e4 - 0x1f09f8

void entry_1f09e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f09e4: 0x8e22f138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1f09e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f09ec: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1f09f0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f09f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f09f8
// Address: 0x1f09f8 - 0x1f0a38

void entry_1f09f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f09f8) {
        switch (ctx->pc) {
            case 0x1f0a24: ctx->pc = 0; goto label_1f0a24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f09f8: 0x8ea26250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 25168)));
    // 0x1f09fc: 0x24030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1f0a00: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0a04: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1f0a08: 0x8c4402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 760)));
    // 0x1f0a0c: 0x1080000a
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1f0a38(rdram, ctx, runtime); return;
    }
    // 0x1f0a14: 0x8c626654
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 26196)));
    // 0x1f0a18: 0x14400002
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f0a24;
    }
    // 0x1f0a20: 0xc48c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[12] = *(float*)&val; }
label_1f0a24:
    // 0x1f0a24: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1f0a28: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0a2c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f0a30: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1f0a38);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 752));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f0a38
// Address: 0x1f0a38 - 0x1f0a80

void entry_1f0a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0a38) {
        switch (ctx->pc) {
            case 0x1f0a58: ctx->pc = 0; goto label_1f0a58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0a38: 0x8e4302e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 744)));
    // 0x1f0a3c: 0x1060001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0AB4; return;
    }
    // 0x1f0a44: 0x8c620054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 84)));
    // 0x1f0a48: 0x18400019
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F0AB0; return;
    }
    // 0x1f0a50: 0x2411000a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f0a54: 0x8c620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
label_1f0a58:
    // 0x1f0a58: 0x101900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 4));
    // 0x1f0a5c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f0a60: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1f0a64: 0x5491000d
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 744)));
        ctx->pc = 0x1F0A9C; return;
    }
    // 0x1f0a6c: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1f0a70: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1f0a74: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f0a78: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1f0a80);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f0a80
// Address: 0x1f0a80 - 0x1f0a98

void entry_1f0a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0a80: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f0a98(rdram, ctx, runtime); return;
    }
    // 0x1f0a88: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f0a8c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1f0a90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f0a98);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f0a98
// Address: 0x1f0a98 - 0x1f0ae0

void entry_1f0a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0a98) {
        switch (ctx->pc) {
            case 0x1f0a9c: ctx->pc = 0; goto label_1f0a9c;
            case 0x1f0ab0: ctx->pc = 0; goto label_1f0ab0;
            case 0x1f0ab4: ctx->pc = 0; goto label_1f0ab4;
            case 0x1f0ab8: ctx->pc = 0; goto label_1f0ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0a98: 0x8e4302e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 744)));
label_1f0a9c:
    // 0x1f0a9c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f0aa0: 0x8c620054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 84)));
    // 0x1f0aa4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f0aa8: 0x5440ffeb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
        ctx->pc = 0x1F0A58; return;
    }
label_1f0ab0:
    // 0x1f0ab0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1f0ab4:
    // 0x1f0ab4: 0xaea26250
    WRITE32(ADD32(GPR_U32(ctx, 21), 25168), GPR_U32(ctx, 2));
label_1f0ab8:
    // 0x1f0ab8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f0abc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f0ac0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f0ac4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f0ac8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0acc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f0ad0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f0ad4: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1f0ad8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateWm__FP2WMf
// Address: 0x1f0ae0 - 0x1f0b1c

void entry_1f0b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0b1c) {
        switch (ctx->pc) {
            case 0x1f0b44: ctx->pc = 0; goto label_1f0b44;
            case 0x1f0b54: ctx->pc = 0; goto label_1f0b54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0b1c: 0x8e4302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    // 0x1f0b20: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0b24: 0x10620022
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F0BB0; return;
    }
    // 0x1f0b2c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0b44;
    }
    // 0x1f0b34: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 748)));
        goto label_1f0b54;
    }
    // 0x1f0b3c: 0x10000099
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0DA4; return;
    }
label_1f0b44:
    // 0x1f0b44: 0x50620046
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 728)));
        ctx->pc = 0x1F0C60; return;
    }
    // 0x1f0b4c: 0x10000095
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0DA4; return;
    }
label_1f0b54:
    // 0x1f0b54: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 752)));
        ctx->pc = 0x1F0B6C; return;
    }
    // 0x1f0b5c: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1f0b64);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f0b64
// Address: 0x1f0b64 - 0x1f0b7c

void entry_1f0b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0b64) {
        switch (ctx->pc) {
            case 0x1f0b6c: ctx->pc = 0; goto label_1f0b6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0b64: 0xae4002ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 748), GPR_U32(ctx, 0));
    // 0x1f0b68: 0x8e4402f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 752)));
label_1f0b6c:
    // 0x1f0b6c: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 748)));
        ctx->pc = 0x1F0B84; return;
    }
    // 0x1f0b74: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1f0b7c);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f0b7c
// Address: 0x1f0b7c - 0x1f0ba8

void entry_1f0b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0b7c) {
        switch (ctx->pc) {
            case 0x1f0b84: ctx->pc = 0; goto label_1f0b84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0b7c: 0xae4002f0
    WRITE32(ADD32(GPR_U32(ctx, 18), 752), GPR_U32(ctx, 0));
    // 0x1f0b80: 0x8e4202ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 748)));
label_1f0b84:
    // 0x1f0b84: 0x54400087
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
        ctx->pc = 0x1F0DA4; return;
    }
    // 0x1f0b8c: 0x8e4202f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 752)));
    // 0x1f0b90: 0x54400084
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
        ctx->pc = 0x1F0DA4; return;
    }
    // 0x1f0b98: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f0b9c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f0ba0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f0ba8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f0ba8
// Address: 0x1f0ba8 - 0x1f0bc8

void entry_1f0ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0ba8) {
        switch (ctx->pc) {
            case 0x1f0bb0: ctx->pc = 0; goto label_1f0bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0ba8: 0x1000007e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0DA4; return;
    }
label_1f0bb0:
    // 0x1f0bb0: 0x8e4202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x1f0bb4: 0x8e4502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0bb8: 0x10450020
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x1F0C3C; return;
    }
    // 0x1f0bc0: 0xc07c21e
    SET_GPR_U32(ctx, 31, 0x1f0bc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefreshWmMoveStats__FP2WM10WORLDLEVEL(rdram, ctx, runtime); return;
}


// Function: entry_1f0bc8
// Address: 0x1f0bc8 - 0x1f0bdc

void entry_1f0bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0bc8: 0x8e4502d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x1f0bcc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0bd0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f0bd4: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f0bdc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f0bdc
// Address: 0x1f0bdc - 0x1f0c08

void entry_1f0bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0bdc) {
        switch (ctx->pc) {
            case 0x1f0bf4: ctx->pc = 0; goto label_1f0bf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0bdc: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0bf4;
    }
    // 0x1f0be4: 0x8e4202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x1f0be8: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0bec: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1f0bf0: 0xac400308
    WRITE32(ADD32(GPR_U32(ctx, 2), 776), GPR_U32(ctx, 0));
label_1f0bf4:
    // 0x1f0bf4: 0x8e4502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0bf8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0bfc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f0c00: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f0c08);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f0c08
// Address: 0x1f0c08 - 0x1f0c58

void entry_1f0c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0c08) {
        switch (ctx->pc) {
            case 0x1f0c28: ctx->pc = 0; goto label_1f0c28;
            case 0x1f0c3c: ctx->pc = 0; goto label_1f0c3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0c08: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0c28;
    }
    // 0x1f0c10: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0c14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f0c18: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f0c1c: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0c20: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1f0c24: 0xe4400308
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 776), *(uint32_t*)&val); }
label_1f0c28:
    // 0x1f0c28: 0xc640033c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 828)); ctx->f[0] = *(float*)&val; }
    // 0x1f0c2c: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0c30: 0xe64004dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1244), *(uint32_t*)&val); }
    // 0x1f0c34: 0xae4202d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 728), GPR_U32(ctx, 2));
    // 0x1f0c38: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1f0c3c:
    // 0x1f0c3c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1f0c40: 0xc44c186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[12] = *(float*)&val; }
    // 0x1f0c44: 0x24c66258
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 25176));
    // 0x1f0c48: 0x7a440540
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 18), 1344)));
    // 0x1f0c4c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f0c50: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1f0c58);
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 18), 1360)));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1f0c58
// Address: 0x1f0c58 - 0x1f0c84

void entry_1f0c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0c58) {
        switch (ctx->pc) {
            case 0x1f0c60: ctx->pc = 0; goto label_1f0c60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0c58: 0x10000051
    WRITE128(ADD32(GPR_U32(ctx, 18), 1344), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0DA0; return;
    }
label_1f0c60:
    // 0x1f0c60: 0x8e4502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0c64: 0x5045004f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
        ctx->pc = 0x1F0DA4; return;
    }
    // 0x1f0c6c: 0x8e420560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1376)));
    // 0x1f0c70: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        ctx->pc = 0x1F0CA8; return;
    }
    // 0x1f0c78: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0c7c: 0xc07c21e
    SET_GPR_U32(ctx, 31, 0x1f0c84);
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    RefreshWmMoveStats__FP2WM10WORLDLEVEL(rdram, ctx, runtime); return;
}


// Function: entry_1f0c84
// Address: 0x1f0c84 - 0x1f0c94

void entry_1f0c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0c84: 0x2611f138
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294963512));
    // 0x1f0c88: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f0c8c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1f0c94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f0c94
// Address: 0x1f0c94 - 0x1f0ca4

void entry_1f0c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0c94: 0x8e03f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294963512)));
    // 0x1f0c98: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f0c9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f0ca4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f0ca4
// Address: 0x1f0ca4 - 0x1f0cdc

void entry_1f0ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0ca4) {
        switch (ctx->pc) {
            case 0x1f0ca8: ctx->pc = 0; goto label_1f0ca8;
            case 0x1f0cc0: ctx->pc = 0; goto label_1f0cc0;
            case 0x1f0cc4: ctx->pc = 0; goto label_1f0cc4;
            case 0x1f0cd4: ctx->pc = 0; goto label_1f0cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0ca4: 0x8e4302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 732)));
label_1f0ca8:
    // 0x1f0ca8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f0cac: 0x14620004
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f0cc0;
    }
    // 0x1f0cb4: 0x8e420560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1376)));
    // 0x1f0cb8: 0x10400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0cc4;
    }
label_1f0cc0:
    // 0x1f0cc0: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
label_1f0cc4:
    // 0x1f0cc4: 0x12800003
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1f0cd4;
    }
    // 0x1f0ccc: 0x10000004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0CE0; return;
    }
label_1f0cd4:
    // 0x1f0cd4: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f0cdc);
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f0cdc
// Address: 0x1f0cdc - 0x1f0d08

void entry_1f0cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0cdc) {
        switch (ctx->pc) {
            case 0x1f0ce0: ctx->pc = 0; goto label_1f0ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0cdc: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1f0ce0:
    // 0x1f0ce0: 0x24110034
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1f0ce4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f0ce8: 0x2711818
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0cec: 0x8c455bf0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 23536)));
    // 0x1f0cf0: 0x722021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1f0cf4: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0cf8: 0x10a30013
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 760)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1F0D48; return;
    }
    // 0x1f0d00: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f0d08);
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f0d08
// Address: 0x1f0d08 - 0x1f0d84

void entry_1f0d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0d08) {
        switch (ctx->pc) {
            case 0x1f0d48: ctx->pc = 0; goto label_1f0d48;
            case 0x1f0d5c: ctx->pc = 0; goto label_1f0d5c;
            case 0x1f0d74: ctx->pc = 0; goto label_1f0d74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0d08: 0x511018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0d0c: 0x26430308
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 776));
    // 0x1f0d10: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f0d14: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f0d18: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f0d1c: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x1f0d20: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0d24: 0x512018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0d28: 0x831021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1f0d2c: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1f0d30: 0x8e4302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f0d34: 0x711018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f0d38: 0x521821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1f0d3c: 0xe4610300
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 768), *(uint32_t*)&val); }
    // 0x1f0d40: 0xc640033c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 828)); ctx->f[0] = *(float*)&val; }
    // 0x1f0d44: 0xe64004dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1244), *(uint32_t*)&val); }
label_1f0d48:
    // 0x1f0d48: 0x52000013
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
        ctx->pc = 0x1F0D98; return;
    }
    // 0x1f0d50: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f0d54: 0x56800001
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
        goto label_1f0d5c;
    }
label_1f0d5c:
    // 0x1f0d5c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f0d60: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f0d64: 0x12800003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1f0d74;
    }
    // 0x1f0d6c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1f0d70: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_1f0d74:
    // 0x1f0d74: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f0d78: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f0d7c: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1f0d84);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 752));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f0d84
// Address: 0x1f0d84 - 0x1f0d94

void entry_1f0d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0d84: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f0d88: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f0d8c: 0xc07c23c
    SET_GPR_U32(ctx, 31, 0x1f0d94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ThrowWmDisplayState__FP2WM10WORLDLEVELi(rdram, ctx, runtime); return;
}


// Function: entry_1f0d94
// Address: 0x1f0d94 - 0x1f0de4

void entry_1f0d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0d94) {
        switch (ctx->pc) {
            case 0x1f0d98: ctx->pc = 0; goto label_1f0d98;
            case 0x1f0da0: ctx->pc = 0; goto label_1f0da0;
            case 0x1f0da4: ctx->pc = 0; goto label_1f0da4;
            case 0x1f0dc8: ctx->pc = 0; goto label_1f0dc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0d94: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
label_1f0d98:
    // 0x1f0d98: 0xae400560
    WRITE32(ADD32(GPR_U32(ctx, 18), 1376), GPR_U32(ctx, 0));
    // 0x1f0d9c: 0xae4202d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 728), GPR_U32(ctx, 2));
label_1f0da0:
    // 0x1f0da0: 0x8e4202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 720)));
label_1f0da4:
    // 0x1f0da4: 0x10400037
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0E84; return;
    }
    // 0x1f0dac: 0x24170002
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0db0: 0x245e1858
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1f0db4: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x1f0db8: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f0dbc: 0x265002f8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 760));
    // 0x1f0dc0: 0x2414000a
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f0dc4: 0x0
    // NOP
label_1f0dc8:
    // 0x1f0dc8: 0xc60c0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[12] = *(float*)&val; }
    // 0x1f0dcc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f0dd0: 0xc60d0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 40)); ctx->f[13] = *(float*)&val; }
    // 0x1f0dd4: 0x24646268
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 25192));
    // 0x1f0dd8: 0xc7ce0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 20)); ctx->f[14] = *(float*)&val; }
    // 0x1f0ddc: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1f0de4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1f0de4
// Address: 0x1f0de4 - 0x1f0e00

void entry_1f0de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0de4: 0xe6000024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1f0de8: 0xc60c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1f0dec: 0xc7c00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1f0df0: 0xc601002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1f0df4: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1f0df8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1f0e00);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1f0e00
// Address: 0x1f0e00 - 0x1f0e38

void entry_1f0e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0e00) {
        switch (ctx->pc) {
            case 0x1f0e24: ctx->pc = 0; goto label_1f0e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0e00: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f0e04: 0x8e13000c
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1f0e08: 0x1220000d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F0E40; return;
    }
    // 0x1f0e10: 0x8e4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
    // 0x1f0e14: 0x8e230298
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 664)));
    // 0x1f0e18: 0x10570002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 25208));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 23)) {
        goto label_1f0e24;
    }
    // 0x1f0e20: 0x26a46288
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 25224));
label_1f0e24:
    // 0x1f0e24: 0xc46c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1f0e28: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1f0e2c: 0xc60d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[13] = *(float*)&val; }
    // 0x1f0e30: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1f0e38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1f0e38
// Address: 0x1f0e38 - 0x1f0e70

void entry_1f0e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0e38) {
        switch (ctx->pc) {
            case 0x1f0e40: ctx->pc = 0; goto label_1f0e40;
            case 0x1f0e5c: ctx->pc = 0; goto label_1f0e5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0e38: 0x8e220298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 664)));
    // 0x1f0e3c: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
label_1f0e40:
    // 0x1f0e40: 0x5260000e
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
        ctx->pc = 0x1F0E7C; return;
    }
    // 0x1f0e48: 0x8e4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
    // 0x1f0e4c: 0x8e630298
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 664)));
    // 0x1f0e50: 0x10570002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 25208));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 23)) {
        goto label_1f0e5c;
    }
    // 0x1f0e58: 0x26a46288
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 25224));
label_1f0e5c:
    // 0x1f0e5c: 0xc46c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1f0e60: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1f0e64: 0xc60d0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[13] = *(float*)&val; }
    // 0x1f0e68: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1f0e70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1f0e70
// Address: 0x1f0e70 - 0x1f0eb8

void entry_1f0e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0e70) {
        switch (ctx->pc) {
            case 0x1f0e7c: ctx->pc = 0; goto label_1f0e7c;
            case 0x1f0e84: ctx->pc = 0; goto label_1f0e84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0e70: 0x8e620298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 664)));
    // 0x1f0e74: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1f0e78: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
label_1f0e7c:
    // 0x1f0e7c: 0x681ffd2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x1F0DC8; return;
    }
label_1f0e84:
    // 0x1f0e84: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f0e88: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f0e8c: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f0e90: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f0e94: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f0e98: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f0e9c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f0ea0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f0ea4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f0ea8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f0eac: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1f0eb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderWmAll__FP2WMP2CMP2RO
// Address: 0x1f0eb8 - 0x1f0f04

void entry_1f0f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0f04: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f0f08: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f0f0c: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x1f0f14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_1f0f14
// Address: 0x1f0f14 - 0x1f0f24

void entry_1f0f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0f14: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f0f18: 0x26040040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 64));
    // 0x1f0f1c: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1f0f24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 128));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1f0f24
// Address: 0x1f0f24 - 0x1f0f34

void entry_1f0f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0f24: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f0f28: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f0f2c: 0xc049724
    SET_GPR_U32(ctx, 31, 0x1f0f34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_1f0f34
// Address: 0x1f0f34 - 0x1f0f40

void entry_1f0f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0f34: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1f0f38: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1f0f40);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1f0f40
// Address: 0x1f0f40 - 0x1f0f70

void entry_1f0f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f0f40: 0x8e421990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1f0f44: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f0f48: 0xe45501c8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
    // 0x1f0f4c: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f0f50: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f0f54: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f0f58: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f0f5c: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x1f0f60: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1f0f64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f0f6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f0f70; return;
}


// Function: HandleWmMessage__FP2WM5MSGIDPv
// Address: 0x1f0f70 - 0x1f0f94

void entry_1f0f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0f94) {
        switch (ctx->pc) {
            case 0x1f0fc8: ctx->pc = 0; goto label_1f0fc8;
            case 0x1f0fdc: ctx->pc = 0; goto label_1f0fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0f94: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f0f98: 0x16020028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F103C; return;
    }
    // 0x1f0fa0: 0x8e2302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x1f0fa4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f0fa8: 0x10650010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x1F0FEC; return;
    }
    // 0x1f0fb0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0fc8;
    }
    // 0x1f0fb8: 0x10620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f0fdc;
    }
    // 0x1f0fc0: 0x1000001f
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1040; return;
    }
label_1f0fc8:
    // 0x1f0fc8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f0fcc: 0x1062000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F1004; return;
    }
    // 0x1f0fd4: 0x1000001a
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1040; return;
    }
label_1f0fdc:
    // 0x1f0fdc: 0xc07c414
    SET_GPR_U32(ctx, 31, 0x1f0fe4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 736)));
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f0fe4
// Address: 0x1f0fe4 - 0x1f0ffc

void entry_1f0fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0fe4) {
        switch (ctx->pc) {
            case 0x1f0fec: ctx->pc = 0; goto label_1f0fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0fe4: 0x10000015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F103C; return;
    }
label_1f0fec:
    // 0x1f0fec: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f0ff0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f0ff4: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1f0ffc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1f0ffc
// Address: 0x1f0ffc - 0x1f102c

void entry_1f0ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f0ffc) {
        switch (ctx->pc) {
            case 0x1f1004: ctx->pc = 0; goto label_1f1004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f0ffc: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F103C; return;
    }
label_1f1004:
    // 0x1f1004: 0x8e2202ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 748)));
    // 0x1f1008: 0x1642000d
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F1040; return;
    }
    // 0x1f1010: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f1014: 0x24445f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 24448));
    // 0x1f1018: 0x8c830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1f101c: 0x54650004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F1030; return;
    }
    // 0x1f1024: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1f102c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1f102c
// Address: 0x1f102c - 0x1f1038

void entry_1f102c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f102c) {
        switch (ctx->pc) {
            case 0x1f1030: ctx->pc = 0; goto label_1f1030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f102c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f1030:
    // 0x1f1030: 0xc07c414
    SET_GPR_U32(ctx, 31, 0x1f1038);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f1038
// Address: 0x1f1038 - 0x1f1050

void entry_1f1038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1038) {
        switch (ctx->pc) {
            case 0x1f103c: ctx->pc = 0; goto label_1f103c;
            case 0x1f1040: ctx->pc = 0; goto label_1f1040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1038: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1f103c:
    // 0x1f103c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1f1040:
    // 0x1f1040: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f1044: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f1048: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetWmWms__FP2WM3WMS
// Address: 0x1f1050 - 0x1f10dc

void entry_1f10dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f10dc) {
        switch (ctx->pc) {
            case 0x1f10e4: ctx->pc = 0; goto label_1f10e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f10dc: 0x1000005a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1248; return;
    }
label_1f10e4:
    // 0x1f10e4: 0x8e620560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1376)));
    // 0x1f10e8: 0x14400007
    SET_GPR_U32(ctx, 21, SLTU32(GPR_U32(ctx, 22), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1108; return;
    }
    // 0x1f10f0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f10f4: 0x8c83f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294963512)));
    // 0x1f10f8: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1f10fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f1104);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294963512));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f1104
// Address: 0x1f1104 - 0x1f1160

void entry_1f1104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1104) {
        switch (ctx->pc) {
            case 0x1f1108: ctx->pc = 0; goto label_1f1108;
            case 0x1f1118: ctx->pc = 0; goto label_1f1118;
            case 0x1f113c: ctx->pc = 0; goto label_1f113c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1104: 0x2ed50005
    SET_GPR_U32(ctx, 21, SLTU32(GPR_U32(ctx, 22), 5));
label_1f1108:
    // 0x1f1108: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x1f110c: 0x2403000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f1110: 0x26620528
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 1320));
    // 0x1f1114: 0x0
    // NOP
label_1f1118:
    // 0x1f1118: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x1f111c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1f1120: 0x0
    // NOP
    // 0x1f1124: 0x0
    // NOP
    // 0x1f1128: 0x0
    // NOP
    // 0x1f112c: 0x461fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967244));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1f1118;
    }
    // 0x1f1134: 0x10000044
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1248; return;
    }
label_1f113c:
    // 0x1f113c: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1f1140: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f1144: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1148: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1f114c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1150: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1f1154: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x1f1158: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f1160);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f1160
// Address: 0x1f1160 - 0x1f117c

void entry_1f1160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1160) {
        switch (ctx->pc) {
            case 0x1f1168: ctx->pc = 0; goto label_1f1168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1160: 0x267002f8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 760));
    // 0x1f1164: 0x0
    // NOP
label_1f1168:
    // 0x1f1168: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f116c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f1170: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1174: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f117c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f117c
// Address: 0x1f117c - 0x1f119c

void entry_1f117c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f117c: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
        ctx->pc = 0x1F11AC; return;
    }
    // 0x1f1184: 0xe6140008
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1f1188: 0x8e6202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 736)));
    // 0x1f118c: 0x54520003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 732)));
        entry_1f119c(rdram, ctx, runtime); return;
    }
    // 0x1f1194: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f119c);
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f119c
// Address: 0x1f119c - 0x1f11ec

void entry_1f119c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f119c) {
        switch (ctx->pc) {
            case 0x1f11ac: ctx->pc = 0; goto label_1f11ac;
            case 0x1f11b0: ctx->pc = 0; goto label_1f11b0;
            case 0x1f11d0: ctx->pc = 0; goto label_1f11d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f119c: 0x56220004
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
        goto label_1f11b0;
    }
    // 0x1f11a4: 0x10000002
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f11b0;
    }
label_1f11ac:
    // 0x1f11ac: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
label_1f11b0:
    // 0x1f11b0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f11b4: 0x2a22000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 11));
    // 0x1f11b8: 0x1440ffeb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 52));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1168; return;
    }
    // 0x1f11c0: 0xc660033c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 828)); ctx->f[0] = *(float*)&val; }
    // 0x1f11c4: 0x267202f8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 760));
    // 0x1f11c8: 0x2414000a
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f11cc: 0xe66004dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 1244), *(uint32_t*)&val); }
label_1f11d0:
    // 0x1f11d0: 0x8e500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1f11d4: 0x1200000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1208; return;
    }
    // 0x1f11dc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f11e0: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1f11e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f11ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f11ec
// Address: 0x1f11ec - 0x1f11f4

void entry_1f11ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f11ec: 0xc049b16
    SET_GPR_U32(ctx, 31, 0x1f11f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnsureAloFader__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f11f4
// Address: 0x1f11f4 - 0x1f1220

void entry_1f11f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f11f4) {
        switch (ctx->pc) {
            case 0x1f1208: ctx->pc = 0; goto label_1f1208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f11f4: 0x8e020298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    // 0x1f11f8: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1f11fc: 0x8e030298
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    // 0x1f1200: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1f1204: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
label_1f1208:
    // 0x1f1208: 0x5220000d
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
        ctx->pc = 0x1F1240; return;
    }
    // 0x1f1210: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f1214: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1f1218: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f1220);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f1220
// Address: 0x1f1220 - 0x1f1228

void entry_1f1220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1220: 0xc049b16
    SET_GPR_U32(ctx, 31, 0x1f1228);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    EnsureAloFader__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f1228
// Address: 0x1f1228 - 0x1f1294

void entry_1f1228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1228) {
        switch (ctx->pc) {
            case 0x1f1240: ctx->pc = 0; goto label_1f1240;
            case 0x1f1248: ctx->pc = 0; goto label_1f1248;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1228: 0x8e220298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 664)));
    // 0x1f122c: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1f1230: 0x8e230298
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 664)));
    // 0x1f1234: 0xc6400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f1238: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x1f123c: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
label_1f1240:
    // 0x1f1240: 0x681ffe3
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 52));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x1F11D0; return;
    }
label_1f1248:
    // 0x1f1248: 0x12a000c0
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F154C; return;
    }
    // 0x1f1250: 0x161880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 22), 2));
    // 0x1f1254: 0x2442e7f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961136));
    // 0x1f1258: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f125c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f1260: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1f1268: 0x8e6302e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 736)));
    // 0x1f126c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f1270: 0x54620018
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 812)));
        ctx->pc = 0x1F12D4; return;
    }
    // 0x1f1278: 0x8e6302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 732)));
    // 0x1f127c: 0x38620001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 1));
    // 0x1f1280: 0x2802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1f1284: 0x16000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1298; return;
    }
    // 0x1f128c: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f1294);
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f1294
// Address: 0x1f1294 - 0x1f12cc

void entry_1f1294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1294) {
        switch (ctx->pc) {
            case 0x1f1298: ctx->pc = 0; goto label_1f1298;
            case 0x1f12b8: ctx->pc = 0; goto label_1f12b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1294: 0x24030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 52));
label_1f1298:
    // 0x1f1298: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f129c: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1f12a0: 0x8c4402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 760)));
    // 0x1f12a4: 0x5080004d
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 732)));
        ctx->pc = 0x1F13DC; return;
    }
    // 0x1f12ac: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f12b0: 0x56000001
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[12] = *(float*)&val; }
        goto label_1f12b8;
    }
label_1f12b8:
    // 0x1f12b8: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1f12bc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f12c0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f12c4: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1f12cc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 752));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f12cc
// Address: 0x1f12cc - 0x1f12f0

void entry_1f12cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f12cc) {
        switch (ctx->pc) {
            case 0x1f12d4: ctx->pc = 0; goto label_1f12d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f12cc: 0x10000043
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 732)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F13DC; return;
    }
label_1f12d4:
    // 0x1f12d4: 0x10800006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1f12f0(rdram, ctx, runtime); return;
    }
    // 0x1f12dc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f12e0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f12e4: 0x266702f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 752));
    // 0x1f12e8: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1f12f0);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f12f0
// Address: 0x1f12f0 - 0x1f1304

void entry_1f12f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f12f0: 0x8e6502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 732)));
    // 0x1f12f4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f12f8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1f12fc: 0xc07c62c
    SET_GPR_U32(ctx, 31, 0x1f1304);
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    SetWmCursor__FP2WM10WORLDLEVEL(rdram, ctx, runtime); return;
}


// Function: entry_1f1304
// Address: 0x1f1304 - 0x1f1324

void entry_1f1304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1304: 0x2630f138
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294963512));
    // 0x1f1308: 0x7a620550
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 1360)));
    // 0x1f130c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f1310: 0x8e6502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 732)));
    // 0x1f1314: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
    // 0x1f1318: 0x7e620540
    WRITE128(ADD32(GPR_U32(ctx, 19), 1344), GPR_VEC(ctx, 2));
    // 0x1f131c: 0xc07c21e
    SET_GPR_U32(ctx, 31, 0x1f1324);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RefreshWmMoveStats__FP2WM10WORLDLEVEL(rdram, ctx, runtime); return;
}


// Function: entry_1f1324
// Address: 0x1f1324 - 0x1f1334

void entry_1f1324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1324: 0x267202f8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 760));
    // 0x1f1328: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f132c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1f1334);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f1334
// Address: 0x1f1334 - 0x1f1344

void entry_1f1334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1334: 0x8e23f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1f1338: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f133c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f1344);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f1344
// Address: 0x1f1344 - 0x1f1384

void entry_1f1344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1344: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1f1348: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1f134c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f1350: 0x2404008a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 138));
    // 0x1f1354: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f1358: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f135c: 0x26650564
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1380));
    // 0x1f1360: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1364: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f1368: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f136c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1370: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1f1374: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1f1378: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f137c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1f1384);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1f1384
// Address: 0x1f1384 - 0x1f1394

void entry_1f1384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1384) {
        switch (ctx->pc) {
            case 0x1f1388: ctx->pc = 0; goto label_1f1388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1384: 0x0
    // NOP
label_1f1388:
    // 0x1f1388: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f138c: 0xc07c160
    SET_GPR_U32(ctx, 31, 0x1f1394);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_001f0580(rdram, ctx, runtime); return;
}


// Function: entry_1f1394
// Address: 0x1f1394 - 0x1f140c

void entry_1f1394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1394) {
        switch (ctx->pc) {
            case 0x1f13bc: ctx->pc = 0; goto label_1f13bc;
            case 0x1f13c0: ctx->pc = 0; goto label_1f13c0;
            case 0x1f13dc: ctx->pc = 0; goto label_1f13dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1394: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1398: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 18), 28), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f13bc;
    }
    // 0x1f13a0: 0x2682fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294967294));
    // 0x1f13a4: 0x2c420006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 6));
    // 0x1f13a8: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1f13bc;
    }
    // 0x1f13b0: 0x56800003
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 3));
        goto label_1f13c0;
    }
    // 0x1f13b8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_1f13bc:
    // 0x1f13bc: 0xae430020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 3));
label_1f13c0:
    // 0x1f13c0: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1f13c4: 0xe6550028
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 18), 40), *(uint32_t*)&val); }
    // 0x1f13c8: 0x2a82000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 11));
    // 0x1f13cc: 0xe6550024
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 18), 36), *(uint32_t*)&val); }
    // 0x1f13d0: 0x1440ffed
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 52));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1388; return;
    }
    // 0x1f13d8: 0x8e6202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 732)));
label_1f13dc:
    // 0x1f13dc: 0x8e6402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 740)));
    // 0x1f13e0: 0x14800022
    WRITE32(ADD32(GPR_U32(ctx, 19), 728), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F146C; return;
    }
    // 0x1f13e8: 0x10000058
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F154C; return;
    }
    // 0x1f13f0: 0x8e620560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1376)));
    // 0x1f13f4: 0x14400018
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1f1458(rdram, ctx, runtime); return;
    }
    // 0x1f13fc: 0x8c83f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294963512)));
    // 0x1f1400: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1f1404: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f140c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294963512));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f140c
// Address: 0x1f140c - 0x1f1458

void entry_1f140c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f140c: 0x8e6302e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 736)));
    // 0x1f1410: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f1414: 0x14620010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 139));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        entry_1f1458(rdram, ctx, runtime); return;
    }
    // 0x1f141c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1f1420: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1f1424: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1f1428: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f142c: 0x26650564
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1380));
    // 0x1f1430: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f1434: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f1438: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f143c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1440: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f1444: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1448: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1f144c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1450: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1f1458);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1f1458
// Address: 0x1f1458 - 0x1f1460

void entry_1f1458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1458: 0xc07c242
    SET_GPR_U32(ctx, 31, 0x1f1460);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    CatchWmDisplayState__FP2WM(rdram, ctx, runtime); return;
}


// Function: entry_1f1460
// Address: 0x1f1460 - 0x1f1488

void entry_1f1460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1460) {
        switch (ctx->pc) {
            case 0x1f146c: ctx->pc = 0; goto label_1f146c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1460: 0x8e6402e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 744)));
    // 0x1f1464: 0x50800039
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F154C; return;
    }
label_1f146c:
    // 0x1f146c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f1470: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f1474: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1478: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f147c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1480: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1f1488);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 748));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f1488
// Address: 0x1f1488 - 0x1f1500

void entry_1f1488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1488) {
        switch (ctx->pc) {
            case 0x1f14a0: ctx->pc = 0; goto label_1f14a0;
            case 0x1f14ac: ctx->pc = 0; goto label_1f14ac;
            case 0x1f14e0: ctx->pc = 0; goto label_1f14e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1488: 0x10000031
    WRITE32(ADD32(GPR_U32(ctx, 19), 720), GPR_U32(ctx, 22));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1550; return;
    }
    // 0x1f1490: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1494: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f1498: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f149c: 0x26630320
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 800));
label_1f14a0:
    // 0x1f14a0: 0x8e620534
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1332)));
    // 0x1f14a4: 0x54820001
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
        goto label_1f14ac;
    }
label_1f14ac:
    // 0x1f14ac: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f14b0: 0x2882000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 11));
    // 0x1f14b4: 0x1440fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 52));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f14a0;
    }
    // 0x1f14bc: 0x10000024
    WRITE32(ADD32(GPR_U32(ctx, 19), 720), GPR_U32(ctx, 22));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1550; return;
    }
    // 0x1f14c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f14c8: 0x10000020
    WRITE32(ADD32(GPR_U32(ctx, 19), 728), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F154C; return;
    }
    // 0x1f14d0: 0x26720304
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 772));
    // 0x1f14d4: 0x267402fc
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 19), 764));
    // 0x1f14d8: 0x26750540
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 19), 1344));
    // 0x1f14dc: 0x0
    // NOP
label_1f14e0:
    // 0x1f14e0: 0x8e900000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1f14e4: 0x1200000a
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1f1510(rdram, ctx, runtime); return;
    }
    // 0x1f14ec: 0x8e040298
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 664)));
    // 0x1f14f0: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F1504; return;
    }
    // 0x1f14f8: 0xc05670a
    SET_GPR_U32(ctx, 31, 0x1f1500);
    RemoveFader__FP5FADER(rdram, ctx, runtime); return;
}


// Function: entry_1f1500
// Address: 0x1f1500 - 0x1f1510

void entry_1f1500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1500) {
        switch (ctx->pc) {
            case 0x1f1504: ctx->pc = 0; goto label_1f1504;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1500: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1f1504:
    // 0x1f1504: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f1508: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f1510);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f1510
// Address: 0x1f1510 - 0x1f152c

void entry_1f1510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1510: 0x5220000b
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 52));
        ctx->pc = 0x1F1540; return;
    }
    // 0x1f1518: 0x8e240298
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 664)));
    // 0x1f151c: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1F1530; return;
    }
    // 0x1f1524: 0xc05670a
    SET_GPR_U32(ctx, 31, 0x1f152c);
    RemoveFader__FP5FADER(rdram, ctx, runtime); return;
}


// Function: entry_1f152c
// Address: 0x1f152c - 0x1f153c

void entry_1f152c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f152c) {
        switch (ctx->pc) {
            case 0x1f1530: ctx->pc = 0; goto label_1f1530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f152c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1f1530:
    // 0x1f1530: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f1534: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f153c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f153c
// Address: 0x1f153c - 0x1f1590

void entry_1f153c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f153c) {
        switch (ctx->pc) {
            case 0x1f1540: ctx->pc = 0; goto label_1f1540;
            case 0x1f154c: ctx->pc = 0; goto label_1f154c;
            case 0x1f1550: ctx->pc = 0; goto label_1f1550;
            case 0x1f155c: ctx->pc = 0; goto label_1f155c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f153c: 0x26520034
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 52));
label_1f1540:
    // 0x1f1540: 0x255102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 21)));
    // 0x1f1544: 0x1440ffe6
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 52));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F14E0; return;
    }
label_1f154c:
    // 0x1f154c: 0xae7602d0
    WRITE32(ADD32(GPR_U32(ctx, 19), 720), GPR_U32(ctx, 22));
label_1f1550:
    // 0x1f1550: 0x26e21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
    // 0x1f1554: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f1558: 0xe66002d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 724), *(uint32_t*)&val); }
label_1f155c:
    // 0x1f155c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f1560: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f1564: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f1568: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f156c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f1570: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f1574: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f1578: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f157c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f1580: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1f1584: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1f1588: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ShowWm__FP2WM10WORLDLEVEL3WMS
// Address: 0x1f1590 - 0x1f15e0

void entry_1f15e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f15e0) {
        switch (ctx->pc) {
            case 0x1f15e8: ctx->pc = 0; goto label_1f15e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f15e0: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1604; return;
    }
label_1f15e8:
    // 0x1f15e8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f15ec: 0x14c20004
    WRITE32(ADD32(GPR_U32(ctx, 7), 732), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        entry_1f1600(rdram, ctx, runtime); return;
    }
    // 0x1f15f4: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1f15f8: 0xc07c414
    SET_GPR_U32(ctx, 31, 0x1f1600);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f1600
// Address: 0x1f1600 - 0x1f1610

void entry_1f1600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1600) {
        switch (ctx->pc) {
            case 0x1f1604: ctx->pc = 0; goto label_1f1604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1600: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1f1604:
    // 0x1f1604: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f160c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f1610; return;
}


// Function: HideWm__FP2WM
// Address: 0x1f1610 - 0x1f1638

void entry_1f1638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1638) {
        switch (ctx->pc) {
            case 0x1f163c: ctx->pc = 0; goto label_1f163c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1638: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1f163c:
    // 0x1f163c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f1644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f1648; return;
}


// Function: MoveWm__FP2WM3WMD
// Address: 0x1f1648 - 0x1f170c

void entry_1f170c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f170c) {
        switch (ctx->pc) {
            case 0x1f1714: ctx->pc = 0; goto label_1f1714;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f170c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1f1710: 0x24040079
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 121));
label_1f1714:
    // 0x1f1714: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1f1718: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1f171c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f1720: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1724: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f1728: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f172c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1730: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1734: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f1738: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f173c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1f1740: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1744: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1f174c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1f174c
// Address: 0x1f174c - 0x1f1794

void entry_1f174c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f174c) {
        switch (ctx->pc) {
            case 0x1f1754: ctx->pc = 0; goto label_1f1754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f174c: 0x10000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1798; return;
    }
label_1f1754:
    // 0x1f1754: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1f1758: 0x2404007b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    // 0x1f175c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1f1760: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1f1764: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f1768: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f176c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f1770: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f1774: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1778: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f177c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f1780: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1784: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1f1788: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f178c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1f1794);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1f1794
// Address: 0x1f1794 - 0x1f17a0

void entry_1f1794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1794) {
        switch (ctx->pc) {
            case 0x1f1798: ctx->pc = 0; goto label_1f1798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1794: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1f1798:
    // 0x1f1798: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR
// Address: 0x1f17a0 - 0x1f17f4

void entry_1f17f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f17f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f17f8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f17fc: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1f1800: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f1804: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1808: 0x24620080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 128));
    // 0x1f180c: 0xd8640080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x1f1810: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1f1814: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f1818: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1f181c: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f1820: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f1824: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f1828: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f182c: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1f1830: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f1834: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1f183c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1f183c
// Address: 0x1f183c - 0x1f18b0

void entry_1f183c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f183c) {
        switch (ctx->pc) {
            case 0x1f1880: ctx->pc = 0; goto label_1f1880;
            case 0x1f189c: ctx->pc = 0; goto label_1f189c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f183c: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f1840: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x1f1844: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1f1848: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1f184c: 0x3c01c376
    SET_GPR_U32(ctx, 1, ((uint32_t)50038 << 16));
    // 0x1f1850: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1f1854: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1f1858: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1f185c: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x1f1860: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1f1864: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1f1868: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1f186c: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1f1870: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1f1874: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1f1878: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f189c;
    }
label_1f1880:
    // 0x1f1880: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x1f1884: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f1888: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x1f188c: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1f1890: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f1894: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1f1898: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
label_1f189c:
    // 0x1f189c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f18a0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f18a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f18ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f18b0; return;
}


// Function: SetWmCursor__FP2WM10WORLDLEVEL
// Address: 0x1f18b0 - 0x1f18f8

void entry_1f18f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f18f8) {
        switch (ctx->pc) {
            case 0x1f1900: ctx->pc = 0; goto label_1f1900;
            case 0x1f1914: ctx->pc = 0; goto label_1f1914;
            case 0x1f1944: ctx->pc = 0; goto label_1f1944;
            case 0x1f1948: ctx->pc = 0; goto label_1f1948;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f18f8: 0x10000006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f1914;
    }
label_1f1900:
    // 0x1f1900: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f1904: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1f1908: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f190c: 0x7e030550
    WRITE128(ADD32(GPR_U32(ctx, 16), 1360), GPR_VEC(ctx, 3));
    // 0x1f1910: 0x24050034
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
label_1f1914:
    // 0x1f1914: 0x26040320
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 800));
    // 0x1f1918: 0x2251018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f191c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f1920: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1f1924: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x1f1928: 0x8e020534
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1332)));
    // 0x1f192c: 0x10430005
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_1f1944;
    }
    // 0x1f1934: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1938: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f193c: 0x641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f1940: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
label_1f1944:
    // 0x1f1944: 0xae110534
    WRITE32(ADD32(GPR_U32(ctx, 16), 1332), GPR_U32(ctx, 17));
label_1f1948:
    // 0x1f1948: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f194c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f1950: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f1954: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f195c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f1960; return;
}


// Function: PostWmcLoad__FP3WMC
// Address: 0x1f1960 - 0x1f1974

void entry_1f1974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1974: 0xc057062
    SET_GPR_U32(ctx, 31, 0x1f197c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_1f197c
// Address: 0x1f197c - 0x1f1994

void entry_1f197c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f197c: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F199C; return;
    }
    // 0x1f1984: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f1988: 0x24426620
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 26144));
    // 0x1f198c: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1f1994);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1f1994
// Address: 0x1f1994 - 0x1f19a8

void entry_1f1994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1994) {
        switch (ctx->pc) {
            case 0x1f199c: ctx->pc = 0; goto label_1f199c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1994: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x1f1998: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1f199c:
    // 0x1f199c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f19a0: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1f19a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f19a8
// Address: 0x1f19a8 - 0x1f19bc

void entry_1f19a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f19a8: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1f19ac: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1f19b0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f19b4: 0xc06a9e2
    SET_GPR_U32(ctx, 31, 0x1f19bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotFontScale__FfP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1f19bc
// Address: 0x1f19bc - 0x1f19e0

void entry_1f19bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f19bc: 0x3c02df7f
    SET_GPR_U32(ctx, 2, ((uint32_t)57215 << 16));
    // 0x1f19c0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f19c4: 0x34427f7f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32639));
    // 0x1f19c8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1f19cc: 0xae020208
    WRITE32(ADD32(GPR_U32(ctx, 16), 520), GPR_U32(ctx, 2));
    // 0x1f19d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f19d4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1f19d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f19e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294961160));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f19e0
// Address: 0x1f19e0 - 0x1f19f4

void entry_1f19e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f19e0: 0xae000260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    // 0x1f19e4: 0x26040264
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 612));
    // 0x1f19e8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f19ec: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1f19f4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1f19f4
// Address: 0x1f19f4 - 0x1f1a08

void entry_1f19f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f19f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f19f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f19fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f1a04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f1a08; return;
}


// Function: UpdateWmcActive__FP3WMCP3JOY
// Address: 0x1f1a08 - 0x1f1a80

void entry_1f1a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1a80: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f1a84: 0x24050910
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2320));
    // 0x1f1a88: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1f1a90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1f1a90
// Address: 0x1f1a90 - 0x1f1ab0

void entry_1f1a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1a90) {
        switch (ctx->pc) {
            case 0x1f1a98: ctx->pc = 0; goto label_1f1a98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1a90: 0x10000077
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1C70; return;
    }
label_1f1a98:
    // 0x1f1a98: 0x14430075
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1F1C70; return;
    }
    // 0x1f1aa0: 0x8c8502dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 732)));
    // 0x1f1aa4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f1aa8: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f1ab0);
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 29), 4));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f1ab0
// Address: 0x1f1ab0 - 0x1f1abc

void entry_1f1ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1ab0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1ab4: 0xc05bb26
    SET_GPR_U32(ctx, 31, 0x1f1abc);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    DxSelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1f1abc
// Address: 0x1f1abc - 0x1f1ac8

void entry_1f1abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1abc: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f1ac0: 0xc05bbb4
    SET_GPR_U32(ctx, 31, 0x1f1ac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DySelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1f1ac8
// Address: 0x1f1ac8 - 0x1f1b08

void entry_1f1ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1ac8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f1acc: 0xc6000034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1f1ad0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f1ad4: 0xc602003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 60)); ctx->f[2] = *(float*)&val; }
    // 0x1f1ad8: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f1adc: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1f1ae0: 0xc4410010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1f1ae4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1f1ae8: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x1f1aec: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f1af0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1f1af4: 0x4610006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 3) >= 0) {
        ctx->pc = 0x1F1B10; return;
    }
    // 0x1f1afc: 0x8e240260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1f1b00: 0xc07c592
    SET_GPR_U32(ctx, 31, 0x1f1b08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MoveWm__FP2WM3WMD(rdram, ctx, runtime); return;
}


// Function: entry_1f1b08
// Address: 0x1f1b08 - 0x1f1b24

void entry_1f1b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1b08) {
        switch (ctx->pc) {
            case 0x1f1b10: ctx->pc = 0; goto label_1f1b10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1b08: 0x10000047
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1b10:
    // 0x1f1b10: 0x18600006
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F1B2C; return;
    }
    // 0x1f1b18: 0x8e240260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1f1b1c: 0xc07c592
    SET_GPR_U32(ctx, 31, 0x1f1b24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    MoveWm__FP2WM3WMD(rdram, ctx, runtime); return;
}


// Function: entry_1f1b24
// Address: 0x1f1b24 - 0x1f1b40

void entry_1f1b24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1b24) {
        switch (ctx->pc) {
            case 0x1f1b2c: ctx->pc = 0; goto label_1f1b2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1b24: 0x10000040
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1b2c:
    // 0x1f1b2c: 0x6410006
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1F1B48; return;
    }
    // 0x1f1b34: 0x8e240260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1f1b38: 0xc07c592
    SET_GPR_U32(ctx, 31, 0x1f1b40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    MoveWm__FP2WM3WMD(rdram, ctx, runtime); return;
}


// Function: entry_1f1b40
// Address: 0x1f1b40 - 0x1f1b5c

void entry_1f1b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1b40) {
        switch (ctx->pc) {
            case 0x1f1b48: ctx->pc = 0; goto label_1f1b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1b40: 0x10000039
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1b48:
    // 0x1f1b48: 0x5a400006
    if (GPR_S32(ctx, 18) <= 0) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x1F1B64; return;
    }
    // 0x1f1b50: 0x8e240260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1f1b54: 0xc07c592
    SET_GPR_U32(ctx, 31, 0x1f1b5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    MoveWm__FP2WM3WMD(rdram, ctx, runtime); return;
}


// Function: entry_1f1b5c
// Address: 0x1f1b5c - 0x1f1b7c

void entry_1f1b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1b5c) {
        switch (ctx->pc) {
            case 0x1f1b64: ctx->pc = 0; goto label_1f1b64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1b5c: 0x10000032
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1b64:
    // 0x1f1b64: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x1f1b68: 0x1040002f
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
    // 0x1f1b70: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f1b74: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1f1b7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1f1b7c
// Address: 0x1f1b7c - 0x1f1b84

void entry_1f1b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1b7c: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f1b84);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f1b84
// Address: 0x1f1b84 - 0x1f1ba8

void entry_1f1b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1b84: 0x8e0302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 732)));
    // 0x1f1b88: 0x10620025
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F1C20; return;
    }
    // 0x1f1b90: 0x12600011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1BD8; return;
    }
    // 0x1f1b98: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f1b9c: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x1f1ba0: 0xc058060
    SET_GPR_U32(ctx, 31, 0x1f1ba8);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    call_search_level_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1f1ba8
// Address: 0x1f1ba8 - 0x1f1bc0

void entry_1f1ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1ba8: 0x8e230260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1f1bac: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f1bb0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f1bb4: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1f1bb8: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x1f1bc0);
    WRITE32(ADD32(GPR_U32(ctx, 3), 1376), GPR_U32(ctx, 20));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1f1bc0
// Address: 0x1f1bc0 - 0x1f1bd0

void entry_1f1bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1bc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1bc4: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f1bc8: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x1f1bd0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_1f1bd0
// Address: 0x1f1bd0 - 0x1f1c18

void entry_1f1bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1bd0) {
        switch (ctx->pc) {
            case 0x1f1bd8: ctx->pc = 0; goto label_1f1bd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1bd0: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1bd8:
    // 0x1f1bd8: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1f1bdc: 0x2404007b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    // 0x1f1be0: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1f1be4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1f1be8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f1bec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1bf0: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f1bf4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f1bf8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1bfc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1c00: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f1c04: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1c08: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1f1c0c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1c10: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1f1c18);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1f1c18
// Address: 0x1f1c18 - 0x1f1c28

void entry_1f1c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1c18) {
        switch (ctx->pc) {
            case 0x1f1c20: ctx->pc = 0; goto label_1f1c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1c18: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f1c28(rdram, ctx, runtime); return;
    }
label_1f1c20:
    // 0x1f1c20: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x1f1c28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1f1c28
// Address: 0x1f1c28 - 0x1f1c68

void entry_1f1c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1c28) {
        switch (ctx->pc) {
            case 0x1f1c40: ctx->pc = 0; goto label_1f1c40;
            case 0x1f1c48: ctx->pc = 0; goto label_1f1c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1c28: 0x12600005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1f1c40;
    }
    // 0x1f1c30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1c34: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f1c38: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 640), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f1c48;
    }
label_1f1c40:
    // 0x1f1c40: 0xc4405fc0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24512)); ctx->f[0] = *(float*)&val; }
    // 0x1f1c44: 0xe6200280
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 640), *(uint32_t*)&val); }
label_1f1c48:
    // 0x1f1c48: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1f1c4c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f1c50: 0xc44e0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[14] = *(float*)&val; }
    // 0x1f1c54: 0x24846278
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 25208));
    // 0x1f1c58: 0xc62c027c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 636)); ctx->f[12] = *(float*)&val; }
    // 0x1f1c5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1c60: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1f1c68);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 640)); ctx->f[13] = *(float*)&val; }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1f1c68
// Address: 0x1f1c68 - 0x1f1c90

void entry_1f1c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1c68) {
        switch (ctx->pc) {
            case 0x1f1c6c: ctx->pc = 0; goto label_1f1c6c;
            case 0x1f1c70: ctx->pc = 0; goto label_1f1c70;
            case 0x1f1c74: ctx->pc = 0; goto label_1f1c74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1c68: 0xe620027c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 636), *(uint32_t*)&val); }
label_1f1c6c:
    // 0x1f1c6c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1f1c70:
    // 0x1f1c70: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1f1c74:
    // 0x1f1c74: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f1c78: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f1c7c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f1c80: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f1c84: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f1c88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnWmcActive__FP3WMCi
// Address: 0x1f1c90 - 0x1f1ccc

void entry_1f1ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1ccc: 0xc07c11a
    SET_GPR_U32(ctx, 31, 0x1f1cd4);
    FUN_001f0468(rdram, ctx, runtime); return;
}


// Function: entry_1f1cd4
// Address: 0x1f1cd4 - 0x1f1cf4

void entry_1f1cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1cd4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f1cd8: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f1cdc: 0x14a20007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F1CFC; return;
    }
    // 0x1f1ce4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f1ce8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1cec: 0xc07c124
    SET_GPR_U32(ctx, 31, 0x1f1cf4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001f0490(rdram, ctx, runtime); return;
}


// Function: entry_1f1cf4
// Address: 0x1f1cf4 - 0x1f1d04

void entry_1f1cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1cf4) {
        switch (ctx->pc) {
            case 0x1f1cfc: ctx->pc = 0; goto label_1f1cfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1cf4: 0x2282b
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1f1cf8: 0x8e040260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
label_1f1cfc:
    // 0x1f1cfc: 0xc07c564
    SET_GPR_U32(ctx, 31, 0x1f1d04);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    ShowWm__FP2WM10WORLDLEVEL3WMS(rdram, ctx, runtime); return;
}


// Function: entry_1f1d04
// Address: 0x1f1d04 - 0x1f1d30

void entry_1f1d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1d04: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f1d08: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f1d0c: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1f1d10: 0xe600027c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 636), *(uint32_t*)&val); }
    // 0x1f1d14: 0xe6000280
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 640), *(uint32_t*)&val); }
    // 0x1f1d18: 0x8c4202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 740)));
    // 0x1f1d1c: 0x10400005
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1D34; return;
    }
    // 0x1f1d24: 0xc44c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1f1d28: 0xc06aa2c
    SET_GPR_U32(ctx, 31, 0x1f1d30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtAppear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f1d30
// Address: 0x1f1d30 - 0x1f1d5c

void entry_1f1d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1d30) {
        switch (ctx->pc) {
            case 0x1f1d34: ctx->pc = 0; goto label_1f1d34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1d30: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_1f1d34:
    // 0x1f1d34: 0x24050308
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 776));
    // 0x1f1d38: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1f1d3c: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1f1d40: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1f1d44: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1f1d48: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f1d4c: 0x54450004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F1D60; return;
    }
    // 0x1f1d54: 0xc06fb52
    SET_GPR_U32(ctx, 31, 0x1f1d5c);
    SfxhMusicUnknown1(rdram, ctx, runtime); return;
}


// Function: entry_1f1d5c
// Address: 0x1f1d5c - 0x1f1d6c

void entry_1f1d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1d5c) {
        switch (ctx->pc) {
            case 0x1f1d60: ctx->pc = 0; goto label_1f1d60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1d5c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1f1d60:
    // 0x1f1d60: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f1d64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f1d6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f1d6c
// Address: 0x1f1d6c - 0x1f1d74

void entry_1f1d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1d6c: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x1f1d74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f1d74
// Address: 0x1f1d74 - 0x1f1d80

void entry_1f1d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1d74: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f1d78: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x1f1d80);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1f1d80
// Address: 0x1f1d80 - 0x1f1d90

void entry_1f1d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1d80: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f1d84: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1f1d88: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x1f1d90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_1f1d90
// Address: 0x1f1d90 - 0x1f1da4

void entry_1f1d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1d90) {
        switch (ctx->pc) {
            case 0x1f1d98: ctx->pc = 0; goto label_1f1d98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1d90: 0x10000023
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1E20; return;
    }
label_1f1d98:
    // 0x1f1d98: 0x8c43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 60)));
    // 0x1f1d9c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f1da4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f1da4
// Address: 0x1f1da4 - 0x1f1dbc

void entry_1f1da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1da4: 0x8e040260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1f1da8: 0x8c820560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1376)));
    // 0x1f1dac: 0x5440001c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
        ctx->pc = 0x1F1E20; return;
    }
    // 0x1f1db4: 0xc07c584
    SET_GPR_U32(ctx, 31, 0x1f1dbc);
    HideWm__FP2WM(rdram, ctx, runtime); return;
}


// Function: entry_1f1dbc
// Address: 0x1f1dbc - 0x1f1dd8

void entry_1f1dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1dbc: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1f1dc0: 0x8c4202e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 744)));
    // 0x1f1dc4: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f1dd8(rdram, ctx, runtime); return;
    }
    // 0x1f1dcc: 0xc44c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1f1dd0: 0xc06aa30
    SET_GPR_U32(ctx, 31, 0x1f1dd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtDisappear__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f1dd8
// Address: 0x1f1dd8 - 0x1f1de0

void entry_1f1dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1dd8: 0xc05b846
    SET_GPR_U32(ctx, 31, 0x1f1de0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    RemoveGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f1de0
// Address: 0x1f1de0 - 0x1f1df0

void entry_1f1de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1de0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f1de4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f1de8: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x1f1df0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_1f1df0
// Address: 0x1f1df0 - 0x1f1e1c

void entry_1f1df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1df0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f1df4: 0x24050308
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 776));
    // 0x1f1df8: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1f1dfc: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1f1e00: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1f1e04: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1f1e08: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f1e0c: 0x54450004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
        ctx->pc = 0x1F1E20; return;
    }
    // 0x1f1e14: 0xc06fb5c
    SET_GPR_U32(ctx, 31, 0x1f1e1c);
    SfxhMusicUnknown2(rdram, ctx, runtime); return;
}


// Function: entry_1f1e1c
// Address: 0x1f1e1c - 0x1f1e38

void entry_1f1e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1e1c) {
        switch (ctx->pc) {
            case 0x1f1e20: ctx->pc = 0; goto label_1f1e20;
            case 0x1f1e24: ctx->pc = 0; goto label_1f1e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1e1c: 0xae11025c
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
label_1f1e20:
    // 0x1f1e20: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1f1e24:
    // 0x1f1e24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f1e28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f1e2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f1e34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f1e38; return;
}


// Function: DrawWmFan__FffffiG4RGBAT5i
// Address: 0x1f1e38 - 0x1f1edc

void entry_1f1edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1edc: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1f1ee0: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1f1ee4: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1f1ee8: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1f1eec: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1f1ef0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1ef4: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1f1ef8: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1f1efc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1f1f04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1f1f04
// Address: 0x1f1f04 - 0x1f1f28

void entry_1f1f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1f04: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1f1f08: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1f1f0c: 0x24020044
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1f1f10: 0x32a30001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 21), 1));
    // 0x1f1f14: 0x24060048
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 72));
    // 0x1f1f18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1f1c: 0x43300a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x1f1f20: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1f1f28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1f1f28
// Address: 0x1f1f28 - 0x1f1f44

void entry_1f1f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1f28: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1f1f2c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1f1f30: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f1f34: 0x24070041
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 65));
    // 0x1f1f38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1f3c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1f1f44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1f1f44
// Address: 0x1f1f44 - 0x1f1f54

void entry_1f1f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1f44: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1f48: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f1f4c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1f1f54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1f1f54
// Address: 0x1f1f54 - 0x1f1f88

void entry_1f1f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1f54: 0x461bb802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[27]);
    // 0x1f1f58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f1f5c: 0x4619c040
    ctx->f[1] = FPU_ADD_S(ctx->f[24], ctx->f[25]);
    // 0x1f1f60: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f1f64: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x1f1f68: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x1f1f6c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1f1f70: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1f1f74: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1f1f78: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1f1f7c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1f1f80: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1f1f88);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1f1f88
// Address: 0x1f1f88 - 0x1f1fa8

void entry_1f1f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1f88) {
        switch (ctx->pc) {
            case 0x1f1fa0: ctx->pc = 0; goto label_1f1fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1f88: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1f1f8c: 0x1a400031
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1F2054; return;
    }
    // 0x1f1f94: 0x4600cf06
    ctx->f[28] = FPU_MOV_S(ctx->f[25]);
    // 0x1f1f98: 0x32b00002
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 21), 2));
    // 0x1f1f9c: 0x4600d646
    ctx->f[25] = FPU_MOV_S(ctx->f[26]);
label_1f1fa0:
    // 0x1f1fa0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1f1fa8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1f1fa8
// Address: 0x1f1fa8 - 0x1f1fb8

void entry_1f1fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1fa8: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1f1fac: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f1fb0: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1f1fb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 20));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1f1fb8
// Address: 0x1f1fb8 - 0x1f1ff0

void entry_1f1fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f1fb8: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f1fbc: 0x32620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
    // 0x1f1fc0: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1f1fc4: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1f1fc8: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1f1fcc: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1f1fd0: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x1f1fd4: 0xe7a00010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1f1fd8: 0x10400007
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1FF8; return;
    }
    // 0x1f1fe0: 0x12000005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1FF8; return;
    }
    // 0x1f1fe8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1f1ff0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8832));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1f1ff0
// Address: 0x1f1ff0 - 0x1f2004

void entry_1f1ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f1ff0) {
        switch (ctx->pc) {
            case 0x1f1ff8: ctx->pc = 0; goto label_1f1ff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f1ff0: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2008; return;
    }
label_1f1ff8:
    // 0x1f1ff8: 0x8ec50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1f1ffc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1f2004);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8832));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1f2004
// Address: 0x1f2004 - 0x1f2048

void entry_1f2004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2004) {
        switch (ctx->pc) {
            case 0x1f2008: ctx->pc = 0; goto label_1f2008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2004: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
label_1f2008:
    // 0x1f2008: 0x26842280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8832));
    // 0x1f200c: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1f2010: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f2014: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1f2018: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f201c: 0x461c0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[28]);
    // 0x1f2020: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1f2024: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x1f2028: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x1f202c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1f2030: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1f2034: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1f2038: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1f203c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1f2040: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1f2048);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[29]);
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1f2048
// Address: 0x1f2048 - 0x1f20a8

void entry_1f2048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2048) {
        switch (ctx->pc) {
            case 0x1f2054: ctx->pc = 0; goto label_1f2054;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2048: 0x272102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 18)));
    // 0x1f204c: 0x1440ffd4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F1FA0; return;
    }
label_1f2054:
    // 0x1f2054: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f2058: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f205c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f2060: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f2064: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f2068: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f206c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f2070: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f2074: 0xc7bd00e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[29] = *(float*)&val; }
    // 0x1f2078: 0xc7bc00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[28] = *(float*)&val; }
    // 0x1f207c: 0xc7bb00d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[27] = *(float*)&val; }
    // 0x1f2080: 0xc7ba00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[26] = *(float*)&val; }
    // 0x1f2084: 0xc7b900c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[25] = *(float*)&val; }
    // 0x1f2088: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1f208c: 0xc7b700b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[23] = *(float*)&val; }
    // 0x1f2090: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x1f2094: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x1f2098: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1f209c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f20a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f20a8; return;
}


// Function: DrawWmc__FP3WMC
// Address: 0x1f20a8 - 0x1f2118

void entry_1f2118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2118: 0x8e2240a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16548)));
    // 0x1f211c: 0x10400050
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f2260(rdram, ctx, runtime); return;
    }
    // 0x1f2124: 0x8e630260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1f2128: 0xc674023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 572)); ctx->f[20] = *(float*)&val; }
    // 0x1f212c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f2130: 0xd8620540
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 1344)));
    // 0x1f2134: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f2138: 0x8c821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6544)));
    // 0x1f213c: 0x4614a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x1f2140: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f2144: 0x24470080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 128));
    // 0x1f2148: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f214c: 0xd8e40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 32)));
    // 0x1f2150: 0xd8430080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x1f2154: 0xd8e10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x1f2158: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f215c: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f2160: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2164: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f2168: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1f216c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2170: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1f2178);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1f2178
// Address: 0x1f2178 - 0x1f21fc

void entry_1f2178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2178: 0xc7a20010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[2] = *(float*)&val; }
    // 0x1f217c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1f2180: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1f2184: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1f2188: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x1f218c: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1f2190: 0x3c01c376
    SET_GPR_U32(ctx, 1, ((uint32_t)50038 << 16));
    // 0x1f2194: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1f2198: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1f219c: 0x3c014311
    SET_GPR_U32(ctx, 1, ((uint32_t)17169 << 16));
    // 0x1f21a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f21a4: 0x46051082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[5]);
    // 0x1f21a8: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1f21ac: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x1f21b0: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1f21b4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1f21b8: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1f21bc: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1f21c0: 0x46051080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[5]);
    // 0x1f21c4: 0xa3a00020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21c8: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1f21cc: 0xa3a00021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21d0: 0x460000e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1f21d4: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1f21d8: 0xa3a00022
    WRITE8(ADD32(GPR_U32(ctx, 29), 34), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21dc: 0xe7a20010
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1f21e0: 0xe7a10014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x1f21e4: 0xa3a20023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f21e8: 0xa3a00030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21ec: 0xa3a00031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21f0: 0xa3a00032
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f21f4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1f21fc);
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 0));
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1f21fc
// Address: 0x1f21fc - 0x1f2224

void entry_1f21fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f21fc: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1f2200: 0x460003c6
    ctx->f[15] = FPU_MOV_S(ctx->f[0]);
    // 0x1f2204: 0xc7ad0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    // 0x1f2208: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1f220c: 0x3c014220
    SET_GPR_U32(ctx, 1, ((uint32_t)16928 << 16));
    // 0x1f2210: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f2214: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1f2218: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f221c: 0xc07c78e
    SET_GPR_U32(ctx, 31, 0x1f2224);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    DrawWmFan__FffffiG4RGBAT5i(rdram, ctx, runtime); return;
}


// Function: entry_1f2224
// Address: 0x1f2224 - 0x1f2238

void entry_1f2224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2224: 0xc6000010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f2228: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1f222c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f2230: 0xc081500
    SET_GPR_U32(ctx, 31, 0x1f2238);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_1f2238
// Address: 0x1f2238 - 0x1f2260

void entry_1f2238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2238: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1f223c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1f2240: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f2244: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1f2248: 0x8e2440a4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 16548)));
    // 0x1f224c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1f2250: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1f2254: 0xc7ad0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    // 0x1f2258: 0xc060042
    SET_GPR_U32(ctx, 31, 0x1f2260);
    ctx->f[14] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    DrawKeyholeMask__FP7KEYHOLEffff(rdram, ctx, runtime); return;
}


// Function: entry_1f2260
// Address: 0x1f2260 - 0x1f23a4

void entry_1f2260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2260) {
        switch (ctx->pc) {
            case 0x1f2290: ctx->pc = 0; goto label_1f2290;
            case 0x1f2330: ctx->pc = 0; goto label_1f2330;
            case 0x1f2394: ctx->pc = 0; goto label_1f2394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2260: 0x27a20050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1f2264: 0x27a30070
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1f2268: 0xafa200b0
    WRITE32(ADD32(GPR_U32(ctx, 29), 176), GPR_U32(ctx, 2));
    // 0x1f226c: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f2270: 0xafa300b4
    WRITE32(ADD32(GPR_U32(ctx, 29), 180), GPR_U32(ctx, 3));
    // 0x1f2274: 0x241e00ff
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1f2278: 0xafa000b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 0));
    // 0x1f227c: 0x241700e8
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 232));
    // 0x1f2280: 0xafa000bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 0));
    // 0x1f2284: 0x2415004b
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 75));
    // 0x1f2288: 0x241600b6
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 182));
    // 0x1f228c: 0x0
    // NOP
label_1f2290:
    // 0x1f2290: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1f2294: 0x8e640260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1f2298: 0x2821018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f229c: 0x244202f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 760));
    // 0x1f22a0: 0x828821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1f22a4: 0x8e23001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1f22a8: 0x106000d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F260C; return;
    }
    // 0x1f22b0: 0x8e220020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1f22b4: 0x1040001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967199));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f2330;
    }
    // 0x1f22bc: 0xa3be0051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 30));
    // 0x1f22c0: 0xa3a40050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f22c4: 0xa3b70052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 23));
    // 0x1f22c8: 0x2404005c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 92));
    // 0x1f22cc: 0xa3b50053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 21));
    // 0x1f22d0: 0x8ba50053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f22d4: 0x9ba50050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f22d8: 0xaba50003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f22dc: 0xbba50000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f22e0: 0xa3a40050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f22e4: 0xa3be0051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 30));
    // 0x1f22e8: 0x24040019
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 25));
    // 0x1f22ec: 0xa3b60052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 22));
    // 0x1f22f0: 0xa3a00053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f22f4: 0x8ba50053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f22f8: 0x9ba50050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f22fc: 0xaba50013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2300: 0xbba50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2304: 0x24050064
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    // 0x1f2308: 0xa3a40050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f230c: 0xa3be0051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 30));
    // 0x1f2310: 0xa3a50052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 5));
    // 0x1f2314: 0xa3a00053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f2318: 0x8ba60053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f231c: 0x9ba60050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f2320: 0xaba60043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2324: 0xbba60040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2328: 0x1000001a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2394;
    }
label_1f2330:
    // 0x1f2330: 0xa3b70050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 23));
    // 0x1f2334: 0xa3b70051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 23));
    // 0x1f2338: 0xa3b70052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 23));
    // 0x1f233c: 0xa3b50053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 21));
    // 0x1f2340: 0x8ba50053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f2344: 0x9ba50050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f2348: 0xaba50003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f234c: 0xbba50000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2350: 0xa3b60050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 22));
    // 0x1f2354: 0xa3b60051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 22));
    // 0x1f2358: 0xa3b60052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 22));
    // 0x1f235c: 0xa3a00053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f2360: 0x8ba40053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f2364: 0x9ba40050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1f2368: 0xaba40013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f236c: 0xbba40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2370: 0xa3b50050
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 21));
    // 0x1f2374: 0xa3b50051
    WRITE8(ADD32(GPR_U32(ctx, 29), 81), (uint8_t)GPR_U32(ctx, 21));
    // 0x1f2378: 0xa3b50052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 21));
    // 0x1f237c: 0xa3a00053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f2380: 0x8ba30053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f2384: 0x9ba30050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1f2388: 0xaba30043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f238c: 0xbba30040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2390: 0x8e640260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 608)));
label_1f2394:
    // 0x1f2394: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f2398: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f239c: 0xc07c5e8
    SET_GPR_U32(ctx, 31, 0x1f23a4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f23a4
// Address: 0x1f23a4 - 0x1f23d0

void entry_1f23a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f23a4: 0x2a920009
    SET_GPR_U32(ctx, 18, SLT32(GPR_S32(ctx, 20), 9));
    // 0x1f23a8: 0xc6210024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 36)); ctx->f[1] = *(float*)&val; }
    // 0x1f23ac: 0xc660023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 572)); ctx->f[0] = *(float*)&val; }
    // 0x1f23b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f23b4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f23b8: 0x46000d02
    ctx->f[20] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1f23bc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1f23c0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1f23c4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1f23c8: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1f23d0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1f23d0
// Address: 0x1f23d0 - 0x1f23f4

void entry_1f23d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f23d0: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2468; return;
    }
    // 0x1f23d8: 0x12400023
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2468; return;
    }
    // 0x1f23e0: 0x8e620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1f23e4: 0x8c5002f4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 756)));
    // 0x1f23e8: 0x102200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 8));
    // 0x1f23ec: 0xc058076
    SET_GPR_U32(ctx, 31, 0x1f23f4);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 20)));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1f23f4
// Address: 0x1f23f4 - 0x1f2444

void entry_1f23f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f23f4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1f23f8: 0x1040001a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2464; return;
    }
    // 0x1f2400: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f2404: 0x600013
    ctx->lo = GPR_U32(ctx, 3);
    // 0x1f2408: 0x2403044c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1f240c: 0x72031000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f2410: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1f2414: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f2418: 0x8c640010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1f241c: 0x30840002
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 2));
    // 0x1f2420: 0x14800011
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2468; return;
    }
    // 0x1f2428: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1f242c: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x1f2430: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1f2434: 0x24a51858
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6232));
    // 0x1f2438: 0xc4a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f243c: 0xc081500
    SET_GPR_U32(ctx, 31, 0x1f2444);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_1f2444
// Address: 0x1f2444 - 0x1f24b0

void entry_1f2444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2444) {
        switch (ctx->pc) {
            case 0x1f2464: ctx->pc = 0; goto label_1f2464;
            case 0x1f2468: ctx->pc = 0; goto label_1f2468;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2444: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1f2448: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1f244c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f2450: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1f2454: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1f2458: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1f245c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1f2460: 0x46020500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
label_1f2464:
    // 0x1f2464: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1f2468:
    // 0x1f2468: 0x8ba60003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f246c: 0x9ba60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f2470: 0xaba60053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2474: 0xbba60050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2478: 0xc44e6648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 26184)); ctx->f[14] = *(float*)&val; }
    // 0x1f247c: 0x2404000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1f2480: 0x8ba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f2484: 0x9ba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f2488: 0xaba60073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f248c: 0xbba60070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2490: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f2494: 0x460ea382
    ctx->f[14] = FPU_MUL_S(ctx->f[20], ctx->f[14]);
    // 0x1f2498: 0x8fa600b4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1f249c: 0x8fa500b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f24a0: 0xc62f002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[15] = *(float*)&val; }
    // 0x1f24a4: 0xc7ac0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[12] = *(float*)&val; }
    // 0x1f24a8: 0xc07c78e
    SET_GPR_U32(ctx, 31, 0x1f24b0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[13] = *(float*)&val; }
    DrawWmFan__FffffiG4RGBAT5i(rdram, ctx, runtime); return;
}


// Function: entry_1f24b0
// Address: 0x1f24b0 - 0x1f2500

void entry_1f24b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f24b0: 0x8ba60003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f24b4: 0x9ba60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f24b8: 0xaba60073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f24bc: 0xbba60070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f24c0: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f24c4: 0x8ba50013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f24c8: 0x9ba50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f24cc: 0xaba50053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f24d0: 0xbba50050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f24d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f24d8: 0xc44e6650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 26192)); ctx->f[14] = *(float*)&val; }
    // 0x1f24dc: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f24e0: 0xc62f002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[15] = *(float*)&val; }
    // 0x1f24e4: 0x460ea382
    ctx->f[14] = FPU_MUL_S(ctx->f[20], ctx->f[14]);
    // 0x1f24e8: 0x8fa500b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1f24ec: 0x46007bc7
    ctx->f[15] = FPU_NEG_S(ctx->f[15]);
    // 0x1f24f0: 0x8fa600b0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f24f4: 0xc7ac0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[12] = *(float*)&val; }
    // 0x1f24f8: 0xc07c78e
    SET_GPR_U32(ctx, 31, 0x1f2500);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[13] = *(float*)&val; }
    DrawWmFan__FffffiG4RGBAT5i(rdram, ctx, runtime); return;
}


// Function: entry_1f2500
// Address: 0x1f2500 - 0x1f251c

void entry_1f2500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2500: 0x12400042
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F260C; return;
    }
    // 0x1f2508: 0x8e620260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1f250c: 0x8c5002f4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 756)));
    // 0x1f2510: 0x102200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 8));
    // 0x1f2514: 0xc058076
    SET_GPR_U32(ctx, 31, 0x1f251c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 20)));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1f251c
// Address: 0x1f251c - 0x1f2550

void entry_1f251c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f251c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1f2520: 0x10400039
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f2608(rdram, ctx, runtime); return;
    }
    // 0x1f2528: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1f252c: 0xc6340024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 36)); ctx->f[20] = *(float*)&val; }
    // 0x1f2530: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x1f2534: 0x2402044c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1f2538: 0x72021800
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f253c: 0x8c8223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1f2540: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f2544: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f2548: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1f2550);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1f2550
// Address: 0x1f2550 - 0x1f256c

void entry_1f2550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2550: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f2554: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f2558: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f255c: 0xc44c663c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 26172)); ctx->f[12] = *(float*)&val; }
    // 0x1f2560: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x1f2564: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1f256c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1f256c
// Address: 0x1f256c - 0x1f2594

void entry_1f256c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f256c: 0xc7ac0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[12] = *(float*)&val; }
    // 0x1f2570: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f2574: 0xc7ad0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[13] = *(float*)&val; }
    // 0x1f2578: 0x8a65020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 523); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f257c: 0x9a650208
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 520); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f2580: 0xaba50073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2584: 0xbba50070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f2588: 0xa3be0073
    WRITE8(ADD32(GPR_U32(ctx, 29), 115), (uint8_t)GPR_U32(ctx, 30));
    // 0x1f258c: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1f2594);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1f2594
// Address: 0x1f2594 - 0x1f25a4

void entry_1f2594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2594: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f2598: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f259c: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1f25a4);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1f25a4
// Address: 0x1f25a4 - 0x1f25b4

void entry_1f25a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f25a4: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f25a8: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1f25ac: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1f25b4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 160), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1f25b4
// Address: 0x1f25b4 - 0x1f25c0

void entry_1f25b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f25b4: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f25b8: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1f25c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1f25c0
// Address: 0x1f25c0 - 0x1f25cc

void entry_1f25c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f25c0: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f25c4: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1f25cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1f25cc
// Address: 0x1f25cc - 0x1f2600

void entry_1f25cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f25cc) {
        switch (ctx->pc) {
            case 0x1f25e0: ctx->pc = 0; goto label_1f25e0;
            case 0x1f25e8: ctx->pc = 0; goto label_1f25e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f25cc: 0x32310002
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), 2));
    // 0x1f25d0: 0x12200003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1f25e0;
    }
    // 0x1f25d8: 0x10000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294961200));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f25e8;
    }
label_1f25e0:
    // 0x1f25e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f25e4: 0x2445e838
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294961208));
label_1f25e8:
    // 0x1f25e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f25ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f25f0: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1f25f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f25f8: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x1f2600);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8832));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1f2600
// Address: 0x1f2600 - 0x1f2608

void entry_1f2600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2600: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1f2608);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1f2608
// Address: 0x1f2608 - 0x1f263c

void entry_1f2608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2608) {
        switch (ctx->pc) {
            case 0x1f260c: ctx->pc = 0; goto label_1f260c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2608: 0x8fa300b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 184)));
label_1f260c:
    // 0x1f260c: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1f2610: 0x8fa400bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x1f2614: 0x2a82000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 11));
    // 0x1f2618: 0x24630078
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 120));
    // 0x1f261c: 0x24840078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 120));
    // 0x1f2620: 0xafa300b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 3));
    // 0x1f2624: 0x1440ff1a
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2290; return;
    }
    // 0x1f262c: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1f2630: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1f2634: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1f263c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 6544)));
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1f263c
// Address: 0x1f263c - 0x1f2688

void entry_1f263c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f263c) {
        switch (ctx->pc) {
            case 0x1f2648: ctx->pc = 0; goto label_1f2648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f263c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1f2640: 0x8cc21990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6544)));
    // 0x1f2644: 0xe45701c8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
label_1f2648:
    // 0x1f2648: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1f264c: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1f2650: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1f2654: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1f2658: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1f265c: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1f2660: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1f2664: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1f2668: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f266c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f2670: 0xc7b70178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[23] = *(float*)&val; }
    // 0x1f2674: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x1f2678: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x1f267c: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x1f2680: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: wm__static_initialization_and_destruction_0
// Address: 0x1f2688 - 0x1f26b8

void entry_1f26b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f26b8) {
        switch (ctx->pc) {
            case 0x1f2714: ctx->pc = 0; goto label_1f2714;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f26b8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f26bc: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x1f26c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f26c4: 0xc4606648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 26184)); ctx->f[0] = *(float*)&val; }
    // 0x1f26c8: 0x3c02ff7d
    SET_GPR_U32(ctx, 2, ((uint32_t)65405 << 16));
    // 0x1f26cc: 0x34424b00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 19200));
    // 0x1f26d0: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1f26d4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1f26d8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1f26dc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1f26e0: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1f26e4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1f26e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f26ec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f26f0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f26f4: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x1f26f8: 0x2404003d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 61));
    // 0x1f26fc: 0xe4606650
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 26192), *(uint32_t*)&val); }
    // 0x1f2700: 0xa2040004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f2704: 0xe6020008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1f2708: 0xe601000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1f270c: 0xe6030014
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1f2710: 0xe6030010
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
label_1f2714:
    // 0x1f2714: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f2718: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f271c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f2724: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f2728; return;
}


// Function: junk_001F2728
// Address: 0x1f2728 - 0x1f274c

void entry_1f274c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f274c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f2750: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitWr__FP2WR
// Address: 0x1f2758 - 0x1f276c

void entry_1f276c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f276c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1f2770: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f2774: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f2778: 0xae0206d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1744), GPR_U32(ctx, 2));
    // 0x1f277c: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1f2780: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
    // 0x1f2784: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f2788: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f278c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f2794: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f2798; return;
}


// Function: ApplyWrGlob__FP2WRP3ALOP4GLOB
// Address: 0x1f2798 - 0x1f2840

void entry_1f28a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f28a8) {
        switch (ctx->pc) {
            case 0x1f28bc: ctx->pc = 0; goto label_1f28bc;
            case 0x1f2960: ctx->pc = 0; goto label_1f2960;
            case 0x1f2974: ctx->pc = 0; goto label_1f2974;
            case 0x1f2984: ctx->pc = 0; goto label_1f2984;
            case 0x1f2994: ctx->pc = 0; goto label_1f2994;
            case 0x1f29a4: ctx->pc = 0; goto label_1f29a4;
            case 0x1f29d0: ctx->pc = 0; goto label_1f29d0;
            case 0x1f29d4: ctx->pc = 0; goto label_1f29d4;
            case 0x1f29dc: ctx->pc = 0; goto label_1f29dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f28a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f28ac: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1f28b0: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f28b4: 0x10000069
    WRITE128(ADD32(GPR_U32(ctx, 29), 5392), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2A5C; return;
    }
label_1f28bc:
    // 0x1f28bc: 0x7a830040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x1f28c0: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f28c4: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1f28c8: 0x7a820050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 80)));
    // 0x1f28cc: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1f28d0: 0x7a830060
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x1f28d4: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1f28d8: 0x7a820070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 112)));
    // 0x1f28dc: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1f28e0: 0xc6810028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 40)); ctx->f[1] = *(float*)&val; }
    // 0x1f28e4: 0xc6800030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1f28e8: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1f28ec: 0xe7a00050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1f28f0: 0xc6810028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 40)); ctx->f[1] = *(float*)&val; }
    // 0x1f28f4: 0xc6800030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1f28f8: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1f28fc: 0xe7a00054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x1f2900: 0xc682002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 44)); ctx->f[2] = *(float*)&val; }
    // 0x1f2904: 0xc6810028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 40)); ctx->f[1] = *(float*)&val; }
    // 0x1f2908: 0xc6830030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 48)); ctx->f[3] = *(float*)&val; }
    // 0x1f290c: 0xc6800024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1f2910: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1f2914: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1f2918: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1f291c: 0xe7a10044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x1f2920: 0xc6820024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 36)); ctx->f[2] = *(float*)&val; }
    // 0x1f2924: 0xc6800028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1f2928: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1f292c: 0xafa00048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
    // 0x1f2930: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1f2934: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x1f2938: 0x8e830020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1f293c: 0x50640011
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 36)); ctx->f[0] = *(float*)&val; }
        goto label_1f2984;
    }
    // 0x1f2944: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x1f2948: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f2960;
    }
    // 0x1f2950: 0x50620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 36)); ctx->f[0] = *(float*)&val; }
        goto label_1f2974;
    }
    // 0x1f2958: 0x1000001d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f29d0;
    }
label_1f2960:
    // 0x1f2960: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1f2964: 0x1062000b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f2994;
    }
    // 0x1f296c: 0x10000019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f29d4;
    }
label_1f2974:
    // 0x1f2974: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f2978: 0xc681002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1f297c: 0x10000009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f29a4;
    }
label_1f2984:
    // 0x1f2984: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f2988: 0xc681002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1f298c: 0x10000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937872));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f29a4;
    }
label_1f2994:
    // 0x1f2994: 0xc6800024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1f2998: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1f299c: 0xc681002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1f29a0: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
label_1f29a4:
    // 0x1f29a4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1f29a8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1f29ac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1f29b0: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f29b4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1f29b8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f29bc: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f29c0: 0x4be110d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f29c4: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f29c8: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 5392), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f29dc;
    }
label_1f29d0:
    // 0x1f29d0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
label_1f29d4:
    // 0x1f29d4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f29d8: 0x7fa21510
    WRITE128(ADD32(GPR_U32(ctx, 29), 5392), GPR_VEC(ctx, 2));
label_1f29dc:
    // 0x1f29dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f29e0: 0xc0626bc
    SET_GPR_U32(ctx, 31, 0x1f29e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    FInvertMatrix4__FP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1f29e8
// Address: 0x1f29e8 - 0x1f2a3c

void entry_1f29e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f29e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f29ec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f29f0: 0x8fa21500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
    // 0x1f29f4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1f29f8: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1f29fc: 0xdba61510
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 5392)));
    // 0x1f2a00: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f2a04: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f2a08: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f2a0c: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f2a10: 0x8c460068
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 104)));
    // 0x1f2a14: 0x4bc629bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1f2a18: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1f2a1c: 0x4bc610be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x1f2a20: 0x4bc40988
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2a24: 0xfba61510
    WRITE128(ADD32(GPR_U32(ctx, 29), 5392), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1f2a28: 0x10c0000c
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2A5C; return;
    }
    // 0x1f2a30: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1f2a34: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1f2a3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 64));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1f2a3c
// Address: 0x1f2a3c - 0x1f2adc

void entry_1f2a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2a3c) {
        switch (ctx->pc) {
            case 0x1f2a5c: ctx->pc = 0; goto label_1f2a5c;
            case 0x1f2a70: ctx->pc = 0; goto label_1f2a70;
            case 0x1f2ac4: ctx->pc = 0; goto label_1f2ac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2a3c: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f2a40: 0x7ba300c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f2a44: 0x7ba400d0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f2a48: 0x7ba500e0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1f2a4c: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1f2a50: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x1f2a54: 0x7fa40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 4));
    // 0x1f2a58: 0x7fa50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 5));
label_1f2a5c:
    // 0x1f2a5c: 0x8fa31500
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
    // 0x1f2a60: 0x8c620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    // 0x1f2a64: 0x1840010f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F2EA4; return;
    }
    // 0x1f2a6c: 0x24020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
label_1f2a70:
    // 0x1f2a70: 0x8fa41500
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
    // 0x1f2a74: 0x2021018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f2a78: 0x8fa514fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 5372)));
    // 0x1f2a7c: 0x8c83005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 92)));
    // 0x1f2a80: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f2a84: 0xafb01524
    WRITE32(ADD32(GPR_U32(ctx, 29), 5412), GPR_U32(ctx, 16));
    // 0x1f2a88: 0x24b10110
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 5), 272));
    // 0x1f2a8c: 0x27a700f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1f2a90: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f2a94: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1f2a98: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1f2a9c: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1f2aa0: 0xafa21520
    WRITE32(ADD32(GPR_U32(ctx, 29), 5408), GPR_U32(ctx, 2));
    // 0x1f2aa4: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f2aa8: 0x94450000
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f2aac: 0x94460002
    SET_GPR_U32(ctx, 6, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 2)));
    // 0x1f2ab0: 0x94430010
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1f2ab4: 0xc53023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x1f2ab8: 0xc3001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 6) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,6) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x1f2abc: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1f2ac4;
    }
label_1f2ac4:
    // 0x1f2ac4: 0x8fa21520
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5408)));
    // 0x1f2ac8: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f2acc: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x1f2ad0: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1f2ad4: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1f2adc);
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1f2adc
// Address: 0x1f2adc - 0x1f2c8c

void entry_1f2adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2adc) {
        switch (ctx->pc) {
            case 0x1f2af8: ctx->pc = 0; goto label_1f2af8;
            case 0x1f2b68: ctx->pc = 0; goto label_1f2b68;
            case 0x1f2c20: ctx->pc = 0; goto label_1f2c20;
            case 0x1f2c24: ctx->pc = 0; goto label_1f2c24;
            case 0x1f2c58: ctx->pc = 0; goto label_1f2c58;
            case 0x1f2c68: ctx->pc = 0; goto label_1f2c68;
            case 0x1f2c6c: ctx->pc = 0; goto label_1f2c6c;
            case 0x1f2c7c: ctx->pc = 0; goto label_1f2c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2adc: 0x8fa314fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5372)));
    // 0x1f2ae0: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1f2ae4: 0x27b210f0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 4336));
    // 0x1f2ae8: 0x2b6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    // 0x1f2aec: 0x10400063
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f2c7c;
    }
    // 0x1f2af4: 0x0
    // NOP
label_1f2af8:
    // 0x1f2af8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f2afc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f2b00: 0xdaa60000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1f2b04: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1f2b08: 0x48a42800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1f2b0c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f2b10: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f2b14: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f2b18: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f2b1c: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1f2b20: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1f2b24: 0x4bc610be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x1f2b28: 0x4bc508c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2b2c: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1f2b30: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1f2b34: 0x8e820020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1f2b38: 0x24440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1f2b3c: 0x2c830008
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 8));
    // 0x1f2b40: 0x10600009
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1f2b68;
    }
    // 0x1f2b48: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1f2b4c: 0x2442e840
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961216));
    // 0x1f2b50: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1f2b54: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f2b58: 0x600008
    ctx->pc = GPR_U32(ctx, 3); return;
    // 0x1f2b60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f2b64: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1f2b68:
    // 0x1f2b68: 0x10000040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c6c;
    }
    // 0x1f2b70: 0xafa00068
    WRITE32(ADD32(GPR_U32(ctx, 29), 104), GPR_U32(ctx, 0));
    // 0x1f2b74: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f2b78: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2b7c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f2b80: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2b84: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2b88: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2b8c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f2b90: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1f2b94: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f2b98: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1f2b9c: 0x10000021
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c24;
    }
    // 0x1f2ba4: 0xafa00064
    WRITE32(ADD32(GPR_U32(ctx, 29), 100), GPR_U32(ctx, 0));
    // 0x1f2ba8: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f2bac: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bb0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bb4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bb8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2bbc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bc0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f2bc4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1f2bc8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f2bcc: 0x44841800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 4);
    // 0x1f2bd0: 0x10000014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c24;
    }
    // 0x1f2bd8: 0xafa00060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 0));
    // 0x1f2bdc: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f2be0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2be4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f2be8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bec: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2bf0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2bf4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f2bf8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1f2bfc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f2c00: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1f2c04: 0x10000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c24;
    }
    // 0x1f2c0c: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[3] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c20;
    }
    // 0x1f2c14: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[3] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c20;
    }
    // 0x1f2c1c: 0xc7a30068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[3] = *(float*)&val; }
label_1f2c20:
    // 0x1f2c20: 0xc7a00048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
label_1f2c24:
    // 0x1f2c24: 0xc7a10044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1f2c28: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1f2c2c: 0xc7a20040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[2] = *(float*)&val; }
    // 0x1f2c30: 0xc7a40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[4] = *(float*)&val; }
    // 0x1f2c34: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1f2c38: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1f2c3c: 0x46011000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1f2c40: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f2c44: 0x0
    // NOP
    // 0x1f2c48: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1f2c58;
    }
    // 0x1f2c50: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2c68;
    }
label_1f2c58:
    // 0x1f2c58: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f2c5c: 0x0
    // NOP
    // 0x1f2c60: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[5]);
        goto label_1f2c68;
    }
label_1f2c68:
    // 0x1f2c68: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_1f2c6c:
    // 0x1f2c6c: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    // 0x1f2c70: 0x2b6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    // 0x1f2c74: 0x1440ffa0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f2af8;
    }
label_1f2c7c:
    // 0x1f2c7c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1f2c80: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f2c84: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1f2c8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1f2c8c
// Address: 0x1f2c8c - 0x1f2ca4

void entry_1f2c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f2c8c: 0x8fa31500
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
    // 0x1f2c90: 0x8c660068
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 104)));
    // 0x1f2c94: 0x10c0000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2CC4; return;
    }
    // 0x1f2c9c: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1f2ca4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1f2ca4
// Address: 0x1f2ca4 - 0x1f2de4

void entry_1f2ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2ca4) {
        switch (ctx->pc) {
            case 0x1f2cc4: ctx->pc = 0; goto label_1f2cc4;
            case 0x1f2d08: ctx->pc = 0; goto label_1f2d08;
            case 0x1f2d60: ctx->pc = 0; goto label_1f2d60;
            case 0x1f2da4: ctx->pc = 0; goto label_1f2da4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2ca4: 0x7ba200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f2ca8: 0x7ba300b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f2cac: 0x7ba400c0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f2cb0: 0x7ba500d0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f2cb4: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x1f2cb8: 0x7fa30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 3));
    // 0x1f2cbc: 0x7fa40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 4));
    // 0x1f2cc0: 0x7fa50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 5));
label_1f2cc4:
    // 0x1f2cc4: 0x8fa514fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 5372)));
    // 0x1f2cc8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f2ccc: 0xdba21510
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 5392)));
    // 0x1f2cd0: 0xda240020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1f2cd4: 0xd8a30110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 272)));
    // 0x1f2cd8: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1f2cdc: 0x8fa314f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5368)));
    // 0x1f2ce0: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f2ce4: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f2ce8: 0x4bc220ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2cec: 0xd8a20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
    // 0x1f2cf0: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f2cf4: 0x4be311e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f2cf8: 0x58400065
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
        ctx->pc = 0x1F2E90; return;
    }
    // 0x1f2d00: 0x240300d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 208));
    // 0x1f2d04: 0x0
    // NOP
label_1f2d08:
    // 0x1f2d08: 0x8fa514f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 5368)));
    // 0x1f2d0c: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f2d10: 0x27b500f0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1f2d14: 0x24970001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f2d18: 0x27b210f0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 4336));
    // 0x1f2d1c: 0x2b6202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    // 0x1f2d20: 0x24630050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 80));
    // 0x1f2d24: 0xa39821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1f2d28: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1f2d2c: 0x8fa31520
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5408)));
    // 0x1f2d30: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f2d34: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f2d38: 0x1080004e
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2E74; return;
    }
    // 0x1f2d40: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f2d44: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1f2d48: 0x241e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f2d4c: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1f2d50: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1f2d54: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1f2d58: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x1f2d5c: 0x48a43000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
label_1f2d60:
    // 0x1f2d60: 0xdaa50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1f2d64: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f2d68: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f2d6c: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f2d70: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f2d74: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1f2d78: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1f2d7c: 0x4bc510be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x1f2d80: 0x4bc60848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2d84: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1f2d88: 0x4be20b3c
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f2d8c: 0x10400005
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f2da4;
    }
    // 0x1f2d94: 0x105e0023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 30)) {
        ctx->pc = 0x1F2E24; return;
    }
    // 0x1f2d9c: 0x10000031
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2E64; return;
    }
label_1f2da4:
    // 0x1f2da4: 0xc6600064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 100)); ctx->f[0] = *(float*)&val; }
    // 0x1f2da8: 0x27a414f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 5360));
    // 0x1f2dac: 0xda610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1f2db0: 0x27a514f4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 5364));
    // 0x1f2db4: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1f2db8: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f2dbc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f2dc0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2dc4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f2dc8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f2dcc: 0x8e700060
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 96)));
    // 0x1f2dd0: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1f2dd4: 0xfba61530
    WRITE128(ADD32(GPR_U32(ctx, 29), 5424), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1f2dd8: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1f2ddc: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1f2de4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 5440), _mm_castps_si128(ctx->vu0_vf[7]));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1f2de4
// Address: 0x1f2de4 - 0x1f2ef0

void entry_1f2de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f2de4) {
        switch (ctx->pc) {
            case 0x1f2e24: ctx->pc = 0; goto label_1f2e24;
            case 0x1f2e60: ctx->pc = 0; goto label_1f2e60;
            case 0x1f2e64: ctx->pc = 0; goto label_1f2e64;
            case 0x1f2e74: ctx->pc = 0; goto label_1f2e74;
            case 0x1f2e90: ctx->pc = 0; goto label_1f2e90;
            case 0x1f2ea4: ctx->pc = 0; goto label_1f2ea4;
            case 0x1f2eb4: ctx->pc = 0; goto label_1f2eb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f2de4: 0xc6410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f2de8: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f2dec: 0xc7a014f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 5364)); ctx->f[0] = *(float*)&val; }
    // 0x1f2df0: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f2df4: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f2df8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1f2dfc: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f2e00: 0x2308021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1f2e04: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1f2e08: 0xc7a114f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 5360)); ctx->f[1] = *(float*)&val; }
    // 0x1f2e0c: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1f2e10: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1f2e14: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1f2e18: 0xdba61530
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 5424)));
    // 0x1f2e1c: 0x10000010
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 5440)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f2e60;
    }
label_1f2e24:
    // 0x1f2e24: 0x4be7086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f2e28: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f2e2c: 0xc7a000a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    // 0x1f2e30: 0xc6410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f2e34: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1f2e38: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1f2e3c: 0xc7a000a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[0] = *(float*)&val; }
    // 0x1f2e40: 0xc6420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1f2e44: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1f2e48: 0xe6220004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x1f2e4c: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1f2e50: 0xc7a100a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[1] = *(float*)&val; }
    // 0x1f2e54: 0xe634000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    // 0x1f2e58: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1f2e5c: 0xe6200008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
label_1f2e60:
    // 0x1f2e60: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
label_1f2e64:
    // 0x1f2e64: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1f2e68: 0x2b6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    // 0x1f2e6c: 0x1440ffbc
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2D60; return;
    }
label_1f2e74:
    // 0x1f2e74: 0x8fa314f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5368)));
    // 0x1f2e78: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1f2e7c: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f2e80: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1f2e84: 0x1440ffa0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 208));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2D08; return;
    }
    // 0x1f2e8c: 0x8fa41500
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 5376)));
label_1f2e90:
    // 0x1f2e90: 0x8fb01524
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 5412)));
    // 0x1f2e94: 0x8c820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 88)));
    // 0x1f2e98: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f2e9c: 0x1440fef4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2A70; return;
    }
label_1f2ea4:
    // 0x1f2ea4: 0x8e940084
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 132)));
    // 0x1f2ea8: 0x5680fe77
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x1F2888; return;
    }
    // 0x1f2eb0: 0x8fa514f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 5368)));
label_1f2eb4:
    // 0x1f2eb4: 0x7bbf15e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 5600)));
    // 0x1f2eb8: 0x7bbe15d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 5584)));
    // 0x1f2ebc: 0x7bb715c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 5568)));
    // 0x1f2ec0: 0x7bb615b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 5552)));
    // 0x1f2ec4: 0x7bb515a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 5536)));
    // 0x1f2ec8: 0x7bb41590
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 5520)));
    // 0x1f2ecc: 0x7bb31580
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 5504)));
    // 0x1f2ed0: 0x7bb21570
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 5488)));
    // 0x1f2ed4: 0x7bb11560
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 5472)));
    // 0x1f2ed8: 0x7bb01550
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 5456)));
    // 0x1f2edc: 0xc7b515f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 5624)); ctx->f[21] = *(float*)&val; }
    // 0x1f2ee0: 0xc7b415f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 5616)); ctx->f[20] = *(float*)&val; }
    // 0x1f2ee4: 0xaca008e4
    WRITE32(ADD32(GPR_U32(ctx, 5), 2276), GPR_U32(ctx, 0));
    // 0x1f2ee8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 5632));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2
// Address: 0x1f2ef0 - 0x1f301c

void entry_1f301c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f301c) {
        switch (ctx->pc) {
            case 0x1f3078: ctx->pc = 0; goto label_1f3078;
            case 0x1f307c: ctx->pc = 0; goto label_1f307c;
            case 0x1f308c: ctx->pc = 0; goto label_1f308c;
            case 0x1f3094: ctx->pc = 0; goto label_1f3094;
            case 0x1f309c: ctx->pc = 0; goto label_1f309c;
            case 0x1f30b8: ctx->pc = 0; goto label_1f30b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f301c: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1f3020: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f3024: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f3028: 0xda040040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1f302c: 0xda030020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1f3030: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f3034: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f3038: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f303c: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3040: 0x4be502bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1f3044: 0x4be218bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f3048: 0x4be12148
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f304c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f3050: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f3054: 0x12400008
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1f3078;
    }
    // 0x1f305c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1f3060: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f3064: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f3068: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f306c: 0x4be602bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1f3070: 0x4be118bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1f3074: 0x4be22188
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
label_1f3078:
    // 0x1f3078: 0x8e620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
label_1f307c:
    // 0x1f307c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f3080: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1f3084: 0x1440ffb8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 208));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F2F68; return;
    }
label_1f308c:
    // 0x1f308c: 0x56a00001
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[5]));
        goto label_1f3094;
    }
label_1f3094:
    // 0x1f3094: 0x56400001
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[6]));
        goto label_1f309c;
    }
label_1f309c:
    // 0x1f309c: 0x12e0001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3110; return;
    }
    // 0x1f30a4: 0x12c0001a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3110; return;
    }
    // 0x1f30ac: 0x2e0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1f30b0: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f30b4: 0x0
    // NOP
label_1f30b8:
    // 0x1f30b8: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f30bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f30c0: 0xda810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1f30c4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f30c8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f30cc: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1f30d0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f30d4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f30d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f30dc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f30e0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f30e4: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x1f30ec);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_1f30ec
// Address: 0x1f30ec - 0x1f3140

void entry_1f30ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f30ec) {
        switch (ctx->pc) {
            case 0x1f3110: ctx->pc = 0; goto label_1f3110;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f30ec: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1f30f0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f30f4: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x1f30f8: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f30fc: 0x4be5086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f3100: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f3104: 0x641ffec
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1F30B8; return;
    }
    // 0x1f310c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1f3110:
    // 0x1f3110: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f3114: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f3118: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f311c: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f3120: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f3124: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f3128: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f312c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f3130: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f3134: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1f3138: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetWrBounds__FP2WRP6VECTOR
// Address: 0x1f3140 - 0x1f31f8

void entry_1f3290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3290: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1f3294: 0xc07cc7e
    SET_GPR_U32(ctx, 31, 0x1f329c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1));
    UNoise__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f329c
// Address: 0x1f329c - 0x1f3328

void entry_1f329c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f329c) {
        switch (ctx->pc) {
            case 0x1f32c4: ctx->pc = 0; goto label_1f32c4;
            case 0x1f32dc: ctx->pc = 0; goto label_1f32dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f329c: 0x32020001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 1));
    // 0x1f32a0: 0x10400008
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f32c4;
    }
    // 0x1f32a8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f32ac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f32b0: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x1f32b4: 0x46017001
    ctx->f[0] = FPU_SUB_S(ctx->f[14], ctx->f[1]);
    // 0x1f32b8: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1f32bc: 0x10000007
    ctx->f[14] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f32dc;
    }
label_1f32c4:
    // 0x1f32c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f32c8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f32cc: 0x46157382
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[21]);
    // 0x1f32d0: 0x4601a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1f32d4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1f32d8: 0x46010500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_1f32dc:
    // 0x1f32dc: 0x44901800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 16);
    // 0x1f32e0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1f32e4: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1f32e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f32ec: 0x46147001
    ctx->f[0] = FPU_SUB_S(ctx->f[14], ctx->f[20]);
    // 0x1f32f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f32f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f32f8: 0x4603b0c1
    ctx->f[3] = FPU_SUB_S(ctx->f[22], ctx->f[3]);
    // 0x1f32fc: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1f3300: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x1f3304: 0x46031880
    ctx->f[2] = FPU_ADD_S(ctx->f[3], ctx->f[3]);
    // 0x1f3308: 0x460318c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[3]);
    // 0x1f330c: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1f3310: 0x460118c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1f3314: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1f3318: 0x4600a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1f331c: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1f3320: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UBias__Fff
// Address: 0x1f3328 - 0x1f3358

void entry_1f33a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f33a4) {
        switch (ctx->pc) {
            case 0x1f33c4: ctx->pc = 0; goto label_1f33c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f33a4: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f33a8: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1f33ac: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1f33b0: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1f33b4: 0x4601a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[1]);
    // 0x1f33b8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1f33bc: 0x1440fff4
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3390; return;
    }
label_1f33c4:
    // 0x1f33c4: 0x4614ab03
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[12] = ctx->f[21] / ctx->f[20];
    // 0x1f33c8: 0xc07ccca
    SET_GPR_U32(ctx, 31, 0x1f33d0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[13] = *(float*)&val; }
    UBias__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1f33d0
// Address: 0x1f33d0 - 0x1f3408

void entry_1f33d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f33d0: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f33d4: 0xc6220004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1f33d8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f33dc: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1f33e0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f33e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f33e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f33ec: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1f33f0: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1f33f4: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1f33f8: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1f33fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3404: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3408; return;
}


// Function: UpdateWrMatrixes__FP2WR
// Address: 0x1f3408 - 0x1f346c

void entry_1f346c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f346c) {
        switch (ctx->pc) {
            case 0x1f3470: ctx->pc = 0; goto label_1f3470;
            case 0x1f3488: ctx->pc = 0; goto label_1f3488;
            case 0x1f34c8: ctx->pc = 0; goto label_1f34c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f346c: 0x8e620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
label_1f3470:
    // 0x1f3470: 0x1840008f
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F36B0; return;
    }
    // 0x1f3478: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f347c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1f3480: 0x240200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 208));
    // 0x1f3484: 0x0
    // NOP
label_1f3488:
    // 0x1f3488: 0x2821018
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f348c: 0x24420050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 80));
    // 0x1f3490: 0x2628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1f3494: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f3498: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f349c: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1f34a0: 0x244307e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 2016));
    // 0x1f34a4: 0x244206e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1760));
    // 0x1f34a8: 0x2639021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    // 0x1f34ac: 0x10800006
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1f34c8;
    }
    // 0x1f34b4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f34b8: 0x1082004e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F35F4; return;
    }
    // 0x1f34c0: 0x10000077
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F36A0; return;
    }
label_1f34c8:
    // 0x1f34c8: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1f34cc: 0xc6020068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 104)); ctx->f[2] = *(float*)&val; }
    // 0x1f34d0: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1f34d4: 0x27a40070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1f34d8: 0xc601006c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 108)); ctx->f[1] = *(float*)&val; }
    // 0x1f34dc: 0x27a50074
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 116));
    // 0x1f34e0: 0x46026302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x1f34e4: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1f34e8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1f34ec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f34f0: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x1f34f4: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1f34fc);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1f34fc
// Address: 0x1f34fc - 0x1f35fc

void entry_1f34fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f34fc) {
        switch (ctx->pc) {
            case 0x1f35f4: ctx->pc = 0; goto label_1f35f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f34fc: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x1f3500: 0x8fa20074
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x1f3504: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f3508: 0xda020040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1f350c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f3510: 0xda010020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1f3514: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f3518: 0x8e030060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x1f351c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1f3520: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1f3524: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f3528: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f352c: 0x32900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1f3530: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f3534: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f3538: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f353c: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1f3540: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f3544: 0x2251021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 5)));
    // 0x1f3548: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1f354c: 0x2232021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1f3550: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1f3554: 0x2452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 5)));
    // 0x1f3558: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1f355c: 0x2431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1f3560: 0xe4400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x1f3564: 0xe4420004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1f3568: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1f356c: 0xda010040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1f3570: 0xda020020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1f3574: 0x4be511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1f3578: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f357c: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1f3580: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1f3584: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1f3588: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f358c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1f3590: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1f3594: 0xe4810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1f3598: 0xe4800008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    // 0x1f359c: 0xe4820004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 4), 4), *(uint32_t*)&val); }
    // 0x1f35a0: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1f35a4: 0xda020050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1f35a8: 0xda010030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1f35ac: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1f35b0: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f35b4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f35b8: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f35bc: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1f35c0: 0xe4a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 0), *(uint32_t*)&val); }
    // 0x1f35c4: 0xe4a10004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 5), 4), *(uint32_t*)&val); }
    // 0x1f35c8: 0xda020030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1f35cc: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1f35d0: 0xda010050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1f35d4: 0x4be511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1f35d8: 0x4be30948
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f35dc: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1f35e0: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1f35e4: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1f35e8: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1f35ec: 0x1000002b
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F369C; return;
    }
label_1f35f4:
    // 0x1f35f4: 0xc07ccd6
    SET_GPR_U32(ctx, 31, 0x1f35fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 48));
    GFromOnz__FP3ONZ(rdram, ctx, runtime); return;
}


// Function: entry_1f35fc
// Address: 0x1f35fc - 0x1f3608

void entry_1f35fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f35fc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1f3600: 0xc07ccd6
    SET_GPR_U32(ctx, 31, 0x1f3608);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 128));
    GFromOnz__FP3ONZ(rdram, ctx, runtime); return;
}


// Function: entry_1f3608
// Address: 0x1f3608 - 0x1f3618

void entry_1f3608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3608: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1f360c: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f3610: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1f3618);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 32));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1f3618
// Address: 0x1f3618 - 0x1f3648

void entry_1f3618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3618: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1f361c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f3620: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f3624: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1f3628: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f362c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f3630: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f3634: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f3638: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f363c: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f3640: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1f3648);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1f3648
// Address: 0x1f3648 - 0x1f36e8

void entry_1f3648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3648) {
        switch (ctx->pc) {
            case 0x1f369c: ctx->pc = 0; goto label_1f369c;
            case 0x1f36a0: ctx->pc = 0; goto label_1f36a0;
            case 0x1f36b0: ctx->pc = 0; goto label_1f36b0;
            case 0x1f36c0: ctx->pc = 0; goto label_1f36c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3648: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1f364c: 0xc7a20014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[2] = *(float*)&val; }
    // 0x1f3650: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1f3654: 0x46150841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[21]);
    // 0x1f3658: 0x46151081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[21]);
    // 0x1f365c: 0xc7a50004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[5] = *(float*)&val; }
    // 0x1f3660: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x1f3664: 0xc7a30008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1f3668: 0xc7a40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[4] = *(float*)&val; }
    // 0x1f366c: 0xc7a60018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[6] = *(float*)&val; }
    // 0x1f3670: 0xc7a70020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[7] = *(float*)&val; }
    // 0x1f3674: 0xc7a80024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[8] = *(float*)&val; }
    // 0x1f3678: 0xe6200028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 40), *(uint32_t*)&val); }
    // 0x1f367c: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1f3680: 0xe6250004
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x1f3684: 0xe6230008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x1f3688: 0xe6240010
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1f368c: 0xe6220014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    // 0x1f3690: 0xe6260018
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 17), 24), *(uint32_t*)&val); }
    // 0x1f3694: 0xe6270020
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 17), 32), *(uint32_t*)&val); }
    // 0x1f3698: 0xe6280024
    { float val = ctx->f[8]; WRITE32(ADD32(GPR_U32(ctx, 17), 36), *(uint32_t*)&val); }
label_1f369c:
    // 0x1f369c: 0x8e620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
label_1f36a0:
    // 0x1f36a0: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1f36a4: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1f36a8: 0x1440ff77
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 208));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3488; return;
    }
label_1f36b0:
    // 0x1f36b0: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1f36b4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1f36b8: 0xe6600034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 52), *(uint32_t*)&val); }
    // 0x1f36bc: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1f36c0:
    // 0x1f36c0: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f36c4: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f36c8: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f36cc: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f36d0: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f36d4: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f36d8: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x1f36dc: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1f36e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddWrCircleWarp__FP2WR
// Address: 0x1f36e8 - 0x1f3768

void entry_1f3820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3820: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3824: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f382c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3830; return;
}


// Function: PwreGetWrBend__FP2WR4ENSK
// Address: 0x1f3830 - 0x1f3840

void entry_1f3840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3840: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3844: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f384c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3850; return;
}


// Function: SetWrWavelength__FP2WRf
// Address: 0x1f3850 - 0x1f3868

void entry_1f3868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3868) {
        switch (ctx->pc) {
            case 0x1f388c: ctx->pc = 0; goto label_1f388c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3868: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1f386c: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f3870: 0x0
    // NOP
    // 0x1f3874: 0x45030005
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 100), *(uint32_t*)&val); }
        goto label_1f388c;
    }
    // 0x1f387c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f3880: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f3884: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1f3888: 0xe4400064
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 100), *(uint32_t*)&val); }
label_1f388c:
    // 0x1f388c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3890: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1f3894: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f389c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f38a0; return;
}


// Function: GetWrWavelength__FP2WRPf
// Address: 0x1f38a0 - 0x1f38b8

void entry_1f38b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f38b8) {
        switch (ctx->pc) {
            case 0x1f38e0: ctx->pc = 0; goto label_1f38e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f38b8: 0xc4410064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 100)); ctx->f[1] = *(float*)&val; }
    // 0x1f38bc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1f38c0: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f38c4: 0x0
    // NOP
    // 0x1f38c8: 0x45030005
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
        goto label_1f38e0;
    }
    // 0x1f38d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f38d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f38d8: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1f38dc: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_1f38e0:
    // 0x1f38e0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f38e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f38e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddOnzOnze__FP3ONZffff
// Address: 0x1f38f0 - 0x1f3928

void entry_1f3958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3958: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f395c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1f3960: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1f3964: 0x4600bbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[23]);
    // 0x1f3968: 0xc07ce3c
    SET_GPR_U32(ctx, 31, 0x1f3970);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 48));
    AddOnzOnze__FP3ONZffff(rdram, ctx, runtime); return;
}


// Function: entry_1f3970
// Address: 0x1f3970 - 0x1f3990

void entry_1f3970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3970: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3974: 0xc7b70028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[23] = *(float*)&val; }
    // 0x1f3978: 0xc7b60020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
    // 0x1f397c: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x1f3980: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1f3984: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f398c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3990; return;
}


// Function: AddWrSwivelNoise__FP2WRffff
// Address: 0x1f3990 - 0x1f39c0

void entry_1f39c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f39c0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1f39c4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1f39c8: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1f39cc: 0x4600bbc6
    ctx->f[15] = FPU_MOV_S(ctx->f[23]);
    // 0x1f39d0: 0xc07ce3c
    SET_GPR_U32(ctx, 31, 0x1f39d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 128));
    AddOnzOnze__FP3ONZffff(rdram, ctx, runtime); return;
}


// Function: entry_1f39d8
// Address: 0x1f39d8 - 0x1f39f8

void entry_1f39d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f39d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f39dc: 0xc7b70028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[23] = *(float*)&val; }
    // 0x1f39e0: 0xc7b60020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
    // 0x1f39e4: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x1f39e8: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1f39ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f39f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f39f8; return;
}


// Function: InitXfm__FP3XFM
// Address: 0x1f39f8 - 0x1f3a0c

void entry_1f3a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3a0c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1f3a10: 0x26050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1f3a14: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x1f3a18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3a1c: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f3a20: 0x7e020050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 2));
    // 0x1f3a24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3a28: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1f3a2c: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x1f3a30: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1f3a34: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x1f3a38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadXfmFromBrx__FP3XFMP18CBinaryInputStream
// Address: 0x1f3a40 - 0x1f3a64

void entry_1f3a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3a64: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f3a68: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1f3a70);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 64));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f3a70
// Address: 0x1f3a70 - 0x1f3a7c

void entry_1f3a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3a70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f3a74: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1f3a7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3a7c
// Address: 0x1f3a7c - 0x1f3a90

void entry_1f3a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3a7c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3a80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3a84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3a88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetXfmParent__FP3XFMP3ALO
// Address: 0x1f3a90 - 0x1f3ab8

void entry_1f3ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3ab8: 0x26060050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1f3abc: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1f3ac0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f3ac4: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1f3acc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1f3acc
// Address: 0x1f3acc - 0x1f3ad8

void entry_1f3acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3acc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f3ad0: 0xc060bde
    SET_GPR_U32(ctx, 31, 0x1f3ad8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f3ad8
// Address: 0x1f3ad8 - 0x1f3af0

void entry_1f3ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3ad8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3adc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3ae0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3ae4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3aec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3af0; return;
}


// Function: ApplyXfmProxy__FP3XFMP5PROXY
// Address: 0x1f3af0 - 0x1f3b1c

void entry_1f3b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3b1c: 0x26100050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1f3b20: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f3b24: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f3b28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3b2c: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1f3b34);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1f3b34
// Address: 0x1f3b34 - 0x1f3b48

void entry_1f3b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3b34: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3b38: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3b3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3b40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertXfmLocalToWorld__FP3XFMP6VECTORT1
// Address: 0x1f3b48 - 0x1f3b78

void entry_1f3b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3b78: 0xda010040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1f3b7c: 0x26020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1f3b80: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3b84: 0xda040050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1f3b88: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1f3b8c: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1f3b90: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f3b94: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3b98: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1f3b9c: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1f3ba0: 0x4be3222a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1f3ba4: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1f3ba8: 0x4be309ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f3bac: 0x4be311aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f3bb0: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1f3bb4: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f3bb8: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1f3bbc: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f3bc0: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1f3bc4: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f3bc8: 0xfa250000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1f3bcc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3bd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetXfmPos__FP3XFMP6VECTOR
// Address: 0x1f3bd8 - 0x1f3bf8

void entry_1f3bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3bf8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3bfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3c04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3c08; return;
}


// Function: GetXfmMat__FP3XFMP7MATRIX3
// Address: 0x1f3c08 - 0x1f3c28

void entry_1f3c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3c28: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3c2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3c38; return;
}


// Function: PwarpFromOid__F3OIDT0
// Address: 0x1f3c38 - 0x1f3c7c

void entry_1f3c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3c7c: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1f3c80: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f3c84: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1f3c88: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1f3c90);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f3c90
// Address: 0x1f3c90 - 0x1f3cc0

void entry_1f3c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3c90) {
        switch (ctx->pc) {
            case 0x1f3c94: ctx->pc = 0; goto label_1f3c94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3c90: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1f3c94:
    // 0x1f3c94: 0x16000031
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3D5C; return;
    }
    // 0x1f3c9c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f3ca0: 0x24060074
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 116));
    // 0x1f3ca4: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1f3ca8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3cac: 0x24050205
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 517));
    // 0x1f3cb0: 0x24080100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 256));
    // 0x1f3cb4: 0x3a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f3cb8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1f3cc0);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f3cc0
// Address: 0x1f3cc0 - 0x1f3d80

void entry_1f3cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3cc0) {
        switch (ctx->pc) {
            case 0x1f3cf0: ctx->pc = 0; goto label_1f3cf0;
            case 0x1f3cf4: ctx->pc = 0; goto label_1f3cf4;
            case 0x1f3d1c: ctx->pc = 0; goto label_1f3d1c;
            case 0x1f3d40: ctx->pc = 0; goto label_1f3d40;
            case 0x1f3d50: ctx->pc = 0; goto label_1f3d50;
            case 0x1f3d5c: ctx->pc = 0; goto label_1f3d5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3cc0: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3cc4: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f3cc8: 0x24030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f3ccc: 0x2402003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1f3cd0: 0x47102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 7)));
    // 0x1f3cd4: 0x62380b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 3));
    // 0x1f3cd8: 0x207102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 7)));
    // 0x1f3cdc: 0x1040001c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f3d50;
    }
    // 0x1f3ce4: 0x16340016
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 20)) {
        goto label_1f3d40;
    }
    // 0x1f3cec: 0x0
    // NOP
label_1f3cf0:
    // 0x1f3cf0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1f3cf4:
    // 0x1f3cf4: 0x24425f80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24448));
    // 0x1f3cf8: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1f3cfc: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 144)));
        goto label_1f3d1c;
    }
    // 0x1f3d04: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x1f3d08: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f3d0c: 0x14620003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 144)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f3d1c;
    }
    // 0x1f3d14: 0x8ca20094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 148)));
    // 0x1f3d18: 0xa2900b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 5));
label_1f3d1c:
    // 0x1f3d1c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1f3d20: 0xc7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 7)));
    // 0x1f3d24: 0x1040000a
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f3d50;
    }
    // 0x1f3d2c: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1f3d30: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f3d34: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1f3d38: 0x1224ffed
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 4)) {
        goto label_1f3cf0;
    }
label_1f3d40:
    // 0x1f3d40: 0x8ca200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 176)));
    // 0x1f3d44: 0x1622ffeb
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_1f3cf4;
    }
    // 0x1f3d4c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1f3d50:
    // 0x1f3d50: 0x250800a
    if (GPR_U32(ctx, 16) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 18));
    // 0x1f3d54: 0x270800a
    if (GPR_U32(ctx, 16) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 19));
    // 0x1f3d58: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f3d5c:
    // 0x1f3d5c: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1f3d60: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1f3d64: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1f3d68: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1f3d6c: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1f3d70: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1f3d74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3d7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3d80; return;
}


// Function: LoadWarpFromBrx__FP4WARPP18CBinaryInputStream
// Address: 0x1f3d80 - 0x1f3db4

void entry_1f3db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3db4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f3db8: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1f3dc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 64));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f3dc0
// Address: 0x1f3dc0 - 0x1f3dcc

void entry_1f3dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3dc0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f3dc4: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1f3dcc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3dcc
// Address: 0x1f3dcc - 0x1f3dd4

void entry_1f3dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3dcc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3dd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3dd4
// Address: 0x1f3dd4 - 0x1f3de0

void entry_1f3dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3dd4: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f3dd8: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1f3de0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 160), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f3de0
// Address: 0x1f3de0 - 0x1f3df8

void entry_1f3de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3de0) {
        switch (ctx->pc) {
            case 0x1f3df0: ctx->pc = 0; goto label_1f3df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3de0: 0x8e4300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3de4: 0x1860001e
    WRITE32(ADD32(GPR_U32(ctx, 18), 164), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F3E60; return;
    }
    // 0x1f3dec: 0x0
    // NOP
label_1f3df0:
    // 0x1f3df0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3df8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3df8
// Address: 0x1f3df8 - 0x1f3e04

void entry_1f3df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3df8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f3dfc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3e04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3e04
// Address: 0x1f3e04 - 0x1f3e10

void entry_1f3e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3e04: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f3e08: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3e10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3e10
// Address: 0x1f3e10 - 0x1f3e28

void entry_1f3e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3e10: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f3e14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3e18: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f3e1c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f3e20: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1f3e28);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1f3e28
// Address: 0x1f3e28 - 0x1f3e50

void entry_1f3e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3e28: 0x8e4400a4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 164)));
    // 0x1f3e2c: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1f3e30: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f3e34: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1f3e38: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f3e3c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1f3e40: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f3e44: 0x8c660038
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f3e48: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1f3e50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1f3e50
// Address: 0x1f3e50 - 0x1f3e6c

void entry_1f3e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3e50) {
        switch (ctx->pc) {
            case 0x1f3e60: ctx->pc = 0; goto label_1f3e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3e50: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3e54: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1f3e58: 0x1440ffe5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3DF0; return;
    }
label_1f3e60:
    // 0x1f3e60: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f3e64: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1f3e6c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3e6c
// Address: 0x1f3e6c - 0x1f3e74

void entry_1f3e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3e6c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3e74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3e74
// Address: 0x1f3e74 - 0x1f3e80

void entry_1f3e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3e74: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f3e78: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1f3e80);
    WRITE32(ADD32(GPR_U32(ctx, 18), 168), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f3e80
// Address: 0x1f3e80 - 0x1f3e98

void entry_1f3e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3e80) {
        switch (ctx->pc) {
            case 0x1f3e90: ctx->pc = 0; goto label_1f3e90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3e80: 0x8e4300a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 168)));
    // 0x1f3e84: 0x1860000d
    WRITE32(ADD32(GPR_U32(ctx, 18), 172), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F3EBC; return;
    }
    // 0x1f3e8c: 0x0
    // NOP
label_1f3e90:
    // 0x1f3e90: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f3e98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f3e98
// Address: 0x1f3e98 - 0x1f3ee0

void entry_1f3e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3e98) {
        switch (ctx->pc) {
            case 0x1f3ebc: ctx->pc = 0; goto label_1f3ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3e98: 0x8e4400ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 172)));
    // 0x1f3e9c: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f3ea0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f3ea4: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f3ea8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1f3eac: 0x8e4200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 168)));
    // 0x1f3eb0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f3eb4: 0x1440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F3E90; return;
    }
label_1f3ebc:
    // 0x1f3ebc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f3ec0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f3ec4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f3ec8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3ecc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3ed0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3ed4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3edc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3ee0; return;
}


// Function: CloneWarp__FP4WARPT0
// Address: 0x1f3ee0 - 0x1f3f04

void entry_1f3f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3f04: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3f08: 0x8e4400a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3f0c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1f3f14);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f3f14
// Address: 0x1f3f14 - 0x1f3f44

void entry_1f3f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3f14) {
        switch (ctx->pc) {
            case 0x1f3f28: ctx->pc = 0; goto label_1f3f28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3f14: 0x8e4300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3f18: 0x18600011
    WRITE32(ADD32(GPR_U32(ctx, 18), 164), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F3F60; return;
    }
    // 0x1f3f20: 0x8e6200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 164)));
    // 0x1f3f24: 0x0
    // NOP
label_1f3f28:
    // 0x1f3f28: 0x118080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1f3f2c: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f3f30: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f3f34: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f3f38: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f3f3c: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1f3f44);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f3f44
// Address: 0x1f3f44 - 0x1f3f80

void entry_1f3f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3f44) {
        switch (ctx->pc) {
            case 0x1f3f60: ctx->pc = 0; goto label_1f3f60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3f44: 0x8e4300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
    // 0x1f3f48: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1f3f4c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1f3f50: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3f54: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1f3f58: 0x5440fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 164)));
        ctx->pc = 0x1F3F28; return;
    }
label_1f3f60:
    // 0x1f3f60: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f3f64: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f3f68: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3f6c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3f70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3f74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f3f7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f3f80; return;
}


// Function: PostWarpLoad__FP4WARP
// Address: 0x1f3f80 - 0x1f3fa0

void entry_1f3fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3fa0) {
        switch (ctx->pc) {
            case 0x1f3fb0: ctx->pc = 0; goto label_1f3fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3fa0: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3fa4: 0x18400012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F3FF0; return;
    }
    // 0x1f3fac: 0x8e4300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
label_1f3fb0:
    // 0x1f3fb0: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1f3fb4: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1f3fb8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f3fbc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f3fc0: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f3fc4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f3fc8: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1f3fcc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f3fd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f3fd4
// Address: 0x1f3fd4 - 0x1f3fdc

void entry_1f3fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f3fd4: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1f3fdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f3fdc
// Address: 0x1f3fdc - 0x1f4008

void entry_1f3fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f3fdc) {
        switch (ctx->pc) {
            case 0x1f3ff0: ctx->pc = 0; goto label_1f3ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f3fdc: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f3fe0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1f3fe4: 0x5440fff2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
        ctx->pc = 0x1F3FB0; return;
    }
    // 0x1f3fec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1f3ff0:
    // 0x1f3ff0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f3ff4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f3ff8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f3ffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4008; return;
}


// Function: TriggerWarp__FP4WARP
// Address: 0x1f4008 - 0x1f4030

void entry_1f4030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4030: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4034: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4038: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1f4040);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f4040
// Address: 0x1f4040 - 0x1f4050

void entry_1f4040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4040: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f4044: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4048: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1f4050);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1f4050
// Address: 0x1f4050 - 0x1f4094

void entry_1f4050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4050: 0x56600015
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1F40A8; return;
    }
    // 0x1f4058: 0x3c01c396
    SET_GPR_U32(ctx, 1, ((uint32_t)50070 << 16));
    // 0x1f405c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f4060: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1f4064: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4068: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1f406c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f4070: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f4074: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f4078: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f407c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1f4080: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f4084: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1f4088: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f408c: 0xc05124e
    SET_GPR_U32(ctx, 31, 0x1f4094);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    SetCmLookAt(rdram, ctx, runtime); return;
}


// Function: entry_1f4094
// Address: 0x1f4094 - 0x1f40a0

void entry_1f4094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4094: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1f4098: 0xc051570
    SET_GPR_U32(ctx, 31, 0x1f40a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_1f40a0
// Address: 0x1f40a0 - 0x1f40c0

void entry_1f40a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f40a0) {
        switch (ctx->pc) {
            case 0x1f40a8: ctx->pc = 0; goto label_1f40a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f40a0: 0x10000083
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F42B0; return;
    }
label_1f40a8:
    // 0x1f40a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f40ac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f40b0: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f40b4: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1f40b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f40c0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 184));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f40c0
// Address: 0x1f40c0 - 0x1f40d4

void entry_1f40c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f40c0: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1f40c4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f40c8: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x1f40cc: 0xc06e618
    SET_GPR_U32(ctx, 31, 0x1f40d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    TranslateSoToPosSafe__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1f40d4
// Address: 0x1f40d4 - 0x1f40e8

void entry_1f40d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f40d4: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1f40d8: 0x26450080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 128));
    // 0x1f40dc: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1f40e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f40e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f40e8
// Address: 0x1f40e8 - 0x1f4100

void entry_1f40e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f40e8: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1f40ec: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1f40f0: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x1f40f4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1f40f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f4100);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f4100
// Address: 0x1f4100 - 0x1f4108

void entry_1f4100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4100: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1f4108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1f4108
// Address: 0x1f4108 - 0x1f4144

void entry_1f4108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4108) {
        switch (ctx->pc) {
            case 0x1f4118: ctx->pc = 0; goto label_1f4118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4108: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f410c: 0x18400011
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 96));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F4154; return;
    }
    // 0x1f4114: 0x8e4300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
label_1f4118:
    // 0x1f4118: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f411c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f4120: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4124: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f4128: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f412c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f4130: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f4134: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4138: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f413c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1f4144);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f4144
// Address: 0x1f4144 - 0x1f4170

void entry_1f4144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4144) {
        switch (ctx->pc) {
            case 0x1f4154: ctx->pc = 0; goto label_1f4154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4144: 0x8e4200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 160)));
    // 0x1f4148: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f414c: 0x5440fff2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
        ctx->pc = 0x1F4118; return;
    }
label_1f4154:
    // 0x1f4154: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f4158: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f415c: 0x8e4500b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 180)));
    // 0x1f4160: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4164: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4168: 0xc04fb2c
    SET_GPR_U32(ctx, 31, 0x1f4170);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1f4170
// Address: 0x1f4170 - 0x1f419c

void entry_1f4170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4170) {
        switch (ctx->pc) {
            case 0x1f4180: ctx->pc = 0; goto label_1f4180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4170: 0x8e4200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 168)));
    // 0x1f4174: 0x58400015
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x1F41CC; return;
    }
    // 0x1f417c: 0x8e4300ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 172)));
label_1f4180:
    // 0x1f4180: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f4184: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f4188: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1f418c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f4190: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4194: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1f419c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f419c
// Address: 0x1f419c - 0x1f41b4

void entry_1f419c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f419c: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f41b4(rdram, ctx, runtime); return;
    }
    // 0x1f41a4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f41a8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f41ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f41b4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f41b4
// Address: 0x1f41b4 - 0x1f41e4

void entry_1f41b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f41b4) {
        switch (ctx->pc) {
            case 0x1f41cc: ctx->pc = 0; goto label_1f41cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f41b4: 0x8e4200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 168)));
    // 0x1f41b8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f41bc: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f41c0: 0x5440ffef
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 172)));
        ctx->pc = 0x1F4180; return;
    }
    // 0x1f41c8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1f41cc:
    // 0x1f41cc: 0x24050205
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 517));
    // 0x1f41d0: 0x2406007d
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 125));
    // 0x1f41d4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f41d8: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f41dc: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1f41e4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f41e4
// Address: 0x1f41e4 - 0x1f4228

void entry_1f41e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f41e4) {
        switch (ctx->pc) {
            case 0x1f4210: ctx->pc = 0; goto label_1f4210;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f41e4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f41e8: 0x24030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f41ec: 0x2402003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1f41f0: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x1f41f4: 0x62800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x1f41f8: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1f41fc: 0x600000d
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x1F4234; return;
    }
    // 0x1f4204: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f4208: 0x558821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1f420c: 0x0
    // NOP
label_1f4210:
    // 0x1f4210: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f4214: 0x8c8202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 740)));
    // 0x1f4218: 0x50540004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        ctx->pc = 0x1F422C; return;
    }
    // 0x1f4220: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4228);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4228
// Address: 0x1f4228 - 0x1f4260

void entry_1f4228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4228) {
        switch (ctx->pc) {
            case 0x1f422c: ctx->pc = 0; goto label_1f422c;
            case 0x1f4234: ctx->pc = 0; goto label_1f4234;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4228: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
label_1f422c:
    // 0x1f422c: 0x601fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1F4210; return;
    }
label_1f4234:
    // 0x1f4234: 0xde620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 1336)));
    // 0x1f4238: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f423c: 0x31fb8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 30);
    // 0x1f4240: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f4244: 0x10400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F429C; return;
    }
    // 0x1f424c: 0x8e420098
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 152)));
    // 0x1f4250: 0x1040000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4288; return;
    }
    // 0x1f4258: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1f4260);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1f4260
// Address: 0x1f4260 - 0x1f426c

void entry_1f4260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4260: 0xc64c009c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 156)); ctx->f[12] = *(float*)&val; }
    // 0x1f4264: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1f426c);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1f426c
// Address: 0x1f426c - 0x1f4280

void entry_1f426c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f426c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f4270: 0xe7a00160
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 352), *(uint32_t*)&val); }
    // 0x1f4274: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1f4278: 0xc051570
    SET_GPR_U32(ctx, 31, 0x1f4280);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 352));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_1f4280
// Address: 0x1f4280 - 0x1f4298

void entry_1f4280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4280) {
        switch (ctx->pc) {
            case 0x1f4288: ctx->pc = 0; goto label_1f4288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4280: 0x10000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F429C; return;
    }
label_1f4288:
    // 0x1f4288: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f428c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4290: 0xc051570
    SET_GPR_U32(ctx, 31, 0x1f4298);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_1f4298
// Address: 0x1f4298 - 0x1f42ac

void entry_1f4298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4298) {
        switch (ctx->pc) {
            case 0x1f429c: ctx->pc = 0; goto label_1f429c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4298: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f429c:
    // 0x1f429c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f42a0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f42a4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1f42ac);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1f42ac
// Address: 0x1f42ac - 0x1f42d0

void entry_1f42ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f42ac) {
        switch (ctx->pc) {
            case 0x1f42b0: ctx->pc = 0; goto label_1f42b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f42ac: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
label_1f42b0:
    // 0x1f42b0: 0x7bb501c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1f42b4: 0x7bb401b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1f42b8: 0x7bb301a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1f42bc: 0x7bb20190
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1f42c0: 0x7bb10180
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1f42c4: 0x7bb00170
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1f42c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetWarpRsmg__FP4WARPi3OIDN22
// Address: 0x1f42d0 - 0x1f42fc

void entry_1f42fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f42fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4300: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001F4308
// Address: 0x1f4308 - 0x1f4318

void FUN_001F4308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4308: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f430c: 0xe48c009c
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 156), *(uint32_t*)&val); }
    // 0x1f4310: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 152), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TeleportSwPlayer__FP2SW3OIDT1
// Address: 0x1f4318 - 0x1f432c

void entry_1f432c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f432c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4344; return;
    }
    // 0x1f4334: 0xc07d002
    SET_GPR_U32(ctx, 31, 0x1f433c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    TriggerWarp__FP4WARP(rdram, ctx, runtime); return;
}


// Function: entry_1f433c
// Address: 0x1f433c - 0x1f434c

void entry_1f433c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f433c) {
        switch (ctx->pc) {
            case 0x1f4344: ctx->pc = 0; goto label_1f4344;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f433c: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4370; return;
    }
label_1f4344:
    // 0x1f4344: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1f434c);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1f434c
// Address: 0x1f434c - 0x1f435c

void entry_1f434c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f434c: 0x14400008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4370; return;
    }
    // 0x1f4354: 0xc064988
    SET_GPR_U32(ctx, 31, 0x1f435c);
    PpoStart__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1f435c
// Address: 0x1f435c - 0x1f436c

void entry_1f435c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f435c: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4370; return;
    }
    // 0x1f4364: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1f436c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1f436c
// Address: 0x1f436c - 0x1f4378

void entry_1f436c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f436c) {
        switch (ctx->pc) {
            case 0x1f4370: ctx->pc = 0; goto label_1f4370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f436c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1f4370:
    // 0x1f4370: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PexitDefault__Fv
// Address: 0x1f4378 - 0x1f43a4

void entry_1f43a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f43a4) {
        switch (ctx->pc) {
            case 0x1f43d0: ctx->pc = 0; goto label_1f43d0;
            case 0x1f43e4: ctx->pc = 0; goto label_1f43e4;
            case 0x1f43f4: ctx->pc = 0; goto label_1f43f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f43a4: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f43a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f43ac: 0x24030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f43b0: 0x2402003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1f43b4: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x1f43b8: 0x62280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1f43bc: 0x18a0000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_1f43f4;
    }
    // 0x1f43c4: 0x10000007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f43e4;
    }
    // 0x1f43cc: 0x0
    // NOP
label_1f43d0:
    // 0x1f43d0: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x1f43d4: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f43f4;
    }
    // 0x1f43dc: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1f43e0: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
label_1f43e4:
    // 0x1f43e4: 0x8c6202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 720)));
    // 0x1f43e8: 0x5040fff9
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1f43d0;
    }
    // 0x1f43f0: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1f43f4:
    // 0x1f43f4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f43f8: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1f43fc: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1f4400: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TriggerDefaultExit__Fi5WIPEK
// Address: 0x1f4408 - 0x1f4468

void entry_1f4468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4468) {
        switch (ctx->pc) {
            case 0x1f4470: ctx->pc = 0; goto label_1f4470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4468: 0x10000021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F44F0; return;
    }
label_1f4470:
    // 0x1f4470: 0xc058060
    SET_GPR_U32(ctx, 31, 0x1f4478);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 1));
    call_search_level_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1f4478
// Address: 0x1f4478 - 0x1f4488

void entry_1f4478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4478: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f447c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f4480: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x1f4488);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 445));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_1f4488
// Address: 0x1f4488 - 0x1f4498

void entry_1f4488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4488) {
        switch (ctx->pc) {
            case 0x1f4490: ctx->pc = 0; goto label_1f4490;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4488: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F44F0; return;
    }
label_1f4490:
    // 0x1f4490: 0xc07d0de
    SET_GPR_U32(ctx, 31, 0x1f4498);
    PexitDefault__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1f4498
// Address: 0x1f4498 - 0x1f44b0

void entry_1f4498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4498) {
        switch (ctx->pc) {
            case 0x1f44a8: ctx->pc = 0; goto label_1f44a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4498: 0x10400007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F44B8; return;
    }
    // 0x1f44a0: 0x56200001
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 784), GPR_U32(ctx, 0));
        goto label_1f44a8;
    }
label_1f44a8:
    // 0x1f44a8: 0xc07d202
    SET_GPR_U32(ctx, 31, 0x1f44b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    TriggerExit__FP4EXIT(rdram, ctx, runtime); return;
}


// Function: entry_1f44b0
// Address: 0x1f44b0 - 0x1f44ec

void entry_1f44b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f44b0) {
        switch (ctx->pc) {
            case 0x1f44b8: ctx->pc = 0; goto label_1f44b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f44b0: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F44F0; return;
    }
label_1f44b8:
    // 0x1f44b8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f44bc: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x1f44c0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f44c4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f44c8: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1f44cc: 0xafa50008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 5));
    // 0x1f44d0: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x1f44d4: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1f44d8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f44dc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1f44e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f44e4: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x1f44ec);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_1f44ec
// Address: 0x1f44ec - 0x1f4500

void entry_1f44ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f44ec) {
        switch (ctx->pc) {
            case 0x1f44f0: ctx->pc = 0; goto label_1f44f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f44ec: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1f44f0:
    // 0x1f44f0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f44f4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f44f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadExitFromBrx__FP4EXITP18CBinaryInputStream
// Address: 0x1f4500 - 0x1f4530

void entry_1f4530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4530: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f4534: 0xc04e154
    SET_GPR_U32(ctx, 31, 0x1f453c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 776));
    Unknown2__18CBinaryInputStreamPPv(rdram, ctx, runtime); return;
}


// Function: entry_1f453c
// Address: 0x1f453c - 0x1f4548

void entry_1f453c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f453c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f4540: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x1f4548);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 208));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1f4548
// Address: 0x1f4548 - 0x1f4554

void entry_1f4548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4548: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f454c: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1f4554);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 256));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f4554
// Address: 0x1f4554 - 0x1f456c

void entry_1f4554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4554: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f4558: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1f455c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 740), GPR_U32(ctx, 0));
        ctx->pc = 0x1F4570; return;
    }
    // 0x1f4564: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f456c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f456c
// Address: 0x1f456c - 0x1f4588

void entry_1f456c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f456c) {
        switch (ctx->pc) {
            case 0x1f4570: ctx->pc = 0; goto label_1f4570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f456c: 0xae4002e4
    WRITE32(ADD32(GPR_U32(ctx, 18), 740), GPR_U32(ctx, 0));
label_1f4570:
    // 0x1f4570: 0x264602f0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 752));
    // 0x1f4574: 0x264702f4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 756));
    // 0x1f4578: 0x264802f8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 760));
    // 0x1f457c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f4580: 0xc079312
    SET_GPR_U32(ctx, 31, 0x1f4588);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 748));
    LoadTbspFromBrx__FP18CBinaryInputStreamPiPP5TSURFT1PP4TBSP(rdram, ctx, runtime); return;
}


// Function: entry_1f4588
// Address: 0x1f4588 - 0x1f4598

void entry_1f4588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4588: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f458c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f4590: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1f4598);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f4598
// Address: 0x1f4598 - 0x1f45a0

void entry_1f4598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4598: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f45a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f45a0
// Address: 0x1f45a0 - 0x1f45ac

void entry_1f45a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f45a0: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1f45a4: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1f45ac);
    WRITE32(ADD32(GPR_U32(ctx, 18), 784), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1f45ac
// Address: 0x1f45ac - 0x1f45c0

void entry_1f45ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f45ac) {
        switch (ctx->pc) {
            case 0x1f45b8: ctx->pc = 0; goto label_1f45b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f45ac: 0x8e430310
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f45b0: 0x18600022
    WRITE32(ADD32(GPR_U32(ctx, 18), 788), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F463C; return;
    }
label_1f45b8:
    // 0x1f45b8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f45c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f45c0
// Address: 0x1f45c0 - 0x1f45cc

void entry_1f45c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f45c0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f45c4: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f45cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f45cc
// Address: 0x1f45cc - 0x1f45d8

void entry_1f45cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f45cc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f45d0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1f45d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1f45d8
// Address: 0x1f45d8 - 0x1f45f0

void entry_1f45d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f45d8: 0x8e460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1f45dc: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f45e0: 0x8e450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1f45e4: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f45e8: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1f45f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1f45f0
// Address: 0x1f45f0 - 0x1f461c

void entry_1f45f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f45f0: 0x8e440314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 788)));
    // 0x1f45f4: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1f45f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f45fc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f4600: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f4604: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1f4608: 0xac700000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 16));
    // 0x1f460c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f4610: 0x8c430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x1f4614: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f461c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f461c
// Address: 0x1f461c - 0x1f462c

void entry_1f461c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f461c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f4620: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1f4624: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f462c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f462c
// Address: 0x1f462c - 0x1f4660

void entry_1f462c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f462c) {
        switch (ctx->pc) {
            case 0x1f463c: ctx->pc = 0; goto label_1f463c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f462c: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f4630: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x1f4634: 0x1440ffe0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F45B8; return;
    }
label_1f463c:
    // 0x1f463c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f4640: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f4644: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f4648: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f464c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4650: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4654: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f465c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4660; return;
}


// Function: PostExitLoad__FP4EXIT
// Address: 0x1f4660 - 0x1f4680

void entry_1f4680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4680) {
        switch (ctx->pc) {
            case 0x1f4690: ctx->pc = 0; goto label_1f4690;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4680: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f4684: 0x58400017
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
        ctx->pc = 0x1F46E4; return;
    }
    // 0x1f468c: 0x8e420314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 788)));
label_1f4690:
    // 0x1f4690: 0x108880
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1f4694: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f4698: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f469c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f46a0: 0x8c63004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 76)));
    // 0x1f46a4: 0x50600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 788)));
        ctx->pc = 0x1F46B8; return;
    }
    // 0x1f46ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f46b4);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f46b4
// Address: 0x1f46b4 - 0x1f46d0

void entry_1f46b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f46b4) {
        switch (ctx->pc) {
            case 0x1f46b8: ctx->pc = 0; goto label_1f46b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f46b4: 0x8e420314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 788)));
label_1f46b8:
    // 0x1f46b8: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f46bc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f46c0: 0x8c850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f46c4: 0x8ca30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x1f46c8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f46d0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f46d0
// Address: 0x1f46d0 - 0x1f4744

void entry_1f46d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f46d0) {
        switch (ctx->pc) {
            case 0x1f46e4: ctx->pc = 0; goto label_1f46e4;
            case 0x1f4718: ctx->pc = 0; goto label_1f4718;
            case 0x1f4738: ctx->pc = 0; goto label_1f4738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f46d0: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f46d4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f46d8: 0x5440ffed
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 788)));
        ctx->pc = 0x1F4690; return;
    }
    // 0x1f46e0: 0x8e4202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
label_1f46e4:
    // 0x1f46e4: 0x10400017
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f4744(rdram, ctx, runtime); return;
    }
    // 0x1f46ec: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1f46f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f46f4: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x1f46f8: 0x14600013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4748; return;
    }
    // 0x1f4700: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4704: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1f4708: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_1f4738;
    }
    // 0x1f4710: 0x8c840018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1f4714: 0x0
    // NOP
label_1f4718:
    // 0x1f4718: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1f471c: 0x0
    // NOP
    // 0x1f4720: 0x0
    // NOP
    // 0x1f4724: 0x0
    // NOP
    // 0x1f4728: 0x0
    // NOP
    // 0x1f472c: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 24)));
        goto label_1f4718;
    }
    // 0x1f4734: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
label_1f4738:
    // 0x1f4738: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1f473c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f4744);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f4744
// Address: 0x1f4744 - 0x1f4760

void entry_1f4744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4744) {
        switch (ctx->pc) {
            case 0x1f4748: ctx->pc = 0; goto label_1f4748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4744: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1f4748:
    // 0x1f4748: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f474c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4750: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f475c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4760; return;
}


// Function: SetExitExits__FP4EXIT5EXITS
// Address: 0x1f4760 - 0x1f47a4

void entry_1f47a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f47a4) {
        switch (ctx->pc) {
            case 0x1f47a8: ctx->pc = 0; goto label_1f47a8;
            case 0x1f47b0: ctx->pc = 0; goto label_1f47b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f47a4: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
label_1f47a8:
    // 0x1f47a8: 0x5622000f
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 17));
        ctx->pc = 0x1F47E8; return;
    }
label_1f47b0:
    // 0x1f47b0: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1f47b4: 0x2403fcff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x1f47b8: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1f47bc: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1f47c0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1f47c4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1f47c8: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f47cc: 0x52e78
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 25);
    // 0x1f47d0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1f47d4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f47d8: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1f47dc: 0xc077688
    SET_GPR_U32(ctx, 31, 0x1f47e4);
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    IncrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1f47e4
// Address: 0x1f47e4 - 0x1f4808

void entry_1f47e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f47e4) {
        switch (ctx->pc) {
            case 0x1f47e8: ctx->pc = 0; goto label_1f47e8;
            case 0x1f47f4: ctx->pc = 0; goto label_1f47f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f47e4: 0xae1102e4
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 17));
label_1f47e8:
    // 0x1f47e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f47ec: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1f47f0: 0xe60002e8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 744), *(uint32_t*)&val); }
label_1f47f4:
    // 0x1f47f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f47f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f47fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4800: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TriggerExit__FP4EXIT
// Address: 0x1f4808 - 0x1f4830

void entry_1f4830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4830: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4834: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f4838: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f483c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4840: 0x2442e9f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961656));
    // 0x1f4844: 0x8c440260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1f4848: 0x54830018
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294961656));
        ctx->pc = 0x1F48AC; return;
    }
    // 0x1f4850: 0x8e4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 736)));
    // 0x1f4854: 0x1440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4890; return;
    }
    // 0x1f485c: 0x8e4202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    // 0x1f4860: 0x1440000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4890; return;
    }
    // 0x1f4868: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1f486c: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1f4870: 0x1480000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294961656));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F48AC; return;
    }
    // 0x1f4878: 0xc058068
    SET_GPR_U32(ctx, 31, 0x1f4880);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 764)));
    FFindLevel(rdram, ctx, runtime); return;
}


// Function: entry_1f4880
// Address: 0x1f4880 - 0x1f4898

void entry_1f4880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4880) {
        switch (ctx->pc) {
            case 0x1f4890: ctx->pc = 0; goto label_1f4890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4880: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1f4884: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4888: 0x14430008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294961656));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1F48AC; return;
    }
label_1f4890:
    // 0x1f4890: 0xc07820a
    SET_GPR_U32(ctx, 31, 0x1f4898);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294961656));
    gui_set_mode_3(rdram, ctx, runtime); return;
}


// Function: entry_1f4898
// Address: 0x1f4898 - 0x1f48a4

void entry_1f4898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4898: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f489c: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f48a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f48a4
// Address: 0x1f48a4 - 0x1f48c4

void entry_1f48a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f48a4) {
        switch (ctx->pc) {
            case 0x1f48ac: ctx->pc = 0; goto label_1f48ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f48a4: 0x10000056
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4A00; return;
    }
label_1f48ac:
    // 0x1f48ac: 0x8c820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x1f48b0: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1f48b4: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 728)));
        ctx->pc = 0x1F48C8; return;
    }
    // 0x1f48bc: 0xc0780b2
    SET_GPR_U32(ctx, 31, 0x1f48c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    gui_set_widget_modeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_1f48c4
// Address: 0x1f48c4 - 0x1f48dc

void entry_1f48c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f48c4) {
        switch (ctx->pc) {
            case 0x1f48c8: ctx->pc = 0; goto label_1f48c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f48c4: 0x8e4202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 728)));
label_1f48c8:
    // 0x1f48c8: 0x10400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F48F0; return;
    }
    // 0x1f48d0: 0x8e450318
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 792)));
    // 0x1f48d4: 0xc07d102
    SET_GPR_U32(ctx, 31, 0x1f48dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    TriggerDefaultExit__Fi5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_1f48dc
// Address: 0x1f48dc - 0x1f48e8

void entry_1f48dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f48dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f48e0: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f48e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f48e8
// Address: 0x1f48e8 - 0x1f4900

void entry_1f48e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f48e8) {
        switch (ctx->pc) {
            case 0x1f48f0: ctx->pc = 0; goto label_1f48f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f48e8: 0x1000004a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4A14; return;
    }
label_1f48f0:
    // 0x1f48f0: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4908; return;
    }
    // 0x1f48f8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f4900);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f4900
// Address: 0x1f4900 - 0x1f4928

void entry_1f4900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4900) {
        switch (ctx->pc) {
            case 0x1f4908: ctx->pc = 0; goto label_1f4908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4900: 0x1440000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F492C; return;
    }
label_1f4908:
    // 0x1f4908: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f490c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f4910: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1f4914: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4918: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f491c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4920: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x1f4928);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1120));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1f4928
// Address: 0x1f4928 - 0x1f4934

void entry_1f4928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4928) {
        switch (ctx->pc) {
            case 0x1f492c: ctx->pc = 0; goto label_1f492c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4928: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f492c:
    // 0x1f492c: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4934);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4934
// Address: 0x1f4934 - 0x1f4974

void entry_1f4934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4934) {
        switch (ctx->pc) {
            case 0x1f4940: ctx->pc = 0; goto label_1f4940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4934: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f4938: 0x1840001a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F49A4; return;
    }
label_1f4940:
    // 0x1f4940: 0x8e430314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 788)));
    // 0x1f4944: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1f4948: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f494c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4950: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f4954: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1f4958: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1f495c: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f4960: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4964: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4968: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f496c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1f4974);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1f4974
// Address: 0x1f4974 - 0x1f4984

void entry_1f4974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4974: 0x56800006
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x1F4990; return;
    }
    // 0x1f497c: 0xc04b26a
    SET_GPR_U32(ctx, 31, 0x1f4984);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FWipingAseg__FP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1f4984
// Address: 0x1f4984 - 0x1f4a10

void entry_1f4984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4984) {
        switch (ctx->pc) {
            case 0x1f4990: ctx->pc = 0; goto label_1f4990;
            case 0x1f4994: ctx->pc = 0; goto label_1f4994;
            case 0x1f49a4: ctx->pc = 0; goto label_1f49a4;
            case 0x1f49d0: ctx->pc = 0; goto label_1f49d0;
            case 0x1f49f4: ctx->pc = 0; goto label_1f49f4;
            case 0x1f49f8: ctx->pc = 0; goto label_1f49f8;
            case 0x1f4a00: ctx->pc = 0; goto label_1f4a00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4984: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
        goto label_1f4994;
    }
    // 0x1f498c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
label_1f4990:
    // 0x1f4990: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
label_1f4994:
    // 0x1f4994: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f4998: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1f499c: 0x1440ffe8
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4940; return;
    }
label_1f49a4:
    // 0x1f49a4: 0x56800016
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        goto label_1f4a00;
    }
    // 0x1f49ac: 0xc6410324
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 804)); ctx->f[1] = *(float*)&val; }
    // 0x1f49b0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1f49b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f49b8: 0x0
    // NOP
    // 0x1f49bc: 0x45000004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1f49d0;
    }
    // 0x1f49c4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1f49c8: 0x1000000b
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f49f8;
    }
label_1f49d0:
    // 0x1f49d0: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1f49d4: 0x18400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1f49f4;
    }
    // 0x1f49dc: 0x8e440314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 788)));
    // 0x1f49e0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1f49e4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f49e8: 0xc4610034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1f49ec: 0x10000002
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f49f8;
    }
label_1f49f4:
    // 0x1f49f4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
label_1f49f8:
    // 0x1f49f8: 0xe640031c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 796), *(uint32_t*)&val); }
    // 0x1f49fc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f4a00:
    // 0x1f4a00: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f4a04: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4a08: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1f4a10);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1f4a10
// Address: 0x1f4a10 - 0x1f4a30

void entry_1f4a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4a10) {
        switch (ctx->pc) {
            case 0x1f4a14: ctx->pc = 0; goto label_1f4a14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4a10: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1f4a14:
    // 0x1f4a14: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f4a18: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f4a1c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f4a20: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4a24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4a28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: WipeExit__FP4EXIT
// Address: 0x1f4a30 - 0x1f4a6c

void entry_1f4a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4a6c: 0xc058214
    SET_GPR_U32(ctx, 31, 0x1f4a74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    GrflsFromWid__F3WID(rdram, ctx, runtime); return;
}


// Function: entry_1f4a74
// Address: 0x1f4a74 - 0x1f4acc

void entry_1f4a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4a74) {
        switch (ctx->pc) {
            case 0x1f4a7c: ctx->pc = 0; goto label_1f4a7c;
            case 0x1f4a88: ctx->pc = 0; goto label_1f4a88;
            case 0x1f4a8c: ctx->pc = 0; goto label_1f4a8c;
            case 0x1f4aa0: ctx->pc = 0; goto label_1f4aa0;
            case 0x1f4aa4: ctx->pc = 0; goto label_1f4aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4a74: 0x10000004
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f4a88;
    }
label_1f4a7c:
    // 0x1f4a7c: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1f4a80: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f4a84: 0x41043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 4), 1));
label_1f4a88:
    // 0x1f4a88: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
label_1f4a8c:
    // 0x1f4a8c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 764)));
        goto label_1f4aa0;
    }
    // 0x1f4a94: 0x8e020308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 776)));
    // 0x1f4a98: 0x10000002
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 780)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f4aa4;
    }
label_1f4aa0:
    // 0x1f4aa0: 0x8e030300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 768)));
label_1f4aa4:
    // 0x1f4aa4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1f4aa8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1f4aac: 0x8e060318
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 792)));
    // 0x1f4ab0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f4ab4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f4ab8: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1f4abc: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x1f4ac0: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x1f4ac4: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x1f4acc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_1f4acc
// Address: 0x1f4acc - 0x1f4ae0

void entry_1f4acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4acc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f4ad0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f4ad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4adc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4ae0; return;
}


// Function: UpdateExit__FfP4EXIT
// Address: 0x1f4ae0 - 0x1f4b00

void entry_1f4b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4b00: 0x8e4302e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 740)));
    // 0x1f4b04: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x1f4b08: 0x104000bc
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f4dfc(rdram, ctx, runtime); return;
    }
    // 0x1f4b10: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1f4b14: 0x2442e860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961248));
    // 0x1f4b18: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f4b1c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f4b20: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1f4b28: 0xc641031c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 796)); ctx->f[1] = *(float*)&val; }
    // 0x1f4b2c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1f4b30: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f4b34: 0x0
    // NOP
    // 0x1f4b38: 0x450000b0
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1f4dfc(rdram, ctx, runtime); return;
    }
    // 0x1f4b40: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1f4b44: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f4b48: 0x0
    // NOP
    // 0x1f4b4c: 0x450000ac
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1F4E00; return;
    }
    // 0x1f4b54: 0xc07d28c
    SET_GPR_U32(ctx, 31, 0x1f4b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    WipeExit__FP4EXIT(rdram, ctx, runtime); return;
}


// Function: entry_1f4b5c
// Address: 0x1f4b5c - 0x1f4bc8

void entry_1f4b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4b5c) {
        switch (ctx->pc) {
            case 0x1f4bb4: ctx->pc = 0; goto label_1f4bb4;
            case 0x1f4bb8: ctx->pc = 0; goto label_1f4bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4b5c: 0x100000a7
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 796), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f4dfc(rdram, ctx, runtime); return;
    }
    // 0x1f4b64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f4b68: 0x8c43fa64
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294965860)));
    // 0x1f4b6c: 0x14600026
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_1f4c08(rdram, ctx, runtime); return;
    }
    // 0x1f4b74: 0x8c4301c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 452)));
    // 0x1f4b78: 0x1460000f
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1f4bb8;
    }
    // 0x1f4b80: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f4b84: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4b88: 0x244501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 504));
    // 0x1f4b8c: 0x8ca40260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 608)));
    // 0x1f4b90: 0x10830008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1f4bb4;
    }
    // 0x1f4b98: 0x10820006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1f4bb4;
    }
    // 0x1f4ba0: 0x1482000b
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F4BD0; return;
    }
    // 0x1f4ba8: 0x80a20008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1f4bac: 0x10400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4BD0; return;
    }
label_1f4bb4:
    // 0x1f4bb4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_1f4bb8:
    // 0x1f4bb8: 0x8c83f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294963512)));
    // 0x1f4bbc: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1f4bc0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f4bc8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294963512));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f4bc8
// Address: 0x1f4bc8 - 0x1f4be0

void entry_1f4bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4bc8) {
        switch (ctx->pc) {
            case 0x1f4bd0: ctx->pc = 0; goto label_1f4bd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4bc8: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f4c08(rdram, ctx, runtime); return;
    }
label_1f4bd0:
    // 0x1f4bd0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f4bd4: 0x2630f138
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294963512));
    // 0x1f4bd8: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1f4be0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1f4be0
// Address: 0x1f4be0 - 0x1f4be8

void entry_1f4be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4be0: 0xc058068
    SET_GPR_U32(ctx, 31, 0x1f4be8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 764)));
    FFindLevel(rdram, ctx, runtime); return;
}


// Function: entry_1f4be8
// Address: 0x1f4be8 - 0x1f4bf4

void entry_1f4be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4be8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4bec: 0xc06b422
    SET_GPR_U32(ctx, 31, 0x1f4bf4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    render_level_info_from_id(rdram, ctx, runtime); return;
}


// Function: entry_1f4bf4
// Address: 0x1f4bf4 - 0x1f4c08

void entry_1f4bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4bf4: 0x8e23f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294963512)));
    // 0x1f4bf8: 0xae000464
    WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 0));
    // 0x1f4bfc: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1f4c00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f4c08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f4c08
// Address: 0x1f4c08 - 0x1f4c10

void entry_1f4c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4c08: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1f4c10);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1f4c10
// Address: 0x1f4c10 - 0x1f4c28

void entry_1f4c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4c10: 0x1040007a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f4dfc(rdram, ctx, runtime); return;
    }
    // 0x1f4c18: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f4c1c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4c20: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1f4c28);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1f4c28
// Address: 0x1f4c28 - 0x1f4c34

void entry_1f4c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4c28: 0x8e4402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 760)));
    // 0x1f4c2c: 0xc079370
    SET_GPR_U32(ctx, 31, 0x1f4c34);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1f4c34
// Address: 0x1f4c34 - 0x1f4d6c

void entry_1f4c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4c34) {
        switch (ctx->pc) {
            case 0x1f4c9c: ctx->pc = 0; goto label_1f4c9c;
            case 0x1f4cc4: ctx->pc = 0; goto label_1f4cc4;
            case 0x1f4cdc: ctx->pc = 0; goto label_1f4cdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4c34: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4c38: 0x14800018
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1f4c9c;
    }
    // 0x1f4c40: 0x8e4202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 732)));
    // 0x1f4c44: 0x10400015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f4c9c;
    }
    // 0x1f4c4c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1f4c50: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f4c54: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1f4c58: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f4c5c: 0x0
    // NOP
    // 0x1f4c60: 0x4500000e
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1f4c9c;
    }
    // 0x1f4c68: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f4c6c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f4c70: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x1f4c74: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1f4c78: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f4c7c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f4c80: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1f4c84: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f4c88: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1f4c8c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f4c90: 0x0
    // NOP
    // 0x1f4c94: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1f4c9c;
    }
label_1f4c9c:
    // 0x1f4c9c: 0x8e4302e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 740)));
    // 0x1f4ca0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4ca4: 0x1062003d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F4D9C; return;
    }
    // 0x1f4cac: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
        goto label_1f4cc4;
    }
    // 0x1f4cb4: 0x1060004c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4DE8; return;
    }
    // 0x1f4cbc: 0x10000051
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E04; return;
    }
label_1f4cc4:
    // 0x1f4cc4: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f4cdc;
    }
    // 0x1f4ccc: 0x10620029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F4D74; return;
    }
    // 0x1f4cd4: 0x1000004b
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E04; return;
    }
label_1f4cdc:
    // 0x1f4cdc: 0x14800027
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4D7C; return;
    }
    // 0x1f4ce4: 0x10a00045
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1f4dfc(rdram, ctx, runtime); return;
    }
    // 0x1f4cec: 0x8c43f388
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294964104)));
    // 0x1f4cf0: 0x14600043
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
    // 0x1f4cf8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f4cfc: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1f4d00: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1f4d04: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1f4d08: 0x4be00193
    // Unhandled VU0 Special1 function: 0x13
    // 0x1f4d0c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1f4d10: 0xd8610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1f4d14: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1f4d18: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1f4d1c: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1f4d20: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f4d24: 0xd8640070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1f4d28: 0xd8630050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1f4d2c: 0xd8610060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 96)));
    // 0x1f4d30: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1f4d34: 0x4be208bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1f4d38: 0x4be220be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1f4d3c: 0x4be530fc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1f4d40: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f4d44: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f4d48: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f4d4c: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f4d50: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x1f4d54: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x1f4d58: 0x5440002a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
        ctx->pc = 0x1F4E04; return;
    }
    // 0x1f4d60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4d64: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4d6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4d6c
// Address: 0x1f4d6c - 0x1f4d84

void entry_1f4d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4d6c) {
        switch (ctx->pc) {
            case 0x1f4d74: ctx->pc = 0; goto label_1f4d74;
            case 0x1f4d7c: ctx->pc = 0; goto label_1f4d7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4d6c: 0x10000024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
label_1f4d74:
    // 0x1f4d74: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4D8C; return;
    }
label_1f4d7c:
    // 0x1f4d7c: 0xc07d202
    SET_GPR_U32(ctx, 31, 0x1f4d84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TriggerExit__FP4EXIT(rdram, ctx, runtime); return;
}


// Function: entry_1f4d84
// Address: 0x1f4d84 - 0x1f4dac

void entry_1f4d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4d84) {
        switch (ctx->pc) {
            case 0x1f4d8c: ctx->pc = 0; goto label_1f4d8c;
            case 0x1f4d9c: ctx->pc = 0; goto label_1f4d9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4d84: 0x1000001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
label_1f4d8c:
    // 0x1f4d8c: 0x14a0001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
    // 0x1f4d94: 0x10000010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4DD8; return;
    }
label_1f4d9c:
    // 0x1f4d9c: 0x10800005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4DB4; return;
    }
    // 0x1f4da4: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4dac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4dac
// Address: 0x1f4dac - 0x1f4de0

void entry_1f4dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4dac) {
        switch (ctx->pc) {
            case 0x1f4db4: ctx->pc = 0; goto label_1f4db4;
            case 0x1f4dd8: ctx->pc = 0; goto label_1f4dd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4dac: 0x10000014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
label_1f4db4:
    // 0x1f4db4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1f4db8: 0xc64202e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 744)); ctx->f[2] = *(float*)&val; }
    // 0x1f4dbc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1f4dc0: 0xc6410320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 800)); ctx->f[1] = *(float*)&val; }
    // 0x1f4dc4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1f4dc8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f4dcc: 0x0
    // NOP
    // 0x1f4dd0: 0x4500000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1F4E00; return;
    }
label_1f4dd8:
    // 0x1f4dd8: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4de0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4de0
// Address: 0x1f4de0 - 0x1f4dfc

void entry_1f4de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4de0) {
        switch (ctx->pc) {
            case 0x1f4de8: ctx->pc = 0; goto label_1f4de8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4de0: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4E00; return;
    }
label_1f4de8:
    // 0x1f4de8: 0x54800006
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
        ctx->pc = 0x1F4E04; return;
    }
    // 0x1f4df0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f4df4: 0xc07d1d8
    SET_GPR_U32(ctx, 31, 0x1f4dfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetExitExits__FP4EXIT5EXITS(rdram, ctx, runtime); return;
}


// Function: entry_1f4dfc
// Address: 0x1f4dfc - 0x1f4e18

void entry_1f4dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4dfc) {
        switch (ctx->pc) {
            case 0x1f4e00: ctx->pc = 0; goto label_1f4e00;
            case 0x1f4e04: ctx->pc = 0; goto label_1f4e04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4dfc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1f4e00:
    // 0x1f4e00: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1f4e04:
    // 0x1f4e04: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f4e08: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f4e0c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1f4e10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitCamera__FP6CAMERA
// Address: 0x1f4e18 - 0x1f4e2c

void entry_1f4e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4e2c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f4e30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4e34: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x1f4e38: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4e3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4e44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4e48; return;
}


// Function: PostCameraLoad__FP6CAMERA
// Address: 0x1f4e48 - 0x1f4e60

void entry_1f4e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4e60: 0x8e2602d0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x1f4e64: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f4e68: 0x10c20014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F4EBC; return;
    }
    // 0x1f4e70: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1f4e74: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1f4e78: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1f4e80);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f4e80
// Address: 0x1f4e80 - 0x1f4eb0

void entry_1f4e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4e80) {
        switch (ctx->pc) {
            case 0x1f4ea8: ctx->pc = 0; goto label_1f4ea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4e80: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f4e84: 0x1200000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4EBC; return;
    }
    // 0x1f4e8c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f4e90: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1f4e94: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1f4e98: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f4ea8;
    }
    // 0x1f4ea0: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 17), 728), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F4EBC; return;
    }
label_1f4ea8:
    // 0x1f4ea8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f4eb0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f4eb0
// Address: 0x1f4eb0 - 0x1f4ed0

void entry_1f4eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4eb0) {
        switch (ctx->pc) {
            case 0x1f4eb8: ctx->pc = 0; goto label_1f4eb8;
            case 0x1f4ebc: ctx->pc = 0; goto label_1f4ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4eb0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 724), GPR_U32(ctx, 16));
        goto label_1f4eb8;
    }
label_1f4eb8:
    // 0x1f4eb8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1f4ebc:
    // 0x1f4ebc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4ec0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4ed0; return;
}


// Function: EnableCamera__FP6CAMERA
// Address: 0x1f4ed0 - 0x1f4f08

void entry_1f4f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4f08) {
        switch (ctx->pc) {
            case 0x1f4f14: ctx->pc = 0; goto label_1f4f14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4f08: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4f0c: 0xae020310
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 2));
    // 0x1f4f10: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1f4f14:
    // 0x1f4f14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4f18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableCamera__FP6CAMERA
// Address: 0x1f4f20 - 0x1f4f58

void entry_1f4f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f4f58) {
        switch (ctx->pc) {
            case 0x1f4f5c: ctx->pc = 0; goto label_1f4f5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f4f58: 0xae000310
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 0));
label_1f4f5c:
    // 0x1f4f5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4f60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4f64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4f6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4f70; return;
}


// Function: InitTzp__FP3TZP
// Address: 0x1f4f70 - 0x1f4f84

void entry_1f4f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4f84: 0x26040550
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1360));
    // 0x1f4f88: 0xc07d564
    SET_GPR_U32(ctx, 31, 0x1f4f90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpd__FP3ZPDP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1f4f90
// Address: 0x1f4f90 - 0x1f4fd8

void entry_1f4f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4f90: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1f4f94: 0x2404ff0f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967055));
    // 0x1f4f98: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1f4f9c: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1f4fa0: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1f4fa4: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1f4fa8: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f4fac: 0x52db8
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 22);
    // 0x1f4fb0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f4fb4: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f4fb8: 0xae0304e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1248), GPR_U32(ctx, 3));
    // 0x1f4fbc: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1f4fc0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4fc4: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x1f4fc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4fcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f4fd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f4fd8; return;
}


// Function: PostTzpLoad__FP3TZP
// Address: 0x1f4fd8 - 0x1f4fec

void entry_1f4fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4fec: 0xc07d56a
    SET_GPR_U32(ctx, 31, 0x1f4ff4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1360));
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime); return;
}


// Function: entry_1f4ff4
// Address: 0x1f4ff4 - 0x1f5008

void entry_1f4ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f4ff4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f4ff8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f4ffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f5004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f5008; return;
}


// Function: UpdateTzp__FP3TZPf
// Address: 0x1f5008 - 0x1f503c

void entry_1f503c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f503c) {
        switch (ctx->pc) {
            case 0x1f5058: ctx->pc = 0; goto label_1f5058;
            case 0x1f5070: ctx->pc = 0; goto label_1f5070;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f503c: 0xae600850
    WRITE32(ADD32(GPR_U32(ctx, 19), 2128), GPR_U32(ctx, 0));
    // 0x1f5040: 0x8e750050
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 19), 80)));
    // 0x1f5044: 0x8ea20480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 1152)));
    // 0x1f5048: 0x8c540000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f504c: 0x12800030
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5110; return;
    }
    // 0x1f5054: 0x8e910000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 20), 0)));
label_1f5058:
    // 0x1f5058: 0x5220002a
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 4)));
        ctx->pc = 0x1F5104; return;
    }
    // 0x1f5060: 0x241e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f5064: 0x24170003
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f5068: 0x24160030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f506c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1f5070:
    // 0x1f5070: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f5074: 0x2a31826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 21), GPR_U32(ctx, 3)));
    // 0x1f5078: 0x3802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1f507c: 0x101180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 6));
    // 0x1f5080: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f5084: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x1f508c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f508c
// Address: 0x1f508c - 0x1f50ac

void entry_1f508c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f508c: 0x10400019
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 30), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F50F4; return;
    }
    // 0x1f5094: 0x24050041
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    // 0x1f5098: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1f509c: 0x2229021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f50a0: 0x8e500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1f50a4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f50ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f50ac
// Address: 0x1f50ac - 0x1f5120

void entry_1f50ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f50ac) {
        switch (ctx->pc) {
            case 0x1f50f4: ctx->pc = 0; goto label_1f50f4;
            case 0x1f50f8: ctx->pc = 0; goto label_1f50f8;
            case 0x1f5104: ctx->pc = 0; goto label_1f5104;
            case 0x1f5110: ctx->pc = 0; goto label_1f5110;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f50ac: 0x50400012
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        goto label_1f50f8;
    }
    // 0x1f50b4: 0x8e630850
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2128)));
    // 0x1f50b8: 0x2c62000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 10));
    // 0x1f50bc: 0x1040000d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f50f4;
    }
    // 0x1f50c4: 0x8ce20550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 1360)));
    // 0x1f50c8: 0x1057000a
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 23)) {
        goto label_1f50f4;
    }
    // 0x1f50d0: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f50d4: 0xae620850
    WRITE32(ADD32(GPR_U32(ctx, 19), 2128), GPR_U32(ctx, 2));
    // 0x1f50d8: 0x24840670
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1648));
    // 0x1f50dc: 0x2642021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 4)));
    // 0x1f50e0: 0xac870000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 7));
    // 0x1f50e4: 0x7a420010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1f50e8: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1f50ec: 0x7a230080
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1f50f0: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
label_1f50f4:
    // 0x1f50f4: 0x8e3100d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
label_1f50f8:
    // 0x1f50f8: 0x5620ffdd
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1F5070; return;
    }
    // 0x1f5100: 0x8e940004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 4)));
label_1f5104:
    // 0x1f5104: 0x5680ffd4
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x1F5058; return;
    }
    // 0x1f510c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1f5110:
    // 0x1f5110: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5114: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f5118: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1f5120);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1f5120
// Address: 0x1f5120 - 0x1f5160

void entry_1f5120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5120) {
        switch (ctx->pc) {
            case 0x1f5130: ctx->pc = 0; goto label_1f5130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5120: 0x8e630850
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2128)));
    // 0x1f5124: 0x18600012
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1648));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1F5170; return;
    }
    // 0x1f512c: 0x8e070000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1f5130:
    // 0x1f5130: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f5134: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x1f5138: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f513c: 0xafa70004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 7));
    // 0x1f5140: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5144: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f5148: 0x26100030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
    // 0x1f514c: 0x78e20140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 320)));
    // 0x1f5150: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1f5154: 0x78e30150
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 336)));
    // 0x1f5158: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1f5160);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1f5160
// Address: 0x1f5160 - 0x1f51a0

void entry_1f5160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5160) {
        switch (ctx->pc) {
            case 0x1f5170: ctx->pc = 0; goto label_1f5170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5160: 0x8e630850
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2128)));
    // 0x1f5164: 0x223182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 3)));
    // 0x1f5168: 0x5460fff1
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F5130; return;
    }
label_1f5170:
    // 0x1f5170: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f5174: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f5178: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f517c: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f5180: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f5184: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f5188: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f518c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f5190: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f5194: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f5198: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneTzp__FP3TZPT0
// Address: 0x1f51a0 - 0x1f51b4

void entry_1f51b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f51b4: 0xae100550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 16));
    // 0x1f51b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f51bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f51c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderTzpAll__FP3TZPP2CMP2RO
// Address: 0x1f51c8 - 0x1f51d8

void entry_1f51d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f51d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f51dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f51e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f51e8; return;
}


// Function: FInflictTzpZap__FP3TZPP2XPP3ZPR
// Address: 0x1f51e8 - 0x1f51f8

void entry_1f51f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f51f8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f51fc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f5200: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PzpdEnsureTzp__FP3TZP4ENSK
// Address: 0x1f5208 - 0x1f5210

void FUN_001F5210__FP3TZP(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5210: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1508), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitVolzp__FP5VOLZP
// Address: 0x1f5218 - 0x1f522c

void entry_1f522c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f522c: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1f5230: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f5234: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1f5238: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f523c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f5240: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f5244: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5248: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x1f524c: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f5250: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1f5258);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1f5258
// Address: 0x1f5258 - 0x1f5268

void entry_1f5258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5258: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f525c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5260: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateVolzp__FP5VOLZPf
// Address: 0x1f5268 - 0x1f5284

void entry_1f5284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5284: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1f528c);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1f528c
// Address: 0x1f528c - 0x1f52c0

void entry_1f528c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f528c) {
        switch (ctx->pc) {
            case 0x1f52ac: ctx->pc = 0; goto label_1f52ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f528c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f5290: 0x124000b9
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1f5578(rdram, ctx, runtime); return;
    }
    // 0x1f5298: 0x8e2304e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1248)));
    // 0x1f529c: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1f52ac;
    }
    // 0x1f52a4: 0x146200b5
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F557C; return;
    }
label_1f52ac:
    // 0x1f52ac: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f52b0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f52b4: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x1f52b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f52c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f52c0
// Address: 0x1f52c0 - 0x1f5350

void entry_1f52c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f52c0) {
        switch (ctx->pc) {
            case 0x1f5314: ctx->pc = 0; goto label_1f5314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f52c0: 0x144000ae
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F557C; return;
    }
    // 0x1f52c8: 0xc62203cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[2] = *(float*)&val; }
    // 0x1f52cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f52d0: 0xc64103cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 972)); ctx->f[1] = *(float*)&val; }
    // 0x1f52d4: 0x26500140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1f52d8: 0xda230140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1f52dc: 0x46011040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1f52e0: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1f52e4: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1f52e8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f52ec: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f52f0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f52f4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f52f8: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1f52fc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f5300: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1f5304: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f5308: 0x0
    // NOP
    // 0x1f530c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1f5314;
    }
label_1f5314:
    // 0x1f5314: 0x14400099
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F557C; return;
    }
    // 0x1f531c: 0x8e230554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    // 0x1f5320: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f5324: 0x1462003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 160), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F5418; return;
    }
    // 0x1f532c: 0xc6410158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 344)); ctx->f[1] = *(float*)&val; }
    // 0x1f5330: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1f5334: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f5338: 0x0
    // NOP
    // 0x1f533c: 0x45030090
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
        ctx->pc = 0x1F5580; return;
    }
    // 0x1f5344: 0x8e2503f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f5348: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x1f5350);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_1f5350
// Address: 0x1f5350 - 0x1f5390

void entry_1f5350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5350: 0x1040008a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F557C; return;
    }
    // 0x1f5358: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1f535c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f5360: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1f5364: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f5368: 0x1040000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F53A0; return;
    }
    // 0x1f5370: 0xc64c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1f5374: 0x8e2503f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1012)));
    // 0x1f5378: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f537c: 0x8e2603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f5380: 0x262803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 932));
    // 0x1f5384: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f5388: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x1f5390);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_1f5390
// Address: 0x1f5390 - 0x1f53e8

void entry_1f5390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5390) {
        switch (ctx->pc) {
            case 0x1f53a0: ctx->pc = 0; goto label_1f53a0;
            case 0x1f53b0: ctx->pc = 0; goto label_1f53b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5390: 0x1c40007a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1F557C; return;
    }
    // 0x1f5398: 0x10000068
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F553C; return;
    }
label_1f53a0:
    // 0x1f53a0: 0x8e4203b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 952)));
    // 0x1f53a4: 0x18400064
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F5538; return;
    }
    // 0x1f53ac: 0x8e4203bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 956)));
label_1f53b0:
    // 0x1f53b0: 0x101900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 4));
    // 0x1f53b4: 0x8e4a03ac
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 940)));
    // 0x1f53b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f53bc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f53c0: 0x8e2403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f53c4: 0x84460002
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 2)));
    // 0x1f53c8: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f53cc: 0x84450000
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f53d0: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f53d4: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1f53d8: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x1f53dc: 0x1463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 6)));
    // 0x1f53e0: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1f53e8);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 5)));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1f53e8
// Address: 0x1f53e8 - 0x1f5480

void entry_1f53e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f53e8) {
        switch (ctx->pc) {
            case 0x1f5418: ctx->pc = 0; goto label_1f5418;
            case 0x1f5474: ctx->pc = 0; goto label_1f5474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f53e8: 0x10400063
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f5578(rdram, ctx, runtime); return;
    }
    // 0x1f53f0: 0x14400061
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1f5578(rdram, ctx, runtime); return;
    }
    // 0x1f53f8: 0x1440005f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1f5578(rdram, ctx, runtime); return;
    }
    // 0x1f5400: 0x8e4203b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 952)));
    // 0x1f5404: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1f5408: 0x5440ffe9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 956)));
        ctx->pc = 0x1F53B0; return;
    }
    // 0x1f5410: 0x1000004a
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F553C; return;
    }
label_1f5418:
    // 0x1f5418: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1f541c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f5420: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1f5424: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f5428: 0x10400012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f5474;
    }
    // 0x1f5430: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1f5434: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f5438: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f543c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1f5440: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f5444: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1f5448: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1f544c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1f5450: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1f5454: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1f5458: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1f545c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f5460: 0x0
    // NOP
    // 0x1f5464: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        entry_1f5480(rdram, ctx, runtime); return;
    }
    // 0x1f546c: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f5480(rdram, ctx, runtime); return;
    }
label_1f5474:
    // 0x1f5474: 0x8e2503f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f5478: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x1f5480);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_1f5480
// Address: 0x1f5480 - 0x1f54b8

void entry_1f5480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5480: 0x5440002e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
        ctx->pc = 0x1F553C; return;
    }
    // 0x1f5488: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1f548c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1f5490: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1f5494: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f5498: 0x1040000f
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F54D8; return;
    }
    // 0x1f54a0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f54a4: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F54C0; return;
    }
    // 0x1f54ac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f54b0: 0xc061ea2
    SET_GPR_U32(ctx, 31, 0x1f54b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    MarkSoContactsSphereSphere__FP2SOT0PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1f54b8
// Address: 0x1f54b8 - 0x1f5504

void entry_1f54b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f54b8) {
        switch (ctx->pc) {
            case 0x1f54c0: ctx->pc = 0; goto label_1f54c0;
            case 0x1f54d8: ctx->pc = 0; goto label_1f54d8;
            case 0x1f54f8: ctx->pc = 0; goto label_1f54f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f54b8: 0x1000001d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5530; return;
    }
label_1f54c0:
    // 0x1f54c0: 0xc64c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1f54c4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f54c8: 0x8e2703f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1012)));
    // 0x1f54cc: 0x8e2803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f54d0: 0x10000009
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f54f8;
    }
label_1f54d8:
    // 0x1f54d8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f54dc: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F550C; return;
    }
    // 0x1f54e4: 0xc62c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1f54e8: 0x8e4703f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 1012)));
    // 0x1f54ec: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1f54f0: 0x8e4803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    // 0x1f54f4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f54f8:
    // 0x1f54f8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f54fc: 0xc061e70
    SET_GPR_U32(ctx, 31, 0x1f5504);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 160));
    MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1f5504
// Address: 0x1f5504 - 0x1f552c

void entry_1f5504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5504) {
        switch (ctx->pc) {
            case 0x1f550c: ctx->pc = 0; goto label_1f550c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5504: 0x1000000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5530; return;
    }
label_1f550c:
    // 0x1f550c: 0x8e2703f8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1f5510: 0x10e00006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_1f552c(rdram, ctx, runtime); return;
    }
    // 0x1f5518: 0x8e2603f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1012)));
    // 0x1f551c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f5520: 0xe0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1f5524: 0xc061aea
    SET_GPR_U32(ctx, 31, 0x1f552c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 160));
    MarkSoContactsBspBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1f552c
// Address: 0x1f552c - 0x1f5548

void entry_1f552c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f552c) {
        switch (ctx->pc) {
            case 0x1f5530: ctx->pc = 0; goto label_1f5530;
            case 0x1f5538: ctx->pc = 0; goto label_1f5538;
            case 0x1f553c: ctx->pc = 0; goto label_1f553c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f552c: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
label_1f5530:
    // 0x1f5530: 0x10400012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F557C; return;
    }
label_1f5538:
    // 0x1f5538: 0x8e250554
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
label_1f553c:
    // 0x1f553c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f5540: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1f5548);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f5548
// Address: 0x1f5548 - 0x1f5558

void entry_1f5548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5548: 0x8fa500a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f554c: 0x26240550
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1360));
    // 0x1f5550: 0xc07d5f8
    SET_GPR_U32(ctx, 31, 0x1f5558);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    InflictZpdZap__FP3ZPDP2XPP3ZPR(rdram, ctx, runtime); return;
}


// Function: entry_1f5558
// Address: 0x1f5558 - 0x1f556c

void entry_1f5558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5558: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f555c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f5560: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1f5564: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f556c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f556c
// Address: 0x1f556c - 0x1f5578

void entry_1f556c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f556c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1f5570: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1f5578);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1f5578
// Address: 0x1f5578 - 0x1f5590

void entry_1f5578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5578) {
        switch (ctx->pc) {
            case 0x1f557c: ctx->pc = 0; goto label_1f557c;
            case 0x1f5580: ctx->pc = 0; goto label_1f5580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5578: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1f557c:
    // 0x1f557c: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1f5580:
    // 0x1f5580: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f5584: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f5588: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitZpd__FP3ZPDP2SO
// Address: 0x1f5590 - 0x1f55a8

void entry_1f568c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f568c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f5690: 0x50a00004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x1F56A4; return;
    }
    // 0x1f5698: 0xc07d61a
    SET_GPR_U32(ctx, 31, 0x1f56a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddZpdZapLo__FP3ZPDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1f56a0
// Address: 0x1f56a0 - 0x1f56d8

void entry_1f56a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f56a0) {
        switch (ctx->pc) {
            case 0x1f56a4: ctx->pc = 0; goto label_1f56a4;
            case 0x1f56b4: ctx->pc = 0; goto label_1f56b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f56a0: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_1f56a4:
    // 0x1f56a4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1f56a8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1f56ac: 0x1440fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5678; return;
    }
label_1f56b4:
    // 0x1f56b4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1f56b8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f56bc: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x1f56c0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f56c4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f56c8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f56cc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f56d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyZpdThrow__FP3ZPDP2PO
// Address: 0x1f56d8 - 0x1f5708

void entry_1f5708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5708: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1f570c: 0x1040002a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F57B8; return;
    }
    // 0x1f5714: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1f5718: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f571c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5720: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5724: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5728: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x1f5730);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_1f5730
// Address: 0x1f5730 - 0x1f5744

void entry_1f5730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5730: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f5734: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5738: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1f573c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f5744);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f5744
// Address: 0x1f5744 - 0x1f5760

void entry_1f5744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5744: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f5748: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1f574c: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1f5750: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f5754: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1f5758: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f5760);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f5760
// Address: 0x1f5760 - 0x1f5774

void entry_1f5760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5760: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f5764: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5768: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1f576c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f5774);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f5774
// Address: 0x1f5774 - 0x1f578c

void entry_1f5774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5774: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f5778: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1f577c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1f5780: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5784: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1f578c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1f578c
// Address: 0x1f578c - 0x1f57a0

void entry_1f578c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f578c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f5790: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5794: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1f5798: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f57a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f57a0
// Address: 0x1f57a0 - 0x1f57b0

void entry_1f57a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f57a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f57a4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f57a8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1f57b0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1f57b0
// Address: 0x1f57b0 - 0x1f57c8

void entry_1f57b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f57b0) {
        switch (ctx->pc) {
            case 0x1f57b8: ctx->pc = 0; goto label_1f57b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f57b0: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F57CC; return;
    }
label_1f57b8:
    // 0x1f57b8: 0xc7ac0060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[12] = *(float*)&val; }
    // 0x1f57bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f57c0: 0xc05e166
    SET_GPR_U32(ctx, 31, 0x1f57c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_00178598(rdram, ctx, runtime); return;
}


// Function: entry_1f57c8
// Address: 0x1f57c8 - 0x1f57e0

void entry_1f57c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f57c8) {
        switch (ctx->pc) {
            case 0x1f57cc: ctx->pc = 0; goto label_1f57cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f57c8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1f57cc:
    // 0x1f57cc: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f57d0: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f57d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f57dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f57e0; return;
}


// Function: InflictZpdZap__FP3ZPDP2XPP3ZPR
// Address: 0x1f57e0 - 0x1f57fc

void entry_1f57fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f57fc: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1f5800: 0x3c02001f
    SET_GPR_U32(ctx, 2, ((uint32_t)31 << 16));
    // 0x1f5804: 0x244256d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22232));
    // 0x1f5808: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x1f580c: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x1f5810: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f5814: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x1f5818: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f581c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f5820: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1f5828);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1f5828
// Address: 0x1f5828 - 0x1f5840

void entry_1f5828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5828: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f582c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f5830: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5834: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f583c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f5840; return;
}


// Function: AddZpdZapObject__FP3ZPD3OID
// Address: 0x1f5840 - 0x1f5868

void entry_1f5898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5898: 0x5440001b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
        ctx->pc = 0x1F5908; return;
    }
    // 0x1f58a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f58a4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f58ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 110));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f58ac
// Address: 0x1f58ac - 0x1f58c0

void entry_1f58ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f58ac: 0x54400016
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
        ctx->pc = 0x1F5908; return;
    }
    // 0x1f58b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f58b8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f58c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f58c0
// Address: 0x1f58c0 - 0x1f58d4

void entry_1f58c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f58c0: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
        ctx->pc = 0x1F5908; return;
    }
    // 0x1f58c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f58cc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f58d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f58d4
// Address: 0x1f58d4 - 0x1f58e8

void entry_1f58d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f58d4: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
        ctx->pc = 0x1F5908; return;
    }
    // 0x1f58dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f58e0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f58e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 113));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f58e8
// Address: 0x1f58e8 - 0x1f58fc

void entry_1f58e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f58e8: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
        ctx->pc = 0x1F5908; return;
    }
    // 0x1f58f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f58f4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1f58fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 129));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1f58fc
// Address: 0x1f58fc - 0x1f5930

void entry_1f58fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f58fc) {
        switch (ctx->pc) {
            case 0x1f5908: ctx->pc = 0; goto label_1f5908;
            case 0x1f591c: ctx->pc = 0; goto label_1f591c;
            case 0x1f5920: ctx->pc = 0; goto label_1f5920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f58fc: 0x10400008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f5920;
    }
    // 0x1f5904: 0x8e230094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 148)));
label_1f5908:
    // 0x1f5908: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1f590c: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1f5910: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f5914: 0xac500098
    WRITE32(ADD32(GPR_U32(ctx, 2), 152), GPR_U32(ctx, 16));
    // 0x1f5918: 0xae230094
    WRITE32(ADD32(GPR_U32(ctx, 17), 148), GPR_U32(ctx, 3));
label_1f591c:
    // 0x1f591c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1f5920:
    // 0x1f5920: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f5924: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5928: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveZpdZapLo__FP3ZPDP2LO
// Address: 0x1f5930 - 0x1f59a8

void entry_1f59a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f59a8) {
        switch (ctx->pc) {
            case 0x1f59b4: ctx->pc = 0; goto label_1f59b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f59a8: 0x8e020094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 148)));
    // 0x1f59ac: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1f59b0: 0xae020094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 2));
label_1f59b4:
    // 0x1f59b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f59b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f59bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: memcmp
// Address: 0x1f59c4 - 0x1f5a58

void entry_1f5e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5e1c) {
        switch (ctx->pc) {
            case 0x1f5e24: ctx->pc = 0; goto label_1f5e24;
            case 0x1f5e40: ctx->pc = 0; goto label_1f5e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5e1c: 0x1c40ffd6
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1F5D78; return;
    }
label_1f5e24:
    // 0x1f5e24: 0x8fa4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1f5e28: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f5e2c: 0x204102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x1f5e30: 0x1440ffcf
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5D70; return;
    }
    // 0x1f5e38: 0x10000223
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F66C8; return;
    }
label_1f5e40:
    // 0x1f5e40: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5e44: 0x31042
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), 1));
    // 0x1f5e48: 0x532018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f5e4c: 0x2c630008
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1f5e50: 0x14600092
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 22)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F609C; return;
    }
    // 0x1f5e58: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5e5c: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f5e60: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5e64: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1f5e68: 0xafa20038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 2));
    // 0x1f5e6c: 0x2c620029
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 41));
    // 0x1f5e70: 0x8fa30038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x1f5e74: 0x731818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f5e78: 0x14400069
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 22)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6020; return;
    }
    // 0x1f5e80: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f5e84: 0x410c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 4), 3));
    // 0x1f5e88: 0x531818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f5e8c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f5e90: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1f5e94: 0x2c38821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 3)));
    // 0x1f5e98: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1f5e9c: 0x569021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1f5ea0: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x1f5ea4: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5eac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5eac
// Address: 0x1f5eac - 0x1f5ebc

void entry_1f5eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5eac: 0x441000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F5EE4; return;
    }
    // 0x1f5eb4: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5ebc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5ebc
// Address: 0x1f5ebc - 0x1f5ed0

void entry_1f5ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5ebc: 0x4420014
    if (GPR_S32(ctx, 2) < 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F5F10; return;
    }
    // 0x1f5ec4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f5ec8: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5ed0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5ed0
// Address: 0x1f5ed0 - 0x1f5eec

void entry_1f5ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5ed0) {
        switch (ctx->pc) {
            case 0x1f5ee4: ctx->pc = 0; goto label_1f5ee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5ed0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f5ed4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f5ed8: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f5edc: 0x1000000c
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 22));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5F10; return;
    }
label_1f5ee4:
    // 0x1f5ee4: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5eec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5eec
// Address: 0x1f5eec - 0x1f5f00

void entry_1f5eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5eec: 0x5c400008
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F5F10; return;
    }
    // 0x1f5ef4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f5ef8: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f00
// Address: 0x1f5f00 - 0x1f5f2c

void entry_1f5f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5f00) {
        switch (ctx->pc) {
            case 0x1f5f10: ctx->pc = 0; goto label_1f5f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5f00: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f5f04: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f5f08: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f5f0c: 0x243200b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 18));
label_1f5f10:
    // 0x1f5f10: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f5f14: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f5f18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f5f1c: 0x203a023
    SET_GPR_U32(ctx, 20, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1f5f20: 0x2039021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1f5f24: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f2c
// Address: 0x1f5f2c - 0x1f5f3c

void entry_1f5f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5f2c: 0x441000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F5F60; return;
    }
    // 0x1f5f34: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f3c
// Address: 0x1f5f3c - 0x1f5f4c

void entry_1f5f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5f3c: 0x4400014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F5F90; return;
    }
    // 0x1f5f44: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f4c
// Address: 0x1f5f4c - 0x1f5f68

void entry_1f5f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5f4c) {
        switch (ctx->pc) {
            case 0x1f5f60: ctx->pc = 0; goto label_1f5f60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5f4c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f5f50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f5f54: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f5f58: 0x1000000e
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5F94; return;
    }
label_1f5f60:
    // 0x1f5f60: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f68
// Address: 0x1f5f68 - 0x1f5f7c

void entry_1f5f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5f68: 0x5c40000a
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F5F94; return;
    }
    // 0x1f5f70: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f5f74: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5f7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5f7c
// Address: 0x1f5f7c - 0x1f5fb4

void entry_1f5f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5f7c) {
        switch (ctx->pc) {
            case 0x1f5f90: ctx->pc = 0; goto label_1f5f90;
            case 0x1f5f94: ctx->pc = 0; goto label_1f5f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5f7c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f5f80: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f5f84: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f5f88: 0x10000002
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f5f94;
    }
label_1f5f90:
    // 0x1f5f90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f5f94:
    // 0x1f5f94: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1f5f98: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f5f9c: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f5fa0: 0x2a2a023
    SET_GPR_U32(ctx, 20, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x1f5fa4: 0x2a39023
    SET_GPR_U32(ctx, 18, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 3)));
    // 0x1f5fa8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f5fac: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5fb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5fb4
// Address: 0x1f5fb4 - 0x1f5fc4

void entry_1f5fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5fb4: 0x441000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F5FE8; return;
    }
    // 0x1f5fbc: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5fc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5fc4
// Address: 0x1f5fc4 - 0x1f5fd4

void entry_1f5fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5fc4: 0x4400014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F6018; return;
    }
    // 0x1f5fcc: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5fd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5fd4
// Address: 0x1f5fd4 - 0x1f5ff0

void entry_1f5fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f5fd4) {
        switch (ctx->pc) {
            case 0x1f5fe8: ctx->pc = 0; goto label_1f5fe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f5fd4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f5fd8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f5fdc: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f5fe0: 0x1000000e
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F601C; return;
    }
label_1f5fe8:
    // 0x1f5fe8: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f5ff0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f5ff0
// Address: 0x1f5ff0 - 0x1f6004

void entry_1f5ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f5ff0: 0x5c40000a
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F601C; return;
    }
    // 0x1f5ff8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f5ffc: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f6004);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f6004
// Address: 0x1f6004 - 0x1f602c

void entry_1f6004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6004) {
        switch (ctx->pc) {
            case 0x1f6018: ctx->pc = 0; goto label_1f6018;
            case 0x1f601c: ctx->pc = 0; goto label_1f601c;
            case 0x1f6020: ctx->pc = 0; goto label_1f6020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6004: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f6008: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f600c: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f6010: 0x10000002
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f601c;
    }
label_1f6018:
    // 0x1f6018: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f601c:
    // 0x1f601c: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1f6020:
    // 0x1f6020: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f6024: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f602c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f602c
// Address: 0x1f602c - 0x1f603c

void entry_1f602c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f602c: 0x441000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F6060; return;
    }
    // 0x1f6034: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f603c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f603c
// Address: 0x1f603c - 0x1f604c

void entry_1f603c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f603c: 0x4400014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F6090; return;
    }
    // 0x1f6044: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f604c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f604c
// Address: 0x1f604c - 0x1f6068

void entry_1f604c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f604c) {
        switch (ctx->pc) {
            case 0x1f6060: ctx->pc = 0; goto label_1f6060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f604c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f6050: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f6054: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f6058: 0x1000000e
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6094; return;
    }
label_1f6060:
    // 0x1f6060: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f6068);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f6068
// Address: 0x1f6068 - 0x1f607c

void entry_1f6068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6068: 0x5c40000a
    if (GPR_S32(ctx, 2) > 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F6094; return;
    }
    // 0x1f6070: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f6074: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f607c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f607c
// Address: 0x1f607c - 0x1f6308

void entry_1f607c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f607c) {
        switch (ctx->pc) {
            case 0x1f6090: ctx->pc = 0; goto label_1f6090;
            case 0x1f6094: ctx->pc = 0; goto label_1f6094;
            case 0x1f609c: ctx->pc = 0; goto label_1f609c;
            case 0x1f60a8: ctx->pc = 0; goto label_1f60a8;
            case 0x1f60cc: ctx->pc = 0; goto label_1f60cc;
            case 0x1f60f0: ctx->pc = 0; goto label_1f60f0;
            case 0x1f6118: ctx->pc = 0; goto label_1f6118;
            case 0x1f6130: ctx->pc = 0; goto label_1f6130;
            case 0x1f6150: ctx->pc = 0; goto label_1f6150;
            case 0x1f6154: ctx->pc = 0; goto label_1f6154;
            case 0x1f6188: ctx->pc = 0; goto label_1f6188;
            case 0x1f61a0: ctx->pc = 0; goto label_1f61a0;
            case 0x1f61c0: ctx->pc = 0; goto label_1f61c0;
            case 0x1f61e8: ctx->pc = 0; goto label_1f61e8;
            case 0x1f6200: ctx->pc = 0; goto label_1f6200;
            case 0x1f6220: ctx->pc = 0; goto label_1f6220;
            case 0x1f6224: ctx->pc = 0; goto label_1f6224;
            case 0x1f6238: ctx->pc = 0; goto label_1f6238;
            case 0x1f6268: ctx->pc = 0; goto label_1f6268;
            case 0x1f6288: ctx->pc = 0; goto label_1f6288;
            case 0x1f62b0: ctx->pc = 0; goto label_1f62b0;
            case 0x1f62c8: ctx->pc = 0; goto label_1f62c8;
            case 0x1f62e8: ctx->pc = 0; goto label_1f62e8;
            case 0x1f62ec: ctx->pc = 0; goto label_1f62ec;
            case 0x1f62f0: ctx->pc = 0; goto label_1f62f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f607c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f6080: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f6084: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f6088: 0x10000002
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f6094;
    }
label_1f6090:
    // 0x1f6090: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f6094:
    // 0x1f6094: 0x10000004
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f60a8;
    }
label_1f609c:
    // 0x1f609c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f60a0: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1f60a4: 0xafa40038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 4));
label_1f60a8:
    // 0x1f60a8: 0x17c00008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 30), 2));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1f60cc;
    }
    // 0x1f60b0: 0xde030000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f60b4: 0x2d31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 19)));
    // 0x1f60b8: 0xafa2003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
    // 0x1f60bc: 0xdec20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1f60c0: 0xfec30000
    WRITE64(ADD32(GPR_U32(ctx, 22), 0), GPR_U64(ctx, 3));
    // 0x1f60c4: 0x10000022
    WRITE64(ADD32(GPR_U32(ctx, 16), 0), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f6150;
    }
label_1f60cc:
    // 0x1f60cc: 0x10400012
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 19), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f6118;
    }
    // 0x1f60d4: 0x2d31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 19)));
    // 0x1f60d8: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1f60dc: 0xafa3003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 3));
    // 0x1f60e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f60e4: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f60e8: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f60ec: 0x0
    // NOP
label_1f60f0:
    // 0x1f60f0: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f60f4: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f60f8: 0xdcc20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f60fc: 0xfcc30000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 3));
    // 0x1f6100: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x1f6104: 0x24c60008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8));
    // 0x1f6108: 0x1ca0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f60f0;
    }
    // 0x1f6110: 0x10000010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f6154;
    }
label_1f6118:
    // 0x1f6118: 0x13103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) << (32 + 0));
    // 0x1f611c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f6120: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f6124: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f6128: 0x2d31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 19)));
    // 0x1f612c: 0xafa2003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
label_1f6130:
    // 0x1f6130: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f6134: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f6138: 0x80c20000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f613c: 0xa0c30000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f6140: 0xa0820000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f6144: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1f6148: 0x1ca0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f6130;
    }
label_1f6150:
    // 0x1f6150: 0x8fa20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 56)));
label_1f6154:
    // 0x1f6154: 0x2bc30002
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 30), 2));
    // 0x1f6158: 0x8fb2003c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1f615c: 0x13583c
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 19) << (32 + 0));
    // 0x1f6160: 0x531018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f6164: 0xafa3001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 3));
    // 0x1f6168: 0x240a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f616c: 0x56a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1f6170: 0x1310c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 19), 3));
    // 0x1f6174: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f6178: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1f617c: 0x1000005c
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f62f0;
    }
    // 0x1f6184: 0x0
    // NOP
label_1f6188:
    // 0x1f6188: 0x2534021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    // 0x1f618c: 0xde420000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f6190: 0x2333823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    // 0x1f6194: 0xfe430000
    WRITE64(ADD32(GPR_U32(ctx, 18), 0), GPR_U64(ctx, 3));
    // 0x1f6198: 0x10000021
    WRITE64(ADD32(GPR_U32(ctx, 17), 0), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f6220;
    }
label_1f61a0:
    // 0x1f61a0: 0x10800011
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1f61e8;
    }
    // 0x1f61a8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f61ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f61b0: 0xb34021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1f61b4: 0x2303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f61b8: 0x933823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x1f61bc: 0x0
    // NOP
label_1f61c0:
    // 0x1f61c0: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f61c4: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f61c8: 0xdca20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f61cc: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x1f61d0: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x1f61d4: 0x24a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    // 0x1f61d8: 0x1cc0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f61c0;
    }
    // 0x1f61e0: 0x10000010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f6224;
    }
label_1f61e8:
    // 0x1f61e8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f61ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f61f0: 0xb303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) >> (32 + 0));
    // 0x1f61f4: 0xb34021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1f61f8: 0x933823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x1f61fc: 0x0
    // NOP
label_1f6200:
    // 0x1f6200: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f6204: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f6208: 0x80a20000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f620c: 0xa0a30000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f6210: 0xa0820000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f6214: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f6218: 0x1cc0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f6200;
    }
label_1f6220:
    // 0x1f6220: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_1f6224:
    // 0x1f6224: 0x100902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1f6228: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1f622c: 0x10000030
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f62f0;
    }
    // 0x1f6234: 0x0
    // NOP
label_1f6238:
    // 0x1f6238: 0x14a0002c
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1f62ec;
    }
    // 0x1f6240: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f6244: 0x17c00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1f6268;
    }
    // 0x1f624c: 0xde430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f6250: 0x2534021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    // 0x1f6254: 0xdea20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1f6258: 0x2b33821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 19)));
    // 0x1f625c: 0xfea30000
    WRITE64(ADD32(GPR_U32(ctx, 21), 0), GPR_U64(ctx, 3));
    // 0x1f6260: 0x10000021
    WRITE64(ADD32(GPR_U32(ctx, 18), 0), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f62e8;
    }
label_1f6268:
    // 0x1f6268: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1f626c: 0x10400010
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f62b0;
    }
    // 0x1f6274: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f6278: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f627c: 0xb33821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1f6280: 0x3303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) >> (32 + 0));
    // 0x1f6284: 0x934021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
label_1f6288:
    // 0x1f6288: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f628c: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f6290: 0xdca20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f6294: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x1f6298: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x1f629c: 0x24a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    // 0x1f62a0: 0x1cc0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f6288;
    }
    // 0x1f62a8: 0x10000010
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f62ec;
    }
label_1f62b0:
    // 0x1f62b0: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f62b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f62b8: 0xb303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) >> (32 + 0));
    // 0x1f62bc: 0x934021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x1f62c0: 0xb33821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1f62c4: 0x0
    // NOP
label_1f62c8:
    // 0x1f62c8: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f62cc: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f62d0: 0x80a20000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f62d4: 0xa0a30000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f62d8: 0xa0820000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f62dc: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f62e0: 0x1cc0fff9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f62c8;
    }
label_1f62e8:
    // 0x1f62e8: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
label_1f62ec:
    // 0x1f62ec: 0x100902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
label_1f62f0:
    // 0x1f62f0: 0x232802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
    // 0x1f62f4: 0x16000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6314; return;
    }
    // 0x1f62fc: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f6300: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f6308);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 11));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f6308
// Address: 0x1f6308 - 0x1f63f0

void entry_1f6308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6308) {
        switch (ctx->pc) {
            case 0x1f6314: ctx->pc = 0; goto label_1f6314;
            case 0x1f6328: ctx->pc = 0; goto label_1f6328;
            case 0x1f6358: ctx->pc = 0; goto label_1f6358;
            case 0x1f6370: ctx->pc = 0; goto label_1f6370;
            case 0x1f6398: ctx->pc = 0; goto label_1f6398;
            case 0x1f63a8: ctx->pc = 0; goto label_1f63a8;
            case 0x1f63c8: ctx->pc = 0; goto label_1f63c8;
            case 0x1f63cc: ctx->pc = 0; goto label_1f63cc;
            case 0x1f63d4: ctx->pc = 0; goto label_1f63d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6308: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f630c: 0x18a0ffca
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x1F6238; return;
    }
label_1f6314:
    // 0x1f6314: 0x1310c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 19), 3));
    // 0x1f6318: 0x2bca0002
    SET_GPR_U32(ctx, 10, SLT32(GPR_S32(ctx, 30), 2));
    // 0x1f631c: 0x1000002d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) << (32 + 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f63d4;
    }
    // 0x1f6324: 0x0
    // NOP
label_1f6328:
    // 0x1f6328: 0x14a00028
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1f63cc;
    }
    // 0x1f6330: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f6334: 0x17c00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1f6358;
    }
    // 0x1f633c: 0xde830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1f6340: 0x2333823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    // 0x1f6344: 0xde220000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f6348: 0x2934023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 19)));
    // 0x1f634c: 0xfe230000
    WRITE64(ADD32(GPR_U32(ctx, 17), 0), GPR_U64(ctx, 3));
    // 0x1f6350: 0x1000001d
    WRITE64(ADD32(GPR_U32(ctx, 20), 0), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f63c8;
    }
label_1f6358:
    // 0x1f6358: 0x1140000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) == GPR_U32(ctx, 0)) {
        goto label_1f6398;
    }
    // 0x1f6360: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f6364: 0x9303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 9) >> (32 + 0));
    // 0x1f6368: 0x933823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x1f636c: 0xb34023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
label_1f6370:
    // 0x1f6370: 0xdca30000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f6374: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f6378: 0xdc820000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f637c: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x1f6380: 0xfca20000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 2));
    // 0x1f6384: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1f6388: 0x1cc0fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f6370;
    }
    // 0x1f6390: 0x1000000e
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f63cc;
    }
label_1f6398:
    // 0x1f6398: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f639c: 0xb303e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) >> (32 + 0));
    // 0x1f63a0: 0x933823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x1f63a4: 0xb34023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
label_1f63a8:
    // 0x1f63a8: 0x90a30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f63ac: 0x64c6ffff
    SET_GPR_S64(ctx, 6, (int64_t)GPR_S64(ctx, 6) + (int64_t)4294967295);
    // 0x1f63b0: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f63b4: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f63b8: 0xa0a20000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f63bc: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f63c0: 0x1cc0fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_S32(ctx, 6) > 0) {
        goto label_1f63a8;
    }
label_1f63c8:
    // 0x1f63c8: 0x100a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
label_1f63cc:
    // 0x1f63cc: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1f63d0: 0x232802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
label_1f63d4:
    // 0x1f63d4: 0x1600000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6414; return;
    }
    // 0x1f63dc: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f63e0: 0x7fa90040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 9));
    // 0x1f63e4: 0x7faa0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 10));
    // 0x1f63e8: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f63f0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 11));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f63f0
// Address: 0x1f63f0 - 0x1f6504

void entry_1f63f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f63f0) {
        switch (ctx->pc) {
            case 0x1f6414: ctx->pc = 0; goto label_1f6414;
            case 0x1f6458: ctx->pc = 0; goto label_1f6458;
            case 0x1f6460: ctx->pc = 0; goto label_1f6460;
            case 0x1f647c: ctx->pc = 0; goto label_1f647c;
            case 0x1f6490: ctx->pc = 0; goto label_1f6490;
            case 0x1f64b8: ctx->pc = 0; goto label_1f64b8;
            case 0x1f64c8: ctx->pc = 0; goto label_1f64c8;
            case 0x1f64e8: ctx->pc = 0; goto label_1f64e8;
            case 0x1f64ec: ctx->pc = 0; goto label_1f64ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f63f0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f63f4: 0x7ba90040
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f63f8: 0x7baa0050
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f63fc: 0x4a1ffca
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_S32(ctx, 5) >= 0) {
        ctx->pc = 0x1F6328; return;
    }
    // 0x1f6404: 0x17c0ff66
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F61A0; return;
    }
    // 0x1f640c: 0x1000ff5e
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6188; return;
    }
label_1f6414:
    // 0x1f6414: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1f6418: 0x14400043
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 21)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6528; return;
    }
    // 0x1f6420: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f6424: 0x8fb0003c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1f6428: 0x531018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f642c: 0x561821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1f6430: 0x203102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1f6434: 0x104000a3
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 19), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F66C4; return;
    }
    // 0x1f643c: 0xafa30028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 3));
    // 0x1f6440: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1f6444: 0x2bd50002
    SET_GPR_U32(ctx, 21, SLT32(GPR_S32(ctx, 30), 2));
    // 0x1f6448: 0xffa20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 2));
    // 0x1f644c: 0x13a03c
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 19) << (32 + 0));
    // 0x1f6450: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f6454: 0x0
    // NOP
label_1f6458:
    // 0x1f6458: 0x10000024
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f64ec;
    }
label_1f6460:
    // 0x1f6460: 0x17c00006
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1f647c;
    }
    // 0x1f6468: 0xde020000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f646c: 0xde230000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f6470: 0xfe220000
    WRITE64(ADD32(GPR_U32(ctx, 17), 0), GPR_U64(ctx, 2));
    // 0x1f6474: 0x1000001c
    WRITE64(ADD32(GPR_U32(ctx, 16), 0), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f64e8;
    }
label_1f647c:
    // 0x1f647c: 0x12a0000e
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1f64b8;
    }
    // 0x1f6484: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f6488: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f648c: 0x3283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) >> (32 + 0));
label_1f6490:
    // 0x1f6490: 0xdcc30000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f6494: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f6498: 0xdc820000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f649c: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x1f64a0: 0xfcc20000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 2));
    // 0x1f64a4: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1f64a8: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f6490;
    }
    // 0x1f64b0: 0x1000000e
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f64ec;
    }
label_1f64b8:
    // 0x1f64b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f64bc: 0x14283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) >> (32 + 0));
    // 0x1f64c0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f64c4: 0x0
    // NOP
label_1f64c8:
    // 0x1f64c8: 0x90c30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f64cc: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f64d0: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f64d4: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f64d8: 0xa0c20000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f64dc: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f64e0: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f64c8;
    }
label_1f64e8:
    // 0x1f64e8: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f64ec:
    // 0x1f64ec: 0x2d1102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 17)));
    // 0x1f64f0: 0x10400006
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F650C; return;
    }
    // 0x1f64f8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f64fc: 0x2e0f809
    SET_GPR_U32(ctx, 31, 0x1f6504);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 23); return;
}


// Function: entry_1f6504
// Address: 0x1f6504 - 0x1f6698

void entry_1f6504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6504) {
        switch (ctx->pc) {
            case 0x1f650c: ctx->pc = 0; goto label_1f650c;
            case 0x1f6528: ctx->pc = 0; goto label_1f6528;
            case 0x1f6570: ctx->pc = 0; goto label_1f6570;
            case 0x1f6598: ctx->pc = 0; goto label_1f6598;
            case 0x1f65b0: ctx->pc = 0; goto label_1f65b0;
            case 0x1f65d8: ctx->pc = 0; goto label_1f65d8;
            case 0x1f65e4: ctx->pc = 0; goto label_1f65e4;
            case 0x1f6610: ctx->pc = 0; goto label_1f6610;
            case 0x1f6638: ctx->pc = 0; goto label_1f6638;
            case 0x1f6648: ctx->pc = 0; goto label_1f6648;
            case 0x1f6668: ctx->pc = 0; goto label_1f6668;
            case 0x1f666c: ctx->pc = 0; goto label_1f666c;
            case 0x1f6684: ctx->pc = 0; goto label_1f6684;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6504: 0x1c40ffd6
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1F6460; return;
    }
label_1f650c:
    // 0x1f650c: 0x8fa40028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1f6510: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f6514: 0x204102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x1f6518: 0x1440ffcf
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6458; return;
    }
    // 0x1f6520: 0x10000069
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F66C8; return;
    }
label_1f6528:
    // 0x1f6528: 0x2b61823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 22)));
    // 0x1f652c: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x1f6530: 0xa0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1f6534: 0x62280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1f6538: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f653c: 0x531018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1f6540: 0x18a00025
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_1f65d8;
    }
    // 0x1f6548: 0x2bc20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 30), 2));
    // 0x1f654c: 0x10400012
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f6598;
    }
    // 0x1f6554: 0x510c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 5), 3));
    // 0x1f6558: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f655c: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1f6560: 0x2918023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x1f6564: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f6568: 0x2b43823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 20)));
    // 0x1f656c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1f6570:
    // 0x1f6570: 0xdcc30000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f6574: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f6578: 0xdc820000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f657c: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x1f6580: 0xfcc20000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 2));
    // 0x1f6584: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1f6588: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f6570;
    }
    // 0x1f6590: 0x10000014
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f65e4;
    }
label_1f6598:
    // 0x1f6598: 0x5103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1f659c: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f65a0: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f65a4: 0x2918023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x1f65a8: 0x2b43823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 20)));
    // 0x1f65ac: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1f65b0:
    // 0x1f65b0: 0x90c30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f65b4: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f65b8: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f65bc: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f65c0: 0xa0c20000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f65c4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f65c8: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f65b0;
    }
    // 0x1f65d0: 0x10000004
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f65e4;
    }
label_1f65d8:
    // 0x1f65d8: 0x2918023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x1f65dc: 0x2b43823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 20)));
    // 0x1f65e0: 0xf32823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 19)));
label_1f65e4:
    // 0x1f65e4: 0x205102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 5)));
    // 0x1f65e8: 0x202280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 16));
    // 0x1f65ec: 0x18a0001e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 30), 2));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_1f6668;
    }
    // 0x1f65f4: 0x10400010
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f6638;
    }
    // 0x1f65fc: 0x510c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 5), 3));
    // 0x1f6600: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f6604: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1f6608: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f660c: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
label_1f6610:
    // 0x1f6610: 0xdcc30000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f6614: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f6618: 0xdc820000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f661c: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x1f6620: 0xfcc20000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 2));
    // 0x1f6624: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1f6628: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f6610;
    }
    // 0x1f6630: 0x1000000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f666c;
    }
label_1f6638:
    // 0x1f6638: 0x5103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1f663c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f6640: 0x2283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1f6644: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1f6648:
    // 0x1f6648: 0x90c30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f664c: 0x64a5ffff
    SET_GPR_S64(ctx, 5, (int64_t)GPR_S64(ctx, 5) + (int64_t)4294967295);
    // 0x1f6650: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f6654: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f6658: 0xa0c20000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f665c: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1f6660: 0x1ca0fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_S32(ctx, 5) > 0) {
        goto label_1f6648;
    }
label_1f6668:
    // 0x1f6668: 0x100282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
label_1f666c:
    // 0x1f666c: 0x265102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), GPR_U32(ctx, 5)));
    // 0x1f6670: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1F669C; return;
    }
    // 0x1f6678: 0xb3001b
    { uint32_t divisor = GPR_U32(ctx, 19); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 5) / divisor; ctx->hi = GPR_U32(ctx, 19) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,5); } }
    // 0x1f667c: 0x52600001
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1f6684;
    }
label_1f6684:
    // 0x1f6684: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f6688: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f668c: 0x2812
    SET_GPR_U32(ctx, 5, ctx->lo);
    // 0x1f6690: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x1f6698);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_1f6698
// Address: 0x1f6698 - 0x1f66f8

void entry_1f6698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6698) {
        switch (ctx->pc) {
            case 0x1f669c: ctx->pc = 0; goto label_1f669c;
            case 0x1f66b4: ctx->pc = 0; goto label_1f66b4;
            case 0x1f66c4: ctx->pc = 0; goto label_1f66c4;
            case 0x1f66c8: ctx->pc = 0; goto label_1f66c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6698: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f669c:
    // 0x1f669c: 0x265102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), GPR_U32(ctx, 5)));
    // 0x1f66a0: 0x10400009
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f66c8;
    }
    // 0x1f66a8: 0xb3001b
    { uint32_t divisor = GPR_U32(ctx, 19); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 5) / divisor; ctx->hi = GPR_U32(ctx, 19) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,5); } }
    // 0x1f66ac: 0x52600001
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1f66b4;
    }
label_1f66b4:
    // 0x1f66b4: 0x2a5b023
    SET_GPR_U32(ctx, 22, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 5)));
    // 0x1f66b8: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1f66bc: 0x1000fd93
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F5D0C; return;
    }
label_1f66c4:
    // 0x1f66c4: 0xdfbf0100
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 256)));
label_1f66c8:
    // 0x1f66c8: 0xdfbe00f0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1f66cc: 0xdfb700e0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1f66d0: 0xdfb600d0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f66d4: 0xdfb500c0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f66d8: 0xdfb400b0
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f66dc: 0xdfb300a0
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f66e0: 0xdfb20090
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f66e4: 0xdfb10080
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f66e8: 0xdfb00070
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f66ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f66f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f66f8; return;
}


// Function: srand
// Address: 0x1f66f8 - 0x1f6708

void FUN_001f6880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6880) {
        switch (ctx->pc) {
            case 0x1f6898: ctx->pc = 0; goto label_1f6898;
            case 0x1f68a0: ctx->pc = 0; goto label_1f68a0;
            case 0x1f68b8: ctx->pc = 0; goto label_1f68b8;
            case 0x1f68d8: ctx->pc = 0; goto label_1f68d8;
            case 0x1f6910: ctx->pc = 0; goto label_1f6910;
            case 0x1f6920: ctx->pc = 0; goto label_1f6920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6880: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f6884: 0x14400006
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f68a0;
    }
    // 0x1f688c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f6890: 0x3e00008
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1f6898:
    // 0x1f6898: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1f68a0:
    // 0x1f68a0: 0x1060fffd
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1f6898;
    }
    // 0x1f68a8: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f68ac: 0x5462000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1f68d8;
    }
    // 0x1f68b4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
label_1f68b8:
    // 0x1f68b8: 0xa71021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1f68bc: 0x80460000
    SET_GPR_S32(ctx, 6, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f68c0: 0x10c0fff5
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 7)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1f6898;
    }
    // 0x1f68c8: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f68cc: 0x50c3fffa
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
        goto label_1f68b8;
    }
    // 0x1f68d4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1f68d8:
    // 0x1f68d8: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1f68dc: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
        goto label_1f68a0;
    }
    // 0x1f68e4: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f68ec: 0x0
    // NOP
    // 0x1f68f0: 0x0
    // NOP
    // 0x1f68f4: 0x0
    // NOP
    // 0x1f68f8: 0x0
    // NOP
    // 0x1f68fc: 0x0
    // NOP
    // 0x1f6900: 0x24030000
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 0));
    // 0x1f6904: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6908: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
label_1f6910:
    // 0x1f6910: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f6914: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6918: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
label_1f6920:
    // 0x1f6920: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f6924: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6928: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f6930: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1f6934: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6938: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f6940: 0x2403000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1f6944: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6948: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddIntcHandler
// Address: 0x1f6950 - 0x1f6960

void FUN_001f6d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6d40: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1f6d44: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x1f6d48: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1f6d4c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f6d50: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f6d54: 0x40106000
    SET_GPR_U32(ctx, 16, ctx->cop0_status);
    // 0x1f6d58: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1f6d5c: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f6d60: 0x12000003
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1f6d70(rdram, ctx, runtime); return;
    }
    // 0x1f6d68: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x1f6d70);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6d70
// Address: 0x1f6d70 - 0x1f6d78

void entry_1f6d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6d70: 0xc07da6c
    SET_GPR_U32(ctx, 31, 0x1f6d78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn__DisableIntc(rdram, ctx, runtime); return;
}


// Function: entry_1f6d78
// Address: 0x1f6d78 - 0x1f6d90

void entry_1f6d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6d78: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f6d7c: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1f6d80: 0x12000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6D94; return;
    }
    // 0x1f6d88: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f6d90);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6d90
// Address: 0x1f6d90 - 0x1f6da8

void entry_1f6d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6d90) {
        switch (ctx->pc) {
            case 0x1f6d94: ctx->pc = 0; goto label_1f6d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6d90: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f6d94:
    // 0x1f6d94: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f6d98: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f6d9c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f6da0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnableIntc
// Address: 0x1f6da8 - 0x1f6dd8

void entry_1f6dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6dd8: 0xc07da68
    SET_GPR_U32(ctx, 31, 0x1f6de0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn__EnableIntc(rdram, ctx, runtime); return;
}


// Function: entry_1f6de0
// Address: 0x1f6de0 - 0x1f6df8

void entry_1f6de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6de0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f6de4: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1f6de8: 0x12000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6DFC; return;
    }
    // 0x1f6df0: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f6df8);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6df8
// Address: 0x1f6df8 - 0x1f6e10

void entry_1f6df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6df8) {
        switch (ctx->pc) {
            case 0x1f6dfc: ctx->pc = 0; goto label_1f6dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6df8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f6dfc:
    // 0x1f6dfc: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f6e00: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f6e04: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f6e08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DisableDmac
// Address: 0x1f6e10 - 0x1f6e40

void entry_1f6e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6e40: 0xc07da74
    SET_GPR_U32(ctx, 31, 0x1f6e48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn__DisableDmac(rdram, ctx, runtime); return;
}


// Function: entry_1f6e48
// Address: 0x1f6e48 - 0x1f6e60

void entry_1f6e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6e48: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f6e4c: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1f6e50: 0x12000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6E64; return;
    }
    // 0x1f6e58: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f6e60);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6e60
// Address: 0x1f6e60 - 0x1f6e78

void entry_1f6e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6e60) {
        switch (ctx->pc) {
            case 0x1f6e64: ctx->pc = 0; goto label_1f6e64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6e60: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f6e64:
    // 0x1f6e64: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f6e68: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f6e6c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f6e70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f6e78
// Address: 0x1f6e78 - 0x1f6ea8

void FUN_001f6e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6e78: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1f6e7c: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x1f6e80: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1f6e84: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f6e88: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f6e8c: 0x40106000
    SET_GPR_U32(ctx, 16, ctx->cop0_status);
    // 0x1f6e90: 0x3c020001
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    // 0x1f6e94: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f6e98: 0x12000003
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1f6ea8(rdram, ctx, runtime); return;
    }
    // 0x1f6ea0: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x1f6ea8);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6ea8
// Address: 0x1f6ea8 - 0x1f6eb0

void entry_1f6ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6ea8: 0xc07da70
    SET_GPR_U32(ctx, 31, 0x1f6eb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn__EnableDmac(rdram, ctx, runtime); return;
}


// Function: entry_1f6eb0
// Address: 0x1f6eb0 - 0x1f6ec8

void entry_1f6eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6eb0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f6eb4: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1f6eb8: 0x12000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F6ECC; return;
    }
    // 0x1f6ec0: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f6ec8);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f6ec8
// Address: 0x1f6ec8 - 0x1f6ee0

void entry_1f6ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f6ec8) {
        switch (ctx->pc) {
            case 0x1f6ecc: ctx->pc = 0; goto label_1f6ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f6ec8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1f6ecc:
    // 0x1f6ecc: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f6ed0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f6ed4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f6ed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSyscall
// Address: 0x1f6ee0 - 0x1f6ef0

void FUN_001f6ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6ef0: 0x2403005a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 90));
    // 0x1f6ef4: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f6ef8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f6ef0_cont_1f6f00
// Address: 0x1f6f00 - 0x1f6f0c

void FUN_001f6ef0_cont_1f6f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f00: 0x63082
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 6), 2));
    // 0x1f6f04: 0x10c0000a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1f6f30(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f6f0c; return;
}


// Function: entry_1f6f08
// Address: 0x1f6f0c - 0x1f6f10

void entry_1f6f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f6f10; return;
}


// Function: entry_1f6f10
// Address: 0x1f6f10 - 0x1f6f18

void entry_1f6f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f10: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f6f14: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // Fall-through to next function
    ctx->pc = 0x1f6f18; return;
}


// Function: entry_1f6f18
// Address: 0x1f6f18 - 0x1f6f20

void entry_1f6f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f18: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1f6f1c: 0xe6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // Fall-through to next function
    ctx->pc = 0x1f6f20; return;
}


// Function: entry_1f6f20
// Address: 0x1f6f20 - 0x1f6f28

void entry_1f6f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f20: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x1f6f24: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // Fall-through to next function
    ctx->pc = 0x1f6f28; return;
}


// Function: entry_1f6f28
// Address: 0x1f6f28 - 0x1f6f30

void entry_1f6f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f28: 0x1440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1f6f10(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f6f30; return;
}


// Function: entry_1f6f30
// Address: 0x1f6f30 - 0x1f6f38

void entry_1f6f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f30: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RFU091
// Address: 0x1f6f38 - 0x1f6f40

void entry_1f6f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f40: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitAlarm1
// Address: 0x1f6f48 - 0x1f6f50

void entry_1f6f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f50: 0xffbf0030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 31));
    // 0x1f6f54: 0x34421810
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 6160));
    // Fall-through to next function
    ctx->pc = 0x1f6f58; return;
}


// Function: entry_1f6f58
// Address: 0x1f6f58 - 0x1f6f60

void entry_1f6f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f58: 0xffb20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 18));
    // 0x1f6f5c: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // Fall-through to next function
    ctx->pc = 0x1f6f60; return;
}


// Function: entry_1f6f60
// Address: 0x1f6f60 - 0x1f6f68

void entry_1f6f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f60: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f6f64: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // Fall-through to next function
    ctx->pc = 0x1f6f68; return;
}


// Function: entry_1f6f68
// Address: 0x1f6f68 - 0x1f6f74

void entry_1f6f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f68: 0x30630100
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 256));
    // 0x1f6f6c: 0x14600026
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        InitAlarm1_cont_1f6f90_cont_1f6fa8_cont_1f6fc0_cont_1f6fd8_cont_1f6ff0_cont_1f7008(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f6f74; return;
}


// Function: entry_1f6f70
// Address: 0x1f6f74 - 0x1f6f78

void entry_1f6f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f74: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // Fall-through to next function
    ctx->pc = 0x1f6f78; return;
}


// Function: entry_1f6f78
// Address: 0x1f6f78 - 0x1f6f80

void entry_1f6f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f78: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f6f7c: 0x245070e8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 28904));
    // Fall-through to next function
    ctx->pc = 0x1f6f80; return;
}


// Function: entry_1f6f80
// Address: 0x1f6f80 - 0x1f6f88

void entry_1f6f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f80: 0x8c4470e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 28904)));
    // 0x1f6f84: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // Fall-through to next function
    ctx->pc = 0x1f6f88; return;
}


// Function: entry_1f6f88
// Address: 0x1f6f88 - 0x1f6f90

void entry_1f6f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f88: 0xc07dbb8
    SET_GPR_U32(ctx, 31, 0x1f6f90);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 16));
    SetSyscall(rdram, ctx, runtime); return;
}


// Function: InitAlarm1_cont_1f6f90
// Address: 0x1f6f90 - 0x1f6f98

void entry_1f6f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6f98: 0x24a56980
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 27008));
    // 0x1f6f9c: 0x34846000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 24576));
    // Fall-through to next function
    ctx->pc = 0x1f6fa0; return;
}


// Function: entry_1f6fa0
// Address: 0x1f6fa0 - 0x1f6fa8

void entry_1f6fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fa0: 0xc07dbbc
    SET_GPR_U32(ctx, 31, 0x1f6fa8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1856));
    FUN_001f6ef0(rdram, ctx, runtime); return;
}


// Function: InitAlarm1_cont_1f6f90_cont_1f6fa8
// Address: 0x1f6fa8 - 0x1f6fb0

void entry_1f6fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fb0: 0x24a570c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 28864));
    // 0x1f6fb4: 0x34842000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 8192));
    // Fall-through to next function
    ctx->pc = 0x1f6fb8; return;
}


// Function: entry_1f6fb8
// Address: 0x1f6fb8 - 0x1f6fc0

void entry_1f6fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fb8: 0xc07dbbc
    SET_GPR_U32(ctx, 31, 0x1f6fc0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 40));
    FUN_001f6ef0(rdram, ctx, runtime); return;
}


// Function: InitAlarm1_cont_1f6f90_cont_1f6fa8_cont_1f6fc0
// Address: 0x1f6fc0 - 0x1f6fc8

void entry_1f6fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fc8: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1f6fd0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1f6fd0
// Address: 0x1f6fd0 - 0x1f6fdc

void entry_1f6fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fd0: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1f6fd4: 0xc07dbb8
    SET_GPR_U32(ctx, 31, 0x1f6fdc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    SetSyscall(rdram, ctx, runtime); return;
}


// Function: entry_1f6fdc
// Address: 0x1f6fdc - 0x1f6fe0

void entry_1f6fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fdc: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // Fall-through to next function
    ctx->pc = 0x1f6fe0; return;
}


// Function: entry_1f6fe0
// Address: 0x1f6fe0 - 0x1f6fe8

void entry_1f6fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fe0: 0xc07dbce
    SET_GPR_U32(ctx, 31, 0x1f6fe8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    RFU091(rdram, ctx, runtime); return;
}


// Function: entry_1f6fe8
// Address: 0x1f6fe8 - 0x1f6ff0

void entry_1f6fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6fe8: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f6fec: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // Fall-through to next function
    ctx->pc = 0x1f6ff0; return;
}


// Function: InitAlarm1_cont_1f6f90_cont_1f6fa8_cont_1f6fc0_cont_1f6fd8_cont_1f6ff0
// Address: 0x1f6ff0 - 0x1f6ff8

void entry_1f6ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f6ff8: 0x2e420008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 8));
    // 0x1f6ffc: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        entry_1f6fe0(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f7004; return;
}


// Function: entry_1f7000
// Address: 0x1f7004 - 0x1f7008

void entry_1f7000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7004: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // Fall-through to next function
    ctx->pc = 0x1f7008; return;
}


// Function: InitAlarm1_cont_1f6f90_cont_1f6fa8_cont_1f6fc0_cont_1f6fd8_cont_1f6ff0_cont_1f7008
// Address: 0x1f7008 - 0x1f7010

void entry_1f7010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7010: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7014: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: entry_1f7018
// Address: 0x1f701c - 0x1f7020

void entry_1f7018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f701c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7020; return;
}


// Function: topThread
// Address: 0x1f7020 - 0x1f7028

void entry_1f7028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7028) {
        switch (ctx->pc) {
            case 0x1f7060: ctx->pc = 0; goto label_1f7060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7028: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f702c: 0xffb60060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 22));
    // 0x1f7030: 0xffb50050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 21));
    // 0x1f7034: 0x3c160062
    SET_GPR_U32(ctx, 22, ((uint32_t)98 << 16));
    // 0x1f7038: 0xffb40040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 20));
    // 0x1f703c: 0x3c150025
    SET_GPR_U32(ctx, 21, ((uint32_t)37 << 16));
    // 0x1f7040: 0xffb30030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 19));
    // 0x1f7044: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f7048: 0xffb20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 18));
    // 0x1f704c: 0x24130002
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f7050: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f7054: 0x26320008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 8));
    // 0x1f7058: 0xffbf0070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 31));
    // 0x1f705c: 0x26300009
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 9));
label_1f7060:
    // 0x1f7060: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f7068);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 23408)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f7068
// Address: 0x1f7068 - 0x1f70c0

void entry_1f7068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7068) {
        switch (ctx->pc) {
            case 0x1f70a8: ctx->pc = 0; goto label_1f70a8;
            case 0x1f70b8: ctx->pc = 0; goto label_1f70b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7068: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f706c: 0x306301ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 511));
    // 0x1f7070: 0x24640001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f7074: 0x31840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1f7078: 0xae240000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 4));
    // 0x1f707c: 0x2431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1f7080: 0x2033021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1f7084: 0x90420000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f7088: 0x1054000f
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 2), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x1F70C8; return;
    }
    // 0x1f7090: 0x10a00005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4294961544));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1f70a8;
    }
    // 0x1f7098: 0x10400007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f70b8;
    }
    // 0x1f70a0: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F70E8; return;
    }
label_1f70a8:
    // 0x1f70a8: 0x1053000b
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x1F70D8; return;
    }
    // 0x1f70b0: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F70E8; return;
    }
label_1f70b8:
    // 0x1f70b8: 0xc07dab0
    SET_GPR_U32(ctx, 31, 0x1f70c0);
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    WakeupThread(rdram, ctx, runtime); return;
}


// Function: entry_1f70c0
// Address: 0x1f70c0 - 0x1f70d0

void entry_1f70c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f70c0) {
        switch (ctx->pc) {
            case 0x1f70c8: ctx->pc = 0; goto label_1f70c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f70c0: 0x1000ffe7
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7060; return;
    }
label_1f70c8:
    // 0x1f70c8: 0xc07da9c
    SET_GPR_U32(ctx, 31, 0x1f70d0);
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    RotateThreadReadyQueue(rdram, ctx, runtime); return;
}


// Function: entry_1f70d0
// Address: 0x1f70d0 - 0x1f70e0

void entry_1f70d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f70d0) {
        switch (ctx->pc) {
            case 0x1f70d8: ctx->pc = 0; goto label_1f70d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f70d0: 0x1000ffe3
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7060; return;
    }
label_1f70d8:
    // 0x1f70d8: 0xc07dabc
    SET_GPR_U32(ctx, 31, 0x1f70e0);
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    SuspendThread(rdram, ctx, runtime); return;
}


// Function: entry_1f70e0
// Address: 0x1f70e0 - 0x1f70f0

void entry_1f70e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f70e0) {
        switch (ctx->pc) {
            case 0x1f70e8: ctx->pc = 0; goto label_1f70e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f70e0: 0x1000ffdf
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7060; return;
    }
label_1f70e8:
    // 0x1f70e8: 0xc07ded4
    SET_GPR_U32(ctx, 31, 0x1f70f0);
    kprintf(rdram, ctx, runtime); return;
}


// Function: entry_1f70f0
// Address: 0x1f70f0 - 0x1f70f8

void entry_1f70f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f70f0: 0x1000ffdb
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7060; return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f70f8; return;
}


// Function: InitThread
// Address: 0x1f70f8 - 0x1f7128

void entry_1f716c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f716c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f7170: 0x4810005
    WRITE32(ADD32(GPR_U32(ctx, 16), 28968), GPR_U32(ctx, 4));
    if (GPR_S32(ctx, 4) >= 0) {
        entry_1f7188(rdram, ctx, runtime); return;
    }
    // 0x1f7178: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f7180);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 23408)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f7180
// Address: 0x1f7180 - 0x1f7188

void entry_1f7180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7180: 0x1000000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F71B8; return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f7188; return;
}


// Function: entry_1f7188
// Address: 0x1f7188 - 0x1f71a0

void entry_1f7188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7188: 0x3c020062
    SET_GPR_U32(ctx, 2, ((uint32_t)98 << 16));
    // 0x1f718c: 0x24435b78
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23416));
    // 0x1f7190: 0xac405b78
    WRITE32(ADD32(GPR_U32(ctx, 2), 23416), GPR_U32(ctx, 0));
    // 0x1f7194: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f7198: 0xc07da88
    SET_GPR_U32(ctx, 31, 0x1f71a0);
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    StartThread(rdram, ctx, runtime); return;
}


// Function: entry_1f71a0
// Address: 0x1f71a0 - 0x1f71a8

void entry_1f71a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f71a0: 0xc07daa4
    SET_GPR_U32(ctx, 31, 0x1f71a8);
    GetThreadId(rdram, ctx, runtime); return;
}


// Function: entry_1f71a8
// Address: 0x1f71a8 - 0x1f71b4

void entry_1f71a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f71a8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f71ac: 0xc07da94
    SET_GPR_U32(ctx, 31, 0x1f71b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ChangeThreadPriority(rdram, ctx, runtime); return;
}


// Function: entry_1f71b4
// Address: 0x1f71b4 - 0x1f71d0

void entry_1f71b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f71b4) {
        switch (ctx->pc) {
            case 0x1f71b8: ctx->pc = 0; goto label_1f71b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f71b4: 0x8e027128
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28968)));
label_1f71b8:
    // 0x1f71b8: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f71bc: 0xdfb10060
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f71c0: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f71c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f71cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f71d0; return;
}


// Function: iWakeupThread
// Address: 0x1f71d0 - 0x1f71f8

void entry_1f71f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f71f8) {
        switch (ctx->pc) {
            case 0x1f7200: ctx->pc = 0; goto label_1f7200;
            case 0x1f7214: ctx->pc = 0; goto label_1f7214;
            case 0x1f721c: ctx->pc = 0; goto label_1f721c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f71f8: 0x10000017
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7258; return;
    }
label_1f7200:
    // 0x1f7200: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f7214;
    }
    // 0x1f7208: 0x8c437128
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28968)));
    // 0x1f720c: 0x14600003
    SET_GPR_U32(ctx, 3, ((uint32_t)98 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1f721c;
    }
label_1f7214:
    // 0x1f7214: 0x1000000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7254; return;
    }
label_1f721c:
    // 0x1f721c: 0x3c050062
    SET_GPR_U32(ctx, 5, ((uint32_t)98 << 16));
    // 0x1f7220: 0x24635b78
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23416));
    // 0x1f7224: 0x8ca45b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 23408)));
    // 0x1f7228: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1f722c: 0x304201ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 511));
    // 0x1f7230: 0x23040
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 2), 1));
    // 0x1f7234: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1f7238: 0x662821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1f723c: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x1f7240: 0xa0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1f7244: 0xa0a00008
    WRITE8(ADD32(GPR_U32(ctx, 5), 8), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f7248: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x1f7250);
    WRITE8(ADD32(GPR_U32(ctx, 3), 9), (uint8_t)GPR_U32(ctx, 16));
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f7250
// Address: 0x1f7250 - 0x1f7270

void entry_1f7250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7250) {
        switch (ctx->pc) {
            case 0x1f7254: ctx->pc = 0; goto label_1f7254;
            case 0x1f7258: ctx->pc = 0; goto label_1f7258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7250: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f7254:
    // 0x1f7254: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_1f7258:
    // 0x1f7258: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f725c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f7264: 0x0
    // NOP
    // 0x1f7268: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1f726c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7270; return;
}


// Function: kputchar
// Address: 0x1f7270 - 0x1f72a8

void entry_1f72e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f72e8) {
        switch (ctx->pc) {
            case 0x1f72f0: ctx->pc = 0; goto label_1f72f0;
            case 0x1f72f4: ctx->pc = 0; goto label_1f72f4;
            case 0x1f7330: ctx->pc = 0; goto label_1f7330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f72e8: 0x10000002
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 28972)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f72f4;
    }
label_1f72f0:
    // 0x1f72f0: 0x3c120062
    SET_GPR_U32(ctx, 18, ((uint32_t)98 << 16));
label_1f72f4:
    // 0x1f72f4: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f72f8: 0x1602000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 24448));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1f7330;
    }
    // 0x1f7300: 0x26445f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 24448));
    // 0x1f7304: 0xae20712c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28972), GPR_U32(ctx, 0));
    // 0x1f7308: 0xa41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1f730c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7310: 0xa0500000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 16));
    // 0x1f7314: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f7318: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f731c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7320: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7324: 0xa0600001
    WRITE8(ADD32(GPR_U32(ctx, 3), 1), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f7328: 0x807e850
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    kputs(rdram, ctx, runtime); return;
label_1f7330:
    // 0x1f7330: 0x24a30001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f7334: 0xae23712c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28972), GPR_U32(ctx, 3));
    // 0x1f7338: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1f733c: 0xa0500000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 16));
    // 0x1f7340: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7344: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7348: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f734c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7350: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: serialPutchar
// Address: 0x1f7358 - 0x1f7370

void entry_1f7370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7370) {
        switch (ctx->pc) {
            case 0x1f7380: ctx->pc = 0; goto label_1f7380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7370: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7374: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f7378: 0x807dc9c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    kputchar(rdram, ctx, runtime); return;
label_1f7380:
    // 0x1f7380: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7384: 0x807dc9c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    kputchar(rdram, ctx, runtime); return;
    // 0x1f738c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7390; return;
}


// Function: ftoi
// Address: 0x1f7390 - 0x1f7420

void FUN_001f7420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7420: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1f7424: 0xffb20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 18));
    // 0x1f7428: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f742c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f7430: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x1f7434: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f7438: 0xffbf0030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 31));
    // 0x1f743c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f7440: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1f7448);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f7448
// Address: 0x1f7448 - 0x1f7458

void entry_1f7448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7448: 0x4410008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        entry_1f746c(rdram, ctx, runtime); return;
    }
    // 0x1f7450: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x1f7458);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_1f7458
// Address: 0x1f7458 - 0x1f746c

void entry_1f7458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7458: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f745c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f7460: 0x8c627130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28976)));
    // 0x1f7464: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f746c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 45));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f746c
// Address: 0x1f746c - 0x1f747c

void entry_1f746c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f746c: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x1f7470: 0xdc25e9c8
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 1), 4294961608)));
    // 0x1f7474: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1f747c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f747c
// Address: 0x1f747c - 0x1f74a0

void entry_1f747c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f747c) {
        switch (ctx->pc) {
            case 0x1f7490: ctx->pc = 0; goto label_1f7490;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f747c: 0x4410011
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F74C4; return;
    }
    // 0x1f7484: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F74A4; return;
    }
    // 0x1f748c: 0x0
    // NOP
label_1f7490:
    // 0x1f7490: 0x34058048
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32840));
    // 0x1f7494: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x1f7498: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1f74a0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1f74a0
// Address: 0x1f74a0 - 0x1f74b4

void entry_1f74a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f74a0) {
        switch (ctx->pc) {
            case 0x1f74a4: ctx->pc = 0; goto label_1f74a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f74a0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1f74a4:
    // 0x1f74a4: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x1f74a8: 0xdc25e9d0
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 1), 4294961616)));
    // 0x1f74ac: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1f74b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f74b4
// Address: 0x1f74b4 - 0x1f74d4

void entry_1f74b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f74b4) {
        switch (ctx->pc) {
            case 0x1f74c4: ctx->pc = 0; goto label_1f74c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f74b4: 0x440fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F7490; return;
    }
    // 0x1f74bc: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7514; return;
    }
label_1f74c4:
    // 0x1f74c4: 0x3405ffc0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65472));
    // 0x1f74c8: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x1f74cc: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1f74d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f74d4
// Address: 0x1f74d4 - 0x1f74f8

void entry_1f74d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f74d4) {
        switch (ctx->pc) {
            case 0x1f74e8: ctx->pc = 0; goto label_1f74e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f74d4: 0x440000f
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F7514; return;
    }
    // 0x1f74dc: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F74FC; return;
    }
    // 0x1f74e4: 0x0
    // NOP
label_1f74e8:
    // 0x1f74e8: 0x34058048
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32840));
    // 0x1f74ec: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x1f74f0: 0xc07f422
    SET_GPR_U32(ctx, 31, 0x1f74f8);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    FUN_001fd088(rdram, ctx, runtime); return;
}


// Function: entry_1f74f8
// Address: 0x1f74f8 - 0x1f750c

void entry_1f74f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f74f8) {
        switch (ctx->pc) {
            case 0x1f74fc: ctx->pc = 0; goto label_1f74fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f74f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1f74fc:
    // 0x1f74fc: 0x3405ffc0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65472));
    // 0x1f7500: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x1f7504: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1f750c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f750c
// Address: 0x1f750c - 0x1f7524

void entry_1f750c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f750c) {
        switch (ctx->pc) {
            case 0x1f7514: ctx->pc = 0; goto label_1f7514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f750c: 0x441fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F74E8; return;
    }
label_1f7514:
    // 0x1f7514: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x1f7518: 0xdc25e9d8
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 1), 4294961624)));
    // 0x1f751c: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1f7524);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1f7524
// Address: 0x1f7524 - 0x1f752c

void entry_1f7524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7524: 0xc07ed4a
    SET_GPR_U32(ctx, 31, 0x1f752c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___fixunsdfdi(rdram, ctx, runtime); return;
}


// Function: entry_1f752c
// Address: 0x1f752c - 0x1f7534

void entry_1f752c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f752c: 0xc07dce4
    SET_GPR_U32(ctx, 31, 0x1f7534);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ftoi(rdram, ctx, runtime); return;
}


// Function: entry_1f7534
// Address: 0x1f7534 - 0x1f7540

void entry_1f7534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7534: 0x2644e9b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294961584));
    // 0x1f7538: 0xc07ded4
    SET_GPR_U32(ctx, 31, 0x1f7540);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    kprintf(rdram, ctx, runtime); return;
}


// Function: entry_1f7540
// Address: 0x1f7540 - 0x1f7588

void entry_1f7540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7540) {
        switch (ctx->pc) {
            case 0x1f7568: ctx->pc = 0; goto label_1f7568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7540: 0x6200009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) < 0) {
        goto label_1f7568;
    }
    // 0x1f7548: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1f754c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7550: 0x2484e9b8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961592));
    // 0x1f7554: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7558: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f755c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7560: 0x807ded4
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    kprintf(rdram, ctx, runtime); return;
label_1f7568:
    // 0x1f7568: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1f756c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7570: 0x2484e9c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961600));
    // 0x1f7574: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7578: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f757c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7580: 0x807ded4
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    kprintf(rdram, ctx, runtime); return;
}


// Function: _printf
// Address: 0x1f7588 - 0x1f774c

void entry_1f774c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f774c) {
        switch (ctx->pc) {
            case 0x1f7778: ctx->pc = 0; goto label_1f7778;
            case 0x1f7788: ctx->pc = 0; goto label_1f7788;
            case 0x1f778c: ctx->pc = 0; goto label_1f778c;
            case 0x1f77ac: ctx->pc = 0; goto label_1f77ac;
            case 0x1f77b0: ctx->pc = 0; goto label_1f77b0;
            case 0x1f77c4: ctx->pc = 0; goto label_1f77c4;
            case 0x1f77d8: ctx->pc = 0; goto label_1f77d8;
            case 0x1f77e4: ctx->pc = 0; goto label_1f77e4;
            case 0x1f77f8: ctx->pc = 0; goto label_1f77f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f774c: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f7750: 0x1440fff9
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7738; return;
    }
    // 0x1f7758: 0x100000f1
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f7760: 0x2402006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1f7764: 0x14e20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 104));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7778;
    }
    // 0x1f776c: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f7770: 0x10000006
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f778c;
    }
label_1f7778:
    // 0x1f7778: 0x14e20003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7788;
    }
    // 0x1f7780: 0x10000002
    SET_GPR_U32(ctx, 17, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f778c;
    }
label_1f7788:
    // 0x1f7788: 0x9e71fff8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 4294967288)));
label_1f778c:
    // 0x1f778c: 0x27b0001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 31));
    // 0x1f7790: 0x16200006
    WRITE8(ADD32(GPR_U32(ctx, 29), 31), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1f77ac;
    }
    // 0x1f7798: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f779c: 0x27b0001e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 30));
    // 0x1f77a0: 0xa3a2001e
    WRITE8(ADD32(GPR_U32(ctx, 29), 30), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f77a4: 0x1000000c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f77d8;
    }
label_1f77ac:
    // 0x1f77ac: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1f77b0:
    // 0x1f77b0: 0x3223000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 17), 15));
    // 0x1f77b4: 0x2c62000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 10));
    // 0x1f77b8: 0x14400002
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 3) + (int64_t)48);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f77c4;
    }
    // 0x1f77c0: 0x64620057
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 3) + (int64_t)87);
label_1f77c4:
    // 0x1f77c4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1f77c8: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1f77cc: 0x11893a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) >> 4);
    // 0x1f77d0: 0x1620fff7
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1f77b0;
    }
label_1f77d8:
    // 0x1f77d8: 0x12800002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1f77e4;
    }
    // 0x1f77e0: 0x282800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 20));
label_1f77e4:
    // 0x1f77e4: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f77e8: 0x104000cc
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B1C; return;
    }
    // 0x1f77f0: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f77f4: 0x0
    // NOP
label_1f77f8:
    // 0x1f77f8: 0x42600
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 24));
    // 0x1f77fc: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7800: 0x42603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 24));
    // 0x1f7804: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f780c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f780c
// Address: 0x1f780c - 0x1f7880

void entry_1f780c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f780c) {
        switch (ctx->pc) {
            case 0x1f7838: ctx->pc = 0; goto label_1f7838;
            case 0x1f7848: ctx->pc = 0; goto label_1f7848;
            case 0x1f784c: ctx->pc = 0; goto label_1f784c;
            case 0x1f7868: ctx->pc = 0; goto label_1f7868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f780c: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f7810: 0x1440fff9
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F77F8; return;
    }
    // 0x1f7818: 0x100000c1
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f7820: 0x2402006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1f7824: 0x14e20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 104));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7838;
    }
    // 0x1f782c: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f7830: 0x10000006
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f784c;
    }
label_1f7838:
    // 0x1f7838: 0x14e20003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7848;
    }
    // 0x1f7840: 0x10000002
    SET_GPR_S32(ctx, 17, (int16_t)READ16(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f784c;
    }
label_1f7848:
    // 0x1f7848: 0x8e71fff8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 4294967288)));
label_1f784c:
    // 0x1f784c: 0x27b0001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 31));
    // 0x1f7850: 0x16200005
    WRITE8(ADD32(GPR_U32(ctx, 29), 31), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1f7868;
    }
    // 0x1f7858: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f785c: 0x27b0001e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 30));
    // 0x1f7860: 0x10000019
    WRITE8(ADD32(GPR_U32(ctx, 29), 30), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F78C8; return;
    }
label_1f7868:
    // 0x1f7868: 0x6210005
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 17) >= 0) {
        entry_1f7880(rdram, ctx, runtime); return;
    }
    // 0x1f7870: 0x11882f
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) - GPR_U64(ctx, 17));
    // 0x1f7874: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7878: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7880);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 45));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7880
// Address: 0x1f7880 - 0x1f7898

void entry_1f7880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7880) {
        switch (ctx->pc) {
            case 0x1f7890: ctx->pc = 0; goto label_1f7890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7880: 0x12200012
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F78CC; return;
    }
    // 0x1f7888: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f788c: 0x0
    // NOP
label_1f7890:
    // 0x1f7890: 0xc07ede4
    SET_GPR_U32(ctx, 31, 0x1f7898);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    FUN_001fb790(rdram, ctx, runtime); return;
}


// Function: entry_1f7898
// Address: 0x1f7898 - 0x1f78b4

void entry_1f7898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7898: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1f789c: 0x64420030
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 2) + (int64_t)48);
    // 0x1f78a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f78a4: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1f78a8: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f78ac: 0xc07eb8e
    SET_GPR_U32(ctx, 31, 0x1f78b4);
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    fn___divdi3(rdram, ctx, runtime); return;
}


// Function: entry_1f78b4
// Address: 0x1f78b4 - 0x1f78fc

void entry_1f78b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f78b4) {
        switch (ctx->pc) {
            case 0x1f78c8: ctx->pc = 0; goto label_1f78c8;
            case 0x1f78cc: ctx->pc = 0; goto label_1f78cc;
            case 0x1f78d8: ctx->pc = 0; goto label_1f78d8;
            case 0x1f78e8: ctx->pc = 0; goto label_1f78e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f78b4: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f78b8: 0x1620fff5
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7890; return;
    }
    // 0x1f78c0: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f78cc;
    }
label_1f78c8:
    // 0x1f78c8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1f78cc:
    // 0x1f78cc: 0x12800002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1f78d8;
    }
    // 0x1f78d4: 0x282800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 20));
label_1f78d8:
    // 0x1f78d8: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f78dc: 0x1040008f
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B1C; return;
    }
    // 0x1f78e4: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
label_1f78e8:
    // 0x1f78e8: 0x42600
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 24));
    // 0x1f78ec: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f78f0: 0x42603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 24));
    // 0x1f78f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f78fc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f78fc
// Address: 0x1f78fc - 0x1f7970

void entry_1f78fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f78fc) {
        switch (ctx->pc) {
            case 0x1f7928: ctx->pc = 0; goto label_1f7928;
            case 0x1f7938: ctx->pc = 0; goto label_1f7938;
            case 0x1f793c: ctx->pc = 0; goto label_1f793c;
            case 0x1f795c: ctx->pc = 0; goto label_1f795c;
            case 0x1f7968: ctx->pc = 0; goto label_1f7968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f78fc: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f7900: 0x1440fff9
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F78E8; return;
    }
    // 0x1f7908: 0x10000085
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f7910: 0x2402006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1f7914: 0x14e20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 104));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7928;
    }
    // 0x1f791c: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f7920: 0x10000006
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f793c;
    }
label_1f7928:
    // 0x1f7928: 0x14e20003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 2)) {
        goto label_1f7938;
    }
    // 0x1f7930: 0x10000002
    SET_GPR_U32(ctx, 17, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 4294967288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f793c;
    }
label_1f7938:
    // 0x1f7938: 0x9e71fff8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 4294967288)));
label_1f793c:
    // 0x1f793c: 0x27b0001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 31));
    // 0x1f7940: 0x16200006
    WRITE8(ADD32(GPR_U32(ctx, 29), 31), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1f795c;
    }
    // 0x1f7948: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f794c: 0x27b0001e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 30));
    // 0x1f7950: 0xa3a2001e
    WRITE8(ADD32(GPR_U32(ctx, 29), 30), (uint8_t)GPR_U32(ctx, 2));
    // 0x1f7954: 0x10000010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7998; return;
    }
label_1f795c:
    // 0x1f795c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1f7960: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f7964: 0x0
    // NOP
label_1f7968:
    // 0x1f7968: 0xc07f0f4
    SET_GPR_U32(ctx, 31, 0x1f7970);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    fn___umoddi3(rdram, ctx, runtime); return;
}


// Function: entry_1f7970
// Address: 0x1f7970 - 0x1f798c

void entry_1f7970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7970: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1f7974: 0x64420030
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 2) + (int64_t)48);
    // 0x1f7978: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f797c: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1f7980: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1f7984: 0xc07ef80
    SET_GPR_U32(ctx, 31, 0x1f798c);
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    FUN_001fbe00(rdram, ctx, runtime); return;
}


// Function: entry_1f798c
// Address: 0x1f798c - 0x1f79cc

void entry_1f798c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f798c) {
        switch (ctx->pc) {
            case 0x1f7998: ctx->pc = 0; goto label_1f7998;
            case 0x1f79a4: ctx->pc = 0; goto label_1f79a4;
            case 0x1f79b8: ctx->pc = 0; goto label_1f79b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f798c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f7990: 0x1620fff5
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7968; return;
    }
label_1f7998:
    // 0x1f7998: 0x12800002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1f79a4;
    }
    // 0x1f79a0: 0x282800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 20));
label_1f79a4:
    // 0x1f79a4: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f79a8: 0x1040005c
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B1C; return;
    }
    // 0x1f79b0: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f79b4: 0x0
    // NOP
label_1f79b8:
    // 0x1f79b8: 0x42600
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 24));
    // 0x1f79bc: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f79c0: 0x42603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 24));
    // 0x1f79c4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f79cc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f79cc
// Address: 0x1f79cc - 0x1f7a0c

void entry_1f79cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f79cc: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f79d0: 0x1440fff9
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F79B8; return;
    }
    // 0x1f79d8: 0x10000051
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f79e0: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f79e4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1f79e8: 0xc66cfff8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4294967288)); ctx->f[12] = *(float*)&val; }
    // 0x1f79ec: 0x46006032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1f79f0: 0x0
    // NOP
    // 0x1f79f4: 0x45000007
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1F7A14; return;
    }
    // 0x1f79fc: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f7a00: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7a0c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7a0c
// Address: 0x1f7a0c - 0x1f7a1c

void entry_1f7a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7a0c) {
        switch (ctx->pc) {
            case 0x1f7a14: ctx->pc = 0; goto label_1f7a14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7a0c: 0x10000044
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
label_1f7a14:
    // 0x1f7a14: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1f7a1c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1f7a1c
// Address: 0x1f7a1c - 0x1f7a24

void entry_1f7a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a1c: 0xc07dd08
    SET_GPR_U32(ctx, 31, 0x1f7a24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_001f7420(rdram, ctx, runtime); return;
}


// Function: entry_1f7a24
// Address: 0x1f7a24 - 0x1f7a54

void entry_1f7a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a24: 0x1000003e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f7a2c: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f7a30: 0x8e63fff8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967288)));
    // 0x1f7a34: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f7a38: 0x14400017
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7A98; return;
    }
    // 0x1f7a40: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f7a44: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1f7a48: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a4c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7a54);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7a54
// Address: 0x1f7a54 - 0x1f7a60

void entry_1f7a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a54: 0x8ea37130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a58: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f7a60);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 110));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f7a60
// Address: 0x1f7a60 - 0x1f7a6c

void entry_1f7a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a60: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7a6c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 117));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7a6c
// Address: 0x1f7a6c - 0x1f7a78

void entry_1f7a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a6c: 0x8ea37130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a70: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f7a78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 108));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f7a78
// Address: 0x1f7a78 - 0x1f7a84

void entry_1f7a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a78: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a7c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7a84);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 108));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7a84
// Address: 0x1f7a84 - 0x1f7a90

void entry_1f7a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7a84: 0x8ea37130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7a88: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f7a90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 41));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f7a90
// Address: 0x1f7a90 - 0x1f7abc

void entry_1f7a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7a90) {
        switch (ctx->pc) {
            case 0x1f7a98: ctx->pc = 0; goto label_1f7a98;
            case 0x1f7aa8: ctx->pc = 0; goto label_1f7aa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7a90: 0x10000023
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
label_1f7a98:
    // 0x1f7a98: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1f7a9c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1f7aa0: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f7aa4: 0x0
    // NOP
label_1f7aa8:
    // 0x1f7aa8: 0x42600
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 24));
    // 0x1f7aac: 0x8ea37130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7ab0: 0x42603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 24));
    // 0x1f7ab4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f7abc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f7abc
// Address: 0x1f7abc - 0x1f7af0

void entry_1f7abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7abc: 0x92020000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f7ac0: 0x1440fff9
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7AA8; return;
    }
    // 0x1f7ac8: 0x10000015
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
    // 0x1f7ad0: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1f7ad4: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1f7ad8: 0x8271fff8
    SET_GPR_S32(ctx, 17, (int8_t)READ8(ADD32(GPR_U32(ctx, 19), 4294967288)));
    // 0x1f7adc: 0x8ea27130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 28976)));
    // 0x1f7ae0: 0x11203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) << (32 + 0));
    // 0x1f7ae4: 0x4203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1f7ae8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1f7af0);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1f7af0
// Address: 0x1f7af0 - 0x1f7b08

void entry_1f7af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7af0) {
        switch (ctx->pc) {
            case 0x1f7af8: ctx->pc = 0; goto label_1f7af8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7af0: 0x1000000b
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7B20; return;
    }
label_1f7af8:
    // 0x1f7af8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f7afc: 0x8c437130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28976)));
    // 0x1f7b00: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1f7b08);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1f7b08
// Address: 0x1f7b08 - 0x1f7b50

void entry_1f7b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7b08) {
        switch (ctx->pc) {
            case 0x1f7b10: ctx->pc = 0; goto label_1f7b10;
            case 0x1f7b1c: ctx->pc = 0; goto label_1f7b1c;
            case 0x1f7b20: ctx->pc = 0; goto label_1f7b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7b08: 0x10000005
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f7b20;
    }
label_1f7b10:
    // 0x1f7b10: 0x10000002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f7b1c;
    }
    // 0x1f7b18: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1f7b1c:
    // 0x1f7b1c: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1f7b20:
    // 0x1f7b20: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f7b24: 0x1440fea4
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F75B8; return;
    }
    // 0x1f7b2c: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f7b30: 0xdfb50070
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f7b34: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f7b38: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f7b3c: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f7b40: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7b44: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7b48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: kprintf
// Address: 0x1f7b50 - 0x1f7b7c

void entry_1f7b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7b7c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7b80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: printf_2
// Address: 0x1f7b88 - 0x1f7bd0

void entry_1f7bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7bd0: 0xae117130
    WRITE32(ADD32(GPR_U32(ctx, 16), 28976), GPR_U32(ctx, 17));
    // 0x1f7bd4: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7bd8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7bdc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7be0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceSifInitRpc
// Address: 0x1f7be8 - 0x1f7c00

void entry_1f7c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7c00) {
        switch (ctx->pc) {
            case 0x1f7c28: ctx->pc = 0; goto label_1f7c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7c00: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f7c04: 0x8c627134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28980)));
    // 0x1f7c08: 0x10400007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f7c28;
    }
    // 0x1f7c10: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f7c14: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7c18: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7c1c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7c20: 0x807e76a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    EIntr(rdram, ctx, runtime); return;
label_1f7c28:
    // 0x1f7c28: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f7c30);
    WRITE32(ADD32(GPR_U32(ctx, 3), 28980), GPR_U32(ctx, 17));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f7c30
// Address: 0x1f7c30 - 0x1f7c38

void entry_1f7c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7c30: 0xc07e87a
    SET_GPR_U32(ctx, 31, 0x1f7c38);
    sceSifInitCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f7c38
// Address: 0x1f7c38 - 0x1f7c40

void entry_1f7c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7c38: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x1f7c40);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f7c40
// Address: 0x1f7c40 - 0x1f7cb4

void entry_1f7c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7c40: 0x3c030062
    SET_GPR_U32(ctx, 3, ((uint32_t)98 << 16));
    // 0x1f7c44: 0x3c080062
    SET_GPR_U32(ctx, 8, ((uint32_t)98 << 16));
    // 0x1f7c48: 0x24726000
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 3), 24576));
    // 0x1f7c4c: 0x3c060062
    SET_GPR_U32(ctx, 6, ((uint32_t)98 << 16));
    // 0x1f7c50: 0x3c070062
    SET_GPR_U32(ctx, 7, ((uint32_t)98 << 16));
    // 0x1f7c54: 0x25107800
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 8), 30720));
    // 0x1f7c58: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1f7c5c: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x1f7c60: 0x24c66800
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 26624));
    // 0x1f7c64: 0x24e77000
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 28672));
    // 0x1f7c68: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1f7c6c: 0xe23825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x1f7c70: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x1f7c74: 0x2421025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1f7c78: 0xad117800
    WRITE32(ADD32(GPR_U32(ctx, 8), 30720), GPR_U32(ctx, 17));
    // 0x1f7c7c: 0x3c05001f
    SET_GPR_U32(ctx, 5, ((uint32_t)31 << 16));
    // 0x1f7c80: 0xae060014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 6));
    // 0x1f7c84: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7c88: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1f7c8c: 0x24a57ea8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32424));
    // 0x1f7c90: 0xae07001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 7));
    // 0x1f7c94: 0x34840008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 8));
    // 0x1f7c98: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f7c9c: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x1f7ca0: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1f7ca4: 0xae000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
    // 0x1f7ca8: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    // 0x1f7cac: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f7cb4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f7cb4
// Address: 0x1f7cb4 - 0x1f7ccc

void entry_1f7cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7cb4: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x1f7cb8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7cbc: 0x24a58010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294934544));
    // 0x1f7cc0: 0x34840009
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 9));
    // 0x1f7cc4: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f7ccc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f7ccc
// Address: 0x1f7ccc - 0x1f7ce4

void entry_1f7ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7ccc: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x1f7cd0: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7cd4: 0x24a58200
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935040));
    // 0x1f7cd8: 0x3484000a
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 10));
    // 0x1f7cdc: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f7ce4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f7ce4
// Address: 0x1f7ce4 - 0x1f7cfc

void entry_1f7ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7ce4: 0x3c05001f
    SET_GPR_U32(ctx, 5, ((uint32_t)31 << 16));
    // 0x1f7ce8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7cec: 0x24a57f60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32608));
    // 0x1f7cf0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f7cf4: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f7cfc);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 12));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f7cfc
// Address: 0x1f7cfc - 0x1f7d04

void entry_1f7cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7cfc: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f7d04);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f7d04
// Address: 0x1f7d04 - 0x1f7d10

void entry_1f7d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7d04: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7d08: 0xc07db3c
    SET_GPR_U32(ctx, 31, 0x1f7d10);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 2));
    sceSifGetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f7d10
// Address: 0x1f7d10 - 0x1f7d3c

void entry_1f7d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7d10: 0x14400017
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7D70; return;
    }
    // 0x1f7d18: 0x26450040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 64));
    // 0x1f7d1c: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7d20: 0xacb1000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 17));
    // 0x1f7d24: 0x34840002
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 2));
    // 0x1f7d28: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1f7d2c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f7d30: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f7d34: 0xc07e98c
    SET_GPR_U32(ctx, 31, 0x1f7d3c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f7d3c
// Address: 0x1f7d3c - 0x1f7d48

void entry_1f7d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7d3c) {
        switch (ctx->pc) {
            case 0x1f7d40: ctx->pc = 0; goto label_1f7d40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7d3c: 0x0
    // NOP
label_1f7d40:
    // 0x1f7d40: 0xc07e870
    SET_GPR_U32(ctx, 31, 0x1f7d48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifGetSreg(rdram, ctx, runtime); return;
}


// Function: entry_1f7d48
// Address: 0x1f7d48 - 0x1f7d88

void entry_1f7d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7d48) {
        switch (ctx->pc) {
            case 0x1f7d70: ctx->pc = 0; goto label_1f7d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7d48: 0x1040fffd
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7D40; return;
    }
    // 0x1f7d50: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7d54: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7d58: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f7d5c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7d60: 0x34840002
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 2));
    // 0x1f7d64: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7d68: 0x807db38
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    sceSifSetReg(rdram, ctx, runtime); return;
label_1f7d70:
    // 0x1f7d70: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7d74: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7d78: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7d7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f7d84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7d88; return;
}


// Function: sceSifExitRpc
// Address: 0x1f7d88 - 0x1f7d98

void entry_1f7d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7d98: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f7d9c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7da0: 0xac407134
    WRITE32(ADD32(GPR_U32(ctx, 2), 28980), GPR_U32(ctx, 0));
    // 0x1f7da4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f7dac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7db0; return;
}


// Function: _sceRpcGetPacket
// Address: 0x1f7db0 - 0x1f7dc8

void entry_1f7dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7dc8) {
        switch (ctx->pc) {
            case 0x1f7de0: ctx->pc = 0; goto label_1f7de0;
            case 0x1f7e18: ctx->pc = 0; goto label_1f7e18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7dc8: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1f7dcc: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f7dd0: 0x18800019
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1F7E38; return;
    }
    // 0x1f7dd8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f7ddc: 0x0
    // NOP
label_1f7de0:
    // 0x1f7de0: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1f7de4: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1f7de8: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
        ctx->pc = 0x1F7E2C; return;
    }
    // 0x1f7df0: 0x31400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 16));
    // 0x1f7df4: 0x34420005
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 5));
    // 0x1f7df8: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1f7dfc: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f7e00: 0x24430001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1f7e04: 0x14650004
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_1f7e18;
    }
    // 0x1f7e0c: 0x24420002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2));
    // 0x1f7e10: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f7e14: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_1f7e18:
    // 0x1f7e18: 0xae100014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 16));
    // 0x1f7e1c: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f7e24);
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f7e24
// Address: 0x1f7e24 - 0x1f7e40

void entry_1f7e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7e24) {
        switch (ctx->pc) {
            case 0x1f7e2c: ctx->pc = 0; goto label_1f7e2c;
            case 0x1f7e38: ctx->pc = 0; goto label_1f7e38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7e24: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7E44; return;
    }
label_1f7e2c:
    // 0x1f7e2c: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1f7e30: 0x1440ffeb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F7DE0; return;
    }
label_1f7e38:
    // 0x1f7e38: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f7e40);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f7e40
// Address: 0x1f7e40 - 0x1f7e58

void entry_1f7e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7e40) {
        switch (ctx->pc) {
            case 0x1f7e44: ctx->pc = 0; goto label_1f7e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7e40: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f7e44:
    // 0x1f7e44: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7e48: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7e4c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7e50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _sceRpcFreePacket
// Address: 0x1f7e58 - 0x1f7e78

void entry_1f7f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f7f08) {
        switch (ctx->pc) {
            case 0x1f7f10: ctx->pc = 0; goto label_1f7f10;
            case 0x1f7f28: ctx->pc = 0; goto label_1f7f28;
            case 0x1f7f2c: ctx->pc = 0; goto label_1f7f2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f7f08: 0x10000007
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f7f28;
    }
label_1f7f10:
    // 0x1f7f10: 0x8e30001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1f7f14: 0xae020024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 2));
    // 0x1f7f18: 0x8e230028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1f7f1c: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x1f7f20: 0x8e22002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 44)));
    // 0x1f7f24: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
label_1f7f28:
    // 0x1f7f28: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_1f7f2c:
    // 0x1f7f2c: 0x4800003
    if (GPR_S32(ctx, 4) < 0) {
        entry_1f7f3c(rdram, ctx, runtime); return;
    }
    // 0x1f7f34: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x1f7f3c);
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f7f3c
// Address: 0x1f7f3c - 0x1f7f44

void entry_1f7f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7f3c: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f7f44);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f7f44
// Address: 0x1f7f44 - 0x1f7f60

void entry_1f7f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7f44: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    // 0x1f7f48: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f7f4c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7f50: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7f54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f7f5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f7f60; return;
}


// Function: FUN_001f7f60
// Address: 0x1f7f60 - 0x1f7f78

void FUN_001f7f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7f60: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1f7f64: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1f7f68: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1f7f6c: 0xffbf0010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 31));
    // 0x1f7f70: 0xc07df9e
    SET_GPR_U32(ctx, 31, 0x1f7f78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    _sceRpcGetFPacket(rdram, ctx, runtime); return;
}


// Function: entry_1f7f78
// Address: 0x1f7f78 - 0x1f7fc0

void entry_1f7f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f7f78: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1f7f7c: 0x3c038000
    SET_GPR_U32(ctx, 3, ((uint32_t)32768 << 16));
    // 0x1f7f80: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1f7f84: 0x3463000c
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 12));
    // 0x1f7f88: 0xac450014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 5));
    // 0x1f7f8c: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f7f90: 0xac44001c
    WRITE32(ADD32(GPR_U32(ctx, 2), 28), GPR_U32(ctx, 4));
    // 0x1f7f94: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f7f98: 0xac430020
    WRITE32(ADD32(GPR_U32(ctx, 2), 32), GPR_U32(ctx, 3));
    // 0x1f7f9c: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f7fa0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f7fa4: 0x34840008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 8));
    // 0x1f7fa8: 0x8e090028
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x1f7fac: 0x8e070020
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1f7fb0: 0x8e080024
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1f7fb4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f7fb8: 0x807e99c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = 0x1fa670; return;
}


// Function: _search_svdata
// Address: 0x1f7fc0 - 0x1f8010

void entry_1f8034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8034: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8038: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1f803c: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1f8040: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x1f8044: 0x34420009
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 9));
    // 0x1f8048: 0xae44001c
    WRITE32(ADD32(GPR_U32(ctx, 18), 28), GPR_U32(ctx, 4));
    // 0x1f804c: 0xae430014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 3));
    // 0x1f8050: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f8054: 0xae420020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 2));
    // 0x1f8058: 0xc07dff0
    SET_GPR_U32(ctx, 31, 0x1f8060);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    _search_svdata(rdram, ctx, runtime); return;
}


// Function: entry_1f8060
// Address: 0x1f8060 - 0x1f80c0

void entry_1f8060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8060) {
        switch (ctx->pc) {
            case 0x1f807c: ctx->pc = 0; goto label_1f807c;
            case 0x1f808c: ctx->pc = 0; goto label_1f808c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8060: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8064: 0x54600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 36), GPR_U32(ctx, 3));
        goto label_1f807c;
    }
    // 0x1f806c: 0xae400024
    WRITE32(ADD32(GPR_U32(ctx, 18), 36), GPR_U32(ctx, 0));
    // 0x1f8070: 0xae400028
    WRITE32(ADD32(GPR_U32(ctx, 18), 40), GPR_U32(ctx, 0));
    // 0x1f8074: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 18), 44), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f808c;
    }
label_1f807c:
    // 0x1f807c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1f8080: 0xae420028
    WRITE32(ADD32(GPR_U32(ctx, 18), 40), GPR_U32(ctx, 2));
    // 0x1f8084: 0x8c630014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1f8088: 0xae43002c
    WRITE32(ADD32(GPR_U32(ctx, 18), 44), GPR_U32(ctx, 3));
label_1f808c:
    // 0x1f808c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f8090: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f8094: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f8098: 0x34840008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 8));
    // 0x1f809c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f80a0: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f80a4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f80a8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f80ac: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f80b0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f80b4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f80b8: 0x807e99c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = 0x1fa670; return;
}


// Function: sceSifBindRpc
// Address: 0x1f80c0 - 0x1f80f8

void entry_1f80f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f80f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f80fc: 0x12000039
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81E4; return;
    }
    // 0x1f8104: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1f8108: 0x32430001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 1));
    // 0x1f810c: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x1f8110: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1f8114: 0xae130020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 19));
    // 0x1f8118: 0xae100014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 16));
    // 0x1f811c: 0x14600022
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81A8; return;
    }
    // 0x1f8124: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f8128: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1f812c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1f8130: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f8138);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8138
// Address: 0x1f8138 - 0x1f8148

void entry_1f8138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8138: 0x4410005
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F8150; return;
    }
    // 0x1f8140: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f8148);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f8148
// Address: 0x1f8148 - 0x1f8170

void entry_1f8148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8148) {
        switch (ctx->pc) {
            case 0x1f8150: ctx->pc = 0; goto label_1f8150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8148: 0x10000026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967293));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81E4; return;
    }
label_1f8150:
    // 0x1f8150: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f8154: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f8158: 0x34840009
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 9));
    // 0x1f815c: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f8160: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8164: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8168: 0xc07e98c
    SET_GPR_U32(ctx, 31, 0x1f8170);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f8170
// Address: 0x1f8170 - 0x1f8180

void entry_1f8170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8170: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8190; return;
    }
    // 0x1f8178: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f8180);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f8180
// Address: 0x1f8180 - 0x1f8188

void entry_1f8180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8180: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8188);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8188
// Address: 0x1f8188 - 0x1f8198

void entry_1f8188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8188) {
        switch (ctx->pc) {
            case 0x1f8190: ctx->pc = 0; goto label_1f8190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8188: 0x10000016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81E4; return;
    }
label_1f8190:
    // 0x1f8190: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8198);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8198
// Address: 0x1f8198 - 0x1f81a0

void entry_1f8198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8198: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f81a0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f81a0
// Address: 0x1f81a0 - 0x1f81d0

void entry_1f81a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f81a0) {
        switch (ctx->pc) {
            case 0x1f81a8: ctx->pc = 0; goto label_1f81a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f81a0: 0x10000010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81E4; return;
    }
label_1f81a8:
    // 0x1f81a8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f81ac: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f81b0: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x1f81b4: 0x34840009
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 9));
    // 0x1f81b8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f81bc: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1f81c0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f81c4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f81c8: 0xc07e98c
    SET_GPR_U32(ctx, 31, 0x1f81d0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f81d0
// Address: 0x1f81d0 - 0x1f81e0

void entry_1f81d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f81d0: 0x14400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F81E4; return;
    }
    // 0x1f81d8: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f81e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f81e0
// Address: 0x1f81e0 - 0x1f8290

void entry_1f81e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f81e0) {
        switch (ctx->pc) {
            case 0x1f81e4: ctx->pc = 0; goto label_1f81e4;
            case 0x1f821c: ctx->pc = 0; goto label_1f821c;
            case 0x1f8220: ctx->pc = 0; goto label_1f8220;
            case 0x1f8284: ctx->pc = 0; goto label_1f8284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f81e0: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
label_1f81e4:
    // 0x1f81e4: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f81e8: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f81ec: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f81f0: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f81f4: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f81f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8200: 0x8c850034
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 52)));
    // 0x1f8204: 0x8ca60040
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x1f8208: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1f820c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 16)));
        goto label_1f821c;
    }
    // 0x1f8214: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8220;
    }
label_1f821c:
    // 0x1f821c: 0xac45003c
    WRITE32(ADD32(GPR_U32(ctx, 2), 60), GPR_U32(ctx, 5));
label_1f8220:
    // 0x1f8220: 0xacc50010
    WRITE32(ADD32(GPR_U32(ctx, 6), 16), GPR_U32(ctx, 5));
    // 0x1f8224: 0x8c820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x1f8228: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x1f822c: 0xaca20020
    WRITE32(ADD32(GPR_U32(ctx, 5), 32), GPR_U32(ctx, 2));
    // 0x1f8230: 0xaca3001c
    WRITE32(ADD32(GPR_U32(ctx, 5), 28), GPR_U32(ctx, 3));
    // 0x1f8234: 0x8c820020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1f8238: 0xaca20024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 2));
    // 0x1f823c: 0x8c830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 36)));
    // 0x1f8240: 0xaca3000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 3));
    // 0x1f8244: 0x8c820028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 40)));
    // 0x1f8248: 0xaca20028
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 2));
    // 0x1f824c: 0x8c83002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 44)));
    // 0x1f8250: 0xaca3002c
    WRITE32(ADD32(GPR_U32(ctx, 5), 44), GPR_U32(ctx, 3));
    // 0x1f8254: 0x8c820030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x1f8258: 0xaca20030
    WRITE32(ADD32(GPR_U32(ctx, 5), 48), GPR_U32(ctx, 2));
    // 0x1f825c: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1f8260: 0xaca30034
    WRITE32(ADD32(GPR_U32(ctx, 5), 52), GPR_U32(ctx, 3));
    // 0x1f8264: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f8268: 0x4800006
    if (GPR_S32(ctx, 4) < 0) {
        goto label_1f8284;
    }
    // 0x1f8270: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x1f8274: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f8284;
    }
    // 0x1f827c: 0x807dc74
    iWakeupThread(rdram, ctx, runtime); return;
label_1f8284:
    // 0x1f8284: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f828c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8290; return;
}


// Function: sceSifCallRpc
// Address: 0x1f8290 - 0x1f82e8
// STUBBED: Redirect to ps2_stubs for sound bank loading

void entry_1f82e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f82e8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f82ec: 0x12000057
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F844C; return;
    }
    // 0x1f82f4: 0x8fa200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f82f8: 0x33c40002
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 30), 2));
    // 0x1f82fc: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1f8300: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x1f8304: 0xae300000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 16));
    // 0x1f8308: 0xae230004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
    // 0x1f830c: 0xae37001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 23));
    // 0x1f8310: 0xae160020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 22));
    // 0x1f8314: 0xae120024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 18));
    // 0x1f8318: 0xae140028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 20));
    // 0x1f831c: 0xae13002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 19));
    // 0x1f8320: 0xae100014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 16));
    // 0x1f8324: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1f8328: 0xae11001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 17));
    // 0x1f832c: 0x14800011
    WRITE32(ADD32(GPR_U32(ctx, 16), 52), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        entry_1f8374(rdram, ctx, runtime); return;
    }
    // 0x1f8334: 0x16b40007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 20)) {
        ctx->pc = 0x1F8354; return;
    }
    // 0x1f833c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f8340: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f8344: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f834c);
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 18));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f834c
// Address: 0x1f834c - 0x1f8364

void entry_1f834c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f834c) {
        switch (ctx->pc) {
            case 0x1f8354: ctx->pc = 0; goto label_1f8354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f834c: 0x1000000a
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 30), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8378; return;
    }
label_1f8354:
    // 0x1f8354: 0x1a400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        entry_1f8364(rdram, ctx, runtime); return;
    }
    // 0x1f835c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f8364);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f8364
// Address: 0x1f8364 - 0x1f8374

void entry_1f8364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8364: 0x1a600003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        entry_1f8374(rdram, ctx, runtime); return;
    }
    // 0x1f836c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f8374);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f8374
// Address: 0x1f8374 - 0x1f83bc

void entry_1f8374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8374) {
        switch (ctx->pc) {
            case 0x1f8378: ctx->pc = 0; goto label_1f8378;
            case 0x1f8390: ctx->pc = 0; goto label_1f8390;
            case 0x1f8394: ctx->pc = 0; goto label_1f8394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8374: 0x33c20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 30), 1));
label_1f8378:
    // 0x1f8378: 0x50400014
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x1F83CC; return;
    }
    // 0x1f8380: 0x16e00003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_1f8390;
    }
    // 0x1f8388: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8394;
    }
label_1f8390:
    // 0x1f8390: 0xae020030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 2));
label_1f8394:
    // 0x1f8394: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8398: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f839c: 0x8e280014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1f83a0: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f83a4: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x1f83a8: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f83ac: 0x3484000a
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 10));
    // 0x1f83b0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f83b4: 0xc07e98c
    SET_GPR_U32(ctx, 31, 0x1f83bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f83bc
// Address: 0x1f83bc - 0x1f83dc

void entry_1f83bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f83bc) {
        switch (ctx->pc) {
            case 0x1f83cc: ctx->pc = 0; goto label_1f83cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f83bc: 0x14400023
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F844C; return;
    }
    // 0x1f83c4: 0x10000018
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f8428(rdram, ctx, runtime); return;
    }
label_1f83cc:
    // 0x1f83cc: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1f83d0: 0xafb30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 19));
    // 0x1f83d4: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f83dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f83dc
// Address: 0x1f83dc - 0x1f83ec

void entry_1f83dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f83dc: 0x4410005
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F83F4; return;
    }
    // 0x1f83e4: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f83ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f83ec
// Address: 0x1f83ec - 0x1f8418

void entry_1f83ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f83ec) {
        switch (ctx->pc) {
            case 0x1f83f4: ctx->pc = 0; goto label_1f83f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f83ec: 0x10000017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967293));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F844C; return;
    }
label_1f83f4:
    // 0x1f83f4: 0xae130030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 19));
    // 0x1f83f8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f83fc: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f8400: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f8404: 0x8e280014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1f8408: 0x3484000a
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 10));
    // 0x1f840c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f8410: 0xc07e98c
    SET_GPR_U32(ctx, 31, 0x1f8418);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1f8418
// Address: 0x1f8418 - 0x1f8428

void entry_1f8418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8418: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8438; return;
    }
    // 0x1f8420: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8428);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8428
// Address: 0x1f8428 - 0x1f8430

void entry_1f8428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8428: 0xc07df96
    SET_GPR_U32(ctx, 31, 0x1f8430);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sceRpcFreePacket(rdram, ctx, runtime); return;
}


// Function: entry_1f8430
// Address: 0x1f8430 - 0x1f8440

void entry_1f8430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8430) {
        switch (ctx->pc) {
            case 0x1f8438: ctx->pc = 0; goto label_1f8438;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8430: 0x10000006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F844C; return;
    }
label_1f8438:
    // 0x1f8438: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8440);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8440
// Address: 0x1f8440 - 0x1f8448

void entry_1f8440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8440: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8448);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8448
// Address: 0x1f8448 - 0x1f8480

void entry_1f8448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8448) {
        switch (ctx->pc) {
            case 0x1f844c: ctx->pc = 0; goto label_1f844c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8448: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f844c:
    // 0x1f844c: 0xdfbf00b0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f8450: 0xdfbe00a0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f8454: 0xdfb70090
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f8458: 0xdfb60080
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f845c: 0xdfb50070
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f8460: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f8464: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f8468: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f846c: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f8470: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f8474: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f847c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8480; return;
}


// Function: sceSifCheckStatRpc
// Address: 0x1f8480 - 0x1f84d8
// STUBBED: Always return "RPC complete" (0)

void entry_1f8510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8510: 0xae0271c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 29120), GPR_U32(ctx, 2));
    // 0x1f8514: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f851c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f851c
// Address: 0x1f851c - 0x1f8538

void entry_1f851c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f851c) {
        switch (ctx->pc) {
            case 0x1f8528: ctx->pc = 0; goto label_1f8528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f851c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f8520: 0xac6271c4
    WRITE32(ADD32(GPR_U32(ctx, 3), 29124), GPR_U32(ctx, 2));
    // 0x1f8524: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
label_1f8528:
    // 0x1f8528: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f852c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8534: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8538; return;
}


// Function: get_iob
// Address: 0x1f8538 - 0x1f8554

void entry_1f8554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8554: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f855c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 29120)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f855c
// Address: 0x1f855c - 0x1f8570

void entry_1f855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f855c: 0x2e030020
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 16), 32));
    // 0x1f8560: 0x14600005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8578; return;
    }
    // 0x1f8568: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f8570);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 29120)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8570
// Address: 0x1f8570 - 0x1f858c

void entry_1f8570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8570) {
        switch (ctx->pc) {
            case 0x1f8578: ctx->pc = 0; goto label_1f8578;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8570: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8590; return;
    }
label_1f8578:
    // 0x1f8578: 0x108100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 4));
    // 0x1f857c: 0x24428940
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294936896));
    // 0x1f8580: 0x8e2471c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 29120)));
    // 0x1f8584: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f858c);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f858c
// Address: 0x1f858c - 0x1f85a8

void entry_1f858c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f858c) {
        switch (ctx->pc) {
            case 0x1f8590: ctx->pc = 0; goto label_1f8590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f858c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1f8590:
    // 0x1f8590: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f8594: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f8598: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f859c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f85a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f85a8; return;
}


// Function: FUN_001f85a8
// Address: 0x1f85a8 - 0x1f8634

void FUN_001f85a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f85a8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f85ac: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1f85b0: 0x24468500
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294935808));
    // 0x1f85b4: 0x3c072000
    SET_GPR_U32(ctx, 7, ((uint32_t)8192 << 16));
    // 0x1f85b8: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1f85bc: 0xc72825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    // 0x1f85c0: 0x88a20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f85c4: 0x98a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1f85c8: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f85cc: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1f85d0: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f85d4: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1f85d8: 0x24c40008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 8));
    // 0x1f85dc: 0x88650003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f85e0: 0x98650000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x1f85e4: 0xaba50007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f85e8: 0xbba50004
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 4); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f85ec: 0x872025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 7)));
    // 0x1f85f0: 0x24c2000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 12));
    // 0x1f85f4: 0x88830003
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f85f8: 0x98830000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1f85fc: 0xaba3000b
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 11); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8600: 0xbba30008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8604: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1f8608: 0x884a0003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 10, (GPR_U32(ctx,10) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f860c: 0x984a0000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 10, (GPR_U32(ctx,10) & ~mask) | (word << shift)); }
    // 0x1f8610: 0xabaa000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 10) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8614: 0xbbaa000c
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 12); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 10) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8618: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f861c: 0x4600005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_S32(ctx, 3) < 0) {
        entry_1f8634(rdram, ctx, runtime); return;
    }
    // 0x1f8624: 0x24c50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1f8628: 0x8fa6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1f862c: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1f8634);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1f8634
// Address: 0x1f8634 - 0x1f88e8

void entry_1f8634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8634) {
        switch (ctx->pc) {
            case 0x1f8690: ctx->pc = 0; goto label_1f8690;
            case 0x1f86b0: ctx->pc = 0; goto label_1f86b0;
            case 0x1f86b4: ctx->pc = 0; goto label_1f86b4;
            case 0x1f86d0: ctx->pc = 0; goto label_1f86d0;
            case 0x1f8734: ctx->pc = 0; goto label_1f8734;
            case 0x1f8790: ctx->pc = 0; goto label_1f8790;
            case 0x1f87c4: ctx->pc = 0; goto label_1f87c4;
            case 0x1f88dc: ctx->pc = 0; goto label_1f88dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8634: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f8638: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x1f863c: 0x2c830019
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 25));
    // 0x1f8640: 0x106000a9
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1f88e8(rdram, ctx, runtime); return;
    }
    // 0x1f8648: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1f864c: 0x2442eb10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961936));
    // 0x1f8650: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f8654: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f8658: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1f8660: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f8664: 0x3c032000
    SET_GPR_U32(ctx, 3, ((uint32_t)8192 << 16));
    // 0x1f8668: 0x24428514
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935828));
    // 0x1f866c: 0x433025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f8670: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f8674: 0x5840000f
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
        goto label_1f86b4;
    }
    // 0x1f867c: 0x8cc80008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1f8680: 0x1840000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1f86b0;
    }
    // 0x1f8688: 0x24c70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1f868c: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
label_1f8690:
    // 0x1f8690: 0x1052021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x1f8694: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f8698: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f869c: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f86a0: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f86a4: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1f86a8: 0x1440fff9
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f8690;
    }
label_1f86b0:
    // 0x1f86b0: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
label_1f86b4:
    // 0x1f86b4: 0x1840008d
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F88EC; return;
    }
    // 0x1f86bc: 0x8cc8000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1f86c0: 0x1840008a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1F88EC; return;
    }
    // 0x1f86c8: 0x24c70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 80));
    // 0x1f86cc: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
label_1f86d0:
    // 0x1f86d0: 0x1052021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x1f86d4: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f86d8: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f86dc: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f86e0: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x1f86e4: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1f86e8: 0x1440fff9
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f86d0;
    }
    // 0x1f86f0: 0x1000007e
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F88EC; return;
    }
    // 0x1f86f8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f86fc: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1f8700: 0x24428514
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935828));
    // 0x1f8704: 0x441825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f8708: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1f870c: 0x88660003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f8710: 0x98660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f8714: 0xaba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8718: 0xbba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f871c: 0x441825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f8720: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f8724: 0x641025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f8728: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x1f872c: 0x10400018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f8790;
    }
label_1f8734:
    // 0x1f8734: 0x686a0007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f8738: 0x6c6a0000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f873c: 0x6865000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1f8740: 0x6c650008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1f8744: 0x68660017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f8748: 0x6c660010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f874c: 0x6867001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f8750: 0x6c670018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f8754: 0xb08a0007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8758: 0xb48a0000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f875c: 0xb085000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8760: 0xb4850008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8764: 0xb0860017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8768: 0xb4860010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f876c: 0xb087001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8770: 0xb4870018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8774: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1f8778: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f877c: 0x0
    // NOP
    // 0x1f8780: 0x1462ffec
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f8734;
    }
    // 0x1f8788: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f87c4;
    }
label_1f8790:
    // 0x1f8790: 0xdc680000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f8794: 0xdc690008
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1f8798: 0xdc6a0010
    SET_GPR_U64(ctx, 10, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1f879c: 0xdc650018
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1f87a0: 0xfc880000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 8));
    // 0x1f87a4: 0xfc890008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 9));
    // 0x1f87a8: 0xfc8a0010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 10));
    // 0x1f87ac: 0xfc850018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 5));
    // 0x1f87b0: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1f87b4: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f87b8: 0x0
    // NOP
    // 0x1f87bc: 0x1462fff4
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f8790;
    }
label_1f87c4:
    // 0x1f87c4: 0x88660003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f87c8: 0x98660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f87cc: 0xa8860003
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f87d0: 0x10000045
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f88e8(rdram, ctx, runtime); return;
    }
    // 0x1f87d8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f87dc: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1f87e0: 0x24428514
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935828));
    // 0x1f87e4: 0x441825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f87e8: 0x886a0003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 10, (GPR_U32(ctx,10) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f87ec: 0x986a0000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 10, (GPR_U32(ctx,10) & ~mask) | (word << shift)); }
    // 0x1f87f0: 0xabaa0013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 10) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f87f4: 0xbbaa0010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 10) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f87f8: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1f87fc: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f8800: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f8804: 0x68480007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f8808: 0x6c480000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f880c: 0x6849000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f8810: 0x6c490008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f8814: 0x684a0017
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f8818: 0x6c4a0010
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f881c: 0x6844001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1f8820: 0x6c440018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1f8824: 0xb0680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8828: 0xb4680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f882c: 0xb069000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8830: 0xb4690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8834: 0xb06a0017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8838: 0xb46a0010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f883c: 0xb064001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8840: 0xb4640018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8844: 0x68480027
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f8848: 0x6c480020
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f884c: 0x6849002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f8850: 0x6c490028
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f8854: 0x684a0037
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f8858: 0x6c4a0030
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x1f885c: 0x6844003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1f8860: 0x6c440038
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1f8864: 0xb0680027
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8868: 0xb4680020
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f886c: 0xb069002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8870: 0xb4690028
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8874: 0xb06a0037
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 55); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8878: 0xb46a0030
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 48); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f887c: 0xb064003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f8880: 0x10000019
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f88e8(rdram, ctx, runtime); return;
    }
    // 0x1f8888: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f888c: 0x3c072000
    SET_GPR_U32(ctx, 7, ((uint32_t)8192 << 16));
    // 0x1f8890: 0x24458514
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294935828));
    // 0x1f8894: 0xa71825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1f8898: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1f889c: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1f88a0: 0x88660003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f88a4: 0x98660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f88a8: 0xaba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f88ac: 0xbba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f88b0: 0x88430003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f88b4: 0x98430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1f88b8: 0xaba30017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f88bc: 0xbba30014
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 20); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f88c0: 0x8fa60014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1f88c4: 0x2cc20401
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 1025));
    // 0x1f88c8: 0x14400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f88dc;
    }
    // 0x1f88d0: 0x24020400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1f88d4: 0x24060400
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1f88d8: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
label_1f88dc:
    // 0x1f88dc: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f88e0: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1f88e8);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1f88e8
// Address: 0x1f88e8 - 0x1f895c

void entry_1f88e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f88e8) {
        switch (ctx->pc) {
            case 0x1f88ec: ctx->pc = 0; goto label_1f88ec;
            case 0x1f8920: ctx->pc = 0; goto label_1f8920;
            case 0x1f8924: ctx->pc = 0; goto label_1f8924;
            case 0x1f8954: ctx->pc = 0; goto label_1f8954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f88e8: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_1f88ec:
    // 0x1f88ec: 0x4810019
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1f8954;
    }
    // 0x1f88f4: 0x41023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x1f88f8: 0x8ce37138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 28984)));
    // 0x1f88fc: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8900: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1f8904: 0x14660006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 6)) {
        goto label_1f8920;
    }
    // 0x1f890c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8910: 0xace27138
    WRITE32(ADD32(GPR_U32(ctx, 7), 28984), GPR_U32(ctx, 2));
    // 0x1f8914: 0x10000012
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8960; return;
    }
    // 0x1f891c: 0x0
    // NOP
label_1f8920:
    // 0x1f8920: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_1f8924:
    // 0x1f8924: 0x28a20020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 32));
    // 0x1f8928: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 28984));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1f895c(rdram, ctx, runtime); return;
    }
    // 0x1f8930: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1f8934: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f8938: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f893c: 0x1486fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 6)) {
        goto label_1f8924;
    }
    // 0x1f8944: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8948: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1f894c: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8960; return;
    }
label_1f8954:
    // 0x1f8954: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x1f895c);
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f895c
// Address: 0x1f895c - 0x1f8968

void entry_1f895c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f895c) {
        switch (ctx->pc) {
            case 0x1f8960: ctx->pc = 0; goto label_1f8960;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f895c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_1f8960:
    // 0x1f8960: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _sceFsSemInit
// Address: 0x1f8968 - 0x1f89a0

void entry_1f89a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f89a0) {
        switch (ctx->pc) {
            case 0x1f89a8: ctx->pc = 0; goto label_1f89a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f89a0: 0xae0271bc
    WRITE32(ADD32(GPR_U32(ctx, 16), 29116), GPR_U32(ctx, 2));
    // 0x1f89a4: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
label_1f89a8:
    // 0x1f89a8: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f89ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f89b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f89b8; return;
}


// Function: _sceFsWaitS
// Address: 0x1f89b8 - 0x1f89c8

void entry_1f89c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f89c8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f89cc: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f89d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 29116)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f89d4
// Address: 0x1f89d4 - 0x1f89e8

void entry_1f89d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f89d4: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f89d8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f89dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f89e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f89e8; return;
}


// Function: _sceFsSigSema
// Address: 0x1f89e8 - 0x1f8a10

void entry_1f8a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a10: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1f8a14: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x1f8a18: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f8a1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8a24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8a28; return;
}


// Function: FUN_001f8a28
// Address: 0x1f8a28 - 0x1f8a54

void FUN_001f8a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a28: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x1f8a2c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8a30: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x1f8a34: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x1f8a38: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x1f8a3c: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x1f8a40: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x1f8a44: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x1f8a48: 0xffbf0060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 31));
    // 0x1f8a4c: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x1f8a54);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294937536));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f8a54
// Address: 0x1f8a54 - 0x1f8a60

void entry_1f8a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a54: 0xae008bc0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294937536), GPR_U32(ctx, 0));
    // 0x1f8a58: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x1f8a60);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f8a60
// Address: 0x1f8a60 - 0x1f8a7c

void entry_1f8a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a60: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x1f8a64: 0x3c060063
    SET_GPR_U32(ctx, 6, ((uint32_t)99 << 16));
    // 0x1f8a68: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f8a6c: 0x24a585a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935976));
    // 0x1f8a70: 0x24c68b80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937472));
    // 0x1f8a74: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f8a7c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 17));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f8a7c
// Address: 0x1f8a7c - 0x1f8a94

void entry_1f8a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a7c: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x1f8a80: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f8a84: 0x24a589f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937080));
    // 0x1f8a88: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f8a8c: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x1f8a94);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 19));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_1f8a94
// Address: 0x1f8a94 - 0x1f8a9c

void entry_1f8a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8a94: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1f8a9c);
    SET_GPR_U32(ctx, 19, ((uint32_t)99 << 16));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1f8a9c
// Address: 0x1f8a9c - 0x1f8ae4

void entry_1f8a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8a9c) {
        switch (ctx->pc) {
            case 0x1f8aa8: ctx->pc = 0; goto label_1f8aa8;
            case 0x1f8ab0: ctx->pc = 0; goto label_1f8ab0;
            case 0x1f8ad0: ctx->pc = 0; goto label_1f8ad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8a9c: 0x1000000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 4294937408));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8ad0;
    }
    // 0x1f8aa4: 0x0
    // NOP
label_1f8aa8:
    // 0x1f8aa8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8aac: 0x0
    // NOP
label_1f8ab0:
    // 0x1f8ab0: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1f8ab4: 0x0
    // NOP
    // 0x1f8ab8: 0x0
    // NOP
    // 0x1f8abc: 0x0
    // NOP
    // 0x1f8ac0: 0x0
    // NOP
    // 0x1f8ac4: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1f8ab0;
    }
    // 0x1f8acc: 0x26708b40
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 4294937408));
label_1f8ad0:
    // 0x1f8ad0: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x1f8ad4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f8ad8: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x1f8adc: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x1f8ae4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f8ae4
// Address: 0x1f8ae4 - 0x1f8b00

void entry_1f8ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8ae4: 0x440003a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F8BD0; return;
    }
    // 0x1f8aec: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1f8af0: 0x1040ffed
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8AA8; return;
    }
    // 0x1f8af8: 0xc07e136
    SET_GPR_U32(ctx, 31, 0x1f8b00);
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    _sceFsIobSemaMK(rdram, ctx, runtime); return;
}


// Function: entry_1f8b00
// Address: 0x1f8b00 - 0x1f8b08

void entry_1f8b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8b00: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8b08);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 29120)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8b08
// Address: 0x1f8b08 - 0x1f8b60

void entry_1f8b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8b08) {
        switch (ctx->pc) {
            case 0x1f8b28: ctx->pc = 0; goto label_1f8b28;
            case 0x1f8b4c: ctx->pc = 0; goto label_1f8b4c;
            case 0x1f8b58: ctx->pc = 0; goto label_1f8b58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8b08: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1f8b0c: 0x24638940
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294936896));
    // 0x1f8b10: 0x24640200
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 512));
    // 0x1f8b14: 0x64102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f8b18: 0x1040000c
    SET_GPR_U32(ctx, 18, ((uint32_t)98 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f8b4c;
    }
    // 0x1f8b20: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
    // 0x1f8b24: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
label_1f8b28:
    // 0x1f8b28: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x1f8b2c: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1f8b30: 0x64102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f8b34: 0x0
    // NOP
    // 0x1f8b38: 0x0
    // NOP
    // 0x1f8b3c: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f8b28;
    }
    // 0x1f8b44: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 29120)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8b58;
    }
label_1f8b4c:
    // 0x1f8b4c: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
    // 0x1f8b50: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x1f8b54: 0x8e8471c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 29120)));
label_1f8b58:
    // 0x1f8b58: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f8b60);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294935744));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8b60
// Address: 0x1f8b60 - 0x1f8b90

void entry_1f8b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8b60: 0x26238500
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294935808));
    // 0x1f8b64: 0x26648b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294937408));
    // 0x1f8b68: 0xae437840
    WRITE32(ADD32(GPR_U32(ctx, 18), 30784), GPR_U32(ctx, 3));
    // 0x1f8b6c: 0x26477840
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 30784));
    // 0x1f8b70: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f8b74: 0x240500ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1f8b78: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8b7c: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8b80: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f8b84: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8b88: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f8b90);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f8b90
// Address: 0x1f8b90 - 0x1f8bf8

void entry_1f8b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8b90) {
        switch (ctx->pc) {
            case 0x1f8ba4: ctx->pc = 0; goto label_1f8ba4;
            case 0x1f8bd0: ctx->pc = 0; goto label_1f8bd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8b90: 0x4430004
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
        goto label_1f8ba4;
    }
    // 0x1f8b98: 0x3c02fffe
    SET_GPR_U32(ctx, 2, ((uint32_t)65534 << 16));
    // 0x1f8b9c: 0x1000000c
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8bd0;
    }
label_1f8ba4:
    // 0x1f8ba4: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
    // 0x1f8ba8: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f8bac: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1f8bb0: 0x24a98b68
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 4294937448));
    // 0x1f8bb4: 0x88460003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f8bb8: 0x98460000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1f8bbc: 0xa9260003
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8bc0: 0xb9260000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f8bc4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f8bc8: 0xac8371b8
    WRITE32(ADD32(GPR_U32(ctx, 4), 29112), GPR_U32(ctx, 3));
    // 0x1f8bcc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f8bd0:
    // 0x1f8bd0: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f8bd4: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f8bd8: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f8bdc: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f8be0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f8be4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f8be8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8bf0: 0x27bd0050
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1f8bf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8bf8; return;
}


// Function: sceFsReset
// Address: 0x1f8bf8 - 0x1f8c1c

void entry_1f8c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8c1c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f8c20: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8c24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8c2c: 0x0
    // NOP
    // 0x1f8c30: 0x27bd0150
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    // 0x1f8c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8c38; return;
}


// Function: sceClose
// Address: 0x1f8c38 - 0x1f8c60

void entry_1f8c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8c60: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8c64: 0xc07e26e
    SET_GPR_U32(ctx, 31, 0x1f8c6c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    _sceFsWaitS(rdram, ctx, runtime); return;
}


// Function: entry_1f8c6c
// Address: 0x1f8c6c - 0x1f8c84

void entry_1f8c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8c6c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f8c70: 0x8c6271b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 29112)));
    // 0x1f8c74: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8C8C; return;
    }
    // 0x1f8c7c: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8c84);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8c84
// Address: 0x1f8c84 - 0x1f8ca8

void entry_1f8c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8c84) {
        switch (ctx->pc) {
            case 0x1f8c8c: ctx->pc = 0; goto label_1f8c8c;
            case 0x1f8ca0: ctx->pc = 0; goto label_1f8ca0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8c84: 0x10000043
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8D94; return;
    }
label_1f8c8c:
    // 0x1f8c8c: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1f8ca0;
    }
    // 0x1f8c94: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f8c98: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F8CB0; return;
    }
label_1f8ca0:
    // 0x1f8ca0: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8ca8);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8ca8
// Address: 0x1f8ca8 - 0x1f8ce0

void entry_1f8ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8ca8) {
        switch (ctx->pc) {
            case 0x1f8cb0: ctx->pc = 0; goto label_1f8cb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8ca8: 0x1000003a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967287));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8D94; return;
    }
label_1f8cb0:
    // 0x1f8cb0: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f8cb4: 0x24428940
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294936896));
    // 0x1f8cb8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f8cbc: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x1f8cc0: 0x2021023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f8cc4: 0xafa40014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 4));
    // 0x1f8cc8: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1f8ccc: 0xae420010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 2));
    // 0x1f8cd0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f8cd4: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1f8cd8: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f8ce0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8ce0
// Address: 0x1f8ce0 - 0x1f8d2c

void entry_1f8ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8ce0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8ce4: 0x27a30030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f8ce8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f8cec: 0xae917880
    WRITE32(ADD32(GPR_U32(ctx, 20), 30848), GPR_U32(ctx, 17));
    // 0x1f8cf0: 0x245384c0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294935744));
    // 0x1f8cf4: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x1f8cf8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8cfc: 0xae430004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 3));
    // 0x1f8d00: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x1f8d04: 0x24848b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937408));
    // 0x1f8d08: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f8d0c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f8d10: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f8d14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8d18: 0x24080014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1f8d1c: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f8d20: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8d24: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f8d2c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f8d2c
// Address: 0x1f8d2c - 0x1f8d3c

void entry_1f8d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8d2c: 0x4430007
    if (GPR_S32(ctx, 2) >= 0) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
        ctx->pc = 0x1F8D4C; return;
    }
    // 0x1f8d34: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8d3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d3c
// Address: 0x1f8d3c - 0x1f8d44

void entry_1f8d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8d3c: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8d44);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d44
// Address: 0x1f8d44 - 0x1f8d5c

void entry_1f8d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8d44) {
        switch (ctx->pc) {
            case 0x1f8d4c: ctx->pc = 0; goto label_1f8d4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8d44: 0x10000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8D94; return;
    }
label_1f8d4c:
    // 0x1f8d4c: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x1f8d50: 0x2621025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1f8d54: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8d5c);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d5c
// Address: 0x1f8d5c - 0x1f8d6c

void entry_1f8d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8d5c: 0x16000005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8D74; return;
    }
    // 0x1f8d64: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8d6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d6c
// Address: 0x1f8d6c - 0x1f8d7c

void entry_1f8d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8d6c) {
        switch (ctx->pc) {
            case 0x1f8d74: ctx->pc = 0; goto label_1f8d74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8d6c: 0x10000009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8D94; return;
    }
label_1f8d74:
    // 0x1f8d74: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8d7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d7c
// Address: 0x1f8d7c - 0x1f8d84

void entry_1f8d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8d7c: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8d84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8d84
// Address: 0x1f8d84 - 0x1f8db8

void entry_1f8d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8d84) {
        switch (ctx->pc) {
            case 0x1f8d94: ctx->pc = 0; goto label_1f8d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8d84: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f8d88: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8d8c: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1f8d90: 0x3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
label_1f8d94:
    // 0x1f8d94: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f8d98: 0xdfb40080
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f8d9c: 0xdfb30070
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f8da0: 0xdfb20060
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f8da4: 0xdfb10050
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f8da8: 0xdfb00040
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f8dac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f8db4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f8db8; return;
}


// Function: sceRead
// Address: 0x1f8db8 - 0x1f8df8

void entry_1f8df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8df8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8dfc: 0xc07e26e
    SET_GPR_U32(ctx, 31, 0x1f8e04);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    _sceFsWaitS(rdram, ctx, runtime); return;
}


// Function: entry_1f8e04
// Address: 0x1f8e04 - 0x1f8e1c

void entry_1f8e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8e04: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f8e08: 0x8c6271b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 29112)));
    // 0x1f8e0c: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8E24; return;
    }
    // 0x1f8e14: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8e1c);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8e1c
// Address: 0x1f8e1c - 0x1f8e40

void entry_1f8e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8e1c) {
        switch (ctx->pc) {
            case 0x1f8e24: ctx->pc = 0; goto label_1f8e24;
            case 0x1f8e38: ctx->pc = 0; goto label_1f8e38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8e1c: 0x10000076
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FF8; return;
    }
label_1f8e24:
    // 0x1f8e24: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1f8e38;
    }
    // 0x1f8e2c: 0x8e130004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f8e30: 0x56600005
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F8E48; return;
    }
label_1f8e38:
    // 0x1f8e38: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8e40);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8e40
// Address: 0x1f8e40 - 0x1f8e80

void entry_1f8e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8e40) {
        switch (ctx->pc) {
            case 0x1f8e48: ctx->pc = 0; goto label_1f8e48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8e40: 0x1000006d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967287));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FF8; return;
    }
label_1f8e48:
    // 0x1f8e48: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f8e4c: 0x24428940
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294936896));
    // 0x1f8e50: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f8e54: 0xae23000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 3));
    // 0x1f8e58: 0x2021023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f8e5c: 0xafa40014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 4));
    // 0x1f8e60: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1f8e64: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x1f8e68: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f8e6c: 0xae360010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 22));
    // 0x1f8e70: 0xae370014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 23));
    // 0x1f8e74: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1f8e78: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f8e80);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8e80
// Address: 0x1f8e80 - 0x1f8eac

void entry_1f8e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8e80: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f8e84: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8e88: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f8e8c: 0xae230008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 3));
    // 0x1f8e90: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x1f8e94: 0x32628000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 32768));
    // 0x1f8e98: 0x10400021
    WRITE32(ADD32(GPR_U32(ctx, 20), 30848), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8F20; return;
    }
    // 0x1f8ea0: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1f8ea4: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8eac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 29124)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8eac
// Address: 0x1f8eac - 0x1f8f18

void entry_1f8eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8eac) {
        switch (ctx->pc) {
            case 0x1f8ed8: ctx->pc = 0; goto label_1f8ed8;
            case 0x1f8edc: ctx->pc = 0; goto label_1f8edc;
            case 0x1f8f10: ctx->pc = 0; goto label_1f8f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8eac: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1f8eb0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8eb4: 0x8ce37138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 28984)));
    // 0x1f8eb8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8ebc: 0x14620006
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f8ed8;
    }
    // 0x1f8ec4: 0x8e837880
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 30848)));
    // 0x1f8ec8: 0x31023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1f8ecc: 0xace37138
    WRITE32(ADD32(GPR_U32(ctx, 7), 28984), GPR_U32(ctx, 3));
    // 0x1f8ed0: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 20), 30848), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8f10;
    }
label_1f8ed8:
    // 0x1f8ed8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_1f8edc:
    // 0x1f8edc: 0x28c20020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 32));
    // 0x1f8ee0: 0x1040000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f8f10;
    }
    // 0x1f8ee8: 0x24e37138
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 28984));
    // 0x1f8eec: 0x432821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f8ef0: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f8ef4: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f8ef8: 0x1444fff8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1f8edc;
    }
    // 0x1f8f00: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f8f04: 0x21823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1f8f08: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1f8f0c: 0xae230000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
label_1f8f10:
    // 0x1f8f10: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f8f18);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 29124)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8f18
// Address: 0x1f8f18 - 0x1f8f40

void entry_1f8f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8f18) {
        switch (ctx->pc) {
            case 0x1f8f20: ctx->pc = 0; goto label_1f8f20;
            case 0x1f8f28: ctx->pc = 0; goto label_1f8f28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8f18: 0x10000003
    SET_GPR_U32(ctx, 21, ((uint32_t)8192 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f8f28;
    }
label_1f8f20:
    // 0x1f8f20: 0x3c1e0063
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
    // 0x1f8f24: 0x3c152000
    SET_GPR_U32(ctx, 21, ((uint32_t)8192 << 16));
label_1f8f28:
    // 0x1f8f28: 0x2751024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 21)));
    // 0x1f8f2c: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8F44; return;
    }
    // 0x1f8f34: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1f8f38: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f8f40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f8f40
// Address: 0x1f8f40 - 0x1f8f54

void entry_1f8f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8f40) {
        switch (ctx->pc) {
            case 0x1f8f44: ctx->pc = 0; goto label_1f8f44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8f40: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
label_1f8f44:
    // 0x1f8f44: 0x240500a4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 164));
    // 0x1f8f48: 0x24448500
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294935808));
    // 0x1f8f4c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f8f54);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 30), 4294935744));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f8f54
// Address: 0x1f8f54 - 0x1f8f60

void entry_1f8f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8f54: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f8f58: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f8f60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f8f60
// Address: 0x1f8f60 - 0x1f8f8c

void entry_1f8f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8f60: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f8f64: 0x26877880
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 30848));
    // 0x1f8f68: 0x24448b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937408));
    // 0x1f8f6c: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f8f70: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f8f74: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f8f78: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1f8f7c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f8f80: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f8f84: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f8f8c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f8f8c
// Address: 0x1f8f8c - 0x1f8f9c

void entry_1f8f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8f8c: 0x4410007
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 21), GPR_U32(ctx, 16)));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F8FAC; return;
    }
    // 0x1f8f94: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8f9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8f9c
// Address: 0x1f8f9c - 0x1f8fa4

void entry_1f8f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8f9c: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8fa4);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8fa4
// Address: 0x1f8fa4 - 0x1f8fb4

void entry_1f8fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8fa4) {
        switch (ctx->pc) {
            case 0x1f8fac: ctx->pc = 0; goto label_1f8fac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8fa4: 0x10000014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FF8; return;
    }
label_1f8fac:
    // 0x1f8fac: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f8fb4);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8fb4
// Address: 0x1f8fb4 - 0x1f8fc4

void entry_1f8fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8fb4: 0x16000005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 32768));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FCC; return;
    }
    // 0x1f8fbc: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8fc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8fc4
// Address: 0x1f8fc4 - 0x1f8fdc

void entry_1f8fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8fc4) {
        switch (ctx->pc) {
            case 0x1f8fcc: ctx->pc = 0; goto label_1f8fcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8fc4: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FF8; return;
    }
label_1f8fcc:
    // 0x1f8fcc: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FE4; return;
    }
    // 0x1f8fd4: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8fdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8fdc
// Address: 0x1f8fdc - 0x1f8fec

void entry_1f8fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8fdc) {
        switch (ctx->pc) {
            case 0x1f8fe4: ctx->pc = 0; goto label_1f8fe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8fdc: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F8FF8; return;
    }
label_1f8fe4:
    // 0x1f8fe4: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f8fec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8fec
// Address: 0x1f8fec - 0x1f8ff4

void entry_1f8fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f8fec: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f8ff4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f8ff4
// Address: 0x1f8ff4 - 0x1f9028

void entry_1f8ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f8ff4) {
        switch (ctx->pc) {
            case 0x1f8ff8: ctx->pc = 0; goto label_1f8ff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f8ff4: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
label_1f8ff8:
    // 0x1f8ff8: 0xdfbf00d0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f8ffc: 0xdfbe00c0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f9000: 0xdfb700b0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f9004: 0xdfb600a0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f9008: 0xdfb50090
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f900c: 0xdfb40080
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f9010: 0xdfb30070
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f9014: 0xdfb20060
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f9018: 0xdfb10050
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f901c: 0xdfb00040
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f9020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f9028
// Address: 0x1f9028 - 0x1f9068

void FUN_001f9028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9028: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x1f902c: 0xffb50090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 21));
    // 0x1f9030: 0xffb10050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 17));
    // 0x1f9034: 0xc0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1f9038: 0xffb700b0
    WRITE64(ADD32(GPR_U32(ctx, 29), 176), GPR_U64(ctx, 23));
    // 0x1f903c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1f9040: 0xffb20060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 18));
    // 0x1f9044: 0x3c170062
    SET_GPR_U32(ctx, 23, ((uint32_t)98 << 16));
    // 0x1f9048: 0xffb00040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 16));
    // 0x1f904c: 0x26f27880
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 23), 30848));
    // 0x1f9050: 0xffbf00d0
    WRITE64(ADD32(GPR_U32(ctx, 29), 208), GPR_U64(ctx, 31));
    // 0x1f9054: 0xffbe00c0
    WRITE64(ADD32(GPR_U32(ctx, 29), 192), GPR_U64(ctx, 30));
    // 0x1f9058: 0xffb600a0
    WRITE64(ADD32(GPR_U32(ctx, 29), 160), GPR_U64(ctx, 22));
    // 0x1f905c: 0xffb40080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 20));
    // 0x1f9060: 0xc07e14e
    SET_GPR_U32(ctx, 31, 0x1f9068);
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 19));
    get_iob(rdram, ctx, runtime); return;
}


// Function: entry_1f9068
// Address: 0x1f9068 - 0x1f9074

void entry_1f9068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9068: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f906c: 0xc07e26e
    SET_GPR_U32(ctx, 31, 0x1f9074);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    _sceFsWaitS(rdram, ctx, runtime); return;
}


// Function: entry_1f9074
// Address: 0x1f9074 - 0x1f908c

void entry_1f9074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9074: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1f9078: 0x8c6271b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 29112)));
    // 0x1f907c: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9094; return;
    }
    // 0x1f9084: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f908c);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f908c
// Address: 0x1f908c - 0x1f90b0

void entry_1f908c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f908c) {
        switch (ctx->pc) {
            case 0x1f9094: ctx->pc = 0; goto label_1f9094;
            case 0x1f90a8: ctx->pc = 0; goto label_1f90a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f908c: 0x1000008a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92B8; return;
    }
label_1f9094:
    // 0x1f9094: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1f90a8;
    }
    // 0x1f909c: 0x8e160004
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f90a0: 0x56c00005
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1F90B8; return;
    }
label_1f90a8:
    // 0x1f90a8: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f90b0);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f90b0
// Address: 0x1f90b0 - 0x1f90f0

void entry_1f90b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f90b0) {
        switch (ctx->pc) {
            case 0x1f90b8: ctx->pc = 0; goto label_1f90b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f90b0: 0x10000081
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967287));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92B8; return;
    }
label_1f90b8:
    // 0x1f90b8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f90bc: 0x24428940
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294936896));
    // 0x1f90c0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f90c4: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x1f90c8: 0x2021023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f90cc: 0xafa40014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 4));
    // 0x1f90d0: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1f90d4: 0xae42002c
    WRITE32(ADD32(GPR_U32(ctx, 18), 44), GPR_U32(ctx, 2));
    // 0x1f90d8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f90dc: 0xae550014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 21));
    // 0x1f90e0: 0xae510010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 17));
    // 0x1f90e4: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1f90e8: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f90f0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f90f0
// Address: 0x1f90f0 - 0x1f911c

void entry_1f90f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f90f0: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f90f4: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f90f8: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f90fc: 0xae430008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 3));
    // 0x1f9100: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    // 0x1f9104: 0x32c28000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 22), 32768));
    // 0x1f9108: 0x10400024
    WRITE32(ADD32(GPR_U32(ctx, 23), 30848), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F919C; return;
    }
    // 0x1f9110: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x1f9114: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f911c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 29124)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f911c
// Address: 0x1f911c - 0x1f9194

void entry_1f911c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f911c) {
        switch (ctx->pc) {
            case 0x1f9150: ctx->pc = 0; goto label_1f9150;
            case 0x1f9158: ctx->pc = 0; goto label_1f9158;
            case 0x1f918c: ctx->pc = 0; goto label_1f918c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f911c: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1f9120: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9124: 0x8ce37138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 28984)));
    // 0x1f9128: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f912c: 0x14620008
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 17), 15));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f9150;
    }
    // 0x1f9134: 0x8ee37880
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 30848)));
    // 0x1f9138: 0x3c1e0063
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
    // 0x1f913c: 0x31023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1f9140: 0xace37138
    WRITE32(ADD32(GPR_U32(ctx, 7), 28984), GPR_U32(ctx, 3));
    // 0x1f9144: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 23), 30848), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f918c;
    }
    // 0x1f914c: 0x0
    // NOP
label_1f9150:
    // 0x1f9150: 0x3c1e0063
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
    // 0x1f9154: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_1f9158:
    // 0x1f9158: 0x28c20020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 32));
    // 0x1f915c: 0x1040000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f918c;
    }
    // 0x1f9164: 0x24e37138
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 28984));
    // 0x1f9168: 0x432821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f916c: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f9170: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f9174: 0x1444fff8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1f9158;
    }
    // 0x1f917c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1f9180: 0x21823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1f9184: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1f9188: 0xae430000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
label_1f918c:
    // 0x1f918c: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f9194);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 29124)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9194
// Address: 0x1f9194 - 0x1f91e0

void entry_1f9194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9194) {
        switch (ctx->pc) {
            case 0x1f919c: ctx->pc = 0; goto label_1f919c;
            case 0x1f91a4: ctx->pc = 0; goto label_1f91a4;
            case 0x1f91b4: ctx->pc = 0; goto label_1f91b4;
            case 0x1f91c0: ctx->pc = 0; goto label_1f91c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9194: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f91a4;
    }
label_1f919c:
    // 0x1f919c: 0x3230000f
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 17), 15));
    // 0x1f91a0: 0x3c1e0063
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
label_1f91a4:
    // 0x1f91a4: 0x16000003
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1f91b4;
    }
    // 0x1f91ac: 0x10000004
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f91c0;
    }
label_1f91b4:
    // 0x1f91b4: 0x2623fff0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294967280));
    // 0x1f91b8: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1f91bc: 0x438023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_1f91c0:
    // 0x1f91c0: 0x2b0182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 16)));
    // 0x1f91c4: 0x3c132000
    SET_GPR_U32(ctx, 19, ((uint32_t)8192 << 16));
    // 0x1f91c8: 0x2d31024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 22), GPR_U32(ctx, 19)));
    // 0x1f91cc: 0x14400004
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1f91e0(rdram, ctx, runtime); return;
    }
    // 0x1f91d4: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1f91d8: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f91e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f91e0
// Address: 0x1f91e0 - 0x1f9248

void entry_1f91e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f91e0) {
        switch (ctx->pc) {
            case 0x1f91f8: ctx->pc = 0; goto label_1f91f8;
            case 0x1f9218: ctx->pc = 0; goto label_1f9218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f91e0: 0x2338825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    // 0x1f91e4: 0xae500018
    WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 16));
    // 0x1f91e8: 0x1a00000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_1f9218;
    }
    // 0x1f91f0: 0x2646001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 28));
    // 0x1f91f4: 0x0
    // NOP
label_1f91f8:
    // 0x1f91f8: 0x2251021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 5)));
    // 0x1f91fc: 0xc52021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x1f9200: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f9204: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1f9208: 0xb0102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 16)));
    // 0x1f920c: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1f9210: 0x1440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f91f8;
    }
label_1f9218:
    // 0x1f9218: 0x27d084c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 30), 4294935744));
    // 0x1f921c: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f9220: 0x24448b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937408));
    // 0x1f9224: 0x26e77880
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 23), 30848));
    // 0x1f9228: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f922c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1f9230: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9234: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1f9238: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f923c: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f9240: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f9248);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f9248
// Address: 0x1f9248 - 0x1f9258

void entry_1f9248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9248: 0x4410007
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F9268; return;
    }
    // 0x1f9250: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f9258);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9258
// Address: 0x1f9258 - 0x1f9260

void entry_1f9258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9258: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f9260);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9260
// Address: 0x1f9260 - 0x1f9274

void entry_1f9260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9260) {
        switch (ctx->pc) {
            case 0x1f9268: ctx->pc = 0; goto label_1f9268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9260: 0x10000015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92B8; return;
    }
label_1f9268:
    // 0x1f9268: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1f926c: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f9274);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9274
// Address: 0x1f9274 - 0x1f9284

void entry_1f9274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9274: 0x16000005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 22), 32768));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F928C; return;
    }
    // 0x1f927c: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f9284);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9284
// Address: 0x1f9284 - 0x1f929c

void entry_1f9284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9284) {
        switch (ctx->pc) {
            case 0x1f928c: ctx->pc = 0; goto label_1f928c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9284: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92B8; return;
    }
label_1f928c:
    // 0x1f928c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92A4; return;
    }
    // 0x1f9294: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f929c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f929c
// Address: 0x1f929c - 0x1f92ac

void entry_1f929c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f929c) {
        switch (ctx->pc) {
            case 0x1f92a4: ctx->pc = 0; goto label_1f92a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f929c: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F92B8; return;
    }
label_1f92a4:
    // 0x1f92a4: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f92ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f92ac
// Address: 0x1f92ac - 0x1f92b4

void entry_1f92ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f92ac: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f92b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f92b4
// Address: 0x1f92b4 - 0x1f92e8

void entry_1f92b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f92b4) {
        switch (ctx->pc) {
            case 0x1f92b8: ctx->pc = 0; goto label_1f92b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f92b4: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
label_1f92b8:
    // 0x1f92b8: 0xdfbf00d0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1f92bc: 0xdfbe00c0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1f92c0: 0xdfb700b0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f92c4: 0xdfb600a0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f92c8: 0xdfb50090
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f92cc: 0xdfb40080
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f92d0: 0xdfb30070
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f92d4: 0xdfb20060
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f92d8: 0xdfb10050
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f92dc: 0xdfb00040
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f92e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceIoctl
// Address: 0x1f92e8 - 0x1f9328

void entry_1f9328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9328: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f932c: 0xc07e26e
    SET_GPR_U32(ctx, 31, 0x1f9334);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    _sceFsWaitS(rdram, ctx, runtime); return;
}


// Function: entry_1f9334
// Address: 0x1f9334 - 0x1f9350

void entry_1f9334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9334: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f9338: 0xae927844
    WRITE32(ADD32(GPR_U32(ctx, 20), 30788), GPR_U32(ctx, 18));
    // 0x1f933c: 0x8c4371b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 29112)));
    // 0x1f9340: 0x14600003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_1f9350(rdram, ctx, runtime); return;
    }
    // 0x1f9348: 0xc07e28a
    SET_GPR_U32(ctx, 31, 0x1f9350);
    FUN_001f8a28(rdram, ctx, runtime); return;
}


// Function: entry_1f9350
// Address: 0x1f9350 - 0x1f936c

void entry_1f9350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9350) {
        switch (ctx->pc) {
            case 0x1f9364: ctx->pc = 0; goto label_1f9364;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9350: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1f9364;
    }
    // 0x1f9358: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f935c: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 1044), GPR_U32(ctx, 0));
        ctx->pc = 0x1F9374; return;
    }
label_1f9364:
    // 0x1f9364: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f936c);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f936c
// Address: 0x1f936c - 0x1f93b4

void entry_1f936c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f936c) {
        switch (ctx->pc) {
            case 0x1f9374: ctx->pc = 0; goto label_1f9374;
            case 0x1f939c: ctx->pc = 0; goto label_1f939c;
            case 0x1f93ac: ctx->pc = 0; goto label_1f93ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f936c: 0x100000a7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967287));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F960C; return;
    }
label_1f9374:
    // 0x1f9374: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f9378: 0x12220029
    WRITE32(ADD32(GPR_U32(ctx, 19), 1048), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F9420; return;
    }
    // 0x1f9380: 0x2a220003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 3));
    // 0x1f9384: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f939c;
    }
    // 0x1f938c: 0x52350007
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
        goto label_1f93ac;
    }
    // 0x1f9394: 0x10000032
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9460; return;
    }
label_1f939c:
    // 0x1f939c: 0x12220027
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1F943C; return;
    }
    // 0x1f93a4: 0x1000002e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9460; return;
    }
label_1f93ac:
    // 0x1f93ac: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f93b4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 29124)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f93b4
// Address: 0x1f93b4 - 0x1f9418

void entry_1f93b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f93b4) {
        switch (ctx->pc) {
            case 0x1f93d8: ctx->pc = 0; goto label_1f93d8;
            case 0x1f93f0: ctx->pc = 0; goto label_1f93f0;
            case 0x1f93f4: ctx->pc = 0; goto label_1f93f4;
            case 0x1f9408: ctx->pc = 0; goto label_1f9408;
            case 0x1f9410: ctx->pc = 0; goto label_1f9410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f93b4: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1f93b8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f93bc: 0x8ca37138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 28984)));
    // 0x1f93c0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f93c4: 0x1462000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f93f4;
    }
    // 0x1f93cc: 0x24a37138
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 28984));
    // 0x1f93d0: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f93d4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1f93d8:
    // 0x1f93d8: 0x28820020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 32));
    // 0x1f93dc: 0x10400004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f93f0;
    }
    // 0x1f93e4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f93e8: 0x5045fffb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1f93d8;
    }
label_1f93f0:
    // 0x1f93f0: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
label_1f93f4:
    // 0x1f93f4: 0x14820004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 30788)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1f9408;
    }
    // 0x1f93fc: 0x8e827844
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 30788)));
    // 0x1f9400: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9410;
    }
label_1f9408:
    // 0x1f9408: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f940c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1f9410:
    // 0x1f9410: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x1f9418);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 29124)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9418
// Address: 0x1f9418 - 0x1f9458

void entry_1f9418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9418) {
        switch (ctx->pc) {
            case 0x1f9420: ctx->pc = 0; goto label_1f9420;
            case 0x1f943c: ctx->pc = 0; goto label_1f943c;
            case 0x1f9450: ctx->pc = 0; goto label_1f9450;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9418: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9450;
    }
label_1f9420:
    // 0x1f9420: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1f9424: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1f9428: 0x24428510
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935824));
    // 0x1f942c: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f9430: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f9434: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9450;
    }
label_1f943c:
    // 0x1f943c: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1f9440: 0x24428510
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935824));
    // 0x1f9444: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f9448: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f944c: 0xfe430000
    WRITE64(ADD32(GPR_U32(ctx, 18), 0), GPR_U64(ctx, 3));
label_1f9450:
    // 0x1f9450: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f9458);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9458
// Address: 0x1f9458 - 0x1f9568

void entry_1f9458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9458) {
        switch (ctx->pc) {
            case 0x1f9460: ctx->pc = 0; goto label_1f9460;
            case 0x1f9480: ctx->pc = 0; goto label_1f9480;
            case 0x1f94ac: ctx->pc = 0; goto label_1f94ac;
            case 0x1f9508: ctx->pc = 0; goto label_1f9508;
            case 0x1f9518: ctx->pc = 0; goto label_1f9518;
            case 0x1f954c: ctx->pc = 0; goto label_1f954c;
            case 0x1f9550: ctx->pc = 0; goto label_1f9550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9458: 0x1000006c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F960C; return;
    }
label_1f9460:
    // 0x1f9460: 0xae710010
    WRITE32(ADD32(GPR_U32(ctx, 19), 16), GPR_U32(ctx, 17));
    // 0x1f9464: 0x16400006
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1f9480;
    }
    // 0x1f946c: 0xae60041c
    WRITE32(ADD32(GPR_U32(ctx, 19), 1052), GPR_U32(ctx, 0));
    // 0x1f9470: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f9474: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f9478: 0x10000034
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f954c;
    }
label_1f9480:
    // 0x1f9480: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f9484: 0x26640014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 20));
    // 0x1f9488: 0x24030400
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1f948c: 0xc41025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1f9490: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x1f9494: 0x1040001c
    WRITE32(ADD32(GPR_U32(ctx, 19), 1052), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f9508;
    }
    // 0x1f949c: 0x24c20400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 1024));
    // 0x1f94a0: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f94a4: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f94a8: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
label_1f94ac:
    // 0x1f94ac: 0x68c30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f94b0: 0x6cc30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f94b4: 0x68c5000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1f94b8: 0x6cc50008
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1f94bc: 0x68c70017
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f94c0: 0x6cc70010
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f94c4: 0x68c8001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f94c8: 0x6cc80018
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f94cc: 0xb0830007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94d0: 0xb4830000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94d4: 0xb085000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94d8: 0xb4850008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94dc: 0xb0870017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94e0: 0xb4870010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94e4: 0xb088001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94e8: 0xb4880018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f94ec: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x1f94f0: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f94f4: 0x0
    // NOP
    // 0x1f94f8: 0x14c2ffec
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1f94ac;
    }
    // 0x1f9500: 0x10000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9550;
    }
label_1f9508:
    // 0x1f9508: 0x24c20400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 1024));
    // 0x1f950c: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1f9510: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f9514: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
label_1f9518:
    // 0x1f9518: 0xdcc30000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1f951c: 0xdcc50008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1f9520: 0xdcc70010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x1f9524: 0xdcc80018
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1f9528: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x1f952c: 0xfc850008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 5));
    // 0x1f9530: 0xfc870010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 7));
    // 0x1f9534: 0xfc880018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 8));
    // 0x1f9538: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x1f953c: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f9540: 0x0
    // NOP
    // 0x1f9544: 0x14c2fff4
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1f9518;
    }
label_1f954c:
    // 0x1f954c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1f9550:
    // 0x1f9550: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x1f9554: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x1f9558: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f955c: 0xafa00024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    // 0x1f9560: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1f9568);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 4294935744));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9568
// Address: 0x1f9568 - 0x1f958c

void entry_1f9568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9568: 0x26d07880
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 22), 30848));
    // 0x1f956c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f9570: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f9574: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f9578: 0xae720004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 18));
    // 0x1f957c: 0xae620008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 2));
    // 0x1f9580: 0x24050420
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1056));
    // 0x1f9584: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f958c);
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 17));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f958c
// Address: 0x1f958c - 0x1f95b4

void entry_1f958c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f958c: 0x26a48b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4294937408));
    // 0x1f9590: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f9594: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f9598: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1f959c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f95a0: 0x24080420
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1056));
    // 0x1f95a4: 0x280482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1f95a8: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f95ac: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f95b4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f95b4
// Address: 0x1f95b4 - 0x1f95c4

void entry_1f95b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f95b4: 0x4410007
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1F95D4; return;
    }
    // 0x1f95bc: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f95c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f95c4
// Address: 0x1f95c4 - 0x1f95cc

void entry_1f95c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f95c4: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f95cc);
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f95cc
// Address: 0x1f95cc - 0x1f95e0

void entry_1f95cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f95cc) {
        switch (ctx->pc) {
            case 0x1f95d4: ctx->pc = 0; goto label_1f95d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f95cc: 0x1000000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F960C; return;
    }
label_1f95d4:
    // 0x1f95d4: 0x2821025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1f95d8: 0xc07e27a
    SET_GPR_U32(ctx, 31, 0x1f95e0);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    _sceFsSigSema(rdram, ctx, runtime); return;
}


// Function: entry_1f95e0
// Address: 0x1f95e0 - 0x1f95f0

void entry_1f95e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f95e0: 0x16000005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F95F8; return;
    }
    // 0x1f95e8: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f95f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f95f0
// Address: 0x1f95f0 - 0x1f9600

void entry_1f95f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f95f0) {
        switch (ctx->pc) {
            case 0x1f95f8: ctx->pc = 0; goto label_1f95f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f95f0: 0x10000006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967285));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F960C; return;
    }
label_1f95f8:
    // 0x1f95f8: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1f9600);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9600
// Address: 0x1f9600 - 0x1f9608

void entry_1f9600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9600: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x1f9608);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_1f9608
// Address: 0x1f9608 - 0x1f9690

void entry_1f9608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9608) {
        switch (ctx->pc) {
            case 0x1f960c: ctx->pc = 0; goto label_1f960c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9608: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
label_1f960c:
    // 0x1f960c: 0xdfbf00b0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1f9610: 0xdfb600a0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1f9614: 0xdfb50090
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1f9618: 0xdfb40080
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1f961c: 0xdfb30070
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f9620: 0xdfb20060
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f9624: 0xdfb10050
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f9628: 0xdfb00040
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f962c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9634: 0x0
    // NOP
    // 0x1f9638: 0x27bd00d0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1f963c: 0x0
    // NOP
    // 0x1f9640: 0x27bd00d0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1f9644: 0x0
    // NOP
    // 0x1f9648: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f964c: 0x0
    // NOP
    // 0x1f9650: 0x27bd00d0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1f9654: 0x0
    // NOP
    // 0x1f9658: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f965c: 0x0
    // NOP
    // 0x1f9660: 0x27bd00d0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1f9664: 0x0
    // NOP
    // 0x1f9668: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f966c: 0x0
    // NOP
    // 0x1f9670: 0x27bd00e0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1f9674: 0x0
    // NOP
    // 0x1f9678: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f967c: 0x0
    // NOP
    // 0x1f9680: 0x27bd00e0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1f9684: 0x0
    // NOP
    // 0x1f9688: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f968c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9690; return;
}


// Function: _lf_bind
// Address: 0x1f9690 - 0x1f96cc

void entry_1f96cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f96cc) {
        switch (ctx->pc) {
            case 0x1f96dc: ctx->pc = 0; goto label_1f96dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f96cc: 0x4430003
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        goto label_1f96dc;
    }
    // 0x1f96d4: 0x10000028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9778; return;
    }
label_1f96dc:
    // 0x1f96dc: 0x10400019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9744; return;
    }
    // 0x1f96e4: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
    // 0x1f96e8: 0xae4071cc
    WRITE32(ADD32(GPR_U32(ctx, 18), 29132), GPR_U32(ctx, 0));
    // 0x1f96ec: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f96f0: 0x240500ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1f96f4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f96f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f96fc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9700: 0x26298c00
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 4294937600));
    // 0x1f9704: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f9708: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f9710);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f9710
// Address: 0x1f9710 - 0x1f9790

void entry_1f9710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9710) {
        switch (ctx->pc) {
            case 0x1f9724: ctx->pc = 0; goto label_1f9724;
            case 0x1f9744: ctx->pc = 0; goto label_1f9744;
            case 0x1f9750: ctx->pc = 0; goto label_1f9750;
            case 0x1f9774: ctx->pc = 0; goto label_1f9774;
            case 0x1f9778: ctx->pc = 0; goto label_1f9778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9710: 0x4410004
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_1f9724;
    }
    // 0x1f9718: 0x3c02fffe
    SET_GPR_U32(ctx, 2, ((uint32_t)65534 << 16));
    // 0x1f971c: 0x10000016
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9778;
    }
label_1f9724:
    // 0x1f9724: 0x26278c00
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 4294937600));
    // 0x1f9728: 0x24668e28
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4294938152));
    // 0x1f972c: 0x88e40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f9730: 0x98e40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1f9734: 0xa8c40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f9738: 0xb8c40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f973c: 0x1000000e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9778;
    }
label_1f9744:
    // 0x1f9744: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x1f9748: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f974c: 0x0
    // NOP
label_1f9750:
    // 0x1f9750: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1f9754: 0x0
    // NOP
    // 0x1f9758: 0x0
    // NOP
    // 0x1f975c: 0x0
    // NOP
    // 0x1f9760: 0x0
    // NOP
    // 0x1f9764: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1f9750;
    }
    // 0x1f976c: 0x1000ffd2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294938112));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F96B8; return;
    }
label_1f9774:
    // 0x1f9774: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f9778:
    // 0x1f9778: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f977c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f9780: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f9784: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9788: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _lf_version
// Address: 0x1f9790 - 0x1f97cc

void entry_1f97cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f97cc: 0x1040000b
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F97FC; return;
    }
    // 0x1f97d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f97d8: 0x8e0571d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 29136)));
    // 0x1f97dc: 0xc07d671
    SET_GPR_U32(ctx, 31, 0x1f97e4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    memcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f97e4
// Address: 0x1f97e4 - 0x1f97f8

void entry_1f97e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f97e4: 0x10400005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 29136)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F97FC; return;
    }
    // 0x1f97ec: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f97f0: 0xc07d671
    SET_GPR_U32(ctx, 31, 0x1f97f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    memcmp(rdram, ctx, runtime); return;
}


// Function: entry_1f97f8
// Address: 0x1f97f8 - 0x1f9820

void entry_1f97f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f97f8) {
        switch (ctx->pc) {
            case 0x1f97fc: ctx->pc = 0; goto label_1f97fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f97f8: 0x2902b
    SET_GPR_U32(ctx, 18, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1f97fc:
    // 0x1f97fc: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f9800: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f9804: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f9808: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f980c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9810: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f9814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f981c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9820; return;
}


// Function: sceSifLoadFileReset
// Address: 0x1f9820 - 0x1f9848

void entry_1f9848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9848: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f984c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9850: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9858: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1f985c: 0x0
    // NOP
    // 0x1f9860: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f9864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9868; return;
}


// Function: _sceSifLoadModule
// Address: 0x1f9868 - 0x1f98a0

void entry_1f98a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f98a0: 0x4400071
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1F9A68; return;
    }
    // 0x1f98a8: 0xc07e5e4
    SET_GPR_U32(ctx, 31, 0x1f98b0);
    _lf_version(rdram, ctx, runtime); return;
}


// Function: entry_1f98b0
// Address: 0x1f98b0 - 0x1f98d8

void entry_1f98b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f98b0) {
        switch (ctx->pc) {
            case 0x1f98c4: ctx->pc = 0; goto label_1f98c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f98b0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
        goto label_1f98c4;
    }
    // 0x1f98b8: 0x3c02fffe
    SET_GPR_U32(ctx, 2, ((uint32_t)65534 << 16));
    // 0x1f98bc: 0x1000006a
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65532));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9A68; return;
    }
label_1f98c4:
    // 0x1f98c4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f98c8: 0x24518c08
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294937608));
    // 0x1f98cc: 0x240600fc
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 252));
    // 0x1f98d0: 0xc0805c8
    SET_GPR_U32(ctx, 31, 0x1f98d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    strncpy(rdram, ctx, runtime); return;
}


// Function: entry_1f98d8
// Address: 0x1f98d8 - 0x1f9a08

void entry_1f98d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f98d8) {
        switch (ctx->pc) {
            case 0x1f9910: ctx->pc = 0; goto label_1f9910;
            case 0x1f996c: ctx->pc = 0; goto label_1f996c;
            case 0x1f9978: ctx->pc = 0; goto label_1f9978;
            case 0x1f99ac: ctx->pc = 0; goto label_1f99ac;
            case 0x1f99f8: ctx->pc = 0; goto label_1f99f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f98d8: 0x2622fff8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967288));
    // 0x1f98dc: 0x1200004c
    WRITE8(ADD32(GPR_U32(ctx, 2), 259), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9A10; return;
    }
    // 0x1f98e4: 0x2a4200fd
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 253));
    // 0x1f98e8: 0x14400043
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f99f8;
    }
    // 0x1f98f0: 0x262400fc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 252));
    // 0x1f98f4: 0x2041025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x1f98f8: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x1f98fc: 0x1040001b
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f996c;
    }
    // 0x1f9904: 0x260200e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 224));
    // 0x1f9908: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f990c: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
label_1f9910:
    // 0x1f9910: 0x68660007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f9914: 0x6c660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f9918: 0x6867000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f991c: 0x6c670008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f9920: 0x68680017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f9924: 0x6c680010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f9928: 0x6869001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f992c: 0x6c690018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1f9930: 0xb0860007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9934: 0xb4860000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9938: 0xb087000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f993c: 0xb4870008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9940: 0xb0880017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9944: 0xb4880010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9948: 0xb089001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f994c: 0xb4890018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f9950: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1f9954: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f9958: 0x0
    // NOP
    // 0x1f995c: 0x1462ffec
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f9910;
    }
    // 0x1f9964: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f99ac;
    }
label_1f996c:
    // 0x1f996c: 0x260200e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 224));
    // 0x1f9970: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f9974: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
label_1f9978:
    // 0x1f9978: 0xdc660000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1f997c: 0xdc670008
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1f9980: 0xdc680010
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1f9984: 0xdc690018
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1f9988: 0xfc860000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 6));
    // 0x1f998c: 0xfc870008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 7));
    // 0x1f9990: 0xfc880010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 8));
    // 0x1f9994: 0xfc890018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 9));
    // 0x1f9998: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1f999c: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1f99a0: 0x0
    // NOP
    // 0x1f99a4: 0x1462fff4
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1f9978;
    }
label_1f99ac:
    // 0x1f99ac: 0x68660007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f99b0: 0x6c660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1f99b4: 0x6867000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f99b8: 0x6c670008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1f99bc: 0x68680017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f99c0: 0x6c680010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1f99c4: 0x8869001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 9, (GPR_U32(ctx,9) & ~mask) | ((word >> shift) & mask)); }
    // 0x1f99c8: 0x98690018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 9, (GPR_U32(ctx,9) & ~mask) | (word << shift)); }
    // 0x1f99cc: 0xb0860007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99d0: 0xb4860000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99d4: 0xb087000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99d8: 0xb4870008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99dc: 0xb0880017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99e0: 0xb4880010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f99e4: 0xa889001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 9) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f99e8: 0x240200fc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 252));
    // 0x1f99ec: 0xb8890018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 9) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1f99f0: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294937600), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9A20; return;
    }
label_1f99f8:
    // 0x1f99f8: 0x262400fc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 252));
    // 0x1f99fc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1f9a00: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1f9a08);
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1f9a08
// Address: 0x1f9a08 - 0x1f9a4c

void entry_1f9a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9a08) {
        switch (ctx->pc) {
            case 0x1f9a10: ctx->pc = 0; goto label_1f9a10;
            case 0x1f9a1c: ctx->pc = 0; goto label_1f9a1c;
            case 0x1f9a20: ctx->pc = 0; goto label_1f9a20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9a08: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294967288), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9a1c;
    }
label_1f9a10:
    // 0x1f9a10: 0xa0400104
    WRITE8(ADD32(GPR_U32(ctx, 2), 260), (uint8_t)GPR_U32(ctx, 0));
    // 0x1f9a14: 0x3c150063
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    // 0x1f9a18: 0xae20fff8
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294967288), GPR_U32(ctx, 0));
label_1f9a1c:
    // 0x1f9a1c: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
label_1f9a20:
    // 0x1f9a20: 0x26b08c00
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294937600));
    // 0x1f9a24: 0x24a48e00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294938112));
    // 0x1f9a28: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1f9a2c: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1f9a30: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9a34: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f9a38: 0x24080200
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 512));
    // 0x1f9a3c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f9a40: 0x240a0008
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1f9a44: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x1f9a4c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f9a4c
// Address: 0x1f9a4c - 0x1f9a90

void entry_1f9a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9a4c) {
        switch (ctx->pc) {
            case 0x1f9a60: ctx->pc = 0; goto label_1f9a60;
            case 0x1f9a68: ctx->pc = 0; goto label_1f9a68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9a4c: 0x4430004
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_1f9a60;
    }
    // 0x1f9a54: 0x3c02fffe
    SET_GPR_U32(ctx, 2, ((uint32_t)65534 << 16));
    // 0x1f9a58: 0x10000003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9a68;
    }
label_1f9a60:
    // 0x1f9a60: 0x8ea28c00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4294937600)));
    // 0x1f9a64: 0xae830000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 3));
label_1f9a68:
    // 0x1f9a68: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f9a6c: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f9a70: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f9a74: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1f9a78: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f9a7c: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f9a80: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9a84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9a8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9a90; return;
}


// Function: sceSifLoadModule
// Address: 0x1f9a90 - 0x1f9aa4

void entry_1f9aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9aa4: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9aa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9ab0: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f9ab4: 0x0
    // NOP
    // 0x1f9ab8: 0x27bd0070
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1f9abc: 0x0
    // NOP
    // 0x1f9ac0: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1f9ac4: 0x0
    // NOP
    // 0x1f9ac8: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1f9acc: 0x0
    // NOP
    // 0x1f9ad0: 0x27bd0050
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1f9ad4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9ad8; return;
}


// Function: sceSifResetIop
// Address: 0x1f9ad8 - 0x1f9af4

void entry_1f9af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9af4: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f9af8: 0xc07db3c
    SET_GPR_U32(ctx, 31, 0x1f9b00);
    sceSifGetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9b00
// Address: 0x1f9b00 - 0x1f9ba4

void entry_1f9b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9b00) {
        switch (ctx->pc) {
            case 0x1f9b28: ctx->pc = 0; goto label_1f9b28;
            case 0x1f9b48: ctx->pc = 0; goto label_1f9b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9b00: 0x3c0a0063
    SET_GPR_U32(ctx, 10, ((uint32_t)99 << 16));
    // 0x1f9b04: 0x40582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f9b08: 0x25438e40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 10), 4294938176));
    // 0x1f9b0c: 0xac700014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 16));
    // 0x1f9b10: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f9b14: 0x1040000c
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f9b48;
    }
    // 0x1f9b1c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f9b20: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f9b24: 0x0
    // NOP
label_1f9b28:
    // 0x1f9b28: 0x25438e40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 10), 4294938176));
    // 0x1f9b2c: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1f9b30: 0x25290001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
    // 0x1f9b34: 0xa0640018
    WRITE8(ADD32(GPR_U32(ctx, 3), 24), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f9b38: 0x2291021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 9)));
    // 0x1f9b3c: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1f9b40: 0x5460fff9
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
        goto label_1f9b28;
    }
label_1f9b48:
    // 0x1f9b48: 0x25468e40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 10), 4294938176));
    // 0x1f9b4c: 0x3c038000
    SET_GPR_U32(ctx, 3, ((uint32_t)32768 << 16));
    // 0x1f9b50: 0xacc00004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 0));
    // 0x1f9b54: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1f9b58: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1f9b5c: 0x348400ff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 255));
    // 0x1f9b60: 0x34630003
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 3));
    // 0x1f9b64: 0x24050068
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 104));
    // 0x1f9b68: 0xdd428e40
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 10), 4294938176)));
    // 0x1f9b6c: 0x24070068
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 104));
    // 0x1f9b70: 0xacc90010
    WRITE32(ADD32(GPR_U32(ctx, 6), 16), GPR_U32(ctx, 9));
    // 0x1f9b74: 0x24080044
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1f9b78: 0xacc30008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 3));
    // 0x1f9b7c: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f9b80: 0xfd428e40
    WRITE64(ADD32(GPR_U32(ctx, 10), 4294938176), GPR_U64(ctx, 2));
    // 0x1f9b84: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1f9b88: 0xa1458e40
    WRITE8(ADD32(GPR_U32(ctx, 10), 4294938176), (uint8_t)GPR_U32(ctx, 5));
    // 0x1f9b8c: 0x24050068
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 104));
    // 0x1f9b90: 0xafab0004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 11));
    // 0x1f9b94: 0xafa70008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 7));
    // 0x1f9b98: 0xafa8000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 8));
    // 0x1f9b9c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1f9ba4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 6));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1f9ba4
// Address: 0x1f9ba4 - 0x1f9bb0

void entry_1f9ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ba4: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f9ba8: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1f9bb0);
    SET_GPR_U32(ctx, 5, ((uint32_t)4 << 16));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9bb0
// Address: 0x1f9bb0 - 0x1f9bbc

void entry_1f9bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9bb0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f9bb4: 0xc07db28
    SET_GPR_U32(ctx, 31, 0x1f9bbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    sceSifSetDma(rdram, ctx, runtime); return;
}


// Function: entry_1f9bbc
// Address: 0x1f9bbc - 0x1f9bcc

void entry_1f9bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9bbc: 0x1040000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9BFC; return;
    }
    // 0x1f9bc4: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1f9bcc);
    SET_GPR_U32(ctx, 5, ((uint32_t)1 << 16));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9bcc
// Address: 0x1f9bcc - 0x1f9bd8

void entry_1f9bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9bcc: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1f9bd0: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1f9bd8);
    SET_GPR_U32(ctx, 5, ((uint32_t)2 << 16));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9bd8
// Address: 0x1f9bd8 - 0x1f9be8

void entry_1f9bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9bd8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f9bdc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1f9be0: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1f9be8);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 2));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9be8
// Address: 0x1f9be8 - 0x1f9bf4

void entry_1f9be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9be8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1f9bec: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1f9bf4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1f9bf4
// Address: 0x1f9bf4 - 0x1f9c18

void entry_1f9bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9bf4) {
        switch (ctx->pc) {
            case 0x1f9bfc: ctx->pc = 0; goto label_1f9bfc;
            case 0x1f9c00: ctx->pc = 0; goto label_1f9c00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9bf4: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9c00;
    }
label_1f9bfc:
    // 0x1f9bfc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1f9c00:
    // 0x1f9c00: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1f9c04: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f9c08: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9c0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9c14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9c18; return;
}


// Function: sceSifSyncIop
// Address: 0x1f9c18 - 0x1f9c28

void entry_1f9c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9c28: 0x3c030004
    SET_GPR_U32(ctx, 3, ((uint32_t)4 << 16));
    // 0x1f9c2c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1f9c30: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1F9C44; return;
    }
    // 0x1f9c38: 0xc07e828
    SET_GPR_U32(ctx, 31, 0x1f9c40);
    sceResetttyinit(rdram, ctx, runtime); return;
}


// Function: entry_1f9c40
// Address: 0x1f9c40 - 0x1f9c50

void entry_1f9c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9c40) {
        switch (ctx->pc) {
            case 0x1f9c44: ctx->pc = 0; goto label_1f9c44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9c40: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1f9c44:
    // 0x1f9c44: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f9c48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceSifRebootIop
// Address: 0x1f9c50 - 0x1f9cbc

void entry_1f9cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9cbc) {
        switch (ctx->pc) {
            case 0x1f9cc4: ctx->pc = 0; goto label_1f9cc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9cbc: 0x10000023
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1f9d4c(rdram, ctx, runtime); return;
    }
label_1f9cc4:
    // 0x1f9cc4: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x1f9ccc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f9ccc
// Address: 0x1f9ccc - 0x1f9cd4

void entry_1f9ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ccc: 0xc07df62
    SET_GPR_U32(ctx, 31, 0x1f9cd4);
    sceSifExitRpc(rdram, ctx, runtime); return;
}


// Function: entry_1f9cd4
// Address: 0x1f9cd4 - 0x1f9d4c

void entry_1f9cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9cd4) {
        switch (ctx->pc) {
            case 0x1f9ce8: ctx->pc = 0; goto label_1f9ce8;
            case 0x1f9d0c: ctx->pc = 0; goto label_1f9d0c;
            case 0x1f9d14: ctx->pc = 0; goto label_1f9d14;
            case 0x1f9d20: ctx->pc = 0; goto label_1f9d20;
            case 0x1f9d40: ctx->pc = 0; goto label_1f9d40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9cd4: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f9cd8: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f9cdc: 0x1040000b
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f9d0c;
    }
    // 0x1f9ce4: 0x92050000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
label_1f9ce8:
    // 0x1f9ce8: 0xa0640000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f9cec: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1f9cf0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f9cf4: 0x92240000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f9cf8: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1f9cfc: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f9ce8;
    }
    // 0x1f9d04: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f9d14;
    }
label_1f9d0c:
    // 0x1f9d0c: 0x92050000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f9d10: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1f9d14:
    // 0x1f9d14: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 0));
        goto label_1f9d40;
    }
    // 0x1f9d1c: 0x0
    // NOP
label_1f9d20:
    // 0x1f9d20: 0xa0640000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 4));
    // 0x1f9d24: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1f9d28: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1f9d2c: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1f9d30: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1f9d34: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f9d20;
    }
    // 0x1f9d3c: 0xa0600000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 0));
label_1f9d40:
    // 0x1f9d40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1f9d44: 0xc07e6b6
    SET_GPR_U32(ctx, 31, 0x1f9d4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifResetIop(rdram, ctx, runtime); return;
}


// Function: entry_1f9d4c
// Address: 0x1f9d4c - 0x1f9d60

void entry_1f9d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9d4c: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1f9d50: 0xdfb10060
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1f9d54: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1f9d58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DIntr
// Address: 0x1f9d60 - 0x1f9da8

void entry_1f9e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CustomSyscallHandler_1f9e08
// Address: 0x1f9e08 - 0x1f9e10

void entry_1f9e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e10: 0x10440008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        entry_1f9e30(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f9e18; return;
}


// Function: entry_1f9e18
// Address: 0x1f9e18 - 0x1f9e20

void entry_1f9e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e18: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1f9e1c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // Fall-through to next function
    ctx->pc = 0x1f9e20; return;
}


// Function: entry_1f9e20
// Address: 0x1f9e20 - 0x1f9e28

void entry_1f9e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e20: 0x0
    // NOP
    // 0x1f9e24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9e28; return;
}


// Function: entry_1f9e28
// Address: 0x1f9e28 - 0x1f9e34

void entry_1f9e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e28: 0x0
    // NOP
    // 0x1f9e2c: 0x1444fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        entry_1f9e18(rdram, ctx, runtime); return;
    }
    // Fall-through to next function
    ctx->pc = 0x1f9e34; return;
}


// Function: entry_1f9e30
// Address: 0x1f9e34 - 0x1f9e3c

void entry_1f9e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e34: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: entry_1f9e38
// Address: 0x1f9e3c - 0x1f9e40

void entry_1f9e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9e40; return;
}


// Function: FindAddress
// Address: 0x1f9e40 - 0x1f9e48

void entry_1f9e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e48: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetSystemCallTableEntry
// Address: 0x1f9e50 - 0x1f9e58

void entry_1f9e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e58: 0x244371d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 29144));
    // 0x1f9e5c: 0x8c4471d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 29144)));
    // Fall-through to next function
    ctx->pc = 0x1f9e60; return;
}


// Function: entry_1f9e60
// Address: 0x1f9e60 - 0x1f9e68

void entry_1f9e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e60: 0x8c650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1f9e64: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // Fall-through to next function
    ctx->pc = 0x1f9e68; return;
}


// Function: entry_1f9e68
// Address: 0x1f9e68 - 0x1f9e70

void entry_1f9e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e68: 0xc07e7a4
    SET_GPR_U32(ctx, 31, 0x1f9e70);
    SetSyscall1(rdram, ctx, runtime); return;
}


// Function: GetSystemCallTableEntry_cont_1f9e70
// Address: 0x1f9e70 - 0x1f9e7c

void entry_1f9e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e80: 0x2442fdf4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966772));
    // 0x1f9e84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: entry_1f9e88
// Address: 0x1f9e8c - 0x1f9e90

void entry_1f9e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9e90; return;
}


// Function: SetSyscall1
// Address: 0x1f9e90 - 0x1f9e98

void entry_1f9e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9e98: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: entry_1f9ea0
// Address: 0x1f9ea0 - 0x1f9ea8

void entry_1f9ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ea0: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1f9ea4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9ea8; return;
}


// Function: fn__InitSys
// Address: 0x1f9ea8 - 0x1f9eb0

void entry_1f9eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9eb0: 0xc07e770
    SET_GPR_U32(ctx, 31, 0x1f9eb8);
    supplement_crt0(rdram, ctx, runtime); return;
}


// Function: fn__InitSys_cont_1f9eb8
// Address: 0x1f9eb8 - 0x1f9ec0

void entry_1f9ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1f9ee8; return;
}


// Function: SetSyscall2
// Address: 0x1f9ee8 - 0x1f9ef0

void entry_1f9ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ef0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001f9ef8
// Address: 0x1f9ef8 - 0x1f9f40

void FUN_001f9ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1f9ef8) {
        switch (ctx->pc) {
            case 0x1f9f18: ctx->pc = 0; goto label_1f9f18;
            case 0x1f9f38: ctx->pc = 0; goto label_1f9f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1f9ef8: 0x2403005a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 90));
    // 0x1f9efc: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1f9f00: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1f9f08: 0x63082
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 6), 2));
    // 0x1f9f0c: 0x10c0000a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1f9f38;
    }
    // 0x1f9f14: 0x0
    // NOP
label_1f9f18:
    // 0x1f9f18: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1f9f1c: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1f9f20: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1f9f24: 0xe6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x1f9f28: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x1f9f2c: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1f9f30: 0x1440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1f9f18;
    }
label_1f9f38:
    // 0x1f9f38: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RFU0911
// Address: 0x1f9f40 - 0x1f9f50

void entry_1f9f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9f64: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1f9f68: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1f9f6c: 0x34421fff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8191));
    // 0x1f9f70: 0x27b00004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 4));
    // 0x1f9f74: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f9f78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1f9f7c: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1f9f80: 0xc07dae4
    SET_GPR_U32(ctx, 31, 0x1f9f88);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    SetOsdConfigParam(rdram, ctx, runtime); return;
}


// Function: entry_1f9f88
// Address: 0x1f9f88 - 0x1f9f90

void entry_1f9f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9f88: 0xc07dae8
    SET_GPR_U32(ctx, 31, 0x1f9f90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetOsdConfigParam(rdram, ctx, runtime); return;
}


// Function: entry_1f9f90
// Address: 0x1f9f90 - 0x1f9f98

void entry_1f9f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9f90: 0xc07dae4
    SET_GPR_U32(ctx, 31, 0x1f9f98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetOsdConfigParam(rdram, ctx, runtime); return;
}


// Function: entry_1f9f98
// Address: 0x1f9f98 - 0x1f9fb8

void entry_1f9f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9f98: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1f9f9c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1f9fa0: 0x21342
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 13));
    // 0x1f9fa4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1f9fa8: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x1f9fac: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1f9fb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitExecPS2
// Address: 0x1f9fb8 - 0x1f9fd0

void entry_1f9fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9fd0: 0x1040001e
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA04C; return;
    }
    // 0x1f9fd8: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f9fdc: 0x24507998
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 31128));
    // 0x1f9fe0: 0x8c447998
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 31128)));
    // 0x1f9fe4: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1f9fe8: 0xc07e7ba
    SET_GPR_U32(ctx, 31, 0x1f9ff0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 16));
    SetSyscall2(rdram, ctx, runtime); return;
}


// Function: entry_1f9ff0
// Address: 0x1f9ff0 - 0x1fa008

void entry_1f9ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1f9ff0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1f9ff4: 0x3c048007
    SET_GPR_U32(ctx, 4, ((uint32_t)32775 << 16));
    // 0x1f9ff8: 0x240607a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1960));
    // 0x1f9ffc: 0x24a571f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 29168));
    // 0x1fa000: 0xc07e7be
    SET_GPR_U32(ctx, 31, 0x1fa008);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16384));
    FUN_001f9ef8(rdram, ctx, runtime); return;
}


// Function: entry_1fa008
// Address: 0x1fa008 - 0x1fa010

void entry_1fa008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa008: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1fa010);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa010
// Address: 0x1fa010 - 0x1fa018

void entry_1fa010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa010: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1fa018);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa018
// Address: 0x1fa018 - 0x1fa024

void entry_1fa018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa018: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fa01c: 0xc07e7ba
    SET_GPR_U32(ctx, 31, 0x1fa024);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    SetSyscall2(rdram, ctx, runtime); return;
}


// Function: entry_1fa024
// Address: 0x1fa024 - 0x1fa030

void entry_1fa024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa024) {
        switch (ctx->pc) {
            case 0x1fa028: ctx->pc = 0; goto label_1fa028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa024: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1fa028:
    // 0x1fa028: 0xc07e7d0
    SET_GPR_U32(ctx, 31, 0x1fa030);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    RFU0911(rdram, ctx, runtime); return;
}


// Function: entry_1fa030
// Address: 0x1fa030 - 0x1fa040

void entry_1fa030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa030: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fa034: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fa038: 0xc07e7ba
    SET_GPR_U32(ctx, 31, 0x1fa040);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    SetSyscall2(rdram, ctx, runtime); return;
}


// Function: entry_1fa040
// Address: 0x1fa040 - 0x1fa068

void entry_1fa040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa040) {
        switch (ctx->pc) {
            case 0x1fa04c: ctx->pc = 0; goto label_1fa04c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa040: 0x2e420003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 3));
    // 0x1fa044: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1FA028; return;
    }
label_1fa04c:
    // 0x1fa04c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa050: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa054: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa058: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa05c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa064: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa068; return;
}


// Function: InitTLB
// Address: 0x1fa068 - 0x1fa078

void entry_1fa08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa08c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fa090: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa094: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa098: 0x807da48
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = 0x1f6920; return;
}


// Function: sceResetttyinit
// Address: 0x1fa0a0 - 0x1fa0d8

void FUN_001fa0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa0d8: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: kill
// Address: 0x1fa0e0 - 0x1fa0f8

void entry_1fa0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa0f8: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa0fc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa108: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa10c: 0x0
    // NOP
    // 0x1fa110: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa114: 0x0
    // NOP
    // 0x1fa118: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa11c: 0x0
    // NOP
    // 0x1fa120: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa124: 0x0
    // NOP
    // 0x1fa128: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa12c: 0x0
    // NOP
    // 0x1fa130: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa134: 0x0
    // NOP
    // 0x1fa138: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fa13c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa140; return;
}


// Function: kputs
// Address: 0x1fa140 - 0x1fa158

void entry_1fa158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa158: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa15c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa164: 0x0
    // NOP
    // 0x1fa168: 0xac64000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 4));
    // 0x1fa16c: 0x0
    // NOP
    // 0x1fa170: 0x0
    // NOP
    // 0x1fa174: 0x0
    // NOP
    // 0x1fa178: 0x0
    // NOP
    // 0x1fa17c: 0x0
    // NOP
    // 0x1fa180: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1fa184: 0x0
    // NOP
    // 0x1fa188: 0x27bd0030
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1fa18c: 0x0
    // NOP
    // 0x1fa190: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1fa194: 0x8ca6001c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 28)));
    // 0x1fa198: 0x8c830014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x1fa19c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1fa1a0: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1fa1a4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa1ac: 0x0
    // NOP
    // 0x1fa1b0: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1fa1b4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 8), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa1bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa1c0; return;
}


// Function: sceSifGetSreg
// Address: 0x1fa1c0 - 0x1fa1e8

void entry_1fa208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa208) {
        switch (ctx->pc) {
            case 0x1fa238: ctx->pc = 0; goto label_1fa238;
            case 0x1fa2a0: ctx->pc = 0; goto label_1fa2a0;
            case 0x1fa2d0: ctx->pc = 0; goto label_1fa2d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa208: 0x3c0a0027
    SET_GPR_U32(ctx, 10, ((uint32_t)39 << 16));
    // 0x1fa20c: 0x8d4279b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 31160)));
    // 0x1fa210: 0x10400009
    SET_GPR_U32(ctx, 19, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fa238;
    }
    // 0x1fa218: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fa21c: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1fa220: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa224: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa228: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa22c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa230: 0x807e76a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    EIntr(rdram, ctx, runtime); return;
label_1fa238:
    // 0x1fa238: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
    // 0x1fa23c: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x1fa240: 0x24a59340
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294939456));
    // 0x1fa244: 0x266692c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 4294939328));
    // 0x1fa248: 0x3c120063
    SET_GPR_U32(ctx, 18, ((uint32_t)99 << 16));
    // 0x1fa24c: 0xa22825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1fa250: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1fa254: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fa258: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x1fa25c: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x1fa260: 0x26429398
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294939544));
    // 0x1fa264: 0xad4379b8
    WRITE32(ADD32(GPR_U32(ctx, 10), 31160), GPR_U32(ctx, 3));
    // 0x1fa268: 0x252893c0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 9), 4294939584));
    // 0x1fa26c: 0xae469398
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294939544), GPR_U32(ctx, 6));
    // 0x1fa270: 0x248494c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939840));
    // 0x1fa274: 0x24070020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fa278: 0xac44001c
    WRITE32(ADD32(GPR_U32(ctx, 2), 28), GPR_U32(ctx, 4));
    // 0x1fa27c: 0xac450004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 5));
    // 0x1fa280: 0x100182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1fa284: 0xac470010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 7));
    // 0x1fa288: 0x3c140063
    SET_GPR_U32(ctx, 20, ((uint32_t)99 << 16));
    // 0x1fa28c: 0xac400008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    // 0x1fa290: 0x2410001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 31));
    // 0x1fa294: 0xac48000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 8));
    // 0x1fa298: 0xac400014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 0));
    // 0x1fa29c: 0xac400018
    WRITE32(ADD32(GPR_U32(ctx, 2), 24), GPR_U32(ctx, 0));
label_1fa2a0:
    // 0x1fa2a0: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x1fa2a4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1fa2a8: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x1fa2ac: 0x24630008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1fa2b0: 0x0
    // NOP
    // 0x1fa2b4: 0x601fffa
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1fa2a0;
    }
    // 0x1fa2bc: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1fa2c0: 0x2410001f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 31));
    // 0x1fa2c4: 0x244294c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294939840));
    // 0x1fa2c8: 0x2442007c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 124));
    // 0x1fa2cc: 0x0
    // NOP
label_1fa2d0:
    // 0x1fa2d0: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x1fa2d4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1fa2d8: 0x2442fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967292));
    // 0x1fa2dc: 0x0
    // NOP
    // 0x1fa2e0: 0x0
    // NOP
    // 0x1fa2e4: 0x601fffa
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1fa2d0;
    }
    // 0x1fa2ec: 0x3c020020
    SET_GPR_U32(ctx, 2, ((uint32_t)32 << 16));
    // 0x1fa2f0: 0x3c030020
    SET_GPR_U32(ctx, 3, ((uint32_t)32 << 16));
    // 0x1fa2f4: 0x2442a1b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943152));
    // 0x1fa2f8: 0x252493c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 4294939584));
    // 0x1fa2fc: 0x2463a190
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294943120));
    // 0x1fa300: 0x26519398
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 4294939544));
    // 0x1fa304: 0xad2293c0
    WRITE32(ADD32(GPR_U32(ctx, 9), 4294939584), GPR_U32(ctx, 2));
    // 0x1fa308: 0x24100020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fa30c: 0xac830008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 3));
    // 0x1fa310: 0xac91000c
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 17));
    // 0x1fa314: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x1fa31c);
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 17));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_1fa31c
// Address: 0x1fa31c - 0x1fa324

void entry_1fa31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa31c: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1fa324);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa324
// Address: 0x1fa324 - 0x1fa364

void entry_1fa324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa324) {
        switch (ctx->pc) {
            case 0x1fa348: ctx->pc = 0; goto label_1fa348;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa324: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x1fa328: 0x3442e010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 57360));
    // 0x1fa32c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fa330: 0x30630020
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 32));
    // 0x1fa334: 0x10600004
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1fa348;
    }
    // 0x1fa33c: 0x3c011001
    SET_GPR_U32(ctx, 1, ((uint32_t)4097 << 16));
    // 0x1fa340: 0xac30e010
    WRITE32(ADD32(GPR_U32(ctx, 1), 4294959120), GPR_U32(ctx, 16));
    // 0x1fa344: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
label_1fa348:
    // 0x1fa348: 0x3442c000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 49152));
    // 0x1fa34c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fa350: 0x30630100
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 256));
    // 0x1fa354: 0x14600004
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA368; return;
    }
    // 0x1fa35c: 0xc07db30
    SET_GPR_U32(ctx, 31, 0x1fa364);
    sceSifSetDChain(rdram, ctx, runtime); return;
}


// Function: entry_1fa364
// Address: 0x1fa364 - 0x1fa378

void entry_1fa364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa364) {
        switch (ctx->pc) {
            case 0x1fa368: ctx->pc = 0; goto label_1fa368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa364: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
label_1fa368:
    // 0x1fa368: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1fa36c: 0x24a5a6b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944432));
    // 0x1fa370: 0xc07da5c
    SET_GPR_U32(ctx, 31, 0x1fa378);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddDmacHandler(rdram, ctx, runtime); return;
}


// Function: entry_1fa378
// Address: 0x1fa378 - 0x1fa388

void entry_1fa378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa378: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1fa37c: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1fa380: 0xc07db9e
    SET_GPR_U32(ctx, 31, 0x1fa388);
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939540), GPR_U32(ctx, 2));
    FUN_001f6e78(rdram, ctx, runtime); return;
}


// Function: entry_1fa388
// Address: 0x1fa388 - 0x1fa394

void entry_1fa388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa388: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fa38c: 0xc07db3c
    SET_GPR_U32(ctx, 31, 0x1fa394);
    sceSifGetReg(rdram, ctx, runtime); return;
}


// Function: entry_1fa394
// Address: 0x1fa394 - 0x1fa3e8

void entry_1fa394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa394) {
        switch (ctx->pc) {
            case 0x1fa3dc: ctx->pc = 0; goto label_1fa3dc;
            case 0x1fa3e0: ctx->pc = 0; goto label_1fa3e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa394: 0x10400011
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fa3dc;
    }
    // 0x1fa39c: 0x26859380
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 4294939520));
    // 0x1fa3a0: 0x266292c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4294939328));
    // 0x1fa3a4: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fa3a8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fa3ac: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1fa3b0: 0x24060014
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1fa3b4: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa3b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa3bc: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa3c0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa3c4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa3c8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa3cc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa3d0: 0xaca20010
    WRITE32(ADD32(GPR_U32(ctx, 5), 16), GPR_U32(ctx, 2));
    // 0x1fa3d4: 0x807e98c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    sceSifSendCmd(rdram, ctx, runtime); return;
label_1fa3dc:
    // 0x1fa3dc: 0x3c100002
    SET_GPR_U32(ctx, 16, ((uint32_t)2 << 16));
label_1fa3e0:
    // 0x1fa3e0: 0xc07db3c
    SET_GPR_U32(ctx, 31, 0x1fa3e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    sceSifGetReg(rdram, ctx, runtime); return;
}


// Function: entry_1fa3e8
// Address: 0x1fa3e8 - 0x1fa3fc

void entry_1fa3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa3e8: 0x501024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1fa3ec: 0x1040fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA3E0; return;
    }
    // 0x1fa3f4: 0xc07db3c
    SET_GPR_U32(ctx, 31, 0x1fa3fc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294939544));
    sceSifGetReg(rdram, ctx, runtime); return;
}


// Function: entry_1fa3fc
// Address: 0x1fa3fc - 0x1fa40c

void entry_1fa3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa3fc: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1fa400: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fa404: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1fa40c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1fa40c
// Address: 0x1fa40c - 0x1fa41c

void entry_1fa40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa40c: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fa410: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fa414: 0xc07db38
    SET_GPR_U32(ctx, 31, 0x1fa41c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 1));
    sceSifSetReg(rdram, ctx, runtime); return;
}


// Function: entry_1fa41c
// Address: 0x1fa41c - 0x1fa468

void entry_1fa41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa41c: 0x26839380
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 4294939520));
    // 0x1fa420: 0x266292c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4294939328));
    // 0x1fa424: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fa428: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fa42c: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1fa430: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fa434: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa438: 0x34840002
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 2));
    // 0x1fa43c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa440: 0x24060014
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1fa444: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa448: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa44c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa450: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa454: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    // 0x1fa458: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fa45c: 0xac60000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 0));
    // 0x1fa460: 0x807e98c
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: sceSifExitCmd
// Address: 0x1fa468 - 0x1fa478

void entry_1fa478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa478: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1fa47c: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1fa480: 0xc07da64
    SET_GPR_U32(ctx, 31, 0x1fa488);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 4294939540)));
    RemoveDmacHandler(rdram, ctx, runtime); return;
}


// Function: entry_1fa488
// Address: 0x1fa488 - 0x1fa4a0

void entry_1fa488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa488: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1fa48c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa490: 0xac6079b8
    WRITE32(ADD32(GPR_U32(ctx, 3), 31160), GPR_U32(ctx, 0));
    // 0x1fa494: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa49c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa4a0; return;
}


// Function: sceSifAddCmdHandler
// Address: 0x1fa4a0 - 0x1fa4d0

void entry_1fa580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa580) {
        switch (ctx->pc) {
            case 0x1fa588: ctx->pc = 0; goto label_1fa588;
            case 0x1fa594: ctx->pc = 0; goto label_1fa594;
            case 0x1fa598: ctx->pc = 0; goto label_1fa598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa580: 0x10000005
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fa598;
    }
label_1fa588:
    // 0x1fa588: 0x92020000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fa58c: 0xae000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
    // 0x1fa590: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_1fa594:
    // 0x1fa594: 0x122900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 18), 4));
label_1fa598:
    // 0x1fa598: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1fa59c: 0x8c4493a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939552)));
    // 0x1fa5a0: 0x3a51821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 5)));
    // 0x1fa5a4: 0xac700000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 16));
    // 0x1fa5a8: 0x27a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 4));
    // 0x1fa5ac: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1fa5b0: 0x27a30008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 8));
    // 0x1fa5b4: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1fa5b8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fa5bc: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x1fa5c0: 0x27a4000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 12));
    // 0x1fa5c4: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1fa5c8: 0xae140008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 20));
    // 0x1fa5cc: 0xa2110000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 17));
    // 0x1fa5d0: 0x24020044
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1fa5d4: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1fa5d8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fa5dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fa5e0: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x1fa5e8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa5e8
// Address: 0x1fa5e8 - 0x1fa5fc

void entry_1fa5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa5e8: 0x32620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
    // 0x1fa5ec: 0x10400005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA604; return;
    }
    // 0x1fa5f4: 0xc07db2c
    SET_GPR_U32(ctx, 31, 0x1fa5fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    isceSifSetDma(rdram, ctx, runtime); return;
}


// Function: entry_1fa5fc
// Address: 0x1fa5fc - 0x1fa60c

void entry_1fa5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa5fc) {
        switch (ctx->pc) {
            case 0x1fa604: ctx->pc = 0; goto label_1fa604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa5fc: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA610; return;
    }
label_1fa604:
    // 0x1fa604: 0xc07db28
    SET_GPR_U32(ctx, 31, 0x1fa60c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sceSifSetDma(rdram, ctx, runtime); return;
}


// Function: entry_1fa60c
// Address: 0x1fa60c - 0x1fa630

void entry_1fa60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa60c) {
        switch (ctx->pc) {
            case 0x1fa610: ctx->pc = 0; goto label_1fa610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa60c: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
label_1fa610:
    // 0x1fa610: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1fa614: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fa618: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1fa61c: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa620: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa62c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa630; return;
}


// Function: sceSifSendCmd
// Address: 0x1fa630 - 0x1fa660

void entry_1fa660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa660) {
        switch (ctx->pc) {
            case 0x1fa670: ctx->pc = 0; goto label_1fa670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa660: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa664: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa66c: 0x0
    // NOP
label_1fa670:
    // 0x1fa670: 0xc0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1fa674: 0xe0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1fa678: 0x100582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1fa67c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fa680: 0x120502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1fa684: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1fa688: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fa68c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fa690: 0x60402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fa694: 0x160482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x1fa698: 0xc07e93e
    SET_GPR_U32(ctx, 31, 0x1fa6a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceSifSendCmd(rdram, ctx, runtime); return;
}


// Function: entry_1fa6a0
// Address: 0x1fa6a0 - 0x1fa6b0

void entry_1fa6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa6a0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa6a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa6ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa6b0; return;
}


// Function: _sceSifCmdIntrHdlr
// Address: 0x1fa6b0 - 0x1fa6c4

void entry_1fa6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa6c4) {
        switch (ctx->pc) {
            case 0x1fa710: ctx->pc = 0; goto label_1fa710;
            case 0x1fa72c: ctx->pc = 0; goto label_1fa72c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa6c4: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1fa6c8: 0x8c679398
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 4294939544)));
    // 0x1fa6cc: 0x24709398
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 4294939544));
    // 0x1fa6d0: 0x90e20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1fa6d4: 0x304500ff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 2), 255));
    // 0x1fa6d8: 0x10a0003b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA7C8; return;
    }
    // 0x1fa6e0: 0x24a2000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 15));
    // 0x1fa6e4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fa6e8: 0x24a4001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 30));
    // 0x1fa6ec: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1fa6f0: 0x43200b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1fa6f4: 0xe0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1fa6f8: 0x42903
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 4), 4));
    // 0x1fa6fc: 0xa0e00000
    WRITE8(ADD32(GPR_U32(ctx, 7), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1fa700: 0x18a0000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_1fa72c;
    }
    // 0x1fa708: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1fa70c: 0x0
    // NOP
label_1fa710:
    // 0x1fa710: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fa714: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1fa718: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1fa71c: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x1fa720: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1fa724: 0x1480fffa
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1fa710;
    }
label_1fa72c:
    // 0x1fa72c: 0xc07db34
    SET_GPR_U32(ctx, 31, 0x1fa734);
    isceSifSetDChain(rdram, ctx, runtime); return;
}


// Function: entry_1fa734
// Address: 0x1fa734 - 0x1fa780

void entry_1fa734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa734: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fa738: 0x4610013
    if (GPR_S32(ctx, 3) >= 0) {
        ctx->pc = 0x1FA788; return;
    }
    // 0x1fa740: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fa744: 0x3c037fff
    SET_GPR_U32(ctx, 3, ((uint32_t)32767 << 16));
    // 0x1fa748: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1fa74c: 0x8e040010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1fa750: 0x432824
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fa754: 0xa4202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    // 0x1fa758: 0x10800018
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1fa7bc(rdram, ctx, runtime); return;
    }
    // 0x1fa760: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1fa764: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fa768: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fa76c: 0x10c00013
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1fa7bc(rdram, ctx, runtime); return;
    }
    // 0x1fa774: 0x8c450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1fa778: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1fa780);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1fa780
// Address: 0x1fa780 - 0x1fa7bc

void entry_1fa780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa780) {
        switch (ctx->pc) {
            case 0x1fa788: ctx->pc = 0; goto label_1fa788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa780: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fa7bc(rdram, ctx, runtime); return;
    }
label_1fa788:
    // 0x1fa788: 0x8fa50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fa78c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1fa790: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1fa794: 0x10400009
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1fa7bc(rdram, ctx, runtime); return;
    }
    // 0x1fa79c: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1fa7a0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fa7a4: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fa7a8: 0x10c00004
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1fa7bc(rdram, ctx, runtime); return;
    }
    // 0x1fa7b0: 0x8c450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1fa7b4: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1fa7bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1fa7bc
// Address: 0x1fa7bc - 0x1fa7d8

void entry_1fa7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa7bc) {
        switch (ctx->pc) {
            case 0x1fa7c8: ctx->pc = 0; goto label_1fa7c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa7bc: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1fa7c0: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x1fa7c4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1fa7c8:
    // 0x1fa7c8: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1fa7cc: 0xdfb00070
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1fa7d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceSifWriteBackDCache
// Address: 0x1fa7d8 - 0x1fa890

void entry_1fa8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa8f8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1fa8fc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1fa900: 0xffb20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 18));
    // 0x1fa904: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x1fa908: 0x24120003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1fa90c: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1fa910: 0xffbf0030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 31));
    // 0x1fa914: 0x24507d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 32048));
    // 0x1fa918: 0x8c447d30
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 32048)));
    // 0x1fa91c: 0x26110018
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 24));
    // 0x1fa920: 0xc07ea3a
    SET_GPR_U32(ctx, 31, 0x1fa928);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    SetSyscall3(rdram, ctx, runtime); return;
}


// Function: entry_1fa928
// Address: 0x1fa928 - 0x1fa940

void entry_1fa928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa928: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1fa92c: 0x3c048007
    SET_GPR_U32(ctx, 4, ((uint32_t)32775 << 16));
    // 0x1fa930: 0x24060328
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 808));
    // 0x1fa934: 0x24a579c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 31168));
    // 0x1fa938: 0xc07ea24
    SET_GPR_U32(ctx, 31, 0x1fa940);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 20480));
    iReferEventFlagStatus(rdram, ctx, runtime); return;
}


// Function: entry_1fa940
// Address: 0x1fa940 - 0x1fa948

void entry_1fa940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa940: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1fa948);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa948
// Address: 0x1fa948 - 0x1fa950

void entry_1fa948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa948: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x1fa950);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_1fa950
// Address: 0x1fa950 - 0x1fa95c

void entry_1fa950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa950: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fa954: 0xc07ea3a
    SET_GPR_U32(ctx, 31, 0x1fa95c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    SetSyscall3(rdram, ctx, runtime); return;
}


// Function: entry_1fa95c
// Address: 0x1fa95c - 0x1fa968

void entry_1fa95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa95c: 0x8e040010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1fa960: 0xc07ea3a
    SET_GPR_U32(ctx, 31, 0x1fa968);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    SetSyscall3(rdram, ctx, runtime); return;
}


// Function: entry_1fa968
// Address: 0x1fa968 - 0x1fa970

void entry_1fa968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa968: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fa96c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa970; return;
}


// Function: entry_1fa970
// Address: 0x1fa970 - 0x1fa978

void entry_1fa970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa970: 0xc07ea36
    SET_GPR_U32(ctx, 31, 0x1fa978);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    RFU0912(rdram, ctx, runtime); return;
}


// Function: entry_1fa978
// Address: 0x1fa978 - 0x1fa988

void entry_1fa978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa978: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fa97c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fa980: 0xc07ea3a
    SET_GPR_U32(ctx, 31, 0x1fa988);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    SetSyscall3(rdram, ctx, runtime); return;
}


// Function: entry_1fa988
// Address: 0x1fa988 - 0x1fa9b0

void entry_1fa988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa988: 0x2e420008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 8));
    // 0x1fa98c: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        entry_1fa970(rdram, ctx, runtime); return;
    }
    // 0x1fa994: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fa998: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fa99c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fa9a0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fa9a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fa9ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fa9b0; return;
}


// Function: fn__SetTLBEntry
// Address: 0x1fa9b0 - 0x1fa9c0

void entry_1fa9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fa9d0: 0x3c030200
    SET_GPR_U32(ctx, 3, ((uint32_t)512 << 16));
    // 0x1fa9d4: 0x14430005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1FA9EC; return;
    }
    // 0x1fa9dc: 0xc07ea80
    SET_GPR_U32(ctx, 31, 0x1fa9e4);
    InitTLB32MB(rdram, ctx, runtime); return;
}


// Function: entry_1fa9e4
// Address: 0x1fa9e4 - 0x1fa9f4

void entry_1fa9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa9e4) {
        switch (ctx->pc) {
            case 0x1fa9ec: ctx->pc = 0; goto label_1fa9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa9e4: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FA9F8; return;
    }
label_1fa9ec:
    // 0x1fa9ec: 0xc07db4c
    SET_GPR_U32(ctx, 31, 0x1fa9f4);
    fn__InitTLB(rdram, ctx, runtime); return;
}


// Function: entry_1fa9f4
// Address: 0x1fa9f4 - 0x1faa00

void entry_1fa9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fa9f4) {
        switch (ctx->pc) {
            case 0x1fa9f8: ctx->pc = 0; goto label_1fa9f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fa9f4: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_1fa9f8:
    // 0x1fa9f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitTLB32MB
// Address: 0x1faa00 - 0x1faa50

void entry_1faa50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1faa50: 0x40803000
    ctx->cop0_wired = GPR_U32(ctx, 0) & 0x3F; ctx->cop0_random = 47;
    // 0x1faa54: 0x40f
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1faa58: 0x8e517fe0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 32736)));
    // 0x1faa5c: 0x2a220031
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 49));
    // 0x1faa60: 0x14400006
    SET_GPR_U64(ctx, 25, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1faa7c(rdram, ctx, runtime); return;
    }
    // 0x1faa68: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1faa6c: 0xc07ded4
    SET_GPR_U32(ctx, 31, 0x1faa74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962280));
    kprintf(rdram, ctx, runtime); return;
}


// Function: entry_1faa74
// Address: 0x1faa74 - 0x1faa7c

void entry_1faa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1faa74: 0xc07e81e
    SET_GPR_U32(ctx, 31, 0x1faa7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    Exit(rdram, ctx, runtime); return;
}


// Function: entry_1faa7c
// Address: 0x1faa7c - 0x1faaa8

void entry_1faa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1faa7c) {
        switch (ctx->pc) {
            case 0x1faa90: ctx->pc = 0; goto label_1faa90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1faa7c: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    // 0x1faa80: 0x1040000d
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAAB8; return;
    }
    // 0x1faa88: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1faa8c: 0x0
    // NOP
label_1faa90:
    // 0x1faa90: 0x320202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
    // 0x1faa94: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1faa98: 0x8e070008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1faa9c: 0x8e08000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1faaa0: 0xc07ea6c
    SET_GPR_U32(ctx, 31, 0x1faaa8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    fn__SetTLBEntry(rdram, ctx, runtime); return;
}


// Function: entry_1faaa8
// Address: 0x1faaa8 - 0x1faadc

void entry_1faaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1faaa8) {
        switch (ctx->pc) {
            case 0x1faab8: ctx->pc = 0; goto label_1faab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1faaa8: 0x27390001
    SET_GPR_S32(ctx, 25, ADD32(GPR_U32(ctx, 25), 1));
    // 0x1faaac: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    // 0x1faab0: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1FAA90; return;
    }
label_1faab8:
    // 0x1faab8: 0x26507fe0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 32736));
    // 0x1faabc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1faac0: 0x3228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 25), GPR_U32(ctx, 2)));
    // 0x1faac4: 0x2a230031
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), 49));
    // 0x1faac8: 0x14600007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAAE8; return;
    }
    // 0x1faad0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1faad4: 0xc07ded4
    SET_GPR_U32(ctx, 31, 0x1faadc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962304));
    kprintf(rdram, ctx, runtime); return;
}


// Function: entry_1faadc
// Address: 0x1faadc - 0x1faae4

void entry_1faadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1faadc: 0xc07e81e
    SET_GPR_U32(ctx, 31, 0x1faae4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    Exit(rdram, ctx, runtime); return;
}


// Function: entry_1faae4
// Address: 0x1faae4 - 0x1fab10

void entry_1faae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1faae4) {
        switch (ctx->pc) {
            case 0x1faae8: ctx->pc = 0; goto label_1faae8;
            case 0x1faaf8: ctx->pc = 0; goto label_1faaf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1faae4: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
label_1faae8:
    // 0x1faae8: 0x1040000d
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAB20; return;
    }
    // 0x1faaf0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1faaf4: 0x0
    // NOP
label_1faaf8:
    // 0x1faaf8: 0x320202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
    // 0x1faafc: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1fab00: 0x8e070008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fab04: 0x8e08000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1fab08: 0xc07ea6c
    SET_GPR_U32(ctx, 31, 0x1fab10);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    fn__SetTLBEntry(rdram, ctx, runtime); return;
}


// Function: entry_1fab10
// Address: 0x1fab10 - 0x1fab58

void entry_1fab10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fab10) {
        switch (ctx->pc) {
            case 0x1fab20: ctx->pc = 0; goto label_1fab20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fab10: 0x27390001
    SET_GPR_S32(ctx, 25, ADD32(GPR_U32(ctx, 25), 1));
    // 0x1fab14: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    // 0x1fab18: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1FAAF8; return;
    }
label_1fab20:
    // 0x1fab20: 0x26507fe0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 32736));
    // 0x1fab24: 0xae19000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 25));
    // 0x1fab28: 0x40993000
    ctx->cop0_wired = GPR_U32(ctx, 25) & 0x3F; ctx->cop0_random = 47;
    // 0x1fab2c: 0x40f
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1fab30: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fab34: 0x58400019
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
        ctx->pc = 0x1FAB9C; return;
    }
    // 0x1fab3c: 0x3228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 25), GPR_U32(ctx, 2)));
    // 0x1fab40: 0x2a220031
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 49));
    // 0x1fab44: 0x14400007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAB64; return;
    }
    // 0x1fab4c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1fab50: 0xc07ded4
    SET_GPR_U32(ctx, 31, 0x1fab58);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962328));
    kprintf(rdram, ctx, runtime); return;
}


// Function: entry_1fab58
// Address: 0x1fab58 - 0x1fab60

void entry_1fab58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fab58: 0xc07e81e
    SET_GPR_U32(ctx, 31, 0x1fab60);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    Exit(rdram, ctx, runtime); return;
}


// Function: entry_1fab60
// Address: 0x1fab60 - 0x1fab88

void entry_1fab60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fab60) {
        switch (ctx->pc) {
            case 0x1fab64: ctx->pc = 0; goto label_1fab64;
            case 0x1fab70: ctx->pc = 0; goto label_1fab70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fab60: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
label_1fab64:
    // 0x1fab64: 0x1040000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAB98; return;
    }
    // 0x1fab6c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1fab70:
    // 0x1fab70: 0x320202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
    // 0x1fab74: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1fab78: 0x8e070008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fab7c: 0x8e08000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1fab80: 0xc07ea6c
    SET_GPR_U32(ctx, 31, 0x1fab88);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    fn__SetTLBEntry(rdram, ctx, runtime); return;
}


// Function: entry_1fab88
// Address: 0x1fab88 - 0x1fabcc

void entry_1fab88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fab88) {
        switch (ctx->pc) {
            case 0x1fab98: ctx->pc = 0; goto label_1fab98;
            case 0x1fab9c: ctx->pc = 0; goto label_1fab9c;
            case 0x1fabb0: ctx->pc = 0; goto label_1fabb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fab88: 0x27390001
    SET_GPR_S32(ctx, 25, ADD32(GPR_U32(ctx, 25), 1));
    // 0x1fab8c: 0x331102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 25), GPR_S32(ctx, 17)));
    // 0x1fab90: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1FAB70; return;
    }
label_1fab98:
    // 0x1fab98: 0x320802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
label_1fab9c:
    // 0x1fab9c: 0x2a020030
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 48));
    // 0x1faba0: 0x1040000d
    SET_GPR_U32(ctx, 25, SLL32(GPR_U32(ctx, 25), 13));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FABD8; return;
    }
    // 0x1faba8: 0x3c02e000
    SET_GPR_U32(ctx, 2, ((uint32_t)57344 << 16));
    // 0x1fabac: 0x3228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 25), GPR_U32(ctx, 2)));
label_1fabb0:
    // 0x1fabb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fabb4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fabb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fabbc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fabc0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fabc4: 0xc07ea6c
    SET_GPR_U32(ctx, 31, 0x1fabcc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    fn__SetTLBEntry(rdram, ctx, runtime); return;
}


// Function: entry_1fabcc
// Address: 0x1fabcc - 0x1fac14

void entry_1fabcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fabcc) {
        switch (ctx->pc) {
            case 0x1fabd8: ctx->pc = 0; goto label_1fabd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fabcc: 0x2a020030
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 48));
    // 0x1fabd0: 0x1440fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8192));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FABB0; return;
    }
label_1fabd8:
    // 0x1fabd8: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fabdc: 0x320102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 25) + GPR_U64(ctx, 0));
    // 0x1fabe0: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fabe4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fabe8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fabec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fabf4: 0x0
    // NOP
    // 0x1fabf8: 0x0
    // NOP
    // 0x1fabfc: 0x0
    // NOP
    // 0x1fac00: 0x3c010000
    SET_GPR_U32(ctx, 1, ((uint32_t)0 << 16));
    // 0x1fac04: 0x8c210000
    SET_GPR_U32(ctx, 1, READ32(ADD32(GPR_U32(ctx, 1), 0)));
    // 0x1fac08: 0x3c1d0000
    SET_GPR_U32(ctx, 29, ((uint32_t)0 << 16));
    // 0x1fac0c: 0x20f809
    SET_GPR_U32(ctx, 31, 0x1fac14);
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4096));
    ctx->pc = GPR_U32(ctx, 1); return;
}


// Function: entry_1fac14
// Address: 0x1fac14 - 0x1fac40

void entry_1fac14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fac14: 0x2403ffac
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967212));
    // 0x1fac18: 0xc
    runtime->handleSyscall(rdram, ctx);
    // 0x1fac1c: 0x0
    // NOP
    // 0x1fac20: 0x0
    // NOP
    // 0x1fac24: 0x0
    // NOP
    // 0x1fac28: 0x0
    // NOP
    // 0x1fac2c: 0x0
    // NOP
    // 0x1fac30: 0x0
    // NOP
    // 0x1fac34: 0x0
    // NOP
    // 0x1fac38: 0x0
    // NOP
    // 0x1fac3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fac40; return;
}


// Function: _kExitTLBHandler
// Address: 0x1fac40 - 0x1fad58

void entry_1fad58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fad58) {
        switch (ctx->pc) {
            case 0x1fad68: ctx->pc = 0; goto label_1fad68;
            case 0x1fada8: ctx->pc = 0; goto label_1fada8;
            case 0x1fadcc: ctx->pc = 0; goto label_1fadcc;
            case 0x1fadf0: ctx->pc = 0; goto label_1fadf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fad58: 0x3ffffcd
    runtime->handleBreak(rdram, ctx);
    // 0x1fad5c: 0x0
    // NOP
    // 0x1fad60: 0x27bd0020
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fad64: 0x0
    // NOP
label_1fad68:
    // 0x1fad68: 0x3c070028
    SET_GPR_U32(ctx, 7, ((uint32_t)40 << 16));
    // 0x1fad6c: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1fad70: 0x8ce5b130
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 4294947120)));
    // 0x1fad74: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fad78: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1fad7c: 0x24e3b130
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 4294947120));
    // 0x1fad80: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x1fad84: 0x14a20011
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1fadcc;
    }
    // 0x1fad8c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fad90: 0x1040000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fadcc;
    }
    // 0x1fad98: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fad9c: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1fada0: 0x24e4b130
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 7), 4294947120));
    // 0x1fada4: 0x0
    // NOP
label_1fada8:
    // 0x1fada8: 0x64a30001
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 5) + (int64_t)1);
    // 0x1fadac: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fadb0: 0x6103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1fadb4: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fadb8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1fadbc: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1fadc0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fadc4: 0x5460fff8
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
        goto label_1fada8;
    }
label_1fadcc:
    // 0x1fadcc: 0x5883c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fadd0: 0x11883f
    SET_GPR_S64(ctx, 17, GPR_S64(ctx, 17) >> (32 + 0));
    // 0x1fadd4: 0x1220000b
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FAE04; return;
    }
    // 0x1faddc: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1fade0: 0x2442b130
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947120));
    // 0x1fade4: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fade8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fadec: 0x0
    // NOP
label_1fadf0:
    // 0x1fadf0: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1fadf4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fadfc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967292));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fadfc
// Address: 0x1fadfc - 0x1fae18

void entry_1fadfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fadfc) {
        switch (ctx->pc) {
            case 0x1fae04: ctx->pc = 0; goto label_1fae04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fadfc: 0x5620fffc
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1FADF0; return;
    }
label_1fae04:
    // 0x1fae04: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fae08: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fae0c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fae10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___main__Fv
// Address: 0x1fae18 - 0x1fae38

void entry_1fb548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb548: 0x440002c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1FB5FC; return;
    }
    // 0x1fb550: 0x3405f7c0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 63424));
    // 0x1fb554: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x1fb558: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1fb560);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1fb560
// Address: 0x1fb560 - 0x1fb568

void entry_1fb560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb560: 0xc07f52a
    SET_GPR_U32(ctx, 31, 0x1fb568);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptoul(rdram, ctx, runtime); return;
}


// Function: entry_1fb568
// Address: 0x1fb568 - 0x1fb57c

void entry_1fb568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb568: 0x2803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fb56c: 0x6000005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 1));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x1FB584; return;
    }
    // 0x1fb574: 0xc07ed86
    SET_GPR_U32(ctx, 31, 0x1fb57c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___floatdidf(rdram, ctx, runtime); return;
}


// Function: entry_1fb57c
// Address: 0x1fb57c - 0x1fb590

void entry_1fb57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb57c) {
        switch (ctx->pc) {
            case 0x1fb584: ctx->pc = 0; goto label_1fb584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb57c: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FB5A0; return;
    }
label_1fb584:
    // 0x1fb584: 0x10207a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) >> 1);
    // 0x1fb588: 0xc07ed86
    SET_GPR_U32(ctx, 31, 0x1fb590);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    fn___floatdidf(rdram, ctx, runtime); return;
}


// Function: entry_1fb590
// Address: 0x1fb590 - 0x1fb59c

void entry_1fb590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb590: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fb594: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1fb59c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1fb59c
// Address: 0x1fb59c - 0x1fb5a8

void entry_1fb59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb59c) {
        switch (ctx->pc) {
            case 0x1fb5a0: ctx->pc = 0; goto label_1fb5a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb59c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1fb5a0:
    // 0x1fb5a0: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x1fb5a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_1fb5a8
// Address: 0x1fb5a8 - 0x1fb5bc

void entry_1fb5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb5a8: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fb5ac: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fb5b0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1fb5b4: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1fb5bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1fb5bc
// Address: 0x1fb5bc - 0x1fb5cc

void entry_1fb5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb5bc: 0x4410009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1FB5E4; return;
    }
    // 0x1fb5c4: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x1fb5cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_1fb5cc
// Address: 0x1fb5cc - 0x1fb5d4

void entry_1fb5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb5cc: 0xc07f52a
    SET_GPR_U32(ctx, 31, 0x1fb5d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptoul(rdram, ctx, runtime); return;
}


// Function: entry_1fb5d4
// Address: 0x1fb5d4 - 0x1fb5ec

void entry_1fb5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb5d4) {
        switch (ctx->pc) {
            case 0x1fb5e4: ctx->pc = 0; goto label_1fb5e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb5d4: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fb5d8: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fb5dc: 0x10000006
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) - GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FB5F8; return;
    }
label_1fb5e4:
    // 0x1fb5e4: 0xc07f52a
    SET_GPR_U32(ctx, 31, 0x1fb5ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dptoul(rdram, ctx, runtime); return;
}


// Function: entry_1fb5ec
// Address: 0x1fb5ec - 0x1fb618

void entry_1fb5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb5ec) {
        switch (ctx->pc) {
            case 0x1fb5f8: ctx->pc = 0; goto label_1fb5f8;
            case 0x1fb5fc: ctx->pc = 0; goto label_1fb5fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb5ec: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fb5f0: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fb5f4: 0x202802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) + GPR_U64(ctx, 2));
label_1fb5f8:
    // 0x1fb5f8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1fb5fc:
    // 0x1fb5fc: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fb600: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fb604: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fb608: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fb60c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fb614: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fb618; return;
}


// Function: fn___floatdidf
// Address: 0x1fb618 - 0x1fb640

void entry_1fb640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb640: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fb644: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1fb64c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1fb64c
// Address: 0x1fb64c - 0x1fb658

void entry_1fb64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb64c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fb650: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1fb658);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1fb658
// Address: 0x1fb658 - 0x1fb678

void entry_1fb658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb658: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fb65c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1fb660: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fb664: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1fb668: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x1fb66c: 0x10803f
    SET_GPR_S64(ctx, 16, GPR_S64(ctx, 16) >> (32 + 0));
    // 0x1fb670: 0xc07f4d6
    SET_GPR_U32(ctx, 31, 0x1fb678);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    litodp(rdram, ctx, runtime); return;
}


// Function: entry_1fb678
// Address: 0x1fb678 - 0x1fb690

void entry_1fb678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb678: 0x6010006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1FB694; return;
    }
    // 0x1fb680: 0x340583e0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 33760));
    // 0x1fb684: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x1fb688: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1fb690);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1fb690
// Address: 0x1fb690 - 0x1fb69c

void entry_1fb690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb690) {
        switch (ctx->pc) {
            case 0x1fb694: ctx->pc = 0; goto label_1fb694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb690: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1fb694:
    // 0x1fb694: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1fb69c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1fb69c
// Address: 0x1fb69c - 0x1fb6b0

void entry_1fb69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb69c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fb6a0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fb6a4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fb6a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___floatdisf
// Address: 0x1fb6b0 - 0x1fb714

void entry_1fb714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb714: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fb718: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1fb720);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1fb720
// Address: 0x1fb720 - 0x1fb72c

void entry_1fb720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb720: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fb724: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1fb72c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1fb72c
// Address: 0x1fb72c - 0x1fb74c

void entry_1fb72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb72c: 0x3c10ffff
    SET_GPR_U32(ctx, 16, ((uint32_t)65535 << 16));
    // 0x1fb730: 0x10803e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) >> (32 + 0));
    // 0x1fb734: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fb738: 0x2308024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1fb73c: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x1fb740: 0x10803f
    SET_GPR_S64(ctx, 16, GPR_S64(ctx, 16) >> (32 + 0));
    // 0x1fb744: 0xc07f4d6
    SET_GPR_U32(ctx, 31, 0x1fb74c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    litodp(rdram, ctx, runtime); return;
}


// Function: entry_1fb74c
// Address: 0x1fb74c - 0x1fb764

void entry_1fb74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb74c: 0x6030006
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        ctx->pc = 0x1FB768; return;
    }
    // 0x1fb754: 0x340583e0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 33760));
    // 0x1fb758: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x1fb75c: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1fb764);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1fb764
// Address: 0x1fb764 - 0x1fb770

void entry_1fb764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb764) {
        switch (ctx->pc) {
            case 0x1fb768: ctx->pc = 0; goto label_1fb768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb764: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1fb768:
    // 0x1fb768: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1fb770);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1fb770
// Address: 0x1fb770 - 0x1fb778

void entry_1fb770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb770: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x1fb778);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_1fb778
// Address: 0x1fb778 - 0x1fb790

void entry_1fb778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fb778: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fb77c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fb780: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fb784: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fb788: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fb790
// Address: 0x1fb790 - 0x1fbe00

void FUN_001fb790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fb790) {
        switch (ctx->pc) {
            case 0x1fb804: ctx->pc = 0; goto label_1fb804;
            case 0x1fb858: ctx->pc = 0; goto label_1fb858;
            case 0x1fb8a8: ctx->pc = 0; goto label_1fb8a8;
            case 0x1fb8c0: ctx->pc = 0; goto label_1fb8c0;
            case 0x1fb8fc: ctx->pc = 0; goto label_1fb8fc;
            case 0x1fb910: ctx->pc = 0; goto label_1fb910;
            case 0x1fb924: ctx->pc = 0; goto label_1fb924;
            case 0x1fb938: ctx->pc = 0; goto label_1fb938;
            case 0x1fb950: ctx->pc = 0; goto label_1fb950;
            case 0x1fb968: ctx->pc = 0; goto label_1fb968;
            case 0x1fb9a0: ctx->pc = 0; goto label_1fb9a0;
            case 0x1fb9d4: ctx->pc = 0; goto label_1fb9d4;
            case 0x1fba20: ctx->pc = 0; goto label_1fba20;
            case 0x1fba24: ctx->pc = 0; goto label_1fba24;
            case 0x1fba34: ctx->pc = 0; goto label_1fba34;
            case 0x1fba78: ctx->pc = 0; goto label_1fba78;
            case 0x1fba7c: ctx->pc = 0; goto label_1fba7c;
            case 0x1fba88: ctx->pc = 0; goto label_1fba88;
            case 0x1fba94: ctx->pc = 0; goto label_1fba94;
            case 0x1fbad8: ctx->pc = 0; goto label_1fbad8;
            case 0x1fbadc: ctx->pc = 0; goto label_1fbadc;
            case 0x1fbaec: ctx->pc = 0; goto label_1fbaec;
            case 0x1fbb2c: ctx->pc = 0; goto label_1fbb2c;
            case 0x1fbb44: ctx->pc = 0; goto label_1fbb44;
            case 0x1fbb64: ctx->pc = 0; goto label_1fbb64;
            case 0x1fbb88: ctx->pc = 0; goto label_1fbb88;
            case 0x1fbba0: ctx->pc = 0; goto label_1fbba0;
            case 0x1fbbe0: ctx->pc = 0; goto label_1fbbe0;
            case 0x1fbbf0: ctx->pc = 0; goto label_1fbbf0;
            case 0x1fbc08: ctx->pc = 0; goto label_1fbc08;
            case 0x1fbc44: ctx->pc = 0; goto label_1fbc44;
            case 0x1fbc98: ctx->pc = 0; goto label_1fbc98;
            case 0x1fbc9c: ctx->pc = 0; goto label_1fbc9c;
            case 0x1fbca4: ctx->pc = 0; goto label_1fbca4;
            case 0x1fbcfc: ctx->pc = 0; goto label_1fbcfc;
            case 0x1fbd00: ctx->pc = 0; goto label_1fbd00;
            case 0x1fbd40: ctx->pc = 0; goto label_1fbd40;
            case 0x1fbd50: ctx->pc = 0; goto label_1fbd50;
            case 0x1fbd88: ctx->pc = 0; goto label_1fbd88;
            case 0x1fbd8c: ctx->pc = 0; goto label_1fbd8c;
            case 0x1fbde8: ctx->pc = 0; goto label_1fbde8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fb790: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1fb794: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1fb798: 0xffb00030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 16));
    // 0x1fb79c: 0x8503f
    SET_GPR_S64(ctx, 10, GPR_S64(ctx, 8) >> (32 + 0));
    // 0x1fb7a0: 0xa203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 10) << (32 + 0));
    // 0x1fb7a4: 0x4203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fb7a8: 0x4810016
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1fb804;
    }
    // 0x1fb7b0: 0x8103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) << (32 + 0));
    // 0x1fb7b4: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fb7b8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fb7bc: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fb7c0: 0x21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fb7c4: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fb7c8: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fb7cc: 0x41823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x1fb7d0: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fb7d4: 0x3c04ffff
    SET_GPR_U32(ctx, 4, ((uint32_t)65535 << 16));
    // 0x1fb7d8: 0x4203e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) >> (32 + 0));
    // 0x1fb7dc: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1fb7e0: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fb7e4: 0x6103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1fb7e8: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fb7ec: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fb7f0: 0xc43024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1fb7f4: 0x621823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fb7f8: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fb7fc: 0xc34025
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fb800: 0x8503f
    SET_GPR_S64(ctx, 10, GPR_S64(ctx, 8) >> (32 + 0));
label_1fb804:
    // 0x1fb804: 0x5203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1fb808: 0x4810013
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1fb858;
    }
    // 0x1fb810: 0x5103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fb814: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fb818: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fb81c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fb820: 0x21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fb824: 0xe33824
    SET_GPR_U32(ctx, 7, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x1fb828: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fb82c: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fb830: 0x3c05ffff
    SET_GPR_U32(ctx, 5, ((uint32_t)65535 << 16));
    // 0x1fb834: 0x5283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) >> (32 + 0));
    // 0x1fb838: 0xe23825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x1fb83c: 0x7183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 7) << (32 + 0));
    // 0x1fb840: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fb844: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1fb848: 0xe53824
    SET_GPR_U32(ctx, 7, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x1fb84c: 0x832023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1fb850: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1fb854: 0xe42825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
label_1fb858:
    // 0x1fb858: 0x8603c
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 8) << (32 + 0));
    // 0x1fb85c: 0xc603f
    SET_GPR_S64(ctx, 12, GPR_S64(ctx, 12) >> (32 + 0));
    // 0x1fb860: 0x5483f
    SET_GPR_S64(ctx, 9, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1fb864: 0xa503c
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 10) << (32 + 0));
    // 0x1fb868: 0xa503f
    SET_GPR_S64(ctx, 10, GPR_S64(ctx, 10) >> (32 + 0));
    // 0x1fb86c: 0x5403c
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fb870: 0x8403f
    SET_GPR_S64(ctx, 8, GPR_S64(ctx, 8) >> (32 + 0));
    // 0x1fb874: 0x152000b3
    SET_GPR_U64(ctx, 25, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 9) != GPR_U32(ctx, 0)) {
        goto label_1fbb44;
    }
    // 0x1fb87c: 0x148102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 10), GPR_U32(ctx, 8)));
    // 0x1fb880: 0x10400023
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fb910;
    }
    // 0x1fb888: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1fb88c: 0x14400006
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fb8a8;
    }
    // 0x1fb894: 0x2d020100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), 256));
    // 0x1fb898: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fb89c: 0x10000008
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fb8c0;
    }
    // 0x1fb8a4: 0x0
    // NOP
label_1fb8a8:
    // 0x1fb8a8: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fb8ac: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fb8b0: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fb8b4: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1fb8b8: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1fb8bc: 0x0
    // NOP
label_1fb8c0:
    // 0x1fb8c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fb8c4: 0xa82006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 8), GPR_U32(ctx, 5) & 0x1F));
    // 0x1fb8c8: 0x2442edb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962608));
    // 0x1fb8cc: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fb8d0: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fb8d4: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fb8d8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fb8dc: 0xc36823
    SET_GPR_U32(ctx, 13, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fb8e0: 0x11a00006
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 13)));
    if (GPR_U32(ctx, 13) == GPR_U32(ctx, 0)) {
        goto label_1fb8fc;
    }
    // 0x1fb8e8: 0x1aa1804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 10), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fb8ec: 0x4c1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 2) & 0x1F));
    // 0x1fb8f0: 0x1a84004
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 8), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fb8f4: 0x625025
    SET_GPR_U32(ctx, 10, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fb8f8: 0x1ac6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 13) & 0x1F));
label_1fb8fc:
    // 0x1fb8fc: 0x82c02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 8), 16));
    // 0x1fb900: 0x3107ffff
    SET_GPR_U32(ctx, 7, AND32(GPR_U32(ctx, 8), 65535));
    // 0x1fb904: 0x10000060
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 10) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,10); } }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fba88;
    }
    // 0x1fb90c: 0x0
    // NOP
label_1fb910:
    // 0x1fb910: 0x15000009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_1fb938;
    }
    // 0x1fb918: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fb91c: 0x51000001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fb924;
    }
label_1fb924:
    // 0x1fb924: 0x49001b
    { uint32_t divisor = GPR_U32(ctx, 9); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 2) / divisor; ctx->hi = GPR_U32(ctx, 9) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,2); } }
    // 0x1fb928: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fb92c: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fb930: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1fb934: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
label_1fb938:
    // 0x1fb938: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fb950;
    }
    // 0x1fb940: 0x2d020100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), 256));
    // 0x1fb944: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fb948: 0x10000007
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fb968;
    }
label_1fb950:
    // 0x1fb950: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fb954: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fb958: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fb95c: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1fb960: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1fb964: 0x0
    // NOP
label_1fb968:
    // 0x1fb968: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fb96c: 0xa82006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 8), GPR_U32(ctx, 5) & 0x1F));
    // 0x1fb970: 0x2442edb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962608));
    // 0x1fb974: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fb978: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fb97c: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fb980: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fb984: 0xc36823
    SET_GPR_U32(ctx, 13, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fb988: 0x15a00005
    SET_GPR_U32(ctx, 14, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 13)));
    if (GPR_U32(ctx, 13) != GPR_U32(ctx, 0)) {
        goto label_1fb9a0;
    }
    // 0x1fb990: 0x1485023
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 10), GPR_U32(ctx, 8)));
    // 0x1fb994: 0x82c02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 8), 16));
    // 0x1fb998: 0x10000038
    SET_GPR_U32(ctx, 9, AND32(GPR_U32(ctx, 8), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fba7c;
    }
label_1fb9a0:
    // 0x1fb9a0: 0x1aa1804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 10), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fb9a4: 0x1cc1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fb9a8: 0x1ca3806
    SET_GPR_U32(ctx, 7, SRL32(GPR_U32(ctx, 10), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fb9ac: 0x625025
    SET_GPR_U32(ctx, 10, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fb9b0: 0x1a84004
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 8), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fb9b4: 0x1ac6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fb9b8: 0x82c02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 8), 16));
    // 0x1fb9bc: 0xe5001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 7) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,7); } }
    // 0x1fb9c0: 0x3109ffff
    SET_GPR_U32(ctx, 9, AND32(GPR_U32(ctx, 8), 65535));
    // 0x1fb9c4: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1fb9c8: 0xa2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 10), 16));
    // 0x1fb9cc: 0x50e00001
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fb9d4;
    }
label_1fb9d4:
    // 0x1fb9d4: 0x120582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1fb9d8: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fb9dc: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fb9e0: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fb9e4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fb9e8: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fb9ec: 0x493018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fb9f0: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fb9f4: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fb9f8: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fba24;
    }
    // 0x1fba00: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fba04: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fba08: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fba24;
    }
    // 0x1fba10: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fba14: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
        goto label_1fba20;
    }
    // 0x1fba1c: 0x0
    // NOP
label_1fba20:
    // 0x1fba20: 0x661823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fba24:
    // 0x1fba24: 0x3144ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 10), 65535));
    // 0x1fba28: 0x67001b
    { uint32_t divisor = GPR_U32(ctx, 7); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 7) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fba2c: 0x50e00001
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fba34;
    }
label_1fba34:
    // 0x1fba34: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fba38: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fba3c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fba40: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fba44: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fba48: 0x4b3018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fba4c: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fba50: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fba54: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fba7c;
    }
    // 0x1fba5c: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fba60: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fba64: 0x14400005
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fba7c;
    }
    // 0x1fba6c: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fba70: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
        goto label_1fba78;
    }
label_1fba78:
    // 0x1fba78: 0x665023
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fba7c:
    // 0x1fba7c: 0x145001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 10) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,10); } }
    // 0x1fba80: 0x120382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1fba84: 0x0
    // NOP
label_1fba88:
    // 0x1fba88: 0xc2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 12), 16));
    // 0x1fba8c: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fba94;
    }
label_1fba94:
    // 0x1fba94: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fba98: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fba9c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbaa0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbaa4: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbaa8: 0x473018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbaac: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbab0: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbab4: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fbadc;
    }
    // 0x1fbabc: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fbac0: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fbac4: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fbadc;
    }
    // 0x1fbacc: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbad0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
        goto label_1fbad8;
    }
label_1fbad8:
    // 0x1fbad8: 0x661823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fbadc:
    // 0x1fbadc: 0x3184ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 12), 65535));
    // 0x1fbae0: 0x65001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fbae4: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbaec;
    }
label_1fbaec:
    // 0x1fbaec: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbaf0: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fbaf4: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbaf8: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbafc: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbb00: 0x473018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbb04: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbb08: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbb0c: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbb2c;
    }
    // 0x1fbb14: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fbb18: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fbb1c: 0x14400003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbb2c;
    }
    // 0x1fbb24: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
        goto label_1fbb2c;
    }
label_1fbb2c:
    // 0x1fbb2c: 0x13200097
    SET_GPR_U32(ctx, 12, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 25) == GPR_U32(ctx, 0)) {
        goto label_1fbd8c;
    }
    // 0x1fbb34: 0x1ac1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbb38: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fbb3c: 0x10000092
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 2) >> (32 + 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbd88;
    }
label_1fbb44:
    // 0x1fbb44: 0x149102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 10), GPR_U32(ctx, 9)));
    // 0x1fbb48: 0x10400006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 12) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbb64;
    }
    // 0x1fbb50: 0xa183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 10) << (32 + 0));
    // 0x1fbb54: 0x2783e
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fbb58: 0x1e37825
    SET_GPR_U32(ctx, 15, OR32(GPR_U32(ctx, 15), GPR_U32(ctx, 3)));
    // 0x1fbb5c: 0x1000008b
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 15));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbd8c;
    }
label_1fbb64:
    // 0x1fbb64: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1fbb68: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbb6c: 0x14400006
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbb88;
    }
    // 0x1fbb74: 0x2d220100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), 256));
    // 0x1fbb78: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fbb7c: 0x10000008
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbba0;
    }
    // 0x1fbb84: 0x0
    // NOP
label_1fbb88:
    // 0x1fbb88: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fbb8c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fbb90: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fbb94: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbb98: 0x62300a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
    // 0x1fbb9c: 0x0
    // NOP
label_1fbba0:
    // 0x1fbba0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fbba4: 0xc92006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 9), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fbba8: 0x2442edb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962608));
    // 0x1fbbac: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fbbb0: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fbbb4: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fbbb8: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbbbc: 0xa36823
    SET_GPR_U32(ctx, 13, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1fbbc0: 0x15a00011
    SET_GPR_U32(ctx, 14, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 13)));
    if (GPR_U32(ctx, 13) != GPR_U32(ctx, 0)) {
        goto label_1fbc08;
    }
    // 0x1fbbc8: 0x12a102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), GPR_U32(ctx, 10)));
    // 0x1fbbcc: 0x14400004
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 12), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbbe0;
    }
    // 0x1fbbd4: 0x188102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 8)));
    // 0x1fbbd8: 0x14400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbbf0;
    }
label_1fbbe0:
    // 0x1fbbe0: 0x1491823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 10), GPR_U32(ctx, 9)));
    // 0x1fbbe4: 0x184102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 4)));
    // 0x1fbbe8: 0x625023
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fbbec: 0x80602d
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1fbbf0:
    // 0x1fbbf0: 0x13200066
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 12) << (32 + 0));
    if (GPR_U32(ctx, 25) == GPR_U32(ctx, 0)) {
        goto label_1fbd8c;
    }
    // 0x1fbbf8: 0xa183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 10) << (32 + 0));
    // 0x1fbbfc: 0x2783e
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fbc00: 0x10000061
    SET_GPR_U32(ctx, 15, OR32(GPR_U32(ctx, 15), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbd88;
    }
label_1fbc08:
    // 0x1fbc08: 0x1aa1804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 10), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbc0c: 0x1c82006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 8), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fbc10: 0x1ca3806
    SET_GPR_U32(ctx, 7, SRL32(GPR_U32(ctx, 10), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fbc14: 0x1cc1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fbc18: 0x1a92804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 9), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbc1c: 0x625025
    SET_GPR_U32(ctx, 10, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fbc20: 0xa44825
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1fbc24: 0x1a84004
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 8), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbc28: 0x1ac6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbc2c: 0x93402
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 9), 16));
    // 0x1fbc30: 0xe6001b
    { uint32_t divisor = GPR_U32(ctx, 6); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 7) / divisor; ctx->hi = GPR_U32(ctx, 6) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,7); } }
    // 0x1fbc34: 0x3125ffff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 9), 65535));
    // 0x1fbc38: 0xa2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 10), 16));
    // 0x1fbc3c: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbc44;
    }
label_1fbc44:
    // 0x1fbc44: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbc48: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fbc4c: 0x40582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fbc50: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbc54: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbc58: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbc5c: 0x1653818
    { int64_t result = (int64_t)GPR_S32(ctx, 11) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbc60: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbc64: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fbc68: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
        goto label_1fbc9c;
    }
    // 0x1fbc70: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbc74: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbc78: 0x14400007
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbc98;
    }
    // 0x1fbc80: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fbc84: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
        goto label_1fbc9c;
    }
    // 0x1fbc8c: 0x256bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294967295));
    // 0x1fbc90: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbc94: 0x0
    // NOP
label_1fbc98:
    // 0x1fbc98: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
label_1fbc9c:
    // 0x1fbc9c: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbca4;
    }
label_1fbca4:
    // 0x1fbca4: 0x66001b
    { uint32_t divisor = GPR_U32(ctx, 6); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 6) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fbca8: 0x3144ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 10), 65535));
    // 0x1fbcac: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbcb0: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fbcb4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fbcb8: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbcbc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbcc0: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbcc4: 0xc53818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbcc8: 0x642825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbccc: 0xa7102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1fbcd0: 0x1040000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 11) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbd00;
    }
    // 0x1fbcd8: 0xa92821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x1fbcdc: 0xa9102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x1fbce0: 0x14400006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbcfc;
    }
    // 0x1fbce8: 0xa7102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1fbcec: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 11) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbd00;
    }
    // 0x1fbcf4: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x1fbcf8: 0xa92821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
label_1fbcfc:
    // 0x1fbcfc: 0xb103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 11) << (32 + 0));
label_1fbd00:
    // 0x1fbd00: 0xa72823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1fbd04: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1fbd08: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fbd0c: 0xa0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1fbd10: 0x461025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1fbd14: 0x480019
    { uint64_t result = (uint64_t)GPR_U32(ctx, 2) * (uint64_t)GPR_U32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbd18: 0x3810
    SET_GPR_U32(ctx, 7, ctx->hi);
    // 0x1fbd1c: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x1fbd20: 0x147182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    // 0x1fbd24: 0x14600006
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1fbd40;
    }
    // 0x1fbd2c: 0x14ea0008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 10)) {
        goto label_1fbd50;
    }
    // 0x1fbd34: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbd50;
    }
    // 0x1fbd3c: 0x0
    // NOP
label_1fbd40:
    // 0x1fbd40: 0xe91823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 9)));
    // 0x1fbd44: 0xc4102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1fbd48: 0x623823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fbd4c: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1fbd50:
    // 0x1fbd50: 0x1320000e
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 12), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 25) == GPR_U32(ctx, 0)) {
        goto label_1fbd8c;
    }
    // 0x1fbd58: 0xa71823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1fbd5c: 0x184102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 4)));
    // 0x1fbd60: 0x625023
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fbd64: 0x1ca2804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 10), GPR_U32(ctx, 14) & 0x1F));
    // 0x1fbd68: 0x1a42006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbd6c: 0x1aa1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 10), GPR_U32(ctx, 13) & 0x1F));
    // 0x1fbd70: 0xa42825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1fbd74: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fbd78: 0x5283c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fbd7c: 0x5783e
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 5) >> (32 + 0));
    // 0x1fbd80: 0x1e27825
    SET_GPR_U32(ctx, 15, OR32(GPR_U32(ctx, 15), GPR_U32(ctx, 2)));
    // 0x1fbd84: 0x0
    // NOP
label_1fbd88:
    // 0x1fbd88: 0xff2f0000
    WRITE64(ADD32(GPR_U32(ctx, 25), 0), GPR_U64(ctx, 15));
label_1fbd8c:
    // 0x1fbd8c: 0x12000016
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1fbde8;
    }
    // 0x1fbd94: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fbd98: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1fbd9c: 0x304c024
    SET_GPR_U32(ctx, 24, AND32(GPR_U32(ctx, 24), GPR_U32(ctx, 4)));
    // 0x1fbda0: 0x3103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbda4: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fbda8: 0x21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fbdac: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbdb0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fbdb4: 0x31823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1fbdb8: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fbdbc: 0x302c025
    SET_GPR_U32(ctx, 24, OR32(GPR_U32(ctx, 24), GPR_U32(ctx, 2)));
    // 0x1fbdc0: 0x18203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 24) << (32 + 0));
    // 0x1fbdc4: 0x4203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fbdc8: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1fbdcc: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1fbdd0: 0x4202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x1fbdd4: 0x302c024
    SET_GPR_U32(ctx, 24, AND32(GPR_U32(ctx, 24), GPR_U32(ctx, 2)));
    // 0x1fbdd8: 0x641823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbddc: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbde0: 0x303c025
    SET_GPR_U32(ctx, 24, OR32(GPR_U32(ctx, 24), GPR_U32(ctx, 3)));
    // 0x1fbde4: 0xffb80000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 24));
label_1fbde8:
    // 0x1fbde8: 0xdfa20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fbdec: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fbdf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fbdf8: 0x807f64c
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: FUN_001fbe00
// Address: 0x1fbe00 - 0x1fc3d0

void FUN_001fbe00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fbe00) {
        switch (ctx->pc) {
            case 0x1fbe48: ctx->pc = 0; goto label_1fbe48;
            case 0x1fbe60: ctx->pc = 0; goto label_1fbe60;
            case 0x1fbe9c: ctx->pc = 0; goto label_1fbe9c;
            case 0x1fbeb4: ctx->pc = 0; goto label_1fbeb4;
            case 0x1fbf08: ctx->pc = 0; goto label_1fbf08;
            case 0x1fbf0c: ctx->pc = 0; goto label_1fbf0c;
            case 0x1fbf14: ctx->pc = 0; goto label_1fbf14;
            case 0x1fbf60: ctx->pc = 0; goto label_1fbf60;
            case 0x1fbf74: ctx->pc = 0; goto label_1fbf74;
            case 0x1fbf88: ctx->pc = 0; goto label_1fbf88;
            case 0x1fbfa0: ctx->pc = 0; goto label_1fbfa0;
            case 0x1fbfb8: ctx->pc = 0; goto label_1fbfb8;
            case 0x1fbfd0: ctx->pc = 0; goto label_1fbfd0;
            case 0x1fc00c: ctx->pc = 0; goto label_1fc00c;
            case 0x1fc040: ctx->pc = 0; goto label_1fc040;
            case 0x1fc098: ctx->pc = 0; goto label_1fc098;
            case 0x1fc09c: ctx->pc = 0; goto label_1fc09c;
            case 0x1fc0a4: ctx->pc = 0; goto label_1fc0a4;
            case 0x1fc0fc: ctx->pc = 0; goto label_1fc0fc;
            case 0x1fc100: ctx->pc = 0; goto label_1fc100;
            case 0x1fc110: ctx->pc = 0; goto label_1fc110;
            case 0x1fc128: ctx->pc = 0; goto label_1fc128;
            case 0x1fc178: ctx->pc = 0; goto label_1fc178;
            case 0x1fc17c: ctx->pc = 0; goto label_1fc17c;
            case 0x1fc184: ctx->pc = 0; goto label_1fc184;
            case 0x1fc1d0: ctx->pc = 0; goto label_1fc1d0;
            case 0x1fc1e4: ctx->pc = 0; goto label_1fc1e4;
            case 0x1fc1f8: ctx->pc = 0; goto label_1fc1f8;
            case 0x1fc218: ctx->pc = 0; goto label_1fc218;
            case 0x1fc230: ctx->pc = 0; goto label_1fc230;
            case 0x1fc278: ctx->pc = 0; goto label_1fc278;
            case 0x1fc2b4: ctx->pc = 0; goto label_1fc2b4;
            case 0x1fc308: ctx->pc = 0; goto label_1fc308;
            case 0x1fc30c: ctx->pc = 0; goto label_1fc30c;
            case 0x1fc314: ctx->pc = 0; goto label_1fc314;
            case 0x1fc36c: ctx->pc = 0; goto label_1fc36c;
            case 0x1fc370: ctx->pc = 0; goto label_1fc370;
            case 0x1fc3b0: ctx->pc = 0; goto label_1fc3b0;
            case 0x1fc3b8: ctx->pc = 0; goto label_1fc3b8;
            case 0x1fc3bc: ctx->pc = 0; goto label_1fc3bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fbe00: 0x5403f
    SET_GPR_S64(ctx, 8, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1fbe04: 0x4583f
    SET_GPR_S64(ctx, 11, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fbe08: 0x5483c
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fbe0c: 0x9483f
    SET_GPR_S64(ctx, 9, GPR_S64(ctx, 9) >> (32 + 0));
    // 0x1fbe10: 0x4603c
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1fbe14: 0xc603f
    SET_GPR_S64(ctx, 12, GPR_S64(ctx, 12) >> (32 + 0));
    // 0x1fbe18: 0x150000f2
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_1fc1e4;
    }
    // 0x1fbe20: 0x169102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 11), GPR_U32(ctx, 9)));
    // 0x1fbe24: 0x10400053
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbf74;
    }
    // 0x1fbe2c: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbe30: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbe48;
    }
    // 0x1fbe38: 0x2d220100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), 256));
    // 0x1fbe3c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fbe40: 0x10000007
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbe60;
    }
label_1fbe48:
    // 0x1fbe48: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fbe4c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fbe50: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fbe54: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbe58: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1fbe5c: 0x0
    // NOP
label_1fbe60:
    // 0x1fbe60: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fbe64: 0xa92006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 9), GPR_U32(ctx, 5) & 0x1F));
    // 0x1fbe68: 0x2442eeb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962864));
    // 0x1fbe6c: 0x24070020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fbe70: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fbe74: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fbe78: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fbe7c: 0xe33023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x1fbe80: 0x10c00006
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1fbe9c;
    }
    // 0x1fbe88: 0xcb1804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 11), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fbe8c: 0x4c1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 2) & 0x1F));
    // 0x1fbe90: 0xc94804
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 9), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fbe94: 0x625825
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fbe98: 0xcc6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 6) & 0x1F));
label_1fbe9c:
    // 0x1fbe9c: 0x92c02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 9), 16));
    // 0x1fbea0: 0x3128ffff
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 9), 65535));
    // 0x1fbea4: 0x165001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 11) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,11); } }
    // 0x1fbea8: 0xc2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 12), 16));
    // 0x1fbeac: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbeb4;
    }
label_1fbeb4:
    // 0x1fbeb4: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbeb8: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fbebc: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fbec0: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbec4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbec8: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbecc: 0xe83018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbed0: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbed4: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbed8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fbf0c;
    }
    // 0x1fbee0: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbee4: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbee8: 0x14400007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbf08;
    }
    // 0x1fbef0: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbef4: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fbf0c;
    }
    // 0x1fbefc: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x1fbf00: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbf04: 0x0
    // NOP
label_1fbf08:
    // 0x1fbf08: 0x661823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fbf0c:
    // 0x1fbf0c: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbf14;
    }
label_1fbf14:
    // 0x1fbf14: 0x65001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fbf18: 0x3184ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 12), 65535));
    // 0x1fbf1c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbf20: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fbf24: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fbf28: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fbf2c: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fbf30: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fbf34: 0xa83018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fbf38: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fbf3c: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbf40: 0x10400007
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fbf60;
    }
    // 0x1fbf48: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fbf4c: 0x14400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbf60;
    }
    // 0x1fbf54: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fbf58: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
        goto label_1fbf60;
    }
label_1fbf60:
    // 0x1fbf60: 0x7103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
    // 0x1fbf64: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1fbf68: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fbf6c: 0x10000110
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc3b0;
    }
label_1fbf74:
    // 0x1fbf74: 0x1520000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    if (GPR_U32(ctx, 9) != GPR_U32(ctx, 0)) {
        goto label_1fbfa0;
    }
    // 0x1fbf7c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fbf80: 0x51200001
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fbf88;
    }
label_1fbf88:
    // 0x1fbf88: 0x48001b
    { uint32_t divisor = GPR_U32(ctx, 8); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 2) / divisor; ctx->hi = GPR_U32(ctx, 8) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,2); } }
    // 0x1fbf8c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fbf90: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fbf94: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1fbf98: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbf9c: 0x0
    // NOP
label_1fbfa0:
    // 0x1fbfa0: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fbfb8;
    }
    // 0x1fbfa8: 0x2d220100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 9), 256));
    // 0x1fbfac: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fbfb0: 0x10000007
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fbfd0;
    }
label_1fbfb8:
    // 0x1fbfb8: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fbfbc: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fbfc0: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fbfc4: 0x49102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1fbfc8: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1fbfcc: 0x0
    // NOP
label_1fbfd0:
    // 0x1fbfd0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fbfd4: 0xa92006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 9), GPR_U32(ctx, 5) & 0x1F));
    // 0x1fbfd8: 0x2442eeb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962864));
    // 0x1fbfdc: 0x24070020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fbfe0: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fbfe4: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fbfe8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fbfec: 0xe33023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x1fbff0: 0x14c00006
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1fc00c;
    }
    // 0x1fbff8: 0x1695823
    SET_GPR_U32(ctx, 11, SUB32(GPR_U32(ctx, 11), GPR_U32(ctx, 9)));
    // 0x1fbffc: 0x240d0001
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fc000: 0x94402
    SET_GPR_U32(ctx, 8, SRL32(GPR_U32(ctx, 9), 16));
    // 0x1fc004: 0x10000042
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 9), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc110;
    }
label_1fc00c:
    // 0x1fc00c: 0xcb1804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 11), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc010: 0xec1006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 7) & 0x1F));
    // 0x1fc014: 0xc94804
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 9), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc018: 0xeb3806
    SET_GPR_U32(ctx, 7, SRL32(GPR_U32(ctx, 11), GPR_U32(ctx, 7) & 0x1F));
    // 0x1fc01c: 0xcc6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc020: 0x625825
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fc024: 0x94402
    SET_GPR_U32(ctx, 8, SRL32(GPR_U32(ctx, 9), 16));
    // 0x1fc028: 0xe8001b
    { uint32_t divisor = GPR_U32(ctx, 8); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 7) / divisor; ctx->hi = GPR_U32(ctx, 8) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,7); } }
    // 0x1fc02c: 0x312affff
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 9), 65535));
    // 0x1fc030: 0x100282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1fc034: 0xb2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 11), 16));
    // 0x1fc038: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc040;
    }
label_1fc040:
    // 0x1fc040: 0x140682d
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1fc044: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc048: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc04c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc050: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc054: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc058: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc05c: 0xea3018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 10); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc060: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc064: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc068: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fc09c;
    }
    // 0x1fc070: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc074: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc078: 0x14400007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc098;
    }
    // 0x1fc080: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc084: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fc09c;
    }
    // 0x1fc08c: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x1fc090: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc094: 0x0
    // NOP
label_1fc098:
    // 0x1fc098: 0x661823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fc09c:
    // 0x1fc09c: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc0a4;
    }
label_1fc0a4:
    // 0x1fc0a4: 0x65001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fc0a8: 0x3164ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 11), 65535));
    // 0x1fc0ac: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc0b0: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc0b4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc0b8: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc0bc: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc0c0: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc0c4: 0xad3018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 13); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc0c8: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc0cc: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc0d0: 0x1040000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc100;
    }
    // 0x1fc0d8: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc0dc: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc0e0: 0x14400006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc0fc;
    }
    // 0x1fc0e8: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc0ec: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc100;
    }
    // 0x1fc0f4: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1fc0f8: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
label_1fc0fc:
    // 0x1fc0fc: 0x7103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
label_1fc100:
    // 0x1fc100: 0x665823
    SET_GPR_U32(ctx, 11, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc104: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1fc108: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fc10c: 0x456825
    SET_GPR_U32(ctx, 13, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
label_1fc110:
    // 0x1fc110: 0x100282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1fc114: 0xc2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 12), 16));
    // 0x1fc118: 0x165001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 11) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,11); } }
    // 0x1fc11c: 0x140402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1fc120: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc128;
    }
label_1fc128:
    // 0x1fc128: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc12c: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc130: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc134: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc138: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc13c: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc140: 0xe83018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc144: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc148: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc14c: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fc17c;
    }
    // 0x1fc154: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc158: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc15c: 0x14400006
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc178;
    }
    // 0x1fc164: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc168: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
        goto label_1fc17c;
    }
    // 0x1fc170: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x1fc174: 0x691821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
label_1fc178:
    // 0x1fc178: 0x661823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
label_1fc17c:
    // 0x1fc17c: 0x50a00001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc184;
    }
label_1fc184:
    // 0x1fc184: 0x65001b
    { uint32_t divisor = GPR_U32(ctx, 5); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 5) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fc188: 0x3184ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 12), 65535));
    // 0x1fc18c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc190: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc194: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc198: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc19c: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc1a0: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc1a4: 0xa83018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc1a8: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc1ac: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc1b0: 0x10400007
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc1d0;
    }
    // 0x1fc1b8: 0x69102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 9)));
    // 0x1fc1bc: 0x14400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc1d0;
    }
    // 0x1fc1c4: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc1c8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
        goto label_1fc1d0;
    }
label_1fc1d0:
    // 0x1fc1d0: 0x7103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
    // 0x1fc1d4: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1fc1d8: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fc1dc: 0x10000076
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc3b8;
    }
label_1fc1e4:
    // 0x1fc1e4: 0x168102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 11), GPR_U32(ctx, 8)));
    // 0x1fc1e8: 0x10400003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc1f8;
    }
    // 0x1fc1f0: 0x1000006f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc3b0;
    }
label_1fc1f8:
    // 0x1fc1f8: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1fc1fc: 0x14400006
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc218;
    }
    // 0x1fc204: 0x2d020100
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), 256));
    // 0x1fc208: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fc20c: 0x10000008
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc230;
    }
    // 0x1fc214: 0x0
    // NOP
label_1fc218:
    // 0x1fc218: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1fc21c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fc220: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1fc224: 0x48102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x1fc228: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1fc22c: 0x0
    // NOP
label_1fc230:
    // 0x1fc230: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fc234: 0xa82006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 8), GPR_U32(ctx, 5) & 0x1F));
    // 0x1fc238: 0x2442eeb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294962864));
    // 0x1fc23c: 0x24070020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1fc240: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fc244: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fc248: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1fc24c: 0xe33023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x1fc250: 0x54c00009
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
        goto label_1fc278;
    }
    // 0x1fc258: 0x10b102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), GPR_U32(ctx, 11)));
    // 0x1fc25c: 0x14400054
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc3b0;
    }
    // 0x1fc264: 0x189102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 9)));
    // 0x1fc268: 0x14400051
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc3b0;
    }
    // 0x1fc270: 0x1000004f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fc3b0;
    }
label_1fc278:
    // 0x1fc278: 0xc82804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 8), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc27c: 0xec2006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 12), GPR_U32(ctx, 7) & 0x1F));
    // 0x1fc280: 0xe91806
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 9), GPR_U32(ctx, 7) & 0x1F));
    // 0x1fc284: 0xeb3806
    SET_GPR_U32(ctx, 7, SRL32(GPR_U32(ctx, 11), GPR_U32(ctx, 7) & 0x1F));
    // 0x1fc288: 0xcb1004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 11), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc28c: 0x445825
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1fc290: 0xa34025
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1fc294: 0xcc6004
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 12), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc298: 0xc94804
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 9), GPR_U32(ctx, 6) & 0x1F));
    // 0x1fc29c: 0x83402
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 8), 16));
    // 0x1fc2a0: 0xe6001b
    { uint32_t divisor = GPR_U32(ctx, 6); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 7) / divisor; ctx->hi = GPR_U32(ctx, 6) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,7); } }
    // 0x1fc2a4: 0x3105ffff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 8), 65535));
    // 0x1fc2a8: 0xb2402
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 11), 16));
    // 0x1fc2ac: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc2b4;
    }
label_1fc2b4:
    // 0x1fc2b4: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc2b8: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc2bc: 0x40502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc2c0: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc2c4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc2c8: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc2cc: 0x1453818
    { int64_t result = (int64_t)GPR_S32(ctx, 10) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc2d0: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc2d4: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fc2d8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
        goto label_1fc30c;
    }
    // 0x1fc2e0: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc2e4: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc2e8: 0x14400007
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc308;
    }
    // 0x1fc2f0: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fc2f4: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
        goto label_1fc30c;
    }
    // 0x1fc2fc: 0x254affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294967295));
    // 0x1fc300: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc304: 0x0
    // NOP
label_1fc308:
    // 0x1fc308: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
label_1fc30c:
    // 0x1fc30c: 0x50c00001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1fc314;
    }
label_1fc314:
    // 0x1fc314: 0x66001b
    { uint32_t divisor = GPR_U32(ctx, 6); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 3) / divisor; ctx->hi = GPR_U32(ctx, 6) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,3); } }
    // 0x1fc318: 0x3164ffff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 11), 65535));
    // 0x1fc31c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1fc320: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x1fc324: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fc328: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fc32c: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1fc330: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fc334: 0xc53818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc338: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fc33c: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fc340: 0x1040000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 10) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc370;
    }
    // 0x1fc348: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc34c: 0x68102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc350: 0x14400006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fc36c;
    }
    // 0x1fc358: 0x67102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fc35c: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 10) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc370;
    }
    // 0x1fc364: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1fc368: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
label_1fc36c:
    // 0x1fc36c: 0xa103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 10) << (32 + 0));
label_1fc370:
    // 0x1fc370: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fc374: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x1fc378: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fc37c: 0x462825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1fc380: 0xa90019
    { uint64_t result = (uint64_t)GPR_U32(ctx, 5) * (uint64_t)GPR_U32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fc384: 0x3010
    SET_GPR_U32(ctx, 6, ctx->hi);
    // 0x1fc388: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x1fc38c: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fc390: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
        goto label_1fc3b0;
    }
    // 0x1fc398: 0x14c30007
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 3)) {
        goto label_1fc3b8;
    }
    // 0x1fc3a0: 0x184102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 4)));
    // 0x1fc3a4: 0x10400005
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) << (32 + 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fc3bc;
    }
    // 0x1fc3ac: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
label_1fc3b0:
    // 0x1fc3b0: 0x682d
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fc3b4: 0x0
    // NOP
label_1fc3b8:
    // 0x1fc3b8: 0x5183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) << (32 + 0));
label_1fc3bc:
    // 0x1fc3bc: 0xd103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 13) << (32 + 0));
    // 0x1fc3c0: 0x3703e
    SET_GPR_U64(ctx, 14, GPR_U64(ctx, 3) >> (32 + 0));
    // 0x1fc3c4: 0x1c21025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 14), GPR_U32(ctx, 2)));
    // 0x1fc3c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___umoddi3
// Address: 0x1fc3d0 - 0x1fc910

void entry_1fcd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcd40: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fcd44: 0x27a40068
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 104));
    // 0x1fcd48: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fcd50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fcd50
// Address: 0x1fcd50 - 0x1fcd60

void entry_1fcd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcd50: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fcd54: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1fcd58: 0xc07f2b8
    SET_GPR_U32(ctx, 31, 0x1fcd60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    _fpadd_parts(rdram, ctx, runtime); return;
}


// Function: entry_1fcd60
// Address: 0x1fcd60 - 0x1fcd68

void entry_1fcd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcd60: 0xc07f244
    SET_GPR_U32(ctx, 31, 0x1fcd68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___pack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fcd68
// Address: 0x1fcd68 - 0x1fcd78

void entry_1fcd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcd68: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1fcd6c: 0xdfb00070
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1fcd70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: dpsub
// Address: 0x1fcd78 - 0x1fcd98

void entry_1fcd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcd98: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fcd9c: 0x27a40068
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 104));
    // 0x1fcda0: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fcda8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fcda8
// Address: 0x1fcda8 - 0x1fcdc4

void entry_1fcda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcda8: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1fcdac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fcdb0: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1fcdb4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1fcdb8: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x1fcdbc: 0xc07f2b8
    SET_GPR_U32(ctx, 31, 0x1fcdc4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    _fpadd_parts(rdram, ctx, runtime); return;
}


// Function: entry_1fcdc4
// Address: 0x1fcdc4 - 0x1fcdcc

void entry_1fcdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcdc4: 0xc07f244
    SET_GPR_U32(ctx, 31, 0x1fcdcc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___pack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fcdcc
// Address: 0x1fcdcc - 0x1fcde0

void entry_1fcdcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcdcc: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1fcdd0: 0xdfb00070
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1fcdd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fcddc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fcde0; return;
}


// Function: dpmul
// Address: 0x1fcde0 - 0x1fce1c

void entry_1fce1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fce1c: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fce20: 0x27a40068
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 104));
    // 0x1fce24: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fce2c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fce2c
// Address: 0x1fce2c - 0x1fcef8

void entry_1fce2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fce2c) {
        switch (ctx->pc) {
            case 0x1fce6c: ctx->pc = 0; goto label_1fce6c;
            case 0x1fce7c: ctx->pc = 0; goto label_1fce7c;
            case 0x1fce88: ctx->pc = 0; goto label_1fce88;
            case 0x1fce90: ctx->pc = 0; goto label_1fce90;
            case 0x1fce98: ctx->pc = 0; goto label_1fce98;
            case 0x1fceac: ctx->pc = 0; goto label_1fceac;
            case 0x1fceb8: ctx->pc = 0; goto label_1fceb8;
            case 0x1fced0: ctx->pc = 0; goto label_1fced0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fce2c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fce30: 0x2c820002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 2));
    // 0x1fce34: 0x14400016
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fce90;
    }
    // 0x1fce3c: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fce40: 0x2c620002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 2));
    // 0x1fce44: 0x5440001c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
        goto label_1fceb8;
    }
    // 0x1fce4c: 0x38820004
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 4), 4));
    // 0x1fce50: 0x14400006
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fce6c;
    }
    // 0x1fce58: 0x38620002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    // 0x1fce5c: 0x10400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fce7c;
    }
    // 0x1fce64: 0x1000000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fce98;
    }
label_1fce6c:
    // 0x1fce6c: 0x14400006
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fce88;
    }
    // 0x1fce74: 0x14400010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fceb8;
    }
label_1fce7c:
    // 0x1fce7c: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1fce80: 0x10000074
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294944624));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FD054; return;
    }
label_1fce88:
    // 0x1fce88: 0x14400008
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fceac;
    }
label_1fce90:
    // 0x1fce90: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fce94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1fce98:
    // 0x1fce98: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1fce9c: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fcea0: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fcea4: 0x1000006b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FD054; return;
    }
label_1fceac:
    // 0x1fceac: 0x14400008
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fced0;
    }
    // 0x1fceb4: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
label_1fceb8:
    // 0x1fceb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fcebc: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fcec0: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fcec4: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fcec8: 0x10000062
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FD054; return;
    }
label_1fced0:
    // 0x1fced0: 0x3c16ffff
    SET_GPR_U32(ctx, 22, ((uint32_t)65535 << 16));
    // 0x1fced4: 0x16b03e
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 22) >> (32 + 0));
    // 0x1fced8: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fcedc: 0x2768024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 22)));
    // 0x1fcee0: 0x256a824
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 22)));
    // 0x1fcee4: 0x13983e
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) >> (32 + 0));
    // 0x1fcee8: 0x12903e
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) >> (32 + 0));
    // 0x1fceec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fcef0: 0xc07fa24
    SET_GPR_U32(ctx, 31, 0x1fcef8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = 0x1fe890; return;
}


// Function: entry_1fcef8
// Address: 0x1fcef8 - 0x1fcf08

void entry_1fcef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcef8: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fcefc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fcf00: 0xc07fa24
    SET_GPR_U32(ctx, 31, 0x1fcf08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = 0x1fe890; return;
}


// Function: entry_1fcf08
// Address: 0x1fcf08 - 0x1fcf18

void entry_1fcf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcf08: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fcf0c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1fcf10: 0xc07fa24
    SET_GPR_U32(ctx, 31, 0x1fcf18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = 0x1fe890; return;
}


// Function: entry_1fcf18
// Address: 0x1fcf18 - 0x1fcf28

void entry_1fcf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fcf18: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fcf1c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1fcf20: 0xc07fa24
    SET_GPR_U32(ctx, 31, 0x1fcf28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = 0x1fe890; return;
}


// Function: entry_1fcf28
// Address: 0x1fcf28 - 0x1fd05c

void entry_1fcf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fcf28) {
        switch (ctx->pc) {
            case 0x1fcfa0: ctx->pc = 0; goto label_1fcfa0;
            case 0x1fcfb8: ctx->pc = 0; goto label_1fcfb8;
            case 0x1fcfcc: ctx->pc = 0; goto label_1fcfcc;
            case 0x1fcff8: ctx->pc = 0; goto label_1fcff8;
            case 0x1fd020: ctx->pc = 0; goto label_1fd020;
            case 0x1fd040: ctx->pc = 0; goto label_1fd040;
            case 0x1fd044: ctx->pc = 0; goto label_1fd044;
            case 0x1fd048: ctx->pc = 0; goto label_1fd048;
            case 0x1fd054: ctx->pc = 0; goto label_1fd054;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fcf28: 0x230802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 16));
    // 0x1fcf2c: 0x8fa50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fcf30: 0x10203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) << (32 + 0));
    // 0x1fcf34: 0x211882b
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1fcf38: 0x284202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 4));
    // 0x1fcf3c: 0x10803e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) >> (32 + 0));
    // 0x1fcf40: 0x8fa70028
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1fcf44: 0x2168024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 22)));
    // 0x1fcf48: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fcf4c: 0x11883c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << (32 + 0));
    // 0x1fcf50: 0x8fa60024
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1fcf54: 0x94a02b
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 20)));
    // 0x1fcf58: 0x202802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) + GPR_U64(ctx, 2));
    // 0x1fcf5c: 0xa72821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x1fcf60: 0x661826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fcf64: 0x2348825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 20)));
    // 0x1fcf68: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1fcf6c: 0x230882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) + GPR_U64(ctx, 16));
    // 0x1fcf70: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1fcf74: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fcf78: 0x210fa
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 3);
    // 0x1fcf7c: 0xafa30044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 3));
    // 0x1fcf80: 0x51102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1fcf84: 0x10400011
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fcfcc;
    }
    // 0x1fcf8c: 0x34068000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1fcf90: 0x6343c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 16));
    // 0x1fcf94: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fcf98: 0x318fa
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) >> 3);
    // 0x1fcf9c: 0x32220001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 1));
label_1fcfa0:
    // 0x1fcfa0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fcfa4: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fcfa8: 0x10400003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fcfb8;
    }
    // 0x1fcfb0: 0x4207a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) >> 1);
    // 0x1fcfb4: 0x862025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
label_1fcfb8:
    // 0x1fcfb8: 0x11887a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) >> 1);
    // 0x1fcfbc: 0x71102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x1fcfc0: 0x1440fff7
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fcfa0;
    }
    // 0x1fcfc8: 0xafa50048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 5));
label_1fcfcc:
    // 0x1fcfcc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fcfd0: 0x2113a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 4);
    // 0x1fcfd4: 0x51102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1fcfd8: 0x14400011
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 17), 255));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd020;
    }
    // 0x1fcfe0: 0x8fa50048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1fcfe4: 0x34088000
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1fcfe8: 0x8443c
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << (32 + 16));
    // 0x1fcfec: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fcff0: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1fcff4: 0x6313a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) >> 4);
label_1fcff8:
    // 0x1fcff8: 0x118878
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << 1);
    // 0x1fcffc: 0x881824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 8)));
    // 0x1fd000: 0x2271025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    // 0x1fd004: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1fd008: 0x43880b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
    // 0x1fd00c: 0xd1102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 17)));
    // 0x1fd010: 0x1040fff9
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 1);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fcff8;
    }
    // 0x1fd018: 0xafa50048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 5));
    // 0x1fd01c: 0x322300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 17), 255));
label_1fd020:
    // 0x1fd020: 0x24020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1fd024: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 17));
        goto label_1fd048;
    }
    // 0x1fd02c: 0x32220100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 256));
    // 0x1fd030: 0x10400003
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 17) + (int64_t)128);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd040;
    }
    // 0x1fd038: 0x10000002
    SET_GPR_S64(ctx, 17, (int64_t)GPR_S64(ctx, 17) + (int64_t)128);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd044;
    }
label_1fd040:
    // 0x1fd040: 0x44880b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
label_1fd044:
    // 0x1fd044: 0xffb10050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 17));
label_1fd048:
    // 0x1fd048: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1fd04c: 0xaee20000
    WRITE32(ADD32(GPR_U32(ctx, 23), 0), GPR_U32(ctx, 2));
    // 0x1fd050: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_1fd054:
    // 0x1fd054: 0xc07f244
    SET_GPR_U32(ctx, 31, 0x1fd05c);
    fn___pack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd05c
// Address: 0x1fd05c - 0x1fd088

void entry_1fd05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd05c: 0xdfbf00f0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1fd060: 0xdfb700e0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1fd064: 0xdfb600d0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1fd068: 0xdfb500c0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1fd06c: 0xdfb400b0
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1fd070: 0xdfb300a0
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1fd074: 0xdfb20090
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1fd078: 0xdfb10080
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1fd07c: 0xdfb00070
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1fd080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fd088
// Address: 0x1fd088 - 0x1fd0a8

void FUN_001fd088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd088: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x1fd08c: 0xffa40040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 4));
    // 0x1fd090: 0xffa50048
    WRITE64(ADD32(GPR_U32(ctx, 29), 72), GPR_U64(ctx, 5));
    // 0x1fd094: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1fd098: 0xffb00050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 16));
    // 0x1fd09c: 0xffbf0060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 31));
    // 0x1fd0a0: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fd0a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd0a8
// Address: 0x1fd0a8 - 0x1fd0b8

void entry_1fd0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd0a8: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fd0ac: 0x27a40048
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 72));
    // 0x1fd0b0: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fd0b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd0b8
// Address: 0x1fd0b8 - 0x1fd1e0

void entry_1fd0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd0b8) {
        switch (ctx->pc) {
            case 0x1fd0d0: ctx->pc = 0; goto label_1fd0d0;
            case 0x1fd104: ctx->pc = 0; goto label_1fd104;
            case 0x1fd118: ctx->pc = 0; goto label_1fd118;
            case 0x1fd130: ctx->pc = 0; goto label_1fd130;
            case 0x1fd148: ctx->pc = 0; goto label_1fd148;
            case 0x1fd174: ctx->pc = 0; goto label_1fd174;
            case 0x1fd188: ctx->pc = 0; goto label_1fd188;
            case 0x1fd18c: ctx->pc = 0; goto label_1fd18c;
            case 0x1fd1a0: ctx->pc = 0; goto label_1fd1a0;
            case 0x1fd1cc: ctx->pc = 0; goto label_1fd1cc;
            case 0x1fd1d0: ctx->pc = 0; goto label_1fd1d0;
            case 0x1fd1d4: ctx->pc = 0; goto label_1fd1d4;
            case 0x1fd1d8: ctx->pc = 0; goto label_1fd1d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd0b8: 0x8fa70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd0bc: 0x2ce20002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), 2));
    // 0x1fd0c0: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd0d0;
    }
    // 0x1fd0c8: 0x10000043
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd1d8;
    }
label_1fd0d0:
    // 0x1fd0d0: 0x8fa60020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fd0d4: 0x2cc20002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 2));
    // 0x1fd0d8: 0x1440003f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd1d8;
    }
    // 0x1fd0e0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fd0e4: 0x38e40004
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 7), 4));
    // 0x1fd0e8: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1fd0ec: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fd0f0: 0x10800004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1fd104;
    }
    // 0x1fd0f8: 0x38e20002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 7), 2));
    // 0x1fd0fc: 0x14400006
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 6), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd118;
    }
label_1fd104:
    // 0x1fd104: 0x14e60034
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 6)) {
        goto label_1fd1d8;
    }
    // 0x1fd10c: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x1fd110: 0x10000031
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294944624));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd1d8;
    }
label_1fd118:
    // 0x1fd118: 0x14400005
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd130;
    }
    // 0x1fd120: 0xffa00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 0));
    // 0x1fd124: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1fd128: 0x1000002b
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd1d8;
    }
label_1fd130:
    // 0x1fd130: 0x14400005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd148;
    }
    // 0x1fd138: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1fd13c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1fd140: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd1d8;
    }
label_1fd148:
    // 0x1fd148: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1fd14c: 0xdfa40010
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd150: 0xdfa80030
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fd154: 0x621023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1fd158: 0x88302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 8)));
    // 0x1fd15c: 0x10c00005
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1fd174;
    }
    // 0x1fd164: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1fd168: 0x42078
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 1);
    // 0x1fd16c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1fd170: 0x88302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 8)));
label_1fd174:
    // 0x1fd174: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1fd178: 0x2137c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 13));
    // 0x1fd17c: 0x10000003
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd18c;
    }
    // 0x1fd184: 0x0
    // NOP
label_1fd188:
    // 0x1fd188: 0x88302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 8)));
label_1fd18c:
    // 0x1fd18c: 0x54c00004
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 1);
        goto label_1fd1a0;
    }
    // 0x1fd194: 0xe23825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x1fd198: 0x88202f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) - GPR_U64(ctx, 8));
    // 0x1fd19c: 0x2107a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 1);
label_1fd1a0:
    // 0x1fd1a0: 0x1440fff9
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 1);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd188;
    }
    // 0x1fd1a8: 0x30e300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 7), 255));
    // 0x1fd1ac: 0x24020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1fd1b0: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE64(ADD32(GPR_U32(ctx, 5), 16), GPR_U64(ctx, 7));
        goto label_1fd1d4;
    }
    // 0x1fd1b8: 0x30e20100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 256));
    // 0x1fd1bc: 0x10400003
    SET_GPR_S64(ctx, 2, (int64_t)GPR_S64(ctx, 7) + (int64_t)128);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd1cc;
    }
    // 0x1fd1c4: 0x10000002
    SET_GPR_S64(ctx, 7, (int64_t)GPR_S64(ctx, 7) + (int64_t)128);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd1d0;
    }
label_1fd1cc:
    // 0x1fd1cc: 0x44380b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 2));
label_1fd1d0:
    // 0x1fd1d0: 0xfca70010
    WRITE64(ADD32(GPR_U32(ctx, 5), 16), GPR_U64(ctx, 7));
label_1fd1d4:
    // 0x1fd1d4: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1fd1d8:
    // 0x1fd1d8: 0xc07f244
    SET_GPR_U32(ctx, 31, 0x1fd1e0);
    fn___pack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd1e0
// Address: 0x1fd1e0 - 0x1fd1f0

void entry_1fd1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd1e0: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1fd1e4: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fd1e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___fpcmp_parts_d
// Address: 0x1fd1f0 - 0x1fd308

void entry_1fd328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd328: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1fd32c: 0x27a40048
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 72));
    // 0x1fd330: 0xc07f290
    SET_GPR_U32(ctx, 31, 0x1fd338);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___unpack_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd338
// Address: 0x1fd338 - 0x1fd344

void entry_1fd338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd338: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fd33c: 0xc07f47c
    SET_GPR_U32(ctx, 31, 0x1fd344);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___fpcmp_parts_d(rdram, ctx, runtime); return;
}


// Function: entry_1fd344
// Address: 0x1fd344 - 0x1fd358

void entry_1fd344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd344: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1fd348: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fd34c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd354: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd358; return;
}


// Function: litodp
// Address: 0x1fd358 - 0x1fd404

void entry_1fd404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd404) {
        switch (ctx->pc) {
            case 0x1fd408: ctx->pc = 0; goto label_1fd408;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd404: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_1fd408:
    // 0x1fd408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: dptoli
// Address: 0x1fd410 - 0x1fd428

void entry_1fd428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd428) {
        switch (ctx->pc) {
            case 0x1fd440: ctx->pc = 0; goto label_1fd440;
            case 0x1fd448: ctx->pc = 0; goto label_1fd448;
            case 0x1fd460: ctx->pc = 0; goto label_1fd460;
            case 0x1fd478: ctx->pc = 0; goto label_1fd478;
            case 0x1fd498: ctx->pc = 0; goto label_1fd498;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd428: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd42c: 0x38620002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    // 0x1fd430: 0x10400003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd440;
    }
    // 0x1fd438: 0x10400003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd448;
    }
label_1fd440:
    // 0x1fd440: 0x10000015
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd498;
    }
label_1fd448:
    // 0x1fd448: 0x10400005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd460;
    }
    // 0x1fd450: 0x480fffb
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 31));
    if (GPR_S32(ctx, 4) < 0) {
        goto label_1fd440;
    }
    // 0x1fd458: 0x14400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd478;
    }
label_1fd460:
    // 0x1fd460: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fd464: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x1fd468: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fd46c: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x1fd470: 0x10000009
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd498;
    }
label_1fd478:
    // 0x1fd478: 0xdfa20010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd47c: 0x641823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fd480: 0x621016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (GPR_U32(ctx, 3) & 0x3F));
    // 0x1fd484: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fd488: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fd48c: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1fd490: 0x21823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1fd494: 0x64100b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
label_1fd498:
    // 0x1fd498: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fd49c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd4a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd4a8; return;
}


// Function: dptoul
// Address: 0x1fd4a8 - 0x1fd4c0

void entry_1fd4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd4c0) {
        switch (ctx->pc) {
            case 0x1fd4d8: ctx->pc = 0; goto label_1fd4d8;
            case 0x1fd4e0: ctx->pc = 0; goto label_1fd4e0;
            case 0x1fd504: ctx->pc = 0; goto label_1fd504;
            case 0x1fd510: ctx->pc = 0; goto label_1fd510;
            case 0x1fd528: ctx->pc = 0; goto label_1fd528;
            case 0x1fd534: ctx->pc = 0; goto label_1fd534;
            case 0x1fd53c: ctx->pc = 0; goto label_1fd53c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd4c0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd4c4: 0x38620002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    // 0x1fd4c8: 0x10400003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd4d8;
    }
    // 0x1fd4d0: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd4e0;
    }
label_1fd4d8:
    // 0x1fd4d8: 0x10000018
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd53c;
    }
label_1fd4e0:
    // 0x1fd4e0: 0x14400016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd53c;
    }
    // 0x1fd4e8: 0x38620004
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 4));
    // 0x1fd4ec: 0x10400005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd504;
    }
    // 0x1fd4f4: 0x480fff8
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 32));
    if (GPR_S32(ctx, 4) < 0) {
        goto label_1fd4d8;
    }
    // 0x1fd4fc: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 61));
        goto label_1fd510;
    }
label_1fd504:
    // 0x1fd504: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1fd508: 0x1000000c
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd53c;
    }
label_1fd510:
    // 0x1fd510: 0x14400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd528;
    }
    // 0x1fd518: 0xdfa20010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd51c: 0x2483ffc4
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 4294967236));
    // 0x1fd520: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (GPR_U32(ctx, 3) & 0x3F));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd534;
    }
label_1fd528:
    // 0x1fd528: 0xdfa20010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd52c: 0x641823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fd530: 0x621016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (GPR_U32(ctx, 3) & 0x3F));
label_1fd534:
    // 0x1fd534: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fd538: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
label_1fd53c:
    // 0x1fd53c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fd540: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___make_dp
// Address: 0x1fd548 - 0x1fd568

void entry_1fd568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd568: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fd56c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd578; return;
}


// Function: dptofp
// Address: 0x1fd578 - 0x1fd590

void entry_1fd590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd590: 0xdfa20010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd594: 0x3c033fff
    SET_GPR_U32(ctx, 3, ((uint32_t)16383 << 16));
    // 0x1fd598: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1fd59c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd5a0: 0x240b8
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) << 2);
    // 0x1fd5a4: 0x8403f
    SET_GPR_S64(ctx, 8, GPR_S64(ctx, 8) >> (32 + 0));
    // 0x1fd5a8: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fd5ac: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fd5b0: 0x35070001
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 8), 1));
    // 0x1fd5b4: 0x8fa60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fd5b8: 0xc07f60e
    SET_GPR_U32(ctx, 31, 0x1fd5c0);
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 8));
    fn___make_fp(rdram, ctx, runtime); return;
}


// Function: entry_1fd5c0
// Address: 0x1fd5c0 - 0x1fd5d0

void entry_1fd5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd5c0: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fd5c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd5cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd5d0; return;
}


// Function: FUN_001fd5d0
// Address: 0x1fd5d0 - 0x1fd6e0

void FUN_001fd5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd5d0) {
        switch (ctx->pc) {
            case 0x1fd5f8: ctx->pc = 0; goto label_1fd5f8;
            case 0x1fd614: ctx->pc = 0; goto label_1fd614;
            case 0x1fd644: ctx->pc = 0; goto label_1fd644;
            case 0x1fd650: ctx->pc = 0; goto label_1fd650;
            case 0x1fd65c: ctx->pc = 0; goto label_1fd65c;
            case 0x1fd678: ctx->pc = 0; goto label_1fd678;
            case 0x1fd688: ctx->pc = 0; goto label_1fd688;
            case 0x1fd68c: ctx->pc = 0; goto label_1fd68c;
            case 0x1fd690: ctx->pc = 0; goto label_1fd690;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd5d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fd5d4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fd5d8: 0x8c880004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1fd5dc: 0x2c620002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 2));
    // 0x1fd5e0: 0x10400005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd5f8;
    }
    // 0x1fd5e8: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x1fd5ec: 0x240700ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1fd5f0: 0x10000026
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd68c;
    }
label_1fd5f8:
    // 0x1fd5f8: 0x38620004
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 4));
    // 0x1fd5fc: 0x10400014
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd650;
    }
    // 0x1fd604: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd614;
    }
    // 0x1fd60c: 0x1000001f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd68c;
    }
label_1fd614:
    // 0x1fd614: 0x10a0001e
    SET_GPR_U32(ctx, 3, ((uint32_t)65408 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1fd690;
    }
    // 0x1fd61c: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fd620: 0x2862ff82
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4294967170));
    // 0x1fd624: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967170));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd644;
    }
    // 0x1fd62c: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fd630: 0x2843001a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), 26));
    // 0x1fd634: 0x14600014
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), GPR_U32(ctx, 2) & 0x1F));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1fd688;
    }
    // 0x1fd63c: 0x10000012
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd688;
    }
label_1fd644:
    // 0x1fd644: 0x28620080
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 128));
    // 0x1fd648: 0x14400004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 3), 127));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd65c;
    }
label_1fd650:
    // 0x1fd650: 0x240700ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 255));
    // 0x1fd654: 0x1000000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd68c;
    }
label_1fd65c:
    // 0x1fd65c: 0x24020040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1fd660: 0x30a3007f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), 127));
    // 0x1fd664: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 63));
        goto label_1fd678;
    }
    // 0x1fd66c: 0x30a30080
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), 128));
    // 0x1fd670: 0x24a20040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 64));
    // 0x1fd674: 0x43280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
label_1fd678:
    // 0x1fd678: 0x4a30004
    if (GPR_S32(ctx, 5) >= 0) {
        SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), 7));
        goto label_1fd68c;
    }
    // 0x1fd680: 0x52842
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), 1));
    // 0x1fd684: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
label_1fd688:
    // 0x1fd688: 0x529c2
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), 7));
label_1fd68c:
    // 0x1fd68c: 0x3c03ff80
    SET_GPR_U32(ctx, 3, ((uint32_t)65408 << 16));
label_1fd690:
    // 0x1fd690: 0x3c02007f
    SET_GPR_U32(ctx, 2, ((uint32_t)127 << 16));
    // 0x1fd694: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fd698: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fd69c: 0xa21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1fd6a0: 0x3c03807f
    SET_GPR_U32(ctx, 3, ((uint32_t)32895 << 16));
    // 0x1fd6a4: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1fd6a8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1fd6ac: 0x30e400ff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 7), 255));
    // 0x1fd6b0: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fd6b4: 0x425c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 23));
    // 0x1fd6b8: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x1fd6bc: 0xc43025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1fd6c0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1fd6c4: 0x81fc0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 8), 31));
    // 0x1fd6c8: 0xc23024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1fd6cc: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1fd6d0: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x1fd6d4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd6dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd6e0; return;
}


// Function: fn___unpack_f
// Address: 0x1fd6e0 - 0x1fd7a0

void FUN_001fd7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd7a0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1fd7a4: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1fd7a8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1fd7ac: 0xe7ac0010
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1fd7b0: 0xc07f5b8
    SET_GPR_U32(ctx, 31, 0x1fd7b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___unpack_f(rdram, ctx, runtime); return;
}


// Function: entry_1fd7b8
// Address: 0x1fd7b8 - 0x1fd838

void entry_1fd7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd7b8) {
        switch (ctx->pc) {
            case 0x1fd7d0: ctx->pc = 0; goto label_1fd7d0;
            case 0x1fd7d8: ctx->pc = 0; goto label_1fd7d8;
            case 0x1fd7fc: ctx->pc = 0; goto label_1fd7fc;
            case 0x1fd808: ctx->pc = 0; goto label_1fd808;
            case 0x1fd820: ctx->pc = 0; goto label_1fd820;
            case 0x1fd82c: ctx->pc = 0; goto label_1fd82c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd7b8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd7bc: 0x38620002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 2));
    // 0x1fd7c0: 0x10400003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd7d0;
    }
    // 0x1fd7c8: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd7d8;
    }
label_1fd7d0:
    // 0x1fd7d0: 0x10000016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd82c;
    }
label_1fd7d8:
    // 0x1fd7d8: 0x14400014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fd82c;
    }
    // 0x1fd7e0: 0x38620004
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 4));
    // 0x1fd7e4: 0x10400005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fd7fc;
    }
    // 0x1fd7ec: 0x480fff8
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 32));
    if (GPR_S32(ctx, 4) < 0) {
        goto label_1fd7d0;
    }
    // 0x1fd7f4: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 31));
        goto label_1fd808;
    }
label_1fd7fc:
    // 0x1fd7fc: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1fd800: 0x1000000a
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd82c;
    }
label_1fd808:
    // 0x1fd808: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
        goto label_1fd820;
    }
    // 0x1fd810: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1fd814: 0x2482ffe2
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294967266));
    // 0x1fd818: 0x10000004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), GPR_U32(ctx, 2) & 0x1F));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fd82c;
    }
label_1fd820:
    // 0x1fd820: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1fd824: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1fd828: 0x431006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), GPR_U32(ctx, 2) & 0x1F));
label_1fd82c:
    // 0x1fd82c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fd830: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___make_fp
// Address: 0x1fd838 - 0x1fd858

void entry_1fd858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd858: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd85c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd864: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd868; return;
}


// Function: fptodp
// Address: 0x1fd868 - 0x1fd880

void entry_1fd880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd880: 0x8fa7000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1fd884: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd888: 0x7383c
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << (32 + 0));
    // 0x1fd88c: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1fd890: 0x8fa60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1fd894: 0xc07f552
    SET_GPR_U32(ctx, 31, 0x1fd89c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) >> 2);
    fn___make_dp(rdram, ctx, runtime); return;
}


// Function: entry_1fd89c
// Address: 0x1fd89c - 0x1fd8b8

void entry_1fd89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd89c) {
        switch (ctx->pc) {
            case 0x1fd8a8: ctx->pc = 0; goto label_1fd8a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd89c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fd8a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1fd8a8:
    // 0x1fd8a8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1fd8ac: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x1fd8b0: 0xc0635d6
    SET_GPR_U32(ctx, 31, 0x1fd8b8);
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    fn___builtin_new(rdram, ctx, runtime); return;
}


// Function: entry_1fd8b8
// Address: 0x1fd8b8 - 0x1fd8c8

void entry_1fd8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd8b8) {
        switch (ctx->pc) {
            case 0x1fd8c0: ctx->pc = 0; goto label_1fd8c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd8b8: 0x10000015
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fd910(rdram, ctx, runtime); return;
    }
label_1fd8c0:
    // 0x1fd8c0: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fd8c8);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fd8c8
// Address: 0x1fd8c8 - 0x1fd8d0

void entry_1fd8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8c8: 0xc07fa66
    SET_GPR_U32(ctx, 31, 0x1fd8d0);
    fn___start_cp_handler(rdram, ctx, runtime); return;
}


// Function: entry_1fd8d0
// Address: 0x1fd8d0 - 0x1fd8d8

void entry_1fd8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8d0: 0xc080000
    SET_GPR_U32(ctx, 31, 0x1fd8d8);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    bad_alloc_type_info_function(rdram, ctx, runtime); return;
}


// Function: entry_1fd8d8
// Address: 0x1fd8d8 - 0x1fd8e8

void entry_1fd8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8d8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1fd8dc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fd8e0: 0xc07fb04
    SET_GPR_U32(ctx, 31, 0x1fd8e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_001fec10(rdram, ctx, runtime); return;
}


// Function: entry_1fd8e8
// Address: 0x1fd8e8 - 0x1fd8f0

void entry_1fd8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8e8: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fd8f0);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fd8f0
// Address: 0x1fd8f0 - 0x1fd8f8

void entry_1fd8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8f0: 0xc07fac6
    SET_GPR_U32(ctx, 31, 0x1fd8f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___cp_pop_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fd8f8
// Address: 0x1fd8f8 - 0x1fd910

void entry_1fd8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd8f8: 0x1000fffb
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fd8e8(rdram, ctx, runtime); return;
    }
    // 0x1fd900: 0x1000ffef
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FD8C0; return;
    }
    // 0x1fd908: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fd910);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fd910
// Address: 0x1fd910 - 0x1fd920

void entry_1fd910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd910: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd91c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd920; return;
}


// Function: FUN_001fd920
// Address: 0x1fd920 - 0x1fd930

void FUN_001fd920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd920: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fd924: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fd928: 0xc080534
    SET_GPR_U32(ctx, 31, 0x1fd930);
    abort(rdram, ctx, runtime); return;
}


// Function: fn___terminate
// Address: 0x1fd930 - 0x1fd948

void entry_1fd948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd948: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd94c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd954: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd958; return;
}


// Function: fn___throw_type_match
// Address: 0x1fd958 - 0x1fd96c

void entry_1fd96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd96c: 0x2800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x1fd970: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd974: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fd978: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd97c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd984: 0x0
    // NOP
    // 0x1fd988: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: new_eh_context
// Address: 0x1fd990 - 0x1fd9a4

void entry_1fd9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd9a4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fd9a8: 0x16000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FD9BC; return;
    }
    // 0x1fd9b0: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fd9b8);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fd9b8
// Address: 0x1fd9b8 - 0x1fd9c8

void entry_1fd9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fd9b8) {
        switch (ctx->pc) {
            case 0x1fd9bc: ctx->pc = 0; goto label_1fd9bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fd9b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1fd9bc:
    // 0x1fd9bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fd9c0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1fd9c8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1fd9c8
// Address: 0x1fd9c8 - 0x1fd9e8

void entry_1fd9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd9c8: 0x26030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1fd9cc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fd9d0: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x1fd9d4: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fd9d8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fd9dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fd9e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fd9e8; return;
}


// Function: FUN_001fd9e8
// Address: 0x1fd9e8 - 0x1fda00

void FUN_001fd9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fd9e8: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fd9ec: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fd9f0: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fd9f4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fd9f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fda00);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fda00
// Address: 0x1fda00 - 0x1fda10

void entry_1fda00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fda00: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fda04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fda0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fda10; return;
}


// Function: fn___get_eh_info
// Address: 0x1fda10 - 0x1fda28

void entry_1fda28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fda28: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fda2c: 0x24420008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 8));
    // 0x1fda30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: eh_context_initialize
// Address: 0x1fda38 - 0x1fda54

void entry_1fda54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fda54: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fda58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: eh_context_static
// Address: 0x1fda60 - 0x1fda9c

void entry_1fda9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fda9c) {
        switch (ctx->pc) {
            case 0x1fdaac: ctx->pc = 0; goto label_1fdaac;
            case 0x1fdab0: ctx->pc = 0; goto label_1fdab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fda9c: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1fdaa0: 0x2463a7b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944688));
    // 0x1fdaa4: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fdab0;
    }
label_1fdaac:
    // 0x1fdaac: 0x3c110063
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
label_1fdab0:
    // 0x1fdab0: 0x2622a798
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294944664));
    // 0x1fdab4: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fdab8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fdabc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fdac0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fdac8
// Address: 0x1fdac8 - 0x1fdae0

void FUN_001fdac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fdac8: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fdacc: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fdad0: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fdad4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fdad8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fdae0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fdae0
// Address: 0x1fdae0 - 0x1fdaf0

void entry_1fdae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fdae0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fdae4: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1fdae8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fdaf0
// Address: 0x1fdaf0 - 0x1fdb5c

void FUN_001fdaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fdaf0: 0x27bdf8b0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294965424));
    // 0x1fdaf4: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fdaf8: 0xffbe06d0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1744), GPR_U64(ctx, 30));
    // 0x1fdafc: 0xffbf06e0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1760), GPR_U64(ctx, 31));
    // 0x1fdb00: 0xffb706c0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1728), GPR_U64(ctx, 23));
    // 0x1fdb04: 0xffb606b0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1712), GPR_U64(ctx, 22));
    // 0x1fdb08: 0xffb506a0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1696), GPR_U64(ctx, 21));
    // 0x1fdb0c: 0xffb40690
    WRITE64(ADD32(GPR_U32(ctx, 29), 1680), GPR_U64(ctx, 20));
    // 0x1fdb10: 0xffb30680
    WRITE64(ADD32(GPR_U32(ctx, 29), 1664), GPR_U64(ctx, 19));
    // 0x1fdb14: 0xffb20670
    WRITE64(ADD32(GPR_U32(ctx, 29), 1648), GPR_U64(ctx, 18));
    // 0x1fdb18: 0xffb10660
    WRITE64(ADD32(GPR_U32(ctx, 29), 1632), GPR_U64(ctx, 17));
    // 0x1fdb1c: 0xffb00650
    WRITE64(ADD32(GPR_U32(ctx, 29), 1616), GPR_U64(ctx, 16));
    // 0x1fdb20: 0xe7bf0748
    { float val = ctx->f[31]; WRITE32(ADD32(GPR_U32(ctx, 29), 1864), *(uint32_t*)&val); }
    // 0x1fdb24: 0xe7be0740
    { float val = ctx->f[30]; WRITE32(ADD32(GPR_U32(ctx, 29), 1856), *(uint32_t*)&val); }
    // 0x1fdb28: 0xe7bd0738
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 1848), *(uint32_t*)&val); }
    // 0x1fdb2c: 0xe7bc0730
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 1840), *(uint32_t*)&val); }
    // 0x1fdb30: 0xe7bb0728
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 1832), *(uint32_t*)&val); }
    // 0x1fdb34: 0xe7ba0720
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 1824), *(uint32_t*)&val); }
    // 0x1fdb38: 0xe7b90718
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 1816), *(uint32_t*)&val); }
    // 0x1fdb3c: 0xe7b80710
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 1808), *(uint32_t*)&val); }
    // 0x1fdb40: 0xe7b70708
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 1800), *(uint32_t*)&val); }
    // 0x1fdb44: 0xe7b60700
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 1792), *(uint32_t*)&val); }
    // 0x1fdb48: 0xe7b506f8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 1784), *(uint32_t*)&val); }
    // 0x1fdb4c: 0xe7b406f0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 1776), *(uint32_t*)&val); }
    // 0x1fdb50: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fdb54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fdb5c);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fdb5c
// Address: 0x1fdb5c - 0x1fdbec

void entry_1fdb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdb5c) {
        switch (ctx->pc) {
            case 0x1fdbac: ctx->pc = 0; goto label_1fdbac;
            case 0x1fdbd0: ctx->pc = 0; goto label_1fdbd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdb5c: 0xafc20640
    WRITE32(ADD32(GPR_U32(ctx, 30), 1600), GPR_U32(ctx, 2));
    // 0x1fdb60: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1fdb64: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1fdb68: 0x24650004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1fdb6c: 0xafc20644
    WRITE32(ADD32(GPR_U32(ctx, 30), 1604), GPR_U32(ctx, 2));
    // 0x1fdb70: 0xafc50648
    WRITE32(ADD32(GPR_U32(ctx, 30), 1608), GPR_U32(ctx, 5));
    // 0x1fdb74: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fdb78: 0x10400027
    SET_GPR_U32(ctx, 2, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1fdc18(rdram, ctx, runtime); return;
    }
    // 0x1fdb80: 0xafc30000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 3));
    // 0x1fdb84: 0x2442dba8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957992));
    // 0x1fdb88: 0xafc00004
    WRITE32(ADD32(GPR_U32(ctx, 30), 4), GPR_U32(ctx, 0));
    // 0x1fdb8c: 0x27c30008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 30), 8));
    // 0x1fdb90: 0xafde0008
    WRITE32(ADD32(GPR_U32(ctx, 30), 8), GPR_U32(ctx, 30));
    // 0x1fdb94: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x1fdb98: 0xafde064c
    WRITE32(ADD32(GPR_U32(ctx, 30), 1612), GPR_U32(ctx, 30));
    // 0x1fdb9c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fdba0: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 29));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fdbac;
    }
    // 0x1fdba8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1fdbac:
    // 0x1fdbac: 0x14400018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 1612)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDC10; return;
    }
    // 0x1fdbb4: 0x8fc60644
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1604)));
    // 0x1fdbb8: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x1fdbbc: 0x8fc50648
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1608)));
    // 0x1fdbc0: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1fdbc4: 0x1060000e
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1612)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDC00; return;
    }
    // 0x1fdbcc: 0x0
    // NOP
label_1fdbd0:
    // 0x1fdbd0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1fdbd4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1fdbd8: 0x8c640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1fdbdc: 0x8fc60648
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1608)));
    // 0x1fdbe0: 0x8c630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fdbe4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1fdbec);
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1fdbec
// Address: 0x1fdbec - 0x1fdc18

void entry_1fdbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdbec) {
        switch (ctx->pc) {
            case 0x1fdc00: ctx->pc = 0; goto label_1fdc00;
            case 0x1fdc10: ctx->pc = 0; goto label_1fdc10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdbec: 0x8fc30648
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1608)));
    // 0x1fdbf0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1fdbf4: 0x1440fff6
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDBD0; return;
    }
    // 0x1fdbfc: 0x8fc5064c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1612)));
label_1fdc00:
    // 0x1fdc00: 0x8fc60644
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1604)));
    // 0x1fdc04: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1fdc08: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fdc18(rdram, ctx, runtime); return;
    }
label_1fdc10:
    // 0x1fdc10: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fdc18);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fdc18
// Address: 0x1fdc18 - 0x1fdc40

void entry_1fdc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdc18) {
        switch (ctx->pc) {
            case 0x1fdc38: ctx->pc = 0; goto label_1fdc38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdc18: 0x8fc30640
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1600)));
    // 0x1fdc1c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1fdc20: 0x10400005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1604)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fdc38;
    }
    // 0x1fdc28: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1fdc2c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fdc30: 0x14400008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDC54; return;
    }
label_1fdc38:
    // 0x1fdc38: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fdc40);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fdc40
// Address: 0x1fdc40 - 0x1fdcd0

void entry_1fdc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdc40) {
        switch (ctx->pc) {
            case 0x1fdc54: ctx->pc = 0; goto label_1fdc54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdc40: 0x8fc60644
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1604)));
    // 0x1fdc44: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fdc48: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fdc4c: 0x24830008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1fdc50: 0x8fc50644
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1604)));
label_1fdc54:
    // 0x1fdc54: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1fdc58: 0x8c9e0008
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fdc5c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fdc60: 0x400008
    SET_GPR_U32(ctx, 29, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    ctx->pc = GPR_U32(ctx, 2); return;
    // 0x1fdc68: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fdc6c: 0x27bdf8b0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294965424));
    // 0x1fdc70: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fdc74: 0xffbf06e0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1760), GPR_U64(ctx, 31));
    // 0x1fdc78: 0xffbe06d0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1744), GPR_U64(ctx, 30));
    // 0x1fdc7c: 0xffb706c0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1728), GPR_U64(ctx, 23));
    // 0x1fdc80: 0xffb606b0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1712), GPR_U64(ctx, 22));
    // 0x1fdc84: 0xffb506a0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1696), GPR_U64(ctx, 21));
    // 0x1fdc88: 0xffb40690
    WRITE64(ADD32(GPR_U32(ctx, 29), 1680), GPR_U64(ctx, 20));
    // 0x1fdc8c: 0xffb30680
    WRITE64(ADD32(GPR_U32(ctx, 29), 1664), GPR_U64(ctx, 19));
    // 0x1fdc90: 0xffb20670
    WRITE64(ADD32(GPR_U32(ctx, 29), 1648), GPR_U64(ctx, 18));
    // 0x1fdc94: 0xffb10660
    WRITE64(ADD32(GPR_U32(ctx, 29), 1632), GPR_U64(ctx, 17));
    // 0x1fdc98: 0xffb00650
    WRITE64(ADD32(GPR_U32(ctx, 29), 1616), GPR_U64(ctx, 16));
    // 0x1fdc9c: 0xe7bf0748
    { float val = ctx->f[31]; WRITE32(ADD32(GPR_U32(ctx, 29), 1864), *(uint32_t*)&val); }
    // 0x1fdca0: 0xe7be0740
    { float val = ctx->f[30]; WRITE32(ADD32(GPR_U32(ctx, 29), 1856), *(uint32_t*)&val); }
    // 0x1fdca4: 0xe7bd0738
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 1848), *(uint32_t*)&val); }
    // 0x1fdca8: 0xe7bc0730
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 1840), *(uint32_t*)&val); }
    // 0x1fdcac: 0xe7bb0728
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 1832), *(uint32_t*)&val); }
    // 0x1fdcb0: 0xe7ba0720
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 1824), *(uint32_t*)&val); }
    // 0x1fdcb4: 0xe7b90718
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 1816), *(uint32_t*)&val); }
    // 0x1fdcb8: 0xe7b80710
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 1808), *(uint32_t*)&val); }
    // 0x1fdcbc: 0xe7b70708
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 1800), *(uint32_t*)&val); }
    // 0x1fdcc0: 0xe7b60700
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 1792), *(uint32_t*)&val); }
    // 0x1fdcc4: 0xe7b506f8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 1784), *(uint32_t*)&val); }
    // 0x1fdcc8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fdcd0);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 1776), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fdcd0
// Address: 0x1fdcd0 - 0x1fdd4c

void entry_1fdcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdcd0) {
        switch (ctx->pc) {
            case 0x1fdd30: ctx->pc = 0; goto label_1fdd30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdcd0: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1fdcd4: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1fdcd8: 0xafa20640
    WRITE32(ADD32(GPR_U32(ctx, 29), 1600), GPR_U32(ctx, 2));
    // 0x1fdcdc: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1fdce0: 0xafa20644
    WRITE32(ADD32(GPR_U32(ctx, 29), 1604), GPR_U32(ctx, 2));
    // 0x1fdce4: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fdce8: 0x10400020
    SET_GPR_U32(ctx, 2, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDD6C; return;
    }
    // 0x1fdcf0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1fdcf4: 0xafa00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    // 0x1fdcf8: 0x27a30008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 8));
    // 0x1fdcfc: 0xafbd0008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 29));
    // 0x1fdd00: 0x2442dd10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958352));
    // 0x1fdd04: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x1fdd08: 0xafbd0648
    WRITE32(ADD32(GPR_U32(ctx, 29), 1608), GPR_U32(ctx, 29));
    // 0x1fdd0c: 0xac7d0008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 29));
    // 0x1fdd10: 0x8fa30640
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fdd14: 0x8fa60648
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1608)));
    // 0x1fdd18: 0xac660000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 6));
    // 0x1fdd1c: 0x8fa20644
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1604)));
    // 0x1fdd20: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fdd24: 0x1060000e
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1608)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDD60; return;
    }
    // 0x1fdd2c: 0x0
    // NOP
label_1fdd30:
    // 0x1fdd30: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1fdd34: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1fdd38: 0x8c640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1fdd3c: 0x8fa60644
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1604)));
    // 0x1fdd40: 0x8c630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fdd44: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1fdd4c);
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1fdd4c
// Address: 0x1fdd4c - 0x1fdd80

void entry_1fdd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdd4c) {
        switch (ctx->pc) {
            case 0x1fdd60: ctx->pc = 0; goto label_1fdd60;
            case 0x1fdd6c: ctx->pc = 0; goto label_1fdd6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdd4c: 0x8fa30644
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1604)));
    // 0x1fdd50: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1fdd54: 0x1440fff6
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDD30; return;
    }
    // 0x1fdd5c: 0x8fa60648
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1608)));
label_1fdd60:
    // 0x1fdd60: 0x8fa30640
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fdd64: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fdd68: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1fdd6c:
    // 0x1fdd6c: 0x8fa60640
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fdd70: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fdd74: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fdd78: 0xc07f6bc
    SET_GPR_U32(ctx, 31, 0x1fdd80);
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 3));
    FUN_001fdaf0(rdram, ctx, runtime); return;
}


// Function: entry_1fdd80
// Address: 0x1fdd80 - 0x1fdd94

void entry_1fdd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fdd80: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1fdd84: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x1fdd88: 0xffbf0010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 31));
    // 0x1fdd8c: 0xc07f684
    SET_GPR_U32(ctx, 31, 0x1fdd94);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___get_eh_info(rdram, ctx, runtime); return;
}


// Function: entry_1fdd94
// Address: 0x1fdd94 - 0x1fddb4

void entry_1fdd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdd94) {
        switch (ctx->pc) {
            case 0x1fddac: ctx->pc = 0; goto label_1fddac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdd94: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fdd98: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fdd9c: 0x14400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1fddac;
    }
    // 0x1fdda4: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FDDB8; return;
    }
label_1fddac:
    // 0x1fddac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fddb4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fddb4
// Address: 0x1fddb4 - 0x1fddd8

void entry_1fddb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fddb4) {
        switch (ctx->pc) {
            case 0x1fddb8: ctx->pc = 0; goto label_1fddb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fddb4: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1fddb8:
    // 0x1fddb8: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fddbc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fddc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fddc8: 0x3e00008
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 4), 6)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fddd0: 0x3e00008
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 4), 4)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: old_find_exception_handler
// Address: 0x1fddd8 - 0x1fdeb0

void entry_1fdf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fdf98) {
        switch (ctx->pc) {
            case 0x1fdfa8: ctx->pc = 0; goto label_1fdfa8;
            case 0x1fdfb0: ctx->pc = 0; goto label_1fdfb0;
            case 0x1fdfb8: ctx->pc = 0; goto label_1fdfb8;
            case 0x1fdfbc: ctx->pc = 0; goto label_1fdfbc;
            case 0x1fdfc8: ctx->pc = 0; goto label_1fdfc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fdf98: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
        goto label_1fdfbc;
    }
    // 0x1fdfa0: 0x52600001
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1fdfa8;
    }
label_1fdfa8:
    // 0x1fdfa8: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fdfc8;
    }
label_1fdfb0:
    // 0x1fdfb0: 0x52600001
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1fdfb8;
    }
label_1fdfb8:
    // 0x1fdfb8: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
label_1fdfbc:
    // 0x1fdfbc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fdfc0: 0x1452ffe7
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x1FDF60; return;
    }
label_1fdfc8:
    // 0x1fdfc8: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1fdfcc: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1fdfd0: 0xdfb60060
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1fdfd4: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1fdfd8: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1fdfdc: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fdfe0: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fdfe4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fdfe8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fdfec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fdff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fdff8; return;
}


// Function: get_reg_addr
// Address: 0x1fdff8 - 0x1fe074

void entry_1fe074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe074: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe078: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: copy_reg
// Address: 0x1fe080 - 0x1fe0a4

void entry_1fe0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe0a4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe0a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fe0ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fe0b0: 0xc07f7fe
    SET_GPR_U32(ctx, 31, 0x1fe0b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    get_reg_addr(rdram, ctx, runtime); return;
}


// Function: entry_1fe0b8
// Address: 0x1fe0b8 - 0x1fe0e4

void entry_1fe0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe0b8) {
        switch (ctx->pc) {
            case 0x1fe0dc: ctx->pc = 0; goto label_1fe0dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe0b8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe0bc: 0x2a22001f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 31));
    // 0x1fe0c0: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
        goto label_1fe0dc;
    }
    // 0x1fe0c8: 0x2402003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1fe0cc: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1fe0d0: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x1fe0d4: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1fe0d8: 0x62300a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 3));
label_1fe0dc:
    // 0x1fe0dc: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1fe0e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1fe0e4
// Address: 0x1fe0e4 - 0x1fe100

void entry_1fe0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe0e4: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1fe0e8: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fe0ec: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fe0f0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe0f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe0fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fe100; return;
}


// Function: next_stack_level
// Address: 0x1fe100 - 0x1fe11c

void entry_1fe11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe11c) {
        switch (ctx->pc) {
            case 0x1fe130: ctx->pc = 0; goto label_1fe130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe11c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe120: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 664)));
        goto label_1fe130;
    }
    // 0x1fe128: 0x10000013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE178; return;
    }
label_1fe130:
    // 0x1fe130: 0x2241021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x1fe134: 0x8043029c
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 668)));
    // 0x1fe138: 0x10600008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE15C; return;
    }
    // 0x1fe140: 0xc07f7fe
    SET_GPR_U32(ctx, 31, 0x1fe148);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    get_reg_addr(rdram, ctx, runtime); return;
}


// Function: entry_1fe148
// Address: 0x1fe148 - 0x1fe190

void entry_1fe148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe148) {
        switch (ctx->pc) {
            case 0x1fe15c: ctx->pc = 0; goto label_1fe15c;
            case 0x1fe164: ctx->pc = 0; goto label_1fe164;
            case 0x1fe178: ctx->pc = 0; goto label_1fe178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe148: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe14c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fe150: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fe154: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fe164;
    }
label_1fe15c:
    // 0x1fe15c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fe160: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_1fe164:
    // 0x1fe164: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fe168: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fe16c: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1fe170: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1fe174: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
label_1fe178:
    // 0x1fe178: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1fe17c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fe180: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe184: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe18c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fe190; return;
}


// Function: fn___unwinding_cleanup
// Address: 0x1fe190 - 0x1fe198

void entry_1fe244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe244) {
        switch (ctx->pc) {
            case 0x1fe250: ctx->pc = 0; goto label_1fe250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe244: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe248: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE284; return;
    }
label_1fe250:
    // 0x1fe250: 0x10600008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE274; return;
    }
    // 0x1fe258: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1fe25c: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1fe260: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fe264: 0xc07f7ac
    SET_GPR_U32(ctx, 31, 0x1fe26c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 1504));
    find_exception_handler(rdram, ctx, runtime); return;
}


// Function: entry_1fe26c
// Address: 0x1fe26c - 0x1fe280

void entry_1fe26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe26c) {
        switch (ctx->pc) {
            case 0x1fe274: ctx->pc = 0; goto label_1fe274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe26c: 0x10000005
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE284; return;
    }
label_1fe274:
    // 0x1fe274: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1fe278: 0xc07f776
    SET_GPR_U32(ctx, 31, 0x1fe280);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    old_find_exception_handler(rdram, ctx, runtime); return;
}


// Function: entry_1fe280
// Address: 0x1fe280 - 0x1fe320

void entry_1fe280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe280) {
        switch (ctx->pc) {
            case 0x1fe284: ctx->pc = 0; goto label_1fe284;
            case 0x1fe2a8: ctx->pc = 0; goto label_1fe2a8;
            case 0x1fe308: ctx->pc = 0; goto label_1fe308;
            case 0x1fe310: ctx->pc = 0; goto label_1fe310;
            case 0x1fe314: ctx->pc = 0; goto label_1fe314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe280: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1fe284:
    // 0x1fe284: 0x12a00022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1504)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1fe310;
    }
    // 0x1fe28c: 0x1040001e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1528)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1fe308;
    }
    // 0x1fe294: 0x5440001f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
        goto label_1fe314;
    }
    // 0x1fe29c: 0x27a302f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 752));
    // 0x1fe2a0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fe2a4: 0x262402e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 736));
label_1fe2a8:
    // 0x1fe2a8: 0xdc450000
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe2ac: 0xdc460008
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1fe2b0: 0xdc470010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1fe2b4: 0xdc480018
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1fe2b8: 0xfc650000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 5));
    // 0x1fe2bc: 0xfc660008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 6));
    // 0x1fe2c0: 0xfc670010
    WRITE64(ADD32(GPR_U32(ctx, 3), 16), GPR_U64(ctx, 7));
    // 0x1fe2c4: 0xfc680018
    WRITE64(ADD32(GPR_U32(ctx, 3), 24), GPR_U64(ctx, 8));
    // 0x1fe2c8: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1fe2cc: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1fe2d0: 0x0
    // NOP
    // 0x1fe2d4: 0x1444fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1fe2a8;
    }
    // 0x1fe2dc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fe2e0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fe2e4: 0xafb005f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 1520), GPR_U32(ctx, 16));
    // 0x1fe2e8: 0xafb505ec
    WRITE32(ADD32(GPR_U32(ctx, 29), 1516), GPR_U32(ctx, 21));
    // 0x1fe2ec: 0xafa405f8
    WRITE32(ADD32(GPR_U32(ctx, 29), 1528), GPR_U32(ctx, 4));
    // 0x1fe2f0: 0xafa505f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 1524), GPR_U32(ctx, 5));
    // 0x1fe2f4: 0xdc460000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe2f8: 0xdc470008
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1fe2fc: 0xfc660000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 6));
    // 0x1fe300: 0x10000003
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fe310;
    }
label_1fe308:
    // 0x1fe308: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 29), 1524), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE350; return;
    }
label_1fe310:
    // 0x1fe310: 0x9624029a
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
label_1fe314:
    // 0x1fe314: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1fe318: 0xc07f7fe
    SET_GPR_U32(ctx, 31, 0x1fe320);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    get_reg_addr(rdram, ctx, runtime); return;
}


// Function: entry_1fe320
// Address: 0x1fe320 - 0x1fe344

void entry_1fe320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe320) {
        switch (ctx->pc) {
            case 0x1fe330: ctx->pc = 0; goto label_1fe330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe320: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe324: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fe328: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fe32c: 0x2470ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 4294967295));
label_1fe330:
    // 0x1fe330: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fe334: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1fe338: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fe33c: 0xc07f840
    SET_GPR_U32(ctx, 31, 0x1fe344);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    next_stack_level(rdram, ctx, runtime); return;
}


// Function: entry_1fe344
// Address: 0x1fe344 - 0x1fe374

void entry_1fe344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe344) {
        switch (ctx->pc) {
            case 0x1fe350: ctx->pc = 0; goto label_1fe350;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe344: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe348: 0x1620ffad
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE200; return;
    }
label_1fe350:
    // 0x1fe350: 0x8fa505f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 1528)));
    // 0x1fe354: 0x10a00007
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 1524)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1fe374(rdram, ctx, runtime); return;
    }
    // 0x1fe35c: 0x27b102f0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 752));
    // 0x1fe360: 0x8fb505ec
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 29), 1516)));
    // 0x1fe364: 0x10c00003
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 1520)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_1fe374(rdram, ctx, runtime); return;
    }
    // 0x1fe36c: 0xc07f864
    SET_GPR_U32(ctx, 31, 0x1fe374);
    fn___unwinding_cleanup(rdram, ctx, runtime); return;
}


// Function: entry_1fe374
// Address: 0x1fe374 - 0x1fe384

void entry_1fe374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe374: 0x56a00004
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 21));
        ctx->pc = 0x1FE388; return;
    }
    // 0x1fe37c: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fe384);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe384
// Address: 0x1fe384 - 0x1fe410

void entry_1fe384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe384) {
        switch (ctx->pc) {
            case 0x1fe388: ctx->pc = 0; goto label_1fe388;
            case 0x1fe39c: ctx->pc = 0; goto label_1fe39c;
            case 0x1fe3ac: ctx->pc = 0; goto label_1fe3ac;
            case 0x1fe400: ctx->pc = 0; goto label_1fe400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe384: 0xae750000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 21));
label_1fe388:
    // 0x1fe388: 0x8fa705e8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 1512)));
    // 0x1fe38c: 0x16070003
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 7)) {
        goto label_1fe39c;
    }
    // 0x1fe394: 0x1000003d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE48C; return;
    }
label_1fe39c:
    // 0x1fe39c: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fe3a0: 0x8fb005e8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 1512)));
    // 0x1fe3a4: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1fe3a8: 0x27c402e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 736));
label_1fe3ac:
    // 0x1fe3ac: 0xdc480000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe3b0: 0xdc450008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1fe3b4: 0xdc460010
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1fe3b8: 0xdc470018
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1fe3bc: 0xfc680000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 8));
    // 0x1fe3c0: 0xfc650008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 5));
    // 0x1fe3c4: 0xfc660010
    WRITE64(ADD32(GPR_U32(ctx, 3), 16), GPR_U64(ctx, 6));
    // 0x1fe3c8: 0xfc670018
    WRITE64(ADD32(GPR_U32(ctx, 3), 24), GPR_U64(ctx, 7));
    // 0x1fe3cc: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1fe3d0: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1fe3d4: 0x0
    // NOP
    // 0x1fe3d8: 0x1444fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1fe3ac;
    }
    // 0x1fe3e0: 0xdc480000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe3e4: 0xdc440008
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1fe3e8: 0xfc680000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 8));
    // 0x1fe3ec: 0xfc640008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 4));
    // 0x1fe3f0: 0x8fa705e8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 1512)));
    // 0x1fe3f4: 0x50f60022
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
        ctx->pc = 0x1FE480; return;
    }
    // 0x1fe3fc: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1fe400:
    // 0x1fe400: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1fe404: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fe408: 0xc07f840
    SET_GPR_U32(ctx, 31, 0x1fe410);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    next_stack_level(rdram, ctx, runtime); return;
}


// Function: entry_1fe410
// Address: 0x1fe410 - 0x1fe448

void entry_1fe410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe410) {
        switch (ctx->pc) {
            case 0x1fe428: ctx->pc = 0; goto label_1fe428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe410: 0x240a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1fe414: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe418: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1fe41c: 0x9624029a
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
    // 0x1fe420: 0x2633029c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 668));
    // 0x1fe424: 0x0
    // NOP
label_1fe428:
    // 0x1fe428: 0x12040008
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1FE44C; return;
    }
    // 0x1fe430: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe434: 0x10600005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE44C; return;
    }
    // 0x1fe43c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fe440: 0xc07f820
    SET_GPR_U32(ctx, 31, 0x1fe448);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    copy_reg(rdram, ctx, runtime); return;
}


// Function: entry_1fe448
// Address: 0x1fe448 - 0x1fe464

void entry_1fe448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe448) {
        switch (ctx->pc) {
            case 0x1fe44c: ctx->pc = 0; goto label_1fe44c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe448: 0x9624029a
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
label_1fe44c:
    // 0x1fe44c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1fe450: 0x2a02004f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 79));
    // 0x1fe454: 0x1440fff4
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE428; return;
    }
    // 0x1fe45c: 0xc07f7fe
    SET_GPR_U32(ctx, 31, 0x1fe464);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    get_reg_addr(rdram, ctx, runtime); return;
}


// Function: entry_1fe464
// Address: 0x1fe464 - 0x1fe4c8

void entry_1fe464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe464) {
        switch (ctx->pc) {
            case 0x1fe480: ctx->pc = 0; goto label_1fe480;
            case 0x1fe48c: ctx->pc = 0; goto label_1fe48c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe464: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe468: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1fe46c: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x1fe470: 0x2470ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1fe474: 0x1616ffe2
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 22)) {
        ctx->pc = 0x1FE400; return;
    }
    // 0x1fe47c: 0x9622029a
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 666)));
label_1fe480:
    // 0x1fe480: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1fe484: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1fe488: 0x8043029c
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 668)));
label_1fe48c:
    // 0x1fe48c: 0x8fa805e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 1508)));
    // 0x1fe490: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1fe494: 0xdfbf0690
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 1680)));
    // 0x1fe498: 0xad110000
    WRITE32(ADD32(GPR_U32(ctx, 8), 0), GPR_U32(ctx, 17));
    // 0x1fe49c: 0xdfbe0680
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x1fe4a0: 0xdfb70670
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 1648)));
    // 0x1fe4a4: 0xdfb60660
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 1632)));
    // 0x1fe4a8: 0xdfb50650
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 1616)));
    // 0x1fe4ac: 0xdfb40640
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fe4b0: 0xdfb30630
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 1584)));
    // 0x1fe4b4: 0xdfb20620
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 1568)));
    // 0x1fe4b8: 0xdfb10610
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 1552)));
    // 0x1fe4bc: 0xdfb00600
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 1536)));
    // 0x1fe4c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1696));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fe4c8
// Address: 0x1fe4c8 - 0x1fe534

void FUN_001fe4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe4c8: 0x27bdf910
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294965520));
    // 0x1fe4cc: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fe4d0: 0xffbe0670
    WRITE64(ADD32(GPR_U32(ctx, 29), 1648), GPR_U64(ctx, 30));
    // 0x1fe4d4: 0xffbf0680
    WRITE64(ADD32(GPR_U32(ctx, 29), 1664), GPR_U64(ctx, 31));
    // 0x1fe4d8: 0xffb70660
    WRITE64(ADD32(GPR_U32(ctx, 29), 1632), GPR_U64(ctx, 23));
    // 0x1fe4dc: 0xffb60650
    WRITE64(ADD32(GPR_U32(ctx, 29), 1616), GPR_U64(ctx, 22));
    // 0x1fe4e0: 0xffb50640
    WRITE64(ADD32(GPR_U32(ctx, 29), 1600), GPR_U64(ctx, 21));
    // 0x1fe4e4: 0xffb40630
    WRITE64(ADD32(GPR_U32(ctx, 29), 1584), GPR_U64(ctx, 20));
    // 0x1fe4e8: 0xffb30620
    WRITE64(ADD32(GPR_U32(ctx, 29), 1568), GPR_U64(ctx, 19));
    // 0x1fe4ec: 0xffb20610
    WRITE64(ADD32(GPR_U32(ctx, 29), 1552), GPR_U64(ctx, 18));
    // 0x1fe4f0: 0xffb10600
    WRITE64(ADD32(GPR_U32(ctx, 29), 1536), GPR_U64(ctx, 17));
    // 0x1fe4f4: 0xffb005f0
    WRITE64(ADD32(GPR_U32(ctx, 29), 1520), GPR_U64(ctx, 16));
    // 0x1fe4f8: 0xe7bf06e8
    { float val = ctx->f[31]; WRITE32(ADD32(GPR_U32(ctx, 29), 1768), *(uint32_t*)&val); }
    // 0x1fe4fc: 0xe7be06e0
    { float val = ctx->f[30]; WRITE32(ADD32(GPR_U32(ctx, 29), 1760), *(uint32_t*)&val); }
    // 0x1fe500: 0xe7bd06d8
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 1752), *(uint32_t*)&val); }
    // 0x1fe504: 0xe7bc06d0
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 1744), *(uint32_t*)&val); }
    // 0x1fe508: 0xe7bb06c8
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 1736), *(uint32_t*)&val); }
    // 0x1fe50c: 0xe7ba06c0
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 1728), *(uint32_t*)&val); }
    // 0x1fe510: 0xe7b906b8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 1720), *(uint32_t*)&val); }
    // 0x1fe514: 0xe7b806b0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 1712), *(uint32_t*)&val); }
    // 0x1fe518: 0xe7b706a8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 1704), *(uint32_t*)&val); }
    // 0x1fe51c: 0xe7b606a0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 1696), *(uint32_t*)&val); }
    // 0x1fe520: 0xe7b50698
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 1688), *(uint32_t*)&val); }
    // 0x1fe524: 0xe7b40690
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 1680), *(uint32_t*)&val); }
    // 0x1fe528: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fe52c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fe534);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fe534
// Address: 0x1fe534 - 0x1fe558

void entry_1fe534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe534: 0xafc205e4
    WRITE32(ADD32(GPR_U32(ctx, 30), 1508), GPR_U32(ctx, 2));
    // 0x1fe538: 0x27c202f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 752));
    // 0x1fe53c: 0x8fc305e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1508)));
    // 0x1fe540: 0xafc205e8
    WRITE32(ADD32(GPR_U32(ctx, 30), 1512), GPR_U32(ctx, 2));
    // 0x1fe544: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1fe548: 0x14400006
    WRITE32(ADD32(GPR_U32(ctx, 30), 1504), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE564; return;
    }
    // 0x1fe550: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fe558);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe558
// Address: 0x1fe558 - 0x1fe57c

void entry_1fe558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe558) {
        switch (ctx->pc) {
            case 0x1fe564: ctx->pc = 0; goto label_1fe564;
            case 0x1fe56c: ctx->pc = 0; goto label_1fe56c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe558: 0x27c505e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 1504));
    // 0x1fe55c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 30), 1516), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fe56c;
    }
label_1fe564:
    // 0x1fe564: 0x27c605e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 30), 1504));
    // 0x1fe568: 0xafc605ec
    WRITE32(ADD32(GPR_U32(ctx, 30), 1516), GPR_U32(ctx, 6));
label_1fe56c:
    // 0x1fe56c: 0x3c070020
    SET_GPR_U32(ctx, 7, ((uint32_t)32 << 16));
    // 0x1fe570: 0x8fc505e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
    // 0x1fe574: 0xc07ff20
    SET_GPR_U32(ctx, 31, 0x1fe57c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 7), 4294960492));
    fn___frame_state_for(rdram, ctx, runtime); return;
}


// Function: entry_1fe57c
// Address: 0x1fe57c - 0x1fe590

void entry_1fe57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe57c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe580: 0x14600004
    WRITE32(ADD32(GPR_U32(ctx, 30), 1504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE594; return;
    }
    // 0x1fe588: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fe590);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe590
// Address: 0x1fe590 - 0x1fe608

void entry_1fe590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe590) {
        switch (ctx->pc) {
            case 0x1fe594: ctx->pc = 0; goto label_1fe594;
            case 0x1fe5a8: ctx->pc = 0; goto label_1fe5a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe590: 0x8fc305e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
label_1fe594:
    // 0x1fe594: 0x27c806f0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 30), 1776));
    // 0x1fe598: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fe59c: 0xac680000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 8));
    // 0x1fe5a0: 0x248302e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 736));
    // 0x1fe5a4: 0x8fc205e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
label_1fe5a8:
    // 0x1fe5a8: 0xdc850000
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fe5ac: 0xdc860008
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fe5b0: 0xdc870010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1fe5b4: 0xdc880018
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1fe5b8: 0xfc450000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 5));
    // 0x1fe5bc: 0xfc460008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 6));
    // 0x1fe5c0: 0xfc470010
    WRITE64(ADD32(GPR_U32(ctx, 2), 16), GPR_U64(ctx, 7));
    // 0x1fe5c4: 0xfc480018
    WRITE64(ADD32(GPR_U32(ctx, 2), 24), GPR_U64(ctx, 8));
    // 0x1fe5c8: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1fe5cc: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1fe5d0: 0x0
    // NOP
    // 0x1fe5d4: 0x1483fff4
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1fe5a8;
    }
    // 0x1fe5dc: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fe5e0: 0xdc850008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fe5e4: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x1fe5e8: 0xfc450008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 5));
    // 0x1fe5ec: 0x27c20680
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1664));
    // 0x1fe5f0: 0x8fc405e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 1508)));
    // 0x1fe5f4: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe5f8: 0x8fc605e8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    // 0x1fe5fc: 0x8fc705ec
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 30), 1516)));
    // 0x1fe600: 0xc07f866
    SET_GPR_U32(ctx, 31, 0x1fe608);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    throw_helper(rdram, ctx, runtime); return;
}


// Function: entry_1fe608
// Address: 0x1fe608 - 0x1fe6a8

void entry_1fe608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe608) {
        switch (ctx->pc) {
            case 0x1fe640: ctx->pc = 0; goto label_1fe640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe608: 0x8fc605e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
    // 0x1fe60c: 0x3c030020
    SET_GPR_U32(ctx, 3, ((uint32_t)32 << 16));
    // 0x1fe610: 0x8fc805e8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    // 0x1fe614: 0x2465e638
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 4294960696));
    // 0x1fe618: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fe61c: 0x27c40680
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 1664));
    // 0x1fe620: 0x8d070000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1fe624: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x1fe628: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe62c: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fe630: 0x10000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 1508)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fe640;
    }
    // 0x1fe638: 0x800008
    SET_GPR_U32(ctx, 29, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    ctx->pc = GPR_U32(ctx, 4); return;
label_1fe640:
    // 0x1fe640: 0x3c0e82d
    SET_GPR_U64(ctx, 29, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1fe644: 0xdfbf0680
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x1fe648: 0xdfbe0670
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 1648)));
    // 0x1fe64c: 0xdfb70660
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 1632)));
    // 0x1fe650: 0xdfb60650
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 1616)));
    // 0x1fe654: 0xdfb50640
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fe658: 0xdfb40630
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 1584)));
    // 0x1fe65c: 0xdfb30620
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 1568)));
    // 0x1fe660: 0xdfb20610
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 1552)));
    // 0x1fe664: 0xdfb10600
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 1536)));
    // 0x1fe668: 0xdfb005f0
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 1520)));
    // 0x1fe66c: 0xc7bf06e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1768)); ctx->f[31] = *(float*)&val; }
    // 0x1fe670: 0xc7be06e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1760)); ctx->f[30] = *(float*)&val; }
    // 0x1fe674: 0xc7bd06d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1752)); ctx->f[29] = *(float*)&val; }
    // 0x1fe678: 0xc7bc06d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1744)); ctx->f[28] = *(float*)&val; }
    // 0x1fe67c: 0xc7bb06c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1736)); ctx->f[27] = *(float*)&val; }
    // 0x1fe680: 0xc7ba06c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1728)); ctx->f[26] = *(float*)&val; }
    // 0x1fe684: 0xc7b906b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1720)); ctx->f[25] = *(float*)&val; }
    // 0x1fe688: 0xc7b806b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1712)); ctx->f[24] = *(float*)&val; }
    // 0x1fe68c: 0xc7b706a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1704)); ctx->f[23] = *(float*)&val; }
    // 0x1fe690: 0xc7b606a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1696)); ctx->f[22] = *(float*)&val; }
    // 0x1fe694: 0xc7b50698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1688)); ctx->f[21] = *(float*)&val; }
    // 0x1fe698: 0xc7b40690
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1680)); ctx->f[20] = *(float*)&val; }
    // 0x1fe69c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1776));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe6a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fe6a8; return;
}


// Function: FUN_001fe6a8
// Address: 0x1fe6a8 - 0x1fe71c

void FUN_001fe6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe6a8: 0x27bdf900
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294965504));
    // 0x1fe6ac: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fe6b0: 0xffbe0680
    WRITE64(ADD32(GPR_U32(ctx, 29), 1664), GPR_U64(ctx, 30));
    // 0x1fe6b4: 0x3a0f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1fe6b8: 0xffbf0690
    WRITE64(ADD32(GPR_U32(ctx, 29), 1680), GPR_U64(ctx, 31));
    // 0x1fe6bc: 0xffb70670
    WRITE64(ADD32(GPR_U32(ctx, 29), 1648), GPR_U64(ctx, 23));
    // 0x1fe6c0: 0xffb60660
    WRITE64(ADD32(GPR_U32(ctx, 29), 1632), GPR_U64(ctx, 22));
    // 0x1fe6c4: 0xffb50650
    WRITE64(ADD32(GPR_U32(ctx, 29), 1616), GPR_U64(ctx, 21));
    // 0x1fe6c8: 0xffb40640
    WRITE64(ADD32(GPR_U32(ctx, 29), 1600), GPR_U64(ctx, 20));
    // 0x1fe6cc: 0xffb30630
    WRITE64(ADD32(GPR_U32(ctx, 29), 1584), GPR_U64(ctx, 19));
    // 0x1fe6d0: 0xffb20620
    WRITE64(ADD32(GPR_U32(ctx, 29), 1568), GPR_U64(ctx, 18));
    // 0x1fe6d4: 0xffb10610
    WRITE64(ADD32(GPR_U32(ctx, 29), 1552), GPR_U64(ctx, 17));
    // 0x1fe6d8: 0xffb00600
    WRITE64(ADD32(GPR_U32(ctx, 29), 1536), GPR_U64(ctx, 16));
    // 0x1fe6dc: 0xe7bf06f8
    { float val = ctx->f[31]; WRITE32(ADD32(GPR_U32(ctx, 29), 1784), *(uint32_t*)&val); }
    // 0x1fe6e0: 0xe7be06f0
    { float val = ctx->f[30]; WRITE32(ADD32(GPR_U32(ctx, 29), 1776), *(uint32_t*)&val); }
    // 0x1fe6e4: 0xe7bd06e8
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 1768), *(uint32_t*)&val); }
    // 0x1fe6e8: 0xe7bc06e0
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 1760), *(uint32_t*)&val); }
    // 0x1fe6ec: 0xe7bb06d8
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 1752), *(uint32_t*)&val); }
    // 0x1fe6f0: 0xe7ba06d0
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 1744), *(uint32_t*)&val); }
    // 0x1fe6f4: 0xe7b906c8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 1736), *(uint32_t*)&val); }
    // 0x1fe6f8: 0xe7b806c0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 1728), *(uint32_t*)&val); }
    // 0x1fe6fc: 0xe7b706b8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 1720), *(uint32_t*)&val); }
    // 0x1fe700: 0xe7b606b0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 1712), *(uint32_t*)&val); }
    // 0x1fe704: 0xe7b506a8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 1704), *(uint32_t*)&val); }
    // 0x1fe708: 0xe7b406a0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 1696), *(uint32_t*)&val); }
    // 0x1fe70c: 0xafc405e4
    WRITE32(ADD32(GPR_U32(ctx, 30), 1508), GPR_U32(ctx, 4));
    // 0x1fe710: 0x8c62804c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934604)));
    // 0x1fe714: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fe71c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fe71c
// Address: 0x1fe71c - 0x1fe740

void entry_1fe71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe71c: 0xafc205e8
    WRITE32(ADD32(GPR_U32(ctx, 30), 1512), GPR_U32(ctx, 2));
    // 0x1fe720: 0x27c202f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 752));
    // 0x1fe724: 0x8fc305e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    // 0x1fe728: 0xafc205ec
    WRITE32(ADD32(GPR_U32(ctx, 30), 1516), GPR_U32(ctx, 2));
    // 0x1fe72c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1fe730: 0x14400003
    WRITE32(ADD32(GPR_U32(ctx, 30), 1504), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1fe740(rdram, ctx, runtime); return;
    }
    // 0x1fe738: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fe740);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe740
// Address: 0x1fe740 - 0x1fe764

void entry_1fe740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe740: 0x8fc605e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1508)));
    // 0x1fe744: 0x27c705e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 30), 1504));
    // 0x1fe748: 0x8fc505e8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    // 0x1fe74c: 0xaca6000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 6));
    // 0x1fe750: 0xafc705f0
    WRITE32(ADD32(GPR_U32(ctx, 30), 1520), GPR_U32(ctx, 7));
    // 0x1fe754: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x1fe758: 0x8fc505e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
    // 0x1fe75c: 0xc07ff20
    SET_GPR_U32(ctx, 31, 0x1fe764);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 8), 4294960980));
    fn___frame_state_for(rdram, ctx, runtime); return;
}


// Function: entry_1fe764
// Address: 0x1fe764 - 0x1fe778

void entry_1fe764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe764: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe768: 0x14600004
    WRITE32(ADD32(GPR_U32(ctx, 30), 1504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FE77C; return;
    }
    // 0x1fe770: 0xc07f64c
    SET_GPR_U32(ctx, 31, 0x1fe778);
    fn___terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe778
// Address: 0x1fe778 - 0x1fe7f0

void entry_1fe778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe778) {
        switch (ctx->pc) {
            case 0x1fe77c: ctx->pc = 0; goto label_1fe77c;
            case 0x1fe790: ctx->pc = 0; goto label_1fe790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe778: 0x8fc305e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
label_1fe77c:
    // 0x1fe77c: 0x27c20700
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1792));
    // 0x1fe780: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fe784: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1fe788: 0x8fc205ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 1516)));
    // 0x1fe78c: 0x248302e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 736));
label_1fe790:
    // 0x1fe790: 0xdc850000
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fe794: 0xdc860008
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fe798: 0xdc870010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1fe79c: 0xdc880018
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1fe7a0: 0xfc450000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 5));
    // 0x1fe7a4: 0xfc460008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 6));
    // 0x1fe7a8: 0xfc470010
    WRITE64(ADD32(GPR_U32(ctx, 2), 16), GPR_U64(ctx, 7));
    // 0x1fe7ac: 0xfc480018
    WRITE64(ADD32(GPR_U32(ctx, 2), 24), GPR_U64(ctx, 8));
    // 0x1fe7b0: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1fe7b4: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1fe7b8: 0x0
    // NOP
    // 0x1fe7bc: 0x1483fff4
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1fe790;
    }
    // 0x1fe7c4: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1fe7c8: 0xdc850008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1fe7cc: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x1fe7d0: 0xfc450008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 5));
    // 0x1fe7d4: 0x27c20690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1680));
    // 0x1fe7d8: 0x8fc405e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    // 0x1fe7dc: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe7e0: 0x8fc605ec
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1516)));
    // 0x1fe7e4: 0x8fc705f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 30), 1520)));
    // 0x1fe7e8: 0xc07f866
    SET_GPR_U32(ctx, 31, 0x1fe7f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    throw_helper(rdram, ctx, runtime); return;
}


// Function: entry_1fe7f0
// Address: 0x1fe7f0 - 0x1fe8f0

void entry_1fe7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fe7f0) {
        switch (ctx->pc) {
            case 0x1fe828: ctx->pc = 0; goto label_1fe828;
            case 0x1fe890: ctx->pc = 0; goto label_1fe890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fe7f0: 0x8fc605e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 1504)));
    // 0x1fe7f4: 0x3c030020
    SET_GPR_U32(ctx, 3, ((uint32_t)32 << 16));
    // 0x1fe7f8: 0x8fc805ec
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 30), 1516)));
    // 0x1fe7fc: 0x2465e820
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 4294961184));
    // 0x1fe800: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1fe804: 0x27c40690
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 1680));
    // 0x1fe808: 0x8d070000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1fe80c: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x1fe810: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fe814: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1fe818: 0x10000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 1512)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1fe828;
    }
    // 0x1fe820: 0x800008
    SET_GPR_U32(ctx, 29, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    ctx->pc = GPR_U32(ctx, 4); return;
label_1fe828:
    // 0x1fe828: 0x3c0e82d
    SET_GPR_U64(ctx, 29, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1fe82c: 0xdfbf0690
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 1680)));
    // 0x1fe830: 0xdfbe0680
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x1fe834: 0xdfb70670
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 1648)));
    // 0x1fe838: 0xdfb60660
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 1632)));
    // 0x1fe83c: 0xdfb50650
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 1616)));
    // 0x1fe840: 0xdfb40640
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 1600)));
    // 0x1fe844: 0xdfb30630
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 1584)));
    // 0x1fe848: 0xdfb20620
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 1568)));
    // 0x1fe84c: 0xdfb10610
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 1552)));
    // 0x1fe850: 0xdfb00600
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 1536)));
    // 0x1fe854: 0xc7bf06f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1784)); ctx->f[31] = *(float*)&val; }
    // 0x1fe858: 0xc7be06f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1776)); ctx->f[30] = *(float*)&val; }
    // 0x1fe85c: 0xc7bd06e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1768)); ctx->f[29] = *(float*)&val; }
    // 0x1fe860: 0xc7bc06e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1760)); ctx->f[28] = *(float*)&val; }
    // 0x1fe864: 0xc7bb06d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1752)); ctx->f[27] = *(float*)&val; }
    // 0x1fe868: 0xc7ba06d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1744)); ctx->f[26] = *(float*)&val; }
    // 0x1fe86c: 0xc7b906c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1736)); ctx->f[25] = *(float*)&val; }
    // 0x1fe870: 0xc7b806c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1728)); ctx->f[24] = *(float*)&val; }
    // 0x1fe874: 0xc7b706b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1720)); ctx->f[23] = *(float*)&val; }
    // 0x1fe878: 0xc7b606b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1712)); ctx->f[22] = *(float*)&val; }
    // 0x1fe87c: 0xc7b506a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1704)); ctx->f[21] = *(float*)&val; }
    // 0x1fe880: 0xc7b406a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1696)); ctx->f[20] = *(float*)&val; }
    // 0x1fe884: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1792));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe88c: 0x0
    // NOP
label_1fe890:
    // 0x1fe890: 0x4303f
    SET_GPR_S64(ctx, 6, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fe894: 0x5183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1fe898: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1fe89c: 0x4203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fe8a0: 0x5283c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 0));
    // 0x1fe8a4: 0x5283f
    SET_GPR_S64(ctx, 5, GPR_S64(ctx, 5) >> (32 + 0));
    // 0x1fe8a8: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fe8ac: 0x70c53018
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 5); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x1fe8b0: 0x850019
    { uint64_t result = (uint64_t)GPR_U32(ctx, 4) * (uint64_t)GPR_U32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1fe8b4: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x1fe8b8: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x1fe8bc: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x1fe8c0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fe8c4: 0x4203e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) >> (32 + 0));
    // 0x1fe8c8: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1fe8cc: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1fe8d0: 0x3c05ffff
    SET_GPR_U32(ctx, 5, ((uint32_t)65535 << 16));
    // 0x1fe8d4: 0x5283e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) >> (32 + 0));
    // 0x1fe8d8: 0x4103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x1fe8dc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1fe8e0: 0x852024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1fe8e4: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1fe8e8: 0x3e00008
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: terminate
// Address: 0x1fe8f0 - 0x1fe908

void FUN_001fe908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe908: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fe90c: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fe910: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fe918);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe918
// Address: 0x1fe918 - 0x1fe938

void entry_1fe918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe918: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fe91c: 0x8c628048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294934600)));
    // 0x1fe920: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294934600), GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe928: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x1fe92c: 0x8c628640
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294936128)));
    // 0x1fe930: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294936128), GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fe938
// Address: 0x1fe938 - 0x1fe950

void FUN_001fe938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe938: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x1fe93c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fe940: 0x8c438640
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294936128)));
    // 0x1fe944: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fe948: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1fe950);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1fe950
// Address: 0x1fe950 - 0x1fe960

void entry_1fe950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe950: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fe954: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fe958: 0xc07f684
    SET_GPR_U32(ctx, 31, 0x1fe960);
    fn___get_eh_info(rdram, ctx, runtime); return;
}


// Function: entry_1fe960
// Address: 0x1fe960 - 0x1fe978

void entry_1fe960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe960: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe964: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe968: 0x24420008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 8));
    // 0x1fe96c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fe974: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fe978; return;
}


// Function: fn___cp_eh_info
// Address: 0x1fe978 - 0x1fe988

void entry_1fe988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe988: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe98c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe990: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___start_cp_handler
// Address: 0x1fe998 - 0x1fe9a8

void entry_1fe9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe9a8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fe9ac: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fe9b0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fe9b4: 0xdc640020
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1fe9b8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1fe9bc: 0xac650014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 5));
    // 0x1fe9c0: 0x64840001
    SET_GPR_S64(ctx, 4, (int64_t)GPR_S64(ctx, 4) + (int64_t)1);
    // 0x1fe9c4: 0xfc640020
    WRITE64(ADD32(GPR_U32(ctx, 3), 32), GPR_U64(ctx, 4));
    // 0x1fe9c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___eh_alloc
// Address: 0x1fe9d0 - 0x1fe9e0

void entry_1fe9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe9e0: 0x14400003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1fe9f0(rdram, ctx, runtime); return;
    }
    // 0x1fe9e8: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fe9f0);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fe9f0
// Address: 0x1fe9f0 - 0x1fe9f8

void entry_1fe9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fe9f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___eh_free
// Address: 0x1fe9f8 - 0x1fea08

void entry_1fea08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fea08: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fea0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fea14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fea18; return;
}


// Function: fn___cplus_type_matcher
// Address: 0x1fea18 - 0x1fea5c

void entry_1fea5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fea5c: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1fea60: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fea64: 0xc0801de
    SET_GPR_U32(ctx, 31, 0x1fea6c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    fn___throw_type_match_rtti(rdram, ctx, runtime); return;
}


// Function: entry_1fea6c
// Address: 0x1fea6c - 0x1fea88

void entry_1fea6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fea6c) {
        switch (ctx->pc) {
            case 0x1fea74: ctx->pc = 0; goto label_1fea74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fea6c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
        goto label_1fea74;
    }
label_1fea74:
    // 0x1fea74: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fea78: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fea7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fea84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fea88; return;
}


// Function: fn___cp_push_exception
// Address: 0x1fea88 - 0x1feab4

void entry_1feab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feab4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1feab8: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1feabc: 0x3c020020
    SET_GPR_U32(ctx, 2, ((uint32_t)32 << 16));
    // 0x1feac0: 0xae12000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 18));
    // 0x1feac4: 0xae110010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 17));
    // 0x1feac8: 0x2442ea18
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961688));
    // 0x1feacc: 0xae130028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 19));
    // 0x1fead0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1fead4: 0xae130008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 19));
    // 0x1fead8: 0xfe000020
    WRITE64(ADD32(GPR_U32(ctx, 16), 32), GPR_U64(ctx, 0));
    // 0x1feadc: 0xae000014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 0));
    // 0x1feae0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1feae4: 0xa6040004
    WRITE16(ADD32(GPR_U32(ctx, 16), 4), (uint16_t)GPR_U32(ctx, 4));
    // 0x1feae8: 0xc07f684
    SET_GPR_U32(ctx, 31, 0x1feaf0);
    WRITE16(ADD32(GPR_U32(ctx, 16), 6), (uint16_t)GPR_U32(ctx, 3));
    fn___get_eh_info(rdram, ctx, runtime); return;
}


// Function: entry_1feaf0
// Address: 0x1feaf0 - 0x1feb18

void entry_1feaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feaf0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1feaf4: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1feaf8: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    // 0x1feafc: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1feb00: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1feb04: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1feb08: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1feb0c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1feb10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___cp_pop_exception
// Address: 0x1feb18 - 0x1feb2c

void entry_1feb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1feb2c) {
        switch (ctx->pc) {
            case 0x1feb58: ctx->pc = 0; goto label_1feb58;
            case 0x1feb70: ctx->pc = 0; goto label_1feb70;
            case 0x1feb74: ctx->pc = 0; goto label_1feb74;
            case 0x1feb84: ctx->pc = 0; goto label_1feb84;
            case 0x1feb8c: ctx->pc = 0; goto label_1feb8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1feb2c: 0xde030020
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1feb30: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1feb34: 0x6463ffff
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 3) + (int64_t)4294967295);
    // 0x1feb38: 0x14600024
    WRITE64(ADD32(GPR_U32(ctx, 16), 32), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_1febcc(rdram, ctx, runtime); return;
    }
    // 0x1feb40: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1feb44: 0x16030004
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        goto label_1feb58;
    }
    // 0x1feb4c: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1feb50: 0x1040001f
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FEBD0; return;
    }
label_1feb58:
    // 0x1feb58: 0x1060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1feb8c;
    }
    // 0x1feb60: 0x10700008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        goto label_1feb84;
    }
    // 0x1feb68: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1feb74;
    }
label_1feb70:
    // 0x1feb70: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
label_1feb74:
    // 0x1feb74: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 24));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1feb8c;
    }
    // 0x1feb7c: 0x1450fffc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        goto label_1feb70;
    }
label_1feb84:
    // 0x1feb84: 0x54600003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        entry_1feb94(rdram, ctx, runtime); return;
    }
label_1feb8c:
    // 0x1feb8c: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1feb94);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1feb94
// Address: 0x1feb94 - 0x1febac

void entry_1feb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feb94: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1feb98: 0x10600004
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1febac(rdram, ctx, runtime); return;
    }
    // 0x1feba0: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1feba4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1febac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1febac
// Address: 0x1febac - 0x1febb4

void entry_1febac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1febac: 0xc080310
    SET_GPR_U32(ctx, 31, 0x1febb4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    fn___is_pointer(rdram, ctx, runtime); return;
}


// Function: entry_1febb4
// Address: 0x1febb4 - 0x1febc4

void entry_1febb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1febb4: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1febc4(rdram, ctx, runtime); return;
    }
    // 0x1febbc: 0xc07fa7e
    SET_GPR_U32(ctx, 31, 0x1febc4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    fn___eh_free(rdram, ctx, runtime); return;
}


// Function: entry_1febc4
// Address: 0x1febc4 - 0x1febcc

void entry_1febc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1febc4: 0xc07fa7e
    SET_GPR_U32(ctx, 31, 0x1febcc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___eh_free(rdram, ctx, runtime); return;
}


// Function: entry_1febcc
// Address: 0x1febcc - 0x1febe0

void entry_1febcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1febcc) {
        switch (ctx->pc) {
            case 0x1febd0: ctx->pc = 0; goto label_1febd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1febcc: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_1febd0:
    // 0x1febd0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1febd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1febdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1febe0; return;
}


// Function: fn___uncatch_exception
// Address: 0x1febe0 - 0x1febf0

void entry_1febf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1febf0: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1febf4: 0x14400003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1fec04(rdram, ctx, runtime); return;
    }
    // 0x1febfc: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fec04);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fec04
// Address: 0x1fec04 - 0x1fec10

void entry_1fec04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec04: 0xac400014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 0));
    // 0x1fec08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fec10
// Address: 0x1fec10 - 0x1fec3c

void FUN_001fec10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec10: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x1fec14: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x1fec18: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x1fec1c: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1fec20: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x1fec24: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1fec28: 0xffbf0070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 31));
    // 0x1fec2c: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x1fec30: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x1fec34: 0xc07f684
    SET_GPR_U32(ctx, 31, 0x1fec3c);
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    fn___get_eh_info(rdram, ctx, runtime); return;
}


// Function: entry_1fec3c
// Address: 0x1fec3c - 0x1fec60

void entry_1fec3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fec3c) {
        switch (ctx->pc) {
            case 0x1fec50: ctx->pc = 0; goto label_1fec50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fec3c: 0x1a600010
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x1FEC80; return;
    }
    // 0x1fec44: 0x2a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1fec48: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1fec4c: 0x0
    // NOP
label_1fec50:
    // 0x1fec50: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fec54: 0x8e45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1fec58: 0xc0801de
    SET_GPR_U32(ctx, 31, 0x1fec60);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    fn___throw_type_match_rtti(rdram, ctx, runtime); return;
}


// Function: entry_1fec60
// Address: 0x1fec60 - 0x1fec70

void entry_1fec60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec60: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        entry_1fec78(rdram, ctx, runtime); return;
    }
    // 0x1fec68: 0xc07faf8
    SET_GPR_U32(ctx, 31, 0x1fec70);
    fn___uncatch_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fec70
// Address: 0x1fec70 - 0x1fec78

void entry_1fec70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec70: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fec78);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fec78
// Address: 0x1fec78 - 0x1fec88

void entry_1fec78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fec78) {
        switch (ctx->pc) {
            case 0x1fec80: ctx->pc = 0; goto label_1fec80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fec78: 0x1600fff5
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FEC50; return;
    }
label_1fec80:
    // 0x1fec80: 0xc07fa4e
    SET_GPR_U32(ctx, 31, 0x1fec88);
    FUN_001fe938(rdram, ctx, runtime); return;
}


// Function: entry_1fec88
// Address: 0x1fec88 - 0x1fec90

void entry_1fec88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec88: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fec90);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fec90
// Address: 0x1fec90 - 0x1fec98

void entry_1fec90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fec90: 0xc07fa66
    SET_GPR_U32(ctx, 31, 0x1fec98);
    fn___start_cp_handler(rdram, ctx, runtime); return;
}


// Function: entry_1fec98
// Address: 0x1fec98 - 0x1fecc8

void entry_1fec98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fec98) {
        switch (ctx->pc) {
            case 0x1fecb8: ctx->pc = 0; goto label_1fecb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fec98: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fec9c: 0x12540012
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x1FECE8; return;
    }
    // 0x1feca4: 0x1a600010
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x1FECE8; return;
    }
    // 0x1fecac: 0x2a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1fecb0: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1fecb4: 0x0
    // NOP
label_1fecb8:
    // 0x1fecb8: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1fecbc: 0x8e85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x1fecc0: 0xc0801de
    SET_GPR_U32(ctx, 31, 0x1fecc8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    fn___throw_type_match_rtti(rdram, ctx, runtime); return;
}


// Function: entry_1fecc8
// Address: 0x1fecc8 - 0x1fecd8

void entry_1fecc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fecc8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        entry_1fece0(rdram, ctx, runtime); return;
    }
    // 0x1fecd0: 0xc07faf8
    SET_GPR_U32(ctx, 31, 0x1fecd8);
    fn___uncatch_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fecd8
// Address: 0x1fecd8 - 0x1fece0

void entry_1fecd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fecd8: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fece0);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fece0
// Address: 0x1fece0 - 0x1fecf0

void entry_1fece0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fece0) {
        switch (ctx->pc) {
            case 0x1fece8: ctx->pc = 0; goto label_1fece8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fece0: 0x1600fff5
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FECB8; return;
    }
label_1fece8:
    // 0x1fece8: 0xc07fbdc
    SET_GPR_U32(ctx, 31, 0x1fecf0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    bad_exception_type_info_function(rdram, ctx, runtime); return;
}


// Function: entry_1fecf0
// Address: 0x1fecf0 - 0x1fed14

void entry_1fecf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fecf0) {
        switch (ctx->pc) {
            case 0x1fed00: ctx->pc = 0; goto label_1fed00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fecf0: 0x1a600025
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x1FED88; return;
    }
    // 0x1fecf8: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1fecfc: 0x0
    // NOP
label_1fed00:
    // 0x1fed00: 0x8e460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1fed04: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1fed08: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1fed0c: 0xc0801de
    SET_GPR_U32(ctx, 31, 0x1fed14);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    fn___throw_type_match_rtti(rdram, ctx, runtime); return;
}


// Function: entry_1fed14
// Address: 0x1fed14 - 0x1fed30

void entry_1fed14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed14: 0x10400018
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1fed78(rdram, ctx, runtime); return;
    }
    // 0x1fed1c: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x1fed20: 0x2451f0c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294963392));
    // 0x1fed24: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1fed28: 0xc07fa74
    SET_GPR_U32(ctx, 31, 0x1fed30);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    fn___eh_alloc(rdram, ctx, runtime); return;
}


// Function: entry_1fed30
// Address: 0x1fed30 - 0x1fed44

void entry_1fed30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fed30) {
        switch (ctx->pc) {
            case 0x1fed3c: ctx->pc = 0; goto label_1fed3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fed30: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fed34: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fed44(rdram, ctx, runtime); return;
    }
label_1fed3c:
    // 0x1fed3c: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fed44);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fed44
// Address: 0x1fed44 - 0x1fed5c

void entry_1fed44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed44: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1fed48: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1fed4c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fed50: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fed54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fed5c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fed5c
// Address: 0x1fed5c - 0x1fed70

void entry_1fed5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed5c: 0x3c060020
    SET_GPR_U32(ctx, 6, ((uint32_t)32 << 16));
    // 0x1fed60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fed64: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fed68: 0xc07faa2
    SET_GPR_U32(ctx, 31, 0x1fed70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294962984));
    fn___cp_push_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fed70
// Address: 0x1fed70 - 0x1fed78

void entry_1fed70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed70: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fed78);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fed78
// Address: 0x1fed78 - 0x1fed90

void entry_1fed78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fed78) {
        switch (ctx->pc) {
            case 0x1fed88: ctx->pc = 0; goto label_1fed88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fed78: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1fed7c: 0x213102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 19)));
    // 0x1fed80: 0x1440ffdf
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FED00; return;
    }
label_1fed88:
    // 0x1fed88: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fed90);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fed90
// Address: 0x1fed90 - 0x1fed98

void entry_1fed90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed90: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fed98);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fed98
// Address: 0x1fed98 - 0x1fedac

void entry_1fed98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fed98: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1fed9c: 0x1000ffe7
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FED3C; return;
    }
    // 0x1feda4: 0xc07fac6
    SET_GPR_U32(ctx, 31, 0x1fedac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___cp_pop_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fedac
// Address: 0x1fedac - 0x1fedc4

void entry_1fedac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fedac: 0x1000fff8
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fed90(rdram, ctx, runtime); return;
    }
    // 0x1fedb4: 0x1000ffb4
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fec88(rdram, ctx, runtime); return;
    }
    // 0x1fedbc: 0xc07fa3c
    SET_GPR_U32(ctx, 31, 0x1fedc4);
    terminate(rdram, ctx, runtime); return;
}


// Function: entry_1fedc4
// Address: 0x1fedc4 - 0x1fedf4

void entry_1fedc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fedc4: 0x0
    // NOP
    // 0x1fedc8: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1fedcc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fedd0: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x1fedd4: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1fedd8: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x1feddc: 0x2451f290
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294963856));
    // 0x1fede0: 0xffbf0040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 31));
    // 0x1fede4: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x1fede8: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x1fedec: 0xc07fa74
    SET_GPR_U32(ctx, 31, 0x1fedf4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    fn___eh_alloc(rdram, ctx, runtime); return;
}


// Function: entry_1fedf4
// Address: 0x1fedf4 - 0x1fee08

void entry_1fedf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fedf4) {
        switch (ctx->pc) {
            case 0x1fee00: ctx->pc = 0; goto label_1fee00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fedf4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fedf8: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fee08(rdram, ctx, runtime); return;
    }
label_1fee00:
    // 0x1fee00: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fee08);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fee08
// Address: 0x1fee08 - 0x1fee20

void entry_1fee08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fee08: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1fee0c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1fee10: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fee14: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fee18: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1fee20);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1fee20
// Address: 0x1fee20 - 0x1fee34

void entry_1fee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fee20: 0x3c060020
    SET_GPR_U32(ctx, 6, ((uint32_t)32 << 16));
    // 0x1fee24: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fee28: 0x24c60638
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1592));
    // 0x1fee2c: 0xc07faa2
    SET_GPR_U32(ctx, 31, 0x1fee34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___cp_push_exception(rdram, ctx, runtime); return;
}


// Function: entry_1fee34
// Address: 0x1fee34 - 0x1fee3c

void entry_1fee34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fee34: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fee3c);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fee3c
// Address: 0x1fee3c - 0x1fee74

void entry_1fee3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fee3c: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1fee40: 0x1000ffef
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FEE00; return;
    }
    // 0x1fee48: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1fee4c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fee50: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x1fee54: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1fee58: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x1fee5c: 0x2451f278
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294963832));
    // 0x1fee60: 0xffbf0040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 31));
    // 0x1fee64: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x1fee68: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x1fee6c: 0xc07fa74
    SET_GPR_U32(ctx, 31, 0x1fee74);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    fn___eh_alloc(rdram, ctx, runtime); return;
}


// Function: entry_1fee74
// Address: 0x1fee74 - 0x1fee88

void entry_1fee74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1fee74) {
        switch (ctx->pc) {
            case 0x1fee80: ctx->pc = 0; goto label_1fee80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1fee74: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1fee78: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1fee88(rdram, ctx, runtime); return;
    }
label_1fee80:
    // 0x1fee80: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1fee88);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1fee88
// Address: 0x1fee88 - 0x1feea0

void entry_1fee88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fee88: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1fee8c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1fee90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1fee94: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1fee98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1feea0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1feea0
// Address: 0x1feea0 - 0x1feeb4

void entry_1feea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feea0: 0x3c060020
    SET_GPR_U32(ctx, 6, ((uint32_t)32 << 16));
    // 0x1feea4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1feea8: 0x24c605a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1440));
    // 0x1feeac: 0xc07faa2
    SET_GPR_U32(ctx, 31, 0x1feeb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___cp_push_exception(rdram, ctx, runtime); return;
}


// Function: entry_1feeb4
// Address: 0x1feeb4 - 0x1feebc

void entry_1feeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feeb4: 0xc07f932
    SET_GPR_U32(ctx, 31, 0x1feebc);
    FUN_001fe4c8(rdram, ctx, runtime); return;
}


// Function: entry_1feebc
// Address: 0x1feebc - 0x1feed8

void entry_1feebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1feebc: 0x2642f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294963416));
    // 0x1feec0: 0x1000ffef
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FEE80; return;
    }
    // 0x1feec8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1feecc: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1feed0: 0xc07f684
    SET_GPR_U32(ctx, 31, 0x1feed8);
    fn___get_eh_info(rdram, ctx, runtime); return;
}


// Function: entry_1feed8
// Address: 0x1feed8 - 0x1fef00

void entry_1feed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1feed8) {
        switch (ctx->pc) {
            case 0x1feeec: ctx->pc = 0; goto label_1feeec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1feed8: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1feedc: 0x10400003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1feeec;
    }
    // 0x1feee4: 0x8c420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1feee8: 0x2c430001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 1));
label_1feeec:
    // 0x1feeec: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1feef0: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1feef4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1feefc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fef00; return;
}


// Function: exception__what
// Address: 0x1fef00 - 0x1fef18

void entry_1fef18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fef18: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1fef1c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fef20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fef28
// Address: 0x1fef28 - 0x1fef4c

void FUN_001fef28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fef28: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fef2c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fef30: 0x2442f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963416));
    // 0x1fef34: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fef38: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x1fef3c: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1fef4c(rdram, ctx, runtime); return;
    }
    // 0x1fef44: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x1fef4c);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_1fef4c
// Address: 0x1fef4c - 0x1fef70

void entry_1fef4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fef4c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fef50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fef58: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1fef5c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1fef60: 0x2463f0c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963392));
    // 0x1fef64: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1fef6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1fef70; return;
}


// Function: bad_exception_type_info_function
// Address: 0x1fef70 - 0x1fef94

void entry_1fef94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fef94: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1fef98: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x1fef9c: 0x24a5f0f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963440));
    // 0x1fefa0: 0x24c6b318
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947608));
    // 0x1fefa4: 0xc080046
    SET_GPR_U32(ctx, 31, 0x1fefac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_1fefac
// Address: 0x1fefac - 0x1fefc0

void entry_1fefac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fefac: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1fefb0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1fefb4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fefb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001fefc0
// Address: 0x1fefc0 - 0x1fefe4

void FUN_001fefc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fefc0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1fefc4: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1fefc8: 0x2442f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963416));
    // 0x1fefcc: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x1fefd0: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x1fefd4: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1fefe4(rdram, ctx, runtime); return;
    }
    // 0x1fefdc: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x1fefe4);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_1fefe4
// Address: 0x1fefe4 - 0x1ff008

void entry_1fefe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1fefe4: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1fefe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1feff0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1feff4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1feff8: 0x2463f0d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963416));
    // 0x1feffc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ff004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ff008; return;
}


// Function: exception_type_info_function
// Address: 0x1ff008 - 0x1ff034

void entry_1ff034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff034: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ff038: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ff03c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ff040: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: decode_uleb128
// Address: 0x1ff048 - 0x1ff090

void entry_1ff20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff20c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ff210: 0xc07ff96
    SET_GPR_U32(ctx, 31, 0x1ff218);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fde_split(rdram, ctx, runtime); return;
}


// Function: entry_1ff218
// Address: 0x1ff218 - 0x1ff234

void entry_1ff218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff218: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1ff21c: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1ff220: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ff224: 0x50500003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        entry_1ff234(rdram, ctx, runtime); return;
    }
    // 0x1ff22c: 0xc080534
    SET_GPR_U32(ctx, 31, 0x1ff234);
    abort(rdram, ctx, runtime); return;
}


// Function: entry_1ff234
// Address: 0x1ff234 - 0x1ff420

void entry_1ff234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff234) {
        switch (ctx->pc) {
            case 0x1ff248: ctx->pc = 0; goto label_1ff248;
            case 0x1ff258: ctx->pc = 0; goto label_1ff258;
            case 0x1ff2b0: ctx->pc = 0; goto label_1ff2b0;
            case 0x1ff2b4: ctx->pc = 0; goto label_1ff2b4;
            case 0x1ff2b8: ctx->pc = 0; goto label_1ff2b8;
            case 0x1ff2e8: ctx->pc = 0; goto label_1ff2e8;
            case 0x1ff2ec: ctx->pc = 0; goto label_1ff2ec;
            case 0x1ff2fc: ctx->pc = 0; goto label_1ff2fc;
            case 0x1ff30c: ctx->pc = 0; goto label_1ff30c;
            case 0x1ff310: ctx->pc = 0; goto label_1ff310;
            case 0x1ff328: ctx->pc = 0; goto label_1ff328;
            case 0x1ff358: ctx->pc = 0; goto label_1ff358;
            case 0x1ff3b0: ctx->pc = 0; goto label_1ff3b0;
            case 0x1ff3b4: ctx->pc = 0; goto label_1ff3b4;
            case 0x1ff3b8: ctx->pc = 0; goto label_1ff3b8;
            case 0x1ff3e8: ctx->pc = 0; goto label_1ff3e8;
            case 0x1ff408: ctx->pc = 0; goto label_1ff408;
            case 0x1ff40c: ctx->pc = 0; goto label_1ff40c;
            case 0x1ff418: ctx->pc = 0; goto label_1ff418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff234: 0x8e2b0008
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1ff238: 0x11a00034
    SET_GPR_U64(ctx, 14, GPR_U64(ctx, 13) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 13) == GPR_U32(ctx, 0)) {
        goto label_1ff30c;
    }
    // 0x1ff240: 0x2daf0002
    SET_GPR_U32(ctx, 15, SLTU32(GPR_U32(ctx, 13), 2));
    // 0x1ff244: 0x25c4ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 14), 4294967295));
label_1ff248:
    // 0x1ff248: 0x45040
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 4), 1));
    // 0x1ff24c: 0x10000027
    SET_GPR_U64(ctx, 14, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff2ec;
    }
    // 0x1ff254: 0x0
    // NOP
label_1ff258:
    // 0x1ff258: 0x246c0002
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 3), 2));
    // 0x1ff25c: 0x18d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 13)));
    // 0x1ff260: 0x10400013
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 4), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ff2b0;
    }
    // 0x1ff268: 0xeb4021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
    // 0x1ff26c: 0x8d090008
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x1ff270: 0x8d030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    // 0x1ff274: 0x8d260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 9), 8)));
    // 0x1ff278: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ff27c: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1ff280: 0x1840000c
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff2b4;
    }
    // 0x1ff288: 0xab1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 11)));
    // 0x1ff28c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ff290: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ff294: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1ff298: 0x18400007
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff2b8;
    }
    // 0x1ff2a0: 0xac690000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 9));
    // 0x1ff2a4: 0xad040008
    WRITE32(ADD32(GPR_U32(ctx, 8), 8), GPR_U32(ctx, 4));
    // 0x1ff2a8: 0x1000000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff2e8;
    }
label_1ff2b0:
    // 0x1ff2b0: 0x42880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 2));
label_1ff2b4:
    // 0x1ff2b4: 0xeb3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
label_1ff2b8:
    // 0x1ff2b8: 0xab3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 11)));
    // 0x1ff2bc: 0x8ce40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x1ff2c0: 0x8cc50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ff2c4: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ff2c8: 0x8ca30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1ff2cc: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ff2d0: 0x1840000a
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff2fc;
    }
    // 0x1ff2d8: 0xacc40000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 4));
    // 0x1ff2dc: 0xace50004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 5));
    // 0x1ff2e0: 0x25440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 10), 1));
    // 0x1ff2e4: 0x0
    // NOP
label_1ff2e8:
    // 0x1ff2e8: 0x45040
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 4), 1));
label_1ff2ec:
    // 0x1ff2ec: 0x25420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 10), 1));
    // 0x1ff2f0: 0x4d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 13)));
    // 0x1ff2f4: 0x1440ffd8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ff258;
    }
label_1ff2fc:
    // 0x1ff2fc: 0x15c0ffd2
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 14), 4294967295));
    if (GPR_U32(ctx, 14) != GPR_U32(ctx, 0)) {
        goto label_1ff248;
    }
    // 0x1ff304: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff310;
    }
label_1ff30c:
    // 0x1ff30c: 0x240f0001
    SET_GPR_S32(ctx, 15, ADD32(GPR_U32(ctx, 0), 1));
label_1ff310:
    // 0x1ff310: 0x15e00041
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 15) != GPR_U32(ctx, 0)) {
        goto label_1ff418;
    }
    // 0x1ff318: 0xd1080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 13), 2));
    // 0x1ff31c: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ff320: 0x4b7021
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x1ff324: 0x25cefffc
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 4294967292));
label_1ff328:
    // 0x1ff328: 0x25adffff
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 13), 4294967295));
    // 0x1ff32c: 0x8d620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 0)));
    // 0x1ff330: 0x8dc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x1ff334: 0xad630000
    WRITE32(ADD32(GPR_U32(ctx, 11), 0), GPR_U32(ctx, 3));
    // 0x1ff338: 0xadc20000
    WRITE32(ADD32(GPR_U32(ctx, 14), 0), GPR_U32(ctx, 2));
    // 0x1ff33c: 0x20d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 13)));
    // 0x1ff340: 0x10400031
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ff408;
    }
    // 0x1ff348: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ff34c: 0x2daf0002
    SET_GPR_U32(ctx, 15, SLTU32(GPR_U32(ctx, 13), 2));
    // 0x1ff350: 0x254c0002
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 10), 2));
    // 0x1ff354: 0x0
    // NOP
label_1ff358:
    // 0x1ff358: 0x18d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 12), GPR_U32(ctx, 13)));
    // 0x1ff35c: 0x10400014
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 4), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ff3b0;
    }
    // 0x1ff364: 0xeb4021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
    // 0x1ff368: 0x8d090008
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x1ff36c: 0x8d030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    // 0x1ff370: 0x8d260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 9), 8)));
    // 0x1ff374: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ff378: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1ff37c: 0x1840000d
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff3b4;
    }
    // 0x1ff384: 0xab1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 11)));
    // 0x1ff388: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ff38c: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ff390: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1ff394: 0x18400008
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff3b8;
    }
    // 0x1ff39c: 0xac690000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 9));
    // 0x1ff3a0: 0xad040008
    WRITE32(ADD32(GPR_U32(ctx, 8), 8), GPR_U32(ctx, 4));
    // 0x1ff3a4: 0x10000010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff3e8;
    }
    // 0x1ff3ac: 0x0
    // NOP
label_1ff3b0:
    // 0x1ff3b0: 0x42880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 2));
label_1ff3b4:
    // 0x1ff3b4: 0xeb3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
label_1ff3b8:
    // 0x1ff3b8: 0xab3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 11)));
    // 0x1ff3bc: 0x8ce40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x1ff3c0: 0x8cc50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ff3c4: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ff3c8: 0x8ca30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1ff3cc: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ff3d0: 0x1840000e
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ff40c;
    }
    // 0x1ff3d8: 0xacc40000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 4));
    // 0x1ff3dc: 0xace50004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 5));
    // 0x1ff3e0: 0x25440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 10), 1));
    // 0x1ff3e4: 0x0
    // NOP
label_1ff3e8:
    // 0x1ff3e8: 0x41840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 1));
    // 0x1ff3ec: 0x60502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1ff3f0: 0x25420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 10), 1));
    // 0x1ff3f4: 0x4d102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 13)));
    // 0x1ff3f8: 0x1440ffd7
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 10), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ff358;
    }
    // 0x1ff400: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff40c;
    }
label_1ff408:
    // 0x1ff408: 0x2daf0002
    SET_GPR_U32(ctx, 15, SLTU32(GPR_U32(ctx, 13), 2));
label_1ff40c:
    // 0x1ff40c: 0x11e0ffc6
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 4294967292));
    if (GPR_U32(ctx, 15) == GPR_U32(ctx, 0)) {
        goto label_1ff328;
    }
    // 0x1ff414: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1ff418:
    // 0x1ff418: 0xc07fc38
    SET_GPR_U32(ctx, 31, 0x1ff420);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fde_merge(rdram, ctx, runtime); return;
}


// Function: entry_1ff420
// Address: 0x1ff420 - 0x1ff428

void entry_1ff420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff420: 0xc0635d4
    SET_GPR_U32(ctx, 31, 0x1ff428);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    free(rdram, ctx, runtime); return;
}


// Function: entry_1ff428
// Address: 0x1ff428 - 0x1ff448

void entry_1ff428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff428: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ff42c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ff430: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ff434: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ff438: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ff43c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ff444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ff448; return;
}


// Function: count_fdes
// Address: 0x1ff448 - 0x1ff490

void entry_1ff55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff55c) {
        switch (ctx->pc) {
            case 0x1ff570: ctx->pc = 0; goto label_1ff570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff55c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff560: 0x1460fffb
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FF550; return;
    }
    // 0x1ff568: 0x10000005
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 20), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FF580; return;
    }
label_1ff570:
    // 0x1ff570: 0xc07fd12
    SET_GPR_U32(ctx, 31, 0x1ff578);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    count_fdes(rdram, ctx, runtime); return;
}


// Function: entry_1ff578
// Address: 0x1ff578 - 0x1ff58c

void entry_1ff578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff578) {
        switch (ctx->pc) {
            case 0x1ff57c: ctx->pc = 0; goto label_1ff57c;
            case 0x1ff580: ctx->pc = 0; goto label_1ff580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff578: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1ff57c:
    // 0x1ff57c: 0x148080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 20), 2));
label_1ff580:
    // 0x1ff580: 0xae740010
    WRITE32(ADD32(GPR_U32(ctx, 19), 16), GPR_U32(ctx, 20));
    // 0x1ff584: 0xc0635d0
    SET_GPR_U32(ctx, 31, 0x1ff58c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    malloc(rdram, ctx, runtime); return;
}


// Function: entry_1ff58c
// Address: 0x1ff58c - 0x1ff598

void entry_1ff58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff58c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ff590: 0xc0635d0
    SET_GPR_U32(ctx, 31, 0x1ff598);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    malloc(rdram, ctx, runtime); return;
}


// Function: entry_1ff598
// Address: 0x1ff598 - 0x1ff5e8

void entry_1ff598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff598) {
        switch (ctx->pc) {
            case 0x1ff5d8: ctx->pc = 0; goto label_1ff5d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff598: 0x3c03ffff
    SET_GPR_U32(ctx, 3, ((uint32_t)65535 << 16));
    // 0x1ff59c: 0x8e64000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1ff5a0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1ff5a4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1ff5a8: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x1ff5ac: 0xafa00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    // 0x1ff5b0: 0xafa0000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 0));
    // 0x1ff5b4: 0x10800012
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FF600; return;
    }
    // 0x1ff5bc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ff5c0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff5c4: 0x10400013
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ff614(rdram, ctx, runtime); return;
    }
    // 0x1ff5cc: 0x27b10014
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 20));
    // 0x1ff5d0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff5d4: 0x0
    // NOP
label_1ff5d8:
    // 0x1ff5d8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ff5dc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ff5e0: 0xc07fd24
    SET_GPR_U32(ctx, 31, 0x1ff5e8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    add_fdes(rdram, ctx, runtime); return;
}


// Function: entry_1ff5e8
// Address: 0x1ff5e8 - 0x1ff614

void entry_1ff5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff5e8) {
        switch (ctx->pc) {
            case 0x1ff600: ctx->pc = 0; goto label_1ff600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff5e8: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1ff5ec: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff5f0: 0x5440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1FF5D8; return;
    }
    // 0x1ff5f8: 0x10000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FF618; return;
    }
label_1ff600:
    // 0x1ff600: 0x8e640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1ff604: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ff608: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ff60c: 0xc07fd24
    SET_GPR_U32(ctx, 31, 0x1ff614);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 20));
    add_fdes(rdram, ctx, runtime); return;
}


// Function: entry_1ff614
// Address: 0x1ff614 - 0x1ff620

void entry_1ff614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff614) {
        switch (ctx->pc) {
            case 0x1ff618: ctx->pc = 0; goto label_1ff618;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff614: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1ff618:
    // 0x1ff618: 0xc07fc78
    SET_GPR_U32(ctx, 31, 0x1ff620);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    end_fde_sort(rdram, ctx, runtime); return;
}


// Function: entry_1ff620
// Address: 0x1ff620 - 0x1ff658

void entry_1ff620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff620: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ff624: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1ff628: 0xae62000c
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 2));
    // 0x1ff62c: 0xae630004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 3));
    // 0x1ff630: 0xae640000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 4));
    // 0x1ff634: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ff638: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ff63c: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ff640: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ff644: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ff648: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ff64c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ff654: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ff658; return;
}


// Function: find_fde
// Address: 0x1ff658 - 0x1ff694

void entry_1ff694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff694) {
        switch (ctx->pc) {
            case 0x1ff69c: ctx->pc = 0; goto label_1ff69c;
            case 0x1ff6c4: ctx->pc = 0; goto label_1ff6c4;
            case 0x1ff6cc: ctx->pc = 0; goto label_1ff6cc;
            case 0x1ff6e0: ctx->pc = 0; goto label_1ff6e0;
            case 0x1ff708: ctx->pc = 0; goto label_1ff708;
            case 0x1ff718: ctx->pc = 0; goto label_1ff718;
            case 0x1ff724: ctx->pc = 0; goto label_1ff724;
            case 0x1ff728: ctx->pc = 0; goto label_1ff728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff694: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff698: 0x222102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
label_1ff69c:
    // 0x1ff69c: 0x5440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1FF678; return;
    }
    // 0x1ff6a4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ff6a8: 0x222102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1ff6ac: 0x5040fff2
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1FF678; return;
    }
    // 0x1ff6b4: 0x56000005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 16)));
        goto label_1ff6cc;
    }
    // 0x1ff6bc: 0x1000001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff728;
    }
label_1ff6c4:
    // 0x1ff6c4: 0x10000018
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff728;
    }
label_1ff6cc:
    // 0x1ff6cc: 0x10e00015
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_1ff724;
    }
    // 0x1ff6d4: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ff6d8: 0x1071021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 7)));
    // 0x1ff6dc: 0x0
    // NOP
label_1ff6e0:
    // 0x1ff6e0: 0x23042
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 2), 1));
    // 0x1ff6e4: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1ff6e8: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1ff6ec: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ff6f0: 0x8c650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ff6f4: 0x225102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 5)));
    // 0x1ff6f8: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
        goto label_1ff708;
    }
    // 0x1ff700: 0x10000005
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ff718;
    }
label_1ff708:
    // 0x1ff708: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1ff70c: 0x222102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1ff710: 0x1440ffec
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ff6c4;
    }
label_1ff718:
    // 0x1ff718: 0x107102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), GPR_U32(ctx, 7)));
    // 0x1ff71c: 0x1440fff0
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 7)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ff6e0;
    }
label_1ff724:
    // 0x1ff724: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ff728:
    // 0x1ff728: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ff72c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ff730: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ff734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ff73c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ff740; return;
}


// Function: extract_cie_info
// Address: 0x1ff740 - 0x1ff77c

void entry_1ff77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff77c: 0x1040000a
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FF7A8; return;
    }
    // 0x1ff784: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ff788: 0xc07d9ce
    SET_GPR_U32(ctx, 31, 0x1ff790);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4294963480));
    strcmp(rdram, ctx, runtime); return;
}


// Function: entry_1ff790
// Address: 0x1ff790 - 0x1ff7b0

void entry_1ff790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff790) {
        switch (ctx->pc) {
            case 0x1ff7a8: ctx->pc = 0; goto label_1ff7a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff790: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 122));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ff7a8;
    }
    // 0x1ff798: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ff79c: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ff7a0: 0x14640022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1FF82C; return;
    }
label_1ff7a8:
    // 0x1ff7a8: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1ff7b0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1ff7b0
// Address: 0x1ff7b0 - 0x1ff7c4

void entry_1ff7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff7b0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ff7b4: 0x2605f118
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4294963480));
    // 0x1ff7b8: 0x829021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1ff7bc: 0xc07d9ce
    SET_GPR_U32(ctx, 31, 0x1ff7c4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1));
    strcmp(rdram, ctx, runtime); return;
}


// Function: entry_1ff7c4
// Address: 0x1ff7c4 - 0x1ff7e8

void entry_1ff7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff7c4) {
        switch (ctx->pc) {
            case 0x1ff7dc: ctx->pc = 0; goto label_1ff7dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff7c4: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
        goto label_1ff7dc;
    }
    // 0x1ff7cc: 0x8a020003
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1ff7d0: 0x9a020000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1ff7d4: 0x26500005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 5));
    // 0x1ff7d8: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
label_1ff7dc:
    // 0x1ff7dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ff7e0: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff7e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff7e8
// Address: 0x1ff7e8 - 0x1ff7f4

void entry_1ff7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff7e8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff7ec: 0xc07fc24
    SET_GPR_U32(ctx, 31, 0x1ff7f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 12));
    decode_sleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff7f4
// Address: 0x1ff7f4 - 0x1ff820

void entry_1ff7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff7f4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff7f8: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ff7fc: 0x92030000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ff800: 0x2404007a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 122));
    // 0x1ff804: 0xae230010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 3));
    // 0x1ff808: 0x80a20000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ff80c: 0x14440006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1FF828; return;
    }
    // 0x1ff814: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ff818: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff820);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff820
// Address: 0x1ff820 - 0x1ff848

void entry_1ff820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff820) {
        switch (ctx->pc) {
            case 0x1ff828: ctx->pc = 0; goto label_1ff828;
            case 0x1ff82c: ctx->pc = 0; goto label_1ff82c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff820: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ff824: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_1ff828:
    // 0x1ff828: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ff82c:
    // 0x1ff82c: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ff830: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ff834: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ff838: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ff83c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ff844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ff848; return;
}


// Function: execute_cfa_insn
// Address: 0x1ff848 - 0x1ff958

void entry_1ff958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ff958) {
        switch (ctx->pc) {
            case 0x1ff95c: ctx->pc = 0; goto label_1ff95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ff958: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1ff95c:
    // 0x1ff95c: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff964);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff964
// Address: 0x1ff964 - 0x1ff9a8

void entry_1ff964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff964: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ff968: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff96c: 0x8e45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1ff970: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ff974: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ff978: 0x852018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1ff97c: 0x218c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1ff980: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1ff984: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1ff988: 0xa046029c
    WRITE8(ADD32(GPR_U32(ctx, 2), 668), (uint8_t)GPR_U32(ctx, 6));
    // 0x1ff98c: 0xafa40000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 4));
    // 0x1ff990: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ff994: 0x1000008b
    WRITE64(ADD32(GPR_U32(ctx, 3), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ff99c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ff9a0: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff9a8);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff9a8
// Address: 0x1ff9a8 - 0x1ff9c8

void entry_1ff9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff9a8: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ff9ac: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff9b0: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1ff9b4: 0x10000083
    WRITE8(ADD32(GPR_U32(ctx, 3), 668), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ff9bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ff9c0: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff9c8);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff9c8
// Address: 0x1ff9c8 - 0x1ff9d4

void entry_1ff9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff9c8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff9cc: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ff9d4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 8));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ff9d4
// Address: 0x1ff9d4 - 0x1ffa10

void entry_1ff9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ff9d4: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ff9d8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ff9dc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ff9e0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ff9e4: 0x410c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 3));
    // 0x1ff9e8: 0x2242021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x1ff9ec: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1ff9f0: 0xa085029c
    WRITE8(ADD32(GPR_U32(ctx, 4), 668), (uint8_t)GPR_U32(ctx, 5));
    // 0x1ff9f4: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1ff9f8: 0x3183e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) >> (32 + 0));
    // 0x1ff9fc: 0x10000071
    WRITE64(ADD32(GPR_U32(ctx, 2), 24), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ffa04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ffa08: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffa10);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffa10
// Address: 0x1ffa10 - 0x1ffa1c

void entry_1ffa10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ffa10: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffa14: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffa1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffa1c
// Address: 0x1ffa1c - 0x1ffa40

void entry_1ffa1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ffa1c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffa20: 0x97a30004
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ffa24: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ffa28: 0xa6230298
    WRITE16(ADD32(GPR_U32(ctx, 17), 664), (uint16_t)GPR_U32(ctx, 3));
    // 0x1ffa2c: 0x10000065
    WRITE64(ADD32(GPR_U32(ctx, 17), 8), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ffa34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ffa38: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffa40);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffa40
// Address: 0x1ffa40 - 0x1ffa5c

void entry_1ffa40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ffa40: 0x97a30004
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ffa44: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffa48: 0x1000005e
    WRITE16(ADD32(GPR_U32(ctx, 17), 664), (uint16_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ffa50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ffa54: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffa5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffa5c
// Address: 0x1ffa5c - 0x1ffa74

void entry_1ffa5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ffa5c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ffa60: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffa64: 0x10000057
    WRITE64(ADD32(GPR_U32(ctx, 17), 8), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ffa6c: 0xc0635d0
    SET_GPR_U32(ctx, 31, 0x1ffa74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 760));
    malloc(rdram, ctx, runtime); return;
}


// Function: entry_1ffa74
// Address: 0x1ffa74 - 0x1ffb34

void entry_1ffa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffa74) {
        switch (ctx->pc) {
            case 0x1ffa80: ctx->pc = 0; goto label_1ffa80;
            case 0x1ffae4: ctx->pc = 0; goto label_1ffae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffa74: 0x262502e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 736));
    // 0x1ffa78: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffa7c: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1ffa80:
    // 0x1ffa80: 0xdc660000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ffa84: 0xdc670008
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ffa88: 0xdc680010
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1ffa8c: 0xdc690018
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1ffa90: 0xfc860000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 6));
    // 0x1ffa94: 0xfc870008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 7));
    // 0x1ffa98: 0xfc880010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 8));
    // 0x1ffa9c: 0xfc890018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 9));
    // 0x1ffaa0: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1ffaa4: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1ffaa8: 0x0
    // NOP
    // 0x1ffaac: 0x1465fff4
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_1ffa80;
    }
    // 0x1ffab4: 0xdc650000
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ffab8: 0xdc660008
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ffabc: 0xdc670010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1ffac0: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x1ffac4: 0xfc860008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 6));
    // 0x1ffac8: 0xfc870010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 7));
    // 0x1ffacc: 0x1000003d
    WRITE32(ADD32(GPR_U32(ctx, 17), 752), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
    // 0x1ffad4: 0x8e2402f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 752)));
    // 0x1ffad8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ffadc: 0x248202e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 736));
    // 0x1ffae0: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1ffae4:
    // 0x1ffae4: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ffae8: 0xdcc30008
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1ffaec: 0xdcc70010
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x1ffaf0: 0xdcc80018
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1ffaf4: 0xfca90000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 9));
    // 0x1ffaf8: 0xfca30008
    WRITE64(ADD32(GPR_U32(ctx, 5), 8), GPR_U64(ctx, 3));
    // 0x1ffafc: 0xfca70010
    WRITE64(ADD32(GPR_U32(ctx, 5), 16), GPR_U64(ctx, 7));
    // 0x1ffb00: 0xfca80018
    WRITE64(ADD32(GPR_U32(ctx, 5), 24), GPR_U64(ctx, 8));
    // 0x1ffb04: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x1ffb08: 0x24a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    // 0x1ffb0c: 0x0
    // NOP
    // 0x1ffb10: 0x14c2fff4
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1ffae4;
    }
    // 0x1ffb18: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ffb1c: 0xdcc20008
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1ffb20: 0xdcc30010
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x1ffb24: 0xfca90000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 9));
    // 0x1ffb28: 0xfca20008
    WRITE64(ADD32(GPR_U32(ctx, 5), 8), GPR_U64(ctx, 2));
    // 0x1ffb2c: 0xc0635d4
    SET_GPR_U32(ctx, 31, 0x1ffb34);
    WRITE64(ADD32(GPR_U32(ctx, 5), 16), GPR_U64(ctx, 3));
    free(rdram, ctx, runtime); return;
}


// Function: entry_1ffb34
// Address: 0x1ffb34 - 0x1ffbac

void entry_1ffb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffb34) {
        switch (ctx->pc) {
            case 0x1ffb58: ctx->pc = 0; goto label_1ffb58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffb34: 0x10000024
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFBC8; return;
    }
    // 0x1ffb3c: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ffb40: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ffb44: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1ffb48: 0x24070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ffb4c: 0x2629029c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 668));
    // 0x1ffb50: 0x26280018
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 24));
    // 0x1ffb54: 0x0
    // NOP
label_1ffb58:
    // 0x1ffb58: 0x2482fff0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294967280));
    // 0x1ffb5c: 0x24860001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1ffb60: 0x1272821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 7)));
    // 0x1ffb64: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1ffb68: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ffb6c: 0x420c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    // 0x1ffb70: 0xa0a30000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1ffb74: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1ffb78: 0x1042021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x1ffb7c: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x1ffb80: 0xafa60004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 6));
    // 0x1ffb84: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ffb88: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x1ffb8c: 0x2ce20020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), 32));
    // 0x1ffb90: 0x1440fff1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ffb58;
    }
    // 0x1ffb98: 0x1000000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFBC8; return;
    }
    // 0x1ffba0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ffba4: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffbac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffbac
// Address: 0x1ffbac - 0x1ffbc4

void entry_1ffbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffbac) {
        switch (ctx->pc) {
            case 0x1ffbbc: ctx->pc = 0; goto label_1ffbbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffbac: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ffbb0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffbb4: 0x10000003
    WRITE64(ADD32(GPR_U32(ctx, 17), 16), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ffbc4(rdram, ctx, runtime); return;
    }
label_1ffbbc:
    // 0x1ffbbc: 0xc080534
    SET_GPR_U32(ctx, 31, 0x1ffbc4);
    abort(rdram, ctx, runtime); return;
}


// Function: entry_1ffbc4
// Address: 0x1ffbc4 - 0x1ffc08

void entry_1ffbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffbc4) {
        switch (ctx->pc) {
            case 0x1ffbc8: ctx->pc = 0; goto label_1ffbc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffbc4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ffbc8:
    // 0x1ffbc8: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ffbcc: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ffbd0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ffbd4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ffbd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ffbe0: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x1ffbe4: 0x8c62a7b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294944696)));
    // 0x1ffbe8: 0xaca4000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 4));
    // 0x1ffbec: 0xaca20014
    WRITE32(ADD32(GPR_U32(ctx, 5), 20), GPR_U32(ctx, 2));
    // 0x1ffbf0: 0xac65a7b8
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294944696), GPR_U32(ctx, 5));
    // 0x1ffbf4: 0xaca40008
    WRITE32(ADD32(GPR_U32(ctx, 5), 8), GPR_U32(ctx, 4));
    // 0x1ffbf8: 0xaca00004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 0));
    // 0x1ffbfc: 0xaca00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 0));
    // 0x1ffc00: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 16), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___deregister_frame_info
// Address: 0x1ffc08 - 0x1ffc4c

void entry_1ffc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffc4c) {
        switch (ctx->pc) {
            case 0x1ffc54: ctx->pc = 0; goto label_1ffc54;
            case 0x1ffc5c: ctx->pc = 0; goto label_1ffc5c;
            case 0x1ffc6c: ctx->pc = 0; goto label_1ffc6c;
            case 0x1ffc70: ctx->pc = 0; goto label_1ffc70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffc4c: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ffc70;
    }
label_1ffc54:
    // 0x1ffc54: 0x1440fff4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFC28; return;
    }
label_1ffc5c:
    // 0x1ffc5c: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ffc60: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ffc64: 0x8080534
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    abort(rdram, ctx, runtime); return;
label_1ffc6c:
    // 0x1ffc6c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ffc70:
    // 0x1ffc70: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ffc74: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ffc78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___frame_state_for
// Address: 0x1ffc80 - 0x1ffcb4

void entry_1ffcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ffcb4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffcb8: 0x12400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFCD4; return;
    }
    // 0x1ffcc0: 0xc07fdd0
    SET_GPR_U32(ctx, 31, 0x1ffcc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    extract_cie_info(rdram, ctx, runtime); return;
}


// Function: entry_1ffcc8
// Address: 0x1ffcc8 - 0x1ffcec

void entry_1ffcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffcc8) {
        switch (ctx->pc) {
            case 0x1ffcd4: ctx->pc = 0; goto label_1ffcd4;
            case 0x1ffcdc: ctx->pc = 0; goto label_1ffcdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffcc8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffccc: 0x16000003
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1ffcdc;
    }
label_1ffcd4:
    // 0x1ffcd4: 0x10000055
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFE2C; return;
    }
label_1ffcdc:
    // 0x1ffcdc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ffce0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ffce4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1ffcec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 760));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1ffcec
// Address: 0x1ffcec - 0x1ffd38

void entry_1ffcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffcec) {
        switch (ctx->pc) {
            case 0x1ffd28: ctx->pc = 0; goto label_1ffd28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffcec: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ffcf0: 0x97a40010
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ffcf4: 0x2463fffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x1ffcf8: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ffcfc: 0xa7a402ba
    WRITE16(ADD32(GPR_U32(ctx, 29), 698), (uint16_t)GPR_U32(ctx, 4));
    // 0x1ffd00: 0x2431823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1ffd04: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ffd08: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ffd0c: 0x24710004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1ffd10: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1ffd14: 0x1040000e
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFD50; return;
    }
    // 0x1ffd1c: 0x26530010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1ffd20: 0x27b50300
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 768));
    // 0x1ffd24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ffd28:
    // 0x1ffd28: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ffd2c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ffd30: 0xc07fe12
    SET_GPR_U32(ctx, 31, 0x1ffd38);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    execute_cfa_insn(rdram, ctx, runtime); return;
}


// Function: entry_1ffd38
// Address: 0x1ffd38 - 0x1ffd78

void entry_1ffd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffd38) {
        switch (ctx->pc) {
            case 0x1ffd50: ctx->pc = 0; goto label_1ffd50;
            case 0x1ffd5c: ctx->pc = 0; goto label_1ffd5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffd38: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffd3c: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1ffd40: 0x1440fff9
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFD28; return;
    }
    // 0x1ffd48: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ffd5c;
    }
label_1ffd50:
    // 0x1ffd50: 0x26530010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1ffd54: 0x27b50300
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 768));
    // 0x1ffd58: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_1ffd5c:
    // 0x1ffd5c: 0x2403007a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 122));
    // 0x1ffd60: 0x80820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ffd64: 0x14430006
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1FFD80; return;
    }
    // 0x1ffd6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ffd70: 0xc07fc12
    SET_GPR_U32(ctx, 31, 0x1ffd78);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 800));
    decode_uleb128(rdram, ctx, runtime); return;
}


// Function: entry_1ffd78
// Address: 0x1ffd78 - 0x1ffdc0

void entry_1ffd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffd78) {
        switch (ctx->pc) {
            case 0x1ffd80: ctx->pc = 0; goto label_1ffd80;
            case 0x1ffdb0: ctx->pc = 0; goto label_1ffdb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffd78: 0x8fa30320
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 800)));
    // 0x1ffd7c: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_1ffd80:
    // 0x1ffd80: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ffd84: 0x8e450008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1ffd88: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1ffd8c: 0x24510004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1ffd90: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1ffd94: 0x10400011
    WRITE32(ADD32(GPR_U32(ctx, 29), 804), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFDDC; return;
    }
    // 0x1ffd9c: 0x2c5102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 5)));
    // 0x1ffda0: 0x1440000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFDE0; return;
    }
    // 0x1ffda8: 0x27b20324
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 804));
    // 0x1ffdac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ffdb0:
    // 0x1ffdb0: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ffdb4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ffdb8: 0xc07fe12
    SET_GPR_U32(ctx, 31, 0x1ffdc0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    execute_cfa_insn(rdram, ctx, runtime); return;
}


// Function: entry_1ffdc0
// Address: 0x1ffdc0 - 0x1ffe58

void entry_1ffdc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ffdc0) {
        switch (ctx->pc) {
            case 0x1ffddc: ctx->pc = 0; goto label_1ffddc;
            case 0x1ffde0: ctx->pc = 0; goto label_1ffde0;
            case 0x1ffde4: ctx->pc = 0; goto label_1ffde4;
            case 0x1ffe2c: ctx->pc = 0; goto label_1ffe2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ffdc0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ffdc4: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1ffdc8: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 804)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ffddc;
    }
    // 0x1ffdd0: 0x2c2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x1ffdd4: 0x1040fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1FFDB0; return;
    }
label_1ffddc:
    // 0x1ffddc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1ffde0:
    // 0x1ffde0: 0x2e0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_1ffde4:
    // 0x1ffde4: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ffde8: 0xdc850008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ffdec: 0xdc860010
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1ffdf0: 0xdc870018
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1ffdf4: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x1ffdf8: 0xfc450008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 5));
    // 0x1ffdfc: 0xfc460010
    WRITE64(ADD32(GPR_U32(ctx, 2), 16), GPR_U64(ctx, 6));
    // 0x1ffe00: 0xfc470018
    WRITE64(ADD32(GPR_U32(ctx, 2), 24), GPR_U64(ctx, 7));
    // 0x1ffe04: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1ffe08: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1ffe0c: 0x0
    // NOP
    // 0x1ffe10: 0x1495fff4
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 21)) {
        goto label_1ffde4;
    }
    // 0x1ffe18: 0xdc830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ffe1c: 0xdc850008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1ffe20: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x1ffe24: 0xfc450008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 5));
    // 0x1ffe28: 0x2e0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_1ffe2c:
    // 0x1ffe2c: 0xdfbf03b0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 944)));
    // 0x1ffe30: 0xdfb703a0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 928)));
    // 0x1ffe34: 0xdfb60390
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 912)));
    // 0x1ffe38: 0xdfb50380
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 896)));
    // 0x1ffe3c: 0xdfb40370
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 880)));
    // 0x1ffe40: 0xdfb30360
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 864)));
    // 0x1ffe44: 0xdfb20350
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 848)));
    // 0x1ffe48: 0xdfb10340
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x1ffe4c: 0xdfb00330
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x1ffe50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 960));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fde_split
// Address: 0x1ffe58 - 0x200000

void entry_1f0018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0018 inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f0018;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f0028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0028 inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f0028;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f0044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0044 inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f0044;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f004c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f004c inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f004c;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f0054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0054 inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f0054;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f005c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f005c inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1f005c;
    entry_1efff4(rdram, ctx, runtime);
}

void entry_1f01a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01a0 inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01a0;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01b0 inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01b0;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01cc inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01cc;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01d4 inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01d4;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01dc inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01dc;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01e4 inside entry_1f0148 (0x1f0148 - 0x1f01f4)
    ctx->pc = 0x1f01e4;
    entry_1f0148(rdram, ctx, runtime);
}

void entry_1f01fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f01fc inside entry_1f01f4 (0x1f01f4 - 0x1f0218)
    ctx->pc = 0x1f01fc;
    entry_1f01f4(rdram, ctx, runtime);
}

void entry_1f0200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0200 inside entry_1f01f4 (0x1f01f4 - 0x1f0218)
    ctx->pc = 0x1f0200;
    entry_1f01f4(rdram, ctx, runtime);
}

void entry_1f0268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0268 inside entry_1f0264 (0x1f0264 - 0x1f02c8)
    ctx->pc = 0x1f0268;
    entry_1f0264(rdram, ctx, runtime);
}

void entry_1f0288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0288 inside entry_1f0264 (0x1f0264 - 0x1f02c8)
    ctx->pc = 0x1f0288;
    entry_1f0264(rdram, ctx, runtime);
}

void entry_1f02a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f02a0 inside entry_1f0264 (0x1f0264 - 0x1f02c8)
    ctx->pc = 0x1f02a0;
    entry_1f0264(rdram, ctx, runtime);
}

void entry_1f02e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f02e0 inside entry_1f02c8 (0x1f02c8 - 0x1f0308)
    ctx->pc = 0x1f02e0;
    entry_1f02c8(rdram, ctx, runtime);
}

void entry_1f0300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0300 inside entry_1f02c8 (0x1f02c8 - 0x1f0308)
    ctx->pc = 0x1f0300;
    entry_1f02c8(rdram, ctx, runtime);
}

void entry_1f034c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f034c inside entry_1f0344 (0x1f0344 - 0x1f036c)
    ctx->pc = 0x1f034c;
    entry_1f0344(rdram, ctx, runtime);
}

void entry_1f0354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0354 inside entry_1f0344 (0x1f0344 - 0x1f036c)
    ctx->pc = 0x1f0354;
    entry_1f0344(rdram, ctx, runtime);
}

void entry_1f035c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f035c inside entry_1f0344 (0x1f0344 - 0x1f036c)
    ctx->pc = 0x1f035c;
    entry_1f0344(rdram, ctx, runtime);
}

void entry_1f0360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0360 inside entry_1f0344 (0x1f0344 - 0x1f036c)
    ctx->pc = 0x1f0360;
    entry_1f0344(rdram, ctx, runtime);
}

void entry_1f0364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0364 inside entry_1f0344 (0x1f0344 - 0x1f036c)
    ctx->pc = 0x1f0364;
    entry_1f0344(rdram, ctx, runtime);
}

void entry_1f0374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0374 inside entry_1f036c (0x1f036c - 0x1f03dc)
    ctx->pc = 0x1f0374;
    entry_1f036c(rdram, ctx, runtime);
}

void entry_1f038c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f038c inside entry_1f036c (0x1f036c - 0x1f03dc)
    ctx->pc = 0x1f038c;
    entry_1f036c(rdram, ctx, runtime);
}

void entry_1f03bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f03bc inside entry_1f036c (0x1f036c - 0x1f03dc)
    ctx->pc = 0x1f03bc;
    entry_1f036c(rdram, ctx, runtime);
}

void entry_1f03e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f03e4 inside entry_1f03dc (0x1f03dc - 0x1f03fc)
    ctx->pc = 0x1f03e4;
    entry_1f03dc(rdram, ctx, runtime);
}

void entry_1f03ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f03ec inside entry_1f03dc (0x1f03dc - 0x1f03fc)
    ctx->pc = 0x1f03ec;
    entry_1f03dc(rdram, ctx, runtime);
}

void entry_1f0400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0400 inside entry_1f03fc (0x1f03fc - 0x1f0428)
    ctx->pc = 0x1f0400;
    entry_1f03fc(rdram, ctx, runtime);
}

void entry_1f0404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0404 inside entry_1f03fc (0x1f03fc - 0x1f0428)
    ctx->pc = 0x1f0404;
    entry_1f03fc(rdram, ctx, runtime);
}

void entry_1f0410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0410 inside entry_1f03fc (0x1f03fc - 0x1f0428)
    ctx->pc = 0x1f0410;
    entry_1f03fc(rdram, ctx, runtime);
}

void entry_1f0484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0484 inside FUN_001f0468 (0x1f0468 - 0x1f0490)
    ctx->pc = 0x1f0484;
    FUN_001f0468(rdram, ctx, runtime);
}

void entry_1f04b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f04b0 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f04b0;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f04d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f04d0 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f04d0;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f04d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f04d4 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f04d4;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f04d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f04d8 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f04d8;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f052c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f052c inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f052c;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f0568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0568 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f0568;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f0570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0570 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f0570;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f0578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0578 inside FUN_001f0490 (0x1f0490 - 0x1f0580)
    ctx->pc = 0x1f0578;
    FUN_001f0490(rdram, ctx, runtime);
}

void entry_1f05a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f05a8 inside FUN_001f0580 (0x1f0580 - 0x1f05bc)
    ctx->pc = 0x1f05a8;
    FUN_001f0580(rdram, ctx, runtime);
}

void entry_1f05f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f05f0 inside entry_1f05bc (0x1f05bc - 0x1f0644)
    ctx->pc = 0x1f05f0;
    entry_1f05bc(rdram, ctx, runtime);
}

void entry_1f060c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f060c inside entry_1f05bc (0x1f05bc - 0x1f0644)
    ctx->pc = 0x1f060c;
    entry_1f05bc(rdram, ctx, runtime);
}

void entry_1f0628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0628 inside entry_1f05bc (0x1f05bc - 0x1f0644)
    ctx->pc = 0x1f0628;
    entry_1f05bc(rdram, ctx, runtime);
}

void entry_1f0638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0638 inside entry_1f05bc (0x1f05bc - 0x1f0644)
    ctx->pc = 0x1f0638;
    entry_1f05bc(rdram, ctx, runtime);
}

void entry_1f0648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0648 inside entry_1f0644 (0x1f0644 - 0x1f0660)
    ctx->pc = 0x1f0648;
    entry_1f0644(rdram, ctx, runtime);
}

void entry_1f064c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f064c inside entry_1f0644 (0x1f0644 - 0x1f0660)
    ctx->pc = 0x1f064c;
    entry_1f0644(rdram, ctx, runtime);
}

void entry_1f06c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f06c0 inside entry_1f0674 (0x1f0674 - 0x1f0758)
    ctx->pc = 0x1f06c0;
    entry_1f0674(rdram, ctx, runtime);
}

void entry_1f0728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0728 inside entry_1f0674 (0x1f0674 - 0x1f0758)
    ctx->pc = 0x1f0728;
    entry_1f0674(rdram, ctx, runtime);
}

void entry_1f0734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0734 inside entry_1f0674 (0x1f0674 - 0x1f0758)
    ctx->pc = 0x1f0734;
    entry_1f0674(rdram, ctx, runtime);
}

void entry_1f07d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f07d0 inside entry_1f0790 (0x1f0790 - 0x1f07d8)
    ctx->pc = 0x1f07d0;
    entry_1f0790(rdram, ctx, runtime);
}

void entry_1f07f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f07f0 inside entry_1f07d8 (0x1f07d8 - 0x1f0820)
    ctx->pc = 0x1f07f0;
    entry_1f07d8(rdram, ctx, runtime);
}

void entry_1f0800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0800 inside entry_1f07d8 (0x1f07d8 - 0x1f0820)
    ctx->pc = 0x1f0800;
    entry_1f07d8(rdram, ctx, runtime);
}

void entry_1f08b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f08b4 inside entry_1f08ac (0x1f08ac - 0x1f08d0)
    ctx->pc = 0x1f08b4;
    entry_1f08ac(rdram, ctx, runtime);
}

void entry_1f08d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f08d4 inside entry_1f08d0 (0x1f08d0 - 0x1f08dc)
    ctx->pc = 0x1f08d4;
    entry_1f08d0(rdram, ctx, runtime);
}

void entry_1f097c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f097c inside CatchWmDisplayState__FP2WM (0x1f0908 - 0x1f0988)
    ctx->pc = 0x1f097c;
    CatchWmDisplayState__FP2WM(rdram, ctx, runtime);
}

void entry_1f0a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0a24 inside entry_1f09f8 (0x1f09f8 - 0x1f0a38)
    ctx->pc = 0x1f0a24;
    entry_1f09f8(rdram, ctx, runtime);
}

void entry_1f0a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0a58 inside entry_1f0a38 (0x1f0a38 - 0x1f0a80)
    ctx->pc = 0x1f0a58;
    entry_1f0a38(rdram, ctx, runtime);
}

void entry_1f0a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0a9c inside entry_1f0a98 (0x1f0a98 - 0x1f0ae0)
    ctx->pc = 0x1f0a9c;
    entry_1f0a98(rdram, ctx, runtime);
}

void entry_1f0ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0ab0 inside entry_1f0a98 (0x1f0a98 - 0x1f0ae0)
    ctx->pc = 0x1f0ab0;
    entry_1f0a98(rdram, ctx, runtime);
}

void entry_1f0ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0ab4 inside entry_1f0a98 (0x1f0a98 - 0x1f0ae0)
    ctx->pc = 0x1f0ab4;
    entry_1f0a98(rdram, ctx, runtime);
}

void entry_1f0ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0ab8 inside entry_1f0a98 (0x1f0a98 - 0x1f0ae0)
    ctx->pc = 0x1f0ab8;
    entry_1f0a98(rdram, ctx, runtime);
}

void entry_1f0b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0b44 inside entry_1f0b1c (0x1f0b1c - 0x1f0b64)
    ctx->pc = 0x1f0b44;
    entry_1f0b1c(rdram, ctx, runtime);
}

void entry_1f0b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0b54 inside entry_1f0b1c (0x1f0b1c - 0x1f0b64)
    ctx->pc = 0x1f0b54;
    entry_1f0b1c(rdram, ctx, runtime);
}

void entry_1f0b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0b6c inside entry_1f0b64 (0x1f0b64 - 0x1f0b7c)
    ctx->pc = 0x1f0b6c;
    entry_1f0b64(rdram, ctx, runtime);
}

void entry_1f0b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0b84 inside entry_1f0b7c (0x1f0b7c - 0x1f0ba8)
    ctx->pc = 0x1f0b84;
    entry_1f0b7c(rdram, ctx, runtime);
}

void entry_1f0bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0bb0 inside entry_1f0ba8 (0x1f0ba8 - 0x1f0bc8)
    ctx->pc = 0x1f0bb0;
    entry_1f0ba8(rdram, ctx, runtime);
}

void entry_1f0bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0bf4 inside entry_1f0bdc (0x1f0bdc - 0x1f0c08)
    ctx->pc = 0x1f0bf4;
    entry_1f0bdc(rdram, ctx, runtime);
}

void entry_1f0c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0c28 inside entry_1f0c08 (0x1f0c08 - 0x1f0c58)
    ctx->pc = 0x1f0c28;
    entry_1f0c08(rdram, ctx, runtime);
}

void entry_1f0c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0c3c inside entry_1f0c08 (0x1f0c08 - 0x1f0c58)
    ctx->pc = 0x1f0c3c;
    entry_1f0c08(rdram, ctx, runtime);
}

void entry_1f0c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0c60 inside entry_1f0c58 (0x1f0c58 - 0x1f0c84)
    ctx->pc = 0x1f0c60;
    entry_1f0c58(rdram, ctx, runtime);
}

void entry_1f0ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0ca8 inside entry_1f0ca4 (0x1f0ca4 - 0x1f0cdc)
    ctx->pc = 0x1f0ca8;
    entry_1f0ca4(rdram, ctx, runtime);
}

void entry_1f0cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0cc0 inside entry_1f0ca4 (0x1f0ca4 - 0x1f0cdc)
    ctx->pc = 0x1f0cc0;
    entry_1f0ca4(rdram, ctx, runtime);
}

void entry_1f0cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0cc4 inside entry_1f0ca4 (0x1f0ca4 - 0x1f0cdc)
    ctx->pc = 0x1f0cc4;
    entry_1f0ca4(rdram, ctx, runtime);
}

void entry_1f0cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0cd4 inside entry_1f0ca4 (0x1f0ca4 - 0x1f0cdc)
    ctx->pc = 0x1f0cd4;
    entry_1f0ca4(rdram, ctx, runtime);
}

void entry_1f0ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0ce0 inside entry_1f0cdc (0x1f0cdc - 0x1f0d08)
    ctx->pc = 0x1f0ce0;
    entry_1f0cdc(rdram, ctx, runtime);
}

void entry_1f0d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0d48 inside entry_1f0d08 (0x1f0d08 - 0x1f0d84)
    ctx->pc = 0x1f0d48;
    entry_1f0d08(rdram, ctx, runtime);
}

void entry_1f0d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0d5c inside entry_1f0d08 (0x1f0d08 - 0x1f0d84)
    ctx->pc = 0x1f0d5c;
    entry_1f0d08(rdram, ctx, runtime);
}

void entry_1f0d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0d74 inside entry_1f0d08 (0x1f0d08 - 0x1f0d84)
    ctx->pc = 0x1f0d74;
    entry_1f0d08(rdram, ctx, runtime);
}

void entry_1f0d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0d98 inside entry_1f0d94 (0x1f0d94 - 0x1f0de4)
    ctx->pc = 0x1f0d98;
    entry_1f0d94(rdram, ctx, runtime);
}

void entry_1f0da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0da0 inside entry_1f0d94 (0x1f0d94 - 0x1f0de4)
    ctx->pc = 0x1f0da0;
    entry_1f0d94(rdram, ctx, runtime);
}

void entry_1f0da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0da4 inside entry_1f0d94 (0x1f0d94 - 0x1f0de4)
    ctx->pc = 0x1f0da4;
    entry_1f0d94(rdram, ctx, runtime);
}

void entry_1f0dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0dc8 inside entry_1f0d94 (0x1f0d94 - 0x1f0de4)
    ctx->pc = 0x1f0dc8;
    entry_1f0d94(rdram, ctx, runtime);
}

void entry_1f0e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0e24 inside entry_1f0e00 (0x1f0e00 - 0x1f0e38)
    ctx->pc = 0x1f0e24;
    entry_1f0e00(rdram, ctx, runtime);
}

void entry_1f0e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0e40 inside entry_1f0e38 (0x1f0e38 - 0x1f0e70)
    ctx->pc = 0x1f0e40;
    entry_1f0e38(rdram, ctx, runtime);
}

void entry_1f0e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0e5c inside entry_1f0e38 (0x1f0e38 - 0x1f0e70)
    ctx->pc = 0x1f0e5c;
    entry_1f0e38(rdram, ctx, runtime);
}

void entry_1f0e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0e7c inside entry_1f0e70 (0x1f0e70 - 0x1f0eb8)
    ctx->pc = 0x1f0e7c;
    entry_1f0e70(rdram, ctx, runtime);
}

void entry_1f0e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0e84 inside entry_1f0e70 (0x1f0e70 - 0x1f0eb8)
    ctx->pc = 0x1f0e84;
    entry_1f0e70(rdram, ctx, runtime);
}

void entry_1f0fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0fc8 inside entry_1f0f94 (0x1f0f94 - 0x1f0fe4)
    ctx->pc = 0x1f0fc8;
    entry_1f0f94(rdram, ctx, runtime);
}

void entry_1f0fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0fdc inside entry_1f0f94 (0x1f0f94 - 0x1f0fe4)
    ctx->pc = 0x1f0fdc;
    entry_1f0f94(rdram, ctx, runtime);
}

void entry_1f0fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f0fec inside entry_1f0fe4 (0x1f0fe4 - 0x1f0ffc)
    ctx->pc = 0x1f0fec;
    entry_1f0fe4(rdram, ctx, runtime);
}

void entry_1f1004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1004 inside entry_1f0ffc (0x1f0ffc - 0x1f102c)
    ctx->pc = 0x1f1004;
    entry_1f0ffc(rdram, ctx, runtime);
}

void entry_1f1030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1030 inside entry_1f102c (0x1f102c - 0x1f1038)
    ctx->pc = 0x1f1030;
    entry_1f102c(rdram, ctx, runtime);
}

void entry_1f103c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f103c inside entry_1f1038 (0x1f1038 - 0x1f1050)
    ctx->pc = 0x1f103c;
    entry_1f1038(rdram, ctx, runtime);
}

void entry_1f1040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1040 inside entry_1f1038 (0x1f1038 - 0x1f1050)
    ctx->pc = 0x1f1040;
    entry_1f1038(rdram, ctx, runtime);
}

void entry_1f10b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f10b4 inside SetWmWms__FP2WM3WMS (0x1f1050 - 0x1f10dc)
    ctx->pc = 0x1f10b4;
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime);
}

void entry_1f10c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f10c8 inside SetWmWms__FP2WM3WMS (0x1f1050 - 0x1f10dc)
    ctx->pc = 0x1f10c8;
    SetWmWms__FP2WM3WMS(rdram, ctx, runtime);
}

void entry_1f10e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f10e4 inside entry_1f10dc (0x1f10dc - 0x1f1104)
    ctx->pc = 0x1f10e4;
    entry_1f10dc(rdram, ctx, runtime);
}

void entry_1f1108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1108 inside entry_1f1104 (0x1f1104 - 0x1f1160)
    ctx->pc = 0x1f1108;
    entry_1f1104(rdram, ctx, runtime);
}

void entry_1f1118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1118 inside entry_1f1104 (0x1f1104 - 0x1f1160)
    ctx->pc = 0x1f1118;
    entry_1f1104(rdram, ctx, runtime);
}

void entry_1f113c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f113c inside entry_1f1104 (0x1f1104 - 0x1f1160)
    ctx->pc = 0x1f113c;
    entry_1f1104(rdram, ctx, runtime);
}

void entry_1f1168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1168 inside entry_1f1160 (0x1f1160 - 0x1f117c)
    ctx->pc = 0x1f1168;
    entry_1f1160(rdram, ctx, runtime);
}

void entry_1f11ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f11ac inside entry_1f119c (0x1f119c - 0x1f11ec)
    ctx->pc = 0x1f11ac;
    entry_1f119c(rdram, ctx, runtime);
}

void entry_1f11b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f11b0 inside entry_1f119c (0x1f119c - 0x1f11ec)
    ctx->pc = 0x1f11b0;
    entry_1f119c(rdram, ctx, runtime);
}

void entry_1f11d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f11d0 inside entry_1f119c (0x1f119c - 0x1f11ec)
    ctx->pc = 0x1f11d0;
    entry_1f119c(rdram, ctx, runtime);
}

void entry_1f1208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1208 inside entry_1f11f4 (0x1f11f4 - 0x1f1220)
    ctx->pc = 0x1f1208;
    entry_1f11f4(rdram, ctx, runtime);
}

void entry_1f1240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1240 inside entry_1f1228 (0x1f1228 - 0x1f1294)
    ctx->pc = 0x1f1240;
    entry_1f1228(rdram, ctx, runtime);
}

void entry_1f1248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1248 inside entry_1f1228 (0x1f1228 - 0x1f1294)
    ctx->pc = 0x1f1248;
    entry_1f1228(rdram, ctx, runtime);
}

void entry_1f1298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1298 inside entry_1f1294 (0x1f1294 - 0x1f12cc)
    ctx->pc = 0x1f1298;
    entry_1f1294(rdram, ctx, runtime);
}

void entry_1f12b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f12b8 inside entry_1f1294 (0x1f1294 - 0x1f12cc)
    ctx->pc = 0x1f12b8;
    entry_1f1294(rdram, ctx, runtime);
}

void entry_1f12d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f12d4 inside entry_1f12cc (0x1f12cc - 0x1f12f0)
    ctx->pc = 0x1f12d4;
    entry_1f12cc(rdram, ctx, runtime);
}

void entry_1f1388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1388 inside entry_1f1384 (0x1f1384 - 0x1f1394)
    ctx->pc = 0x1f1388;
    entry_1f1384(rdram, ctx, runtime);
}

void entry_1f13bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f13bc inside entry_1f1394 (0x1f1394 - 0x1f140c)
    ctx->pc = 0x1f13bc;
    entry_1f1394(rdram, ctx, runtime);
}

void entry_1f13c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f13c0 inside entry_1f1394 (0x1f1394 - 0x1f140c)
    ctx->pc = 0x1f13c0;
    entry_1f1394(rdram, ctx, runtime);
}

void entry_1f13dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f13dc inside entry_1f1394 (0x1f1394 - 0x1f140c)
    ctx->pc = 0x1f13dc;
    entry_1f1394(rdram, ctx, runtime);
}

void entry_1f146c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f146c inside entry_1f1460 (0x1f1460 - 0x1f1488)
    ctx->pc = 0x1f146c;
    entry_1f1460(rdram, ctx, runtime);
}

void entry_1f14a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f14a0 inside entry_1f1488 (0x1f1488 - 0x1f1500)
    ctx->pc = 0x1f14a0;
    entry_1f1488(rdram, ctx, runtime);
}

void entry_1f14ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f14ac inside entry_1f1488 (0x1f1488 - 0x1f1500)
    ctx->pc = 0x1f14ac;
    entry_1f1488(rdram, ctx, runtime);
}

void entry_1f14e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f14e0 inside entry_1f1488 (0x1f1488 - 0x1f1500)
    ctx->pc = 0x1f14e0;
    entry_1f1488(rdram, ctx, runtime);
}

void entry_1f1504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1504 inside entry_1f1500 (0x1f1500 - 0x1f1510)
    ctx->pc = 0x1f1504;
    entry_1f1500(rdram, ctx, runtime);
}

void entry_1f1530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1530 inside entry_1f152c (0x1f152c - 0x1f153c)
    ctx->pc = 0x1f1530;
    entry_1f152c(rdram, ctx, runtime);
}

void entry_1f1540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1540 inside entry_1f153c (0x1f153c - 0x1f1590)
    ctx->pc = 0x1f1540;
    entry_1f153c(rdram, ctx, runtime);
}

void entry_1f154c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f154c inside entry_1f153c (0x1f153c - 0x1f1590)
    ctx->pc = 0x1f154c;
    entry_1f153c(rdram, ctx, runtime);
}

void entry_1f1550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1550 inside entry_1f153c (0x1f153c - 0x1f1590)
    ctx->pc = 0x1f1550;
    entry_1f153c(rdram, ctx, runtime);
}

void entry_1f155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f155c inside entry_1f153c (0x1f153c - 0x1f1590)
    ctx->pc = 0x1f155c;
    entry_1f153c(rdram, ctx, runtime);
}

void entry_1f15c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f15c4 inside ShowWm__FP2WM10WORLDLEVEL3WMS (0x1f1590 - 0x1f15e0)
    ctx->pc = 0x1f15c4;
    ShowWm__FP2WM10WORLDLEVEL3WMS(rdram, ctx, runtime);
}

void entry_1f15cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f15cc inside ShowWm__FP2WM10WORLDLEVEL3WMS (0x1f1590 - 0x1f15e0)
    ctx->pc = 0x1f15cc;
    ShowWm__FP2WM10WORLDLEVEL3WMS(rdram, ctx, runtime);
}

void entry_1f15e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f15e8 inside entry_1f15e0 (0x1f15e0 - 0x1f1600)
    ctx->pc = 0x1f15e8;
    entry_1f15e0(rdram, ctx, runtime);
}

void entry_1f1604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1604 inside entry_1f1600 (0x1f1600 - 0x1f1610)
    ctx->pc = 0x1f1604;
    entry_1f1600(rdram, ctx, runtime);
}

void entry_1f163c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f163c inside entry_1f1638 (0x1f1638 - 0x1f1648)
    ctx->pc = 0x1f163c;
    entry_1f1638(rdram, ctx, runtime);
}

void entry_1f167c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f167c inside MoveWm__FP2WM3WMD (0x1f1648 - 0x1f170c)
    ctx->pc = 0x1f167c;
    MoveWm__FP2WM3WMD(rdram, ctx, runtime);
}

void entry_1f16c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f16c0 inside MoveWm__FP2WM3WMD (0x1f1648 - 0x1f170c)
    ctx->pc = 0x1f16c0;
    MoveWm__FP2WM3WMD(rdram, ctx, runtime);
}

void entry_1f16e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f16e4 inside MoveWm__FP2WM3WMD (0x1f1648 - 0x1f170c)
    ctx->pc = 0x1f16e4;
    MoveWm__FP2WM3WMD(rdram, ctx, runtime);
}

void entry_1f1714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1714 inside entry_1f170c (0x1f170c - 0x1f174c)
    ctx->pc = 0x1f1714;
    entry_1f170c(rdram, ctx, runtime);
}

void entry_1f1754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1754 inside entry_1f174c (0x1f174c - 0x1f1794)
    ctx->pc = 0x1f1754;
    entry_1f174c(rdram, ctx, runtime);
}

void entry_1f1798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1798 inside entry_1f1794 (0x1f1794 - 0x1f17a0)
    ctx->pc = 0x1f1798;
    entry_1f1794(rdram, ctx, runtime);
}

void entry_1f17cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f17cc inside GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR (0x1f17a0 - 0x1f17f4)
    ctx->pc = 0x1f17cc;
    GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR(rdram, ctx, runtime);
}

void entry_1f17dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f17dc inside GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR (0x1f17a0 - 0x1f17f4)
    ctx->pc = 0x1f17dc;
    GetWmWorldPosScreen__FP2WM10WORLDLEVELP6VECTOR(rdram, ctx, runtime);
}

void entry_1f1880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1880 inside entry_1f183c (0x1f183c - 0x1f18b0)
    ctx->pc = 0x1f1880;
    entry_1f183c(rdram, ctx, runtime);
}

void entry_1f189c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f189c inside entry_1f183c (0x1f183c - 0x1f18b0)
    ctx->pc = 0x1f189c;
    entry_1f183c(rdram, ctx, runtime);
}

void entry_1f1900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1900 inside entry_1f18f8 (0x1f18f8 - 0x1f1960)
    ctx->pc = 0x1f1900;
    entry_1f18f8(rdram, ctx, runtime);
}

void entry_1f1914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1914 inside entry_1f18f8 (0x1f18f8 - 0x1f1960)
    ctx->pc = 0x1f1914;
    entry_1f18f8(rdram, ctx, runtime);
}

void entry_1f1944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1944 inside entry_1f18f8 (0x1f18f8 - 0x1f1960)
    ctx->pc = 0x1f1944;
    entry_1f18f8(rdram, ctx, runtime);
}

void entry_1f1948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1948 inside entry_1f18f8 (0x1f18f8 - 0x1f1960)
    ctx->pc = 0x1f1948;
    entry_1f18f8(rdram, ctx, runtime);
}

void entry_1f199c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f199c inside entry_1f1994 (0x1f1994 - 0x1f19a8)
    ctx->pc = 0x1f199c;
    entry_1f1994(rdram, ctx, runtime);
}

void entry_1f1a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1a78 inside UpdateWmcActive__FP3WMCP3JOY (0x1f1a08 - 0x1f1a80)
    ctx->pc = 0x1f1a78;
    UpdateWmcActive__FP3WMCP3JOY(rdram, ctx, runtime);
}

void entry_1f1a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1a98 inside entry_1f1a90 (0x1f1a90 - 0x1f1ab0)
    ctx->pc = 0x1f1a98;
    entry_1f1a90(rdram, ctx, runtime);
}

void entry_1f1b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1b10 inside entry_1f1b08 (0x1f1b08 - 0x1f1b24)
    ctx->pc = 0x1f1b10;
    entry_1f1b08(rdram, ctx, runtime);
}

void entry_1f1b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1b2c inside entry_1f1b24 (0x1f1b24 - 0x1f1b40)
    ctx->pc = 0x1f1b2c;
    entry_1f1b24(rdram, ctx, runtime);
}

void entry_1f1b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1b48 inside entry_1f1b40 (0x1f1b40 - 0x1f1b5c)
    ctx->pc = 0x1f1b48;
    entry_1f1b40(rdram, ctx, runtime);
}

void entry_1f1b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1b64 inside entry_1f1b5c (0x1f1b5c - 0x1f1b7c)
    ctx->pc = 0x1f1b64;
    entry_1f1b5c(rdram, ctx, runtime);
}

void entry_1f1bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1bd8 inside entry_1f1bd0 (0x1f1bd0 - 0x1f1c18)
    ctx->pc = 0x1f1bd8;
    entry_1f1bd0(rdram, ctx, runtime);
}

void entry_1f1c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c20 inside entry_1f1c18 (0x1f1c18 - 0x1f1c28)
    ctx->pc = 0x1f1c20;
    entry_1f1c18(rdram, ctx, runtime);
}

void entry_1f1c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c40 inside entry_1f1c28 (0x1f1c28 - 0x1f1c68)
    ctx->pc = 0x1f1c40;
    entry_1f1c28(rdram, ctx, runtime);
}

void entry_1f1c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c48 inside entry_1f1c28 (0x1f1c28 - 0x1f1c68)
    ctx->pc = 0x1f1c48;
    entry_1f1c28(rdram, ctx, runtime);
}

void entry_1f1c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c6c inside entry_1f1c68 (0x1f1c68 - 0x1f1c90)
    ctx->pc = 0x1f1c6c;
    entry_1f1c68(rdram, ctx, runtime);
}

void entry_1f1c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c70 inside entry_1f1c68 (0x1f1c68 - 0x1f1c90)
    ctx->pc = 0x1f1c70;
    entry_1f1c68(rdram, ctx, runtime);
}

void entry_1f1c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1c74 inside entry_1f1c68 (0x1f1c68 - 0x1f1c90)
    ctx->pc = 0x1f1c74;
    entry_1f1c68(rdram, ctx, runtime);
}

void entry_1f1cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1cfc inside entry_1f1cf4 (0x1f1cf4 - 0x1f1d04)
    ctx->pc = 0x1f1cfc;
    entry_1f1cf4(rdram, ctx, runtime);
}

void entry_1f1d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1d34 inside entry_1f1d30 (0x1f1d30 - 0x1f1d5c)
    ctx->pc = 0x1f1d34;
    entry_1f1d30(rdram, ctx, runtime);
}

void entry_1f1d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1d60 inside entry_1f1d5c (0x1f1d5c - 0x1f1d6c)
    ctx->pc = 0x1f1d60;
    entry_1f1d5c(rdram, ctx, runtime);
}

void entry_1f1d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1d98 inside entry_1f1d90 (0x1f1d90 - 0x1f1da4)
    ctx->pc = 0x1f1d98;
    entry_1f1d90(rdram, ctx, runtime);
}

void entry_1f1e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1e20 inside entry_1f1e1c (0x1f1e1c - 0x1f1e38)
    ctx->pc = 0x1f1e20;
    entry_1f1e1c(rdram, ctx, runtime);
}

void entry_1f1e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1e24 inside entry_1f1e1c (0x1f1e1c - 0x1f1e38)
    ctx->pc = 0x1f1e24;
    entry_1f1e1c(rdram, ctx, runtime);
}

void entry_1f1fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1fa0 inside entry_1f1f88 (0x1f1f88 - 0x1f1fa8)
    ctx->pc = 0x1f1fa0;
    entry_1f1f88(rdram, ctx, runtime);
}

void entry_1f1ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f1ff8 inside entry_1f1ff0 (0x1f1ff0 - 0x1f2004)
    ctx->pc = 0x1f1ff8;
    entry_1f1ff0(rdram, ctx, runtime);
}

void entry_1f2008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2008 inside entry_1f2004 (0x1f2004 - 0x1f2048)
    ctx->pc = 0x1f2008;
    entry_1f2004(rdram, ctx, runtime);
}

void entry_1f2054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2054 inside entry_1f2048 (0x1f2048 - 0x1f20a8)
    ctx->pc = 0x1f2054;
    entry_1f2048(rdram, ctx, runtime);
}

void entry_1f2290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2290 inside entry_1f2260 (0x1f2260 - 0x1f23a4)
    ctx->pc = 0x1f2290;
    entry_1f2260(rdram, ctx, runtime);
}

void entry_1f2330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2330 inside entry_1f2260 (0x1f2260 - 0x1f23a4)
    ctx->pc = 0x1f2330;
    entry_1f2260(rdram, ctx, runtime);
}

void entry_1f2394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2394 inside entry_1f2260 (0x1f2260 - 0x1f23a4)
    ctx->pc = 0x1f2394;
    entry_1f2260(rdram, ctx, runtime);
}

void entry_1f2464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2464 inside entry_1f2444 (0x1f2444 - 0x1f24b0)
    ctx->pc = 0x1f2464;
    entry_1f2444(rdram, ctx, runtime);
}

void entry_1f2468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2468 inside entry_1f2444 (0x1f2444 - 0x1f24b0)
    ctx->pc = 0x1f2468;
    entry_1f2444(rdram, ctx, runtime);
}

void entry_1f25e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f25e0 inside entry_1f25cc (0x1f25cc - 0x1f2600)
    ctx->pc = 0x1f25e0;
    entry_1f25cc(rdram, ctx, runtime);
}

void entry_1f25e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f25e8 inside entry_1f25cc (0x1f25cc - 0x1f2600)
    ctx->pc = 0x1f25e8;
    entry_1f25cc(rdram, ctx, runtime);
}

void entry_1f260c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f260c inside entry_1f2608 (0x1f2608 - 0x1f263c)
    ctx->pc = 0x1f260c;
    entry_1f2608(rdram, ctx, runtime);
}

void entry_1f2648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2648 inside entry_1f263c (0x1f263c - 0x1f2688)
    ctx->pc = 0x1f2648;
    entry_1f263c(rdram, ctx, runtime);
}

void entry_1f2714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2714 inside entry_1f26b8 (0x1f26b8 - 0x1f2728)
    ctx->pc = 0x1f2714;
    entry_1f26b8(rdram, ctx, runtime);
}

void entry_1f27c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f27c8 inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f27c8;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f27f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f27f0 inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f27f0;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f27fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f27fc inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f27fc;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f2808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2808 inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f2808;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f2824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2824 inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f2824;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f2838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2838 inside ApplyWrGlob__FP2WRP3ALOP4GLOB (0x1f2798 - 0x1f2840)
    ctx->pc = 0x1f2838;
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime);
}

void entry_1f2888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2888 inside UpdateWrStateVectors__FP2WR (0x1f2840 - 0x1f28a8)
    ctx->pc = 0x1f2888;
    UpdateWrStateVectors__FP2WR(rdram, ctx, runtime);
}

void entry_1f28bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f28bc inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f28bc;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f2960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2960 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f2960;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f2974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2974 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f2974;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f2984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2984 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f2984;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f2994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2994 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f2994;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f29a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f29a4 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f29a4;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f29d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f29d0 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f29d0;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f29d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f29d4 inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f29d4;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f29dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f29dc inside entry_1f28a8 (0x1f28a8 - 0x1f29e8)
    ctx->pc = 0x1f29dc;
    entry_1f28a8(rdram, ctx, runtime);
}

void entry_1f2a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2a5c inside entry_1f2a3c (0x1f2a3c - 0x1f2adc)
    ctx->pc = 0x1f2a5c;
    entry_1f2a3c(rdram, ctx, runtime);
}

void entry_1f2a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2a70 inside entry_1f2a3c (0x1f2a3c - 0x1f2adc)
    ctx->pc = 0x1f2a70;
    entry_1f2a3c(rdram, ctx, runtime);
}

void entry_1f2ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2ac4 inside entry_1f2a3c (0x1f2a3c - 0x1f2adc)
    ctx->pc = 0x1f2ac4;
    entry_1f2a3c(rdram, ctx, runtime);
}

void entry_1f2af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2af8 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2af8;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2b68 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2b68;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c20 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c20;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c24 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c24;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c58 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c58;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c68 inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c68;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c6c inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c6c;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2c7c inside entry_1f2adc (0x1f2adc - 0x1f2c8c)
    ctx->pc = 0x1f2c7c;
    entry_1f2adc(rdram, ctx, runtime);
}

void entry_1f2cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2cc4 inside entry_1f2ca4 (0x1f2ca4 - 0x1f2de4)
    ctx->pc = 0x1f2cc4;
    entry_1f2ca4(rdram, ctx, runtime);
}

void entry_1f2d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2d08 inside entry_1f2ca4 (0x1f2ca4 - 0x1f2de4)
    ctx->pc = 0x1f2d08;
    entry_1f2ca4(rdram, ctx, runtime);
}

void entry_1f2d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2d60 inside entry_1f2ca4 (0x1f2ca4 - 0x1f2de4)
    ctx->pc = 0x1f2d60;
    entry_1f2ca4(rdram, ctx, runtime);
}

void entry_1f2da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2da4 inside entry_1f2ca4 (0x1f2ca4 - 0x1f2de4)
    ctx->pc = 0x1f2da4;
    entry_1f2ca4(rdram, ctx, runtime);
}

void entry_1f2e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2e24 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2e24;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2e60 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2e60;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2e64 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2e64;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2e74 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2e74;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2e90 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2e90;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2ea4 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2ea4;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2eb4 inside entry_1f2de4 (0x1f2de4 - 0x1f2ef0)
    ctx->pc = 0x1f2eb4;
    entry_1f2de4(rdram, ctx, runtime);
}

void entry_1f2f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2f68 inside WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2 (0x1f2ef0 - 0x1f301c)
    ctx->pc = 0x1f2f68;
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime);
}

void entry_1f2fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2fa8 inside WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2 (0x1f2ef0 - 0x1f301c)
    ctx->pc = 0x1f2fa8;
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime);
}

void entry_1f2fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f2fac inside WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2 (0x1f2ef0 - 0x1f301c)
    ctx->pc = 0x1f2fac;
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime);
}

void entry_1f3078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3078 inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f3078;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f307c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f307c inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f307c;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f308c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f308c inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f308c;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f3094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3094 inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f3094;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f309c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f309c inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f309c;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f30b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f30b8 inside entry_1f301c (0x1f301c - 0x1f30ec)
    ctx->pc = 0x1f30b8;
    entry_1f301c(rdram, ctx, runtime);
}

void entry_1f3110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3110 inside entry_1f30ec (0x1f30ec - 0x1f3140)
    ctx->pc = 0x1f3110;
    entry_1f30ec(rdram, ctx, runtime);
}

void entry_1f3170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3170 inside GetWrBounds__FP2WRP6VECTOR (0x1f3140 - 0x1f31f8)
    ctx->pc = 0x1f3170;
    GetWrBounds__FP2WRP6VECTOR(rdram, ctx, runtime);
}

void entry_1f3198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3198 inside GetWrBounds__FP2WRP6VECTOR (0x1f3140 - 0x1f31f8)
    ctx->pc = 0x1f3198;
    GetWrBounds__FP2WRP6VECTOR(rdram, ctx, runtime);
}

void entry_1f31d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f31d8 inside GetWrBounds__FP2WRP6VECTOR (0x1f3140 - 0x1f31f8)
    ctx->pc = 0x1f31d8;
    GetWrBounds__FP2WRP6VECTOR(rdram, ctx, runtime);
}

void entry_1f31e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f31e8 inside GetWrBounds__FP2WRP6VECTOR (0x1f3140 - 0x1f31f8)
    ctx->pc = 0x1f31e8;
    GetWrBounds__FP2WRP6VECTOR(rdram, ctx, runtime);
}

void entry_1f32c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f32c4 inside entry_1f329c (0x1f329c - 0x1f3328)
    ctx->pc = 0x1f32c4;
    entry_1f329c(rdram, ctx, runtime);
}

void entry_1f32dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f32dc inside entry_1f329c (0x1f329c - 0x1f3328)
    ctx->pc = 0x1f32dc;
    entry_1f329c(rdram, ctx, runtime);
}

void entry_1f3390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3390 inside GFromOnz__FP3ONZ (0x1f3358 - 0x1f33a4)
    ctx->pc = 0x1f3390;
    GFromOnz__FP3ONZ(rdram, ctx, runtime);
}

void entry_1f33c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f33c4 inside entry_1f33a4 (0x1f33a4 - 0x1f33d0)
    ctx->pc = 0x1f33c4;
    entry_1f33a4(rdram, ctx, runtime);
}

void entry_1f3470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3470 inside entry_1f346c (0x1f346c - 0x1f34fc)
    ctx->pc = 0x1f3470;
    entry_1f346c(rdram, ctx, runtime);
}

void entry_1f3488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3488 inside entry_1f346c (0x1f346c - 0x1f34fc)
    ctx->pc = 0x1f3488;
    entry_1f346c(rdram, ctx, runtime);
}

void entry_1f34c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f34c8 inside entry_1f346c (0x1f346c - 0x1f34fc)
    ctx->pc = 0x1f34c8;
    entry_1f346c(rdram, ctx, runtime);
}

void entry_1f35f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f35f4 inside entry_1f34fc (0x1f34fc - 0x1f35fc)
    ctx->pc = 0x1f35f4;
    entry_1f34fc(rdram, ctx, runtime);
}

void entry_1f369c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f369c inside entry_1f3648 (0x1f3648 - 0x1f36e8)
    ctx->pc = 0x1f369c;
    entry_1f3648(rdram, ctx, runtime);
}

void entry_1f36a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f36a0 inside entry_1f3648 (0x1f3648 - 0x1f36e8)
    ctx->pc = 0x1f36a0;
    entry_1f3648(rdram, ctx, runtime);
}

void entry_1f36b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f36b0 inside entry_1f3648 (0x1f3648 - 0x1f36e8)
    ctx->pc = 0x1f36b0;
    entry_1f3648(rdram, ctx, runtime);
}

void entry_1f36c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f36c0 inside entry_1f3648 (0x1f3648 - 0x1f36e8)
    ctx->pc = 0x1f36c0;
    entry_1f3648(rdram, ctx, runtime);
}

void entry_1f374c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f374c inside AddWrCircleWarp__FP2WR (0x1f36e8 - 0x1f3768)
    ctx->pc = 0x1f374c;
    AddWrCircleWarp__FP2WR(rdram, ctx, runtime);
}

void entry_1f37ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f37ec inside PwreGetWrCur__FP2WR4ENSK4WREK (0x1f37d8 - 0x1f3810)
    ctx->pc = 0x1f37ec;
    PwreGetWrCur__FP2WR4ENSK4WREK(rdram, ctx, runtime);
}

void entry_1f37f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f37f4 inside PwreGetWrCur__FP2WR4ENSK4WREK (0x1f37d8 - 0x1f3810)
    ctx->pc = 0x1f37f4;
    PwreGetWrCur__FP2WR4ENSK4WREK(rdram, ctx, runtime);
}

void entry_1f388c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f388c inside entry_1f3868 (0x1f3868 - 0x1f38a0)
    ctx->pc = 0x1f388c;
    entry_1f3868(rdram, ctx, runtime);
}

void entry_1f38e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f38e0 inside entry_1f38b8 (0x1f38b8 - 0x1f38f0)
    ctx->pc = 0x1f38e0;
    entry_1f38b8(rdram, ctx, runtime);
}

void entry_1f3920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3920 inside AddOnzOnze__FP3ONZffff (0x1f38f0 - 0x1f3928)
    ctx->pc = 0x1f3920;
    AddOnzOnze__FP3ONZffff(rdram, ctx, runtime);
}

void entry_1f3c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3c94 inside entry_1f3c90 (0x1f3c90 - 0x1f3cc0)
    ctx->pc = 0x1f3c94;
    entry_1f3c90(rdram, ctx, runtime);
}

void entry_1f3cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3cf0 inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3cf0;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3cf4 inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3cf4;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3d1c inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3d1c;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3d40 inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3d40;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3d50 inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3d50;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3d5c inside entry_1f3cc0 (0x1f3cc0 - 0x1f3d80)
    ctx->pc = 0x1f3d5c;
    entry_1f3cc0(rdram, ctx, runtime);
}

void entry_1f3df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3df0 inside entry_1f3de0 (0x1f3de0 - 0x1f3df8)
    ctx->pc = 0x1f3df0;
    entry_1f3de0(rdram, ctx, runtime);
}

void entry_1f3e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3e60 inside entry_1f3e50 (0x1f3e50 - 0x1f3e6c)
    ctx->pc = 0x1f3e60;
    entry_1f3e50(rdram, ctx, runtime);
}

void entry_1f3e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3e90 inside entry_1f3e80 (0x1f3e80 - 0x1f3e98)
    ctx->pc = 0x1f3e90;
    entry_1f3e80(rdram, ctx, runtime);
}

void entry_1f3ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3ebc inside entry_1f3e98 (0x1f3e98 - 0x1f3ee0)
    ctx->pc = 0x1f3ebc;
    entry_1f3e98(rdram, ctx, runtime);
}

void entry_1f3f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3f28 inside entry_1f3f14 (0x1f3f14 - 0x1f3f44)
    ctx->pc = 0x1f3f28;
    entry_1f3f14(rdram, ctx, runtime);
}

void entry_1f3f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3f60 inside entry_1f3f44 (0x1f3f44 - 0x1f3f80)
    ctx->pc = 0x1f3f60;
    entry_1f3f44(rdram, ctx, runtime);
}

void entry_1f3fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3fb0 inside entry_1f3fa0 (0x1f3fa0 - 0x1f3fd4)
    ctx->pc = 0x1f3fb0;
    entry_1f3fa0(rdram, ctx, runtime);
}

void entry_1f3ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f3ff0 inside entry_1f3fdc (0x1f3fdc - 0x1f4008)
    ctx->pc = 0x1f3ff0;
    entry_1f3fdc(rdram, ctx, runtime);
}

void entry_1f40a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f40a8 inside entry_1f40a0 (0x1f40a0 - 0x1f40c0)
    ctx->pc = 0x1f40a8;
    entry_1f40a0(rdram, ctx, runtime);
}

void entry_1f4118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4118 inside entry_1f4108 (0x1f4108 - 0x1f4144)
    ctx->pc = 0x1f4118;
    entry_1f4108(rdram, ctx, runtime);
}

void entry_1f4154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4154 inside entry_1f4144 (0x1f4144 - 0x1f4170)
    ctx->pc = 0x1f4154;
    entry_1f4144(rdram, ctx, runtime);
}

void entry_1f4180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4180 inside entry_1f4170 (0x1f4170 - 0x1f419c)
    ctx->pc = 0x1f4180;
    entry_1f4170(rdram, ctx, runtime);
}

void entry_1f41cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f41cc inside entry_1f41b4 (0x1f41b4 - 0x1f41e4)
    ctx->pc = 0x1f41cc;
    entry_1f41b4(rdram, ctx, runtime);
}

void entry_1f4210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4210 inside entry_1f41e4 (0x1f41e4 - 0x1f4228)
    ctx->pc = 0x1f4210;
    entry_1f41e4(rdram, ctx, runtime);
}

void entry_1f422c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f422c inside entry_1f4228 (0x1f4228 - 0x1f4260)
    ctx->pc = 0x1f422c;
    entry_1f4228(rdram, ctx, runtime);
}

void entry_1f4234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4234 inside entry_1f4228 (0x1f4228 - 0x1f4260)
    ctx->pc = 0x1f4234;
    entry_1f4228(rdram, ctx, runtime);
}

void entry_1f4288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4288 inside entry_1f4280 (0x1f4280 - 0x1f4298)
    ctx->pc = 0x1f4288;
    entry_1f4280(rdram, ctx, runtime);
}

void entry_1f429c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f429c inside entry_1f4298 (0x1f4298 - 0x1f42ac)
    ctx->pc = 0x1f429c;
    entry_1f4298(rdram, ctx, runtime);
}

void entry_1f42b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f42b0 inside entry_1f42ac (0x1f42ac - 0x1f42d0)
    ctx->pc = 0x1f42b0;
    entry_1f42ac(rdram, ctx, runtime);
}

void entry_1f4344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4344 inside entry_1f433c (0x1f433c - 0x1f434c)
    ctx->pc = 0x1f4344;
    entry_1f433c(rdram, ctx, runtime);
}

void entry_1f4370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4370 inside entry_1f436c (0x1f436c - 0x1f4378)
    ctx->pc = 0x1f4370;
    entry_1f436c(rdram, ctx, runtime);
}

void entry_1f43d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f43d0 inside entry_1f43a4 (0x1f43a4 - 0x1f4408)
    ctx->pc = 0x1f43d0;
    entry_1f43a4(rdram, ctx, runtime);
}

void entry_1f43e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f43e4 inside entry_1f43a4 (0x1f43a4 - 0x1f4408)
    ctx->pc = 0x1f43e4;
    entry_1f43a4(rdram, ctx, runtime);
}

void entry_1f43f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f43f4 inside entry_1f43a4 (0x1f43a4 - 0x1f4408)
    ctx->pc = 0x1f43f4;
    entry_1f43a4(rdram, ctx, runtime);
}

void entry_1f4454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4454 inside TriggerDefaultExit__Fi5WIPEK (0x1f4408 - 0x1f4468)
    ctx->pc = 0x1f4454;
    TriggerDefaultExit__Fi5WIPEK(rdram, ctx, runtime);
}

void entry_1f4470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4470 inside entry_1f4468 (0x1f4468 - 0x1f4478)
    ctx->pc = 0x1f4470;
    entry_1f4468(rdram, ctx, runtime);
}

void entry_1f4490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4490 inside entry_1f4488 (0x1f4488 - 0x1f4498)
    ctx->pc = 0x1f4490;
    entry_1f4488(rdram, ctx, runtime);
}

void entry_1f44a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f44a8 inside entry_1f4498 (0x1f4498 - 0x1f44b0)
    ctx->pc = 0x1f44a8;
    entry_1f4498(rdram, ctx, runtime);
}

void entry_1f44b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f44b8 inside entry_1f44b0 (0x1f44b0 - 0x1f44ec)
    ctx->pc = 0x1f44b8;
    entry_1f44b0(rdram, ctx, runtime);
}

void entry_1f44f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f44f0 inside entry_1f44ec (0x1f44ec - 0x1f4500)
    ctx->pc = 0x1f44f0;
    entry_1f44ec(rdram, ctx, runtime);
}

void entry_1f4570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4570 inside entry_1f456c (0x1f456c - 0x1f4588)
    ctx->pc = 0x1f4570;
    entry_1f456c(rdram, ctx, runtime);
}

void entry_1f45b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f45b8 inside entry_1f45ac (0x1f45ac - 0x1f45c0)
    ctx->pc = 0x1f45b8;
    entry_1f45ac(rdram, ctx, runtime);
}

void entry_1f463c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f463c inside entry_1f462c (0x1f462c - 0x1f4660)
    ctx->pc = 0x1f463c;
    entry_1f462c(rdram, ctx, runtime);
}

void entry_1f4690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4690 inside entry_1f4680 (0x1f4680 - 0x1f46b4)
    ctx->pc = 0x1f4690;
    entry_1f4680(rdram, ctx, runtime);
}

void entry_1f46b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f46b8 inside entry_1f46b4 (0x1f46b4 - 0x1f46d0)
    ctx->pc = 0x1f46b8;
    entry_1f46b4(rdram, ctx, runtime);
}

void entry_1f46e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f46e4 inside entry_1f46d0 (0x1f46d0 - 0x1f4744)
    ctx->pc = 0x1f46e4;
    entry_1f46d0(rdram, ctx, runtime);
}

void entry_1f4718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4718 inside entry_1f46d0 (0x1f46d0 - 0x1f4744)
    ctx->pc = 0x1f4718;
    entry_1f46d0(rdram, ctx, runtime);
}

void entry_1f4738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4738 inside entry_1f46d0 (0x1f46d0 - 0x1f4744)
    ctx->pc = 0x1f4738;
    entry_1f46d0(rdram, ctx, runtime);
}

void entry_1f4748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4748 inside entry_1f4744 (0x1f4744 - 0x1f4760)
    ctx->pc = 0x1f4748;
    entry_1f4744(rdram, ctx, runtime);
}

void entry_1f47a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f47a8 inside entry_1f47a4 (0x1f47a4 - 0x1f47e4)
    ctx->pc = 0x1f47a8;
    entry_1f47a4(rdram, ctx, runtime);
}

void entry_1f47b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f47b0 inside entry_1f47a4 (0x1f47a4 - 0x1f47e4)
    ctx->pc = 0x1f47b0;
    entry_1f47a4(rdram, ctx, runtime);
}

void entry_1f47e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f47e8 inside entry_1f47e4 (0x1f47e4 - 0x1f4808)
    ctx->pc = 0x1f47e8;
    entry_1f47e4(rdram, ctx, runtime);
}

void entry_1f47f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f47f4 inside entry_1f47e4 (0x1f47e4 - 0x1f4808)
    ctx->pc = 0x1f47f4;
    entry_1f47e4(rdram, ctx, runtime);
}

void entry_1f4890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4890 inside entry_1f4880 (0x1f4880 - 0x1f4898)
    ctx->pc = 0x1f4890;
    entry_1f4880(rdram, ctx, runtime);
}

void entry_1f48ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f48ac inside entry_1f48a4 (0x1f48a4 - 0x1f48c4)
    ctx->pc = 0x1f48ac;
    entry_1f48a4(rdram, ctx, runtime);
}

void entry_1f48c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f48c8 inside entry_1f48c4 (0x1f48c4 - 0x1f48dc)
    ctx->pc = 0x1f48c8;
    entry_1f48c4(rdram, ctx, runtime);
}

void entry_1f48f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f48f0 inside entry_1f48e8 (0x1f48e8 - 0x1f4900)
    ctx->pc = 0x1f48f0;
    entry_1f48e8(rdram, ctx, runtime);
}

void entry_1f4908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4908 inside entry_1f4900 (0x1f4900 - 0x1f4928)
    ctx->pc = 0x1f4908;
    entry_1f4900(rdram, ctx, runtime);
}

void entry_1f492c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f492c inside entry_1f4928 (0x1f4928 - 0x1f4934)
    ctx->pc = 0x1f492c;
    entry_1f4928(rdram, ctx, runtime);
}

void entry_1f4940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4940 inside entry_1f4934 (0x1f4934 - 0x1f4974)
    ctx->pc = 0x1f4940;
    entry_1f4934(rdram, ctx, runtime);
}

void entry_1f4990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4990 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f4990;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f4994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4994 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f4994;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f49a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f49a4 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f49a4;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f49d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f49d0 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f49d0;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f49f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f49f4 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f49f4;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f49f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f49f8 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f49f8;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f4a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a00 inside entry_1f4984 (0x1f4984 - 0x1f4a10)
    ctx->pc = 0x1f4a00;
    entry_1f4984(rdram, ctx, runtime);
}

void entry_1f4a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a14 inside entry_1f4a10 (0x1f4a10 - 0x1f4a30)
    ctx->pc = 0x1f4a14;
    entry_1f4a10(rdram, ctx, runtime);
}

void entry_1f4a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a64 inside WipeExit__FP4EXIT (0x1f4a30 - 0x1f4a6c)
    ctx->pc = 0x1f4a64;
    WipeExit__FP4EXIT(rdram, ctx, runtime);
}

void entry_1f4a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a7c inside entry_1f4a74 (0x1f4a74 - 0x1f4acc)
    ctx->pc = 0x1f4a7c;
    entry_1f4a74(rdram, ctx, runtime);
}

void entry_1f4a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a88 inside entry_1f4a74 (0x1f4a74 - 0x1f4acc)
    ctx->pc = 0x1f4a88;
    entry_1f4a74(rdram, ctx, runtime);
}

void entry_1f4a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4a8c inside entry_1f4a74 (0x1f4a74 - 0x1f4acc)
    ctx->pc = 0x1f4a8c;
    entry_1f4a74(rdram, ctx, runtime);
}

void entry_1f4aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4aa0 inside entry_1f4a74 (0x1f4a74 - 0x1f4acc)
    ctx->pc = 0x1f4aa0;
    entry_1f4a74(rdram, ctx, runtime);
}

void entry_1f4aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4aa4 inside entry_1f4a74 (0x1f4a74 - 0x1f4acc)
    ctx->pc = 0x1f4aa4;
    entry_1f4a74(rdram, ctx, runtime);
}

void entry_1f4bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4bb4 inside entry_1f4b5c (0x1f4b5c - 0x1f4bc8)
    ctx->pc = 0x1f4bb4;
    entry_1f4b5c(rdram, ctx, runtime);
}

void entry_1f4bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4bb8 inside entry_1f4b5c (0x1f4b5c - 0x1f4bc8)
    ctx->pc = 0x1f4bb8;
    entry_1f4b5c(rdram, ctx, runtime);
}

void entry_1f4bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4bd0 inside entry_1f4bc8 (0x1f4bc8 - 0x1f4be0)
    ctx->pc = 0x1f4bd0;
    entry_1f4bc8(rdram, ctx, runtime);
}

void entry_1f4c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4c9c inside entry_1f4c34 (0x1f4c34 - 0x1f4d6c)
    ctx->pc = 0x1f4c9c;
    entry_1f4c34(rdram, ctx, runtime);
}

void entry_1f4cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4cc4 inside entry_1f4c34 (0x1f4c34 - 0x1f4d6c)
    ctx->pc = 0x1f4cc4;
    entry_1f4c34(rdram, ctx, runtime);
}

void entry_1f4cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4cdc inside entry_1f4c34 (0x1f4c34 - 0x1f4d6c)
    ctx->pc = 0x1f4cdc;
    entry_1f4c34(rdram, ctx, runtime);
}

void entry_1f4d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4d74 inside entry_1f4d6c (0x1f4d6c - 0x1f4d84)
    ctx->pc = 0x1f4d74;
    entry_1f4d6c(rdram, ctx, runtime);
}

void entry_1f4d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4d7c inside entry_1f4d6c (0x1f4d6c - 0x1f4d84)
    ctx->pc = 0x1f4d7c;
    entry_1f4d6c(rdram, ctx, runtime);
}

void entry_1f4d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4d8c inside entry_1f4d84 (0x1f4d84 - 0x1f4dac)
    ctx->pc = 0x1f4d8c;
    entry_1f4d84(rdram, ctx, runtime);
}

void entry_1f4d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4d9c inside entry_1f4d84 (0x1f4d84 - 0x1f4dac)
    ctx->pc = 0x1f4d9c;
    entry_1f4d84(rdram, ctx, runtime);
}

void entry_1f4db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4db4 inside entry_1f4dac (0x1f4dac - 0x1f4de0)
    ctx->pc = 0x1f4db4;
    entry_1f4dac(rdram, ctx, runtime);
}

void entry_1f4dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4dd8 inside entry_1f4dac (0x1f4dac - 0x1f4de0)
    ctx->pc = 0x1f4dd8;
    entry_1f4dac(rdram, ctx, runtime);
}

void entry_1f4de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4de8 inside entry_1f4de0 (0x1f4de0 - 0x1f4dfc)
    ctx->pc = 0x1f4de8;
    entry_1f4de0(rdram, ctx, runtime);
}

void entry_1f4e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4e00 inside entry_1f4dfc (0x1f4dfc - 0x1f4e18)
    ctx->pc = 0x1f4e00;
    entry_1f4dfc(rdram, ctx, runtime);
}

void entry_1f4e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4e04 inside entry_1f4dfc (0x1f4dfc - 0x1f4e18)
    ctx->pc = 0x1f4e04;
    entry_1f4dfc(rdram, ctx, runtime);
}

void entry_1f4ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4ea8 inside entry_1f4e80 (0x1f4e80 - 0x1f4eb0)
    ctx->pc = 0x1f4ea8;
    entry_1f4e80(rdram, ctx, runtime);
}

void entry_1f4eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4eb8 inside entry_1f4eb0 (0x1f4eb0 - 0x1f4ed0)
    ctx->pc = 0x1f4eb8;
    entry_1f4eb0(rdram, ctx, runtime);
}

void entry_1f4ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4ebc inside entry_1f4eb0 (0x1f4eb0 - 0x1f4ed0)
    ctx->pc = 0x1f4ebc;
    entry_1f4eb0(rdram, ctx, runtime);
}

void entry_1f4f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4f14 inside entry_1f4f08 (0x1f4f08 - 0x1f4f20)
    ctx->pc = 0x1f4f14;
    entry_1f4f08(rdram, ctx, runtime);
}

void entry_1f4f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f4f5c inside entry_1f4f58 (0x1f4f58 - 0x1f4f70)
    ctx->pc = 0x1f4f5c;
    entry_1f4f58(rdram, ctx, runtime);
}

void entry_1f5058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5058 inside entry_1f503c (0x1f503c - 0x1f508c)
    ctx->pc = 0x1f5058;
    entry_1f503c(rdram, ctx, runtime);
}

void entry_1f5070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5070 inside entry_1f503c (0x1f503c - 0x1f508c)
    ctx->pc = 0x1f5070;
    entry_1f503c(rdram, ctx, runtime);
}

void entry_1f50f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f50f4 inside entry_1f50ac (0x1f50ac - 0x1f5120)
    ctx->pc = 0x1f50f4;
    entry_1f50ac(rdram, ctx, runtime);
}

void entry_1f50f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f50f8 inside entry_1f50ac (0x1f50ac - 0x1f5120)
    ctx->pc = 0x1f50f8;
    entry_1f50ac(rdram, ctx, runtime);
}

void entry_1f5104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5104 inside entry_1f50ac (0x1f50ac - 0x1f5120)
    ctx->pc = 0x1f5104;
    entry_1f50ac(rdram, ctx, runtime);
}

void entry_1f5110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5110 inside entry_1f50ac (0x1f50ac - 0x1f5120)
    ctx->pc = 0x1f5110;
    entry_1f50ac(rdram, ctx, runtime);
}

void entry_1f5130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5130 inside entry_1f5120 (0x1f5120 - 0x1f5160)
    ctx->pc = 0x1f5130;
    entry_1f5120(rdram, ctx, runtime);
}

void entry_1f5170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5170 inside entry_1f5160 (0x1f5160 - 0x1f51a0)
    ctx->pc = 0x1f5170;
    entry_1f5160(rdram, ctx, runtime);
}

void entry_1f52ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f52ac inside entry_1f528c (0x1f528c - 0x1f52c0)
    ctx->pc = 0x1f52ac;
    entry_1f528c(rdram, ctx, runtime);
}

void entry_1f5314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5314 inside entry_1f52c0 (0x1f52c0 - 0x1f5350)
    ctx->pc = 0x1f5314;
    entry_1f52c0(rdram, ctx, runtime);
}

void entry_1f53a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f53a0 inside entry_1f5390 (0x1f5390 - 0x1f53e8)
    ctx->pc = 0x1f53a0;
    entry_1f5390(rdram, ctx, runtime);
}

void entry_1f53b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f53b0 inside entry_1f5390 (0x1f5390 - 0x1f53e8)
    ctx->pc = 0x1f53b0;
    entry_1f5390(rdram, ctx, runtime);
}

void entry_1f5418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5418 inside entry_1f53e8 (0x1f53e8 - 0x1f5480)
    ctx->pc = 0x1f5418;
    entry_1f53e8(rdram, ctx, runtime);
}

void entry_1f5474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5474 inside entry_1f53e8 (0x1f53e8 - 0x1f5480)
    ctx->pc = 0x1f5474;
    entry_1f53e8(rdram, ctx, runtime);
}

void entry_1f54c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f54c0 inside entry_1f54b8 (0x1f54b8 - 0x1f5504)
    ctx->pc = 0x1f54c0;
    entry_1f54b8(rdram, ctx, runtime);
}

void entry_1f54d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f54d8 inside entry_1f54b8 (0x1f54b8 - 0x1f5504)
    ctx->pc = 0x1f54d8;
    entry_1f54b8(rdram, ctx, runtime);
}

void entry_1f54f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f54f8 inside entry_1f54b8 (0x1f54b8 - 0x1f5504)
    ctx->pc = 0x1f54f8;
    entry_1f54b8(rdram, ctx, runtime);
}

void entry_1f550c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f550c inside entry_1f5504 (0x1f5504 - 0x1f552c)
    ctx->pc = 0x1f550c;
    entry_1f5504(rdram, ctx, runtime);
}

void entry_1f5530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5530 inside entry_1f552c (0x1f552c - 0x1f5548)
    ctx->pc = 0x1f5530;
    entry_1f552c(rdram, ctx, runtime);
}

void entry_1f5538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5538 inside entry_1f552c (0x1f552c - 0x1f5548)
    ctx->pc = 0x1f5538;
    entry_1f552c(rdram, ctx, runtime);
}

void entry_1f553c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f553c inside entry_1f552c (0x1f552c - 0x1f5548)
    ctx->pc = 0x1f553c;
    entry_1f552c(rdram, ctx, runtime);
}

void entry_1f557c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f557c inside entry_1f5578 (0x1f5578 - 0x1f5590)
    ctx->pc = 0x1f557c;
    entry_1f5578(rdram, ctx, runtime);
}

void entry_1f5580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5580 inside entry_1f5578 (0x1f5578 - 0x1f5590)
    ctx->pc = 0x1f5580;
    entry_1f5578(rdram, ctx, runtime);
}

void entry_1f5618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5618 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5618;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f5634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5634 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5634;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f5650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5650 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5650;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f5654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5654 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5654;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f5668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5668 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5668;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f5678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5678 inside PostZpdLoad__FP3ZPD (0x1f55a8 - 0x1f568c)
    ctx->pc = 0x1f5678;
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime);
}

void entry_1f56a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f56a4 inside entry_1f56a0 (0x1f56a0 - 0x1f56d8)
    ctx->pc = 0x1f56a4;
    entry_1f56a0(rdram, ctx, runtime);
}

void entry_1f56b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f56b4 inside entry_1f56a0 (0x1f56a0 - 0x1f56d8)
    ctx->pc = 0x1f56b4;
    entry_1f56a0(rdram, ctx, runtime);
}

void entry_1f57b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f57b8 inside entry_1f57b0 (0x1f57b0 - 0x1f57c8)
    ctx->pc = 0x1f57b8;
    entry_1f57b0(rdram, ctx, runtime);
}

void entry_1f57cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f57cc inside entry_1f57c8 (0x1f57c8 - 0x1f57e0)
    ctx->pc = 0x1f57cc;
    entry_1f57c8(rdram, ctx, runtime);
}

void entry_1f5860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5860 inside AddZpdZapObject__FP3ZPD3OID (0x1f5840 - 0x1f5868)
    ctx->pc = 0x1f5860;
    AddZpdZapObject__FP3ZPD3OID(rdram, ctx, runtime);
}

void entry_1f5908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5908 inside entry_1f58fc (0x1f58fc - 0x1f5930)
    ctx->pc = 0x1f5908;
    entry_1f58fc(rdram, ctx, runtime);
}

void entry_1f591c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f591c inside entry_1f58fc (0x1f58fc - 0x1f5930)
    ctx->pc = 0x1f591c;
    entry_1f58fc(rdram, ctx, runtime);
}

void entry_1f5920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5920 inside entry_1f58fc (0x1f58fc - 0x1f5930)
    ctx->pc = 0x1f5920;
    entry_1f58fc(rdram, ctx, runtime);
}

void entry_1f5968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5968 inside RemoveZpdZapLo__FP3ZPDP2LO (0x1f5930 - 0x1f59a8)
    ctx->pc = 0x1f5968;
    RemoveZpdZapLo__FP3ZPDP2LO(rdram, ctx, runtime);
}

void entry_1f5980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5980 inside RemoveZpdZapLo__FP3ZPDP2LO (0x1f5930 - 0x1f59a8)
    ctx->pc = 0x1f5980;
    RemoveZpdZapLo__FP3ZPDP2LO(rdram, ctx, runtime);
}

void entry_1f59b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f59b4 inside entry_1f59a8 (0x1f59a8 - 0x1f59c4)
    ctx->pc = 0x1f59b4;
    entry_1f59a8(rdram, ctx, runtime);
}

void entry_1f59dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f59dc inside memcmp (0x1f59c4 - 0x1f5a58)
    ctx->pc = 0x1f59dc;
    memcmp(rdram, ctx, runtime);
}

void entry_1f5a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5a10 inside memcmp (0x1f59c4 - 0x1f5a58)
    ctx->pc = 0x1f5a10;
    memcmp(rdram, ctx, runtime);
}

void entry_1f5a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5a2c inside memcmp (0x1f59c4 - 0x1f5a58)
    ctx->pc = 0x1f5a2c;
    memcmp(rdram, ctx, runtime);
}

void entry_1f5a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5a44 inside memcmp (0x1f59c4 - 0x1f5a58)
    ctx->pc = 0x1f5a44;
    memcmp(rdram, ctx, runtime);
}

void entry_1f5a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5a50 inside memcmp (0x1f59c4 - 0x1f5a58)
    ctx->pc = 0x1f5a50;
    memcmp(rdram, ctx, runtime);
}

void entry_1f5a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5a7c inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5a7c;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ab4 inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5ab4;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ad4 inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5ad4;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ad8 inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5ad8;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ae4 inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5ae4;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5b00 inside memcpy (0x1f5a58 - 0x1f5b08)
    ctx->pc = 0x1f5b00;
    memcpy(rdram, ctx, runtime);
}

void entry_1f5b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5b3c inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5b3c;
    memmove(rdram, ctx, runtime);
}

void entry_1f5b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5b60 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5b60;
    memmove(rdram, ctx, runtime);
}

void entry_1f5b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5b80 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5b80;
    memmove(rdram, ctx, runtime);
}

void entry_1f5bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5bb8 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5bb8;
    memmove(rdram, ctx, runtime);
}

void entry_1f5bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5bd8 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5bd8;
    memmove(rdram, ctx, runtime);
}

void entry_1f5bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5bdc inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5bdc;
    memmove(rdram, ctx, runtime);
}

void entry_1f5be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5be8 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5be8;
    memmove(rdram, ctx, runtime);
}

void entry_1f5c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5c04 inside memmove (0x1f5b08 - 0x1f5c0c)
    ctx->pc = 0x1f5c04;
    memmove(rdram, ctx, runtime);
}

void entry_1f5c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5c48 inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5c48;
    memset(rdram, ctx, runtime);
}

void entry_1f5c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5c6c inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5c6c;
    memset(rdram, ctx, runtime);
}

void entry_1f5c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5c78 inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5c78;
    memset(rdram, ctx, runtime);
}

void entry_1f5c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5c8c inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5c8c;
    memset(rdram, ctx, runtime);
}

void entry_1f5ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ca8 inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5ca8;
    memset(rdram, ctx, runtime);
}

void entry_1f5cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5cc4 inside memset (0x1f5c0c - 0x1f5cd0)
    ctx->pc = 0x1f5cc4;
    memset(rdram, ctx, runtime);
}

void entry_1f5d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d0c inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d0c;
    qsort(rdram, ctx, runtime);
}

void entry_1f5d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d30 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d30;
    qsort(rdram, ctx, runtime);
}

void entry_1f5d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d34 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d34;
    qsort(rdram, ctx, runtime);
}

void entry_1f5d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d70 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d70;
    qsort(rdram, ctx, runtime);
}

void entry_1f5d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d78 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d78;
    qsort(rdram, ctx, runtime);
}

void entry_1f5d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5d94 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5d94;
    qsort(rdram, ctx, runtime);
}

void entry_1f5da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5da8 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5da8;
    qsort(rdram, ctx, runtime);
}

void entry_1f5dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5dd0 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5dd0;
    qsort(rdram, ctx, runtime);
}

void entry_1f5de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5de0 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5de0;
    qsort(rdram, ctx, runtime);
}

void entry_1f5e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5e00 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5e00;
    qsort(rdram, ctx, runtime);
}

void entry_1f5e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5e04 inside qsort (0x1f5cd0 - 0x1f5e1c)
    ctx->pc = 0x1f5e04;
    qsort(rdram, ctx, runtime);
}

void entry_1f5e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5e24 inside entry_1f5e1c (0x1f5e1c - 0x1f5eac)
    ctx->pc = 0x1f5e24;
    entry_1f5e1c(rdram, ctx, runtime);
}

void entry_1f5e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5e40 inside entry_1f5e1c (0x1f5e1c - 0x1f5eac)
    ctx->pc = 0x1f5e40;
    entry_1f5e1c(rdram, ctx, runtime);
}

void entry_1f5ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5ee4 inside entry_1f5ed0 (0x1f5ed0 - 0x1f5eec)
    ctx->pc = 0x1f5ee4;
    entry_1f5ed0(rdram, ctx, runtime);
}

void entry_1f5f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5f10 inside entry_1f5f00 (0x1f5f00 - 0x1f5f2c)
    ctx->pc = 0x1f5f10;
    entry_1f5f00(rdram, ctx, runtime);
}

void entry_1f5f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5f60 inside entry_1f5f4c (0x1f5f4c - 0x1f5f68)
    ctx->pc = 0x1f5f60;
    entry_1f5f4c(rdram, ctx, runtime);
}

void entry_1f5f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5f90 inside entry_1f5f7c (0x1f5f7c - 0x1f5fb4)
    ctx->pc = 0x1f5f90;
    entry_1f5f7c(rdram, ctx, runtime);
}

void entry_1f5f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5f94 inside entry_1f5f7c (0x1f5f7c - 0x1f5fb4)
    ctx->pc = 0x1f5f94;
    entry_1f5f7c(rdram, ctx, runtime);
}

void entry_1f5fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f5fe8 inside entry_1f5fd4 (0x1f5fd4 - 0x1f5ff0)
    ctx->pc = 0x1f5fe8;
    entry_1f5fd4(rdram, ctx, runtime);
}

void entry_1f6018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6018 inside entry_1f6004 (0x1f6004 - 0x1f602c)
    ctx->pc = 0x1f6018;
    entry_1f6004(rdram, ctx, runtime);
}

void entry_1f601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f601c inside entry_1f6004 (0x1f6004 - 0x1f602c)
    ctx->pc = 0x1f601c;
    entry_1f6004(rdram, ctx, runtime);
}

void entry_1f6020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6020 inside entry_1f6004 (0x1f6004 - 0x1f602c)
    ctx->pc = 0x1f6020;
    entry_1f6004(rdram, ctx, runtime);
}

void entry_1f6060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6060 inside entry_1f604c (0x1f604c - 0x1f6068)
    ctx->pc = 0x1f6060;
    entry_1f604c(rdram, ctx, runtime);
}

void entry_1f6090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6090 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6090;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6094 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6094;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f609c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f609c inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f609c;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f60a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f60a8 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f60a8;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f60cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f60cc inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f60cc;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f60f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f60f0 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f60f0;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6118 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6118;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6130 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6130;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6150 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6150;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6154 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6154;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6188 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6188;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f61a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f61a0 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f61a0;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f61c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f61c0 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f61c0;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f61e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f61e8 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f61e8;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6200 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6200;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6220 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6220;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6224 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6224;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6238 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6238;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6268 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6268;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6288 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f6288;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f62b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f62b0 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f62b0;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f62c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f62c8 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f62c8;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f62e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f62e8 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f62e8;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f62ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f62ec inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f62ec;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f62f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f62f0 inside entry_1f607c (0x1f607c - 0x1f6308)
    ctx->pc = 0x1f62f0;
    entry_1f607c(rdram, ctx, runtime);
}

void entry_1f6314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6314 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f6314;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f6328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6328 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f6328;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f6358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6358 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f6358;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f6370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6370 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f6370;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f6398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6398 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f6398;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f63a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f63a8 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f63a8;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f63c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f63c8 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f63c8;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f63cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f63cc inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f63cc;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f63d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f63d4 inside entry_1f6308 (0x1f6308 - 0x1f63f0)
    ctx->pc = 0x1f63d4;
    entry_1f6308(rdram, ctx, runtime);
}

void entry_1f6414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6414 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f6414;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f6458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6458 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f6458;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f6460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6460 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f6460;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f647c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f647c inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f647c;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f6490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6490 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f6490;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f64b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f64b8 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f64b8;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f64c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f64c8 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f64c8;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f64e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f64e8 inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f64e8;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f64ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f64ec inside entry_1f63f0 (0x1f63f0 - 0x1f6504)
    ctx->pc = 0x1f64ec;
    entry_1f63f0(rdram, ctx, runtime);
}

void entry_1f650c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f650c inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f650c;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6528 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6528;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6570 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6570;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6598 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6598;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f65b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f65b0 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f65b0;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f65d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f65d8 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f65d8;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f65e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f65e4 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f65e4;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6610 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6610;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6638 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6638;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6648 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6648;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6668 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6668;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f666c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f666c inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f666c;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f6684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6684 inside entry_1f6504 (0x1f6504 - 0x1f6698)
    ctx->pc = 0x1f6684;
    entry_1f6504(rdram, ctx, runtime);
}

void entry_1f669c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f669c inside entry_1f6698 (0x1f6698 - 0x1f66f8)
    ctx->pc = 0x1f669c;
    entry_1f6698(rdram, ctx, runtime);
}

void entry_1f66b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f66b4 inside entry_1f6698 (0x1f6698 - 0x1f66f8)
    ctx->pc = 0x1f66b4;
    entry_1f6698(rdram, ctx, runtime);
}

void entry_1f66c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f66c4 inside entry_1f6698 (0x1f6698 - 0x1f66f8)
    ctx->pc = 0x1f66c4;
    entry_1f6698(rdram, ctx, runtime);
}

void entry_1f66c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f66c8 inside entry_1f6698 (0x1f6698 - 0x1f66f8)
    ctx->pc = 0x1f66c8;
    entry_1f6698(rdram, ctx, runtime);
}

void entry_1f67b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f67b0 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f67b0;
    strcmp(rdram, ctx, runtime);
}

void entry_1f67d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f67d4 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f67d4;
    strcmp(rdram, ctx, runtime);
}

void entry_1f67fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f67fc inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f67fc;
    strcmp(rdram, ctx, runtime);
}

void entry_1f6810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6810 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f6810;
    strcmp(rdram, ctx, runtime);
}

void entry_1f682c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f682c inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f682c;
    strcmp(rdram, ctx, runtime);
}

void entry_1f6848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6848 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f6848;
    strcmp(rdram, ctx, runtime);
}

void entry_1f6868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6868 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f6868;
    strcmp(rdram, ctx, runtime);
}

void entry_1f6870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6870 inside strcmp (0x1f6738 - 0x1f6880)
    ctx->pc = 0x1f6870;
    strcmp(rdram, ctx, runtime);
}

void entry_1f6898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6898 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f6898;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f68a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f68a0 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f68a0;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f68b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f68b8 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f68b8;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f68d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f68d8 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f68d8;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f6910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6910 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f6910;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f6920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6920 inside FUN_001f6880 (0x1f6880 - 0x1f6950)
    ctx->pc = 0x1f6920;
    FUN_001f6880(rdram, ctx, runtime);
}

void entry_1f6ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6ab0 inside ReferThreadStatus (0x1f6aa0 - 0x1f6ac0)
    ctx->pc = 0x1f6ab0;
    ReferThreadStatus(rdram, ctx, runtime);
}

void entry_1f6d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6d94 inside entry_1f6d90 (0x1f6d90 - 0x1f6da8)
    ctx->pc = 0x1f6d94;
    entry_1f6d90(rdram, ctx, runtime);
}

void entry_1f6dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6dfc inside entry_1f6df8 (0x1f6df8 - 0x1f6e10)
    ctx->pc = 0x1f6dfc;
    entry_1f6df8(rdram, ctx, runtime);
}

void entry_1f6e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6e64 inside entry_1f6e60 (0x1f6e60 - 0x1f6e78)
    ctx->pc = 0x1f6e64;
    entry_1f6e60(rdram, ctx, runtime);
}

void entry_1f6ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f6ecc inside entry_1f6ec8 (0x1f6ec8 - 0x1f6ee0)
    ctx->pc = 0x1f6ecc;
    entry_1f6ec8(rdram, ctx, runtime);
}

void entry_1f7060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7060 inside entry_1f7028 (0x1f7028 - 0x1f7068)
    ctx->pc = 0x1f7060;
    entry_1f7028(rdram, ctx, runtime);
}

void entry_1f70a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f70a8 inside entry_1f7068 (0x1f7068 - 0x1f70c0)
    ctx->pc = 0x1f70a8;
    entry_1f7068(rdram, ctx, runtime);
}

void entry_1f70b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f70b8 inside entry_1f7068 (0x1f7068 - 0x1f70c0)
    ctx->pc = 0x1f70b8;
    entry_1f7068(rdram, ctx, runtime);
}

void entry_1f70c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f70c8 inside entry_1f70c0 (0x1f70c0 - 0x1f70d0)
    ctx->pc = 0x1f70c8;
    entry_1f70c0(rdram, ctx, runtime);
}

void entry_1f70d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f70d8 inside entry_1f70d0 (0x1f70d0 - 0x1f70e0)
    ctx->pc = 0x1f70d8;
    entry_1f70d0(rdram, ctx, runtime);
}

void entry_1f70e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f70e8 inside entry_1f70e0 (0x1f70e0 - 0x1f70f0)
    ctx->pc = 0x1f70e8;
    entry_1f70e0(rdram, ctx, runtime);
}

void entry_1f71b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f71b8 inside entry_1f71b4 (0x1f71b4 - 0x1f71d0)
    ctx->pc = 0x1f71b8;
    entry_1f71b4(rdram, ctx, runtime);
}

void entry_1f7200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7200 inside entry_1f71f8 (0x1f71f8 - 0x1f7250)
    ctx->pc = 0x1f7200;
    entry_1f71f8(rdram, ctx, runtime);
}

void entry_1f7214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7214 inside entry_1f71f8 (0x1f71f8 - 0x1f7250)
    ctx->pc = 0x1f7214;
    entry_1f71f8(rdram, ctx, runtime);
}

void entry_1f721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f721c inside entry_1f71f8 (0x1f71f8 - 0x1f7250)
    ctx->pc = 0x1f721c;
    entry_1f71f8(rdram, ctx, runtime);
}

void entry_1f7254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7254 inside entry_1f7250 (0x1f7250 - 0x1f7270)
    ctx->pc = 0x1f7254;
    entry_1f7250(rdram, ctx, runtime);
}

void entry_1f7258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7258 inside entry_1f7250 (0x1f7250 - 0x1f7270)
    ctx->pc = 0x1f7258;
    entry_1f7250(rdram, ctx, runtime);
}

void entry_1f7278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7278 inside kputchar (0x1f7270 - 0x1f72a8)
    ctx->pc = 0x1f7278;
    kputchar(rdram, ctx, runtime);
}

void entry_1f72f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f72f0 inside entry_1f72e8 (0x1f72e8 - 0x1f7358)
    ctx->pc = 0x1f72f0;
    entry_1f72e8(rdram, ctx, runtime);
}

void entry_1f72f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f72f4 inside entry_1f72e8 (0x1f72e8 - 0x1f7358)
    ctx->pc = 0x1f72f4;
    entry_1f72e8(rdram, ctx, runtime);
}

void entry_1f7330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7330 inside entry_1f72e8 (0x1f72e8 - 0x1f7358)
    ctx->pc = 0x1f7330;
    entry_1f72e8(rdram, ctx, runtime);
}

void entry_1f7380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7380 inside entry_1f7370 (0x1f7370 - 0x1f7390)
    ctx->pc = 0x1f7380;
    entry_1f7370(rdram, ctx, runtime);
}

void entry_1f73b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f73b4 inside ftoi (0x1f7390 - 0x1f7420)
    ctx->pc = 0x1f73b4;
    ftoi(rdram, ctx, runtime);
}

void entry_1f73c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f73c4 inside ftoi (0x1f7390 - 0x1f7420)
    ctx->pc = 0x1f73c4;
    ftoi(rdram, ctx, runtime);
}

void entry_1f7408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7408 inside ftoi (0x1f7390 - 0x1f7420)
    ctx->pc = 0x1f7408;
    ftoi(rdram, ctx, runtime);
}

void entry_1f7414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7414 inside ftoi (0x1f7390 - 0x1f7420)
    ctx->pc = 0x1f7414;
    ftoi(rdram, ctx, runtime);
}

void entry_1f7490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7490 inside entry_1f747c (0x1f747c - 0x1f74a0)
    ctx->pc = 0x1f7490;
    entry_1f747c(rdram, ctx, runtime);
}

void entry_1f74a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f74a4 inside entry_1f74a0 (0x1f74a0 - 0x1f74b4)
    ctx->pc = 0x1f74a4;
    entry_1f74a0(rdram, ctx, runtime);
}

void entry_1f74c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f74c4 inside entry_1f74b4 (0x1f74b4 - 0x1f74d4)
    ctx->pc = 0x1f74c4;
    entry_1f74b4(rdram, ctx, runtime);
}

void entry_1f74e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f74e8 inside entry_1f74d4 (0x1f74d4 - 0x1f74f8)
    ctx->pc = 0x1f74e8;
    entry_1f74d4(rdram, ctx, runtime);
}

void entry_1f74fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f74fc inside entry_1f74f8 (0x1f74f8 - 0x1f750c)
    ctx->pc = 0x1f74fc;
    entry_1f74f8(rdram, ctx, runtime);
}

void entry_1f7514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7514 inside entry_1f750c (0x1f750c - 0x1f7524)
    ctx->pc = 0x1f7514;
    entry_1f750c(rdram, ctx, runtime);
}

void entry_1f7568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7568 inside entry_1f7540 (0x1f7540 - 0x1f7588)
    ctx->pc = 0x1f7568;
    entry_1f7540(rdram, ctx, runtime);
}

void entry_1f75b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f75b8 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f75b8;
    _printf(rdram, ctx, runtime);
}

void entry_1f75d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f75d0 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f75d0;
    _printf(rdram, ctx, runtime);
}

void entry_1f75d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f75d4 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f75d4;
    _printf(rdram, ctx, runtime);
}

void entry_1f75d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f75d8 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f75d8;
    _printf(rdram, ctx, runtime);
}

void entry_1f7654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7654 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7654;
    _printf(rdram, ctx, runtime);
}

void entry_1f7658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7658 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7658;
    _printf(rdram, ctx, runtime);
}

void entry_1f7668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7668 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7668;
    _printf(rdram, ctx, runtime);
}

void entry_1f7694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7694 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7694;
    _printf(rdram, ctx, runtime);
}

void entry_1f76bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f76bc inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f76bc;
    _printf(rdram, ctx, runtime);
}

void entry_1f76cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f76cc inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f76cc;
    _printf(rdram, ctx, runtime);
}

void entry_1f76d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f76d0 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f76d0;
    _printf(rdram, ctx, runtime);
}

void entry_1f76f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f76f0 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f76f0;
    _printf(rdram, ctx, runtime);
}

void entry_1f76f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f76f8 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f76f8;
    _printf(rdram, ctx, runtime);
}

void entry_1f7718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7718 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7718;
    _printf(rdram, ctx, runtime);
}

void entry_1f7724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7724 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7724;
    _printf(rdram, ctx, runtime);
}

void entry_1f7738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7738 inside _printf (0x1f7588 - 0x1f774c)
    ctx->pc = 0x1f7738;
    _printf(rdram, ctx, runtime);
}

void entry_1f7778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7778 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f7778;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f7788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7788 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f7788;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f778c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f778c inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f778c;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77ac inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77ac;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77b0 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77b0;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77c4 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77c4;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77d8 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77d8;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77e4 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77e4;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f77f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f77f8 inside entry_1f774c (0x1f774c - 0x1f780c)
    ctx->pc = 0x1f77f8;
    entry_1f774c(rdram, ctx, runtime);
}

void entry_1f7838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7838 inside entry_1f780c (0x1f780c - 0x1f7880)
    ctx->pc = 0x1f7838;
    entry_1f780c(rdram, ctx, runtime);
}

void entry_1f7848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7848 inside entry_1f780c (0x1f780c - 0x1f7880)
    ctx->pc = 0x1f7848;
    entry_1f780c(rdram, ctx, runtime);
}

void entry_1f784c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f784c inside entry_1f780c (0x1f780c - 0x1f7880)
    ctx->pc = 0x1f784c;
    entry_1f780c(rdram, ctx, runtime);
}

void entry_1f7868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7868 inside entry_1f780c (0x1f780c - 0x1f7880)
    ctx->pc = 0x1f7868;
    entry_1f780c(rdram, ctx, runtime);
}

void entry_1f7890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7890 inside entry_1f7880 (0x1f7880 - 0x1f7898)
    ctx->pc = 0x1f7890;
    entry_1f7880(rdram, ctx, runtime);
}

void entry_1f78c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f78c8 inside entry_1f78b4 (0x1f78b4 - 0x1f78fc)
    ctx->pc = 0x1f78c8;
    entry_1f78b4(rdram, ctx, runtime);
}

void entry_1f78cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f78cc inside entry_1f78b4 (0x1f78b4 - 0x1f78fc)
    ctx->pc = 0x1f78cc;
    entry_1f78b4(rdram, ctx, runtime);
}

void entry_1f78d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f78d8 inside entry_1f78b4 (0x1f78b4 - 0x1f78fc)
    ctx->pc = 0x1f78d8;
    entry_1f78b4(rdram, ctx, runtime);
}

void entry_1f78e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f78e8 inside entry_1f78b4 (0x1f78b4 - 0x1f78fc)
    ctx->pc = 0x1f78e8;
    entry_1f78b4(rdram, ctx, runtime);
}

void entry_1f7928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7928 inside entry_1f78fc (0x1f78fc - 0x1f7970)
    ctx->pc = 0x1f7928;
    entry_1f78fc(rdram, ctx, runtime);
}

void entry_1f7938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7938 inside entry_1f78fc (0x1f78fc - 0x1f7970)
    ctx->pc = 0x1f7938;
    entry_1f78fc(rdram, ctx, runtime);
}

void entry_1f793c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f793c inside entry_1f78fc (0x1f78fc - 0x1f7970)
    ctx->pc = 0x1f793c;
    entry_1f78fc(rdram, ctx, runtime);
}

void entry_1f795c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f795c inside entry_1f78fc (0x1f78fc - 0x1f7970)
    ctx->pc = 0x1f795c;
    entry_1f78fc(rdram, ctx, runtime);
}

void entry_1f7968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7968 inside entry_1f78fc (0x1f78fc - 0x1f7970)
    ctx->pc = 0x1f7968;
    entry_1f78fc(rdram, ctx, runtime);
}

void entry_1f7998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7998 inside entry_1f798c (0x1f798c - 0x1f79cc)
    ctx->pc = 0x1f7998;
    entry_1f798c(rdram, ctx, runtime);
}

void entry_1f79a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f79a4 inside entry_1f798c (0x1f798c - 0x1f79cc)
    ctx->pc = 0x1f79a4;
    entry_1f798c(rdram, ctx, runtime);
}

void entry_1f79b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f79b8 inside entry_1f798c (0x1f798c - 0x1f79cc)
    ctx->pc = 0x1f79b8;
    entry_1f798c(rdram, ctx, runtime);
}

void entry_1f7a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7a14 inside entry_1f7a0c (0x1f7a0c - 0x1f7a1c)
    ctx->pc = 0x1f7a14;
    entry_1f7a0c(rdram, ctx, runtime);
}

void entry_1f7a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7a98 inside entry_1f7a90 (0x1f7a90 - 0x1f7abc)
    ctx->pc = 0x1f7a98;
    entry_1f7a90(rdram, ctx, runtime);
}

void entry_1f7aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7aa8 inside entry_1f7a90 (0x1f7a90 - 0x1f7abc)
    ctx->pc = 0x1f7aa8;
    entry_1f7a90(rdram, ctx, runtime);
}

void entry_1f7af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7af8 inside entry_1f7af0 (0x1f7af0 - 0x1f7b08)
    ctx->pc = 0x1f7af8;
    entry_1f7af0(rdram, ctx, runtime);
}

void entry_1f7b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7b10 inside entry_1f7b08 (0x1f7b08 - 0x1f7b50)
    ctx->pc = 0x1f7b10;
    entry_1f7b08(rdram, ctx, runtime);
}

void entry_1f7b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7b1c inside entry_1f7b08 (0x1f7b08 - 0x1f7b50)
    ctx->pc = 0x1f7b1c;
    entry_1f7b08(rdram, ctx, runtime);
}

void entry_1f7b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7b20 inside entry_1f7b08 (0x1f7b08 - 0x1f7b50)
    ctx->pc = 0x1f7b20;
    entry_1f7b08(rdram, ctx, runtime);
}

void entry_1f7c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7c28 inside entry_1f7c00 (0x1f7c00 - 0x1f7c30)
    ctx->pc = 0x1f7c28;
    entry_1f7c00(rdram, ctx, runtime);
}

void entry_1f7d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7d40 inside entry_1f7d3c (0x1f7d3c - 0x1f7d48)
    ctx->pc = 0x1f7d40;
    entry_1f7d3c(rdram, ctx, runtime);
}

void entry_1f7d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7d70 inside entry_1f7d48 (0x1f7d48 - 0x1f7d88)
    ctx->pc = 0x1f7d70;
    entry_1f7d48(rdram, ctx, runtime);
}

void entry_1f7de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7de0 inside entry_1f7dc8 (0x1f7dc8 - 0x1f7e24)
    ctx->pc = 0x1f7de0;
    entry_1f7dc8(rdram, ctx, runtime);
}

void entry_1f7e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7e18 inside entry_1f7dc8 (0x1f7dc8 - 0x1f7e24)
    ctx->pc = 0x1f7e18;
    entry_1f7dc8(rdram, ctx, runtime);
}

void entry_1f7e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7e2c inside entry_1f7e24 (0x1f7e24 - 0x1f7e40)
    ctx->pc = 0x1f7e2c;
    entry_1f7e24(rdram, ctx, runtime);
}

void entry_1f7e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7e38 inside entry_1f7e24 (0x1f7e24 - 0x1f7e40)
    ctx->pc = 0x1f7e38;
    entry_1f7e24(rdram, ctx, runtime);
}

void entry_1f7e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7e44 inside entry_1f7e40 (0x1f7e40 - 0x1f7e58)
    ctx->pc = 0x1f7e44;
    entry_1f7e40(rdram, ctx, runtime);
}

void entry_1f7e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7e8c inside _sceRpcGetFPacket (0x1f7e78 - 0x1f7ea8)
    ctx->pc = 0x1f7e8c;
    _sceRpcGetFPacket(rdram, ctx, runtime);
}

void entry_1f7ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7ef0 inside _request_end (0x1f7ea8 - 0x1f7f08)
    ctx->pc = 0x1f7ef0;
    _request_end(rdram, ctx, runtime);
}

void entry_1f7f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7f10 inside entry_1f7f08 (0x1f7f08 - 0x1f7f3c)
    ctx->pc = 0x1f7f10;
    entry_1f7f08(rdram, ctx, runtime);
}

void entry_1f7f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7f28 inside entry_1f7f08 (0x1f7f08 - 0x1f7f3c)
    ctx->pc = 0x1f7f28;
    entry_1f7f08(rdram, ctx, runtime);
}

void entry_1f7f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7f2c inside entry_1f7f08 (0x1f7f08 - 0x1f7f3c)
    ctx->pc = 0x1f7f2c;
    entry_1f7f08(rdram, ctx, runtime);
}

void entry_1f7fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7fd0 inside _search_svdata (0x1f7fc0 - 0x1f8010)
    ctx->pc = 0x1f7fd0;
    _search_svdata(rdram, ctx, runtime);
}

void entry_1f7fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7fe0 inside _search_svdata (0x1f7fc0 - 0x1f8010)
    ctx->pc = 0x1f7fe0;
    _search_svdata(rdram, ctx, runtime);
}

void entry_1f7ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7ff0 inside _search_svdata (0x1f7fc0 - 0x1f8010)
    ctx->pc = 0x1f7ff0;
    _search_svdata(rdram, ctx, runtime);
}

void entry_1f7ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f7ffc inside _search_svdata (0x1f7fc0 - 0x1f8010)
    ctx->pc = 0x1f7ffc;
    _search_svdata(rdram, ctx, runtime);
}

void entry_1f8004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8004 inside _search_svdata (0x1f7fc0 - 0x1f8010)
    ctx->pc = 0x1f8004;
    _search_svdata(rdram, ctx, runtime);
}

void entry_1f807c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f807c inside entry_1f8060 (0x1f8060 - 0x1f80c0)
    ctx->pc = 0x1f807c;
    entry_1f8060(rdram, ctx, runtime);
}

void entry_1f808c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f808c inside entry_1f8060 (0x1f8060 - 0x1f80c0)
    ctx->pc = 0x1f808c;
    entry_1f8060(rdram, ctx, runtime);
}

void entry_1f8150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8150 inside entry_1f8148 (0x1f8148 - 0x1f8170)
    ctx->pc = 0x1f8150;
    entry_1f8148(rdram, ctx, runtime);
}

void entry_1f8190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8190 inside entry_1f8188 (0x1f8188 - 0x1f8198)
    ctx->pc = 0x1f8190;
    entry_1f8188(rdram, ctx, runtime);
}

void entry_1f81a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f81a8 inside entry_1f81a0 (0x1f81a0 - 0x1f81d0)
    ctx->pc = 0x1f81a8;
    entry_1f81a0(rdram, ctx, runtime);
}

void entry_1f81e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f81e4 inside entry_1f81e0 (0x1f81e0 - 0x1f8290)
    ctx->pc = 0x1f81e4;
    entry_1f81e0(rdram, ctx, runtime);
}

void entry_1f821c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f821c inside entry_1f81e0 (0x1f81e0 - 0x1f8290)
    ctx->pc = 0x1f821c;
    entry_1f81e0(rdram, ctx, runtime);
}

void entry_1f8220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8220 inside entry_1f81e0 (0x1f81e0 - 0x1f8290)
    ctx->pc = 0x1f8220;
    entry_1f81e0(rdram, ctx, runtime);
}

void entry_1f8284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8284 inside entry_1f81e0 (0x1f81e0 - 0x1f8290)
    ctx->pc = 0x1f8284;
    entry_1f81e0(rdram, ctx, runtime);
}

void entry_1f8354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8354 inside entry_1f834c (0x1f834c - 0x1f8364)
    ctx->pc = 0x1f8354;
    entry_1f834c(rdram, ctx, runtime);
}

void entry_1f8378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8378 inside entry_1f8374 (0x1f8374 - 0x1f83bc)
    ctx->pc = 0x1f8378;
    entry_1f8374(rdram, ctx, runtime);
}

void entry_1f8390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8390 inside entry_1f8374 (0x1f8374 - 0x1f83bc)
    ctx->pc = 0x1f8390;
    entry_1f8374(rdram, ctx, runtime);
}

void entry_1f8394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8394 inside entry_1f8374 (0x1f8374 - 0x1f83bc)
    ctx->pc = 0x1f8394;
    entry_1f8374(rdram, ctx, runtime);
}

void entry_1f83cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f83cc inside entry_1f83bc (0x1f83bc - 0x1f83dc)
    ctx->pc = 0x1f83cc;
    entry_1f83bc(rdram, ctx, runtime);
}

void entry_1f83f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f83f4 inside entry_1f83ec (0x1f83ec - 0x1f8418)
    ctx->pc = 0x1f83f4;
    entry_1f83ec(rdram, ctx, runtime);
}

void entry_1f8438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8438 inside entry_1f8430 (0x1f8430 - 0x1f8440)
    ctx->pc = 0x1f8438;
    entry_1f8430(rdram, ctx, runtime);
}

void entry_1f844c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f844c inside entry_1f8448 (0x1f8448 - 0x1f8480)
    ctx->pc = 0x1f844c;
    entry_1f8448(rdram, ctx, runtime);
}

void entry_1f84ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f84ac inside sceSifCheckStatRpc (0x1f8480 - 0x1f84d8)
    ctx->pc = 0x1f84ac;
    sceSifCheckStatRpc(rdram, ctx, runtime);
}

void entry_1f84b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f84b4 inside sceSifCheckStatRpc (0x1f8480 - 0x1f84d8)
    ctx->pc = 0x1f84b4;
    sceSifCheckStatRpc(rdram, ctx, runtime);
}

void entry_1f8528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8528 inside entry_1f851c (0x1f851c - 0x1f8538)
    ctx->pc = 0x1f8528;
    entry_1f851c(rdram, ctx, runtime);
}

void entry_1f8578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8578 inside entry_1f8570 (0x1f8570 - 0x1f858c)
    ctx->pc = 0x1f8578;
    entry_1f8570(rdram, ctx, runtime);
}

void entry_1f8590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8590 inside entry_1f858c (0x1f858c - 0x1f85a8)
    ctx->pc = 0x1f8590;
    entry_1f858c(rdram, ctx, runtime);
}

void entry_1f8690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8690 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f8690;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f86b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f86b0 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f86b0;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f86b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f86b4 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f86b4;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f86d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f86d0 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f86d0;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f8734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8734 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f8734;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f8790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8790 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f8790;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f87c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f87c4 inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f87c4;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f88dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f88dc inside entry_1f8634 (0x1f8634 - 0x1f88e8)
    ctx->pc = 0x1f88dc;
    entry_1f8634(rdram, ctx, runtime);
}

void entry_1f88ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f88ec inside entry_1f88e8 (0x1f88e8 - 0x1f895c)
    ctx->pc = 0x1f88ec;
    entry_1f88e8(rdram, ctx, runtime);
}

void entry_1f8920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8920 inside entry_1f88e8 (0x1f88e8 - 0x1f895c)
    ctx->pc = 0x1f8920;
    entry_1f88e8(rdram, ctx, runtime);
}

void entry_1f8924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8924 inside entry_1f88e8 (0x1f88e8 - 0x1f895c)
    ctx->pc = 0x1f8924;
    entry_1f88e8(rdram, ctx, runtime);
}

void entry_1f8954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8954 inside entry_1f88e8 (0x1f88e8 - 0x1f895c)
    ctx->pc = 0x1f8954;
    entry_1f88e8(rdram, ctx, runtime);
}

void entry_1f8960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8960 inside entry_1f895c (0x1f895c - 0x1f8968)
    ctx->pc = 0x1f8960;
    entry_1f895c(rdram, ctx, runtime);
}

void entry_1f89a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f89a8 inside entry_1f89a0 (0x1f89a0 - 0x1f89b8)
    ctx->pc = 0x1f89a8;
    entry_1f89a0(rdram, ctx, runtime);
}

void entry_1f8aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8aa8 inside entry_1f8a9c (0x1f8a9c - 0x1f8ae4)
    ctx->pc = 0x1f8aa8;
    entry_1f8a9c(rdram, ctx, runtime);
}

void entry_1f8ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ab0 inside entry_1f8a9c (0x1f8a9c - 0x1f8ae4)
    ctx->pc = 0x1f8ab0;
    entry_1f8a9c(rdram, ctx, runtime);
}

void entry_1f8ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ad0 inside entry_1f8a9c (0x1f8a9c - 0x1f8ae4)
    ctx->pc = 0x1f8ad0;
    entry_1f8a9c(rdram, ctx, runtime);
}

void entry_1f8b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8b28 inside entry_1f8b08 (0x1f8b08 - 0x1f8b60)
    ctx->pc = 0x1f8b28;
    entry_1f8b08(rdram, ctx, runtime);
}

void entry_1f8b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8b4c inside entry_1f8b08 (0x1f8b08 - 0x1f8b60)
    ctx->pc = 0x1f8b4c;
    entry_1f8b08(rdram, ctx, runtime);
}

void entry_1f8b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8b58 inside entry_1f8b08 (0x1f8b08 - 0x1f8b60)
    ctx->pc = 0x1f8b58;
    entry_1f8b08(rdram, ctx, runtime);
}

void entry_1f8ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ba4 inside entry_1f8b90 (0x1f8b90 - 0x1f8bf8)
    ctx->pc = 0x1f8ba4;
    entry_1f8b90(rdram, ctx, runtime);
}

void entry_1f8bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8bd0 inside entry_1f8b90 (0x1f8b90 - 0x1f8bf8)
    ctx->pc = 0x1f8bd0;
    entry_1f8b90(rdram, ctx, runtime);
}

void entry_1f8c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8c8c inside entry_1f8c84 (0x1f8c84 - 0x1f8ca8)
    ctx->pc = 0x1f8c8c;
    entry_1f8c84(rdram, ctx, runtime);
}

void entry_1f8ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ca0 inside entry_1f8c84 (0x1f8c84 - 0x1f8ca8)
    ctx->pc = 0x1f8ca0;
    entry_1f8c84(rdram, ctx, runtime);
}

void entry_1f8cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8cb0 inside entry_1f8ca8 (0x1f8ca8 - 0x1f8ce0)
    ctx->pc = 0x1f8cb0;
    entry_1f8ca8(rdram, ctx, runtime);
}

void entry_1f8d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8d4c inside entry_1f8d44 (0x1f8d44 - 0x1f8d5c)
    ctx->pc = 0x1f8d4c;
    entry_1f8d44(rdram, ctx, runtime);
}

void entry_1f8d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8d74 inside entry_1f8d6c (0x1f8d6c - 0x1f8d7c)
    ctx->pc = 0x1f8d74;
    entry_1f8d6c(rdram, ctx, runtime);
}

void entry_1f8d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8d94 inside entry_1f8d84 (0x1f8d84 - 0x1f8db8)
    ctx->pc = 0x1f8d94;
    entry_1f8d84(rdram, ctx, runtime);
}

void entry_1f8e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8e24 inside entry_1f8e1c (0x1f8e1c - 0x1f8e40)
    ctx->pc = 0x1f8e24;
    entry_1f8e1c(rdram, ctx, runtime);
}

void entry_1f8e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8e38 inside entry_1f8e1c (0x1f8e1c - 0x1f8e40)
    ctx->pc = 0x1f8e38;
    entry_1f8e1c(rdram, ctx, runtime);
}

void entry_1f8e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8e48 inside entry_1f8e40 (0x1f8e40 - 0x1f8e80)
    ctx->pc = 0x1f8e48;
    entry_1f8e40(rdram, ctx, runtime);
}

void entry_1f8ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ed8 inside entry_1f8eac (0x1f8eac - 0x1f8f18)
    ctx->pc = 0x1f8ed8;
    entry_1f8eac(rdram, ctx, runtime);
}

void entry_1f8edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8edc inside entry_1f8eac (0x1f8eac - 0x1f8f18)
    ctx->pc = 0x1f8edc;
    entry_1f8eac(rdram, ctx, runtime);
}

void entry_1f8f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8f10 inside entry_1f8eac (0x1f8eac - 0x1f8f18)
    ctx->pc = 0x1f8f10;
    entry_1f8eac(rdram, ctx, runtime);
}

void entry_1f8f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8f20 inside entry_1f8f18 (0x1f8f18 - 0x1f8f40)
    ctx->pc = 0x1f8f20;
    entry_1f8f18(rdram, ctx, runtime);
}

void entry_1f8f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8f28 inside entry_1f8f18 (0x1f8f18 - 0x1f8f40)
    ctx->pc = 0x1f8f28;
    entry_1f8f18(rdram, ctx, runtime);
}

void entry_1f8f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8f44 inside entry_1f8f40 (0x1f8f40 - 0x1f8f54)
    ctx->pc = 0x1f8f44;
    entry_1f8f40(rdram, ctx, runtime);
}

void entry_1f8fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8fac inside entry_1f8fa4 (0x1f8fa4 - 0x1f8fb4)
    ctx->pc = 0x1f8fac;
    entry_1f8fa4(rdram, ctx, runtime);
}

void entry_1f8fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8fcc inside entry_1f8fc4 (0x1f8fc4 - 0x1f8fdc)
    ctx->pc = 0x1f8fcc;
    entry_1f8fc4(rdram, ctx, runtime);
}

void entry_1f8fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8fe4 inside entry_1f8fdc (0x1f8fdc - 0x1f8fec)
    ctx->pc = 0x1f8fe4;
    entry_1f8fdc(rdram, ctx, runtime);
}

void entry_1f8ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f8ff8 inside entry_1f8ff4 (0x1f8ff4 - 0x1f9028)
    ctx->pc = 0x1f8ff8;
    entry_1f8ff4(rdram, ctx, runtime);
}

void entry_1f9094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9094 inside entry_1f908c (0x1f908c - 0x1f90b0)
    ctx->pc = 0x1f9094;
    entry_1f908c(rdram, ctx, runtime);
}

void entry_1f90a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f90a8 inside entry_1f908c (0x1f908c - 0x1f90b0)
    ctx->pc = 0x1f90a8;
    entry_1f908c(rdram, ctx, runtime);
}

void entry_1f90b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f90b8 inside entry_1f90b0 (0x1f90b0 - 0x1f90f0)
    ctx->pc = 0x1f90b8;
    entry_1f90b0(rdram, ctx, runtime);
}

void entry_1f9150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9150 inside entry_1f911c (0x1f911c - 0x1f9194)
    ctx->pc = 0x1f9150;
    entry_1f911c(rdram, ctx, runtime);
}

void entry_1f9158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9158 inside entry_1f911c (0x1f911c - 0x1f9194)
    ctx->pc = 0x1f9158;
    entry_1f911c(rdram, ctx, runtime);
}

void entry_1f918c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f918c inside entry_1f911c (0x1f911c - 0x1f9194)
    ctx->pc = 0x1f918c;
    entry_1f911c(rdram, ctx, runtime);
}

void entry_1f919c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f919c inside entry_1f9194 (0x1f9194 - 0x1f91e0)
    ctx->pc = 0x1f919c;
    entry_1f9194(rdram, ctx, runtime);
}

void entry_1f91a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f91a4 inside entry_1f9194 (0x1f9194 - 0x1f91e0)
    ctx->pc = 0x1f91a4;
    entry_1f9194(rdram, ctx, runtime);
}

void entry_1f91b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f91b4 inside entry_1f9194 (0x1f9194 - 0x1f91e0)
    ctx->pc = 0x1f91b4;
    entry_1f9194(rdram, ctx, runtime);
}

void entry_1f91c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f91c0 inside entry_1f9194 (0x1f9194 - 0x1f91e0)
    ctx->pc = 0x1f91c0;
    entry_1f9194(rdram, ctx, runtime);
}

void entry_1f91f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f91f8 inside entry_1f91e0 (0x1f91e0 - 0x1f9248)
    ctx->pc = 0x1f91f8;
    entry_1f91e0(rdram, ctx, runtime);
}

void entry_1f9218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9218 inside entry_1f91e0 (0x1f91e0 - 0x1f9248)
    ctx->pc = 0x1f9218;
    entry_1f91e0(rdram, ctx, runtime);
}

void entry_1f9268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9268 inside entry_1f9260 (0x1f9260 - 0x1f9274)
    ctx->pc = 0x1f9268;
    entry_1f9260(rdram, ctx, runtime);
}

void entry_1f928c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f928c inside entry_1f9284 (0x1f9284 - 0x1f929c)
    ctx->pc = 0x1f928c;
    entry_1f9284(rdram, ctx, runtime);
}

void entry_1f92a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f92a4 inside entry_1f929c (0x1f929c - 0x1f92ac)
    ctx->pc = 0x1f92a4;
    entry_1f929c(rdram, ctx, runtime);
}

void entry_1f92b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f92b8 inside entry_1f92b4 (0x1f92b4 - 0x1f92e8)
    ctx->pc = 0x1f92b8;
    entry_1f92b4(rdram, ctx, runtime);
}

void entry_1f9364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9364 inside entry_1f9350 (0x1f9350 - 0x1f936c)
    ctx->pc = 0x1f9364;
    entry_1f9350(rdram, ctx, runtime);
}

void entry_1f9374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9374 inside entry_1f936c (0x1f936c - 0x1f93b4)
    ctx->pc = 0x1f9374;
    entry_1f936c(rdram, ctx, runtime);
}

void entry_1f939c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f939c inside entry_1f936c (0x1f936c - 0x1f93b4)
    ctx->pc = 0x1f939c;
    entry_1f936c(rdram, ctx, runtime);
}

void entry_1f93ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f93ac inside entry_1f936c (0x1f936c - 0x1f93b4)
    ctx->pc = 0x1f93ac;
    entry_1f936c(rdram, ctx, runtime);
}

void entry_1f93d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f93d8 inside entry_1f93b4 (0x1f93b4 - 0x1f9418)
    ctx->pc = 0x1f93d8;
    entry_1f93b4(rdram, ctx, runtime);
}

void entry_1f93f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f93f0 inside entry_1f93b4 (0x1f93b4 - 0x1f9418)
    ctx->pc = 0x1f93f0;
    entry_1f93b4(rdram, ctx, runtime);
}

void entry_1f93f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f93f4 inside entry_1f93b4 (0x1f93b4 - 0x1f9418)
    ctx->pc = 0x1f93f4;
    entry_1f93b4(rdram, ctx, runtime);
}

void entry_1f9408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9408 inside entry_1f93b4 (0x1f93b4 - 0x1f9418)
    ctx->pc = 0x1f9408;
    entry_1f93b4(rdram, ctx, runtime);
}

void entry_1f9410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9410 inside entry_1f93b4 (0x1f93b4 - 0x1f9418)
    ctx->pc = 0x1f9410;
    entry_1f93b4(rdram, ctx, runtime);
}

void entry_1f9420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9420 inside entry_1f9418 (0x1f9418 - 0x1f9458)
    ctx->pc = 0x1f9420;
    entry_1f9418(rdram, ctx, runtime);
}

void entry_1f943c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f943c inside entry_1f9418 (0x1f9418 - 0x1f9458)
    ctx->pc = 0x1f943c;
    entry_1f9418(rdram, ctx, runtime);
}

void entry_1f9450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9450 inside entry_1f9418 (0x1f9418 - 0x1f9458)
    ctx->pc = 0x1f9450;
    entry_1f9418(rdram, ctx, runtime);
}

void entry_1f9460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9460 inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f9460;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f9480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9480 inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f9480;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f94ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f94ac inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f94ac;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f9508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9508 inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f9508;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f9518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9518 inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f9518;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f954c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f954c inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f954c;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f9550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9550 inside entry_1f9458 (0x1f9458 - 0x1f9568)
    ctx->pc = 0x1f9550;
    entry_1f9458(rdram, ctx, runtime);
}

void entry_1f95d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f95d4 inside entry_1f95cc (0x1f95cc - 0x1f95e0)
    ctx->pc = 0x1f95d4;
    entry_1f95cc(rdram, ctx, runtime);
}

void entry_1f95f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f95f8 inside entry_1f95f0 (0x1f95f0 - 0x1f9600)
    ctx->pc = 0x1f95f8;
    entry_1f95f0(rdram, ctx, runtime);
}

void entry_1f960c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f960c inside entry_1f9608 (0x1f9608 - 0x1f9690)
    ctx->pc = 0x1f960c;
    entry_1f9608(rdram, ctx, runtime);
}

void entry_1f96b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f96b8 inside _lf_bind (0x1f9690 - 0x1f96cc)
    ctx->pc = 0x1f96b8;
    _lf_bind(rdram, ctx, runtime);
}

void entry_1f96dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f96dc inside entry_1f96cc (0x1f96cc - 0x1f9710)
    ctx->pc = 0x1f96dc;
    entry_1f96cc(rdram, ctx, runtime);
}

void entry_1f9724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9724 inside entry_1f9710 (0x1f9710 - 0x1f9790)
    ctx->pc = 0x1f9724;
    entry_1f9710(rdram, ctx, runtime);
}

void entry_1f9744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9744 inside entry_1f9710 (0x1f9710 - 0x1f9790)
    ctx->pc = 0x1f9744;
    entry_1f9710(rdram, ctx, runtime);
}

void entry_1f9750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9750 inside entry_1f9710 (0x1f9710 - 0x1f9790)
    ctx->pc = 0x1f9750;
    entry_1f9710(rdram, ctx, runtime);
}

void entry_1f9774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9774 inside entry_1f9710 (0x1f9710 - 0x1f9790)
    ctx->pc = 0x1f9774;
    entry_1f9710(rdram, ctx, runtime);
}

void entry_1f9778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9778 inside entry_1f9710 (0x1f9710 - 0x1f9790)
    ctx->pc = 0x1f9778;
    entry_1f9710(rdram, ctx, runtime);
}

void entry_1f97fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f97fc inside entry_1f97f8 (0x1f97f8 - 0x1f9820)
    ctx->pc = 0x1f97fc;
    entry_1f97f8(rdram, ctx, runtime);
}

void entry_1f98c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f98c4 inside entry_1f98b0 (0x1f98b0 - 0x1f98d8)
    ctx->pc = 0x1f98c4;
    entry_1f98b0(rdram, ctx, runtime);
}

void entry_1f9910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9910 inside entry_1f98d8 (0x1f98d8 - 0x1f9a08)
    ctx->pc = 0x1f9910;
    entry_1f98d8(rdram, ctx, runtime);
}

void entry_1f996c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f996c inside entry_1f98d8 (0x1f98d8 - 0x1f9a08)
    ctx->pc = 0x1f996c;
    entry_1f98d8(rdram, ctx, runtime);
}

void entry_1f9978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9978 inside entry_1f98d8 (0x1f98d8 - 0x1f9a08)
    ctx->pc = 0x1f9978;
    entry_1f98d8(rdram, ctx, runtime);
}

void entry_1f99ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f99ac inside entry_1f98d8 (0x1f98d8 - 0x1f9a08)
    ctx->pc = 0x1f99ac;
    entry_1f98d8(rdram, ctx, runtime);
}

void entry_1f99f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f99f8 inside entry_1f98d8 (0x1f98d8 - 0x1f9a08)
    ctx->pc = 0x1f99f8;
    entry_1f98d8(rdram, ctx, runtime);
}

void entry_1f9a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9a10 inside entry_1f9a08 (0x1f9a08 - 0x1f9a4c)
    ctx->pc = 0x1f9a10;
    entry_1f9a08(rdram, ctx, runtime);
}

void entry_1f9a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9a1c inside entry_1f9a08 (0x1f9a08 - 0x1f9a4c)
    ctx->pc = 0x1f9a1c;
    entry_1f9a08(rdram, ctx, runtime);
}

void entry_1f9a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9a20 inside entry_1f9a08 (0x1f9a08 - 0x1f9a4c)
    ctx->pc = 0x1f9a20;
    entry_1f9a08(rdram, ctx, runtime);
}

void entry_1f9a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9a60 inside entry_1f9a4c (0x1f9a4c - 0x1f9a90)
    ctx->pc = 0x1f9a60;
    entry_1f9a4c(rdram, ctx, runtime);
}

void entry_1f9a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9a68 inside entry_1f9a4c (0x1f9a4c - 0x1f9a90)
    ctx->pc = 0x1f9a68;
    entry_1f9a4c(rdram, ctx, runtime);
}

void entry_1f9b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9b28 inside entry_1f9b00 (0x1f9b00 - 0x1f9ba4)
    ctx->pc = 0x1f9b28;
    entry_1f9b00(rdram, ctx, runtime);
}

void entry_1f9b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9b48 inside entry_1f9b00 (0x1f9b00 - 0x1f9ba4)
    ctx->pc = 0x1f9b48;
    entry_1f9b00(rdram, ctx, runtime);
}

void entry_1f9bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9bfc inside entry_1f9bf4 (0x1f9bf4 - 0x1f9c18)
    ctx->pc = 0x1f9bfc;
    entry_1f9bf4(rdram, ctx, runtime);
}

void entry_1f9c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9c00 inside entry_1f9bf4 (0x1f9bf4 - 0x1f9c18)
    ctx->pc = 0x1f9c00;
    entry_1f9bf4(rdram, ctx, runtime);
}

void entry_1f9c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9c44 inside entry_1f9c40 (0x1f9c40 - 0x1f9c50)
    ctx->pc = 0x1f9c44;
    entry_1f9c40(rdram, ctx, runtime);
}

void entry_1f9c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9c78 inside sceSifRebootIop (0x1f9c50 - 0x1f9cbc)
    ctx->pc = 0x1f9c78;
    sceSifRebootIop(rdram, ctx, runtime);
}

void entry_1f9c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9c9c inside sceSifRebootIop (0x1f9c50 - 0x1f9cbc)
    ctx->pc = 0x1f9c9c;
    sceSifRebootIop(rdram, ctx, runtime);
}

void entry_1f9ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9ca4 inside sceSifRebootIop (0x1f9c50 - 0x1f9cbc)
    ctx->pc = 0x1f9ca4;
    sceSifRebootIop(rdram, ctx, runtime);
}

void entry_1f9cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9cc4 inside entry_1f9cbc (0x1f9cbc - 0x1f9ccc)
    ctx->pc = 0x1f9cc4;
    entry_1f9cbc(rdram, ctx, runtime);
}

void entry_1f9ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9ce8 inside entry_1f9cd4 (0x1f9cd4 - 0x1f9d4c)
    ctx->pc = 0x1f9ce8;
    entry_1f9cd4(rdram, ctx, runtime);
}

void entry_1f9d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d0c inside entry_1f9cd4 (0x1f9cd4 - 0x1f9d4c)
    ctx->pc = 0x1f9d0c;
    entry_1f9cd4(rdram, ctx, runtime);
}

void entry_1f9d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d14 inside entry_1f9cd4 (0x1f9cd4 - 0x1f9d4c)
    ctx->pc = 0x1f9d14;
    entry_1f9cd4(rdram, ctx, runtime);
}

void entry_1f9d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d20 inside entry_1f9cd4 (0x1f9cd4 - 0x1f9d4c)
    ctx->pc = 0x1f9d20;
    entry_1f9cd4(rdram, ctx, runtime);
}

void entry_1f9d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d40 inside entry_1f9cd4 (0x1f9cd4 - 0x1f9d4c)
    ctx->pc = 0x1f9d40;
    entry_1f9cd4(rdram, ctx, runtime);
}

void entry_1f9d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d78 inside DIntr (0x1f9d60 - 0x1f9da8)
    ctx->pc = 0x1f9d78;
    DIntr(rdram, ctx, runtime);
}

void entry_1f9d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9d9c inside DIntr (0x1f9d60 - 0x1f9da8)
    ctx->pc = 0x1f9d9c;
    DIntr(rdram, ctx, runtime);
}

void entry_1f9f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9f18 inside FUN_001f9ef8 (0x1f9ef8 - 0x1f9f40)
    ctx->pc = 0x1f9f18;
    FUN_001f9ef8(rdram, ctx, runtime);
}

void entry_1f9f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1f9f38 inside FUN_001f9ef8 (0x1f9ef8 - 0x1f9f40)
    ctx->pc = 0x1f9f38;
    FUN_001f9ef8(rdram, ctx, runtime);
}

void entry_1fa028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa028 inside entry_1fa024 (0x1fa024 - 0x1fa030)
    ctx->pc = 0x1fa028;
    entry_1fa024(rdram, ctx, runtime);
}

void entry_1fa04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa04c inside entry_1fa040 (0x1fa040 - 0x1fa068)
    ctx->pc = 0x1fa04c;
    entry_1fa040(rdram, ctx, runtime);
}

void entry_1fa238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa238 inside entry_1fa208 (0x1fa208 - 0x1fa31c)
    ctx->pc = 0x1fa238;
    entry_1fa208(rdram, ctx, runtime);
}

void entry_1fa2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa2a0 inside entry_1fa208 (0x1fa208 - 0x1fa31c)
    ctx->pc = 0x1fa2a0;
    entry_1fa208(rdram, ctx, runtime);
}

void entry_1fa2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa2d0 inside entry_1fa208 (0x1fa208 - 0x1fa31c)
    ctx->pc = 0x1fa2d0;
    entry_1fa208(rdram, ctx, runtime);
}

void entry_1fa348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa348 inside entry_1fa324 (0x1fa324 - 0x1fa364)
    ctx->pc = 0x1fa348;
    entry_1fa324(rdram, ctx, runtime);
}

void entry_1fa368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa368 inside entry_1fa364 (0x1fa364 - 0x1fa378)
    ctx->pc = 0x1fa368;
    entry_1fa364(rdram, ctx, runtime);
}

void entry_1fa3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa3dc inside entry_1fa394 (0x1fa394 - 0x1fa3e8)
    ctx->pc = 0x1fa3dc;
    entry_1fa394(rdram, ctx, runtime);
}

void entry_1fa3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa3e0 inside entry_1fa394 (0x1fa394 - 0x1fa3e8)
    ctx->pc = 0x1fa3e0;
    entry_1fa394(rdram, ctx, runtime);
}

void entry_1fa4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa4b4 inside sceSifAddCmdHandler (0x1fa4a0 - 0x1fa4d0)
    ctx->pc = 0x1fa4b4;
    sceSifAddCmdHandler(rdram, ctx, runtime);
}

void entry_1fa4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa4bc inside sceSifAddCmdHandler (0x1fa4a0 - 0x1fa4d0)
    ctx->pc = 0x1fa4bc;
    sceSifAddCmdHandler(rdram, ctx, runtime);
}

void entry_1fa4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa4e4 inside sceSifRemoveCmdHandler (0x1fa4d0 - 0x1fa4f8)
    ctx->pc = 0x1fa4e4;
    sceSifRemoveCmdHandler(rdram, ctx, runtime);
}

void entry_1fa4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa4ec inside sceSifRemoveCmdHandler (0x1fa4d0 - 0x1fa4f8)
    ctx->pc = 0x1fa4ec;
    sceSifRemoveCmdHandler(rdram, ctx, runtime);
}

void entry_1fa540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa540 inside _sceSifSendCmd (0x1fa4f8 - 0x1fa580)
    ctx->pc = 0x1fa540;
    _sceSifSendCmd(rdram, ctx, runtime);
}

void entry_1fa588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa588 inside entry_1fa580 (0x1fa580 - 0x1fa5e8)
    ctx->pc = 0x1fa588;
    entry_1fa580(rdram, ctx, runtime);
}

void entry_1fa594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa594 inside entry_1fa580 (0x1fa580 - 0x1fa5e8)
    ctx->pc = 0x1fa594;
    entry_1fa580(rdram, ctx, runtime);
}

void entry_1fa598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa598 inside entry_1fa580 (0x1fa580 - 0x1fa5e8)
    ctx->pc = 0x1fa598;
    entry_1fa580(rdram, ctx, runtime);
}

void entry_1fa604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa604 inside entry_1fa5fc (0x1fa5fc - 0x1fa60c)
    ctx->pc = 0x1fa604;
    entry_1fa5fc(rdram, ctx, runtime);
}

void entry_1fa610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa610 inside entry_1fa60c (0x1fa60c - 0x1fa630)
    ctx->pc = 0x1fa610;
    entry_1fa60c(rdram, ctx, runtime);
}

void entry_1fa670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa670 inside entry_1fa660 (0x1fa660 - 0x1fa6a0)
    ctx->pc = 0x1fa670;
    entry_1fa660(rdram, ctx, runtime);
}

void entry_1fa710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa710 inside entry_1fa6c4 (0x1fa6c4 - 0x1fa734)
    ctx->pc = 0x1fa710;
    entry_1fa6c4(rdram, ctx, runtime);
}

void entry_1fa72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa72c inside entry_1fa6c4 (0x1fa6c4 - 0x1fa734)
    ctx->pc = 0x1fa72c;
    entry_1fa6c4(rdram, ctx, runtime);
}

void entry_1fa788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa788 inside entry_1fa780 (0x1fa780 - 0x1fa7bc)
    ctx->pc = 0x1fa788;
    entry_1fa780(rdram, ctx, runtime);
}

void entry_1fa7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa7c8 inside entry_1fa7bc (0x1fa7bc - 0x1fa7d8)
    ctx->pc = 0x1fa7c8;
    entry_1fa7bc(rdram, ctx, runtime);
}

void entry_1fa80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa80c inside sceSifWriteBackDCache (0x1fa7d8 - 0x1fa890)
    ctx->pc = 0x1fa80c;
    sceSifWriteBackDCache(rdram, ctx, runtime);
}

void entry_1fa828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa828 inside sceSifWriteBackDCache (0x1fa7d8 - 0x1fa890)
    ctx->pc = 0x1fa828;
    sceSifWriteBackDCache(rdram, ctx, runtime);
}

void entry_1fa82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa82c inside sceSifWriteBackDCache (0x1fa7d8 - 0x1fa890)
    ctx->pc = 0x1fa82c;
    sceSifWriteBackDCache(rdram, ctx, runtime);
}

void entry_1fa87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa87c inside sceSifWriteBackDCache (0x1fa7d8 - 0x1fa890)
    ctx->pc = 0x1fa87c;
    sceSifWriteBackDCache(rdram, ctx, runtime);
}

void entry_1fa8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa8b0 inside kCopy (0x1fa8a0 - 0x1fa8d8)
    ctx->pc = 0x1fa8b0;
    kCopy(rdram, ctx, runtime);
}

void entry_1fa8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa8d0 inside kCopy (0x1fa8a0 - 0x1fa8d8)
    ctx->pc = 0x1fa8d0;
    kCopy(rdram, ctx, runtime);
}

void entry_1fa9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa9ec inside entry_1fa9e4 (0x1fa9e4 - 0x1fa9f4)
    ctx->pc = 0x1fa9ec;
    entry_1fa9e4(rdram, ctx, runtime);
}

void entry_1fa9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fa9f8 inside entry_1fa9f4 (0x1fa9f4 - 0x1faa00)
    ctx->pc = 0x1fa9f8;
    entry_1fa9f4(rdram, ctx, runtime);
}

void entry_1faa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faa90 inside entry_1faa7c (0x1faa7c - 0x1faaa8)
    ctx->pc = 0x1faa90;
    entry_1faa7c(rdram, ctx, runtime);
}

void entry_1faab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faab8 inside entry_1faaa8 (0x1faaa8 - 0x1faadc)
    ctx->pc = 0x1faab8;
    entry_1faaa8(rdram, ctx, runtime);
}

void entry_1faae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faae8 inside entry_1faae4 (0x1faae4 - 0x1fab10)
    ctx->pc = 0x1faae8;
    entry_1faae4(rdram, ctx, runtime);
}

void entry_1faaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faaf8 inside entry_1faae4 (0x1faae4 - 0x1fab10)
    ctx->pc = 0x1faaf8;
    entry_1faae4(rdram, ctx, runtime);
}

void entry_1fab20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fab20 inside entry_1fab10 (0x1fab10 - 0x1fab58)
    ctx->pc = 0x1fab20;
    entry_1fab10(rdram, ctx, runtime);
}

void entry_1fab64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fab64 inside entry_1fab60 (0x1fab60 - 0x1fab88)
    ctx->pc = 0x1fab64;
    entry_1fab60(rdram, ctx, runtime);
}

void entry_1fab70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fab70 inside entry_1fab60 (0x1fab60 - 0x1fab88)
    ctx->pc = 0x1fab70;
    entry_1fab60(rdram, ctx, runtime);
}

void entry_1fab98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fab98 inside entry_1fab88 (0x1fab88 - 0x1fabcc)
    ctx->pc = 0x1fab98;
    entry_1fab88(rdram, ctx, runtime);
}

void entry_1fab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fab9c inside entry_1fab88 (0x1fab88 - 0x1fabcc)
    ctx->pc = 0x1fab9c;
    entry_1fab88(rdram, ctx, runtime);
}

void entry_1fabb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fabb0 inside entry_1fab88 (0x1fab88 - 0x1fabcc)
    ctx->pc = 0x1fabb0;
    entry_1fab88(rdram, ctx, runtime);
}

void entry_1fabd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fabd8 inside entry_1fabcc (0x1fabcc - 0x1fac14)
    ctx->pc = 0x1fabd8;
    entry_1fabcc(rdram, ctx, runtime);
}

void entry_1fad68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fad68 inside entry_1fad58 (0x1fad58 - 0x1fadfc)
    ctx->pc = 0x1fad68;
    entry_1fad58(rdram, ctx, runtime);
}

void entry_1fada8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fada8 inside entry_1fad58 (0x1fad58 - 0x1fadfc)
    ctx->pc = 0x1fada8;
    entry_1fad58(rdram, ctx, runtime);
}

void entry_1fadcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fadcc inside entry_1fad58 (0x1fad58 - 0x1fadfc)
    ctx->pc = 0x1fadcc;
    entry_1fad58(rdram, ctx, runtime);
}

void entry_1fadf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fadf0 inside entry_1fad58 (0x1fad58 - 0x1fadfc)
    ctx->pc = 0x1fadf0;
    entry_1fad58(rdram, ctx, runtime);
}

void entry_1fae04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fae04 inside entry_1fadfc (0x1fadfc - 0x1fae18)
    ctx->pc = 0x1fae04;
    entry_1fadfc(rdram, ctx, runtime);
}

void entry_1fae30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fae30 inside __main__Fv (0x1fae18 - 0x1fae38)
    ctx->pc = 0x1fae30;
    fn___main__Fv(rdram, ctx, runtime);
}

void entry_1faea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faea8 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1faea8;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1faf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faf04 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1faf04;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1faf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faf50 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1faf50;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1faf68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1faf68 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1faf68;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fafa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fafa4 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fafa4;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fafbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fafbc inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fafbc;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb010 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb010;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb014 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb014;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb01c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb01c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb068 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb068;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb07c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb07c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb090 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb090;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb0a8 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb0a8;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb0c0 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb0c0;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb0d8 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb0d8;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb114 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb114;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb148 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb148;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb1a0 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb1a0;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb1a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb1a4 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb1a4;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb1ac inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb1ac;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb204 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb204;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb208 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb208;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb218 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb218;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb230 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb230;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb280 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb280;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb284 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb284;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb28c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb28c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb2d8 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb2d8;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb2ec inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb2ec;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb2fc inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb2fc;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb318 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb318;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb330 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb330;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb378 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb378;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb3b4 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb3b4;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb408 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb408;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb40c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb40c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb414 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb414;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb46c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb46c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb470 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb470;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb4b0 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb4b0;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb4b8 inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb4b8;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb4bc inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb4bc;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb51c inside __divdi3 (0x1fae38 - 0x1fb528)
    ctx->pc = 0x1fb51c;
    fn___divdi3(rdram, ctx, runtime);
}

void entry_1fb584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb584 inside entry_1fb57c (0x1fb57c - 0x1fb590)
    ctx->pc = 0x1fb584;
    entry_1fb57c(rdram, ctx, runtime);
}

void entry_1fb5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb5a0 inside entry_1fb59c (0x1fb59c - 0x1fb5a8)
    ctx->pc = 0x1fb5a0;
    entry_1fb59c(rdram, ctx, runtime);
}

void entry_1fb5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb5e4 inside entry_1fb5d4 (0x1fb5d4 - 0x1fb5ec)
    ctx->pc = 0x1fb5e4;
    entry_1fb5d4(rdram, ctx, runtime);
}

void entry_1fb5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb5f8 inside entry_1fb5ec (0x1fb5ec - 0x1fb618)
    ctx->pc = 0x1fb5f8;
    entry_1fb5ec(rdram, ctx, runtime);
}

void entry_1fb5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb5fc inside entry_1fb5ec (0x1fb5ec - 0x1fb618)
    ctx->pc = 0x1fb5fc;
    entry_1fb5ec(rdram, ctx, runtime);
}

void entry_1fb694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb694 inside entry_1fb690 (0x1fb690 - 0x1fb69c)
    ctx->pc = 0x1fb694;
    entry_1fb690(rdram, ctx, runtime);
}

void entry_1fb700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb700 inside __floatdisf (0x1fb6b0 - 0x1fb714)
    ctx->pc = 0x1fb700;
    fn___floatdisf(rdram, ctx, runtime);
}

void entry_1fb768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb768 inside entry_1fb764 (0x1fb764 - 0x1fb770)
    ctx->pc = 0x1fb768;
    entry_1fb764(rdram, ctx, runtime);
}

void entry_1fb804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb804 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb804;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb858 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb858;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb8a8 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb8a8;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb8c0 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb8c0;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb8fc inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb8fc;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb910 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb910;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb924 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb924;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb938 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb938;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb950 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb950;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb968 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb968;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb9a0 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb9a0;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fb9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fb9d4 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fb9d4;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba20 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba20;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba24 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba24;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba34 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba34;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba78 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba78;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba7c inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba7c;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba88 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba88;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fba94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fba94 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fba94;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbad8 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbad8;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbadc inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbadc;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbaec inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbaec;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbb2c inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbb2c;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbb44 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbb44;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbb64 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbb64;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbb88 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbb88;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbba0 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbba0;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbbe0 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbbe0;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbbf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbbf0 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbbf0;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbc08 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbc08;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbc44 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbc44;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbc98 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbc98;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbc9c inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbc9c;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbca4 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbca4;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbcfc inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbcfc;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbd00 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbd00;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbd40 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbd40;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbd50 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbd50;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbd88 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbd88;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbd8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbd8c inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbd8c;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbde8 inside FUN_001fb790 (0x1fb790 - 0x1fbe00)
    ctx->pc = 0x1fbde8;
    FUN_001fb790(rdram, ctx, runtime);
}

void entry_1fbe48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbe48 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbe48;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbe60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbe60 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbe60;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbe9c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbe9c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbeb4 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbeb4;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf08 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf08;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf0c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf0c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf14 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf14;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf60 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf60;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf74 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf74;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbf88 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbf88;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbfa0 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbfa0;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbfb8 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbfb8;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fbfd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fbfd0 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fbfd0;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc00c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc00c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc040 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc040;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc098 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc098;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc09c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc09c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc0a4 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc0a4;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc0fc inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc0fc;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc100 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc100;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc110 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc110;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc128 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc128;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc178 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc178;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc17c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc17c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc184 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc184;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc1d0 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc1d0;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc1e4 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc1e4;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc1f8 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc1f8;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc218 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc218;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc230 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc230;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc278 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc278;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc2b4 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc2b4;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc308 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc308;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc30c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc30c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc314 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc314;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc36c inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc36c;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc370 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc370;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc3b0 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc3b0;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc3b8 inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc3b8;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc3bc inside FUN_001fbe00 (0x1fbe00 - 0x1fc3d0)
    ctx->pc = 0x1fc3bc;
    FUN_001fbe00(rdram, ctx, runtime);
}

void entry_1fc420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc420 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc420;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc438 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc438;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc474 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc474;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc488 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc488;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc49c inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc49c;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc4b0 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc4b0;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc4c8 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc4c8;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc4e0 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc4e0;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc518 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc518;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc54c inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc54c;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc598 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc598;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc59c inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc59c;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc5ac inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc5ac;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc5f0 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc5f0;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc5f4 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc5f4;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc600 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc600;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc60c inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc60c;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc650 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc650;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc654 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc654;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc664 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc664;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc6a4 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc6a4;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc6bc inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc6bc;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc6dc inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc6dc;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc700 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc700;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc718 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc718;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc758 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc758;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc768 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc768;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc780 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc780;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc7bc inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc7bc;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc810 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc810;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc814 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc814;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc81c inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc81c;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc874 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc874;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc878 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc878;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc8b8 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc8b8;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc8c8 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc8c8;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc900 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc900;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc904 inside __umoddi3 (0x1fc3d0 - 0x1fc910)
    ctx->pc = 0x1fc904;
    fn___umoddi3(rdram, ctx, runtime);
}

void entry_1fc93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc93c inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc93c;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc95c inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc95c;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc98c inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc98c;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc99c inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc99c;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc9a4 inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc9a4;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc9c0 inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc9c0;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc9dc inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc9dc;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fc9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fc9e0 inside __pack_d (0x1fc910 - 0x1fca40)
    ctx->pc = 0x1fc9e0;
    fn___pack_d(rdram, ctx, runtime);
}

void entry_1fca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fca78 inside __unpack_d (0x1fca40 - 0x1fcae0)
    ctx->pc = 0x1fca78;
    fn___unpack_d(rdram, ctx, runtime);
}

void entry_1fca90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fca90 inside __unpack_d (0x1fca40 - 0x1fcae0)
    ctx->pc = 0x1fca90;
    fn___unpack_d(rdram, ctx, runtime);
}

void entry_1fcaac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcaac inside __unpack_d (0x1fca40 - 0x1fcae0)
    ctx->pc = 0x1fcaac;
    fn___unpack_d(rdram, ctx, runtime);
}

void entry_1fcab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcab0 inside __unpack_d (0x1fca40 - 0x1fcae0)
    ctx->pc = 0x1fcab0;
    fn___unpack_d(rdram, ctx, runtime);
}

void entry_1fcab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcab8 inside __unpack_d (0x1fca40 - 0x1fcae0)
    ctx->pc = 0x1fcab8;
    fn___unpack_d(rdram, ctx, runtime);
}

void entry_1fcaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcaf4 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcaf4;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcafc inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcafc;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcb08 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcb08;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcb10 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcb10;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcb38 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcb38;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcb7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcb7c inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcb7c;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcbc0 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcbc0;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcbe4 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcbe4;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcbec inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcbec;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcbf8 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcbf8;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc1c inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc1c;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc34 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc34;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc40 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc40;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc54 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc54;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc6c inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc6c;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcc7c inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcc7c;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcca8 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcca8;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fccd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fccd4 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fccd4;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcce4 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcce4;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fcd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcd18 inside _fpadd_parts (0x1fcae0 - 0x1fcd20)
    ctx->pc = 0x1fcd18;
    _fpadd_parts(rdram, ctx, runtime);
}

void entry_1fce6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fce6c inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fce6c;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fce7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fce7c inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fce7c;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fce88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fce88 inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fce88;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fce90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fce90 inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fce90;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fce98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fce98 inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fce98;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fceac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fceac inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fceac;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fceb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fceb8 inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fceb8;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fced0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fced0 inside entry_1fce2c (0x1fce2c - 0x1fcef8)
    ctx->pc = 0x1fced0;
    entry_1fce2c(rdram, ctx, runtime);
}

void entry_1fcfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcfa0 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fcfa0;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fcfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcfb8 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fcfb8;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fcfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcfcc inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fcfcc;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fcff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fcff8 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fcff8;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd020 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fd020;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd040 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fd040;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd044 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fd044;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd048 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fd048;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd054 inside entry_1fcf28 (0x1fcf28 - 0x1fd05c)
    ctx->pc = 0x1fd054;
    entry_1fcf28(rdram, ctx, runtime);
}

void entry_1fd0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd0d0 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd0d0;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd104 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd104;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd118 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd118;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd130 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd130;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd148 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd148;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd174 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd174;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd188 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd188;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd18c inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd18c;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd1a0 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd1a0;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd1cc inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd1cc;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd1d0 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd1d0;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd1d4 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd1d4;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd1d8 inside entry_1fd0b8 (0x1fd0b8 - 0x1fd1e0)
    ctx->pc = 0x1fd1d8;
    entry_1fd0b8(rdram, ctx, runtime);
}

void entry_1fd210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd210 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd210;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd218 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd218;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd238 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd238;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd248 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd248;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd264 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd264;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd27c inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd27c;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd28c inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd28c;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd2a8 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd2a8;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd2b4 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd2b4;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd2d4 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd2d4;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd2e0 inside __fpcmp_parts_d (0x1fd1f0 - 0x1fd308)
    ctx->pc = 0x1fd2e0;
    fn___fpcmp_parts_d(rdram, ctx, runtime);
}

void entry_1fd380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd380 inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd380;
    litodp(rdram, ctx, runtime);
}

void entry_1fd3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd3a8 inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd3a8;
    litodp(rdram, ctx, runtime);
}

void entry_1fd3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd3b0 inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd3b0;
    litodp(rdram, ctx, runtime);
}

void entry_1fd3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd3b4 inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd3b4;
    litodp(rdram, ctx, runtime);
}

void entry_1fd3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd3d8 inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd3d8;
    litodp(rdram, ctx, runtime);
}

void entry_1fd3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd3fc inside litodp (0x1fd358 - 0x1fd404)
    ctx->pc = 0x1fd3fc;
    litodp(rdram, ctx, runtime);
}

void entry_1fd408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd408 inside entry_1fd404 (0x1fd404 - 0x1fd410)
    ctx->pc = 0x1fd408;
    entry_1fd404(rdram, ctx, runtime);
}

void entry_1fd440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd440 inside entry_1fd428 (0x1fd428 - 0x1fd4a8)
    ctx->pc = 0x1fd440;
    entry_1fd428(rdram, ctx, runtime);
}

void entry_1fd448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd448 inside entry_1fd428 (0x1fd428 - 0x1fd4a8)
    ctx->pc = 0x1fd448;
    entry_1fd428(rdram, ctx, runtime);
}

void entry_1fd460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd460 inside entry_1fd428 (0x1fd428 - 0x1fd4a8)
    ctx->pc = 0x1fd460;
    entry_1fd428(rdram, ctx, runtime);
}

void entry_1fd478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd478 inside entry_1fd428 (0x1fd428 - 0x1fd4a8)
    ctx->pc = 0x1fd478;
    entry_1fd428(rdram, ctx, runtime);
}

void entry_1fd498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd498 inside entry_1fd428 (0x1fd428 - 0x1fd4a8)
    ctx->pc = 0x1fd498;
    entry_1fd428(rdram, ctx, runtime);
}

void entry_1fd4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd4d8 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd4d8;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd4e0 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd4e0;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd504 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd504;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd510 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd510;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd528 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd528;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd534 inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd534;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd53c inside entry_1fd4c0 (0x1fd4c0 - 0x1fd548)
    ctx->pc = 0x1fd53c;
    entry_1fd4c0(rdram, ctx, runtime);
}

void entry_1fd5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd5f8 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd5f8;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd614 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd614;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd644 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd644;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd650 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd650;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd65c inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd65c;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd678 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd678;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd688 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd688;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd68c inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd68c;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd690 inside FUN_001fd5d0 (0x1fd5d0 - 0x1fd6e0)
    ctx->pc = 0x1fd690;
    FUN_001fd5d0(rdram, ctx, runtime);
}

void entry_1fd710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd710 inside __unpack_f (0x1fd6e0 - 0x1fd7a0)
    ctx->pc = 0x1fd710;
    fn___unpack_f(rdram, ctx, runtime);
}

void entry_1fd730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd730 inside __unpack_f (0x1fd6e0 - 0x1fd7a0)
    ctx->pc = 0x1fd730;
    fn___unpack_f(rdram, ctx, runtime);
}

void entry_1fd744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd744 inside __unpack_f (0x1fd6e0 - 0x1fd7a0)
    ctx->pc = 0x1fd744;
    fn___unpack_f(rdram, ctx, runtime);
}

void entry_1fd748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd748 inside __unpack_f (0x1fd6e0 - 0x1fd7a0)
    ctx->pc = 0x1fd748;
    fn___unpack_f(rdram, ctx, runtime);
}

void entry_1fd750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd750 inside __unpack_f (0x1fd6e0 - 0x1fd7a0)
    ctx->pc = 0x1fd750;
    fn___unpack_f(rdram, ctx, runtime);
}

void entry_1fd7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd7d0 inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd7d0;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd7d8 inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd7d8;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd7fc inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd7fc;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd808 inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd808;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd820 inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd820;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd82c inside entry_1fd7b8 (0x1fd7b8 - 0x1fd838)
    ctx->pc = 0x1fd82c;
    entry_1fd7b8(rdram, ctx, runtime);
}

void entry_1fd8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd8a8 inside entry_1fd89c (0x1fd89c - 0x1fd8b8)
    ctx->pc = 0x1fd8a8;
    entry_1fd89c(rdram, ctx, runtime);
}

void entry_1fd8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd8c0 inside entry_1fd8b8 (0x1fd8b8 - 0x1fd8c8)
    ctx->pc = 0x1fd8c0;
    entry_1fd8b8(rdram, ctx, runtime);
}

void entry_1fd9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fd9bc inside entry_1fd9b8 (0x1fd9b8 - 0x1fd9c8)
    ctx->pc = 0x1fd9bc;
    entry_1fd9b8(rdram, ctx, runtime);
}

void entry_1fdaac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdaac inside entry_1fda9c (0x1fda9c - 0x1fdac8)
    ctx->pc = 0x1fdaac;
    entry_1fda9c(rdram, ctx, runtime);
}

void entry_1fdab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdab0 inside entry_1fda9c (0x1fda9c - 0x1fdac8)
    ctx->pc = 0x1fdab0;
    entry_1fda9c(rdram, ctx, runtime);
}

void entry_1fdbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdbac inside entry_1fdb5c (0x1fdb5c - 0x1fdbec)
    ctx->pc = 0x1fdbac;
    entry_1fdb5c(rdram, ctx, runtime);
}

void entry_1fdbd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdbd0 inside entry_1fdb5c (0x1fdb5c - 0x1fdbec)
    ctx->pc = 0x1fdbd0;
    entry_1fdb5c(rdram, ctx, runtime);
}

void entry_1fdc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdc00 inside entry_1fdbec (0x1fdbec - 0x1fdc18)
    ctx->pc = 0x1fdc00;
    entry_1fdbec(rdram, ctx, runtime);
}

void entry_1fdc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdc10 inside entry_1fdbec (0x1fdbec - 0x1fdc18)
    ctx->pc = 0x1fdc10;
    entry_1fdbec(rdram, ctx, runtime);
}

void entry_1fdc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdc38 inside entry_1fdc18 (0x1fdc18 - 0x1fdc40)
    ctx->pc = 0x1fdc38;
    entry_1fdc18(rdram, ctx, runtime);
}

void entry_1fdc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdc54 inside entry_1fdc40 (0x1fdc40 - 0x1fdcd0)
    ctx->pc = 0x1fdc54;
    entry_1fdc40(rdram, ctx, runtime);
}

void entry_1fdd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdd30 inside entry_1fdcd0 (0x1fdcd0 - 0x1fdd4c)
    ctx->pc = 0x1fdd30;
    entry_1fdcd0(rdram, ctx, runtime);
}

void entry_1fdd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdd60 inside entry_1fdd4c (0x1fdd4c - 0x1fdd80)
    ctx->pc = 0x1fdd60;
    entry_1fdd4c(rdram, ctx, runtime);
}

void entry_1fdd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdd6c inside entry_1fdd4c (0x1fdd4c - 0x1fdd80)
    ctx->pc = 0x1fdd6c;
    entry_1fdd4c(rdram, ctx, runtime);
}

void entry_1fddac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fddac inside entry_1fdd94 (0x1fdd94 - 0x1fddb4)
    ctx->pc = 0x1fddac;
    entry_1fdd94(rdram, ctx, runtime);
}

void entry_1fddb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fddb8 inside entry_1fddb4 (0x1fddb4 - 0x1fddd8)
    ctx->pc = 0x1fddb8;
    entry_1fddb4(rdram, ctx, runtime);
}

void entry_1fde10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde10 inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde10;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde5c inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde5c;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde64 inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde64;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde7c inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde7c;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde80 inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde80;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde8c inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde8c;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fde90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fde90 inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fde90;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fdea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdea8 inside old_find_exception_handler (0x1fddd8 - 0x1fdeb0)
    ctx->pc = 0x1fdea8;
    old_find_exception_handler(rdram, ctx, runtime);
}

void entry_1fdf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdf2c inside find_exception_handler (0x1fdeb0 - 0x1fdf98)
    ctx->pc = 0x1fdf2c;
    find_exception_handler(rdram, ctx, runtime);
}

void entry_1fdf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdf30 inside find_exception_handler (0x1fdeb0 - 0x1fdf98)
    ctx->pc = 0x1fdf30;
    find_exception_handler(rdram, ctx, runtime);
}

void entry_1fdf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdf60 inside find_exception_handler (0x1fdeb0 - 0x1fdf98)
    ctx->pc = 0x1fdf60;
    find_exception_handler(rdram, ctx, runtime);
}

void entry_1fdfa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdfa8 inside entry_1fdf98 (0x1fdf98 - 0x1fdff8)
    ctx->pc = 0x1fdfa8;
    entry_1fdf98(rdram, ctx, runtime);
}

void entry_1fdfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdfb0 inside entry_1fdf98 (0x1fdf98 - 0x1fdff8)
    ctx->pc = 0x1fdfb0;
    entry_1fdf98(rdram, ctx, runtime);
}

void entry_1fdfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdfb8 inside entry_1fdf98 (0x1fdf98 - 0x1fdff8)
    ctx->pc = 0x1fdfb8;
    entry_1fdf98(rdram, ctx, runtime);
}

void entry_1fdfbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdfbc inside entry_1fdf98 (0x1fdf98 - 0x1fdff8)
    ctx->pc = 0x1fdfbc;
    entry_1fdf98(rdram, ctx, runtime);
}

void entry_1fdfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fdfc8 inside entry_1fdf98 (0x1fdf98 - 0x1fdff8)
    ctx->pc = 0x1fdfc8;
    entry_1fdf98(rdram, ctx, runtime);
}

void entry_1fe028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe028 inside get_reg_addr (0x1fdff8 - 0x1fe074)
    ctx->pc = 0x1fe028;
    get_reg_addr(rdram, ctx, runtime);
}

void entry_1fe048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe048 inside get_reg_addr (0x1fdff8 - 0x1fe074)
    ctx->pc = 0x1fe048;
    get_reg_addr(rdram, ctx, runtime);
}

void entry_1fe06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe06c inside get_reg_addr (0x1fdff8 - 0x1fe074)
    ctx->pc = 0x1fe06c;
    get_reg_addr(rdram, ctx, runtime);
}

void entry_1fe0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe0dc inside entry_1fe0b8 (0x1fe0b8 - 0x1fe0e4)
    ctx->pc = 0x1fe0dc;
    entry_1fe0b8(rdram, ctx, runtime);
}

void entry_1fe130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe130 inside entry_1fe11c (0x1fe11c - 0x1fe148)
    ctx->pc = 0x1fe130;
    entry_1fe11c(rdram, ctx, runtime);
}

void entry_1fe15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe15c inside entry_1fe148 (0x1fe148 - 0x1fe190)
    ctx->pc = 0x1fe15c;
    entry_1fe148(rdram, ctx, runtime);
}

void entry_1fe164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe164 inside entry_1fe148 (0x1fe148 - 0x1fe190)
    ctx->pc = 0x1fe164;
    entry_1fe148(rdram, ctx, runtime);
}

void entry_1fe178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe178 inside entry_1fe148 (0x1fe148 - 0x1fe190)
    ctx->pc = 0x1fe178;
    entry_1fe148(rdram, ctx, runtime);
}

void entry_1fe200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe200 inside throw_helper (0x1fe198 - 0x1fe244)
    ctx->pc = 0x1fe200;
    throw_helper(rdram, ctx, runtime);
}

void entry_1fe214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe214 inside throw_helper (0x1fe198 - 0x1fe244)
    ctx->pc = 0x1fe214;
    throw_helper(rdram, ctx, runtime);
}

void entry_1fe224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe224 inside throw_helper (0x1fe198 - 0x1fe244)
    ctx->pc = 0x1fe224;
    throw_helper(rdram, ctx, runtime);
}

void entry_1fe250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe250 inside entry_1fe244 (0x1fe244 - 0x1fe26c)
    ctx->pc = 0x1fe250;
    entry_1fe244(rdram, ctx, runtime);
}

void entry_1fe274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe274 inside entry_1fe26c (0x1fe26c - 0x1fe280)
    ctx->pc = 0x1fe274;
    entry_1fe26c(rdram, ctx, runtime);
}

void entry_1fe284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe284 inside entry_1fe280 (0x1fe280 - 0x1fe320)
    ctx->pc = 0x1fe284;
    entry_1fe280(rdram, ctx, runtime);
}

void entry_1fe2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe2a8 inside entry_1fe280 (0x1fe280 - 0x1fe320)
    ctx->pc = 0x1fe2a8;
    entry_1fe280(rdram, ctx, runtime);
}

void entry_1fe308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe308 inside entry_1fe280 (0x1fe280 - 0x1fe320)
    ctx->pc = 0x1fe308;
    entry_1fe280(rdram, ctx, runtime);
}

void entry_1fe310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe310 inside entry_1fe280 (0x1fe280 - 0x1fe320)
    ctx->pc = 0x1fe310;
    entry_1fe280(rdram, ctx, runtime);
}

void entry_1fe314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe314 inside entry_1fe280 (0x1fe280 - 0x1fe320)
    ctx->pc = 0x1fe314;
    entry_1fe280(rdram, ctx, runtime);
}

void entry_1fe330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe330 inside entry_1fe320 (0x1fe320 - 0x1fe344)
    ctx->pc = 0x1fe330;
    entry_1fe320(rdram, ctx, runtime);
}

void entry_1fe350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe350 inside entry_1fe344 (0x1fe344 - 0x1fe374)
    ctx->pc = 0x1fe350;
    entry_1fe344(rdram, ctx, runtime);
}

void entry_1fe388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe388 inside entry_1fe384 (0x1fe384 - 0x1fe410)
    ctx->pc = 0x1fe388;
    entry_1fe384(rdram, ctx, runtime);
}

void entry_1fe39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe39c inside entry_1fe384 (0x1fe384 - 0x1fe410)
    ctx->pc = 0x1fe39c;
    entry_1fe384(rdram, ctx, runtime);
}

void entry_1fe3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe3ac inside entry_1fe384 (0x1fe384 - 0x1fe410)
    ctx->pc = 0x1fe3ac;
    entry_1fe384(rdram, ctx, runtime);
}

void entry_1fe400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe400 inside entry_1fe384 (0x1fe384 - 0x1fe410)
    ctx->pc = 0x1fe400;
    entry_1fe384(rdram, ctx, runtime);
}

void entry_1fe428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe428 inside entry_1fe410 (0x1fe410 - 0x1fe448)
    ctx->pc = 0x1fe428;
    entry_1fe410(rdram, ctx, runtime);
}

void entry_1fe44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe44c inside entry_1fe448 (0x1fe448 - 0x1fe464)
    ctx->pc = 0x1fe44c;
    entry_1fe448(rdram, ctx, runtime);
}

void entry_1fe480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe480 inside entry_1fe464 (0x1fe464 - 0x1fe4c8)
    ctx->pc = 0x1fe480;
    entry_1fe464(rdram, ctx, runtime);
}

void entry_1fe48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe48c inside entry_1fe464 (0x1fe464 - 0x1fe4c8)
    ctx->pc = 0x1fe48c;
    entry_1fe464(rdram, ctx, runtime);
}

void entry_1fe564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe564 inside entry_1fe558 (0x1fe558 - 0x1fe57c)
    ctx->pc = 0x1fe564;
    entry_1fe558(rdram, ctx, runtime);
}

void entry_1fe56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe56c inside entry_1fe558 (0x1fe558 - 0x1fe57c)
    ctx->pc = 0x1fe56c;
    entry_1fe558(rdram, ctx, runtime);
}

void entry_1fe594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe594 inside entry_1fe590 (0x1fe590 - 0x1fe608)
    ctx->pc = 0x1fe594;
    entry_1fe590(rdram, ctx, runtime);
}

void entry_1fe5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe5a8 inside entry_1fe590 (0x1fe590 - 0x1fe608)
    ctx->pc = 0x1fe5a8;
    entry_1fe590(rdram, ctx, runtime);
}

void entry_1fe640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe640 inside entry_1fe608 (0x1fe608 - 0x1fe6a8)
    ctx->pc = 0x1fe640;
    entry_1fe608(rdram, ctx, runtime);
}

void entry_1fe77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe77c inside entry_1fe778 (0x1fe778 - 0x1fe7f0)
    ctx->pc = 0x1fe77c;
    entry_1fe778(rdram, ctx, runtime);
}

void entry_1fe790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe790 inside entry_1fe778 (0x1fe778 - 0x1fe7f0)
    ctx->pc = 0x1fe790;
    entry_1fe778(rdram, ctx, runtime);
}

void entry_1fe828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe828 inside entry_1fe7f0 (0x1fe7f0 - 0x1fe8f0)
    ctx->pc = 0x1fe828;
    entry_1fe7f0(rdram, ctx, runtime);
}

void entry_1fe890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fe890 inside entry_1fe7f0 (0x1fe7f0 - 0x1fe8f0)
    ctx->pc = 0x1fe890;
    entry_1fe7f0(rdram, ctx, runtime);
}

void entry_1fea3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fea3c inside __cplus_type_matcher (0x1fea18 - 0x1fea5c)
    ctx->pc = 0x1fea3c;
    fn___cplus_type_matcher(rdram, ctx, runtime);
}

void entry_1fea54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fea54 inside __cplus_type_matcher (0x1fea18 - 0x1fea5c)
    ctx->pc = 0x1fea54;
    fn___cplus_type_matcher(rdram, ctx, runtime);
}

void entry_1fea74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fea74 inside entry_1fea6c (0x1fea6c - 0x1fea88)
    ctx->pc = 0x1fea74;
    entry_1fea6c(rdram, ctx, runtime);
}

void entry_1feb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feb58 inside entry_1feb2c (0x1feb2c - 0x1feb94)
    ctx->pc = 0x1feb58;
    entry_1feb2c(rdram, ctx, runtime);
}

void entry_1feb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feb70 inside entry_1feb2c (0x1feb2c - 0x1feb94)
    ctx->pc = 0x1feb70;
    entry_1feb2c(rdram, ctx, runtime);
}

void entry_1feb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feb74 inside entry_1feb2c (0x1feb2c - 0x1feb94)
    ctx->pc = 0x1feb74;
    entry_1feb2c(rdram, ctx, runtime);
}

void entry_1feb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feb84 inside entry_1feb2c (0x1feb2c - 0x1feb94)
    ctx->pc = 0x1feb84;
    entry_1feb2c(rdram, ctx, runtime);
}

void entry_1feb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feb8c inside entry_1feb2c (0x1feb2c - 0x1feb94)
    ctx->pc = 0x1feb8c;
    entry_1feb2c(rdram, ctx, runtime);
}

void entry_1febd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1febd0 inside entry_1febcc (0x1febcc - 0x1febe0)
    ctx->pc = 0x1febd0;
    entry_1febcc(rdram, ctx, runtime);
}

void entry_1fec50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fec50 inside entry_1fec3c (0x1fec3c - 0x1fec60)
    ctx->pc = 0x1fec50;
    entry_1fec3c(rdram, ctx, runtime);
}

void entry_1fec80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fec80 inside entry_1fec78 (0x1fec78 - 0x1fec88)
    ctx->pc = 0x1fec80;
    entry_1fec78(rdram, ctx, runtime);
}

void entry_1fecb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fecb8 inside entry_1fec98 (0x1fec98 - 0x1fecc8)
    ctx->pc = 0x1fecb8;
    entry_1fec98(rdram, ctx, runtime);
}

void entry_1fece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fece8 inside entry_1fece0 (0x1fece0 - 0x1fecf0)
    ctx->pc = 0x1fece8;
    entry_1fece0(rdram, ctx, runtime);
}

void entry_1fed00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fed00 inside entry_1fecf0 (0x1fecf0 - 0x1fed14)
    ctx->pc = 0x1fed00;
    entry_1fecf0(rdram, ctx, runtime);
}

void entry_1fed3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fed3c inside entry_1fed30 (0x1fed30 - 0x1fed44)
    ctx->pc = 0x1fed3c;
    entry_1fed30(rdram, ctx, runtime);
}

void entry_1fed88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fed88 inside entry_1fed78 (0x1fed78 - 0x1fed90)
    ctx->pc = 0x1fed88;
    entry_1fed78(rdram, ctx, runtime);
}

void entry_1fee00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fee00 inside entry_1fedf4 (0x1fedf4 - 0x1fee08)
    ctx->pc = 0x1fee00;
    entry_1fedf4(rdram, ctx, runtime);
}

void entry_1fee80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fee80 inside entry_1fee74 (0x1fee74 - 0x1fee88)
    ctx->pc = 0x1fee80;
    entry_1fee74(rdram, ctx, runtime);
}

void entry_1feeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1feeec inside entry_1feed8 (0x1feed8 - 0x1fef00)
    ctx->pc = 0x1feeec;
    entry_1feed8(rdram, ctx, runtime);
}

void entry_1ff060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff060 inside decode_uleb128 (0x1ff048 - 0x1ff090)
    ctx->pc = 0x1ff060;
    decode_uleb128(rdram, ctx, runtime);
}

void entry_1ff080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff080 inside decode_uleb128 (0x1ff048 - 0x1ff090)
    ctx->pc = 0x1ff080;
    decode_uleb128(rdram, ctx, runtime);
}

void entry_1ff098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff098 inside decode_sleb128 (0x1ff090 - 0x1ff0e0)
    ctx->pc = 0x1ff098;
    decode_sleb128(rdram, ctx, runtime);
}

void entry_1ff0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff0d4 inside decode_sleb128 (0x1ff090 - 0x1ff0e0)
    ctx->pc = 0x1ff0d4;
    decode_sleb128(rdram, ctx, runtime);
}

void entry_1ff138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff138 inside fde_merge (0x1ff0e0 - 0x1ff1e0)
    ctx->pc = 0x1ff138;
    fde_merge(rdram, ctx, runtime);
}

void entry_1ff178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff178 inside fde_merge (0x1ff0e0 - 0x1ff1e0)
    ctx->pc = 0x1ff178;
    fde_merge(rdram, ctx, runtime);
}

void entry_1ff1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff1ac inside fde_merge (0x1ff0e0 - 0x1ff1e0)
    ctx->pc = 0x1ff1ac;
    fde_merge(rdram, ctx, runtime);
}

void entry_1ff1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff1c8 inside fde_merge (0x1ff0e0 - 0x1ff1e0)
    ctx->pc = 0x1ff1c8;
    fde_merge(rdram, ctx, runtime);
}

void entry_1ff248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff248 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff248;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff258 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff258;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2b0 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2b0;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2b4 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2b4;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2b8 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2b8;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2e8 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2e8;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2ec inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2ec;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff2fc inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff2fc;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff30c inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff30c;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff310 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff310;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff328 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff328;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff358 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff358;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff3b0 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff3b0;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff3b4 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff3b4;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff3b8 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff3b8;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff3e8 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff3e8;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff408 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff408;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff40c inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff40c;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff418 inside entry_1ff234 (0x1ff234 - 0x1ff420)
    ctx->pc = 0x1ff418;
    entry_1ff234(rdram, ctx, runtime);
}

void entry_1ff460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff460 inside count_fdes (0x1ff448 - 0x1ff490)
    ctx->pc = 0x1ff460;
    count_fdes(rdram, ctx, runtime);
}

void entry_1ff468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff468 inside count_fdes (0x1ff448 - 0x1ff490)
    ctx->pc = 0x1ff468;
    count_fdes(rdram, ctx, runtime);
}

void entry_1ff478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff478 inside count_fdes (0x1ff448 - 0x1ff490)
    ctx->pc = 0x1ff478;
    count_fdes(rdram, ctx, runtime);
}

void entry_1ff488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff488 inside count_fdes (0x1ff448 - 0x1ff490)
    ctx->pc = 0x1ff488;
    count_fdes(rdram, ctx, runtime);
}

void entry_1ff4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff4a8 inside add_fdes (0x1ff490 - 0x1ff518)
    ctx->pc = 0x1ff4a8;
    add_fdes(rdram, ctx, runtime);
}

void entry_1ff4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff4fc inside add_fdes (0x1ff490 - 0x1ff518)
    ctx->pc = 0x1ff4fc;
    add_fdes(rdram, ctx, runtime);
}

void entry_1ff50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff50c inside add_fdes (0x1ff490 - 0x1ff518)
    ctx->pc = 0x1ff50c;
    add_fdes(rdram, ctx, runtime);
}

void entry_1ff550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff550 inside frame_init (0x1ff518 - 0x1ff55c)
    ctx->pc = 0x1ff550;
    frame_init(rdram, ctx, runtime);
}

void entry_1ff570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff570 inside entry_1ff55c (0x1ff55c - 0x1ff578)
    ctx->pc = 0x1ff570;
    entry_1ff55c(rdram, ctx, runtime);
}

void entry_1ff57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff57c inside entry_1ff578 (0x1ff578 - 0x1ff58c)
    ctx->pc = 0x1ff57c;
    entry_1ff578(rdram, ctx, runtime);
}

void entry_1ff580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff580 inside entry_1ff578 (0x1ff578 - 0x1ff58c)
    ctx->pc = 0x1ff580;
    entry_1ff578(rdram, ctx, runtime);
}

void entry_1ff5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff5d8 inside entry_1ff598 (0x1ff598 - 0x1ff5e8)
    ctx->pc = 0x1ff5d8;
    entry_1ff598(rdram, ctx, runtime);
}

void entry_1ff600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff600 inside entry_1ff5e8 (0x1ff5e8 - 0x1ff614)
    ctx->pc = 0x1ff600;
    entry_1ff5e8(rdram, ctx, runtime);
}

void entry_1ff618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff618 inside entry_1ff614 (0x1ff614 - 0x1ff620)
    ctx->pc = 0x1ff618;
    entry_1ff614(rdram, ctx, runtime);
}

void entry_1ff678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff678 inside find_fde (0x1ff658 - 0x1ff694)
    ctx->pc = 0x1ff678;
    find_fde(rdram, ctx, runtime);
}

void entry_1ff69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff69c inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff69c;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff6c4 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff6c4;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff6cc inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff6cc;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff6e0 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff6e0;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff708 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff708;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff718 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff718;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff724 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff724;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff728 inside entry_1ff694 (0x1ff694 - 0x1ff740)
    ctx->pc = 0x1ff728;
    entry_1ff694(rdram, ctx, runtime);
}

void entry_1ff7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff7a8 inside entry_1ff790 (0x1ff790 - 0x1ff7b0)
    ctx->pc = 0x1ff7a8;
    entry_1ff790(rdram, ctx, runtime);
}

void entry_1ff7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff7dc inside entry_1ff7c4 (0x1ff7c4 - 0x1ff7e8)
    ctx->pc = 0x1ff7dc;
    entry_1ff7c4(rdram, ctx, runtime);
}

void entry_1ff828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff828 inside entry_1ff820 (0x1ff820 - 0x1ff848)
    ctx->pc = 0x1ff828;
    entry_1ff820(rdram, ctx, runtime);
}

void entry_1ff82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff82c inside entry_1ff820 (0x1ff820 - 0x1ff848)
    ctx->pc = 0x1ff82c;
    entry_1ff820(rdram, ctx, runtime);
}

void entry_1ff88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff88c inside execute_cfa_insn (0x1ff848 - 0x1ff958)
    ctx->pc = 0x1ff88c;
    execute_cfa_insn(rdram, ctx, runtime);
}

void entry_1ff8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff8a4 inside execute_cfa_insn (0x1ff848 - 0x1ff958)
    ctx->pc = 0x1ff8a4;
    execute_cfa_insn(rdram, ctx, runtime);
}

void entry_1ff8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff8c0 inside execute_cfa_insn (0x1ff848 - 0x1ff958)
    ctx->pc = 0x1ff8c0;
    execute_cfa_insn(rdram, ctx, runtime);
}

void entry_1ff924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff924 inside execute_cfa_insn (0x1ff848 - 0x1ff958)
    ctx->pc = 0x1ff924;
    execute_cfa_insn(rdram, ctx, runtime);
}

void entry_1ff940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff940 inside execute_cfa_insn (0x1ff848 - 0x1ff958)
    ctx->pc = 0x1ff940;
    execute_cfa_insn(rdram, ctx, runtime);
}

void entry_1ff95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ff95c inside entry_1ff958 (0x1ff958 - 0x1ff964)
    ctx->pc = 0x1ff95c;
    entry_1ff958(rdram, ctx, runtime);
}

void entry_1ffa80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffa80 inside entry_1ffa74 (0x1ffa74 - 0x1ffb34)
    ctx->pc = 0x1ffa80;
    entry_1ffa74(rdram, ctx, runtime);
}

void entry_1ffae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffae4 inside entry_1ffa74 (0x1ffa74 - 0x1ffb34)
    ctx->pc = 0x1ffae4;
    entry_1ffa74(rdram, ctx, runtime);
}

void entry_1ffb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffb58 inside entry_1ffb34 (0x1ffb34 - 0x1ffbac)
    ctx->pc = 0x1ffb58;
    entry_1ffb34(rdram, ctx, runtime);
}

void entry_1ffbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffbbc inside entry_1ffbac (0x1ffbac - 0x1ffbc4)
    ctx->pc = 0x1ffbbc;
    entry_1ffbac(rdram, ctx, runtime);
}

void entry_1ffbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffbc8 inside entry_1ffbc4 (0x1ffbc4 - 0x1ffc08)
    ctx->pc = 0x1ffbc8;
    entry_1ffbc4(rdram, ctx, runtime);
}

void entry_1ffc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffc28 inside __deregister_frame_info (0x1ffc08 - 0x1ffc4c)
    ctx->pc = 0x1ffc28;
    fn___deregister_frame_info(rdram, ctx, runtime);
}

void entry_1ffc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffc54 inside entry_1ffc4c (0x1ffc4c - 0x1ffc80)
    ctx->pc = 0x1ffc54;
    entry_1ffc4c(rdram, ctx, runtime);
}

void entry_1ffc5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffc5c inside entry_1ffc4c (0x1ffc4c - 0x1ffc80)
    ctx->pc = 0x1ffc5c;
    entry_1ffc4c(rdram, ctx, runtime);
}

void entry_1ffc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffc6c inside entry_1ffc4c (0x1ffc4c - 0x1ffc80)
    ctx->pc = 0x1ffc6c;
    entry_1ffc4c(rdram, ctx, runtime);
}

void entry_1ffc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffc70 inside entry_1ffc4c (0x1ffc4c - 0x1ffc80)
    ctx->pc = 0x1ffc70;
    entry_1ffc4c(rdram, ctx, runtime);
}

void entry_1ffcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffcd4 inside entry_1ffcc8 (0x1ffcc8 - 0x1ffcec)
    ctx->pc = 0x1ffcd4;
    entry_1ffcc8(rdram, ctx, runtime);
}

void entry_1ffcdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffcdc inside entry_1ffcc8 (0x1ffcc8 - 0x1ffcec)
    ctx->pc = 0x1ffcdc;
    entry_1ffcc8(rdram, ctx, runtime);
}

void entry_1ffd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffd28 inside entry_1ffcec (0x1ffcec - 0x1ffd38)
    ctx->pc = 0x1ffd28;
    entry_1ffcec(rdram, ctx, runtime);
}

void entry_1ffd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffd50 inside entry_1ffd38 (0x1ffd38 - 0x1ffd78)
    ctx->pc = 0x1ffd50;
    entry_1ffd38(rdram, ctx, runtime);
}

void entry_1ffd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffd5c inside entry_1ffd38 (0x1ffd38 - 0x1ffd78)
    ctx->pc = 0x1ffd5c;
    entry_1ffd38(rdram, ctx, runtime);
}

void entry_1ffd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffd80 inside entry_1ffd78 (0x1ffd78 - 0x1ffdc0)
    ctx->pc = 0x1ffd80;
    entry_1ffd78(rdram, ctx, runtime);
}

void entry_1ffdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffdb0 inside entry_1ffd78 (0x1ffd78 - 0x1ffdc0)
    ctx->pc = 0x1ffdb0;
    entry_1ffd78(rdram, ctx, runtime);
}

void entry_1ffddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffddc inside entry_1ffdc0 (0x1ffdc0 - 0x1ffe58)
    ctx->pc = 0x1ffddc;
    entry_1ffdc0(rdram, ctx, runtime);
}

void entry_1ffde0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffde0 inside entry_1ffdc0 (0x1ffdc0 - 0x1ffe58)
    ctx->pc = 0x1ffde0;
    entry_1ffdc0(rdram, ctx, runtime);
}

void entry_1ffde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffde4 inside entry_1ffdc0 (0x1ffdc0 - 0x1ffe58)
    ctx->pc = 0x1ffde4;
    entry_1ffdc0(rdram, ctx, runtime);
}

void entry_1ffe2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffe2c inside entry_1ffdc0 (0x1ffdc0 - 0x1ffe58)
    ctx->pc = 0x1ffe2c;
    entry_1ffdc0(rdram, ctx, runtime);
}

void entry_1ffea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffea8 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1ffea8;
    fde_split(rdram, ctx, runtime);
}

void entry_1ffee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ffee8 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1ffee8;
    fde_split(rdram, ctx, runtime);
}

void entry_1fff54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fff54 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fff54;
    fde_split(rdram, ctx, runtime);
}

void entry_1fff58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fff58 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fff58;
    fde_split(rdram, ctx, runtime);
}

void entry_1fff60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fff60 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fff60;
    fde_split(rdram, ctx, runtime);
}

void entry_1fff74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fff74 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fff74;
    fde_split(rdram, ctx, runtime);
}

void entry_1fff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fff88 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fff88;
    fde_split(rdram, ctx, runtime);
}

void entry_1fffa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fffa4 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fffa4;
    fde_split(rdram, ctx, runtime);
}

void entry_1fffb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1fffb4 inside fde_split (0x1ffe58 - 0x200000)
    ctx->pc = 0x1fffb4;
    fde_split(rdram, ctx, runtime);
}

