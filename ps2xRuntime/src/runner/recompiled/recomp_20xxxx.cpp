// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_200024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200024: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x200028: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20002c: 0x24a5f210
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963728));
    // 0x200030: 0x24c6b318
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947608));
    // 0x200034: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20003c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20003c
// Address: 0x20003c - 0x200050

void entry_20003c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20003c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200040: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200044: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200048: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00200050
// Address: 0x200050 - 0x200074

void FUN_00200050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200050: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200054: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x200058: 0x2442f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963416));
    // 0x20005c: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x200060: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x200064: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_200074(rdram, ctx, runtime); return;
    }
    // 0x20006c: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x200074);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_200074
// Address: 0x200074 - 0x2000a4

void entry_200074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200074) {
        switch (ctx->pc) {
            case 0x200080: ctx->pc = 0; goto label_200080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200074: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200078: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
label_200080:
    // 0x200080: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x200084: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200088: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x20008c: 0x2442f2a8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963880));
    // 0x200090: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x200094: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_2000a4(rdram, ctx, runtime); return;
    }
    // 0x20009c: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x2000a4);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_2000a4
// Address: 0x2000a4 - 0x2000b0

void entry_2000a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2000a4: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2000a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: type_info__operatorEQEQ
// Address: 0x2000b0 - 0x2000d0

void entry_2000d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2000d0) {
        switch (ctx->pc) {
            case 0x2000d8: ctx->pc = 0; goto label_2000d8;
            case 0x2000e0: ctx->pc = 0; goto label_2000e0;
            case 0x20010c: ctx->pc = 0; goto label_20010c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2000d0: 0x14400003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2000e0;
    }
label_2000d8:
    // 0x2000d8: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2000dc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2000e0:
    // 0x2000e0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2000e4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2000e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2000f0: 0x10800006
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_20010c;
    }
    // 0x2000f8: 0xac87000c
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 7));
    // 0x2000fc: 0x2442f230
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963760));
    // 0x200100: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200104: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    // 0x200108: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
label_20010c:
    // 0x20010c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200114: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200118; return;
}


// Function: FUN_00200118
// Address: 0x200118 - 0x200138

void FUN_00200118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200118) {
        switch (ctx->pc) {
            case 0x200130: ctx->pc = 0; goto label_200130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200118: 0x10800005
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200130;
    }
    // 0x200120: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
    // 0x200124: 0x2442f248
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963784));
    // 0x200128: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x20012c: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200130:
    // 0x200130: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00200138
// Address: 0x200138 - 0x200158

void FUN_00200138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200138) {
        switch (ctx->pc) {
            case 0x20014c: ctx->pc = 0; goto label_20014c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200138: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_20014c;
    }
    // 0x200140: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200144: 0x2442f260
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963808));
    // 0x200148: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_20014c:
    // 0x20014c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200154: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200158; return;
}


// Function: fn___user_type_info__dcast
// Address: 0x200158 - 0x20016c

void entry_20016c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20016c: 0x2800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x200170: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200174: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200178: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20017c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200184: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200188; return;
}


// Function: fn___si_type_info__dcast
// Address: 0x200188 - 0x2001c4

void entry_2001c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2001c4: 0x1440000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_2001f8(rdram, ctx, runtime); return;
    }
    // 0x2001cc: 0x8e0a0008
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x2001d0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x2001d4: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x2001d8: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x2001dc: 0x8d430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
    // 0x2001e0: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x2001e4: 0x2a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x2001e8: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x2001ec: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x2001f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x2001f8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_2001f8
// Address: 0x2001f8 - 0x200220

void entry_2001f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2001f8: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x2001fc: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x200200: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x200204: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x200208: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20020c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200210: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200214: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20021c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200220; return;
}


// Function: fn___class_type_info__dcast
// Address: 0x200220 - 0x200268

void entry_200268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200268) {
        switch (ctx->pc) {
            case 0x200288: ctx->pc = 0; goto label_200288;
            case 0x2002b0: ctx->pc = 0; goto label_2002b0;
            case 0x2002b8: ctx->pc = 0; goto label_2002b8;
            case 0x2002e0: ctx->pc = 0; goto label_2002e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200268: 0x14400057
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2003C8; return;
    }
    // 0x200270: 0x8e45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x200274: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x200278: 0x10a00052
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2003C4; return;
    }
    // 0x200280: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x200284: 0x0
    // NOP
label_200288:
    // 0x200288: 0x13c00009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_2002b0;
    }
    // 0x200290: 0x8e4a0008
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x200294: 0x2ca1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 10)));
    // 0x200298: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x20029c: 0x21782
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 30));
    // 0x2002a0: 0x14440043
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x2003B0; return;
    }
    // 0x2002a8: 0x10000003
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 10)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2002b8;
    }
label_2002b0:
    // 0x2002b0: 0x8e4a0008
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x2002b4: 0x2ca5021
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 10)));
label_2002b8:
    // 0x2002b8: 0x3c021fff
    SET_GPR_U32(ctx, 2, ((uint32_t)8191 << 16));
    // 0x2002bc: 0x8d430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
    // 0x2002c0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2002c4: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2002c8: 0x621024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2002cc: 0x31f42
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 29));
    // 0x2002d0: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x2002d4: 0x10600002
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_2002e0;
    }
    // 0x2002dc: 0x8e100000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_2002e0:
    // 0x2002e0: 0x8d4a0000
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 10), 0)));
    // 0x2002e4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2002e8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x2002ec: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x2002f0: 0x8d430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
    // 0x2002f4: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x2002f8: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x2002fc: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x200300: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x200304: 0x40f809
    SET_GPR_U32(ctx, 31, 0x20030c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_20030c
// Address: 0x20030c - 0x20035c

void entry_20030c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20030c) {
        switch (ctx->pc) {
            case 0x200328: ctx->pc = 0; goto label_200328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20030c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x200310: 0x52000026
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x2003AC; return;
    }
    // 0x200318: 0x16600003
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        goto label_200328;
    }
    // 0x200320: 0x10000021
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2003A8; return;
    }
label_200328:
    // 0x200328: 0x52700020
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x2003AC; return;
    }
    // 0x200330: 0x12a0001b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2003A0; return;
    }
    // 0x200338: 0x8e830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x20033c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200340: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x200344: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x200348: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20034c: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x200350: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x200354: 0x40f809
    SET_GPR_U32(ctx, 31, 0x20035c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_20035c
// Address: 0x20035c - 0x200388

void entry_20035c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20035c: 0x8e830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x200360: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x200364: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x200368: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20036c: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x200370: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200374: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x200378: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20037c: 0x2842021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 4)));
    // 0x200380: 0x40f809
    SET_GPR_U32(ctx, 31, 0x200388);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_200388
// Address: 0x200388 - 0x200418

void entry_200388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200388) {
        switch (ctx->pc) {
            case 0x2003a0: ctx->pc = 0; goto label_2003a0;
            case 0x2003a8: ctx->pc = 0; goto label_2003a8;
            case 0x2003ac: ctx->pc = 0; goto label_2003ac;
            case 0x2003b0: ctx->pc = 0; goto label_2003b0;
            case 0x2003c4: ctx->pc = 0; goto label_2003c4;
            case 0x2003c8: ctx->pc = 0; goto label_2003c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200388: 0x5222000f
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_2003c8;
    }
    // 0x200390: 0x52370006
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 23)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_2003ac;
    }
    // 0x200398: 0x10570003
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 23)) {
        goto label_2003a8;
    }
label_2003a0:
    // 0x2003a0: 0x10000009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2003c8;
    }
label_2003a8:
    // 0x2003a8: 0x8e45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_2003ac:
    // 0x2003ac: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_2003b0:
    // 0x2003b0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x2003b4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x2003b8: 0x45102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x2003bc: 0x1440ffb2
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200288; return;
    }
label_2003c4:
    // 0x2003c4: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_2003c8:
    // 0x2003c8: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x2003cc: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x2003d0: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x2003d4: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x2003d8: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x2003dc: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x2003e0: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x2003e4: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2003e8: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2003ec: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2003f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2003f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2003fc: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200400: 0x2442f230
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963760));
    // 0x200404: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
    // 0x200408: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    // 0x20040c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x200410: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 7));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___class_type_info_type_info_function
// Address: 0x200418 - 0x20043c

void entry_20043c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20043c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x200440: 0x3c060063
    SET_GPR_U32(ctx, 6, ((uint32_t)99 << 16));
    // 0x200444: 0x24a5f2b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963896));
    // 0x200448: 0x24c6c5d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294952408));
    // 0x20044c: 0xc080046
    SET_GPR_U32(ctx, 31, 0x200454);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_200454
// Address: 0x200454 - 0x200468

void entry_200454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200454: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200458: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20045c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200460: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00200468
// Address: 0x200468 - 0x200478

void FUN_00200468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200468: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x20046c: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x200470: 0xc080020
    SET_GPR_U32(ctx, 31, 0x200478);
    ctx->pc = 0x200080; return;
}


// Function: entry_200478
// Address: 0x200478 - 0x2004a8

void entry_200478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200478: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20047c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200484: 0x0
    // NOP
    // 0x200488: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x20048c: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200490: 0x2442f248
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963784));
    // 0x200494: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
    // 0x200498: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    // 0x20049c: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2004a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2004a8; return;
}


// Function: fn___si_type_info_type_info_function
// Address: 0x2004a8 - 0x2004cc

void entry_2004cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2004cc: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x2004d0: 0x3c060063
    SET_GPR_U32(ctx, 6, ((uint32_t)99 << 16));
    // 0x2004d4: 0x24a5f2d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963920));
    // 0x2004d8: 0x24c6c5d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294952408));
    // 0x2004dc: 0xc080046
    SET_GPR_U32(ctx, 31, 0x2004e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_2004e4
// Address: 0x2004e4 - 0x2004f8

void entry_2004e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2004e4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2004e8: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2004ec: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2004f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_002004f8
// Address: 0x2004f8 - 0x200508

void FUN_002004f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2004f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2004fc: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x200500: 0xc080020
    SET_GPR_U32(ctx, 31, 0x200508);
    ctx->pc = 0x200080; return;
}


// Function: entry_200508
// Address: 0x200508 - 0x200530

void entry_200508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200508: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20050c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200514: 0x0
    // NOP
    // 0x200518: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x20051c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x200520: 0x2463f260
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963808));
    // 0x200524: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x200528: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___user_type_info_type_info_function
// Address: 0x200530 - 0x200554

void entry_200554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200554: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x200558: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20055c: 0x24a5f2e8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963944));
    // 0x200560: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x200564: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20056c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20056c
// Address: 0x20056c - 0x200580

void entry_20056c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20056c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200570: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200574: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200578: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00200580
// Address: 0x200580 - 0x200590

void FUN_00200580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200580: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x200584: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x200588: 0xc080020
    SET_GPR_U32(ctx, 31, 0x200590);
    ctx->pc = 0x200080; return;
}


// Function: entry_200590
// Address: 0x200590 - 0x2005a0

void entry_200590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200590: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200594: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20059c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2005a0; return;
}


// Function: FUN_002005a0
// Address: 0x2005a0 - 0x2005c4

void FUN_002005a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2005a0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2005a4: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2005a8: 0x2442f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963416));
    // 0x2005ac: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2005b0: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x2005b4: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_2005c4(rdram, ctx, runtime); return;
    }
    // 0x2005bc: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x2005c4);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_2005c4
// Address: 0x2005c4 - 0x2005e8

void entry_2005c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2005c4: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2005c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2005d0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x2005d4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x2005d8: 0x2463f278
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963832));
    // 0x2005dc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2005e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2005e8; return;
}


// Function: bad_typeid_type_info_function
// Address: 0x2005e8 - 0x20060c

void entry_20060c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20060c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x200610: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x200614: 0x24a5f300
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963968));
    // 0x200618: 0x24c6b318
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947608));
    // 0x20061c: 0xc080046
    SET_GPR_U32(ctx, 31, 0x200624);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_200624
// Address: 0x200624 - 0x200638

void entry_200624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200624: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200628: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20062c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200630: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00200638
// Address: 0x200638 - 0x20065c

void FUN_00200638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200638: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x20063c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x200640: 0x2442f0d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963416));
    // 0x200644: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x200648: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x20064c: 0x10a00003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_20065c(rdram, ctx, runtime); return;
    }
    // 0x200654: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x20065c);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_20065c
// Address: 0x20065c - 0x200680

void entry_20065c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20065c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200660: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200668: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x20066c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x200670: 0x2463f290
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963856));
    // 0x200674: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20067c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200680; return;
}


// Function: bad_cast_type_info_function
// Address: 0x200680 - 0x2006a4

void entry_2006a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2006a4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x2006a8: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x2006ac: 0x24a5f310
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294963984));
    // 0x2006b0: 0x24c6b318
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947608));
    // 0x2006b4: 0xc080046
    SET_GPR_U32(ctx, 31, 0x2006bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_2006bc
// Address: 0x2006bc - 0x2006e0

void entry_2006bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2006bc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2006c0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2006c4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2006c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2006d0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2006d4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2006d8: 0xc08002c
    SET_GPR_U32(ctx, 31, 0x2006e0);
    type_info__operatorEQEQ(rdram, ctx, runtime); return;
}


// Function: entry_2006e0
// Address: 0x2006e0 - 0x200710

void entry_2006e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2006e0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2006e4: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x2006e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2006f0: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2006f8: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x2006fc: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x200700: 0x2463f2a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294963880));
    // 0x200704: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x200708: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: type_info_type_info_function
// Address: 0x200710 - 0x20073c

void entry_20073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20073c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200740: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200744: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200748: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: type_info__before
// Address: 0x200750 - 0x200764

void entry_200764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200764: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200768: 0x217c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 31));
    // 0x20076c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200778; return;
}


// Function: fn___throw_type_match_rtti
// Address: 0x200778 - 0x2007b4

void entry_2007b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2007b4) {
        switch (ctx->pc) {
            case 0x2007cc: ctx->pc = 0; goto label_2007cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2007b4: 0x14400116
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x2007bc: 0x16000003
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_2007cc;
    }
    // 0x2007c4: 0x1000000d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2007FC; return;
    }
label_2007cc:
    // 0x2007cc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x2007d0: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x2007d4: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x2007d8: 0x24a50530
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1328));
    // 0x2007dc: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2007e0: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x2007e4: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x2007e8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2007ec: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x2007f0: 0xc080356
    SET_GPR_U32(ctx, 31, 0x2007f8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_2007f8
// Address: 0x2007f8 - 0x20083c

void entry_2007f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2007f8) {
        switch (ctx->pc) {
            case 0x2007fc: ctx->pc = 0; goto label_2007fc;
            case 0x200814: ctx->pc = 0; goto label_200814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2007f8: 0x40502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_2007fc:
    // 0x2007fc: 0x5540007b
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
        ctx->pc = 0x2009EC; return;
    }
    // 0x200804: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_200814;
    }
    // 0x20080c: 0x1000000c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200840; return;
    }
label_200814:
    // 0x200814: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x200818: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x20081c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200820: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200824: 0x24a51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5216));
    // 0x200828: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x20082c: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x200830: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x200834: 0xc080356
    SET_GPR_U32(ctx, 31, 0x20083c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_20083c
// Address: 0x20083c - 0x20087c

void entry_20083c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20083c) {
        switch (ctx->pc) {
            case 0x200840: ctx->pc = 0; goto label_200840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20083c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_200840:
    // 0x200840: 0x120000f3
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x200848: 0x1220000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_20087c(rdram, ctx, runtime); return;
    }
    // 0x200850: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x200854: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x200858: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x20085c: 0x24a51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5216));
    // 0x200860: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200864: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x200868: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x20086c: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200870: 0x2273821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    // 0x200874: 0xc080356
    SET_GPR_U32(ctx, 31, 0x20087c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_20087c
// Address: 0x20087c - 0x2008c0

void entry_20087c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20087c: 0x504000e4
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x200C10; return;
    }
    // 0x200884: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x200888: 0x8c510008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x20088c: 0x1200000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_2008c0(rdram, ctx, runtime); return;
    }
    // 0x200894: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x200898: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x20089c: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x2008a0: 0x24a513f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5104));
    // 0x2008a4: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2008a8: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x2008ac: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x2008b0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2008b4: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x2008b8: 0xc080356
    SET_GPR_U32(ctx, 31, 0x2008c0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_2008c0
// Address: 0x2008c0 - 0x200904

void entry_2008c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2008c0) {
        switch (ctx->pc) {
            case 0x2008d0: ctx->pc = 0; goto label_2008d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2008c0: 0x10400003
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2008d0;
    }
    // 0x2008c8: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x2008cc: 0x8c53000c
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 12)));
label_2008d0:
    // 0x2008d0: 0x1220000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_200904(rdram, ctx, runtime); return;
    }
    // 0x2008d8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x2008dc: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x2008e0: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x2008e4: 0x24a513f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5104));
    // 0x2008e8: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2008ec: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x2008f0: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x2008f4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2008f8: 0x2273821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    // 0x2008fc: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200904);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200904
// Address: 0x200904 - 0x200948

void entry_200904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200904) {
        switch (ctx->pc) {
            case 0x200914: ctx->pc = 0; goto label_200914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200904: 0x10400003
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_200914;
    }
    // 0x20090c: 0x8c510008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x200910: 0x8c52000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 12)));
label_200914:
    // 0x200914: 0x32620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 1));
    // 0x200918: 0x32540001
    SET_GPR_U32(ctx, 20, AND32(GPR_U32(ctx, 18), 1));
    // 0x20091c: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x200920: 0x144000bb
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x200928: 0x32630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 19), 2));
    // 0x20092c: 0x32420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 2));
    // 0x200930: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x200934: 0x144000b6
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x20093c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200940: 0xc08002c
    SET_GPR_U32(ctx, 31, 0x200948);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    type_info__operatorEQEQ(rdram, ctx, runtime); return;
}


// Function: entry_200948
// Address: 0x200948 - 0x200958

void entry_200948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200948: 0x544000b0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 22));
        ctx->pc = 0x200C0C; return;
    }
    // 0x200950: 0xc080382
    SET_GPR_U32(ctx, 31, 0x200958);
    FUN_00200e08(rdram, ctx, runtime); return;
}


// Function: entry_200958
// Address: 0x200958 - 0x200964

void entry_200958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200958: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20095c: 0xc08002c
    SET_GPR_U32(ctx, 31, 0x200964);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    type_info__operatorEQEQ(rdram, ctx, runtime); return;
}


// Function: entry_200964
// Address: 0x200964 - 0x20099c

void entry_200964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200964: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2009A4; return;
    }
    // 0x20096c: 0x120000a6
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C08; return;
    }
    // 0x200974: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x200978: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x20097c: 0x24a51310
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4880));
    // 0x200980: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200984: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x200988: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x20098c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200990: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x200994: 0xc080356
    SET_GPR_U32(ctx, 31, 0x20099c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_20099c
// Address: 0x20099c - 0x2009dc

void entry_20099c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20099c) {
        switch (ctx->pc) {
            case 0x2009a4: ctx->pc = 0; goto label_2009a4;
            case 0x2009b4: ctx->pc = 0; goto label_2009b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20099c: 0x5040009b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 22));
        ctx->pc = 0x200C0C; return;
    }
label_2009a4:
    // 0x2009a4: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_2009b4;
    }
    // 0x2009ac: 0x1000000c
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2009E0; return;
    }
label_2009b4:
    // 0x2009b4: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x2009b8: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x2009bc: 0x24a50530
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1328));
    // 0x2009c0: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2009c4: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x2009c8: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x2009cc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2009d0: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x2009d4: 0xc080356
    SET_GPR_U32(ctx, 31, 0x2009dc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_2009dc
// Address: 0x2009dc - 0x200a10

void entry_2009dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2009dc) {
        switch (ctx->pc) {
            case 0x2009e0: ctx->pc = 0; goto label_2009e0;
            case 0x2009ec: ctx->pc = 0; goto label_2009ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2009dc: 0x40502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_2009e0:
    // 0x2009e0: 0x1140000d
    if (GPR_U32(ctx, 10) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200A18; return;
    }
    // 0x2009e8: 0x8d430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
label_2009ec:
    // 0x2009ec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x2009f0: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x2009f4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2009f8: 0x84640010
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x2009fc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x200a00: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x200a04: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x200a08: 0x40f809
    SET_GPR_U32(ctx, 31, 0x200a10);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_200a10
// Address: 0x200a10 - 0x200a50

void entry_200a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200a10) {
        switch (ctx->pc) {
            case 0x200a18: ctx->pc = 0; goto label_200a18;
            case 0x200a28: ctx->pc = 0; goto label_200a28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200a10: 0x1000007e
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
label_200a18:
    // 0x200a18: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_200a28;
    }
    // 0x200a20: 0x1000000c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200A54; return;
    }
label_200a28:
    // 0x200a28: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x200a2c: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x200a30: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200a34: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200a38: 0x24a51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5216));
    // 0x200a3c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200a40: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x200a44: 0x2073821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    // 0x200a48: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200a50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200a50
// Address: 0x200a50 - 0x200a94

void entry_200a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200a50) {
        switch (ctx->pc) {
            case 0x200a54: ctx->pc = 0; goto label_200a54;
            case 0x200a6c: ctx->pc = 0; goto label_200a6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200a50: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_200a54:
    // 0x200a54: 0x1200006e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x200a5c: 0x56200003
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_200a6c;
    }
    // 0x200a64: 0x1000000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200A98; return;
    }
label_200a6c:
    // 0x200a6c: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x200a70: 0x3c080020
    SET_GPR_U32(ctx, 8, ((uint32_t)32 << 16));
    // 0x200a74: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200a78: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200a7c: 0x24a51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 5216));
    // 0x200a80: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200a84: 0x25080710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1808));
    // 0x200a88: 0x2273821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    // 0x200a8c: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200a94);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200a94
// Address: 0x200a94 - 0x200ae8

void entry_200a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200a94) {
        switch (ctx->pc) {
            case 0x200a98: ctx->pc = 0; goto label_200a98;
            case 0x200ab8: ctx->pc = 0; goto label_200ab8;
            case 0x200ac8: ctx->pc = 0; goto label_200ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200a94: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_200a98:
    // 0x200a98: 0x1220005c
    SET_GPR_U32(ctx, 30, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
    // 0x200aa0: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x200aa4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x200aa8: 0x3c150020
    SET_GPR_U32(ctx, 21, ((uint32_t)32 << 16));
    // 0x200aac: 0x10000024
    SET_GPR_U32(ctx, 23, ((uint32_t)32 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200B40; return;
    }
    // 0x200ab4: 0x0
    // NOP
label_200ab8:
    // 0x200ab8: 0x56200003
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_200ac8;
    }
    // 0x200ac0: 0x1000000a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200AEC; return;
    }
label_200ac8:
    // 0x200ac8: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200acc: 0x26e51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 23), 5216));
    // 0x200ad0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200ad4: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200ad8: 0x26a80710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 21), 1808));
    // 0x200adc: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200ae0: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200ae8);
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200ae8
// Address: 0x200ae8 - 0x200b1c

void entry_200ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200ae8) {
        switch (ctx->pc) {
            case 0x200aec: ctx->pc = 0; goto label_200aec;
            case 0x200afc: ctx->pc = 0; goto label_200afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200ae8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_200aec:
    // 0x200aec: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_200afc;
    }
    // 0x200af4: 0x1000000a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200B20; return;
    }
label_200afc:
    // 0x200afc: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200b00: 0x26e51460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 23), 5216));
    // 0x200b04: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200b08: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200b0c: 0x26a80710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 21), 1808));
    // 0x200b10: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200b14: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200b1c);
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200b1c
// Address: 0x200b1c - 0x200b6c

void entry_200b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200b1c) {
        switch (ctx->pc) {
            case 0x200b20: ctx->pc = 0; goto label_200b20;
            case 0x200b40: ctx->pc = 0; goto label_200b40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200b1c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_200b20:
    // 0x200b20: 0x1220003b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x200b28: 0x12000038
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
    // 0x200b30: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x200b34: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x200b38: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x200b3c: 0x2a00b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 0));
label_200b40:
    // 0x200b40: 0x1200000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_200b6c(rdram, ctx, runtime); return;
    }
    // 0x200b48: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x200b4c: 0x27c513f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 5104));
    // 0x200b50: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200b54: 0x26a80710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 21), 1808));
    // 0x200b58: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200b5c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x200b60: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200b64: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200b6c);
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 7)));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200b6c
// Address: 0x200b6c - 0x200ba8

void entry_200b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200b6c) {
        switch (ctx->pc) {
            case 0x200b7c: ctx->pc = 0; goto label_200b7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200b6c: 0x10400003
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_200b7c;
    }
    // 0x200b74: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x200b78: 0x8c53000c
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 12)));
label_200b7c:
    // 0x200b7c: 0x1220000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_200ba8(rdram, ctx, runtime); return;
    }
    // 0x200b84: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x200b88: 0x27c513f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 5104));
    // 0x200b8c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x200b90: 0x26a80710
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 21), 1808));
    // 0x200b94: 0x84470000
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x200b98: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200b9c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x200ba0: 0xc080356
    SET_GPR_U32(ctx, 31, 0x200ba8);
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 7)));
    fn___dynamic_cast(rdram, ctx, runtime); return;
}


// Function: entry_200ba8
// Address: 0x200ba8 - 0x200c00

void entry_200ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200ba8) {
        switch (ctx->pc) {
            case 0x200bb8: ctx->pc = 0; goto label_200bb8;
            case 0x200bf8: ctx->pc = 0; goto label_200bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200ba8: 0x10400003
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_200bb8;
    }
    // 0x200bb0: 0x8c510008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x200bb4: 0x8c52000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 12)));
label_200bb8:
    // 0x200bb8: 0x32660001
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 19), 1));
    // 0x200bbc: 0x32450001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 18), 1));
    // 0x200bc0: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x200bc4: 0x14400011
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 19), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
    // 0x200bcc: 0x32430002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 2));
    // 0x200bd0: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x200bd4: 0x1440000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C10; return;
    }
    // 0x200bdc: 0x56800006
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        goto label_200bf8;
    }
    // 0x200be4: 0xc5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 5)));
    // 0x200be8: 0x14400008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
    // 0x200bf0: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x200C0C; return;
    }
label_200bf8:
    // 0x200bf8: 0xc08002c
    SET_GPR_U32(ctx, 31, 0x200c00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    type_info__operatorEQEQ(rdram, ctx, runtime); return;
}


// Function: entry_200c00
// Address: 0x200c00 - 0x200c40

void entry_200c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200c00) {
        switch (ctx->pc) {
            case 0x200c08: ctx->pc = 0; goto label_200c08;
            case 0x200c0c: ctx->pc = 0; goto label_200c0c;
            case 0x200c10: ctx->pc = 0; goto label_200c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200c00: 0x1040ffad
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x200AB8; return;
    }
label_200c08:
    // 0x200c08: 0xafb60000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 22));
label_200c0c:
    // 0x200c0c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_200c10:
    // 0x200c10: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x200c14: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x200c18: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x200c1c: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x200c20: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x200c24: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x200c28: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x200c2c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x200c30: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x200c34: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200c38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___is_pointer
// Address: 0x200c40 - 0x200c80

void entry_200c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200c80) {
        switch (ctx->pc) {
            case 0x200ca8: ctx->pc = 0; goto label_200ca8;
            case 0x200ccc: ctx->pc = 0; goto label_200ccc;
            case 0x200cec: ctx->pc = 0; goto label_200cec;
            case 0x200d0c: ctx->pc = 0; goto label_200d0c;
            case 0x200d2c: ctx->pc = 0; goto label_200d2c;
            case 0x200d4c: ctx->pc = 0; goto label_200d4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200c80: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200c84: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x200c88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200c90: 0x10800005
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200ca8;
    }
    // 0x200c98: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
    // 0x200c9c: 0x2442f428
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964264));
    // 0x200ca0: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200ca4: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200ca8:
    // 0x200ca8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200cb0: 0x10800006
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200ccc;
    }
    // 0x200cb8: 0xac86000c
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 6));
    // 0x200cbc: 0x2442f418
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964248));
    // 0x200cc0: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200cc4: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
    // 0x200cc8: 0xac870008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 7));
label_200ccc:
    // 0x200ccc: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200cd4: 0x0
    // NOP
    // 0x200cd8: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200cec;
    }
    // 0x200ce0: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200ce4: 0x2442f3f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964216));
    // 0x200ce8: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200cec:
    // 0x200cec: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200cf4: 0x0
    // NOP
    // 0x200cf8: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200d0c;
    }
    // 0x200d00: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200d04: 0x2442f3e8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964200));
    // 0x200d08: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200d0c:
    // 0x200d0c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200d14: 0x0
    // NOP
    // 0x200d18: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200d2c;
    }
    // 0x200d20: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200d24: 0x2442f3d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964184));
    // 0x200d28: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200d2c:
    // 0x200d2c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200d34: 0x0
    // NOP
    // 0x200d38: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_200d4c;
    }
    // 0x200d40: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x200d44: 0x2442f3c8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964168));
    // 0x200d48: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_200d4c:
    // 0x200d4c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200d54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200d58; return;
}


// Function: fn___dynamic_cast
// Address: 0x200d58 - 0x200d98

void entry_200d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200d98: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x200d9c: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x200da0: 0x86020010
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x200da4: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x200da8: 0x280f809
    SET_GPR_U32(ctx, 31, 0x200db0);
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_200db0
// Address: 0x200db0 - 0x200db8

void entry_200db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200db0: 0x260f809
    SET_GPR_U32(ctx, 31, 0x200db8);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_200db8
// Address: 0x200db8 - 0x200dd8

void entry_200db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200db8: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x200dbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x200dc0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x200dc4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x200dc8: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x200dcc: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x200dd0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x200dd8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_200dd8
// Address: 0x200dd8 - 0x200e08

void entry_200dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x200dd8: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x200ddc: 0xdfb70070
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x200de0: 0xdfb60060
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x200de4: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x200de8: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x200dec: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x200df0: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x200df4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x200df8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x200dfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200e04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x200e08; return;
}


// Function: FUN_00200e08
// Address: 0x200e08 - 0x2011c0

void FUN_00200e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x200e08) {
        switch (ctx->pc) {
            case 0x200e34: ctx->pc = 0; goto label_200e34;
            case 0x200e6c: ctx->pc = 0; goto label_200e6c;
            case 0x200ea4: ctx->pc = 0; goto label_200ea4;
            case 0x200edc: ctx->pc = 0; goto label_200edc;
            case 0x200f14: ctx->pc = 0; goto label_200f14;
            case 0x200f4c: ctx->pc = 0; goto label_200f4c;
            case 0x200f84: ctx->pc = 0; goto label_200f84;
            case 0x200fbc: ctx->pc = 0; goto label_200fbc;
            case 0x200ff4: ctx->pc = 0; goto label_200ff4;
            case 0x20102c: ctx->pc = 0; goto label_20102c;
            case 0x201064: ctx->pc = 0; goto label_201064;
            case 0x20109c: ctx->pc = 0; goto label_20109c;
            case 0x2010d4: ctx->pc = 0; goto label_2010d4;
            case 0x20110c: ctx->pc = 0; goto label_20110c;
            case 0x201144: ctx->pc = 0; goto label_201144;
            case 0x20117c: ctx->pc = 0; goto label_20117c;
            case 0x2011b4: ctx->pc = 0; goto label_2011b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x200e08: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200e0c: 0x8c828e00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938112)));
    // 0x200e10: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200e34;
    }
    // 0x200e18: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200e34;
    }
    // 0x200e20: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200e24: 0x2463f340
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964032));
    // 0x200e28: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200e2c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200e30: 0xac838e00
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938112), GPR_U32(ctx, 3));
label_200e34:
    // 0x200e34: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200e3c: 0x0
    // NOP
    // 0x200e40: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200e44: 0x8c828e08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938120)));
    // 0x200e48: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938120));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200e6c;
    }
    // 0x200e50: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200e6c;
    }
    // 0x200e58: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200e5c: 0x2463f348
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964040));
    // 0x200e60: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200e64: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200e68: 0xac838e08
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938120), GPR_U32(ctx, 3));
label_200e6c:
    // 0x200e6c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938120));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200e74: 0x0
    // NOP
    // 0x200e78: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200e7c: 0x8c828e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938128)));
    // 0x200e80: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938128));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200ea4;
    }
    // 0x200e88: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200ea4;
    }
    // 0x200e90: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200e94: 0x2463f350
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964048));
    // 0x200e98: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200e9c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200ea0: 0xac838e10
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938128), GPR_U32(ctx, 3));
label_200ea4:
    // 0x200ea4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200eac: 0x0
    // NOP
    // 0x200eb0: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200eb4: 0x8c828e18
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938136)));
    // 0x200eb8: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938136));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200edc;
    }
    // 0x200ec0: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200edc;
    }
    // 0x200ec8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200ecc: 0x2463f358
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964056));
    // 0x200ed0: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200ed4: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200ed8: 0xac838e18
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938136), GPR_U32(ctx, 3));
label_200edc:
    // 0x200edc: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938136));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200ee4: 0x0
    // NOP
    // 0x200ee8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200eec: 0x8c828e20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938144)));
    // 0x200ef0: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938144));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200f14;
    }
    // 0x200ef8: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200f14;
    }
    // 0x200f00: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200f04: 0x2463f360
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964064));
    // 0x200f08: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200f0c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200f10: 0xac838e20
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938144), GPR_U32(ctx, 3));
label_200f14:
    // 0x200f14: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200f1c: 0x0
    // NOP
    // 0x200f20: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200f24: 0x8c828e28
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938152)));
    // 0x200f28: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938152));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200f4c;
    }
    // 0x200f30: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200f4c;
    }
    // 0x200f38: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200f3c: 0x2463f368
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964072));
    // 0x200f40: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200f44: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200f48: 0xac838e28
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938152), GPR_U32(ctx, 3));
label_200f4c:
    // 0x200f4c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938152));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200f54: 0x0
    // NOP
    // 0x200f58: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200f5c: 0x8c828e30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938160)));
    // 0x200f60: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938160));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200f84;
    }
    // 0x200f68: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200f84;
    }
    // 0x200f70: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200f74: 0x2463f370
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964080));
    // 0x200f78: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200f7c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200f80: 0xac838e30
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938160), GPR_U32(ctx, 3));
label_200f84:
    // 0x200f84: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200f8c: 0x0
    // NOP
    // 0x200f90: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200f94: 0x8c828e38
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938168)));
    // 0x200f98: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938168));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200fbc;
    }
    // 0x200fa0: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200fbc;
    }
    // 0x200fa8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200fac: 0x2463f378
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964088));
    // 0x200fb0: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200fb4: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200fb8: 0xac838e38
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938168), GPR_U32(ctx, 3));
label_200fbc:
    // 0x200fbc: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938168));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200fc4: 0x0
    // NOP
    // 0x200fc8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x200fcc: 0x8c828e40
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938176)));
    // 0x200fd0: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938176));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_200ff4;
    }
    // 0x200fd8: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_200ff4;
    }
    // 0x200fe0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x200fe4: 0x2463f380
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964096));
    // 0x200fe8: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x200fec: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x200ff0: 0xac838e40
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938176), GPR_U32(ctx, 3));
label_200ff4:
    // 0x200ff4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x200ffc: 0x0
    // NOP
    // 0x201000: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x201004: 0x8c828e48
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938184)));
    // 0x201008: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938184));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20102c;
    }
    // 0x201010: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_20102c;
    }
    // 0x201018: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x20101c: 0x2463f388
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964104));
    // 0x201020: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x201024: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201028: 0xac838e48
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938184), GPR_U32(ctx, 3));
label_20102c:
    // 0x20102c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938184));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201034: 0x0
    // NOP
    // 0x201038: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x20103c: 0x8c828e50
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938192)));
    // 0x201040: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938192));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_201064;
    }
    // 0x201048: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_201064;
    }
    // 0x201050: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x201054: 0x2463f390
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964112));
    // 0x201058: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x20105c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201060: 0xac838e50
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938192), GPR_U32(ctx, 3));
label_201064:
    // 0x201064: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20106c: 0x0
    // NOP
    // 0x201070: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x201074: 0x8c828e58
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938200)));
    // 0x201078: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938200));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20109c;
    }
    // 0x201080: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_20109c;
    }
    // 0x201088: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x20108c: 0x2463f398
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964120));
    // 0x201090: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x201094: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201098: 0xac838e58
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938200), GPR_U32(ctx, 3));
label_20109c:
    // 0x20109c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938200));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2010a4: 0x0
    // NOP
    // 0x2010a8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x2010ac: 0x8c828e60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938208)));
    // 0x2010b0: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938208));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2010d4;
    }
    // 0x2010b8: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_2010d4;
    }
    // 0x2010c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2010c4: 0x2463f3a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964128));
    // 0x2010c8: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x2010cc: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x2010d0: 0xac838e60
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938208), GPR_U32(ctx, 3));
label_2010d4:
    // 0x2010d4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2010dc: 0x0
    // NOP
    // 0x2010e0: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x2010e4: 0x8c828e68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938216)));
    // 0x2010e8: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938216));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20110c;
    }
    // 0x2010f0: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_20110c;
    }
    // 0x2010f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2010fc: 0x2463f3a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964136));
    // 0x201100: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x201104: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201108: 0xac838e68
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938216), GPR_U32(ctx, 3));
label_20110c:
    // 0x20110c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938216));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201114: 0x0
    // NOP
    // 0x201118: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x20111c: 0x8c828e70
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938224)));
    // 0x201120: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938224));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_201144;
    }
    // 0x201128: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_201144;
    }
    // 0x201130: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x201134: 0x2463f3b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964144));
    // 0x201138: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x20113c: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201140: 0xac838e70
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938224), GPR_U32(ctx, 3));
label_201144:
    // 0x201144: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20114c: 0x0
    // NOP
    // 0x201150: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x201154: 0x8c828e78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938232)));
    // 0x201158: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938232));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20117c;
    }
    // 0x201160: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_20117c;
    }
    // 0x201168: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x20116c: 0x2463f3b8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964152));
    // 0x201170: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x201174: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x201178: 0xac838e78
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938232), GPR_U32(ctx, 3));
label_20117c:
    // 0x20117c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938232));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201184: 0x0
    // NOP
    // 0x201188: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x20118c: 0x8c828e80
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294938240)));
    // 0x201190: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294938240));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2011b4;
    }
    // 0x201198: 0x10a00006
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_2011b4;
    }
    // 0x2011a0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2011a4: 0x2463f3c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294964160));
    // 0x2011a8: 0x2442f408
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964232));
    // 0x2011ac: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x2011b0: 0xac838e80
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294938240), GPR_U32(ctx, 3));
label_2011b4:
    // 0x2011b4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294938240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2011bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2011c0; return;
}


// Function: fn___array_type_info_type_info_function
// Address: 0x2011c0 - 0x2011e4

void entry_2011e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2011e4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x2011e8: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x2011ec: 0x24a5f438
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964280));
    // 0x2011f0: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x2011f4: 0xc080046
    SET_GPR_U32(ctx, 31, 0x2011fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_2011fc
// Address: 0x2011fc - 0x201210

void entry_2011fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2011fc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201200: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201204: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00201210
// Address: 0x201210 - 0x201220

void FUN_00201210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201210: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x201214: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x201218: 0xc080020
    SET_GPR_U32(ctx, 31, 0x201220);
    ctx->pc = 0x200080; return;
}


// Function: entry_201220
// Address: 0x201220 - 0x201230

void entry_201220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201220: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201224: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20122c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201230; return;
}


// Function: fn___ptmd_type_info_type_info_function
// Address: 0x201230 - 0x201254

void entry_201254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201254: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x201258: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20125c: 0x24a5f450
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964304));
    // 0x201260: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x201264: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20126c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20126c
// Address: 0x20126c - 0x201280

void entry_20126c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20126c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201270: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201274: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201278: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00201280
// Address: 0x201280 - 0x201290

void FUN_00201280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201280: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x201284: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x201288: 0xc080020
    SET_GPR_U32(ctx, 31, 0x201290);
    ctx->pc = 0x200080; return;
}


// Function: entry_201290
// Address: 0x201290 - 0x2012a0

void entry_201290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201290: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201294: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20129c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2012a0; return;
}


// Function: fn___ptmf_type_info_type_info_function
// Address: 0x2012a0 - 0x2012c4

void entry_2012c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2012c4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x2012c8: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x2012cc: 0x24a5f468
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964328));
    // 0x2012d0: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x2012d4: 0xc080046
    SET_GPR_U32(ctx, 31, 0x2012dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_2012dc
// Address: 0x2012dc - 0x2012f0

void entry_2012dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2012dc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2012e0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2012e4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2012e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_002012f0
// Address: 0x2012f0 - 0x201300

void FUN_002012f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2012f0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2012f4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2012f8: 0xc080020
    SET_GPR_U32(ctx, 31, 0x201300);
    ctx->pc = 0x200080; return;
}


// Function: entry_201300
// Address: 0x201300 - 0x201310

void entry_201300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201300: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201304: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20130c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201310; return;
}


// Function: fn___func_type_info_type_info_function
// Address: 0x201310 - 0x201334

void entry_201334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201334: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x201338: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20133c: 0x24a5f480
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964352));
    // 0x201340: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x201344: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20134c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20134c
// Address: 0x20134c - 0x201360

void entry_20134c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20134c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201350: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201354: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201358: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00201360
// Address: 0x201360 - 0x201370

void FUN_00201360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201360: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x201364: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x201368: 0xc080020
    SET_GPR_U32(ctx, 31, 0x201370);
    ctx->pc = 0x200080; return;
}


// Function: entry_201370
// Address: 0x201370 - 0x201380

void entry_201370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201370: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201374: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20137c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201380; return;
}


// Function: fn___builtin_type_info_type_info_function
// Address: 0x201380 - 0x2013a4

void entry_2013a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2013a4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x2013a8: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x2013ac: 0x24a5f498
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964376));
    // 0x2013b0: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x2013b4: 0xc080046
    SET_GPR_U32(ctx, 31, 0x2013bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_2013bc
// Address: 0x2013bc - 0x2013d0

void entry_2013bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2013bc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2013c0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2013c4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2013c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_002013d0
// Address: 0x2013d0 - 0x2013e0

void FUN_002013d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2013d0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2013d4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2013d8: 0xc080020
    SET_GPR_U32(ctx, 31, 0x2013e0);
    ctx->pc = 0x200080; return;
}


// Function: entry_2013e0
// Address: 0x2013e0 - 0x2013f0

void entry_2013e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2013e0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2013e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2013ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2013f0; return;
}


// Function: fn___attr_type_info_type_info_function
// Address: 0x2013f0 - 0x201414

void entry_201414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201414: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x201418: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20141c: 0x24a5f4b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964400));
    // 0x201420: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x201424: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20142c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20142c
// Address: 0x20142c - 0x201440

void entry_20142c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20142c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201430: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201434: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201438: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00201440
// Address: 0x201440 - 0x201450

void FUN_00201440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201440: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x201444: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x201448: 0xc080020
    SET_GPR_U32(ctx, 31, 0x201450);
    ctx->pc = 0x200080; return;
}


// Function: entry_201450
// Address: 0x201450 - 0x201460

void entry_201450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201450: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201454: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20145c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201460; return;
}


// Function: fn___pointer_type_info_type_info_function
// Address: 0x201460 - 0x201484

void entry_201484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201484: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x201488: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20148c: 0x24a5f4c8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294964424));
    // 0x201490: 0x24c6b320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947616));
    // 0x201494: 0xc080046
    SET_GPR_U32(ctx, 31, 0x20149c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00200118(rdram, ctx, runtime); return;
}


// Function: entry_20149c
// Address: 0x20149c - 0x2014b0

void entry_20149c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20149c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2014a0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2014a4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2014a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_002014b0
// Address: 0x2014b0 - 0x2014c0

void FUN_002014b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2014b0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2014b4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2014b8: 0xc080020
    SET_GPR_U32(ctx, 31, 0x2014c0);
    ctx->pc = 0x200080; return;
}


// Function: entry_2014c0
// Address: 0x2014c0 - 0x2014d0

void entry_2014c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2014c0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2014c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2014cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2014d0; return;
}


// Function: entry_2014e0
// Address: 0x2014e0 - 0x2014e8

void entry_2014e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2014e0: 0xc04002e
    SET_GPR_U32(ctx, 31, 0x2014e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    _exit(rdram, ctx, runtime); return;
}


// Function: entry_2014e8
// Address: 0x2014e8 - 0x2014f0

void entry_2014e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2014e8: 0x1000fffb
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2014D8; return;
    }
    // Fall-through to next function
    ctx->pc = 0x2014f0; return;
}


// Function: get_ptr_rng
// Address: 0x2014f0 - 0x201500

void entry_201524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201524) {
        switch (ctx->pc) {
            case 0x201534: ctx->pc = 0; goto label_201534;
            case 0x201540: ctx->pc = 0; goto label_201540;
            case 0x201560: ctx->pc = 0; goto label_201560;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201524: 0x14400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 468), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_201534;
    }
    // 0x20152c: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_201560;
    }
label_201534:
    // 0x201534: 0x2442007c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 124));
    // 0x201538: 0x2403001f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 31));
    // 0x20153c: 0x0
    // NOP
label_201540:
    // 0x201540: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x201544: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x201548: 0x2442fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967292));
    // 0x20154c: 0x0
    // NOP
    // 0x201550: 0x0
    // NOP
    // 0x201554: 0x461fffa
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_201540;
    }
    // 0x20155c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_201560:
    // 0x201560: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201564: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201568: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201570: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x201574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201578; return;
}


// Function: _raise_r
// Address: 0x201578 - 0x2015c4

void entry_2015c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2015c4) {
        switch (ctx->pc) {
            case 0x2015d4: ctx->pc = 0; goto label_2015d4;
            case 0x201600: ctx->pc = 0; goto label_201600;
            case 0x201610: ctx->pc = 0; goto label_201610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2015c4: 0x14400022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x201650; return;
    }
    // 0x2015cc: 0x8e0401d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 468)));
    // 0x2015d0: 0x112880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 2));
label_2015d4:
    // 0x2015d4: 0xa41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x2015d8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2015dc: 0x1060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_201610;
    }
    // 0x2015e4: 0x1c600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) > 0) {
        goto label_201600;
    }
    // 0x2015ec: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2015f0: 0x1062000f
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x201630; return;
    }
    // 0x2015f8: 0x10000011
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x201640; return;
    }
label_201600:
    // 0x201600: 0x10620012
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_20164c(rdram, ctx, runtime); return;
    }
    // 0x201608: 0x1000000d
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x201640; return;
    }
label_201610:
    // 0x201610: 0xc0805c0
    SET_GPR_U32(ctx, 31, 0x201618);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _getpid_r(rdram, ctx, runtime); return;
}


// Function: entry_201618
// Address: 0x201618 - 0x201628

void entry_201618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201618: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20161c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x201620: 0xc0805a8
    SET_GPR_U32(ctx, 31, 0x201628);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = 0x2016a0; return;
}


// Function: entry_201628
// Address: 0x201628 - 0x20164c

void entry_201628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201628) {
        switch (ctx->pc) {
            case 0x201630: ctx->pc = 0; goto label_201630;
            case 0x201640: ctx->pc = 0; goto label_201640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201628: 0x1000000a
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x201654; return;
    }
label_201630:
    // 0x201630: 0x24020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    // 0x201634: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x201638: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20164c(rdram, ctx, runtime); return;
    }
label_201640:
    // 0x201640: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x201644: 0x60f809
    SET_GPR_U32(ctx, 31, 0x20164c);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_20164c
// Address: 0x20164c - 0x201668

void entry_20164c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20164c) {
        switch (ctx->pc) {
            case 0x201650: ctx->pc = 0; goto label_201650;
            case 0x201654: ctx->pc = 0; goto label_201654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20164c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_201650:
    // 0x201650: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
label_201654:
    // 0x201654: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x201658: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20165c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201660: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: raise
// Address: 0x201668 - 0x201684

void entry_201684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201684) {
        switch (ctx->pc) {
            case 0x2016a0: ctx->pc = 0; goto label_2016a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201684: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201688: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201690: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x201694: 0x0
    // NOP
    // 0x201698: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x20169c: 0x0
    // NOP
label_2016a0:
    // 0x2016a0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x2016a4: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x2016a8: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x2016ac: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x2016b0: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x2016b4: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x2016b8: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x2016bc: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x2016c0: 0xc07e838
    SET_GPR_U32(ctx, 31, 0x2016c8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947624), GPR_U32(ctx, 0));
    kill(rdram, ctx, runtime); return;
}


// Function: entry_2016c8
// Address: 0x2016c8 - 0x201700

void entry_2016c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2016c8) {
        switch (ctx->pc) {
            case 0x2016e8: ctx->pc = 0; goto label_2016e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2016c8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2016cc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2016d0: 0x14620005
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_2016e8;
    }
    // 0x2016d8: 0x8e22b328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294947624)));
    // 0x2016dc: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
        goto label_2016e8;
    }
    // 0x2016e4: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_2016e8:
    // 0x2016e8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x2016ec: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2016f0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2016f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2016fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201700; return;
}


// Function: _getpid_r
// Address: 0x201700 - 0x201710

void entry_201710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201710: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20171c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201720; return;
}


// Function: strncpy
// Address: 0x201720 - 0x2018e8

void entry_201a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201a8c: 0x3c031200
    SET_GPR_U32(ctx, 3, ((uint32_t)4608 << 16));
    // 0x201a90: 0x24040200
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 512));
    // 0x201a94: 0x34631000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 4096));
    // 0x201a98: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x201a9c: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x201aa0: 0xa6110000
    WRITE16(ADD32(GPR_U32(ctx, 16), 0), (uint16_t)GPR_U32(ctx, 17));
    // 0x201aa4: 0x3404ff00
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 65280));
    // 0x201aa8: 0xdc620000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x201aac: 0xa6120002
    WRITE16(ADD32(GPR_U32(ctx, 16), 2), (uint16_t)GPR_U32(ctx, 18));
    // 0x201ab0: 0x2143a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 16);
    // 0x201ab4: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x201ab8: 0x3042ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65535));
    // 0x201abc: 0xc07db1c
    SET_GPR_U32(ctx, 31, 0x201ac4);
    WRITE16(ADD32(GPR_U32(ctx, 16), 6), (uint16_t)GPR_U32(ctx, 2));
    GsPutIMR(rdram, ctx, runtime); return;
}


// Function: entry_201ac4
// Address: 0x201ac4 - 0x201adc

void entry_201ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201ac4: 0x13182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 19)));
    // 0x201ac8: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x201acc: 0x10400008
    WRITE16(ADD32(GPR_U32(ctx, 16), 4), (uint16_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x201AF0; return;
    }
    // 0x201ad4: 0xc07db50
    SET_GPR_U32(ctx, 31, 0x201adc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_001f6d40(rdram, ctx, runtime); return;
}


// Function: entry_201adc
// Address: 0x201adc - 0x201ae8

void entry_201adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201adc: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x201ae0: 0xc07da58
    SET_GPR_U32(ctx, 31, 0x201ae8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    RemoveIntcHandler(rdram, ctx, runtime); return;
}


// Function: entry_201ae8
// Address: 0x201ae8 - 0x201b38

void entry_201ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201ae8) {
        switch (ctx->pc) {
            case 0x201af0: ctx->pc = 0; goto label_201af0;
            case 0x201b18: ctx->pc = 0; goto label_201b18;
            case 0x201b30: ctx->pc = 0; goto label_201b30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201ae8: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x201aec: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
label_201af0:
    // 0x201af0: 0x32240001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 17), 1));
    // 0x201af4: 0x324500ff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 18), 255));
    // 0x201af8: 0x32660001
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 19), 1));
    // 0x201afc: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x201b00: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x201b04: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x201b08: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201b0c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201b10: 0x807da44
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = 0x1f6910; return;
label_201b18:
    // 0x201b18: 0x3c021200
    SET_GPR_U32(ctx, 2, ((uint32_t)4608 << 16));
    // 0x201b1c: 0x24030100
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 256));
    // 0x201b20: 0x34421000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4096));
    // 0x201b24: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x201b28: 0x10000019
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x201B90; return;
    }
label_201b30:
    // 0x201b30: 0xc0806ea
    SET_GPR_U32(ctx, 31, 0x201b38);
    sceGsGetGParam(rdram, ctx, runtime); return;
}


// Function: entry_201b38
// Address: 0x201b38 - 0x201ba8

void entry_201b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201b38) {
        switch (ctx->pc) {
            case 0x201b90: ctx->pc = 0; goto label_201b90;
            case 0x201b94: ctx->pc = 0; goto label_201b94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201b38: 0x3c031200
    SET_GPR_U32(ctx, 3, ((uint32_t)4608 << 16));
    // 0x201b3c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x201b40: 0x34631000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 4096));
    // 0x201b44: 0x13302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 19)));
    // 0x201b48: 0xdc620000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x201b4c: 0x32240001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 17), 1));
    // 0x201b50: 0xa6060004
    WRITE16(ADD32(GPR_U32(ctx, 16), 4), (uint16_t)GPR_U32(ctx, 6));
    // 0x201b54: 0x324500ff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 18), 255));
    // 0x201b58: 0x2143a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> 16);
    // 0x201b5c: 0xa6110000
    WRITE16(ADD32(GPR_U32(ctx, 16), 0), (uint16_t)GPR_U32(ctx, 17));
    // 0x201b60: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x201b64: 0xa6120002
    WRITE16(ADD32(GPR_U32(ctx, 16), 2), (uint16_t)GPR_U32(ctx, 18));
    // 0x201b68: 0x3042ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65535));
    // 0x201b6c: 0x32660001
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 19), 1));
    // 0x201b70: 0xa6020006
    WRITE16(ADD32(GPR_U32(ctx, 16), 6), (uint16_t)GPR_U32(ctx, 2));
    // 0x201b74: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x201b78: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x201b7c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x201b80: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201b84: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201b88: 0x807da44
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = 0x1f6910; return;
label_201b90:
    // 0x201b90: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
label_201b94:
    // 0x201b94: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x201b98: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x201b9c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201ba0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceGsGetGParam
// Address: 0x201ba8 - 0x201bb8

void entry_201bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201bcc) {
        switch (ctx->pc) {
            case 0x201c1c: ctx->pc = 0; goto label_201c1c;
            case 0x201c68: ctx->pc = 0; goto label_201c68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201bcc: 0x84430006
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 6)));
    // 0x201bd0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x201bd4: 0x14620011
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_201c1c;
    }
    // 0x201bdc: 0x3c021200
    SET_GPR_U32(ctx, 2, ((uint32_t)4608 << 16));
    // 0x201be0: 0x3c031200
    SET_GPR_U32(ctx, 3, ((uint32_t)4608 << 16));
    // 0x201be4: 0x3c061200
    SET_GPR_U32(ctx, 6, ((uint32_t)4608 << 16));
    // 0x201be8: 0xfc440000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 4));
    // 0x201bec: 0x34630070
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 112));
    // 0x201bf0: 0x34c60080
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 128));
    // 0x201bf4: 0x3c041200
    SET_GPR_U32(ctx, 4, ((uint32_t)4608 << 16));
    // 0x201bf8: 0xde050010
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x201bfc: 0x348400c0
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 192));
    // 0x201c00: 0xfc650000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 5));
    // 0x201c04: 0xde020018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x201c08: 0xfcc20000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 2));
    // 0x201c0c: 0xde030020
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x201c10: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x201c14: 0x10000014
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_201c68;
    }
label_201c1c:
    // 0x201c1c: 0x3c031200
    SET_GPR_U32(ctx, 3, ((uint32_t)4608 << 16));
    // 0x201c20: 0x3c021200
    SET_GPR_U32(ctx, 2, ((uint32_t)4608 << 16));
    // 0x201c24: 0x3c061200
    SET_GPR_U32(ctx, 6, ((uint32_t)4608 << 16));
    // 0x201c28: 0xfc640000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 4));
    // 0x201c2c: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x201c30: 0x34c60090
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 144));
    // 0x201c34: 0x3c051200
    SET_GPR_U32(ctx, 5, ((uint32_t)4608 << 16));
    // 0x201c38: 0xde030008
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x201c3c: 0x34a500a0
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 160));
    // 0x201c40: 0x3c041200
    SET_GPR_U32(ctx, 4, ((uint32_t)4608 << 16));
    // 0x201c44: 0xfc430000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 3));
    // 0x201c48: 0x348400e0
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 224));
    // 0x201c4c: 0xde020010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x201c50: 0xfcc20000
    WRITE64(ADD32(GPR_U32(ctx, 6), 0), GPR_U64(ctx, 2));
    // 0x201c54: 0xde030018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x201c58: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x201c5c: 0xde020020
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x201c60: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x201c64: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_201c68:
    // 0x201c68: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201c6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x201c74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x201c78; return;
}


// Function: sceGsPutDrawEnv
// Address: 0x201c78 - 0x201d24

void entry_201d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201d24) {
        switch (ctx->pc) {
            case 0x201d2c: ctx->pc = 0; goto label_201d2c;
            case 0x201d3c: ctx->pc = 0; goto label_201d3c;
            case 0x201d54: ctx->pc = 0; goto label_201d54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201d24: 0x1000000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_201d54;
    }
label_201d2c:
    // 0x201d2c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x201d30: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x201d34: 0x3463a010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 40976));
    // 0x201d38: 0xc21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
label_201d3c:
    // 0x201d3c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x201d40: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x201d44: 0x24040101
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 257));
    // 0x201d48: 0x3463a000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 40960));
    // 0x201d4c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x201d50: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
label_201d54:
    // 0x201d54: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x201d58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceGsSetDefDBuff
// Address: 0x201d60 - 0x201dbc

void entry_201dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201dbc: 0x119c03
    SET_GPR_S32(ctx, 19, SRA32(GPR_S32(ctx, 17), 16));
    // 0x201dc0: 0x1ea403
    SET_GPR_S32(ctx, 20, SRA32(GPR_S32(ctx, 30), 16));
    // 0x201dc4: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x201dc8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x201dcc: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x201dd0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201dd4: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201dd8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x201ddc: 0xc080850
    SET_GPR_U32(ctx, 31, 0x201de4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSetDefDispEnv(rdram, ctx, runtime); return;
}


// Function: entry_201de4
// Address: 0x201de4 - 0x201e00

void entry_201de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201de4: 0x26440028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 40));
    // 0x201de8: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x201dec: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201df0: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201df4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x201df8: 0xc080850
    SET_GPR_U32(ctx, 31, 0x201e00);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSetDefDispEnv(rdram, ctx, runtime); return;
}


// Function: entry_201e00
// Address: 0x201e00 - 0x201e1c

void entry_201e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201e00: 0x26440060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 96));
    // 0x201e04: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x201e08: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201e0c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201e10: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x201e14: 0xc08091e
    SET_GPR_U32(ctx, 31, 0x201e1c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceGsSetDefDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_201e1c
// Address: 0x201e1c - 0x201e38

void entry_201e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201e1c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201e20: 0x26440150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 336));
    // 0x201e24: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x201e28: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201e2c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201e30: 0xc08091e
    SET_GPR_U32(ctx, 31, 0x201e38);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    sceGsSetDefDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_201e38
// Address: 0x201e38 - 0x201e80

void entry_201e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201e38: 0x12e0001d
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 17), 17));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_201eb0(rdram, ctx, runtime); return;
    }
    // 0x201e40: 0x24100800
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2048));
    // 0x201e44: 0x1e8c43
    SET_GPR_S32(ctx, 17, SRA32(GPR_S32(ctx, 30), 17));
    // 0x201e48: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x201e4c: 0x2118823
    SET_GPR_U32(ctx, 17, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x201e50: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x201e54: 0x2028023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x201e58: 0x264400e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 224));
    // 0x201e5c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x201e60: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x201e64: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201e68: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x201e6c: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201e70: 0x280482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201e74: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x201e78: 0xc080998
    SET_GPR_U32(ctx, 31, 0x201e80);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSetDefClear(rdram, ctx, runtime); return;
}


// Function: entry_201e80
// Address: 0x201e80 - 0x201eb0

void entry_201e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201e80: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x201e84: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x201e88: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x201e8c: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x201e90: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x201e94: 0x264401d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 464));
    // 0x201e98: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x201e9c: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201ea0: 0x280482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201ea4: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x201ea8: 0xc080998
    SET_GPR_U32(ctx, 31, 0x201eb0);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSetDefClear(rdram, ctx, runtime); return;
}


// Function: entry_201eb0
// Address: 0x201eb0 - 0x201f54

void entry_201eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x201eb0: 0x700014a9
    SET_GPR_VEC(ctx, 2, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x201eb4: 0x2409000e
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 14));
    // 0x201eb8: 0x7e420050
    WRITE128(ADD32(GPR_U32(ctx, 18), 80), GPR_VEC(ctx, 2));
    // 0x201ebc: 0x24058000
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294934528));
    // 0x201ec0: 0x7e420140
    WRITE128(ADD32(GPR_U32(ctx, 18), 320), GPR_VEC(ctx, 2));
    // 0x201ec4: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x201ec8: 0xde440050
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x201ecc: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x201ed0: 0xde460140
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x201ed4: 0x137100b
    if (GPR_U32(ctx, 23) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 9));
    // 0x201ed8: 0x852024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x201edc: 0x137180b
    if (GPR_U32(ctx, 23) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 9));
    // 0x201ee0: 0xc53024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x201ee4: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x201ee8: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x201eec: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x201ef0: 0xde470058
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x201ef4: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x201ef8: 0xde480148
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 18), 328)));
    // 0x201efc: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x201f00: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x201f04: 0x3193a
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) >> 4);
    // 0x201f08: 0x2405fff0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967280));
    // 0x201f0c: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x201f10: 0x2137c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 13));
    // 0x201f14: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x201f18: 0x832024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x201f1c: 0x1054024
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x201f20: 0xe53824
    SET_GPR_U32(ctx, 7, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x201f24: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x201f28: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x201f2c: 0x1094025
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), GPR_U32(ctx, 9)));
    // 0x201f30: 0xe93825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 9)));
    // 0x201f34: 0xfe440050
    WRITE64(ADD32(GPR_U32(ctx, 18), 80), GPR_U64(ctx, 4));
    // 0x201f38: 0xfe460140
    WRITE64(ADD32(GPR_U32(ctx, 18), 320), GPR_U64(ctx, 6));
    // 0x201f3c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x201f40: 0xfe470058
    WRITE64(ADD32(GPR_U32(ctx, 18), 88), GPR_U64(ctx, 7));
    // 0x201f44: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x201f48: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x201f4c: 0xc0808ec
    SET_GPR_U32(ctx, 31, 0x201f54);
    WRITE64(ADD32(GPR_U32(ctx, 18), 328), GPR_U64(ctx, 8));
    sceGszbufaddr(rdram, ctx, runtime); return;
}


// Function: entry_201f54
// Address: 0x201f54 - 0x201ff8

void entry_201f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x201f54) {
        switch (ctx->pc) {
            case 0x201f90: ctx->pc = 0; goto label_201f90;
            case 0x201fcc: ctx->pc = 0; goto label_201fcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x201f54: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x201f58: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x201f5c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x201f60: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x201f64: 0x34840001
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 1));
    // 0x201f68: 0xdc620000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x201f6c: 0x3403ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 65535));
    // 0x201f70: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x201f74: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x201f78: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x201f7c: 0x10440004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_201f90;
    }
    // 0x201f84: 0x84620000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x201f88: 0x14400010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_201fcc;
    }
label_201f90:
    // 0x201f90: 0x63043
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 1));
    // 0x201f94: 0xde440038
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x201f98: 0xde430060
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 96)));
    // 0x201f9c: 0x61400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 16));
    // 0x201fa0: 0x2405fe00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294966784));
    // 0x201fa4: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x201fa8: 0x651824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x201fac: 0x304201ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 511));
    // 0x201fb0: 0x852024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x201fb4: 0x30c601ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), 511));
    // 0x201fb8: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x201fbc: 0x661825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x201fc0: 0xfe430060
    WRITE64(ADD32(GPR_U32(ctx, 18), 96), GPR_U64(ctx, 3));
    // 0x201fc4: 0xfe440038
    WRITE64(ADD32(GPR_U32(ctx, 18), 56), GPR_U64(ctx, 4));
    // 0x201fc8: 0xdfbf00c0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 192)));
label_201fcc:
    // 0x201fcc: 0xdfbe00b0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x201fd0: 0xdfb700a0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x201fd4: 0xdfb60090
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x201fd8: 0xdfb50080
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x201fdc: 0xdfb40070
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x201fe0: 0xdfb30060
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x201fe4: 0xdfb20050
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x201fe8: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x201fec: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x201ff0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceGsSwapDBuff
// Address: 0x201ff8 - 0x202020

void entry_202020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202020: 0x12000005
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202038; return;
    }
    // 0x202028: 0xc08071e
    SET_GPR_U32(ctx, 31, 0x202030);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    sceGsPutDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_202030
// Address: 0x202030 - 0x202040

void entry_202030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202030) {
        switch (ctx->pc) {
            case 0x202038: ctx->pc = 0; goto label_202038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202030: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202044; return;
    }
label_202038:
    // 0x202038: 0xc08071e
    SET_GPR_U32(ctx, 31, 0x202040);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 80));
    sceGsPutDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_202040
// Address: 0x202040 - 0x202058

void entry_202040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202040) {
        switch (ctx->pc) {
            case 0x202044: ctx->pc = 0; goto label_202044;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202040: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_202044:
    // 0x202044: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202048: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20204c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202054: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202058; return;
}


// Function: sceGsPutIMR
// Address: 0x202058 - 0x202070

void entry_202070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202070: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x202074: 0xc07db1c
    SET_GPR_U32(ctx, 31, 0x20207c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GsPutIMR(rdram, ctx, runtime); return;
}


// Function: entry_20207c
// Address: 0x20207c - 0x202098

void entry_20207c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20207c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x202080: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202084: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202088: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20208c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202094: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202098; return;
}


// Function: sceGsSetHalfOffset
// Address: 0x202098 - 0x202120

void FUN_00202120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202120: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x202124: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x202128: 0xc07db18
    SET_GPR_U32(ctx, 31, 0x202130);
    GsGetIMR(rdram, ctx, runtime); return;
}


// Function: entry_202130
// Address: 0x202130 - 0x202140

void entry_202130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202130: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202134: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20213c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202140; return;
}


// Function: sceGsSetDefDispEnv
// Address: 0x202140 - 0x202190

void entry_202190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202190) {
        switch (ctx->pc) {
            case 0x2021bc: ctx->pc = 0; goto label_2021bc;
            case 0x2021c0: ctx->pc = 0; goto label_2021c0;
            case 0x20221c: ctx->pc = 0; goto label_20221c;
            case 0x20225c: ctx->pc = 0; goto label_20225c;
            case 0x202274: ctx->pc = 0; goto label_202274;
            case 0x202294: ctx->pc = 0; goto label_202294;
            case 0x2022c4: ctx->pc = 0; goto label_2022c4;
            case 0x202304: ctx->pc = 0; goto label_202304;
            case 0x20230c: ctx->pc = 0; goto label_20230c;
            case 0x202324: ctx->pc = 0; goto label_202324;
            case 0x20233c: ctx->pc = 0; goto label_20233c;
            case 0x202358: ctx->pc = 0; goto label_202358;
            case 0x202380: ctx->pc = 0; goto label_202380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202190: 0x24030066
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 102));
    // 0x202194: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x202198: 0xfe230000
    WRITE64(ADD32(GPR_U32(ctx, 17), 0), GPR_U64(ctx, 3));
    // 0x20219c: 0x84c20000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x2021a0: 0x10400006
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 6), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2021bc;
    }
    // 0x2021a8: 0x84c20004
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x2021ac: 0x14400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2021c0;
    }
    // 0x2021b4: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2021c0;
    }
label_2021bc:
    // 0x2021bc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_2021c0:
    // 0x2021c0: 0xfe220008
    WRITE64(ADD32(GPR_U32(ctx, 17), 8), GPR_U64(ctx, 2));
    // 0x2021c4: 0x2602003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 63));
    // 0x2021c8: 0x32a3000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 21), 15));
    // 0x2021cc: 0x21183
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 6));
    // 0x2021d0: 0x31bf8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 15);
    // 0x2021d4: 0x3042003f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 63));
    // 0x2021d8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x2021dc: 0x21278
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 9);
    // 0x2021e0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2021e4: 0xfe230010
    WRITE64(ADD32(GPR_U32(ctx, 17), 16), GPR_U64(ctx, 3));
    // 0x2021e8: 0x84c50002
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 2)));
    // 0x2021ec: 0x14a40029
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 4)) {
        goto label_202294;
    }
    // 0x2021f4: 0x71400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 16));
    // 0x2021f8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2021fc: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x202200: 0x14430016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 2559));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_20225c;
    }
    // 0x202208: 0x26430032
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 50));
    // 0x20220c: 0x50001a
    { int32_t divisor = GPR_S32(ctx, 16); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 16) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,16); } }
    // 0x202210: 0x30630fff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4095));
    // 0x202214: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_20221c;
    }
label_20221c:
    // 0x20221c: 0x33b38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) << 12);
    // 0x202220: 0x84c60004
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x202224: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x202228: 0x72822818
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x20222c: 0x502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x202230: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x202234: 0x64a3027c
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 5) + (int64_t)636);
    // 0x202238: 0x255f8
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) << 23);
    // 0x20223c: 0x30650fff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 3), 4095));
    // 0x202240: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x202244: 0x10c0002f
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) << (32 + 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_202304;
    }
    // 0x20224c: 0x131040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 1));
    // 0x202250: 0x1431825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 10), GPR_U32(ctx, 3)));
    // 0x202254: 0x1000002d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20230c;
    }
label_20225c:
    // 0x20225c: 0x2666ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x202260: 0x50001a
    { int32_t divisor = GPR_S32(ctx, 16); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 16) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,16); } }
    // 0x202264: 0x6333c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 12));
    // 0x202268: 0x26450019
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 25));
    // 0x20226c: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_202274;
    }
label_202274:
    // 0x202274: 0x30a50fff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 4095));
    // 0x202278: 0x52b38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 12);
    // 0x20227c: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x202280: 0x2823818
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x202284: 0x70502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x202288: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20228c: 0x10000032
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 7) + (int64_t)636);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202358;
    }
label_202294:
    // 0x202294: 0x14a2003a
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_202380;
    }
    // 0x20229c: 0x71400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 16));
    // 0x2022a0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2022a4: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x2022a8: 0x1443001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 2559));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_202324;
    }
    // 0x2022b0: 0x26430048
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 72));
    // 0x2022b4: 0x50001a
    { int32_t divisor = GPR_S32(ctx, 16); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 16) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,16); } }
    // 0x2022b8: 0x30630fff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4095));
    // 0x2022bc: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_2022c4;
    }
label_2022c4:
    // 0x2022c4: 0x33b38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) << 12);
    // 0x2022c8: 0x84c60004
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x2022cc: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x2022d0: 0x72822818
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x2022d4: 0x502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x2022d8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x2022dc: 0x64a30290
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 5) + (int64_t)656);
    // 0x2022e0: 0x255f8
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) << 23);
    // 0x2022e4: 0x30650fff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 3), 4095));
    // 0x2022e8: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x2022ec: 0x10c00005
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) << (32 + 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_202304;
    }
    // 0x2022f4: 0x131040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 1));
    // 0x2022f8: 0x1431825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 10), GPR_U32(ctx, 3)));
    // 0x2022fc: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20230c;
    }
label_202304:
    // 0x202304: 0x2662ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x202308: 0x1431825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 10), GPR_U32(ctx, 3)));
label_20230c:
    // 0x20230c: 0x2133c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 12));
    // 0x202310: 0xa21025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x202314: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x202318: 0x671025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x20231c: 0x1000001a
    WRITE64(ADD32(GPR_U32(ctx, 17), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_202388(rdram, ctx, runtime); return;
    }
label_202324:
    // 0x202324: 0x2666ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x202328: 0x50001a
    { int32_t divisor = GPR_S32(ctx, 16); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 16) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,16); } }
    // 0x20232c: 0x6333c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 12));
    // 0x202330: 0x26450024
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 36));
    // 0x202334: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_20233c;
    }
label_20233c:
    // 0x20233c: 0x30a50fff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 4095));
    // 0x202340: 0x52b38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 12);
    // 0x202344: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x202348: 0x2823818
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20234c: 0x70502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x202350: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x202354: 0x64e30290
    SET_GPR_S64(ctx, 3, (int64_t)GPR_S64(ctx, 7) + (int64_t)656);
label_202358:
    // 0x202358: 0x215f8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 23);
    // 0x20235c: 0x30630fff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4095));
    // 0x202360: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x202364: 0x661825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x202368: 0x4203c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 0));
    // 0x20236c: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x202370: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x202374: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x202378: 0x10000003
    WRITE64(ADD32(GPR_U32(ctx, 17), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_202388(rdram, ctx, runtime); return;
    }
label_202380:
    // 0x202380: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x202388);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964496));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_202388
// Address: 0x202388 - 0x2023b0

void entry_202388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202388: 0xfe200020
    WRITE64(ADD32(GPR_U32(ctx, 17), 32), GPR_U64(ctx, 0));
    // 0x20238c: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x202390: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x202394: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x202398: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20239c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2023a0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2023a4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2023a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceGszbufaddr
// Address: 0x2023b0 - 0x2023e0

void entry_2023e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2023e0) {
        switch (ctx->pc) {
            case 0x20241c: ctx->pc = 0; goto label_20241c;
            case 0x202430: ctx->pc = 0; goto label_202430;
            case 0x202458: ctx->pc = 0; goto label_202458;
            case 0x20245c: ctx->pc = 0; goto label_20245c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2023e0: 0x2603003f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 63));
    // 0x2023e4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2023e8: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2023ec: 0x2610007e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 126));
    // 0x2023f0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x2023f4: 0x32310002
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), 2));
    // 0x2023f8: 0x62800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x2023fc: 0x12200007
    SET_GPR_S32(ctx, 16, SRA32(GPR_S32(ctx, 16), 6));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_20241c;
    }
    // 0x202404: 0x2642003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 63));
    // 0x202408: 0x2643007e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 126));
    // 0x20240c: 0x82202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x202410: 0x44180b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 2));
    // 0x202414: 0x10000006
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 3), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202430;
    }
label_20241c:
    // 0x20241c: 0x2642001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 31));
    // 0x202420: 0x2643003e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 62));
    // 0x202424: 0x82202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x202428: 0x44180b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 2));
    // 0x20242c: 0x33143
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 3), 5));
label_202430:
    // 0x202430: 0xdca20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x202434: 0x3403ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 65535));
    // 0x202438: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x20243c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x202440: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x202444: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x202448: 0x14440003
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_202458;
    }
    // 0x202450: 0x10000002
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20245c;
    }
label_202458:
    // 0x202458: 0x21440
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 17));
label_20245c:
    // 0x20245c: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x202460: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202464: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202468: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20246c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202470: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceGsSetDefDrawEnv
// Address: 0x202478 - 0x202508

void entry_202508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202508) {
        switch (ctx->pc) {
            case 0x20252c: ctx->pc = 0; goto label_20252c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202508: 0x2143c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 16));
    // 0x20250c: 0x3263000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 19), 15));
    // 0x202510: 0x2143f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 16));
    // 0x202514: 0x31e38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 24);
    // 0x202518: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20251c: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x202520: 0x42478
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 17);
    // 0x202524: 0x1000000a
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202550; return;
    }
label_20252c:
    // 0x20252c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x202530: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x202534: 0xc0808ec
    SET_GPR_U32(ctx, 31, 0x20253c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceGszbufaddr(rdram, ctx, runtime); return;
}


// Function: entry_20253c
// Address: 0x20253c - 0x202660

void entry_20253c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20253c) {
        switch (ctx->pc) {
            case 0x202550: ctx->pc = 0; goto label_202550;
            case 0x2025f8: ctx->pc = 0; goto label_2025f8;
            case 0x202604: ctx->pc = 0; goto label_202604;
            case 0x202628: ctx->pc = 0; goto label_202628;
            case 0x20262c: ctx->pc = 0; goto label_20262c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20253c: 0x2143c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 16));
    // 0x202540: 0x3263000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 19), 15));
    // 0x202544: 0x2143f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 16));
    // 0x202548: 0x31e38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 24);
    // 0x20254c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_202550:
    // 0x202550: 0xfe020010
    WRITE64(ADD32(GPR_U32(ctx, 16), 16), GPR_U64(ctx, 2));
    // 0x202554: 0x111043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 17), 1));
    // 0x202558: 0x121843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 18), 1));
    // 0x20255c: 0x2143c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 16));
    // 0x202560: 0x24040800
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2048));
    // 0x202564: 0x31c3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 16));
    // 0x202568: 0x2143f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 16));
    // 0x20256c: 0x31c3f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 16));
    // 0x202570: 0x82102f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) - GPR_U64(ctx, 2));
    // 0x202574: 0x83202f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) - GPR_U64(ctx, 3));
    // 0x202578: 0x2113c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 4));
    // 0x20257c: 0x2646ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x202580: 0x2625ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x202584: 0x42138
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 4);
    // 0x202588: 0xde030040
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x20258c: 0xde070050
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x202590: 0x52c3c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 16));
    // 0x202594: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x202598: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x20259c: 0x240b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2025a0: 0xc53025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x2025a4: 0x24020018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    // 0x2025a8: 0x6b1825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 11)));
    // 0x2025ac: 0xeb3825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 11)));
    // 0x2025b0: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x2025b4: 0x2408001a
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 26));
    // 0x2025b8: 0x24090046
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 70));
    // 0x2025bc: 0x240a0045
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 69));
    // 0x2025c0: 0xfe020028
    WRITE64(ADD32(GPR_U32(ctx, 16), 40), GPR_U64(ctx, 2));
    // 0x2025c4: 0xfe040020
    WRITE64(ADD32(GPR_U32(ctx, 16), 32), GPR_U64(ctx, 4));
    // 0x2025c8: 0x32820002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 20), 2));
    // 0x2025cc: 0xfe050038
    WRITE64(ADD32(GPR_U32(ctx, 16), 56), GPR_U64(ctx, 5));
    // 0x2025d0: 0xfe060030
    WRITE64(ADD32(GPR_U32(ctx, 16), 48), GPR_U64(ctx, 6));
    // 0x2025d4: 0xfe080048
    WRITE64(ADD32(GPR_U32(ctx, 16), 72), GPR_U64(ctx, 8));
    // 0x2025d8: 0xfe030040
    WRITE64(ADD32(GPR_U32(ctx, 16), 64), GPR_U64(ctx, 3));
    // 0x2025dc: 0xfe090058
    WRITE64(ADD32(GPR_U32(ctx, 16), 88), GPR_U64(ctx, 9));
    // 0x2025e0: 0xfe070050
    WRITE64(ADD32(GPR_U32(ctx, 16), 80), GPR_U64(ctx, 7));
    // 0x2025e4: 0x10400004
    WRITE64(ADD32(GPR_U32(ctx, 16), 104), GPR_U64(ctx, 10));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2025f8;
    }
    // 0x2025ec: 0xde020060
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x2025f0: 0x10000004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202604;
    }
label_2025f8:
    // 0x2025f8: 0xde020060
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x2025fc: 0x2403fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x202600: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_202604:
    // 0x202604: 0xfe020060
    WRITE64(ADD32(GPR_U32(ctx, 16), 96), GPR_U64(ctx, 2));
    // 0x202608: 0x24020047
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 71));
    // 0x20260c: 0x12a00006
    WRITE64(ADD32(GPR_U32(ctx, 16), 120), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_202628;
    }
    // 0x202614: 0x32a20003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 3));
    // 0x202618: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x20261c: 0x21478
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 17);
    // 0x202620: 0x10000002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20262c;
    }
label_202628:
    // 0x202628: 0x3c020003
    SET_GPR_U32(ctx, 2, ((uint32_t)3 << 16));
label_20262c:
    // 0x20262c: 0xfe020070
    WRITE64(ADD32(GPR_U32(ctx, 16), 112), GPR_U64(ctx, 2));
    // 0x202630: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x202634: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x202638: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20263c: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x202640: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x202644: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202648: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20264c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202650: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202654: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20265c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202660; return;
}


// Function: sceGsSetDefClear
// Address: 0x202660 - 0x202768

void entry_202864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202864: 0xc080a2a
    SET_GPR_U32(ctx, 31, 0x20286c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sceDmaPutEnv(rdram, ctx, runtime); return;
}


// Function: entry_20286c
// Address: 0x20286c - 0x2028a8

void entry_20286c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20286c) {
        switch (ctx->pc) {
            case 0x202890: ctx->pc = 0; goto label_202890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20286c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x202870: 0x16030007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        goto label_202890;
    }
    // 0x202878: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20287c: 0x3463e000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 57344));
    // 0x202880: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x202884: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x202888: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x20288c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_202890:
    // 0x202890: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x202894: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202898: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20289c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2028a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2028a8; return;
}


// Function: sceDmaPutEnv
// Address: 0x2028a8 - 0x202a80

void entry_202ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202ac8) {
        switch (ctx->pc) {
            case 0x202ae0: ctx->pc = 0; goto label_202ae0;
            case 0x202b00: ctx->pc = 0; goto label_202b00;
            case 0x202b10: ctx->pc = 0; goto label_202b10;
            case 0x202b24: ctx->pc = 0; goto label_202b24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202ac8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202acc: 0x41202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 4), 8));
    // 0x202ad0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x202ad4: 0x1040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_202b00;
    }
    // 0x202adc: 0x2405feff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967039));
label_202ae0:
    // 0x202ae0: 0x851824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x202ae4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x202ae8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x202aec: 0x0
    // NOP
    // 0x202af0: 0x0
    // NOP
    // 0x202af4: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_202ae0;
    }
    // 0x202afc: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
label_202b00:
    // 0x202b00: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202b04: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x202b08: 0x1440ffeb
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x202AB8; return;
    }
label_202b10:
    // 0x202b10: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x202b14: 0x8e030030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x202b18: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x202b1c: 0x54620001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 19));
        goto label_202b24;
    }
label_202b24:
    // 0x202b24: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202b28: 0x2403fff3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967283));
    // 0x202b2c: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x202b30: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x202b34: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x202b38: 0x34420105
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 261));
    // 0x202b3c: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202b40: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x202b44: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202b48: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202b4c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202b50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202b58: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x202b5c: 0x0
    // NOP
    // 0x202b60: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x202b64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202b68; return;
}


// Function: sceDmaRecv
// Address: 0x202b68 - 0x202ba8

void entry_202ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202ba8) {
        switch (ctx->pc) {
            case 0x202bc0: ctx->pc = 0; goto label_202bc0;
            case 0x202be0: ctx->pc = 0; goto label_202be0;
            case 0x202bf0: ctx->pc = 0; goto label_202bf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202ba8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202bac: 0x41202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 4), 8));
    // 0x202bb0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x202bb4: 0x1040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_202be0;
    }
    // 0x202bbc: 0x2405feff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967039));
label_202bc0:
    // 0x202bc0: 0x851824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x202bc4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x202bc8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x202bcc: 0x0
    // NOP
    // 0x202bd0: 0x0
    // NOP
    // 0x202bd4: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_202bc0;
    }
    // 0x202bdc: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
label_202be0:
    // 0x202be0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202be4: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x202be8: 0x1440ffeb
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x202B98; return;
    }
label_202bf0:
    // 0x202bf0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x202bf4: 0x2403fff3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967283));
    // 0x202bf8: 0x2404fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x202bfc: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x202c00: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x202c04: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202c08: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x202c0c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202c10: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x202c14: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202c18: 0x34420100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 256));
    // 0x202c1c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x202c20: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202c24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202c2c: 0x0
    // NOP
    // 0x202c30: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x202c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202c38; return;
}


// Function: sceDmaSync
// Address: 0x202c38 - 0x202c98

void entry_202c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202c98) {
        switch (ctx->pc) {
            case 0x202cb0: ctx->pc = 0; goto label_202cb0;
            case 0x202cd0: ctx->pc = 0; goto label_202cd0;
            case 0x202ce0: ctx->pc = 0; goto label_202ce0;
            case 0x202ce4: ctx->pc = 0; goto label_202ce4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202c98: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x202c9c: 0x41202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 4), 8));
    // 0x202ca0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x202ca4: 0x1040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_202cd0;
    }
    // 0x202cac: 0x2405feff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967039));
label_202cb0:
    // 0x202cb0: 0x851824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x202cb4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x202cb8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x202cbc: 0x0
    // NOP
    // 0x202cc0: 0x0
    // NOP
    // 0x202cc4: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_202cb0;
    }
    // 0x202ccc: 0xae230000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
label_202cd0:
    // 0x202cd0: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x202cd4: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x202cd8: 0x1440ffeb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x202C88; return;
    }
label_202ce0:
    // 0x202ce0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_202ce4:
    // 0x202ce4: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202ce8: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202cec: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202cf0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202cfc: 0x0
    // NOP
    // 0x202d00: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x202d04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202d08; return;
}


// Function: FUN_00202d08
// Address: 0x202d08 - 0x202d18

void FUN_00202d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202d08: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x202d0c: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x202d10: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x202d18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_202d18
// Address: 0x202d18 - 0x202d30

void entry_202d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202d18: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x202d1c: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x202d20: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202d24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202d2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202d30; return;
}


// Function: sceCdDelayThread
// Address: 0x202d30 - 0x202d5c

void entry_202d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202d5c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x202d60: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x202d64: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x202d68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x202d6c: 0xc07da78
    SET_GPR_U32(ctx, 31, 0x202d74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 11528));
    SetAlarm(rdram, ctx, runtime); return;
}


// Function: entry_202d74
// Address: 0x202d74 - 0x202d7c

void entry_202d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202d74: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x202d7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_202d7c
// Address: 0x202d7c - 0x202d84

void entry_202d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202d7c: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x202d84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_202d84
// Address: 0x202d84 - 0x202df4

void entry_202d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202d84) {
        switch (ctx->pc) {
            case 0x202da0: ctx->pc = 0; goto label_202da0;
            case 0x202de8: ctx->pc = 0; goto label_202de8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202d84: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x202d88: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202d8c: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202d90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202d98: 0x27bd0030
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    // 0x202d9c: 0x0
    // NOP
label_202da0:
    // 0x202da0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x202da4: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x202da8: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x202dac: 0xffbf0010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 31));
    // 0x202db0: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x202db4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x202db8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x202dbc: 0xae039454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 3));
    // 0x202dc0: 0x8e029454
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294939732)));
    // 0x202dc4: 0xac829458
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294939736), GPR_U32(ctx, 2));
    // 0x202dc8: 0x8e039454
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294939732)));
    // 0x202dcc: 0x14650006
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_202de8;
    }
    // 0x202dd4: 0xae009454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 0));
    // 0x202dd8: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x202ddc: 0xac409430
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939696), GPR_U32(ctx, 0));
    // 0x202de0: 0x10000014
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202E34; return;
    }
label_202de8:
    // 0x202de8: 0x8c449428
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939688)));
    // 0x202dec: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x202df4);
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_202df4
// Address: 0x202df4 - 0x202e1c

void entry_202df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202df4: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x202df8: 0x8c629414
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294939668)));
    // 0x202dfc: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202E24; return;
    }
    // 0x202e04: 0x8c43a7c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294944704)));
    // 0x202e08: 0x10600006
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x202E24; return;
    }
    // 0x202e10: 0x8c449420
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939680)));
    // 0x202e14: 0xc07dad4
    SET_GPR_U32(ctx, 31, 0x202e1c);
    iSignalSema(rdram, ctx, runtime); return;
}


// Function: entry_202e1c
// Address: 0x202e1c - 0x202ef0

void entry_202e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202e1c) {
        switch (ctx->pc) {
            case 0x202e24: ctx->pc = 0; goto label_202e24;
            case 0x202e2c: ctx->pc = 0; goto label_202e2c;
            case 0x202e34: ctx->pc = 0; goto label_202e34;
            case 0x202e80: ctx->pc = 0; goto label_202e80;
            case 0x202ea8: ctx->pc = 0; goto label_202ea8;
            case 0x202eac: ctx->pc = 0; goto label_202eac;
            case 0x202ec8: ctx->pc = 0; goto label_202ec8;
            case 0x202ee8: ctx->pc = 0; goto label_202ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202e1c: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202e2c;
    }
label_202e24:
    // 0x202e24: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x202e28: 0xac409430
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939696), GPR_U32(ctx, 0));
label_202e2c:
    // 0x202e2c: 0xae009454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 0));
    // 0x202e30: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_202e34:
    // 0x202e34: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x202e38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202e40: 0xae400030
    WRITE32(ADD32(GPR_U32(ctx, 18), 48), GPR_U32(ctx, 0));
    // 0x202e44: 0x0
    // NOP
    // 0x202e48: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x202e4c: 0x0
    // NOP
    // 0x202e50: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x202e54: 0x823025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x202e58: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x202e5c: 0x18400012
    SET_GPR_U32(ctx, 9, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_202ea8;
    }
    // 0x202e64: 0x8cc80008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x202e68: 0x1840000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_202ea8;
    }
    // 0x202e70: 0x24c70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 16));
    // 0x202e74: 0x3c090028
    SET_GPR_U32(ctx, 9, ((uint32_t)40 << 16));
    // 0x202e78: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x202e7c: 0x0
    // NOP
label_202e80:
    // 0x202e80: 0x1052021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x202e84: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x202e88: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x202e8c: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x202e90: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x202e94: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x202e98: 0x1440fff9
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_202e80;
    }
    // 0x202ea0: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202eac;
    }
label_202ea8:
    // 0x202ea8: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
label_202eac:
    // 0x202eac: 0x1840000e
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_202ee8;
    }
    // 0x202eb4: 0x8cc8000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x202eb8: 0x1840000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_202ee8;
    }
    // 0x202ec0: 0x24c70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 80));
    // 0x202ec4: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
label_202ec8:
    // 0x202ec8: 0x1052021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    // 0x202ecc: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x202ed0: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x202ed4: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x202ed8: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x202edc: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x202ee0: 0x1440fff9
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_202ec8;
    }
label_202ee8:
    // 0x202ee8: 0x8080b68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 4294939732));
    ctx->pc = 0x202da0; return;
}


// Function: cmd_sem_init
// Address: 0x202ef0 - 0x202f44

void entry_202f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202f44: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x202f48: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x202f50);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294939688), GPR_U32(ctx, 2));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_202f50
// Address: 0x202f50 - 0x202f60

void entry_202f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202f50: 0xae02942c
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939692), GPR_U32(ctx, 2));
    // 0x202f54: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x202f58: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x202f60);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_202f60
// Address: 0x202f60 - 0x202f88

void entry_202f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202f60) {
        switch (ctx->pc) {
            case 0x202f74: ctx->pc = 0; goto label_202f74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202f60: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x202f64: 0xac629420
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939680), GPR_U32(ctx, 2));
    // 0x202f68: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x202f6c: 0xac409430
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939696), GPR_U32(ctx, 0));
    // 0x202f70: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
label_202f74:
    // 0x202f74: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x202f78: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x202f7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x202f84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x202f88; return;
}


// Function: cdvd_exit
// Address: 0x202f88 - 0x202fb8

void entry_202fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x202fb8) {
        switch (ctx->pc) {
            case 0x202fc0: ctx->pc = 0; goto label_202fc0;
            case 0x202fc8: ctx->pc = 0; goto label_202fc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x202fb8: 0x10000003
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_202fc8;
    }
label_202fc0:
    // 0x202fc0: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x202fc4: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
label_202fc8:
    // 0x202fc8: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x202fd0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939688)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_202fd0
// Address: 0x202fd0 - 0x202fdc

void entry_202fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202fd0: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x202fd4: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x202fdc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_202fdc
// Address: 0x202fdc - 0x202fe4

void entry_202fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202fdc: 0xc07dacc
    SET_GPR_U32(ctx, 31, 0x202fe4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294939680)));
    DeleteSema(rdram, ctx, runtime); return;
}


// Function: entry_202fe4
// Address: 0x202fe4 - 0x202fec

void entry_202fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202fe4: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x202fec);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_202fec
// Address: 0x202fec - 0x202ff8

void entry_202fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202fec: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x202ff0: 0xc07e934
    SET_GPR_U32(ctx, 31, 0x202ff8);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 18));
    sceSifRemoveCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_202ff8
// Address: 0x202ff8 - 0x203040

void entry_202ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x202ff8: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x202ffc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x203000: 0x807e76a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    EIntr(rdram, ctx, runtime); return;
    // 0x203008: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x20300c: 0x0
    // NOP
    // 0x203010: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x203014: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x203018: 0x8c45a7c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294944708)));
    // 0x20301c: 0x10a00008
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_203040(rdram, ctx, runtime); return;
    }
    // 0x203024: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203028: 0x8c439424
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939684)));
    // 0x20302c: 0x14600005
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x203044; return;
    }
    // 0x203034: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x203038: 0xa0f809
    SET_GPR_U32(ctx, 31, 0x203040);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294944712)));
    ctx->pc = GPR_U32(ctx, 5); return;
}


// Function: entry_203040
// Address: 0x203040 - 0x203050

void entry_203040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203040) {
        switch (ctx->pc) {
            case 0x203044: ctx->pc = 0; goto label_203044;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203040: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_203044:
    // 0x203044: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20304c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x203050; return;
}


// Function: PowerOffCB
// Address: 0x203050 - 0x203070

void entry_203070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203070: 0x3c050020
    SET_GPR_U32(ctx, 5, ((uint32_t)32 << 16));
    // 0x203074: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x203078: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20307c: 0x24a53010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12304));
    // 0x203080: 0xc07e928
    SET_GPR_U32(ctx, 31, 0x203088);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 18));
    sceSifAddCmdHandler(rdram, ctx, runtime); return;
}


// Function: entry_203088
// Address: 0x203088 - 0x203090

void entry_203088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203088: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x203090);
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_203090
// Address: 0x203090 - 0x2030c0

void entry_203090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203090: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x203094: 0xae009424
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939684), GPR_U32(ctx, 0));
    // 0x203098: 0xac71943c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939708), GPR_U32(ctx, 17));
    // 0x20309c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2030a0: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2030a4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2030a8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2030ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2030b4: 0x0
    // NOP
    // 0x2030b8: 0x27bd00b0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    // 0x2030bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2030c0; return;
}


// Function: _sceCd_ncmd_prechk
// Address: 0x2030c0 - 0x2030e0

void entry_2030e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2030e0: 0x8e049428
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294939688)));
    // 0x2030e4: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x2030ec);
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_2030ec
// Address: 0x2030ec - 0x203118

void entry_2030ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2030ec: 0x8e039428
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294939688)));
    // 0x2030f0: 0x1062000b
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x203120; return;
    }
    // 0x2030f8: 0x8c439410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939664)));
    // 0x2030fc: 0x18600016
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        entry_203158(rdram, ctx, runtime); return;
    }
    // 0x203104: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x203108: 0x8c46941c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4294939676)));
    // 0x20310c: 0x2484f5f8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964728));
    // 0x203110: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x203118);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_203118
// Address: 0x203118 - 0x20313c

void entry_203118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203118) {
        switch (ctx->pc) {
            case 0x203120: ctx->pc = 0; goto label_203120;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203118: 0x1000003f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203218; return;
    }
label_203120:
    // 0x203120: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x203124: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x203128: 0x8c44a7d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294944720)));
    // 0x20312c: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
    // 0x203130: 0xac71941c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939676), GPR_U32(ctx, 17));
    // 0x203134: 0xc07daa8
    SET_GPR_U32(ctx, 31, 0x20313c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944728));
    ReferThreadStatus(rdram, ctx, runtime); return;
}


// Function: entry_20313c
// Address: 0x20313c - 0x203144

void entry_20313c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20313c: 0xc080cb2
    SET_GPR_U32(ctx, 31, 0x203144);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    sceCdSync(rdram, ctx, runtime); return;
}


// Function: entry_203144
// Address: 0x203144 - 0x203158

void entry_203144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203144: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203160; return;
    }
    // 0x20314c: 0x8e049428
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294939688)));
    // 0x203150: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203158);
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203158
// Address: 0x203158 - 0x203168

void entry_203158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203158) {
        switch (ctx->pc) {
            case 0x203160: ctx->pc = 0; goto label_203160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203158: 0x1000002f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203218; return;
    }
label_203160:
    // 0x203160: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x203168);
    SET_GPR_U32(ctx, 18, ((uint32_t)40 << 16));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_203168
// Address: 0x203168 - 0x2031bc

void entry_203168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203168) {
        switch (ctx->pc) {
            case 0x203180: ctx->pc = 0; goto label_203180;
            case 0x203188: ctx->pc = 0; goto label_203188;
            case 0x2031a4: ctx->pc = 0; goto label_2031a4;
            case 0x2031a8: ctx->pc = 0; goto label_2031a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203168: 0x8e429438
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4294939704)));
    // 0x20316c: 0x441002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203218; return;
    }
    // 0x203174: 0x1000000b
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2031a4;
    }
    // 0x20317c: 0x0
    // NOP
label_203180:
    // 0x203180: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x203184: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_203188:
    // 0x203188: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20318c: 0x0
    // NOP
    // 0x203190: 0x0
    // NOP
    // 0x203194: 0x0
    // NOP
    // 0x203198: 0x0
    // NOP
    // 0x20319c: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_203188;
    }
label_2031a4:
    // 0x2031a4: 0x2630a5d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294944208));
label_2031a8:
    // 0x2031a8: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x2031ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2031b0: 0x34a50595
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1429));
    // 0x2031b4: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x2031bc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_2031bc
// Address: 0x2031bc - 0x2031e0

void entry_2031bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2031bc: 0x4430013
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        ctx->pc = 0x20320C; return;
    }
    // 0x2031c4: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x2031c8: 0x8c439410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939664)));
    // 0x2031cc: 0x18600005
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x2031E4; return;
    }
    // 0x2031d4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x2031d8: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x2031e0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964768));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_2031e0
// Address: 0x2031e0 - 0x203230

void entry_2031e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2031e0) {
        switch (ctx->pc) {
            case 0x2031e4: ctx->pc = 0; goto label_2031e4;
            case 0x2031e8: ctx->pc = 0; goto label_2031e8;
            case 0x20320c: ctx->pc = 0; goto label_20320c;
            case 0x203218: ctx->pc = 0; goto label_203218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2031e0: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
label_2031e4:
    // 0x2031e4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_2031e8:
    // 0x2031e8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x2031ec: 0x0
    // NOP
    // 0x2031f0: 0x0
    // NOP
    // 0x2031f4: 0x0
    // NOP
    // 0x2031f8: 0x0
    // NOP
    // 0x2031fc: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_2031e8;
    }
    // 0x203204: 0x1000ffe8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294944208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2031A8; return;
    }
label_20320c:
    // 0x20320c: 0x1040ffdc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203180; return;
    }
    // 0x203214: 0xae409438
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294939704), GPR_U32(ctx, 0));
label_203218:
    // 0x203218: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20321c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203220: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203224: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x203228: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdNcmdDiskReady
// Address: 0x203230 - 0x203244

void entry_203244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203244) {
        switch (ctx->pc) {
            case 0x203254: ctx->pc = 0; goto label_203254;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203244: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203254;
    }
    // 0x20324c: 0x1000001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2032B8; return;
    }
label_203254:
    // 0x203254: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203258: 0x24509480
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294939776));
    // 0x20325c: 0x2484a5d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294944208));
    // 0x203260: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203264: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x203268: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20326c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203270: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203274: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203278: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x20327c: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203284);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203284
// Address: 0x203284 - 0x203298

void entry_203284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203284: 0x4410006
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x2032A0; return;
    }
    // 0x20328c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203290: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203298);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939688)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203298
// Address: 0x203298 - 0x2032b4

void entry_203298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203298) {
        switch (ctx->pc) {
            case 0x2032a0: ctx->pc = 0; goto label_2032a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203298: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2032B8; return;
    }
label_2032a0:
    // 0x2032a0: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x2032a4: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x2032a8: 0x8c649428
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939688)));
    // 0x2032ac: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2032b4);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2032b4
// Address: 0x2032b4 - 0x2032c8

void entry_2032b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2032b4) {
        switch (ctx->pc) {
            case 0x2032b8: ctx->pc = 0; goto label_2032b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2032b4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2032b8:
    // 0x2032b8: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2032bc: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2032c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdSync
// Address: 0x2032c8 - 0x2032f4

void entry_2032f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2032f4) {
        switch (ctx->pc) {
            case 0x203300: ctx->pc = 0; goto label_203300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2032f4: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x2032f8: 0x10000003
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_203308(rdram, ctx, runtime); return;
    }
label_203300:
    // 0x203300: 0xc080b4c
    SET_GPR_U32(ctx, 31, 0x203308);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 60));
    sceCdDelayThread(rdram, ctx, runtime); return;
}


// Function: entry_203308
// Address: 0x203308 - 0x20331c

void entry_203308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203308: 0x8e229430
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294939696)));
    // 0x20330c: 0x1440fffc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x203300; return;
    }
    // 0x203314: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x20331c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294944208));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_20331c
// Address: 0x20331c - 0x203348

void entry_20331c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20331c) {
        switch (ctx->pc) {
            case 0x20332c: ctx->pc = 0; goto label_20332c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20331c: 0x1440fff8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x203300; return;
    }
    // 0x203324: 0x1000000c
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203358; return;
    }
label_20332c:
    // 0x20332c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203330: 0x8c439430
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939696)));
    // 0x203334: 0x14600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x203354; return;
    }
    // 0x20333c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203340: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x203348);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294944208));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_203348
// Address: 0x203348 - 0x203368

void entry_203348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203348) {
        switch (ctx->pc) {
            case 0x203354: ctx->pc = 0; goto label_203354;
            case 0x203358: ctx->pc = 0; goto label_203358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203348: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203354;
    }
    // 0x203350: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_203354:
    // 0x203354: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_203358:
    // 0x203358: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20335c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x203360: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdSyncS
// Address: 0x203368 - 0x203390

void entry_203390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203390) {
        switch (ctx->pc) {
            case 0x203398: ctx->pc = 0; goto label_203398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203390: 0x10000003
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2033a0(rdram, ctx, runtime); return;
    }
label_203398:
    // 0x203398: 0xc080b4c
    SET_GPR_U32(ctx, 31, 0x2033a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 60));
    sceCdDelayThread(rdram, ctx, runtime); return;
}


// Function: entry_2033a0
// Address: 0x2033a0 - 0x2033a8

void entry_2033a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2033a0: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x2033a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294946376));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_2033a8
// Address: 0x2033a8 - 0x2033c4

void entry_2033a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2033a8) {
        switch (ctx->pc) {
            case 0x2033b8: ctx->pc = 0; goto label_2033b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2033a8: 0x1440fffb
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x203398; return;
    }
    // 0x2033b0: 0x10000005
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2033C8; return;
    }
label_2033b8:
    // 0x2033b8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x2033bc: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x2033c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_2033c4
// Address: 0x2033c4 - 0x2033d8

void entry_2033c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2033c4) {
        switch (ctx->pc) {
            case 0x2033c8: ctx->pc = 0; goto label_2033c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2033c4: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_2033c8:
    // 0x2033c8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2033cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2033d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2033d8; return;
}


// Function: _sceCd_scmd_prechk
// Address: 0x2033d8 - 0x2033f8

void entry_2033f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2033f8: 0x8e04942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294939692)));
    // 0x2033fc: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x203404);
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_203404
// Address: 0x203404 - 0x203430

void entry_203404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203404: 0x8e03942c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294939692)));
    // 0x203408: 0x1062000b
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x203438; return;
    }
    // 0x203410: 0x8c439410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939664)));
    // 0x203414: 0x18600016
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        entry_203470(rdram, ctx, runtime); return;
    }
    // 0x20341c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x203420: 0x8c469418
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4294939672)));
    // 0x203424: 0x2484f658
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964824));
    // 0x203428: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x203430);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_203430
// Address: 0x203430 - 0x203454

void entry_203430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203430) {
        switch (ctx->pc) {
            case 0x203438: ctx->pc = 0; goto label_203438;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203430: 0x1000003f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203530; return;
    }
label_203438:
    // 0x203438: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x20343c: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x203440: 0x8c44a7d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294944720)));
    // 0x203444: 0x3c050063
    SET_GPR_U32(ctx, 5, ((uint32_t)99 << 16));
    // 0x203448: 0xac719418
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939672), GPR_U32(ctx, 17));
    // 0x20344c: 0xc07daa8
    SET_GPR_U32(ctx, 31, 0x203454);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944728));
    ReferThreadStatus(rdram, ctx, runtime); return;
}


// Function: entry_203454
// Address: 0x203454 - 0x20345c

void entry_203454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203454: 0xc080cda
    SET_GPR_U32(ctx, 31, 0x20345c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    sceCdSyncS(rdram, ctx, runtime); return;
}


// Function: entry_20345c
// Address: 0x20345c - 0x203470

void entry_20345c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20345c: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203478; return;
    }
    // 0x203464: 0x8e04942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294939692)));
    // 0x203468: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203470);
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203470
// Address: 0x203470 - 0x203480

void entry_203470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203470) {
        switch (ctx->pc) {
            case 0x203478: ctx->pc = 0; goto label_203478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203470: 0x1000002f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203530; return;
    }
label_203478:
    // 0x203478: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x203480);
    SET_GPR_U32(ctx, 18, ((uint32_t)40 << 16));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_203480
// Address: 0x203480 - 0x2034d4

void entry_203480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203480) {
        switch (ctx->pc) {
            case 0x203498: ctx->pc = 0; goto label_203498;
            case 0x2034a0: ctx->pc = 0; goto label_2034a0;
            case 0x2034bc: ctx->pc = 0; goto label_2034bc;
            case 0x2034c0: ctx->pc = 0; goto label_2034c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203480: 0x8e429448
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4294939720)));
    // 0x203484: 0x441002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203530; return;
    }
    // 0x20348c: 0x1000000b
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2034bc;
    }
    // 0x203494: 0x0
    // NOP
label_203498:
    // 0x203498: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x20349c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_2034a0:
    // 0x2034a0: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x2034a4: 0x0
    // NOP
    // 0x2034a8: 0x0
    // NOP
    // 0x2034ac: 0x0
    // NOP
    // 0x2034b0: 0x0
    // NOP
    // 0x2034b4: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_2034a0;
    }
label_2034bc:
    // 0x2034bc: 0x2630ae48
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294946376));
label_2034c0:
    // 0x2034c0: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x2034c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2034c8: 0x34a50593
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1427));
    // 0x2034cc: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x2034d4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_2034d4
// Address: 0x2034d4 - 0x2034f8

void entry_2034d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2034d4: 0x4430013
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        ctx->pc = 0x203524; return;
    }
    // 0x2034dc: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x2034e0: 0x8c439410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939664)));
    // 0x2034e4: 0x18600005
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x2034FC; return;
    }
    // 0x2034ec: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x2034f0: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x2034f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964864));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_2034f8
// Address: 0x2034f8 - 0x203548

void entry_2034f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2034f8) {
        switch (ctx->pc) {
            case 0x2034fc: ctx->pc = 0; goto label_2034fc;
            case 0x203500: ctx->pc = 0; goto label_203500;
            case 0x203524: ctx->pc = 0; goto label_203524;
            case 0x203530: ctx->pc = 0; goto label_203530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2034f8: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
label_2034fc:
    // 0x2034fc: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_203500:
    // 0x203500: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x203504: 0x0
    // NOP
    // 0x203508: 0x0
    // NOP
    // 0x20350c: 0x0
    // NOP
    // 0x203510: 0x0
    // NOP
    // 0x203514: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_203500;
    }
    // 0x20351c: 0x1000ffe8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294946376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2034C0; return;
    }
label_203524:
    // 0x203524: 0x1040ffdc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203498; return;
    }
    // 0x20352c: 0xae409448
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294939720), GPR_U32(ctx, 0));
label_203530:
    // 0x203530: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203534: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203538: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20353c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x203540: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdInit
// Address: 0x203548 - 0x203580

void entry_203580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203580: 0x1440009d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2037F8; return;
    }
    // 0x203588: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20358c: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x203594);
    SET_GPR_U32(ctx, 21, ((uint32_t)40 << 16));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_203594
// Address: 0x203594 - 0x20359c

void entry_203594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203594: 0xc07daa4
    SET_GPR_U32(ctx, 31, 0x20359c);
    SET_GPR_U32(ctx, 20, ((uint32_t)40 << 16));
    GetThreadId(rdram, ctx, runtime); return;
}


// Function: entry_20359c
// Address: 0x20359c - 0x203624

void entry_20359c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20359c) {
        switch (ctx->pc) {
            case 0x203610: ctx->pc = 0; goto label_203610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20359c: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x2035a0: 0x8ea59450
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 4294939728)));
    // 0x2035a4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2035a8: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x2035ac: 0x3c060063
    SET_GPR_U32(ctx, 6, ((uint32_t)99 << 16));
    // 0x2035b0: 0xac839424
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294939684), GPR_U32(ctx, 3));
    // 0x2035b4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x2035b8: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2035bc: 0x3c070028
    SET_GPR_U32(ctx, 7, ((uint32_t)40 << 16));
    // 0x2035c0: 0x3c080028
    SET_GPR_U32(ctx, 8, ((uint32_t)40 << 16));
    // 0x2035c4: 0x3c090028
    SET_GPR_U32(ctx, 9, ((uint32_t)40 << 16));
    // 0x2035c8: 0x3c0b0028
    SET_GPR_U32(ctx, 11, ((uint32_t)40 << 16));
    // 0x2035cc: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x2035d0: 0x3c0a0028
    SET_GPR_U32(ctx, 10, ((uint32_t)40 << 16));
    // 0x2035d4: 0xacc2a7d0
    WRITE32(ADD32(GPR_U32(ctx, 6), 4294944720), GPR_U32(ctx, 2));
    // 0x2035d8: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x2035dc: 0xac64943c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939708), GPR_U32(ctx, 4));
    // 0x2035e0: 0xace49440
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294939712), GPR_U32(ctx, 4));
    // 0x2035e4: 0x2451a9e8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294945256));
    // 0x2035e8: 0xad049438
    WRITE32(ADD32(GPR_U32(ctx, 8), 4294939704), GPR_U32(ctx, 4));
    // 0x2035ec: 0x2612aa40
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 4294945344));
    // 0x2035f0: 0xad249448
    WRITE32(ADD32(GPR_U32(ctx, 9), 4294939720), GPR_U32(ctx, 4));
    // 0x2035f4: 0x3c1e0028
    SET_GPR_U32(ctx, 30, ((uint32_t)40 << 16));
    // 0x2035f8: 0xad649444
    WRITE32(ADD32(GPR_U32(ctx, 11), 4294939716), GPR_U32(ctx, 4));
    // 0x2035fc: 0x3c170028
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
    // 0x203600: 0xad409434
    WRITE32(ADD32(GPR_U32(ctx, 10), 4294939700), GPR_U32(ctx, 0));
    // 0x203604: 0x3c160025
    SET_GPR_U32(ctx, 22, ((uint32_t)37 << 16));
    // 0x203608: 0xaea59450
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294939728), GPR_U32(ctx, 5));
    // 0x20360c: 0xae84944c
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294939724), GPR_U32(ctx, 4));
label_203610:
    // 0x203610: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x203614: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x203618: 0x34a50592
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1426));
    // 0x20361c: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x203624);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_203624
// Address: 0x203624 - 0x203644

void entry_203624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203624: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x203628: 0x4a30012
    if (GPR_S32(ctx, 5) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
        ctx->pc = 0x203674; return;
    }
    // 0x203630: 0x8ee29410
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 4294939664)));
    // 0x203634: 0x18400003
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4294939728)));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_203644(rdram, ctx, runtime); return;
    }
    // 0x20363c: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x203644);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 4294964888));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_203644
// Address: 0x203644 - 0x20368c

void entry_203644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203644) {
        switch (ctx->pc) {
            case 0x203650: ctx->pc = 0; goto label_203650;
            case 0x203674: ctx->pc = 0; goto label_203674;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203644: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x203648: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20364c: 0x0
    // NOP
label_203650:
    // 0x203650: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x203654: 0x0
    // NOP
    // 0x203658: 0x0
    // NOP
    // 0x20365c: 0x0
    // NOP
    // 0x203660: 0x0
    // NOP
    // 0x203664: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_203650;
    }
    // 0x20366c: 0x1000ffe8
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203610; return;
    }
label_203674:
    // 0x203674: 0x10400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2036CC; return;
    }
    // 0x20367c: 0xae13aa40
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294945344), GPR_U32(ctx, 19));
    // 0x203680: 0xae80944c
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294939724), GPR_U32(ctx, 0));
    // 0x203684: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x20368c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_20368c
// Address: 0x20368c - 0x2036b8

void entry_20368c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20368c: 0x27d0a600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 30), 4294944256));
    // 0x203690: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x203694: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x203698: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x20369c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2036a0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2036a4: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x2036a8: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2036ac: 0x240a0010
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 16));
    // 0x2036b0: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x2036b8);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_2036b8
// Address: 0x2036b8 - 0x2037b8

void entry_2036b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2036b8) {
        switch (ctx->pc) {
            case 0x2036cc: ctx->pc = 0; goto label_2036cc;
            case 0x2036d8: ctx->pc = 0; goto label_2036d8;
            case 0x2036fc: ctx->pc = 0; goto label_2036fc;
            case 0x203748: ctx->pc = 0; goto label_203748;
            case 0x203784: ctx->pc = 0; goto label_203784;
            case 0x203788: ctx->pc = 0; goto label_203788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2036b8: 0x4410010
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_2036fc;
    }
    // 0x2036c0: 0xac409424
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939684), GPR_U32(ctx, 0));
    // 0x2036c4: 0x1000004c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2037F8; return;
    }
label_2036cc:
    // 0x2036cc: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x2036d0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2036d4: 0x0
    // NOP
label_2036d8:
    // 0x2036d8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x2036dc: 0x0
    // NOP
    // 0x2036e0: 0x0
    // NOP
    // 0x2036e4: 0x0
    // NOP
    // 0x2036e8: 0x0
    // NOP
    // 0x2036ec: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_2036d8;
    }
    // 0x2036f4: 0x1000ffc6
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203610; return;
    }
label_2036fc:
    // 0x2036fc: 0x3c052000
    SET_GPR_U32(ctx, 5, ((uint32_t)8192 << 16));
    // 0x203700: 0x2602000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 12));
    // 0x203704: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x203708: 0x26030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4));
    // 0x20370c: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x203710: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x203714: 0x852025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x203718: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x20371c: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x203720: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x203724: 0x240200ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 255));
    // 0x203728: 0x10c20016
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_203784;
    }
    // 0x203730: 0x240200fe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 254));
    // 0x203734: 0x14c20004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_203748;
    }
    // 0x20373c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203740: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939664), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_203784;
    }
label_203748:
    // 0x203748: 0x24a200ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 255));
    // 0x20374c: 0xc5182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 5)));
    // 0x203750: 0xa3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 5));
    // 0x203754: 0x21203
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 8));
    // 0x203758: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x20375c: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
        goto label_203784;
    }
    // 0x203764: 0xc4182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 4)));
    // 0x203768: 0x248200ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 255));
    // 0x20376c: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x203770: 0x21203
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 8));
    // 0x203774: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x203778: 0x10400003
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_203788;
    }
    // 0x203780: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
label_203784:
    // 0x203784: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
label_203788:
    // 0x203788: 0xac809424
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294939684), GPR_U32(ctx, 0));
    // 0x20378c: 0x6600015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    if (GPR_S32(ctx, 19) < 0) {
        ctx->pc = 0x2037E4; return;
    }
    // 0x203794: 0x14400013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2037E4; return;
    }
    // 0x20379c: 0x16620011
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x2037E4; return;
    }
    // 0x2037a4: 0x8c439410
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294939664)));
    // 0x2037a8: 0x18600003
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 3) <= 0) {
        entry_2037b8(rdram, ctx, runtime); return;
    }
    // 0x2037b0: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x2037b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964920));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_2037b8
// Address: 0x2037b8 - 0x2037c0

void entry_2037b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2037b8: 0xc080be2
    SET_GPR_U32(ctx, 31, 0x2037c0);
    cdvd_exit(rdram, ctx, runtime); return;
}


// Function: entry_2037c0
// Address: 0x2037c0 - 0x2037ec

void entry_2037c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2037c0) {
        switch (ctx->pc) {
            case 0x2037e4: ctx->pc = 0; goto label_2037e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2037c0: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2037c4: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x2037c8: 0xac449428
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939688), GPR_U32(ctx, 4));
    // 0x2037cc: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x2037d0: 0xac64942c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294939692), GPR_U32(ctx, 4));
    // 0x2037d4: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x2037d8: 0xac449420
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294939680), GPR_U32(ctx, 4));
    // 0x2037dc: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2037F8; return;
    }
label_2037e4:
    // 0x2037e4: 0xc080bbc
    SET_GPR_U32(ctx, 31, 0x2037ec);
    cmd_sem_init(rdram, ctx, runtime); return;
}


// Function: entry_2037ec
// Address: 0x2037ec - 0x2037f4

void entry_2037ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2037ec: 0xc080c14
    SET_GPR_U32(ctx, 31, 0x2037f4);
    PowerOffCB(rdram, ctx, runtime); return;
}


// Function: entry_2037f4
// Address: 0x2037f4 - 0x203828

void entry_2037f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2037f4) {
        switch (ctx->pc) {
            case 0x2037f8: ctx->pc = 0; goto label_2037f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2037f4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2037f8:
    // 0x2037f8: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x2037fc: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x203800: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x203804: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x203808: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20380c: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x203810: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x203814: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203818: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20381c: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdDiskReady
// Address: 0x203828 - 0x20386c
// STUBBED: Returns SCECdComplete (2) immediately to bypass CD initialization

void entry_20386c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20386c: 0xc080bbc
    SET_GPR_U32(ctx, 31, 0x203874);
    SET_GPR_U32(ctx, 19, ((uint32_t)40 << 16));
    cmd_sem_init(rdram, ctx, runtime); return;
}


// Function: entry_203874
// Address: 0x203874 - 0x203880

void entry_203874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203874: 0x8e64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4294939692)));
    // 0x203878: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x203880);
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_203880
// Address: 0x203880 - 0x203894

void entry_203880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203880: 0x8e63942c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294939692)));
    // 0x203884: 0x1462005b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x2039F4; return;
    }
    // 0x20388c: 0xc080cda
    SET_GPR_U32(ctx, 31, 0x203894);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    sceCdSyncS(rdram, ctx, runtime); return;
}


// Function: entry_203894
// Address: 0x203894 - 0x2038a4

void entry_203894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203894: 0x14400045
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2039AC; return;
    }
    // 0x20389c: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x2038a4);
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_2038a4
// Address: 0x2038a4 - 0x2038fc

void entry_2038a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2038a4) {
        switch (ctx->pc) {
            case 0x2038c0: ctx->pc = 0; goto label_2038c0;
            case 0x2038c8: ctx->pc = 0; goto label_2038c8;
            case 0x2038e4: ctx->pc = 0; goto label_2038e4;
            case 0x2038e8: ctx->pc = 0; goto label_2038e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2038a4: 0x8e229444
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294939716)));
    // 0x2038a8: 0x441002c
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x20395C; return;
    }
    // 0x2038b0: 0x3c140063
    SET_GPR_U32(ctx, 20, ((uint32_t)99 << 16));
    // 0x2038b4: 0x1000000b
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2038e4;
    }
    // 0x2038bc: 0x0
    // NOP
label_2038c0:
    // 0x2038c0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2038c4: 0x0
    // NOP
label_2038c8:
    // 0x2038c8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x2038cc: 0x0
    // NOP
    // 0x2038d0: 0x0
    // NOP
    // 0x2038d4: 0x0
    // NOP
    // 0x2038d8: 0x0
    // NOP
    // 0x2038dc: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_2038c8;
    }
label_2038e4:
    // 0x2038e4: 0x26b0aa10
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294945296));
label_2038e8:
    // 0x2038e8: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x2038ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2038f0: 0x34a5059a
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1434));
    // 0x2038f4: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x2038fc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_2038fc
// Address: 0x2038fc - 0x20391c

void entry_2038fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2038fc: 0x4430013
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
        ctx->pc = 0x20394C; return;
    }
    // 0x203904: 0x8ec29410
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4294939664)));
    // 0x203908: 0x18400005
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x203920; return;
    }
    // 0x203910: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x203914: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x20391c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964952));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_20391c
// Address: 0x20391c - 0x203978

void entry_20391c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20391c) {
        switch (ctx->pc) {
            case 0x203920: ctx->pc = 0; goto label_203920;
            case 0x203928: ctx->pc = 0; goto label_203928;
            case 0x20394c: ctx->pc = 0; goto label_20394c;
            case 0x20395c: ctx->pc = 0; goto label_20395c;
            case 0x203964: ctx->pc = 0; goto label_203964;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20391c: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
label_203920:
    // 0x203920: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x203924: 0x0
    // NOP
label_203928:
    // 0x203928: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20392c: 0x0
    // NOP
    // 0x203930: 0x0
    // NOP
    // 0x203934: 0x0
    // NOP
    // 0x203938: 0x0
    // NOP
    // 0x20393c: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_203928;
    }
    // 0x203944: 0x1000ffe8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294945296));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2038E8; return;
    }
label_20394c:
    // 0x20394c: 0x1040ffdc
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2038C0; return;
    }
    // 0x203954: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294939716), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_203964;
    }
label_20395c:
    // 0x20395c: 0x3c140063
    SET_GPR_U32(ctx, 20, ((uint32_t)99 << 16));
    // 0x203960: 0x3c170028
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
label_203964:
    // 0x203964: 0x2690aa50
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 4294945360));
    // 0x203968: 0xae92aa50
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294945360), GPR_U32(ctx, 18));
    // 0x20396c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203970: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203978);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203978
// Address: 0x203978 - 0x2039a4

void entry_203978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203978: 0x26f1a600
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 23), 4294944256));
    // 0x20397c: 0x26a4aa10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4294945296));
    // 0x203980: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203984: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203988: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20398c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203990: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203994: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x203998: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x20399c: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x2039a4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_2039a4
// Address: 0x2039a4 - 0x2039b8

void entry_2039a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2039a4) {
        switch (ctx->pc) {
            case 0x2039ac: ctx->pc = 0; goto label_2039ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2039a4: 0x4430009
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4294939664)));
        ctx->pc = 0x2039CC; return;
    }
label_2039ac:
    // 0x2039ac: 0x8e64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4294939692)));
    // 0x2039b0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2039b8);
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2039b8
// Address: 0x2039b8 - 0x2039dc

void entry_2039b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2039b8) {
        switch (ctx->pc) {
            case 0x2039cc: ctx->pc = 0; goto label_2039cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2039b8: 0x3a440008
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 18), 8));
    // 0x2039bc: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2039c0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x2039c4: 0x1000000b
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2039F4; return;
    }
label_2039cc:
    // 0x2039cc: 0x18400003
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_2039dc(rdram, ctx, runtime); return;
    }
    // 0x2039d4: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x2039dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294964984));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_2039dc
// Address: 0x2039dc - 0x2039f0

void entry_2039dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2039dc: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x2039e0: 0x8e64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4294939692)));
    // 0x2039e4: 0x2221025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x2039e8: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2039f0);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2039f0
// Address: 0x2039f0 - 0x203a20

void entry_2039f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2039f0) {
        switch (ctx->pc) {
            case 0x2039f4: ctx->pc = 0; goto label_2039f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2039f0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2039f4:
    // 0x2039f4: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x2039f8: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x2039fc: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x203a00: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x203a04: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x203a08: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x203a0c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203a10: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203a14: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203a18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdMmode
// Address: 0x203a20 - 0x203a48

void entry_203a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203a48) {
        switch (ctx->pc) {
            case 0x203a58: ctx->pc = 0; goto label_203a58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203a48: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 4294945344), GPR_U32(ctx, 16));
        goto label_203a58;
    }
    // 0x203a50: 0x1000001e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203ACC; return;
    }
label_203a58:
    // 0x203a58: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x203a5c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203a64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203a64
// Address: 0x203a64 - 0x203a98

void entry_203a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203a64: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203a68: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203a6c: 0x2450a600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294944256));
    // 0x203a70: 0x2484ae48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    // 0x203a74: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x203a78: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203a7c: 0x24050022
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    // 0x203a80: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203a84: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203a88: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203a8c: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203a90: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203a98);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203a98
// Address: 0x203a98 - 0x203aac

void entry_203a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203a98: 0x4410006
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203AB4; return;
    }
    // 0x203aa0: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203aa4: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203aac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939692)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203aac
// Address: 0x203aac - 0x203ac8

void entry_203aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203aac) {
        switch (ctx->pc) {
            case 0x203ab4: ctx->pc = 0; goto label_203ab4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203aac: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203ACC; return;
    }
label_203ab4:
    // 0x203ab4: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x203ab8: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x203abc: 0x8c64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    // 0x203ac0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203ac8);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203ac8
// Address: 0x203ac8 - 0x203ae8

void entry_203ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203ac8) {
        switch (ctx->pc) {
            case 0x203acc: ctx->pc = 0; goto label_203acc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203ac8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_203acc:
    // 0x203acc: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x203ad0: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203ad4: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203ad8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203adc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x203ae4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x203ae8; return;
}


// Function: sceCdGetReadPos
// Address: 0x203ae8 - 0x203b18

void entry_203b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203b68) {
        switch (ctx->pc) {
            case 0x203b74: ctx->pc = 0; goto label_203b74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203b68: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x203b6c: 0x10430059
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x203CD4; return;
    }
label_203b74:
    // 0x203b74: 0xc080c30
    SET_GPR_U32(ctx, 31, 0x203b7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    _sceCd_ncmd_prechk(rdram, ctx, runtime); return;
}


// Function: entry_203b7c
// Address: 0x203b7c - 0x203c14

void entry_203b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203b7c) {
        switch (ctx->pc) {
            case 0x203be8: ctx->pc = 0; goto label_203be8;
            case 0x203bf4: ctx->pc = 0; goto label_203bf4;
            case 0x203bf8: ctx->pc = 0; goto label_203bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203b7c: 0x1040004d
    SET_GPR_U32(ctx, 8, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_203cb4(rdram, ctx, runtime); return;
    }
    // 0x203b84: 0xae530000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 19));
    // 0x203b88: 0xae510004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 17));
    // 0x203b8c: 0x3c130028
    SET_GPR_U32(ctx, 19, ((uint32_t)40 << 16));
    // 0x203b90: 0xae540008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 20));
    // 0x203b94: 0x2664a500
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294944000));
    // 0x203b98: 0x2505a5c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 8), 4294944192));
    // 0x203b9c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x203ba0: 0x92020000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x203ba4: 0xa242000c
    WRITE8(ADD32(GPR_U32(ctx, 18), 12), (uint8_t)GPR_U32(ctx, 2));
    // 0x203ba8: 0x92030001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 1)));
    // 0x203bac: 0xa243000d
    WRITE8(ADD32(GPR_U32(ctx, 18), 13), (uint8_t)GPR_U32(ctx, 3));
    // 0x203bb0: 0x92020002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x203bb4: 0xae440010
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 4));
    // 0x203bb8: 0xa242000e
    WRITE8(ADD32(GPR_U32(ctx, 18), 14), (uint8_t)GPR_U32(ctx, 2));
    // 0x203bbc: 0xae450014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 5));
    // 0x203bc0: 0x92070002
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x203bc4: 0x10e60008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 2));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 6)) {
        goto label_203be8;
    }
    // 0x203bcc: 0x1440000a
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 11));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203bf8;
    }
    // 0x203bd4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x203bd8: 0x10e20006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2340));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 2)) {
        goto label_203bf4;
    }
    // 0x203be0: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_203bf8;
    }
label_203be8:
    // 0x203be8: 0x24020918
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2328));
    // 0x203bec: 0x10000002
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_203bf8;
    }
label_203bf4:
    // 0x203bf4: 0x2222818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_203bf8:
    // 0x203bf8: 0x8ea29434
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4294939700)));
    // 0x203bfc: 0x2510a5c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 8), 4294944192));
    // 0x203c00: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x203c04: 0x14400003
    WRITE32(ADD32(GPR_U32(ctx, 8), 4294944192), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_203c14(rdram, ctx, runtime); return;
    }
    // 0x203c0c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203c14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203c14
// Address: 0x203c14 - 0x203c28

void entry_203c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c14: 0x2673a500
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294944000));
    // 0x203c18: 0x24050090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 144));
    // 0x203c1c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x203c20: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203c28);
    SET_GPR_U32(ctx, 20, ((uint32_t)40 << 16));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203c28
// Address: 0x203c28 - 0x203c34

void entry_203c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c28: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x203c2c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203c34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203c34
// Address: 0x203c34 - 0x203c40

void entry_203c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203c38: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203c40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203c40
// Address: 0x203c40 - 0x203c54

void entry_203c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c40: 0x8e829410
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294939664)));
    // 0x203c44: 0x18400003
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_203c54(rdram, ctx, runtime); return;
    }
    // 0x203c4c: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x203c54);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965008));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_203c54
// Address: 0x203c54 - 0x203c98

void entry_203c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c54: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x203c58: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x203c5c: 0xae029454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 2));
    // 0x203c60: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x203c64: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203c68: 0x3c0b0020
    SET_GPR_U32(ctx, 11, ((uint32_t)32 << 16));
    // 0x203c6c: 0xae229430
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294939696), GPR_U32(ctx, 2));
    // 0x203c70: 0x2484a5d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294944208));
    // 0x203c74: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x203c78: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x203c7c: 0x256b2e50
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 11856));
    // 0x203c80: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x203c84: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x203c88: 0x24080018
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 24));
    // 0x203c8c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203c90: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203c98);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203c98
// Address: 0x203c98 - 0x203cb4

void entry_203c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203c98: 0x4430008
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294939664)));
        ctx->pc = 0x203CBC; return;
    }
    // 0x203ca0: 0xae009454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 0));
    // 0x203ca4: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203ca8: 0xae209430
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294939696), GPR_U32(ctx, 0));
    // 0x203cac: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203cb4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939688)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203cb4
// Address: 0x203cb4 - 0x203cd0

void entry_203cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203cb4) {
        switch (ctx->pc) {
            case 0x203cbc: ctx->pc = 0; goto label_203cbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203cb4: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203CD4; return;
    }
label_203cbc:
    // 0x203cbc: 0x18400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x203CD4; return;
    }
    // 0x203cc4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x203cc8: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x203cd0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965032));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_203cd0
// Address: 0x203cd0 - 0x203cf8

void entry_203cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203cd0) {
        switch (ctx->pc) {
            case 0x203cd4: ctx->pc = 0; goto label_203cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203cd0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_203cd4:
    // 0x203cd4: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x203cd8: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x203cdc: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x203ce0: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x203ce4: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203ce8: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203cec: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203cf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdGetDiskType
// Address: 0x203cf8 - 0x203d0c

void entry_203d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203d0c) {
        switch (ctx->pc) {
            case 0x203d1c: ctx->pc = 0; goto label_203d1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203d0c: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203d1c;
    }
    // 0x203d14: 0x1000001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203D80; return;
    }
label_203d1c:
    // 0x203d1c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203d20: 0x2450a600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294944256));
    // 0x203d24: 0x2484ae48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    // 0x203d28: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203d2c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x203d30: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203d34: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203d38: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203d3c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203d40: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203d44: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203d4c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203d4c
// Address: 0x203d4c - 0x203d60

void entry_203d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203d4c: 0x4410006
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203D68; return;
    }
    // 0x203d54: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203d58: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203d60);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939692)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203d60
// Address: 0x203d60 - 0x203d7c

void entry_203d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203d60) {
        switch (ctx->pc) {
            case 0x203d68: ctx->pc = 0; goto label_203d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203d60: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203D80; return;
    }
label_203d68:
    // 0x203d68: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x203d6c: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x203d70: 0x8c64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    // 0x203d74: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203d7c);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203d7c
// Address: 0x203d7c - 0x203d90

void entry_203d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203d7c) {
        switch (ctx->pc) {
            case 0x203d80: ctx->pc = 0; goto label_203d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203d7c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_203d80:
    // 0x203d80: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203d84: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203d88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdGetError
// Address: 0x203d90 - 0x203da4

void entry_203da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203da4) {
        switch (ctx->pc) {
            case 0x203db4: ctx->pc = 0; goto label_203db4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203da4: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203db4;
    }
    // 0x203dac: 0x1000001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203E18; return;
    }
label_203db4:
    // 0x203db4: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203db8: 0x2450a600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294944256));
    // 0x203dbc: 0x2484ae48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    // 0x203dc0: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203dc4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203dc8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203dcc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203dd0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203dd4: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203dd8: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203ddc: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203de4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203de4
// Address: 0x203de4 - 0x203df8

void entry_203de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203de4: 0x4410006
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203E00; return;
    }
    // 0x203dec: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203df0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203df8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939692)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203df8
// Address: 0x203df8 - 0x203e14

void entry_203df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203df8) {
        switch (ctx->pc) {
            case 0x203e00: ctx->pc = 0; goto label_203e00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203df8: 0x10000007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203E18; return;
    }
label_203e00:
    // 0x203e00: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x203e04: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x203e08: 0x8c64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    // 0x203e0c: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203e14);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203e14
// Address: 0x203e14 - 0x203e28

void entry_203e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203e14) {
        switch (ctx->pc) {
            case 0x203e18: ctx->pc = 0; goto label_203e18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203e14: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_203e18:
    // 0x203e18: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203e1c: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203e20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceCdBreak
// Address: 0x203e28 - 0x203e40

void entry_203e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203e40) {
        switch (ctx->pc) {
            case 0x203e50: ctx->pc = 0; goto label_203e50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203e40: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_203e50;
    }
    // 0x203e48: 0x10000020
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203ECC; return;
    }
label_203e50:
    // 0x203e50: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x203e54: 0x2451a600
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294944256));
    // 0x203e58: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x203e5c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203e60: 0xae039454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 3));
    // 0x203e64: 0x2484ae48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    // 0x203e68: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203e6c: 0x24050016
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    // 0x203e70: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203e74: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203e78: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203e7c: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x203e80: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203e84: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203e8c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203e8c
// Address: 0x203e8c - 0x203ea0

void entry_203e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203e8c: 0x4410007
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203EAC; return;
    }
    // 0x203e94: 0x8c44942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939692)));
    // 0x203e98: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203ea0);
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203ea0
// Address: 0x203ea0 - 0x203ec8

void entry_203ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203ea0) {
        switch (ctx->pc) {
            case 0x203eac: ctx->pc = 0; goto label_203eac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203ea0: 0xae009454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 0));
    // 0x203ea4: 0x10000009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203ECC; return;
    }
label_203eac:
    // 0x203eac: 0xae009454
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294939732), GPR_U32(ctx, 0));
    // 0x203eb0: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x203eb4: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x203eb8: 0x2221025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x203ebc: 0x8c64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    // 0x203ec0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203ec8);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203ec8
// Address: 0x203ec8 - 0x203ee0

void entry_203ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203ec8) {
        switch (ctx->pc) {
            case 0x203ecc: ctx->pc = 0; goto label_203ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203ec8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_203ecc:
    // 0x203ecc: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203ed0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203ed4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203ed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00203ee0
// Address: 0x203ee0 - 0x203f10

void FUN_00203ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203ee0: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x203ee4: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x203ee8: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x203eec: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x203ef0: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x203ef4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x203ef8: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x203efc: 0x2633aa40
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 4294945344));
    // 0x203f00: 0xffbf0050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 31));
    // 0x203f04: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x203f08: 0xc080cf6
    SET_GPR_U32(ctx, 31, 0x203f10);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 26));
    _sceCd_scmd_prechk(rdram, ctx, runtime); return;
}


// Function: entry_203f10
// Address: 0x203f10 - 0x203f2c

void entry_203f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203f10) {
        switch (ctx->pc) {
            case 0x203f20: ctx->pc = 0; goto label_203f20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203f10: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 4294945344), GPR_U32(ctx, 16));
        goto label_203f20;
    }
    // 0x203f18: 0x10000025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203FB0; return;
    }
label_203f20:
    // 0x203f20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x203f24: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x203f2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_203f2c
// Address: 0x203f2c - 0x203f60

void entry_203f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203f2c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x203f30: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x203f34: 0x2450a600
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294944256));
    // 0x203f38: 0x2484ae48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294946376));
    // 0x203f3c: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x203f40: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x203f44: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x203f48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x203f4c: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x203f50: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x203f54: 0x240a0008
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 8));
    // 0x203f58: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x203f60);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_203f60
// Address: 0x203f60 - 0x203f74

void entry_203f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x203f60: 0x4410006
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x203F7C; return;
    }
    // 0x203f68: 0x8c44942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294939692)));
    // 0x203f6c: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203f74);
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203f74
// Address: 0x203f74 - 0x203fac

void entry_203f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203f74) {
        switch (ctx->pc) {
            case 0x203f7c: ctx->pc = 0; goto label_203f7c;
            case 0x203f94: ctx->pc = 0; goto label_203f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203f74: 0x1000000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x203FB0; return;
    }
label_203f7c:
    // 0x203f7c: 0x12400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_203f94;
    }
    // 0x203f84: 0x3c032000
    SET_GPR_U32(ctx, 3, ((uint32_t)8192 << 16));
    // 0x203f88: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x203f8c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x203f90: 0xae440000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 4));
label_203f94:
    // 0x203f94: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x203f98: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x203f9c: 0x2021025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x203fa0: 0x8c64942c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294939692)));
    // 0x203fa4: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x203fac);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_203fac
// Address: 0x203fac - 0x203fd0

void entry_203fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x203fac) {
        switch (ctx->pc) {
            case 0x203fb0: ctx->pc = 0; goto label_203fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x203fac: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_203fb0:
    // 0x203fb0: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x203fb4: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x203fb8: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x203fbc: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x203fc0: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x203fc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x203fcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x203fd0; return;
}


// Function: fn___send_to_iop
// Address: 0x203fd0 - 0x204028

void entry_204028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204028) {
        switch (ctx->pc) {
            case 0x204030: ctx->pc = 0; goto label_204030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204028: 0x441001e
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x2040A4; return;
    }
label_204030:
    // 0x204030: 0x2407001c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 28));
    // 0x204034: 0x24030070
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 112));
    // 0x204038: 0x2073818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20403c: 0x72431818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 3); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x204040: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x204044: 0x2673aad0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294945488));
    // 0x204048: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20404c: 0x26250020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 32));
    // 0x204050: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x204054: 0xe39021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x204058: 0x30c20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), 1));
    // 0x20405c: 0x2721821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 18)));
    // 0x204060: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x204064: 0x8c700008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x204068: 0xae260000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 6));
    // 0x20406c: 0xc0813b2
    SET_GPR_U32(ctx, 31, 0x204074);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    SyncDCache(rdram, ctx, runtime); return;
}


// Function: entry_204074
// Address: 0x204074 - 0x204094

void entry_204074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x204074: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x204078: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x20407c: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x204080: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x204084: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x204088: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20408c: 0xc07db28
    SET_GPR_U32(ctx, 31, 0x204094);
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 0));
    sceSifSetDma(rdram, ctx, runtime); return;
}


// Function: entry_204094
// Address: 0x204094 - 0x2040b8

void entry_204094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204094) {
        switch (ctx->pc) {
            case 0x2040a4: ctx->pc = 0; goto label_2040a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204094: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204098: 0x14800009
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 18)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2040C0; return;
    }
    // 0x2040a0: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
label_2040a4:
    // 0x2040a4: 0x8c43ae84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294946436)));
    // 0x2040a8: 0x10600003
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_2040b8(rdram, ctx, runtime); return;
    }
    // 0x2040b0: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x2040b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965048));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_2040b8
// Address: 0x2040b8 - 0x2040e8

void entry_2040b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2040b8) {
        switch (ctx->pc) {
            case 0x2040c0: ctx->pc = 0; goto label_2040c0;
            case 0x2040c8: ctx->pc = 0; goto label_2040c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2040b8: 0x10000003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2040c8;
    }
label_2040c0:
    // 0x2040c0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2040c4: 0xac64000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 4));
label_2040c8:
    // 0x2040c8: 0xdfbf0140
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x2040cc: 0xdfb30130
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x2040d0: 0xdfb20120
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x2040d4: 0xdfb10110
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x2040d8: 0xdfb00100
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x2040dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2040e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2040e8; return;
}


// Function: scePadInit
// Address: 0x2040e8 - 0x204154

void entry_204154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204154) {
        switch (ctx->pc) {
            case 0x204170: ctx->pc = 0; goto label_204170;
            case 0x204178: ctx->pc = 0; goto label_204178;
            case 0x204194: ctx->pc = 0; goto label_204194;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204154: 0x8e030024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x204158: 0x1060ffef
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x204118; return;
    }
    // 0x204160: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x204164: 0x1000000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 40));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204194;
    }
    // 0x20416c: 0x0
    // NOP
label_204170:
    // 0x204170: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x204174: 0x0
    // NOP
label_204178:
    // 0x204178: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20417c: 0x0
    // NOP
    // 0x204180: 0x0
    // NOP
    // 0x204184: 0x0
    // NOP
    // 0x204188: 0x0
    // NOP
    // 0x20418c: 0x1443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_204178;
    }
label_204194:
    // 0x204194: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x204198: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20419c: 0x34a50101
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 257));
    // 0x2041a0: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x2041a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_2041a8
// Address: 0x2041a8 - 0x2041bc

void entry_2041a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2041a8: 0x8e23004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x2041ac: 0x1060fff0
    SET_GPR_U32(ctx, 2, ((uint32_t)1 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x204170; return;
    }
    // 0x2041b4: 0xc08136e
    SET_GPR_U32(ctx, 31, 0x2041bc);
    scePadGetModVersion(rdram, ctx, runtime); return;
}


// Function: entry_2041bc
// Address: 0x2041bc - 0x2041e4

void entry_2041bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2041bc: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2041c0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x2041c4: 0x118203
    SET_GPR_S32(ctx, 16, SRA32(GPR_S32(ctx, 17), 8));
    // 0x2041c8: 0x1202000f
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x204208; return;
    }
    // 0x2041d0: 0x8c43ae84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294946436)));
    // 0x2041d4: 0x1060000a
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_204200(rdram, ctx, runtime); return;
    }
    // 0x2041dc: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x2041e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965120));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_2041e4
// Address: 0x2041e4 - 0x204200

void entry_2041e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2041e4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x2041e8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2041ec: 0x2484f7a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965160));
    // 0x2041f0: 0x322800ff
    SET_GPR_U32(ctx, 8, AND32(GPR_U32(ctx, 17), 255));
    // 0x2041f4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x2041f8: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x204200);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_204200
// Address: 0x204200 - 0x204210

void entry_204200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204200) {
        switch (ctx->pc) {
            case 0x204208: ctx->pc = 0; goto label_204208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204200: 0x10000003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_204210(rdram, ctx, runtime); return;
    }
label_204208:
    // 0x204208: 0xc08108a
    SET_GPR_U32(ctx, 31, 0x204210);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    scePadInit2(rdram, ctx, runtime); return;
}


// Function: entry_204210
// Address: 0x204210 - 0x204228

void entry_204210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x204210: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x204214: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204218: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20421c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204220: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadInit2
// Address: 0x204228 - 0x2042a8

void entry_2042a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2042a8) {
        switch (ctx->pc) {
            case 0x2042b4: ctx->pc = 0; goto label_2042b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2042a8: 0x4430002
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_2042b4;
    }
    // 0x2042b0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_2042b4:
    // 0x2042b4: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2042b8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2042bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2042c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2042c8; return;
}


// Function: scePadPortOpen
// Address: 0x2042c8 - 0x204324

void entry_204324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204324) {
        switch (ctx->pc) {
            case 0x20432c: ctx->pc = 0; goto label_20432c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204324: 0x10000055
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20447C; return;
    }
label_20432c:
    // 0x20432c: 0x2404001c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 28));
    // 0x204330: 0x24030070
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 112));
    // 0x204334: 0x72631818
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 3); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x204338: 0x2442018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20433c: 0x3c1e0063
    SET_GPR_U32(ctx, 30, ((uint32_t)99 << 16));
    // 0x204340: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204344: 0x27c2aad0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 4294945488));
    // 0x204348: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x20434c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x204350: 0x8c430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x204354: 0x1465000b
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x204384; return;
    }
    // 0x20435c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x204360: 0x8c43ae84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294946436)));
    // 0x204364: 0x1060002b
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x204414; return;
    }
    // 0x20436c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x204370: 0x2484f800
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965248));
    // 0x204374: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x20437c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_20437c
// Address: 0x20437c - 0x2043bc

void entry_20437c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20437c) {
        switch (ctx->pc) {
            case 0x204384: ctx->pc = 0; goto label_204384;
            case 0x204398: ctx->pc = 0; goto label_204398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20437c: 0x1000003f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20447C; return;
    }
label_204384:
    // 0x204384: 0x3c170063
    SET_GPR_U32(ctx, 23, ((uint32_t)99 << 16));
    // 0x204388: 0x24160005
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 5));
    // 0x20438c: 0x24150002
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 2));
    // 0x204390: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204394: 0x0
    // NOP
label_204398:
    // 0x204398: 0xae000058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 0));
    // 0x20439c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2043a0: 0xa2160070
    WRITE8(ADD32(GPR_U32(ctx, 16), 112), (uint8_t)GPR_U32(ctx, 22));
    // 0x2043a4: 0x240500ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 255));
    // 0x2043a8: 0xa2150071
    WRITE8(ADD32(GPR_U32(ctx, 16), 113), (uint8_t)GPR_U32(ctx, 21));
    // 0x2043ac: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x2043b0: 0xa2000067
    WRITE8(ADD32(GPR_U32(ctx, 16), 103), (uint8_t)GPR_U32(ctx, 0));
    // 0x2043b4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x2043bc);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_2043bc
// Address: 0x2043bc - 0x20440c

void entry_2043bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2043bc: 0xae000060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 0));
    // 0x2043c0: 0x621fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 128));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x204398; return;
    }
    // 0x2043c8: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2043cc: 0x26f0acc0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 23), 4294945984));
    // 0x2043d0: 0xaef1acc0
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294945984), GPR_U32(ctx, 17));
    // 0x2043d4: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x2043d8: 0xae130004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 19));
    // 0x2043dc: 0x2484aa80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294945408));
    // 0x2043e0: 0xae120008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 18));
    // 0x2043e4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2043e8: 0xae140010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 20));
    // 0x2043ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2043f0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2043f4: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x2043f8: 0x24080080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 128));
    // 0x2043fc: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x204400: 0x240a0080
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 128));
    // 0x204404: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x20440c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_20440c
// Address: 0x20440c - 0x2044b0

void entry_20440c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20440c) {
        switch (ctx->pc) {
            case 0x204414: ctx->pc = 0; goto label_204414;
            case 0x20441c: ctx->pc = 0; goto label_20441c;
            case 0x20447c: ctx->pc = 0; goto label_20447c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20440c: 0x4410003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_20441c;
    }
label_204414:
    // 0x204414: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20447c;
    }
label_20441c:
    // 0x20441c: 0x24070070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 112));
    // 0x204420: 0x72673818
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 7); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x204424: 0x2431818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x204428: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x20442c: 0x122940
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 18), 5));
    // 0x204430: 0x2442abc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945728));
    // 0x204434: 0x27c4aad0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294945488));
    // 0x204438: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x20443c: 0x1331c0
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 19), 7));
    // 0x204440: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x204444: 0xc53021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x204448: 0x831021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x20444c: 0x8e080014
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x204450: 0xac510010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 17));
    // 0x204454: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204458: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20445c: 0xacc00000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 0));
    // 0x204460: 0x641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x204464: 0xaca0000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 0));
    // 0x204468: 0xace80008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 8));
    // 0x20446c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x204470: 0xac540000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 20));
    // 0x204474: 0xac860004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 6));
    // 0x204478: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_20447c:
    // 0x20447c: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x204480: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x204484: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x204488: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20448c: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x204490: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x204494: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x204498: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20449c: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2044a0: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2044a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2044ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2044b0; return;
}


// Function: scePadGetDmaStr
// Address: 0x2044b0 - 0x2044ec

void entry_2044ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2044ec: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x2044f0: 0x8e0300d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 216)));
    // 0x2044f4: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2044f8: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x2044fc: 0x211c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 7));
    // 0x204500: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x204504: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadRead
// Address: 0x204510 - 0x204560

void entry_204560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x204560: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204564: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x204568: 0x8e060060
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x20456c: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x204574);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_204574
// Address: 0x204574 - 0x204590

void entry_204574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204574) {
        switch (ctx->pc) {
            case 0x204578: ctx->pc = 0; goto label_204578;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204574: 0x8e020060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 96)));
label_204578:
    // 0x204578: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20457c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204580: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204584: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20458c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204590; return;
}


// Function: scePadGetState
// Address: 0x204590 - 0x2045d0

void entry_2045d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2045d0) {
        switch (ctx->pc) {
            case 0x2045fc: ctx->pc = 0; goto label_2045fc;
            case 0x204600: ctx->pc = 0; goto label_204600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2045d0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2045d4: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x2045d8: 0x90820070
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 112)));
    // 0x2045dc: 0x14430008
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_204600;
    }
    // 0x2045e4: 0x90830071
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 113)));
    // 0x2045e8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x2045ec: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 112)));
        goto label_204600;
    }
    // 0x2045f4: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204600;
    }
label_2045fc:
    // 0x2045fc: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_204600:
    // 0x204600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204608: 0xa0a30000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x20460c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204610; return;
}


// Function: scePadSetReqState
// Address: 0x204610 - 0x20465c

void entry_20465c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20465c) {
        switch (ctx->pc) {
            case 0x204664: ctx->pc = 0; goto label_204664;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20465c: 0xa0500071
    WRITE8(ADD32(GPR_U32(ctx, 2), 113), (uint8_t)GPR_U32(ctx, 16));
    // 0x204660: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_204664:
    // 0x204664: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204668: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20466c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204678; return;
}


// Function: scePadGetState_2
// Address: 0x204678 - 0x2046b8

void entry_2046b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2046b8) {
        switch (ctx->pc) {
            case 0x2046bc: ctx->pc = 0; goto label_2046bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2046b8: 0x90420071
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 113)));
label_2046bc:
    // 0x2046bc: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2046c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2046c8: 0xa0a30000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x2046cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2046d0; return;
}


// Function: scePadInfoAct
// Address: 0x2046d0 - 0x20471c

void entry_20471c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20471c) {
        switch (ctx->pc) {
            case 0x204760: ctx->pc = 0; goto label_204760;
            case 0x204780: ctx->pc = 0; goto label_204780;
            case 0x204798: ctx->pc = 0; goto label_204798;
            case 0x2047a8: ctx->pc = 0; goto label_2047a8;
            case 0x2047b8: ctx->pc = 0; goto label_2047b8;
            case 0x2047c8: ctx->pc = 0; goto label_2047c8;
            case 0x2047d8: ctx->pc = 0; goto label_2047d8;
            case 0x2047dc: ctx->pc = 0; goto label_2047dc;
            case 0x2047e0: ctx->pc = 0; goto label_2047e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20471c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204720: 0x90850072
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 114)));
    // 0x204724: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204728: 0x14a2002c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_2047dc;
    }
    // 0x204730: 0x90820064
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x204734: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x204738: 0x14400028
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
    // 0x204740: 0x9083006a
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 106)));
    // 0x204744: 0x223102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 3)));
    // 0x204748: 0x10400023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2047d8;
    }
    // 0x204750: 0x16220003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_204760;
    }
    // 0x204758: 0x10000020
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
label_204760:
    // 0x204760: 0x12020011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2047a8;
    }
    // 0x204768: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_204780;
    }
    // 0x204770: 0x12050009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 5)) {
        goto label_204798;
    }
    // 0x204778: 0x10000019
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047e0;
    }
label_204780:
    // 0x204780: 0x1202000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2047b8;
    }
    // 0x204788: 0x1202000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2047c8;
    }
    // 0x204790: 0x10000013
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047e0;
    }
label_204798:
    // 0x204798: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x20479c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x2047a0: 0x1000000e
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
label_2047a8:
    // 0x2047a8: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x2047ac: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x2047b0: 0x1000000a
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 49)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
label_2047b8:
    // 0x2047b8: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x2047bc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x2047c0: 0x10000006
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 50)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
label_2047c8:
    // 0x2047c8: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x2047cc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x2047d0: 0x10000002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 51)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2047dc;
    }
label_2047d8:
    // 0x2047d8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_2047dc:
    // 0x2047dc: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_2047e0:
    // 0x2047e0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2047e4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2047e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2047f0: 0x27bd0030
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    // 0x2047f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2047f8; return;
}


// Function: scePadInfoMode
// Address: 0x2047f8 - 0x204844

void entry_204844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204844) {
        switch (ctx->pc) {
            case 0x204888: ctx->pc = 0; goto label_204888;
            case 0x2048a0: ctx->pc = 0; goto label_2048a0;
            case 0x2048b8: ctx->pc = 0; goto label_2048b8;
            case 0x2048d0: ctx->pc = 0; goto label_2048d0;
            case 0x2048e4: ctx->pc = 0; goto label_2048e4;
            case 0x204900: ctx->pc = 0; goto label_204900;
            case 0x20490c: ctx->pc = 0; goto label_20490c;
            case 0x204918: ctx->pc = 0; goto label_204918;
            case 0x20491c: ctx->pc = 0; goto label_20491c;
            case 0x204920: ctx->pc = 0; goto label_204920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204844: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204848: 0x90830072
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 114)));
    // 0x20484c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204850: 0x14620032
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_20491c;
    }
    // 0x204858: 0x90820071
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 113)));
    // 0x20485c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x204860: 0x1045002e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_20491c;
    }
    // 0x204868: 0x12050013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 5)) {
        goto label_2048b8;
    }
    // 0x204870: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_204888;
    }
    // 0x204878: 0x12030009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        goto label_2048a0;
    }
    // 0x204880: 0x10000027
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204920;
    }
label_204888:
    // 0x204888: 0x12020011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2048d0;
    }
    // 0x204890: 0x12020014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2048e4;
    }
    // 0x204898: 0x10000021
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204920;
    }
label_2048a0:
    // 0x2048a0: 0x90830065
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 101)));
    // 0x2048a4: 0x240200f3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 243));
    // 0x2048a8: 0x1062001b
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_204918;
    }
    // 0x2048b0: 0x1000001b
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204920;
    }
label_2048b8:
    // 0x2048b8: 0x90820064
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x2048bc: 0x10430017
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_20491c;
    }
    // 0x2048c4: 0x90830069
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 105)));
    // 0x2048c8: 0x10000010
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20490c;
    }
label_2048d0:
    // 0x2048d0: 0x90820064
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x2048d4: 0x10430011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_20491c;
    }
    // 0x2048dc: 0x1000000f
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 105)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20491c;
    }
label_2048e4:
    // 0x2048e4: 0x90820064
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x2048e8: 0x1043000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_204918;
    }
    // 0x2048f0: 0x16220003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 104)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_204900;
    }
    // 0x2048f8: 0x10000009
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204920;
    }
label_204900:
    // 0x204900: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x204904: 0x10400004
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_204918;
    }
label_20490c:
    // 0x20490c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x204910: 0x10000002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20491c;
    }
label_204918:
    // 0x204918: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20491c:
    // 0x20491c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_204920:
    // 0x204920: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204924: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204928: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadSetMainMode
// Address: 0x204930 - 0x204998

void entry_204998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204998) {
        switch (ctx->pc) {
            case 0x2049a8: ctx->pc = 0; goto label_2049a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204998: 0x4430003
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_2049a8;
    }
    // 0x2049a0: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2049CC; return;
    }
label_2049a8:
    // 0x2049a8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2049ac: 0x14620007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x2049CC; return;
    }
    // 0x2049b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x2049b8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x2049bc: 0xc081184
    SET_GPR_U32(ctx, 31, 0x2049c4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    scePadSetReqState(rdram, ctx, runtime); return;
}


// Function: entry_2049c4
// Address: 0x2049c4 - 0x2049e8

void entry_2049c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2049c4) {
        switch (ctx->pc) {
            case 0x2049cc: ctx->pc = 0; goto label_2049cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2049c4: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x2049c8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_2049cc:
    // 0x2049cc: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x2049d0: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2049d4: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2049d8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2049dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2049e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2049e8; return;
}


// Function: scePadSetActDirect
// Address: 0x2049e8 - 0x204a0c

void entry_204a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204a0c) {
        switch (ctx->pc) {
            case 0x204a48: ctx->pc = 0; goto label_204a48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204a0c: 0x90430072
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 114)));
    // 0x204a10: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204a14: 0x1462001e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x204A90; return;
    }
    // 0x204a1c: 0x2403001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    // 0x204a20: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x204a24: 0x2431818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x204a28: 0x72242018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 4); ctx->lo1 = (uint32_t)result; ctx->hi1 = (uint32_t)(result >> 32); }
    // 0x204a2c: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x204a30: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x204a34: 0x2442aad0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945488));
    // 0x204a38: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x204a3c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x204a40: 0x8c460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x204a44: 0x24c7000c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 12));
label_204a48:
    // 0x204a48: 0x2051021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 5)));
    // 0x204a4c: 0xe52021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x204a50: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x204a54: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x204a58: 0x28a20006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 6));
    // 0x204a5c: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x204a60: 0x1440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_204a48;
    }
    // 0x204a68: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204a6c: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x204a70: 0xacd00004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 16));
    // 0x204a74: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x204a78: 0xacc20008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 2));
    // 0x204a7c: 0xc080ff4
    SET_GPR_U32(ctx, 31, 0x204a84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___send_to_iop(rdram, ctx, runtime); return;
}


// Function: entry_204a84
// Address: 0x204a84 - 0x204aa8

void entry_204a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204a84) {
        switch (ctx->pc) {
            case 0x204a90: ctx->pc = 0; goto label_204a90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204a84: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x204a88: 0x2800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x204a8c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_204a90:
    // 0x204a90: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x204a94: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204a98: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204a9c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204aa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadSetActAlign
// Address: 0x204aa8 - 0x204b34

void entry_204b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204b34) {
        switch (ctx->pc) {
            case 0x204b44: ctx->pc = 0; goto label_204b44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204b34: 0x4430003
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_204b44;
    }
    // 0x204b3c: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x204B68; return;
    }
label_204b44:
    // 0x204b44: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204b48: 0x14620007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x204B68; return;
    }
    // 0x204b50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x204b54: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x204b58: 0xc081184
    SET_GPR_U32(ctx, 31, 0x204b60);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    scePadSetReqState(rdram, ctx, runtime); return;
}


// Function: entry_204b60
// Address: 0x204b60 - 0x204b80

void entry_204b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204b60) {
        switch (ctx->pc) {
            case 0x204b68: ctx->pc = 0; goto label_204b68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204b60: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x204b64: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_204b68:
    // 0x204b68: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x204b6c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x204b70: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204b74: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204b78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadGetButtonMask
// Address: 0x204b80 - 0x204bc0

void entry_204bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204bc0) {
        switch (ctx->pc) {
            case 0x204bdc: ctx->pc = 0; goto label_204bdc;
            case 0x204c28: ctx->pc = 0; goto label_204c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204bc0: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x204bc4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204bc8: 0x90c20072
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 114)));
    // 0x204bcc: 0x50430003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 100)));
        goto label_204bdc;
    }
    // 0x204bd4: 0x10000014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_204c28;
    }
label_204bdc:
    // 0x204bdc: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x204be0: 0x14400011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_204c28;
    }
    // 0x204be8: 0x90c20066
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 102)));
    // 0x204bec: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x204bf0: 0x1440000d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_204c28;
    }
    // 0x204bf8: 0x90c5007a
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 122)));
    // 0x204bfc: 0x90c4007c
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 124)));
    // 0x204c00: 0x90c3007b
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 123)));
    // 0x204c04: 0x52a38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 8);
    // 0x204c08: 0x90c20079
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 121)));
    // 0x204c0c: 0x42638
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 24);
    // 0x204c10: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x204c14: 0x44102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) + GPR_U64(ctx, 4));
    // 0x204c18: 0x65182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) + GPR_U64(ctx, 5));
    // 0x204c1c: 0x43102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) + GPR_U64(ctx, 3));
    // 0x204c20: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x204c24: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
label_204c28:
    // 0x204c28: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204c2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204c38; return;
}


// Function: scePadSetButtonInfo
// Address: 0x204c38 - 0x204c9c

void entry_204c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204c9c) {
        switch (ctx->pc) {
            case 0x204cac: ctx->pc = 0; goto label_204cac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204c9c: 0x4430003
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
        goto label_204cac;
    }
    // 0x204ca4: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x204CD0; return;
    }
label_204cac:
    // 0x204cac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x204cb0: 0x14620007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x204CD0; return;
    }
    // 0x204cb8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x204cbc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x204cc0: 0xc081184
    SET_GPR_U32(ctx, 31, 0x204cc8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    scePadSetReqState(rdram, ctx, runtime); return;
}


// Function: entry_204cc8
// Address: 0x204cc8 - 0x204ce8

void entry_204cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204cc8) {
        switch (ctx->pc) {
            case 0x204cd0: ctx->pc = 0; goto label_204cd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204cc8: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x204ccc: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_204cd0:
    // 0x204cd0: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x204cd4: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x204cd8: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204cdc: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204ce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: scePadInfoPressMode
// Address: 0x204ce8 - 0x204d28

void entry_204d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204d28) {
        switch (ctx->pc) {
            case 0x204d38: ctx->pc = 0; goto label_204d38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204d28: 0x3c030003
    SET_GPR_U32(ctx, 3, ((uint32_t)3 << 16));
    // 0x204d2c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x204d30: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x204d34: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
label_204d38:
    // 0x204d38: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204d3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204d44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204d48; return;
}


// Function: scePadEnterPressMode
// Address: 0x204d48 - 0x204d90

void entry_204d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x204d90: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204d94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204d9c: 0x0
    // NOP
    // 0x204da0: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x204da4: 0x0
    // NOP
    // 0x204da8: 0x27bd0050
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    // 0x204dac: 0x0
    // NOP
    // 0x204db0: 0x27bd0030
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    // 0x204db4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204db8; return;
}


// Function: scePadGetModVersion
// Address: 0x204db8 - 0x204e00

void entry_204e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204e00) {
        switch (ctx->pc) {
            case 0x204e0c: ctx->pc = 0; goto label_204e0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204e00: 0x4430002
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_204e0c;
    }
    // 0x204e08: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_204e0c:
    // 0x204e0c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204e10: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204e14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204e1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204e20; return;
}


// Function: _sceSDC
// Address: 0x204e20 - 0x204ec8

void entry_204f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x204f00: 0x3c04ffff
    SET_GPR_U32(ctx, 4, ((uint32_t)65535 << 16));
    // 0x204f04: 0x3484ffc0
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65472));
    // 0x204f08: 0x2242824
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x204f0c: 0xc081388
    SET_GPR_U32(ctx, 31, 0x204f14);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    _sceSDC(rdram, ctx, runtime); return;
}


// Function: entry_204f14
// Address: 0x204f14 - 0x204f68

void entry_204f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x204f14) {
        switch (ctx->pc) {
            case 0x204f30: ctx->pc = 0; goto label_204f30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x204f14: 0x12000006
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_204f30;
    }
    // 0x204f1c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204f20: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204f24: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204f28: 0x807e76a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    EIntr(rdram, ctx, runtime); return;
label_204f30:
    // 0x204f30: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x204f34: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x204f38: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x204f3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x204f44: 0x0
    // NOP
    // 0x204f48: 0x822024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x204f4c: 0x0
    // NOP
    // 0x204f50: 0x0
    // NOP
    // 0x204f54: 0x0
    // NOP
    // 0x204f58: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x204f5c: 0x0
    // NOP
    // 0x204f60: 0x822024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x204f64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x204f68; return;
}


// Function: atanf
// Address: 0x204f68 - 0x205048

void entry_205048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205048) {
        switch (ctx->pc) {
            case 0x2050a0: ctx->pc = 0; goto label_2050a0;
            case 0x2050c4: ctx->pc = 0; goto label_2050c4;
            case 0x205108: ctx->pc = 0; goto label_205108;
            case 0x20511c: ctx->pc = 0; goto label_20511c;
            case 0x205120: ctx->pc = 0; goto label_205120;
            case 0x2051bc: ctx->pc = 0; goto label_2051bc;
            case 0x2051fc: ctx->pc = 0; goto label_2051fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205048: 0x3c023f97
    SET_GPR_U32(ctx, 2, ((uint32_t)16279 << 16));
    // 0x20504c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x205050: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x205054: 0x1440001b
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2050c4;
    }
    // 0x20505c: 0x3c023f2f
    SET_GPR_U32(ctx, 2, ((uint32_t)16175 << 16));
    // 0x205060: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x205064: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x205068: 0x1440000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2050a0;
    }
    // 0x205070: 0x460c6000
    ctx->f[0] = FPU_ADD_S(ctx->f[12], ctx->f[12]);
    // 0x205074: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x205078: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x20507c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x205080: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x205084: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x205088: 0x46016040
    ctx->f[1] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x20508c: 0x0
    // NOP
    // 0x205090: 0x0
    // NOP
    // 0x205094: 0x46010303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[1];
    // 0x205098: 0x10000021
    ctx->f[10] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205120;
    }
label_2050a0:
    // 0x2050a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2050a4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2050a8: 0x46006040
    ctx->f[1] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x2050ac: 0x46006001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x2050b0: 0x0
    // NOP
    // 0x2050b4: 0x0
    // NOP
    // 0x2050b8: 0x46010303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[1];
    // 0x2050bc: 0x10000017
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20511c;
    }
label_2050c4:
    // 0x2050c4: 0x3c02401b
    SET_GPR_U32(ctx, 2, ((uint32_t)16411 << 16));
    // 0x2050c8: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2050cc: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x2050d0: 0x1440000d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_205108;
    }
    // 0x2050d8: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x2050dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2050e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2050e4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x2050e8: 0x46006042
    ctx->f[1] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x2050ec: 0x46006001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x2050f0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x2050f4: 0x0
    // NOP
    // 0x2050f8: 0x0
    // NOP
    // 0x2050fc: 0x46010303
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[1];
    // 0x205100: 0x10000006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20511c;
    }
label_205108:
    // 0x205108: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x20510c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x205110: 0x0
    // NOP
    // 0x205114: 0x0
    // NOP
    // 0x205118: 0x460c0303
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[12];
label_20511c:
    // 0x20511c: 0x460c6282
    ctx->f[10] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
label_205120:
    // 0x205120: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x205124: 0x2462f8b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294965424));
    // 0x205128: 0xc469f8b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294965424)); ctx->f[9] = *(float*)&val; }
    // 0x20512c: 0xc4430028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[3] = *(float*)&val; }
    // 0x205130: 0x460a5002
    ctx->f[0] = FPU_MUL_S(ctx->f[10], ctx->f[10]);
    // 0x205134: 0xc4450020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[5] = *(float*)&val; }
    // 0x205138: 0xc4440024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 36)); ctx->f[4] = *(float*)&val; }
    // 0x20513c: 0xc441001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[1] = *(float*)&val; }
    // 0x205140: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x205144: 0xc4460018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[6] = *(float*)&val; }
    // 0x205148: 0x46040102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x20514c: 0xc4420014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[2] = *(float*)&val; }
    // 0x205150: 0xc4470010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[7] = *(float*)&val; }
    // 0x205154: 0x46032940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[3]);
    // 0x205158: 0xc4480008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[8] = *(float*)&val; }
    // 0x20515c: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x205160: 0xc443000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[3] = *(float*)&val; }
    // 0x205164: 0xc4440004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    // 0x205168: 0x46050142
    ctx->f[5] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x20516c: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x205170: 0x46053180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[5]);
    // 0x205174: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x205178: 0x46060182
    ctx->f[6] = FPU_MUL_S(ctx->f[0], ctx->f[6]);
    // 0x20517c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x205180: 0x460639c0
    ctx->f[7] = FPU_ADD_S(ctx->f[7], ctx->f[6]);
    // 0x205184: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x205188: 0x460701c2
    ctx->f[7] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x20518c: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x205190: 0x46074200
    ctx->f[8] = FPU_ADD_S(ctx->f[8], ctx->f[7]);
    // 0x205194: 0x46032100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[3]);
    // 0x205198: 0x46080202
    ctx->f[8] = FPU_MUL_S(ctx->f[0], ctx->f[8]);
    // 0x20519c: 0x46040042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x2051a0: 0x46084a40
    ctx->f[9] = FPU_ADD_S(ctx->f[9], ctx->f[8]);
    // 0x2051a4: 0x4810005
    ctx->f[0] = FPU_MUL_S(ctx->f[10], ctx->f[9]);
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_2051bc;
    }
    // 0x2051ac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x2051b0: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x2051b4: 0x10000011
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2051fc;
    }
label_2051bc:
    // 0x2051bc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x2051c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2051c4: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x2051c8: 0x2442f8a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965408));
    // 0x2051cc: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x2051d0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x2051d4: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x2051d8: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x2051dc: 0x2463f890
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294965392));
    // 0x2051e0: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x2051e4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x2051e8: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x2051ec: 0x460c0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x2051f0: 0x6210002
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_2051fc;
    }
    // 0x2051f8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
label_2051fc:
    // 0x2051fc: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x205200: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x205204: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x205208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: cosf
// Address: 0x205210 - 0x205248

void entry_205248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205248) {
        switch (ctx->pc) {
            case 0x205250: ctx->pc = 0; goto label_205250;
            case 0x20526c: ctx->pc = 0; goto label_20526c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205248: 0x10000029
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2052F0; return;
    }
label_205250:
    // 0x205250: 0x3c027f7f
    SET_GPR_U32(ctx, 2, ((uint32_t)32639 << 16));
    // 0x205254: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x205258: 0x44102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x20525c: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20526c;
    }
    // 0x205264: 0x10000021
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2052ec(rdram, ctx, runtime); return;
    }
label_20526c:
    // 0x20526c: 0xc081f22
    SET_GPR_U32(ctx, 31, 0x205274);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_00207c88(rdram, ctx, runtime); return;
}


// Function: entry_205274
// Address: 0x205274 - 0x2052b4

void entry_205274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205274) {
        switch (ctx->pc) {
            case 0x20529c: ctx->pc = 0; goto label_20529c;
            case 0x2052ac: ctx->pc = 0; goto label_2052ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205274: 0x30430003
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 3));
    // 0x205278: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20527c: 0x1062000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x2052BC; return;
    }
    // 0x205284: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20529c;
    }
    // 0x20528c: 0x10600007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_2052ac;
    }
    // 0x205294: 0x10000013
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2052E4; return;
    }
label_20529c:
    // 0x20529c: 0x1062000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x2052D4; return;
    }
    // 0x2052a4: 0x1000000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2052E4; return;
    }
label_2052ac:
    // 0x2052ac: 0xc082068
    SET_GPR_U32(ctx, 31, 0x2052b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_cosf(rdram, ctx, runtime); return;
}


// Function: entry_2052b4
// Address: 0x2052b4 - 0x2052cc

void entry_2052b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2052b4) {
        switch (ctx->pc) {
            case 0x2052bc: ctx->pc = 0; goto label_2052bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2052b4: 0x1000000e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2052F0; return;
    }
label_2052bc:
    // 0x2052bc: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x2052c0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2052c4: 0xc082312
    SET_GPR_U32(ctx, 31, 0x2052cc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_sinf(rdram, ctx, runtime); return;
}


// Function: entry_2052cc
// Address: 0x2052cc - 0x2052dc

void entry_2052cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2052cc) {
        switch (ctx->pc) {
            case 0x2052d4: ctx->pc = 0; goto label_2052d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2052cc: 0x10000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2052ec(rdram, ctx, runtime); return;
    }
label_2052d4:
    // 0x2052d4: 0xc082068
    SET_GPR_U32(ctx, 31, 0x2052dc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_cosf(rdram, ctx, runtime); return;
}


// Function: entry_2052dc
// Address: 0x2052dc - 0x2052ec

void entry_2052dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2052dc) {
        switch (ctx->pc) {
            case 0x2052e4: ctx->pc = 0; goto label_2052e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2052dc: 0x10000003
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2052ec(rdram, ctx, runtime); return;
    }
label_2052e4:
    // 0x2052e4: 0xc082312
    SET_GPR_U32(ctx, 31, 0x2052ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_sinf(rdram, ctx, runtime); return;
}


// Function: entry_2052ec
// Address: 0x2052ec - 0x2052f8

void entry_2052ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2052ec) {
        switch (ctx->pc) {
            case 0x2052f0: ctx->pc = 0; goto label_2052f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2052ec: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_2052f0:
    // 0x2052f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fabsf
// Address: 0x2052f8 - 0x205318

void entry_205438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205438) {
        switch (ctx->pc) {
            case 0x205440: ctx->pc = 0; goto label_205440;
            case 0x20545c: ctx->pc = 0; goto label_20545c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205438: 0x1000002b
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054E8; return;
    }
label_205440:
    // 0x205440: 0x3c027f7f
    SET_GPR_U32(ctx, 2, ((uint32_t)32639 << 16));
    // 0x205444: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x205448: 0x44102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x20544c: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20545c;
    }
    // 0x205454: 0x10000023
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054E4; return;
    }
label_20545c:
    // 0x20545c: 0xc081f22
    SET_GPR_U32(ctx, 31, 0x205464);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_00207c88(rdram, ctx, runtime); return;
}


// Function: entry_205464
// Address: 0x205464 - 0x2054a8

void entry_205464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205464) {
        switch (ctx->pc) {
            case 0x20548c: ctx->pc = 0; goto label_20548c;
            case 0x20549c: ctx->pc = 0; goto label_20549c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205464: 0x30430003
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 3));
    // 0x205468: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20546c: 0x10620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x2054B0; return;
    }
    // 0x205474: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20548c;
    }
    // 0x20547c: 0x10600007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_20549c;
    }
    // 0x205484: 0x10000014
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054D8; return;
    }
label_20548c:
    // 0x20548c: 0x1062000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x2054C4; return;
    }
    // 0x205494: 0x10000010
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054D8; return;
    }
label_20549c:
    // 0x20549c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2054a0: 0xc082312
    SET_GPR_U32(ctx, 31, 0x2054a8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_sinf(rdram, ctx, runtime); return;
}


// Function: entry_2054a8
// Address: 0x2054a8 - 0x2054bc

void entry_2054a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2054a8) {
        switch (ctx->pc) {
            case 0x2054b0: ctx->pc = 0; goto label_2054b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2054a8: 0x1000000f
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054E8; return;
    }
label_2054b0:
    // 0x2054b0: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x2054b4: 0xc082068
    SET_GPR_U32(ctx, 31, 0x2054bc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_cosf(rdram, ctx, runtime); return;
}


// Function: entry_2054bc
// Address: 0x2054bc - 0x2054d0

void entry_2054bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2054bc) {
        switch (ctx->pc) {
            case 0x2054c4: ctx->pc = 0; goto label_2054c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2054bc: 0x1000000a
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054E8; return;
    }
label_2054c4:
    // 0x2054c4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2054c8: 0xc082312
    SET_GPR_U32(ctx, 31, 0x2054d0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_sinf(rdram, ctx, runtime); return;
}


// Function: entry_2054d0
// Address: 0x2054d0 - 0x2054e0

void entry_2054d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2054d0) {
        switch (ctx->pc) {
            case 0x2054d8: ctx->pc = 0; goto label_2054d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2054d0: 0x10000004
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2054E4; return;
    }
label_2054d8:
    // 0x2054d8: 0xc082068
    SET_GPR_U32(ctx, 31, 0x2054e0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    fn___kernel_cosf(rdram, ctx, runtime); return;
}


// Function: entry_2054e0
// Address: 0x2054e0 - 0x2054f0

void entry_2054e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2054e0) {
        switch (ctx->pc) {
            case 0x2054e4: ctx->pc = 0; goto label_2054e4;
            case 0x2054e8: ctx->pc = 0; goto label_2054e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2054e0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
label_2054e4:
    // 0x2054e4: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_2054e8:
    // 0x2054e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: tanf
// Address: 0x2054f0 - 0x20554c

void entry_20554c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20554c) {
        switch (ctx->pc) {
            case 0x205564: ctx->pc = 0; goto label_205564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20554c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x205550: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205554: 0x21040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    // 0x205558: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x20555c: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x205560: 0x822023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
label_205564:
    // 0x205564: 0xc082354
    SET_GPR_U32(ctx, 31, 0x20556c);
    R_free(rdram, ctx, runtime); return;
}


// Function: entry_20556c
// Address: 0x20556c - 0x205578

void entry_20556c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20556c: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x205570: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: acosf
// Address: 0x205578 - 0x205594

void entry_205594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205594: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205598: 0x8c50ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4294967160)));
    // 0x20559c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2055a0: 0x1203002d
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x205658; return;
    }
    // 0x2055a8: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2055b0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2055b0
// Address: 0x2055b0 - 0x2055c0

void entry_2055b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2055b0: 0x1440002a
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20565C; return;
    }
    // 0x2055b8: 0xc0814be
    SET_GPR_U32(ctx, 31, 0x2055c0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fabsf(rdram, ctx, runtime); return;
}


// Function: entry_2055c0
// Address: 0x2055c0 - 0x2055f4

void entry_2055c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2055c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2055c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2055c8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2055cc: 0x0
    // NOP
    // 0x2055d0: 0x45000021
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205658; return;
    }
    // 0x2055d8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2055dc: 0x2442f8f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965488));
    // 0x2055e0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x2055e4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x2055e8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x2055ec: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2055f4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2055f4
// Address: 0x2055f4 - 0x205614

void entry_2055f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2055f4: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2055f8: 0xffa20008
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    // 0x2055fc: 0xffa30018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 3));
    // 0x205600: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205604: 0x12030005
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x20561C; return;
    }
    // 0x20560c: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205614);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205614
// Address: 0x205614 - 0x205624

void entry_205614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205614) {
        switch (ctx->pc) {
            case 0x20561c: ctx->pc = 0; goto label_20561c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205614: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205630; return;
    }
label_20561c:
    // 0x20561c: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205624);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205624
// Address: 0x205624 - 0x205640

void entry_205624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205624) {
        switch (ctx->pc) {
            case 0x205630: ctx->pc = 0; goto label_205630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205624: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x205628: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x20562c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205630:
    // 0x205630: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205648; return;
    }
    // 0x205638: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205640);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205640
// Address: 0x205640 - 0x205650

void entry_205640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205640) {
        switch (ctx->pc) {
            case 0x205648: ctx->pc = 0; goto label_205648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205640: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x205644: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_205648:
    // 0x205648: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205650);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205650
// Address: 0x205650 - 0x205678

void entry_205650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205650) {
        switch (ctx->pc) {
            case 0x205658: ctx->pc = 0; goto label_205658;
            case 0x20565c: ctx->pc = 0; goto label_20565c;
            case 0x205660: ctx->pc = 0; goto label_205660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205650: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205660;
    }
label_205658:
    // 0x205658: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_20565c:
    // 0x20565c: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
label_205660:
    // 0x205660: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x205664: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x205668: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x20566c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x205674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x205678; return;
}


// Function: asinf
// Address: 0x205678 - 0x205694

void entry_205694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205694: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205698: 0x8c50ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4294967160)));
    // 0x20569c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2056a0: 0x1203002d
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x205758; return;
    }
    // 0x2056a8: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2056b0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2056b0
// Address: 0x2056b0 - 0x2056c0

void entry_2056b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2056b0: 0x1440002a
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20575C; return;
    }
    // 0x2056b8: 0xc0814be
    SET_GPR_U32(ctx, 31, 0x2056c0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fabsf(rdram, ctx, runtime); return;
}


// Function: entry_2056c0
// Address: 0x2056c0 - 0x2056f4

void entry_2056c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2056c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2056c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2056c8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2056cc: 0x0
    // NOP
    // 0x2056d0: 0x45000021
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205758; return;
    }
    // 0x2056d8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2056dc: 0x2442f8f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965496));
    // 0x2056e0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x2056e4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x2056e8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x2056ec: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2056f4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2056f4
// Address: 0x2056f4 - 0x205714

void entry_2056f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2056f4: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2056f8: 0xffa20008
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    // 0x2056fc: 0xffa30018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 3));
    // 0x205700: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205704: 0x12030005
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x20571C; return;
    }
    // 0x20570c: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205714);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205714
// Address: 0x205714 - 0x205724

void entry_205714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205714) {
        switch (ctx->pc) {
            case 0x20571c: ctx->pc = 0; goto label_20571c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205714: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205730; return;
    }
label_20571c:
    // 0x20571c: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205724);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205724
// Address: 0x205724 - 0x205740

void entry_205724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205724) {
        switch (ctx->pc) {
            case 0x205730: ctx->pc = 0; goto label_205730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205724: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x205728: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x20572c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205730:
    // 0x205730: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205748; return;
    }
    // 0x205738: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205740);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205740
// Address: 0x205740 - 0x205750

void entry_205740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205740) {
        switch (ctx->pc) {
            case 0x205748: ctx->pc = 0; goto label_205748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205740: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x205744: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_205748:
    // 0x205748: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205750);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205750
// Address: 0x205750 - 0x205778

void entry_205750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205750) {
        switch (ctx->pc) {
            case 0x205758: ctx->pc = 0; goto label_205758;
            case 0x20575c: ctx->pc = 0; goto label_20575c;
            case 0x205760: ctx->pc = 0; goto label_205760;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205750: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205760;
    }
label_205758:
    // 0x205758: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_20575c:
    // 0x20575c: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
label_205760:
    // 0x205760: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x205764: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x205768: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x20576c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x205774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x205778; return;
}


// Function: atan2f
// Address: 0x205778 - 0x20579c

void entry_20579c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20579c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x2057a0: 0x8c50ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4294967160)));
    // 0x2057a4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2057a8: 0x12030035
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x205880; return;
    }
    // 0x2057b0: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2057b8);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2057b8
// Address: 0x2057b8 - 0x2057c8

void entry_2057b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2057b8: 0x14400032
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205884; return;
    }
    // 0x2057c0: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2057c8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2057c8
// Address: 0x2057c8 - 0x2057fc

void entry_2057c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2057c8: 0x1440002e
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205884; return;
    }
    // 0x2057d0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2057d4: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2057d8: 0x0
    // NOP
    // 0x2057dc: 0x45020029
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[22]);
        ctx->pc = 0x205884; return;
    }
    // 0x2057e4: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2057e8: 0x0
    // NOP
    // 0x2057ec: 0x45000025
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205884; return;
    }
    // 0x2057f4: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2057fc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2057fc
// Address: 0x2057fc - 0x205808

void entry_2057fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2057fc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x205800: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205808);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205808
// Address: 0x205808 - 0x20583c

void entry_205808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205808: 0xffa20010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    // 0x20580c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x205810: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205814: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205818: 0x2463f900
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294965504));
    // 0x20581c: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    // 0x205820: 0xafa40000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 4));
    // 0x205824: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205828: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x20582c: 0x12020005
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x205844; return;
    }
    // 0x205834: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x20583c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_20583c
// Address: 0x20583c - 0x20584c

void entry_20583c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20583c) {
        switch (ctx->pc) {
            case 0x205844: ctx->pc = 0; goto label_205844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20583c: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205858; return;
    }
label_205844:
    // 0x205844: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x20584c);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_20584c
// Address: 0x20584c - 0x205868

void entry_20584c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20584c) {
        switch (ctx->pc) {
            case 0x205858: ctx->pc = 0; goto label_205858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20584c: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x205850: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x205854: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205858:
    // 0x205858: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205870; return;
    }
    // 0x205860: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205868);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205868
// Address: 0x205868 - 0x205878

void entry_205868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205868) {
        switch (ctx->pc) {
            case 0x205870: ctx->pc = 0; goto label_205870;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205868: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20586c: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_205870:
    // 0x205870: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205878);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205878
// Address: 0x205878 - 0x2058a0

void entry_205878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205878) {
        switch (ctx->pc) {
            case 0x205880: ctx->pc = 0; goto label_205880;
            case 0x205884: ctx->pc = 0; goto label_205884;
            case 0x205888: ctx->pc = 0; goto label_205888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205878: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205888;
    }
label_205880:
    // 0x205880: 0x4600b006
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
label_205884:
    // 0x205884: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
label_205888:
    // 0x205888: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20588c: 0xc7b60060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[22] = *(float*)&val; }
    // 0x205890: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x205894: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x205898: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fmodf
// Address: 0x2058a0 - 0x2058cc

void entry_2058cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2058cc: 0x8e30ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x2058d0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2058d4: 0x12020038
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x2059B8; return;
    }
    // 0x2058dc: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2058e4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2058e4
// Address: 0x2058e4 - 0x2058f4

void entry_2058e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2058e4: 0x14400035
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2059BC; return;
    }
    // 0x2058ec: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2058f4);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2058f4
// Address: 0x2058f4 - 0x20592c

void entry_2058f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2058f4: 0x14400031
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2059BC; return;
    }
    // 0x2058fc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205900: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205904: 0x0
    // NOP
    // 0x205908: 0x4500002b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x2059B8; return;
    }
    // 0x205910: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205914: 0x2442f908
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965512));
    // 0x205918: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20591c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205920: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x205924: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x20592c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_20592c
// Address: 0x20592c - 0x205938

void entry_20592c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20592c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205930: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205938);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205938
// Address: 0x205938 - 0x205948

void entry_205938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205938: 0x16000005
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205950; return;
    }
    // 0x205940: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205948);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205948
// Address: 0x205948 - 0x205974

void entry_205948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205948) {
        switch (ctx->pc) {
            case 0x205950: ctx->pc = 0; goto label_205950;
            case 0x20595c: ctx->pc = 0; goto label_20595c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205948: 0x10000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20595c;
    }
label_205950:
    // 0x205950: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205954: 0xdc43f910
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 4294965520)));
    // 0x205958: 0xffa30018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 3));
label_20595c:
    // 0x20595c: 0x8e23ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205960: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205964: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20597C; return;
    }
    // 0x20596c: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205974);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205974
// Address: 0x205974 - 0x205984

void entry_205974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205974) {
        switch (ctx->pc) {
            case 0x20597c: ctx->pc = 0; goto label_20597c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205974: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205990; return;
    }
label_20597c:
    // 0x20597c: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205984);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205984
// Address: 0x205984 - 0x2059a0

void entry_205984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205984) {
        switch (ctx->pc) {
            case 0x205990: ctx->pc = 0; goto label_205990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205984: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x205988: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x20598c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205990:
    // 0x205990: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2059A8; return;
    }
    // 0x205998: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x2059a0);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_2059a0
// Address: 0x2059a0 - 0x2059b0

void entry_2059a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2059a0) {
        switch (ctx->pc) {
            case 0x2059a8: ctx->pc = 0; goto label_2059a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2059a0: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2059a4: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_2059a8:
    // 0x2059a8: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x2059b0);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_2059b0
// Address: 0x2059b0 - 0x2059e0

void entry_2059b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2059b0) {
        switch (ctx->pc) {
            case 0x2059b8: ctx->pc = 0; goto label_2059b8;
            case 0x2059bc: ctx->pc = 0; goto label_2059bc;
            case 0x2059c0: ctx->pc = 0; goto label_2059c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2059b0: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2059c0;
    }
label_2059b8:
    // 0x2059b8: 0x4600b006
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
label_2059bc:
    // 0x2059bc: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
label_2059c0:
    // 0x2059c0: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x2059c4: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2059c8: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x2059cc: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x2059d0: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x2059d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2059dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2059e0; return;
}


// Function: logf
// Address: 0x2059e0 - 0x205a04

void entry_205a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205a04: 0x8e30ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205a08: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x205a0c: 0x1202000a
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x205A38; return;
    }
    // 0x205a14: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x205a1c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_205a1c
// Address: 0x205a1c - 0x205a54

void entry_205a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205a1c) {
        switch (ctx->pc) {
            case 0x205a38: ctx->pc = 0; goto label_205a38;
            case 0x205a40: ctx->pc = 0; goto label_205a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205a1c: 0x1440003b
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_205b0c(rdram, ctx, runtime); return;
    }
    // 0x205a24: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205a28: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205a2c: 0x0
    // NOP
    // 0x205a30: 0x45000003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_205a40;
    }
label_205a38:
    // 0x205a38: 0x10000034
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_205b0c(rdram, ctx, runtime); return;
    }
label_205a40:
    // 0x205a40: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    // 0x205a44: 0x2442f918
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965528));
    // 0x205a48: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205a4c: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205a54);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205a54
// Address: 0x205a54 - 0x205a80

void entry_205a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205a54) {
        switch (ctx->pc) {
            case 0x205a70: ctx->pc = 0; goto label_205a70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205a54: 0xffa20008
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    // 0x205a58: 0x16000005
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_205a70;
    }
    // 0x205a60: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x205a64: 0xdc22f920
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 1), 4294965536)));
    // 0x205a68: 0x10000006
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205A84; return;
    }
label_205a70:
    // 0x205a70: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205a74: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205a78: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x205a80);
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 2), 4294967152)));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_205a80
// Address: 0x205a80 - 0x205aac

void entry_205a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205a80) {
        switch (ctx->pc) {
            case 0x205a84: ctx->pc = 0; goto label_205a84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205a80: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
label_205a84:
    // 0x205a84: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205a88: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205a8c: 0x0
    // NOP
    // 0x205a90: 0x45000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205AB4; return;
    }
    // 0x205a98: 0x8e23ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205a9c: 0x1462000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x205AC8; return;
    }
    // 0x205aa4: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205aac);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205aac
// Address: 0x205aac - 0x205ad0

void entry_205aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205aac) {
        switch (ctx->pc) {
            case 0x205ab4: ctx->pc = 0; goto label_205ab4;
            case 0x205ac8: ctx->pc = 0; goto label_205ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205aac: 0x1000000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205AE4; return;
    }
label_205ab4:
    // 0x205ab4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205ab8: 0x8e22ff78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205abc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205ac0: 0x10440005
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x205AD8; return;
    }
label_205ac8:
    // 0x205ac8: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205ad0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205ad0
// Address: 0x205ad0 - 0x205ae0

void entry_205ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205ad0) {
        switch (ctx->pc) {
            case 0x205ad8: ctx->pc = 0; goto label_205ad8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205ad0: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205AEC; return;
    }
label_205ad8:
    // 0x205ad8: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205ae0);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205ae0
// Address: 0x205ae0 - 0x205afc

void entry_205ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205ae0) {
        switch (ctx->pc) {
            case 0x205ae4: ctx->pc = 0; goto label_205ae4;
            case 0x205aec: ctx->pc = 0; goto label_205aec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205ae0: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
label_205ae4:
    // 0x205ae4: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x205ae8: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205aec:
    // 0x205aec: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205B04; return;
    }
    // 0x205af4: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205afc);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205afc
// Address: 0x205afc - 0x205b0c

void entry_205afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205afc) {
        switch (ctx->pc) {
            case 0x205b04: ctx->pc = 0; goto label_205b04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205afc: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x205b00: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_205b04:
    // 0x205b04: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205b0c);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205b0c
// Address: 0x205b0c - 0x205b28

void entry_205b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205b0c: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x205b10: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x205b14: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x205b18: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x205b1c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x205b20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: log10f
// Address: 0x205b28 - 0x205b4c

void entry_205b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205b4c: 0x8e30ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205b50: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x205b54: 0x1202003f
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x205C54; return;
    }
    // 0x205b5c: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x205b64);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_205b64
// Address: 0x205b64 - 0x205b94

void entry_205b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205b64: 0x1440003c
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205C58; return;
    }
    // 0x205b6c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205b70: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205b74: 0x0
    // NOP
    // 0x205b78: 0x45000036
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205C54; return;
    }
    // 0x205b80: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    // 0x205b84: 0x2442f928
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965544));
    // 0x205b88: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205b8c: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205b94);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205b94
// Address: 0x205b94 - 0x205bc0

void entry_205b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205b94) {
        switch (ctx->pc) {
            case 0x205bb0: ctx->pc = 0; goto label_205bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205b94: 0xffa20008
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    // 0x205b98: 0x16000005
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_205bb0;
    }
    // 0x205ba0: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x205ba4: 0xdc22f930
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 1), 4294965552)));
    // 0x205ba8: 0x10000006
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205BC4; return;
    }
label_205bb0:
    // 0x205bb0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205bb4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205bb8: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x205bc0);
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 2), 4294967152)));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_205bc0
// Address: 0x205bc0 - 0x205bec

void entry_205bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205bc0) {
        switch (ctx->pc) {
            case 0x205bc4: ctx->pc = 0; goto label_205bc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205bc0: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
label_205bc4:
    // 0x205bc4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205bc8: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205bcc: 0x0
    // NOP
    // 0x205bd0: 0x45000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205BF4; return;
    }
    // 0x205bd8: 0x8e23ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205bdc: 0x1462000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x205C08; return;
    }
    // 0x205be4: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205bec);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205bec
// Address: 0x205bec - 0x205c10

void entry_205bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205bec) {
        switch (ctx->pc) {
            case 0x205bf4: ctx->pc = 0; goto label_205bf4;
            case 0x205c08: ctx->pc = 0; goto label_205c08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205bec: 0x1000000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205C24; return;
    }
label_205bf4:
    // 0x205bf4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205bf8: 0x8e22ff78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x205bfc: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205c00: 0x10440005
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x205C18; return;
    }
label_205c08:
    // 0x205c08: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205c10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205c10
// Address: 0x205c10 - 0x205c20

void entry_205c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205c10) {
        switch (ctx->pc) {
            case 0x205c18: ctx->pc = 0; goto label_205c18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205c10: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205C2C; return;
    }
label_205c18:
    // 0x205c18: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205c20);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205c20
// Address: 0x205c20 - 0x205c3c

void entry_205c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205c20) {
        switch (ctx->pc) {
            case 0x205c24: ctx->pc = 0; goto label_205c24;
            case 0x205c2c: ctx->pc = 0; goto label_205c2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205c20: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
label_205c24:
    // 0x205c24: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x205c28: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_205c2c:
    // 0x205c2c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205C44; return;
    }
    // 0x205c34: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205c3c);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205c3c
// Address: 0x205c3c - 0x205c4c

void entry_205c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205c3c) {
        switch (ctx->pc) {
            case 0x205c44: ctx->pc = 0; goto label_205c44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205c3c: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x205c40: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_205c44:
    // 0x205c44: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205c4c);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205c4c
// Address: 0x205c4c - 0x205c78

void entry_205c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205c4c) {
        switch (ctx->pc) {
            case 0x205c54: ctx->pc = 0; goto label_205c54;
            case 0x205c58: ctx->pc = 0; goto label_205c58;
            case 0x205c5c: ctx->pc = 0; goto label_205c5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205c4c: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205c5c;
    }
label_205c54:
    // 0x205c54: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_205c58:
    // 0x205c58: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
label_205c5c:
    // 0x205c5c: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x205c60: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x205c64: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x205c68: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x205c6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x205c74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x205c78; return;
}


// Function: powf
// Address: 0x205c78 - 0x205cb0

void entry_205cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205cb0: 0x8e70ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    // 0x205cb4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x205cb8: 0x12020125
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x206150; return;
    }
    // 0x205cc0: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x205cc8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_205cc8
// Address: 0x205cc8 - 0x205cd8

void entry_205cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205cc8: 0x14400122
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206154; return;
    }
    // 0x205cd0: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x205cd8);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_205cd8
// Address: 0x205cd8 - 0x205d10

void entry_205cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205cd8: 0x10400023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205D68; return;
    }
    // 0x205ce0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x205ce4: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205ce8: 0x0
    // NOP
    // 0x205cec: 0x45000118
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x206150; return;
    }
    // 0x205cf4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205cf8: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x205cfc: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x205d00: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205d04: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x205d08: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205d10);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205d10
// Address: 0x205d10 - 0x205d1c

void entry_205d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205d10: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205d14: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205d1c);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205d1c
// Address: 0x205d1c - 0x205d28

void entry_205d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205d1c: 0xffa20010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    // 0x205d20: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205d28);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205d28
// Address: 0x205d28 - 0x205d50

void entry_205d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205d28) {
        switch (ctx->pc) {
            case 0x205d38: ctx->pc = 0; goto label_205d38;
            case 0x205d48: ctx->pc = 0; goto label_205d48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205d28: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    // 0x205d2c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205d30: 0x16020005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_205d48;
    }
label_205d38:
    // 0x205d38: 0x3402ffc0
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65472));
    // 0x205d3c: 0x213bc
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 14));
    // 0x205d40: 0x100000f8
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206124; return;
    }
label_205d48:
    // 0x205d48: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205d50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205d50
// Address: 0x205d50 - 0x205d60

void entry_205d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205d50: 0x144000f5
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206128; return;
    }
    // 0x205d58: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205d60);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205d60
// Address: 0x205d60 - 0x205da4

void entry_205d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205d60) {
        switch (ctx->pc) {
            case 0x205d68: ctx->pc = 0; goto label_205d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205d60: 0x100000ef
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206120; return;
    }
label_205d68:
    // 0x205d68: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x205d6c: 0x4616b832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[23], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205d70: 0x45000043
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205E80; return;
    }
    // 0x205d78: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205d7c: 0x0
    // NOP
    // 0x205d80: 0x45000017
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x205DE0; return;
    }
    // 0x205d88: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205d8c: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x205d90: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x205d94: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205d98: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x205d9c: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205da4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205da4
// Address: 0x205da4 - 0x205db0

void entry_205da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205da4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205da8: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205db0);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205db0
// Address: 0x205db0 - 0x205dc8

void entry_205db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205db0: 0xffa20010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    // 0x205db4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205db8: 0x1600ffdf
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205D38; return;
    }
    // 0x205dc0: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205dc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205dc8
// Address: 0x205dc8 - 0x205dd8

void entry_205dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205dc8: 0x144000d7
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206128; return;
    }
    // 0x205dd0: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205dd8);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205dd8
// Address: 0x205dd8 - 0x205de8

void entry_205dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205dd8) {
        switch (ctx->pc) {
            case 0x205de0: ctx->pc = 0; goto label_205de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205dd8: 0x100000d1
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206120; return;
    }
label_205de0:
    // 0x205de0: 0xc082484
    SET_GPR_U32(ctx, 31, 0x205de8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_205de8
// Address: 0x205de8 - 0x205e1c

void entry_205de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205de8: 0x104000da
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206154; return;
    }
    // 0x205df0: 0x4616a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x205df4: 0x0
    // NOP
    // 0x205df8: 0x450000d6
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x206154; return;
    }
    // 0x205e00: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205e04: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x205e08: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x205e0c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205e10: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x205e14: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205e1c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205e1c
// Address: 0x205e1c - 0x205e28

void entry_205e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205e1c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205e20: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205e28);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205e28
// Address: 0x205e28 - 0x205e4c

void entry_205e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205e28) {
        switch (ctx->pc) {
            case 0x205e3c: ctx->pc = 0; goto label_205e3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205e28: 0x16000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_205e3c;
    }
    // 0x205e30: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205e34: 0x10000006
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205E50; return;
    }
label_205e3c:
    // 0x205e3c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205e40: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205e44: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x205e4c);
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 2), 4294967152)));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_205e4c
// Address: 0x205e4c - 0x205e68

void entry_205e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205e4c) {
        switch (ctx->pc) {
            case 0x205e50: ctx->pc = 0; goto label_205e50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205e4c: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
label_205e50:
    // 0x205e50: 0x8e63ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    // 0x205e54: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205e58: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x205E70; return;
    }
    // 0x205e60: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205e68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205e68
// Address: 0x205e68 - 0x205e78

void entry_205e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205e68) {
        switch (ctx->pc) {
            case 0x205e70: ctx->pc = 0; goto label_205e70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205e68: 0x144000af
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206128; return;
    }
label_205e70:
    // 0x205e70: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205e78);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205e78
// Address: 0x205e78 - 0x205e88

void entry_205e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205e78) {
        switch (ctx->pc) {
            case 0x205e80: ctx->pc = 0; goto label_205e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205e78: 0x100000a9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206120; return;
    }
label_205e80:
    // 0x205e80: 0xc082484
    SET_GPR_U32(ctx, 31, 0x205e88);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_205e88
// Address: 0x205e88 - 0x205e98

void entry_205e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205e88: 0x14400080
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20608C; return;
    }
    // 0x205e90: 0xc082484
    SET_GPR_U32(ctx, 31, 0x205e98);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_205e98
// Address: 0x205e98 - 0x205ea8

void entry_205e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205e98: 0x1040007c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20608C; return;
    }
    // 0x205ea0: 0xc082484
    SET_GPR_U32(ctx, 31, 0x205ea8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_205ea8
// Address: 0x205ea8 - 0x205eb8

void entry_205ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205ea8: 0x10400078
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20608C; return;
    }
    // 0x205eb0: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x205eb8);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_205eb8
// Address: 0x205eb8 - 0x205edc

void entry_205eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205eb8: 0x1040001f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x205F38; return;
    }
    // 0x205ec0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x205ec4: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x205ec8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x205ecc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205ed0: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x205ed4: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205edc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205edc
// Address: 0x205edc - 0x205ee8

void entry_205edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205edc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205ee0: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205ee8);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205ee8
// Address: 0x205ee8 - 0x205f20

void entry_205ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205ee8) {
        switch (ctx->pc) {
            case 0x205efc: ctx->pc = 0; goto label_205efc;
            case 0x205f08: ctx->pc = 0; goto label_205f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205ee8: 0x16000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_205efc;
    }
    // 0x205ef0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x205ef4: 0x10000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_205f08;
    }
label_205efc:
    // 0x205efc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205f00: 0xdc43f940
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 4294965568)));
    // 0x205f04: 0xffa30018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 3));
label_205f08:
    // 0x205f08: 0x8e63ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    // 0x205f0c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x205f10: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x205F28; return;
    }
    // 0x205f18: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x205f20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_205f20
// Address: 0x205f20 - 0x205f30

void entry_205f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205f20) {
        switch (ctx->pc) {
            case 0x205f28: ctx->pc = 0; goto label_205f28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205f20: 0x14400081
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206128; return;
    }
label_205f28:
    // 0x205f28: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x205f30);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_205f30
// Address: 0x205f30 - 0x205f54

void entry_205f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205f30) {
        switch (ctx->pc) {
            case 0x205f38: ctx->pc = 0; goto label_205f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205f30: 0x1000007b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206120; return;
    }
label_205f38:
    // 0x205f38: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x205f3c: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x205f40: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x205f44: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x205f48: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x205f4c: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205f54);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205f54
// Address: 0x205f54 - 0x205f60

void entry_205f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205f54: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205f58: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205f60);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205f60
// Address: 0x205f60 - 0x205f7c

void entry_205f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205f60: 0x16000024
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x205FF4; return;
    }
    // 0x205f68: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x205f6c: 0xdc22f948
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 1), 4294965576)));
    // 0x205f70: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205f74: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205f7c);
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205f7c
// Address: 0x205f7c - 0x205f8c

void entry_205f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205f7c: 0x3405ff80
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65408));
    // 0x205f80: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x205f84: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x205f8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_205f8c
// Address: 0x205f8c - 0x205f94

void entry_205f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205f8c: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x205f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_205f94
// Address: 0x205f94 - 0x205fa0

void entry_205f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205f94: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x205f98: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205fa0);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205fa0
// Address: 0x205fa0 - 0x205fac

void entry_205fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205fa0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x205fa4: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x205fac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_205fac
// Address: 0x205fac - 0x205fbc

void entry_205fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205fac: 0x4410035
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x206084; return;
    }
    // 0x205fb4: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205fbc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205fbc
// Address: 0x205fbc - 0x205fc4

void entry_205fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205fbc: 0xc082404
    SET_GPR_U32(ctx, 31, 0x205fc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    rint(rdram, ctx, runtime); return;
}


// Function: entry_205fc4
// Address: 0x205fc4 - 0x205fd0

void entry_205fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205fc4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x205fc8: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x205fd0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_205fd0
// Address: 0x205fd0 - 0x205fdc

void entry_205fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x205fd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x205fd4: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x205fdc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_205fdc
// Address: 0x205fdc - 0x20600c

void entry_205fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x205fdc) {
        switch (ctx->pc) {
            case 0x205ff4: ctx->pc = 0; goto label_205ff4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x205fdc: 0x10400029
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206084; return;
    }
    // 0x205fe4: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x205fe8: 0xdc22f950
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 1), 4294965584)));
    // 0x205fec: 0x10000025
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206084; return;
    }
label_205ff4:
    // 0x205ff4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x205ff8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x205ffc: 0xdc51ff70
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 2), 4294967152)));
    // 0x206000: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x206004: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x20600c);
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 17));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_20600c
// Address: 0x20600c - 0x20601c

void entry_20600c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20600c: 0x3405ff80
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65408));
    // 0x206010: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x206014: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x20601c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_20601c
// Address: 0x20601c - 0x206024

void entry_20601c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20601c: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x206024);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_206024
// Address: 0x206024 - 0x206030

void entry_206024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206024: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x206028: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x206030);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_206030
// Address: 0x206030 - 0x20603c

void entry_206030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206030: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x206034: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x20603c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_20603c
// Address: 0x20603c - 0x20604c

void entry_20603c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20603c: 0x4410011
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x206084; return;
    }
    // 0x206044: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x20604c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_20604c
// Address: 0x20604c - 0x206054

void entry_20604c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20604c: 0xc082404
    SET_GPR_U32(ctx, 31, 0x206054);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    rint(rdram, ctx, runtime); return;
}


// Function: entry_206054
// Address: 0x206054 - 0x206060

void entry_206054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206054: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x206058: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x206060);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_206060
// Address: 0x206060 - 0x20606c

void entry_206060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206060: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x206064: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x20606c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_20606c
// Address: 0x20606c - 0x20607c

void entry_20606c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20606c: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206080; return;
    }
    // 0x206074: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x20607c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_20607c
// Address: 0x20607c - 0x2060a8

void entry_20607c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20607c) {
        switch (ctx->pc) {
            case 0x206080: ctx->pc = 0; goto label_206080;
            case 0x206084: ctx->pc = 0; goto label_206084;
            case 0x20608c: ctx->pc = 0; goto label_20608c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20607c: 0xffa20018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
label_206080:
    // 0x206080: 0x8e63ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
label_206084:
    // 0x206084: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2060FC; return;
    }
label_20608c:
    // 0x20608c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x206090: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x206094: 0x0
    // NOP
    // 0x206098: 0x4500002e
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x206154; return;
    }
    // 0x2060a0: 0xc082484
    SET_GPR_U32(ctx, 31, 0x2060a8);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_2060a8
// Address: 0x2060a8 - 0x2060b8

void entry_2060a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2060a8: 0x1040002a
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206154; return;
    }
    // 0x2060b0: 0xc082484
    SET_GPR_U32(ctx, 31, 0x2060b8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    finitef(rdram, ctx, runtime); return;
}


// Function: entry_2060b8
// Address: 0x2060b8 - 0x2060dc

void entry_2060b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2060b8: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206150; return;
    }
    // 0x2060c0: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x2060c4: 0x2442f938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965560));
    // 0x2060c8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x2060cc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x2060d0: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x2060d4: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2060dc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2060dc
// Address: 0x2060dc - 0x2060e8

void entry_2060dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2060dc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x2060e0: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2060e8);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2060e8
// Address: 0x2060e8 - 0x20610c

void entry_2060e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2060e8) {
        switch (ctx->pc) {
            case 0x2060fc: ctx->pc = 0; goto label_2060fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2060e8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x2060ec: 0xffa20010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    // 0x2060f0: 0x8e63ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294967160)));
    // 0x2060f4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x2060f8: 0xffa40018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 4));
label_2060fc:
    // 0x2060fc: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x206114; return;
    }
    // 0x206104: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x20610c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_20610c
// Address: 0x20610c - 0x20611c

void entry_20610c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20610c) {
        switch (ctx->pc) {
            case 0x206114: ctx->pc = 0; goto label_206114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20610c: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206128; return;
    }
label_206114:
    // 0x206114: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x20611c);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_20611c
// Address: 0x20611c - 0x206138

void entry_20611c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20611c) {
        switch (ctx->pc) {
            case 0x206120: ctx->pc = 0; goto label_206120;
            case 0x206124: ctx->pc = 0; goto label_206124;
            case 0x206128: ctx->pc = 0; goto label_206128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20611c: 0x24030022
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 34));
label_206120:
    // 0x206120: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_206124:
    // 0x206124: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_206128:
    // 0x206128: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206140; return;
    }
    // 0x206130: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x206138);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_206138
// Address: 0x206138 - 0x206148

void entry_206138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206138) {
        switch (ctx->pc) {
            case 0x206140: ctx->pc = 0; goto label_206140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206138: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20613c: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_206140:
    // 0x206140: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x206148);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_206148
// Address: 0x206148 - 0x206180

void entry_206148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206148) {
        switch (ctx->pc) {
            case 0x206150: ctx->pc = 0; goto label_206150;
            case 0x206154: ctx->pc = 0; goto label_206154;
            case 0x206158: ctx->pc = 0; goto label_206158;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206148: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206158;
    }
label_206150:
    // 0x206150: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_206154:
    // 0x206154: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
label_206158:
    // 0x206158: 0xdfb30060
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20615c: 0xdfb20050
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x206160: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x206164: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x206168: 0xc7b70098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[23] = *(float*)&val; }
    // 0x20616c: 0xc7b60090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[22] = *(float*)&val; }
    // 0x206170: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x206174: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x206178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00206180
// Address: 0x206180 - 0x2061a4

void FUN_00206180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206180: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x206184: 0xe7b40060
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x206188: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x20618c: 0xffb10040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 17));
    // 0x206190: 0xffb00030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 16));
    // 0x206194: 0xe7b50068
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x206198: 0xffbf0050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 31));
    // 0x20619c: 0xc08201a
    SET_GPR_U32(ctx, 31, 0x2061a4);
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    fn___ieee754_sqrtf(rdram, ctx, runtime); return;
}


// Function: entry_2061a4
// Address: 0x2061a4 - 0x2061bc

void entry_2061a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2061a4: 0x8e30ff78
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x2061a8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x2061ac: 0x12020031
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x206274; return;
    }
    // 0x2061b4: 0xc08248e
    SET_GPR_U32(ctx, 31, 0x2061bc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    isnanf(rdram, ctx, runtime); return;
}


// Function: entry_2061bc
// Address: 0x2061bc - 0x2061f4

void entry_2061bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2061bc: 0x1440002e
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206278; return;
    }
    // 0x2061c4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2061c8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2061cc: 0x0
    // NOP
    // 0x2061d0: 0x45000028
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x206274; return;
    }
    // 0x2061d8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x2061dc: 0x2442f958
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965592));
    // 0x2061e0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x2061e4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x2061e8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x2061ec: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x2061f4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_2061f4
// Address: 0x2061f4 - 0x206230

void entry_2061f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2061f4) {
        switch (ctx->pc) {
            case 0x20620c: ctx->pc = 0; goto label_20620c;
            case 0x206218: ctx->pc = 0; goto label_206218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2061f4: 0xffa20008
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 2));
    // 0x2061f8: 0x16000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_20620c;
    }
    // 0x206200: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x206204: 0x10000004
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206218;
    }
label_20620c:
    // 0x20620c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x206210: 0xdc43f960
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 4294965600)));
    // 0x206214: 0xffa30018
    WRITE64(ADD32(GPR_U32(ctx, 29), 24), GPR_U64(ctx, 3));
label_206218:
    // 0x206218: 0x8e23ff78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294967160)));
    // 0x20621c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x206220: 0x10620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x206238; return;
    }
    // 0x206228: 0xc0823fa
    SET_GPR_U32(ctx, 31, 0x206230);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn_matherr(rdram, ctx, runtime); return;
}


// Function: entry_206230
// Address: 0x206230 - 0x206240

void entry_206230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206230) {
        switch (ctx->pc) {
            case 0x206238: ctx->pc = 0; goto label_206238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206230: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20624C; return;
    }
label_206238:
    // 0x206238: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x206240);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_206240
// Address: 0x206240 - 0x20625c

void entry_206240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206240) {
        switch (ctx->pc) {
            case 0x20624c: ctx->pc = 0; goto label_20624c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206240: 0x24030021
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 33));
    // 0x206244: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x206248: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_20624c:
    // 0x20624c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206264; return;
    }
    // 0x206254: 0xc08053c
    SET_GPR_U32(ctx, 31, 0x20625c);
    get_ptr_rng(rdram, ctx, runtime); return;
}


// Function: entry_20625c
// Address: 0x20625c - 0x20626c

void entry_20625c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20625c) {
        switch (ctx->pc) {
            case 0x206264: ctx->pc = 0; goto label_206264;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20625c: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x206260: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_206264:
    // 0x206264: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x20626c);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 29), 24)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_20626c
// Address: 0x20626c - 0x206298

void entry_20626c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20626c) {
        switch (ctx->pc) {
            case 0x206274: ctx->pc = 0; goto label_206274;
            case 0x206278: ctx->pc = 0; goto label_206278;
            case 0x20627c: ctx->pc = 0; goto label_20627c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20626c: 0x10000003
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20627c;
    }
label_206274:
    // 0x206274: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_206278:
    // 0x206278: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
label_20627c:
    // 0x20627c: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x206280: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x206284: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x206288: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x20628c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x206294: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x206298; return;
}


// Function: FUN_00206298
// Address: 0x206298 - 0x206538

void FUN_00206298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206298) {
        switch (ctx->pc) {
            case 0x2062f0: ctx->pc = 0; goto label_2062f0;
            case 0x206314: ctx->pc = 0; goto label_206314;
            case 0x206348: ctx->pc = 0; goto label_206348;
            case 0x20644c: ctx->pc = 0; goto label_20644c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206298: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x20629c: 0x460062c6
    ctx->f[11] = FPU_MOV_S(ctx->f[12]);
    // 0x2062a0: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2062a4: 0xe7b60020
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x2062a8: 0xe7b50018
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x2062ac: 0x44025800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[11]);
    // 0x2062b0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2062b4: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x2062b8: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2062bc: 0x3c053f80
    SET_GPR_U32(ctx, 5, ((uint32_t)16256 << 16));
    // 0x2062c0: 0x821824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x2062c4: 0x1465000a
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_2062f0;
    }
    // 0x2062cc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2062d0: 0x1c8000f8
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_S32(ctx, 4) > 0) {
        ctx->pc = 0x2066B4; return;
    }
    // 0x2062d8: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x2062dc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x2062e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2062e4: 0x100000f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2066B8; return;
    }
    // 0x2062ec: 0x0
    // NOP
label_2062f0:
    // 0x2062f0: 0xa3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x2062f4: 0x10400007
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_206314;
    }
    // 0x2062fc: 0x460b5801
    ctx->f[0] = FPU_SUB_S(ctx->f[11], ctx->f[11]);
    // 0x206300: 0x0
    // NOP
    // 0x206304: 0x0
    // NOP
    // 0x206308: 0x46000003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[0];
    // 0x20630c: 0x100000ea
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2066B8; return;
    }
label_206314:
    // 0x206314: 0x3c023eff
    SET_GPR_U32(ctx, 2, ((uint32_t)16127 << 16));
    // 0x206318: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x20631c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x206320: 0x1440004a
    SET_GPR_U32(ctx, 2, ((uint32_t)8960 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20644c;
    }
    // 0x206328: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x20632c: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_MUL_S(ctx->f[11], ctx->f[11]);
        goto label_206348;
    }
    // 0x206334: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x206338: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x20633c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206340: 0x100000dc
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2066B4; return;
    }
label_206348:
    // 0x206348: 0x3c013811
    SET_GPR_U32(ctx, 1, ((uint32_t)14353 << 16));
    // 0x20634c: 0x3421ef08
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61192));
    // 0x206350: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x206354: 0x3c013a4f
    SET_GPR_U32(ctx, 1, ((uint32_t)14927 << 16));
    // 0x206358: 0x34217f04
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32516));
    // 0x20635c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x206360: 0x3c01bd24
    SET_GPR_U32(ctx, 1, ((uint32_t)48420 << 16));
    // 0x206364: 0x34211146
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4422));
    // 0x206368: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x20636c: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206370: 0x3c013d9d
    SET_GPR_U32(ctx, 1, ((uint32_t)15773 << 16));
    // 0x206374: 0x3421c62e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 50734));
    // 0x206378: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x20637c: 0x3c01bf30
    SET_GPR_U32(ctx, 1, ((uint32_t)48944 << 16));
    // 0x206380: 0x34213361
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13153));
    // 0x206384: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206388: 0x4602a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x20638c: 0x3c013e4e
    SET_GPR_U32(ctx, 1, ((uint32_t)15950 << 16));
    // 0x206390: 0x34210aa8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2728));
    // 0x206394: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x206398: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x20639c: 0x3c014001
    SET_GPR_U32(ctx, 1, ((uint32_t)16385 << 16));
    // 0x2063a0: 0x3421572d
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 22317));
    // 0x2063a4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x2063a8: 0x3c01bea6
    SET_GPR_U32(ctx, 1, ((uint32_t)48806 << 16));
    // 0x2063ac: 0x3421b090
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 45200));
    // 0x2063b0: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x2063b4: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x2063b8: 0x3c01c019
    SET_GPR_U32(ctx, 1, ((uint32_t)49177 << 16));
    // 0x2063bc: 0x3421d139
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 53561));
    // 0x2063c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2063c4: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x2063c8: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x2063cc: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x2063d0: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x2063d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2063d8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x2063dc: 0x4602a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x2063e0: 0x3c0133a2
    SET_GPR_U32(ctx, 1, ((uint32_t)13218 << 16));
    // 0x2063e4: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x2063e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2063ec: 0x46060840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[6]);
    // 0x2063f0: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x2063f4: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x2063f8: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x2063fc: 0x46041080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[4]);
    // 0x206400: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206404: 0x4602a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x206408: 0x46070840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[7]);
    // 0x20640c: 0x46031080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x206410: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206414: 0x4602a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x206418: 0x46090840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[9]);
    // 0x20641c: 0x46051580
    ctx->f[22] = FPU_ADD_S(ctx->f[2], ctx->f[5]);
    // 0x206420: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206424: 0x46080840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[8]);
    // 0x206428: 0x4601ad02
    ctx->f[20] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x20642c: 0x0
    // NOP
    // 0x206430: 0x0
    // NOP
    // 0x206434: 0x4616a303
    if (ctx->f[22] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[12] = ctx->f[20] / ctx->f[22];
    // 0x206438: 0x460c5842
    ctx->f[1] = FPU_MUL_S(ctx->f[11], ctx->f[12]);
    // 0x20643c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x206440: 0x46005801
    ctx->f[0] = FPU_SUB_S(ctx->f[11], ctx->f[0]);
    // 0x206444: 0x1000009a
    ctx->f[0] = FPU_SUB_S(ctx->f[10], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2066B0; return;
    }
label_20644c:
    // 0x20644c: 0x481004a
    if (GPR_S32(ctx, 4) >= 0) {
        ctx->pc = 0x206578; return;
    }
    // 0x206454: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x206458: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x20645c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x206460: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x206464: 0x460a5880
    ctx->f[2] = FPU_ADD_S(ctx->f[11], ctx->f[10]);
    // 0x206468: 0x3c013811
    SET_GPR_U32(ctx, 1, ((uint32_t)14353 << 16));
    // 0x20646c: 0x3421ef08
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61192));
    // 0x206470: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206474: 0x3c013a4f
    SET_GPR_U32(ctx, 1, ((uint32_t)14927 << 16));
    // 0x206478: 0x34217f04
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32516));
    // 0x20647c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x206480: 0x3c01bd24
    SET_GPR_U32(ctx, 1, ((uint32_t)48420 << 16));
    // 0x206484: 0x34211146
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4422));
    // 0x206488: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x20648c: 0x46031542
    ctx->f[21] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x206490: 0x3c013d9d
    SET_GPR_U32(ctx, 1, ((uint32_t)15773 << 16));
    // 0x206494: 0x3421c62e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 50734));
    // 0x206498: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x20649c: 0x3c01bf30
    SET_GPR_U32(ctx, 1, ((uint32_t)48944 << 16));
    // 0x2064a0: 0x34213361
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13153));
    // 0x2064a4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x2064a8: 0x3c013e4e
    SET_GPR_U32(ctx, 1, ((uint32_t)15950 << 16));
    // 0x2064ac: 0x34210aa8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2728));
    // 0x2064b0: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x2064b4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x2064b8: 0x3c014001
    SET_GPR_U32(ctx, 1, ((uint32_t)16385 << 16));
    // 0x2064bc: 0x3421572d
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 22317));
    // 0x2064c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2064c4: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x2064c8: 0x3c01bea6
    SET_GPR_U32(ctx, 1, ((uint32_t)48806 << 16));
    // 0x2064cc: 0x3421b090
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 45200));
    // 0x2064d0: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x2064d4: 0x3c01c019
    SET_GPR_U32(ctx, 1, ((uint32_t)49177 << 16));
    // 0x2064d8: 0x3421d139
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 53561));
    // 0x2064dc: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x2064e0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x2064e4: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x2064e8: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x2064ec: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x2064f0: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x2064f4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x2064f8: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x2064fc: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206500: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x206504: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x206508: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x20650c: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206510: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x206514: 0x46050840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[5]);
    // 0x206518: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x20651c: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206520: 0x46090000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[9]);
    // 0x206524: 0x460a0d80
    ctx->f[22] = FPU_ADD_S(ctx->f[1], ctx->f[10]);
    // 0x206528: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x20652c: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x206530: 0xc08201a
    SET_GPR_U32(ctx, 31, 0x206538);
    ctx->f[20] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    fn___ieee754_sqrtf(rdram, ctx, runtime); return;
}


// Function: entry_206538
// Address: 0x206538 - 0x206598

void entry_206538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206538) {
        switch (ctx->pc) {
            case 0x206578: ctx->pc = 0; goto label_206578;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206538: 0x46000286
    ctx->f[10] = FPU_MOV_S(ctx->f[0]);
    // 0x20653c: 0x3c0133a2
    SET_GPR_U32(ctx, 1, ((uint32_t)13218 << 16));
    // 0x206540: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x206544: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x206548: 0x0
    // NOP
    // 0x20654c: 0x0
    // NOP
    // 0x206550: 0x4616a303
    if (ctx->f[22] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[12] = ctx->f[20] / ctx->f[22];
    // 0x206554: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x206558: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x20655c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x206560: 0x460a6002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[10]);
    // 0x206564: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x206568: 0x46005000
    ctx->f[0] = FPU_ADD_S(ctx->f[10], ctx->f[0]);
    // 0x20656c: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x206570: 0x1000004f
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2066B0; return;
    }
label_206578:
    // 0x206578: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x20657c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x206580: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x206584: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x206588: 0x460ba001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[11]);
    // 0x20658c: 0x46010542
    ctx->f[21] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x206590: 0xc08201a
    SET_GPR_U32(ctx, 31, 0x206598);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    fn___ieee754_sqrtf(rdram, ctx, runtime); return;
}


// Function: entry_206598
// Address: 0x206598 - 0x2066c8

void entry_206598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206598) {
        switch (ctx->pc) {
            case 0x2066b0: ctx->pc = 0; goto label_2066b0;
            case 0x2066b4: ctx->pc = 0; goto label_2066b4;
            case 0x2066b8: ctx->pc = 0; goto label_2066b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206598: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x20659c: 0x44835000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 3);
    // 0x2065a0: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x2065a4: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x2065a8: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2065ac: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x2065b0: 0x46000082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x2065b4: 0x3c013811
    SET_GPR_U32(ctx, 1, ((uint32_t)14353 << 16));
    // 0x2065b8: 0x3421ef08
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61192));
    // 0x2065bc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2065c0: 0x3c013a4f
    SET_GPR_U32(ctx, 1, ((uint32_t)14927 << 16));
    // 0x2065c4: 0x34217f04
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32516));
    // 0x2065c8: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x2065cc: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x2065d0: 0x3c013d9d
    SET_GPR_U32(ctx, 1, ((uint32_t)15773 << 16));
    // 0x2065d4: 0x3421c62e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 50734));
    // 0x2065d8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2065dc: 0x3c01bd24
    SET_GPR_U32(ctx, 1, ((uint32_t)48420 << 16));
    // 0x2065e0: 0x34211146
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4422));
    // 0x2065e4: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x2065e8: 0x4602a881
    ctx->f[2] = FPU_SUB_S(ctx->f[21], ctx->f[2]);
    // 0x2065ec: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x2065f0: 0x3c01bf30
    SET_GPR_U32(ctx, 1, ((uint32_t)48944 << 16));
    // 0x2065f4: 0x34213361
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13153));
    // 0x2065f8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x2065fc: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x206600: 0x3c01bea6
    SET_GPR_U32(ctx, 1, ((uint32_t)48806 << 16));
    // 0x206604: 0x3421b090
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 45200));
    // 0x206608: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x20660c: 0x44833000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 3);
    // 0x206610: 0x46050840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[5]);
    // 0x206614: 0x3c014001
    SET_GPR_U32(ctx, 1, ((uint32_t)16385 << 16));
    // 0x206618: 0x3421572d
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 22317));
    // 0x20661c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x206620: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x206624: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x206628: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x20662c: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x206630: 0x460650c0
    ctx->f[3] = FPU_ADD_S(ctx->f[10], ctx->f[6]);
    // 0x206634: 0x3c013e4e
    SET_GPR_U32(ctx, 1, ((uint32_t)15950 << 16));
    // 0x206638: 0x34210aa8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2728));
    // 0x20663c: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x206640: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x206644: 0x46090000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[9]);
    // 0x206648: 0x0
    // NOP
    // 0x20664c: 0x0
    // NOP
    // 0x206650: 0x46031083
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[3];
    // 0x206654: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x206658: 0x3c01c019
    SET_GPR_U32(ctx, 1, ((uint32_t)49177 << 16));
    // 0x20665c: 0x3421d139
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 53561));
    // 0x206660: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x206664: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x206668: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x20666c: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x206670: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x206674: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x206678: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x20667c: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x206680: 0x46140d80
    ctx->f[22] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
    // 0x206684: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x206688: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x20668c: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x206690: 0x4600ad02
    ctx->f[20] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x206694: 0x0
    // NOP
    // 0x206698: 0x0
    // NOP
    // 0x20669c: 0x4616a303
    if (ctx->f[22] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[12] = ctx->f[20] / ctx->f[22];
    // 0x2066a0: 0x460a6002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[10]);
    // 0x2066a4: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x2066a8: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x2066ac: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
label_2066b0:
    // 0x2066b0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_2066b4:
    // 0x2066b4: 0xc7b60020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
label_2066b8:
    // 0x2066b8: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x2066bc: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x2066c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___ieee754_asinf
// Address: 0x2066c8 - 0x206888

void entry_206888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206888: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x20688c: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x206890: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x206894: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x206898: 0x46005201
    ctx->f[8] = FPU_SUB_S(ctx->f[10], ctx->f[0]);
    // 0x20689c: 0x3c013a4f
    SET_GPR_U32(ctx, 1, ((uint32_t)14927 << 16));
    // 0x2068a0: 0x34217f04
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32516));
    // 0x2068a4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x2068a8: 0x3c013811
    SET_GPR_U32(ctx, 1, ((uint32_t)14353 << 16));
    // 0x2068ac: 0x3421ef08
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61192));
    // 0x2068b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2068b4: 0x3c01bd24
    SET_GPR_U32(ctx, 1, ((uint32_t)48420 << 16));
    // 0x2068b8: 0x34211146
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4422));
    // 0x2068bc: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x2068c0: 0x46024502
    ctx->f[20] = FPU_MUL_S(ctx->f[8], ctx->f[2]);
    // 0x2068c4: 0x3c013d9d
    SET_GPR_U32(ctx, 1, ((uint32_t)15773 << 16));
    // 0x2068c8: 0x3421c62e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 50734));
    // 0x2068cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2068d0: 0x3c01bf30
    SET_GPR_U32(ctx, 1, ((uint32_t)48944 << 16));
    // 0x2068d4: 0x34213361
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13153));
    // 0x2068d8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x2068dc: 0x3c013e4e
    SET_GPR_U32(ctx, 1, ((uint32_t)15950 << 16));
    // 0x2068e0: 0x34210aa8
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2728));
    // 0x2068e4: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x2068e8: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x2068ec: 0x3c014001
    SET_GPR_U32(ctx, 1, ((uint32_t)16385 << 16));
    // 0x2068f0: 0x3421572d
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 22317));
    // 0x2068f4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2068f8: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x2068fc: 0x3c01bea6
    SET_GPR_U32(ctx, 1, ((uint32_t)48806 << 16));
    // 0x206900: 0x3421b090
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 45200));
    // 0x206904: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x206908: 0x3c01c019
    SET_GPR_U32(ctx, 1, ((uint32_t)49177 << 16));
    // 0x20690c: 0x3421d139
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 53561));
    // 0x206910: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x206914: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x206918: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x20691c: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x206920: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x206924: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x206928: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x20692c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x206930: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x206934: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x206938: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x20693c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x206940: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x206944: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x206948: 0x46050840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[5]);
    // 0x20694c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x206950: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x206954: 0x46090000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[9]);
    // 0x206958: 0x460a0d80
    ctx->f[22] = FPU_ADD_S(ctx->f[1], ctx->f[10]);
    // 0x20695c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x206960: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x206964: 0xc08201a
    SET_GPR_U32(ctx, 31, 0x20696c);
    ctx->f[21] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    fn___ieee754_sqrtf(rdram, ctx, runtime); return;
}


// Function: entry_20696c
// Address: 0x20696c - 0x206a68

void entry_20696c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20696c) {
        switch (ctx->pc) {
            case 0x2069bc: ctx->pc = 0; goto label_2069bc;
            case 0x206a38: ctx->pc = 0; goto label_206a38;
            case 0x206a44: ctx->pc = 0; goto label_206a44;
            case 0x206a4c: ctx->pc = 0; goto label_206a4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20696c: 0x3c023f79
    SET_GPR_U32(ctx, 2, ((uint32_t)16249 << 16));
    // 0x206970: 0x34429999
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 39321));
    // 0x206974: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x206978: 0x10400010
    ctx->f[7] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2069bc;
    }
    // 0x206980: 0x0
    // NOP
    // 0x206984: 0x0
    // NOP
    // 0x206988: 0x4616aa03
    if (ctx->f[22] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[8] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[8] = ctx->f[21] / ctx->f[22];
    // 0x20698c: 0x3c0133a2
    SET_GPR_U32(ctx, 1, ((uint32_t)13218 << 16));
    // 0x206990: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x206994: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206998: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x20699c: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x2069a0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x2069a4: 0x46083842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[8]);
    // 0x2069a8: 0x46013840
    ctx->f[1] = FPU_ADD_S(ctx->f[7], ctx->f[1]);
    // 0x2069ac: 0x46010840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    // 0x2069b0: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x2069b4: 0x10000020
    ctx->f[20] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206a38;
    }
label_2069bc:
    // 0x2069bc: 0x44023800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[7]);
    // 0x2069c0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2069c4: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x2069c8: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x2069cc: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2069d0: 0x44834000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 3);
    // 0x2069d4: 0x46084002
    ctx->f[0] = FPU_MUL_S(ctx->f[8], ctx->f[8]);
    // 0x2069d8: 0x3c0133a2
    SET_GPR_U32(ctx, 1, ((uint32_t)13218 << 16));
    // 0x2069dc: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x2069e0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2069e4: 0x3c013f49
    SET_GPR_U32(ctx, 1, ((uint32_t)16201 << 16));
    // 0x2069e8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x2069ec: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x2069f0: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x2069f4: 0x46083900
    ctx->f[4] = FPU_ADD_S(ctx->f[7], ctx->f[8]);
    // 0x2069f8: 0x0
    // NOP
    // 0x2069fc: 0x0
    // NOP
    // 0x206a00: 0x4616a943
    if (ctx->f[22] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[5] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[5] = ctx->f[21] / ctx->f[22];
    // 0x206a04: 0x46073840
    ctx->f[1] = FPU_ADD_S(ctx->f[7], ctx->f[7]);
    // 0x206a08: 0x0
    // NOP
    // 0x206a0c: 0x0
    // NOP
    // 0x206a10: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x206a14: 0x46084080
    ctx->f[2] = FPU_ADD_S(ctx->f[8], ctx->f[8]);
    // 0x206a18: 0x46050842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
    // 0x206a1c: 0x46023581
    ctx->f[22] = FPU_SUB_S(ctx->f[6], ctx->f[2]);
    // 0x206a20: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x206a24: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x206a28: 0x46030d41
    ctx->f[21] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x206a2c: 0x4616a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[22]);
    // 0x206a30: 0x46003501
    ctx->f[20] = FPU_SUB_S(ctx->f[6], ctx->f[0]);
    // 0x206a34: 0x0
    // NOP
label_206a38:
    // 0x206a38: 0x1e200002
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    if (GPR_S32(ctx, 17) > 0) {
        goto label_206a44;
    }
    // 0x206a40: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
label_206a44:
    // 0x206a44: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x206a48: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_206a4c:
    // 0x206a4c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x206a50: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x206a54: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x206a58: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x206a5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x206a64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x206a68; return;
}


// Function: fn___ieee754_atan2f
// Address: 0x206a68 - 0x206acc

void entry_206acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206acc) {
        switch (ctx->pc) {
            case 0x206ad4: ctx->pc = 0; goto label_206ad4;
            case 0x206b08: ctx->pc = 0; goto label_206b08;
            case 0x206b10: ctx->pc = 0; goto label_206b10;
            case 0x206b18: ctx->pc = 0; goto label_206b18;
            case 0x206b40: ctx->pc = 0; goto label_206b40;
            case 0x206b70: ctx->pc = 0; goto label_206b70;
            case 0x206b88: ctx->pc = 0; goto label_206b88;
            case 0x206b9c: ctx->pc = 0; goto label_206b9c;
            case 0x206bb0: ctx->pc = 0; goto label_206bb0;
            case 0x206bc4: ctx->pc = 0; goto label_206bc4;
            case 0x206bd8: ctx->pc = 0; goto label_206bd8;
            case 0x206bf8: ctx->pc = 0; goto label_206bf8;
            case 0x206c10: ctx->pc = 0; goto label_206c10;
            case 0x206c1c: ctx->pc = 0; goto label_206c1c;
            case 0x206c28: ctx->pc = 0; goto label_206c28;
            case 0x206c3c: ctx->pc = 0; goto label_206c3c;
            case 0x206c50: ctx->pc = 0; goto label_206c50;
            case 0x206c78: ctx->pc = 0; goto label_206c78;
            case 0x206c88: ctx->pc = 0; goto label_206c88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206acc: 0x1000009d
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206ad4:
    // 0x206ad4: 0x61fc2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 6), 31));
    // 0x206ad8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x206adc: 0x1480000c
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_206b10;
    }
    // 0x206ae4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x206ae8: 0x1202004f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206c28;
    }
    // 0x206af0: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_206b08;
    }
    // 0x206af8: 0x12020050
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206c3c;
    }
    // 0x206b00: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206b10;
    }
label_206b08:
    // 0x206b08: 0x601008e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x206D44; return;
    }
label_206b10:
    // 0x206b10: 0x14a0000b
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_206b40;
    }
label_206b18:
    // 0x206b18: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x206b1c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x206b20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206b24: 0x4c10087
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_S32(ctx, 6) >= 0) {
        ctx->pc = 0x206D44; return;
    }
    // 0x206b2c: 0x3c01bfc9
    SET_GPR_U32(ctx, 1, ((uint32_t)49097 << 16));
    // 0x206b30: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x206b34: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206b38: 0x10000083
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D48; return;
    }
label_206b40:
    // 0x206b40: 0x14a20043
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_206c50;
    }
    // 0x206b48: 0x14850023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 5)) {
        goto label_206bd8;
    }
    // 0x206b50: 0x12020012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206b9c;
    }
    // 0x206b58: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_206b70;
    }
    // 0x206b60: 0x12000009
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_206b88;
    }
    // 0x206b68: 0x10000039
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206c50;
    }
label_206b70:
    // 0x206b70: 0x1202000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206bb0;
    }
    // 0x206b78: 0x12020012
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206bc4;
    }
    // 0x206b80: 0x10000033
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206c50;
    }
label_206b88:
    // 0x206b88: 0x3c013f49
    SET_GPR_U32(ctx, 1, ((uint32_t)16201 << 16));
    // 0x206b8c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x206b90: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206b94: 0x1000006b
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206b9c:
    // 0x206b9c: 0x3c01bf49
    SET_GPR_U32(ctx, 1, ((uint32_t)48969 << 16));
    // 0x206ba0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x206ba4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206ba8: 0x10000066
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206bb0:
    // 0x206bb0: 0x3c014016
    SET_GPR_U32(ctx, 1, ((uint32_t)16406 << 16));
    // 0x206bb4: 0x3421cbe4
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52196));
    // 0x206bb8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206bbc: 0x10000061
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206bc4:
    // 0x206bc4: 0x3c01c016
    SET_GPR_U32(ctx, 1, ((uint32_t)49174 << 16));
    // 0x206bc8: 0x3421cbe4
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52196));
    // 0x206bcc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206bd0: 0x1000005c
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206bd8:
    // 0x206bd8: 0x12020010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206c1c;
    }
    // 0x206be0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_206bf8;
    }
    // 0x206be8: 0x12000009
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_206c10;
    }
    // 0x206bf0: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206c50;
    }
label_206bf8:
    // 0x206bf8: 0x1202000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206c28;
    }
    // 0x206c00: 0x1202000e
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206c3c;
    }
    // 0x206c08: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206c50;
    }
label_206c10:
    // 0x206c10: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x206c14: 0x1000004b
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206c1c:
    // 0x206c1c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x206c20: 0x10000047
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294965748)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D40; return;
    }
label_206c28:
    // 0x206c28: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x206c2c: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x206c30: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206c34: 0x10000043
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206c3c:
    // 0x206c3c: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x206c40: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x206c44: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206c48: 0x1000003e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206D44; return;
    }
label_206c50:
    // 0x206c50: 0x1082ffb1
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_206b18;
    }
    // 0x206c58: 0x215c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 23));
    // 0x206c5c: 0x2843003d
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), 61));
    // 0x206c60: 0x14600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_206c78;
    }
    // 0x206c68: 0x3c033fc9
    SET_GPR_U32(ctx, 3, ((uint32_t)16329 << 16));
    // 0x206c6c: 0x34630fdc
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 4060));
    // 0x206c70: 0x1000000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x206CB0; return;
    }
label_206c78:
    // 0x206c78: 0x4e10003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4294967236));
    if (GPR_S32(ctx, 7) >= 0) {
        goto label_206c88;
    }
    // 0x206c80: 0x1440000a
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x206CAC; return;
    }
label_206c88:
    // 0x206c88: 0x44881000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 8);
    // 0x206c8c: 0x0
    // NOP
    // 0x206c90: 0x0
    // NOP
    // 0x206c94: 0x46020303
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[2];
    // 0x206c98: 0xc0814be
    SET_GPR_U32(ctx, 31, 0x206ca0);
    fabsf(rdram, ctx, runtime); return;
}


// Function: entry_206ca0
// Address: 0x206ca0 - 0x206ca8

void entry_206ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x206ca0: 0xc0813da
    SET_GPR_U32(ctx, 31, 0x206ca8);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    atanf(rdram, ctx, runtime); return;
}


// Function: entry_206ca8
// Address: 0x206ca8 - 0x206d50

void entry_206ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x206ca8) {
        switch (ctx->pc) {
            case 0x206cac: ctx->pc = 0; goto label_206cac;
            case 0x206cb0: ctx->pc = 0; goto label_206cb0;
            case 0x206cd0: ctx->pc = 0; goto label_206cd0;
            case 0x206ce0: ctx->pc = 0; goto label_206ce0;
            case 0x206ce8: ctx->pc = 0; goto label_206ce8;
            case 0x206cf4: ctx->pc = 0; goto label_206cf4;
            case 0x206d1c: ctx->pc = 0; goto label_206d1c;
            case 0x206d40: ctx->pc = 0; goto label_206d40;
            case 0x206d44: ctx->pc = 0; goto label_206d44;
            case 0x206d48: ctx->pc = 0; goto label_206d48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x206ca8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
label_206cac:
    // 0x206cac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_206cb0:
    // 0x206cb0: 0x1202000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206ce0;
    }
    // 0x206cb8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_206cd0;
    }
    // 0x206cc0: 0x12000009
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_206ce8;
    }
    // 0x206cc8: 0x10000014
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206d1c;
    }
label_206cd0:
    // 0x206cd0: 0x12020008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_206cf4;
    }
    // 0x206cd8: 0x10000010
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206d1c;
    }
label_206ce0:
    // 0x206ce0: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x206ce4: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_206ce8:
    // 0x206ce8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x206cec: 0x10000015
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206d44;
    }
label_206cf4:
    // 0x206cf4: 0x3c013422
    SET_GPR_U32(ctx, 1, ((uint32_t)13346 << 16));
    // 0x206cf8: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x206cfc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206d00: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x206d04: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x206d08: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x206d0c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x206d10: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x206d14: 0x1000000a
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_206d40;
    }
label_206d1c:
    // 0x206d1c: 0x3c013422
    SET_GPR_U32(ctx, 1, ((uint32_t)13346 << 16));
    // 0x206d20: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x206d24: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x206d28: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x206d2c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x206d30: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x206d34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x206d38: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x206d3c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_206d40:
    // 0x206d40: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_206d44:
    // 0x206d44: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_206d48:
    // 0x206d48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___ieee754_fmodf
// Address: 0x206d50 - 0x206fa0

void FUN_002072c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2072c8) {
        switch (ctx->pc) {
            case 0x207310: ctx->pc = 0; goto label_207310;
            case 0x207338: ctx->pc = 0; goto label_207338;
            case 0x207350: ctx->pc = 0; goto label_207350;
            case 0x207370: ctx->pc = 0; goto label_207370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2072c8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x2072cc: 0x44036000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[12]);
    // 0x2072d0: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2072d4: 0xe7b40010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x2072d8: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x2072dc: 0x3c02007f
    SET_GPR_U32(ctx, 2, ((uint32_t)127 << 16));
    // 0x2072e0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2072e4: 0x46102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 6)));
    // 0x2072e8: 0x14400019
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207350;
    }
    // 0x2072f0: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x2072f4: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2072f8: 0xc21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x2072fc: 0x14400004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207310;
    }
    // 0x207304: 0x10000038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294965836)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2073E8; return;
    }
    // 0x20730c: 0x0
    // NOP
label_207310:
    // 0x207310: 0x4c10009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967271));
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_207338;
    }
    // 0x207318: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x20731c: 0x46000041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[0]);
    // 0x207320: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x207324: 0x0
    // NOP
    // 0x207328: 0x0
    // NOP
    // 0x20732c: 0x46000803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
    // 0x207330: 0x1000002e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2073EC; return;
    }
label_207338:
    // 0x207338: 0x3c014c00
    SET_GPR_U32(ctx, 1, ((uint32_t)19456 << 16));
    // 0x20733c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207340: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x207344: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x207348: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x20734c: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_207350:
    // 0x207350: 0x3c027f7f
    SET_GPR_U32(ctx, 2, ((uint32_t)32639 << 16));
    // 0x207354: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x207358: 0x46102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 6)));
    // 0x20735c: 0x10400004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967169));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207370;
    }
    // 0x207364: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x207368: 0x1000001f
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2073E8; return;
    }
label_207370:
    // 0x207370: 0x615c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 6), 23));
    // 0x207374: 0x822821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x207378: 0x2403007f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 127));
    // 0x20737c: 0x527c2
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 5), 31));
    // 0x207380: 0x3c02007f
    SET_GPR_U32(ctx, 2, ((uint32_t)127 << 16));
    // 0x207384: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x207388: 0x641823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x20738c: 0x4485a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 5);
    // 0x207390: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x207394: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x207398: 0xc21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x20739c: 0x31dc0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 23));
    // 0x2073a0: 0x431825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x2073a4: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x2073a8: 0xc081be8
    SET_GPR_U32(ctx, 31, 0x2073b0);
    fn___ieee754_logf(rdram, ctx, runtime); return;
}


// Function: entry_2073b0
// Address: 0x2073b0 - 0x2073f8

void entry_2073b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2073b0) {
        switch (ctx->pc) {
            case 0x2073e8: ctx->pc = 0; goto label_2073e8;
            case 0x2073ec: ctx->pc = 0; goto label_2073ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2073b0: 0x3c013554
    SET_GPR_U32(ctx, 1, ((uint32_t)13652 << 16));
    // 0x2073b4: 0x342127db
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 10203));
    // 0x2073b8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2073bc: 0x3c013ede
    SET_GPR_U32(ctx, 1, ((uint32_t)16094 << 16));
    // 0x2073c0: 0x34215bd9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 23513));
    // 0x2073c4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2073c8: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x2073cc: 0x3c013e9a
    SET_GPR_U32(ctx, 1, ((uint32_t)16026 << 16));
    // 0x2073d0: 0x34212080
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8320));
    // 0x2073d4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x2073d8: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x2073dc: 0x4602a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[2]);
    // 0x2073e0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x2073e4: 0x46140800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
label_2073e8:
    // 0x2073e8: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_2073ec:
    // 0x2073ec: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x2073f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_002073f8
// Address: 0x2073f8 - 0x207574

void FUN_002073f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2073f8) {
        switch (ctx->pc) {
            case 0x207458: ctx->pc = 0; goto label_207458;
            case 0x20747c: ctx->pc = 0; goto label_20747c;
            case 0x2074a0: ctx->pc = 0; goto label_2074a0;
            case 0x2074d4: ctx->pc = 0; goto label_2074d4;
            case 0x2074d8: ctx->pc = 0; goto label_2074d8;
            case 0x2074f0: ctx->pc = 0; goto label_2074f0;
            case 0x20750c: ctx->pc = 0; goto label_20750c;
            case 0x207520: ctx->pc = 0; goto label_207520;
            case 0x20754c: ctx->pc = 0; goto label_20754c;
            case 0x20755c: ctx->pc = 0; goto label_20755c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2073f8: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x2073fc: 0xe7b50068
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x207400: 0xe7b40060
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x207404: 0x46006d46
    ctx->f[21] = FPU_MOV_S(ctx->f[13]);
    // 0x207408: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x20740c: 0xffbf0050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 31));
    // 0x207410: 0xffb40040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 20));
    // 0x207414: 0xffb30030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 19));
    // 0x207418: 0xffb20020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 18));
    // 0x20741c: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x207420: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x207424: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x207428: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20742c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x207430: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x207434: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x207438: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x20743c: 0x2428824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x207440: 0x16200005
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_207458;
    }
    // 0x207448: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x20744c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207450: 0x10000203
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_207458:
    // 0x207458: 0x3c037f80
    SET_GPR_U32(ctx, 3, ((uint32_t)32640 << 16));
    // 0x20745c: 0x70102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 16)));
    // 0x207460: 0x544001fe
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
        ctx->pc = 0x207C5C; return;
    }
    // 0x207468: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x20746c: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20747c;
    }
    // 0x207474: 0x100001f9
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[21]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_20747c:
    // 0x20747c: 0x6610015
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) >= 0) {
        goto label_2074d4;
    }
    // 0x207484: 0x3c024b7f
    SET_GPR_U32(ctx, 2, ((uint32_t)19327 << 16));
    // 0x207488: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x20748c: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x207490: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)16255 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2074a0;
    }
    // 0x207498: 0x1000000e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2074d4;
    }
label_2074a0:
    // 0x2074a0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x2074a4: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x2074a8: 0x1040000a
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 17), 23));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2074d4;
    }
    // 0x2074b0: 0x24020096
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 150));
    // 0x2074b4: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x2074b8: 0x512807
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 17), GPR_U32(ctx, 2) & 0x1F));
    // 0x2074bc: 0x451004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), GPR_U32(ctx, 2) & 0x1F));
    // 0x2074c0: 0x14510005
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_2074d8;
    }
    // 0x2074c8: 0x30a30001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), 1));
    // 0x2074cc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x2074d0: 0x43a023
    SET_GPR_U32(ctx, 20, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_2074d4:
    // 0x2074d4: 0x3c027f80
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
label_2074d8:
    // 0x2074d8: 0x16220011
    SET_GPR_U32(ctx, 2, ((uint32_t)16256 << 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_207520;
    }
    // 0x2074e0: 0x16020003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_2074f0;
    }
    // 0x2074e8: 0x100001dc
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[21]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_2074f0:
    // 0x2074f0: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20750c;
    }
    // 0x2074f8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2074fc: 0x64301d7
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->f[0] = FPU_MOV_S(ctx->f[21]);
        ctx->pc = 0x207C5C; return;
    }
    // 0x207504: 0x100001d6
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_20750c:
    // 0x20750c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x207510: 0x64201d2
    if (GPR_S32(ctx, 18) < 0) {
        ctx->f[0] = FPU_NEG_S(ctx->f[21]);
        ctx->pc = 0x207C5C; return;
    }
    // 0x207518: 0x100001d1
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_207520:
    // 0x207520: 0x5622000a
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
        goto label_20754c;
    }
    // 0x207528: 0x64101cc
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x207C5C; return;
    }
    // 0x207530: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x207534: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207538: 0x0
    // NOP
    // 0x20753c: 0x0
    // NOP
    // 0x207540: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x207544: 0x100001c6
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_20754c:
    // 0x20754c: 0x16420003
    SET_GPR_U32(ctx, 2, ((uint32_t)16128 << 16));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        goto label_20755c;
    }
    // 0x207554: 0x100001c1
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_20755c:
    // 0x20755c: 0x16420007
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20757C; return;
    }
    // 0x207564: 0x6600005
    if (GPR_S32(ctx, 19) < 0) {
        ctx->pc = 0x20757C; return;
    }
    // 0x20756c: 0xc08201a
    SET_GPR_U32(ctx, 31, 0x207574);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fn___ieee754_sqrtf(rdram, ctx, runtime); return;
}


// Function: entry_207574
// Address: 0x207574 - 0x207584

void entry_207574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x207574) {
        switch (ctx->pc) {
            case 0x20757c: ctx->pc = 0; goto label_20757c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x207574: 0x100001ba
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_20757c:
    // 0x20757c: 0xc0814be
    SET_GPR_U32(ctx, 31, 0x207584);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fabsf(rdram, ctx, runtime); return;
}


// Function: entry_207584
// Address: 0x207584 - 0x207c44

void entry_207584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x207584) {
        switch (ctx->pc) {
            case 0x2075a4: ctx->pc = 0; goto label_2075a4;
            case 0x2075c0: ctx->pc = 0; goto label_2075c0;
            case 0x2075f4: ctx->pc = 0; goto label_2075f4;
            case 0x2075fc: ctx->pc = 0; goto label_2075fc;
            case 0x207604: ctx->pc = 0; goto label_207604;
            case 0x20762c: ctx->pc = 0; goto label_20762c;
            case 0x207650: ctx->pc = 0; goto label_207650;
            case 0x207658: ctx->pc = 0; goto label_207658;
            case 0x207670: ctx->pc = 0; goto label_207670;
            case 0x20767c: ctx->pc = 0; goto label_20767c;
            case 0x207718: ctx->pc = 0; goto label_207718;
            case 0x207740: ctx->pc = 0; goto label_207740;
            case 0x20776c: ctx->pc = 0; goto label_20776c;
            case 0x207790: ctx->pc = 0; goto label_207790;
            case 0x207988: ctx->pc = 0; goto label_207988;
            case 0x2079ac: ctx->pc = 0; goto label_2079ac;
            case 0x207a10: ctx->pc = 0; goto label_207a10;
            case 0x207a50: ctx->pc = 0; goto label_207a50;
            case 0x207a88: ctx->pc = 0; goto label_207a88;
            case 0x207a98: ctx->pc = 0; goto label_207a98;
            case 0x207aa0: ctx->pc = 0; goto label_207aa0;
            case 0x207aa4: ctx->pc = 0; goto label_207aa4;
            case 0x207b20: ctx->pc = 0; goto label_207b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x207584: 0x3c027f80
    SET_GPR_U32(ctx, 2, ((uint32_t)32640 << 16));
    // 0x207588: 0x12020006
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_2075a4;
    }
    // 0x207590: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_2075a4;
    }
    // 0x207598: 0x3c063f80
    SET_GPR_U32(ctx, 6, ((uint32_t)16256 << 16));
    // 0x20759c: 0x16060019
    SET_GPR_U32(ctx, 10, SRL32(GPR_U32(ctx, 19), 31));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 6)) {
        goto label_207604;
    }
label_2075a4:
    // 0x2075a4: 0x6410006
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_2075c0;
    }
    // 0x2075ac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2075b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2075b4: 0x0
    // NOP
    // 0x2075b8: 0x0
    // NOP
    // 0x2075bc: 0x460d0343
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[13];
label_2075c0:
    // 0x2075c0: 0x66101a6
    ctx->f[0] = FPU_MOV_S(ctx->f[13]);
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x207C5C; return;
    }
    // 0x2075c8: 0x3c02c080
    SET_GPR_U32(ctx, 2, ((uint32_t)49280 << 16));
    // 0x2075cc: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x2075d0: 0x541025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x2075d4: 0x14400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2075f4;
    }
    // 0x2075dc: 0x460d6801
    ctx->f[0] = FPU_SUB_S(ctx->f[13], ctx->f[13]);
    // 0x2075e0: 0x0
    // NOP
    // 0x2075e4: 0x0
    // NOP
    // 0x2075e8: 0x46000343
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[13] = ctx->f[0] / ctx->f[0];
    // 0x2075ec: 0x1000019b
    ctx->f[0] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_2075f4:
    // 0x2075f4: 0x52820001
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 2)) {
        ctx->f[13] = FPU_NEG_S(ctx->f[13]);
        goto label_2075fc;
    }
label_2075fc:
    // 0x2075fc: 0x10000197
    ctx->f[0] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_207604:
    // 0x207604: 0x2542ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 10), 4294967295));
    // 0x207608: 0x541025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x20760c: 0x14400007
    SET_GPR_U32(ctx, 2, ((uint32_t)19712 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20762c;
    }
    // 0x207614: 0x4614a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[20]);
    // 0x207618: 0x0
    // NOP
    // 0x20761c: 0x0
    // NOP
    // 0x207620: 0x46000003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[0];
    // 0x207624: 0x1000018e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_20762c:
    // 0x20762c: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x207630: 0x10400039
    SET_GPR_U32(ctx, 2, ((uint32_t)16255 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207718;
    }
    // 0x207638: 0x3442fff7
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65527));
    // 0x20763c: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207640: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)16256 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207658;
    }
    // 0x207648: 0x6410009
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_207670;
    }
label_207650:
    // 0x207650: 0x10000182
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294965972)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_207658:
    // 0x207658: 0x34420007
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 7));
    // 0x20765c: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207660: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20767c;
    }
    // 0x207668: 0x1e40fff9
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 18) > 0) {
        goto label_207650;
    }
label_207670:
    // 0x207670: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x207674: 0x1000017a
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C60; return;
    }
label_20767c:
    // 0x20767c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x207680: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207684: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x207688: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x20768c: 0x4601a301
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x207690: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x207694: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x207698: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x20769c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x2076a0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x2076a4: 0x3c0136ec
    SET_GPR_U32(ctx, 1, ((uint32_t)14060 << 16));
    // 0x2076a8: 0x3421a570
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 42352));
    // 0x2076ac: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x2076b0: 0x46026082
    ctx->f[2] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x2076b4: 0x3c013fb8
    SET_GPR_U32(ctx, 1, ((uint32_t)16312 << 16));
    // 0x2076b8: 0x3421aa3b
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43579));
    // 0x2076bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2076c0: 0x460c6182
    ctx->f[6] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
    // 0x2076c4: 0x3c013fb8
    SET_GPR_U32(ctx, 1, ((uint32_t)16312 << 16));
    // 0x2076c8: 0x3421aa00
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43520));
    // 0x2076cc: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x2076d0: 0x46046102
    ctx->f[4] = FPU_MUL_S(ctx->f[12], ctx->f[4]);
    // 0x2076d4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x2076d8: 0x460563c2
    ctx->f[15] = FPU_MUL_S(ctx->f[12], ctx->f[5]);
    // 0x2076dc: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x2076e0: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x2076e4: 0x46033242
    ctx->f[9] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x2076e8: 0x46014842
    ctx->f[1] = FPU_MUL_S(ctx->f[9], ctx->f[1]);
    // 0x2076ec: 0x46012381
    ctx->f[14] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x2076f0: 0x460e7800
    ctx->f[0] = FPU_ADD_S(ctx->f[15], ctx->f[14]);
    // 0x2076f4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x2076f8: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x2076fc: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x207700: 0x622024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x207704: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x207708: 0x460f0801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[15]);
    // 0x20770c: 0x1000009e
    ctx->f[1] = FPU_SUB_S(ctx->f[14], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207988;
    }
    // 0x207714: 0x0
    // NOP
label_207718:
    // 0x207718: 0x3c03007f
    SET_GPR_U32(ctx, 3, ((uint32_t)127 << 16));
    // 0x20771c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x207720: 0x70102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 16)));
    // 0x207724: 0x14400006
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207740;
    }
    // 0x20772c: 0x3c014b80
    SET_GPR_U32(ctx, 1, ((uint32_t)19328 << 16));
    // 0x207730: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207734: 0x2409ffe8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 4294967272));
    // 0x207738: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x20773c: 0x44106000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[12]);
label_207740:
    // 0x207740: 0x2032824
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x207744: 0x3c02001c
    SET_GPR_U32(ctx, 2, ((uint32_t)28 << 16));
    // 0x207748: 0x101dc3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 16), 23));
    // 0x20774c: 0x2524ff81
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 4294967169));
    // 0x207750: 0x3442c471
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 50289));
    // 0x207754: 0x834821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x207758: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x20775c: 0x14400003
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20776c;
    }
    // 0x207764: 0x1000000a
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207790;
    }
label_20776c:
    // 0x20776c: 0x3c02005d
    SET_GPR_U32(ctx, 2, ((uint32_t)93 << 16));
    // 0x207770: 0x3442b3d6
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 46038));
    // 0x207774: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x207778: 0x10400005
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207790;
    }
    // 0x207780: 0x3c02ff80
    SET_GPR_U32(ctx, 2, ((uint32_t)65408 << 16));
    // 0x207784: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x207788: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20778c: 0x25290001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
label_207790:
    // 0x207790: 0x44906000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 16);
    // 0x207794: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x207798: 0x83880
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 8), 2));
    // 0x20779c: 0x2442fa50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965840));
    // 0x2077a0: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x2077a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2077a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2077ac: 0xc4420000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    // 0x2077b0: 0x46026000
    ctx->f[0] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    // 0x2077b4: 0x460263c1
    ctx->f[15] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
    // 0x2077b8: 0x0
    // NOP
    // 0x2077bc: 0x0
    // NOP
    // 0x2077c0: 0x46000b83
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[14] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[14] = ctx->f[1] / ctx->f[0];
    // 0x2077c4: 0x460e7d02
    ctx->f[20] = FPU_MUL_S(ctx->f[15], ctx->f[14]);
    // 0x2077c8: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x2077cc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2077d0: 0x3c06ffff
    SET_GPR_U32(ctx, 6, ((uint32_t)65535 << 16));
    // 0x2077d4: 0x34c6f000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 61440));
    // 0x2077d8: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x2077dc: 0x44832800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 3);
    // 0x2077e0: 0x101843
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 16), 1));
    // 0x2077e4: 0x81540
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 8), 21));
    // 0x2077e8: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x2077ec: 0x3c050004
    SET_GPR_U32(ctx, 5, ((uint32_t)4 << 16));
    // 0x2077f0: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x2077f4: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x2077f8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2077fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x207800: 0x46020081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x207804: 0x3c013e53
    SET_GPR_U32(ctx, 1, ((uint32_t)15955 << 16));
    // 0x207808: 0x3421f142
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61762));
    // 0x20780c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207810: 0x3c013e6c
    SET_GPR_U32(ctx, 1, ((uint32_t)15980 << 16));
    // 0x207814: 0x34213255
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 12885));
    // 0x207818: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x20781c: 0x4614a2c2
    ctx->f[11] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x207820: 0x3c013e8b
    SET_GPR_U32(ctx, 1, ((uint32_t)16011 << 16));
    // 0x207824: 0x3421a305
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41733));
    // 0x207828: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x20782c: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x207830: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x207834: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x207838: 0x46026081
    ctx->f[2] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
    // 0x20783c: 0x44832000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 3);
    // 0x207840: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x207844: 0x3c013edb
    SET_GPR_U32(ctx, 1, ((uint32_t)16091 << 16));
    // 0x207848: 0x34216db7
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 28087));
    // 0x20784c: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x207850: 0x46042842
    ctx->f[1] = FPU_MUL_S(ctx->f[5], ctx->f[4]);
    // 0x207854: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x207858: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x20785c: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x207860: 0x46022882
    ctx->f[2] = FPU_MUL_S(ctx->f[5], ctx->f[2]);
    // 0x207864: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x207868: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x20786c: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x207870: 0x46017841
    ctx->f[1] = FPU_SUB_S(ctx->f[15], ctx->f[1]);
    // 0x207874: 0x460b5982
    ctx->f[6] = FPU_MUL_S(ctx->f[11], ctx->f[11]);
    // 0x207878: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x20787c: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x207880: 0x461428c0
    ctx->f[3] = FPU_ADD_S(ctx->f[5], ctx->f[20]);
    // 0x207884: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x207888: 0x46017042
    ctx->f[1] = FPU_MUL_S(ctx->f[14], ctx->f[1]);
    // 0x20788c: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x207890: 0x460308c2
    ctx->f[3] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x207894: 0x46090000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[9]);
    // 0x207898: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x20789c: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x2078a0: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x2078a4: 0x46052ac2
    ctx->f[11] = FPU_MUL_S(ctx->f[5], ctx->f[5]);
    // 0x2078a8: 0x460a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[10]);
    // 0x2078ac: 0x46045880
    ctx->f[2] = FPU_ADD_S(ctx->f[11], ctx->f[4]);
    // 0x2078b0: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x2078b4: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x2078b8: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x2078bc: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x2078c0: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x2078c4: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x2078c8: 0x46041101
    ctx->f[4] = FPU_SUB_S(ctx->f[2], ctx->f[4]);
    // 0x2078cc: 0x460b2101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[11]);
    // 0x2078d0: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x2078d4: 0x46022bc2
    ctx->f[15] = FPU_MUL_S(ctx->f[5], ctx->f[2]);
    // 0x2078d8: 0x46040081
    ctx->f[2] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x2078dc: 0x46141002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[20]);
    // 0x2078e0: 0x46000b80
    ctx->f[14] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x2078e4: 0x460e78c0
    ctx->f[3] = FPU_ADD_S(ctx->f[15], ctx->f[14]);
    // 0x2078e8: 0x44031800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[3]);
    // 0x2078ec: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x2078f0: 0x44833800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 3);
    // 0x2078f4: 0x460f3881
    ctx->f[2] = FPU_SUB_S(ctx->f[7], ctx->f[15]);
    // 0x2078f8: 0x3c01369d
    SET_GPR_U32(ctx, 1, ((uint32_t)13981 << 16));
    // 0x2078fc: 0x3421c3a0
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 50080));
    // 0x207900: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207904: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x207908: 0x3c013f76
    SET_GPR_U32(ctx, 1, ((uint32_t)16246 << 16));
    // 0x20790c: 0x3421384f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 14415));
    // 0x207910: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207914: 0x2442fa60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965856));
    // 0x207918: 0x46027181
    ctx->f[6] = FPU_SUB_S(ctx->f[14], ctx->f[2]);
    // 0x20791c: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x207920: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x207924: 0xc4440000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[4] = *(float*)&val; }
    // 0x207928: 0x3c013f76
    SET_GPR_U32(ctx, 1, ((uint32_t)16246 << 16));
    // 0x20792c: 0x34213800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 14336));
    // 0x207930: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207934: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x207938: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x20793c: 0x2442fa58
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965848));
    // 0x207940: 0x46023882
    ctx->f[2] = FPU_MUL_S(ctx->f[7], ctx->f[2]);
    // 0x207944: 0xe23821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x207948: 0xc4e30000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[3] = *(float*)&val; }
    // 0x20794c: 0x44896000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 9);
    // 0x207950: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x207954: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x207958: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x20795c: 0x46011000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x207960: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x207964: 0x460c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    // 0x207968: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x20796c: 0x662024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x207970: 0x44842000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 4);
    // 0x207974: 0x460c2001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[12]);
    // 0x207978: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x20797c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x207980: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x207984: 0x0
    // NOP
label_207988:
    // 0x207988: 0x2542ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 10), 4294967295));
    // 0x20798c: 0x2683ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x207990: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x207994: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x207998: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x20799c: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2079ac;
    }
    // 0x2079a4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x2079a8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
label_2079ac:
    // 0x2079ac: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x2079b0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2079b4: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x2079b8: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x2079bc: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2079c0: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x2079c4: 0x4602a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[2]);
    // 0x2079c8: 0x44841800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 4);
    // 0x2079cc: 0x4601a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x2079d0: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x2079d4: 0x460311c2
    ctx->f[7] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x2079d8: 0x46010180
    ctx->f[6] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x2079dc: 0x46073340
    ctx->f[13] = FPU_ADD_S(ctx->f[6], ctx->f[7]);
    // 0x2079e0: 0x44076800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[13]);
    // 0x2079e4: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x2079e8: 0x3c034300
    SET_GPR_U32(ctx, 3, ((uint32_t)17152 << 16));
    // 0x2079ec: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x2079f0: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207a10;
    }
    // 0x2079f8: 0x3c017149
    SET_GPR_U32(ctx, 1, ((uint32_t)29001 << 16));
    // 0x2079fc: 0x3421f2ca
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 62154));
    // 0x207a00: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207a04: 0x10000024
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207a98;
    }
    // 0x207a0c: 0x0
    // NOP
label_207a10:
    // 0x207a10: 0x14a3000f
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 3)) {
        goto label_207a50;
    }
    // 0x207a18: 0x3c013338
    SET_GPR_U32(ctx, 1, ((uint32_t)13112 << 16));
    // 0x207a1c: 0x3421aa3c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43580));
    // 0x207a20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207a24: 0x46076841
    ctx->f[1] = FPU_SUB_S(ctx->f[13], ctx->f[7]);
    // 0x207a28: 0x46003000
    ctx->f[0] = FPU_ADD_S(ctx->f[6], ctx->f[0]);
    // 0x207a2c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x207a30: 0x0
    // NOP
    // 0x207a34: 0x4500001a
    SET_GPR_U32(ctx, 6, ((uint32_t)32767 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_207aa0;
    }
    // 0x207a3c: 0x3c017149
    SET_GPR_U32(ctx, 1, ((uint32_t)29001 << 16));
    // 0x207a40: 0x3421f2ca
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 62154));
    // 0x207a44: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207a48: 0x10000013
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207a98;
    }
label_207a50:
    // 0x207a50: 0x3c034316
    SET_GPR_U32(ctx, 3, ((uint32_t)17174 << 16));
    // 0x207a54: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x207a58: 0xa21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x207a5c: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x207a60: 0x14600009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_207a88;
    }
    // 0x207a68: 0x3c02c316
    SET_GPR_U32(ctx, 2, ((uint32_t)49942 << 16));
    // 0x207a6c: 0x14a2000c
    SET_GPR_U32(ctx, 6, ((uint32_t)32767 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_207aa0;
    }
    // 0x207a74: 0x46076801
    ctx->f[0] = FPU_SUB_S(ctx->f[13], ctx->f[7]);
    // 0x207a78: 0x46003036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[6], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x207a7c: 0x0
    // NOP
    // 0x207a80: 0x45000008
    SET_GPR_U32(ctx, 3, ((uint32_t)16128 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_207aa4;
    }
label_207a88:
    // 0x207a88: 0x3c010da2
    SET_GPR_U32(ctx, 1, ((uint32_t)3490 << 16));
    // 0x207a8c: 0x34214260
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16992));
    // 0x207a90: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207a94: 0x4601a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
label_207a98:
    // 0x207a98: 0x10000070
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x207C5C; return;
    }
label_207aa0:
    // 0x207aa0: 0x3c033f00
    SET_GPR_U32(ctx, 3, ((uint32_t)16128 << 16));
label_207aa4:
    // 0x207aa4: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x207aa8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x207aac: 0xa61024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x207ab0: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x207ab4: 0x1060001a
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_207b20;
    }
    // 0x207abc: 0x2483ff82
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 4294967170));
    // 0x207ac0: 0x3c040080
    SET_GPR_U32(ctx, 4, ((uint32_t)128 << 16));
    // 0x207ac4: 0x641807
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 4), GPR_U32(ctx, 3) & 0x1F));
    // 0x207ac8: 0xa34821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x207acc: 0x1261024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    // 0x207ad0: 0x215c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 23));
    // 0x207ad4: 0x2448ff81
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4294967169));
    // 0x207ad8: 0x3c03007f
    SET_GPR_U32(ctx, 3, ((uint32_t)127 << 16));
    // 0x207adc: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x207ae0: 0x1031007
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 3), GPR_U32(ctx, 8) & 0x1F));
    // 0x207ae4: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x207ae8: 0x1221024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x207aec: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x207af0: 0x1231824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x207af4: 0x460c39c1
    ctx->f[7] = FPU_SUB_S(ctx->f[7], ctx->f[12]);
    // 0x207af8: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x207afc: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x207b00: 0x481023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x207b04: 0x434807
    SET_GPR_S32(ctx, 9, SRA32(GPR_S32(ctx, 3), GPR_U32(ctx, 2) & 0x1F));
    // 0x207b08: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x207b0c: 0x46073100
    ctx->f[4] = FPU_ADD_S(ctx->f[6], ctx->f[7]);
    // 0x207b10: 0x85202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x207b14: 0x91023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 9)));
    // 0x207b18: 0x44480a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 2));
    // 0x207b1c: 0x44072000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[4]);
label_207b20:
    // 0x207b20: 0xe0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x207b24: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x207b28: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x207b2c: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x207b30: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x207b34: 0x3c013f31
    SET_GPR_U32(ctx, 1, ((uint32_t)16177 << 16));
    // 0x207b38: 0x34217200
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29184));
    // 0x207b3c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x207b40: 0x3c013f31
    SET_GPR_U32(ctx, 1, ((uint32_t)16177 << 16));
    // 0x207b44: 0x34217218
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29208));
    // 0x207b48: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x207b4c: 0x46076041
    ctx->f[1] = FPU_SUB_S(ctx->f[12], ctx->f[7]);
    // 0x207b50: 0x3c0135bf
    SET_GPR_U32(ctx, 1, ((uint32_t)13759 << 16));
    // 0x207b54: 0x3421be8c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48780));
    // 0x207b58: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207b5c: 0x460363c2
    ctx->f[15] = FPU_MUL_S(ctx->f[12], ctx->f[3]);
    // 0x207b60: 0x3c013331
    SET_GPR_U32(ctx, 1, ((uint32_t)13105 << 16));
    // 0x207b64: 0x3421bb4c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47948));
    // 0x207b68: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207b6c: 0x46026082
    ctx->f[2] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x207b70: 0x3c01b5dd
    SET_GPR_U32(ctx, 1, ((uint32_t)46557 << 16));
    // 0x207b74: 0x3421ea0e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 59918));
    // 0x207b78: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x207b7c: 0x46013041
    ctx->f[1] = FPU_SUB_S(ctx->f[6], ctx->f[1]);
    // 0x207b80: 0x3c01bb36
    SET_GPR_U32(ctx, 1, ((uint32_t)47926 << 16));
    // 0x207b84: 0x34210b61
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2913));
    // 0x207b88: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x207b8c: 0x3c01388a
    SET_GPR_U32(ctx, 1, ((uint32_t)14474 << 16));
    // 0x207b90: 0x3421b355
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 45909));
    // 0x207b94: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x207b98: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x207b9c: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x207ba0: 0x44814000
    *(uint32_t*)&ctx->f[8] = GPR_U32(ctx, 1);
    // 0x207ba4: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x207ba8: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x207bac: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x207bb0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x207bb4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x207bb8: 0x46020b80
    ctx->f[14] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x207bbc: 0x460e7b40
    ctx->f[13] = FPU_ADD_S(ctx->f[15], ctx->f[14]);
    // 0x207bc0: 0x460d6b02
    ctx->f[12] = FPU_MUL_S(ctx->f[13], ctx->f[13]);
    // 0x207bc4: 0x460f6841
    ctx->f[1] = FPU_SUB_S(ctx->f[13], ctx->f[15]);
    // 0x207bc8: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x207bcc: 0x46017241
    ctx->f[9] = FPU_SUB_S(ctx->f[14], ctx->f[1]);
    // 0x207bd0: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x207bd4: 0x46096882
    ctx->f[2] = FPU_MUL_S(ctx->f[13], ctx->f[9]);
    // 0x207bd8: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x207bdc: 0x46024880
    ctx->f[2] = FPU_ADD_S(ctx->f[9], ctx->f[2]);
    // 0x207be0: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x207be4: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x207be8: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x207bec: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x207bf0: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x207bf4: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x207bf8: 0x46006801
    ctx->f[0] = FPU_SUB_S(ctx->f[13], ctx->f[0]);
    // 0x207bfc: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x207c00: 0x460300c1
    ctx->f[3] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x207c04: 0x46006802
    ctx->f[0] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x207c08: 0x0
    // NOP
    // 0x207c0c: 0x0
    // NOP
    // 0x207c10: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x207c14: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x207c18: 0x460d0041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x207c1c: 0x46012341
    ctx->f[13] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x207c20: 0x44026800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[13]);
    // 0x207c24: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x207c28: 0x915c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 23));
    // 0x207c2c: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x207c30: 0x51dc3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 5), 23));
    // 0x207c34: 0x1c600006
    ctx->f[12] = FPU_MOV_S(ctx->f[13]);
    if (GPR_S32(ctx, 3) > 0) {
        ctx->pc = 0x207C50; return;
    }
    // 0x207c3c: 0xc082498
    SET_GPR_U32(ctx, 31, 0x207c44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    scalbnf(rdram, ctx, runtime); return;
}


// Function: entry_207c44
// Address: 0x207c44 - 0x207c88

void entry_207c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x207c44) {
        switch (ctx->pc) {
            case 0x207c50: ctx->pc = 0; goto label_207c50;
            case 0x207c58: ctx->pc = 0; goto label_207c58;
            case 0x207c5c: ctx->pc = 0; goto label_207c5c;
            case 0x207c60: ctx->pc = 0; goto label_207c60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x207c44: 0x10000004
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207c58;
    }
    // 0x207c4c: 0x0
    // NOP
label_207c50:
    // 0x207c50: 0x44856800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 5);
    // 0x207c54: 0x0
    // NOP
label_207c58:
    // 0x207c58: 0x460da002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[13]);
label_207c5c:
    // 0x207c5c: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
label_207c60:
    // 0x207c60: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x207c64: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x207c68: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x207c6c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x207c70: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x207c74: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x207c78: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x207c7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x207c84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x207c88; return;
}


// Function: FUN_00207c88
// Address: 0x207c88 - 0x207dec

void FUN_00207c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x207c88) {
        switch (ctx->pc) {
            case 0x207cd8: ctx->pc = 0; goto label_207cd8;
            case 0x207d2c: ctx->pc = 0; goto label_207d2c;
            case 0x207d4c: ctx->pc = 0; goto label_207d4c;
            case 0x207d64: ctx->pc = 0; goto label_207d64;
            case 0x207d9c: ctx->pc = 0; goto label_207d9c;
            case 0x207dbc: ctx->pc = 0; goto label_207dbc;
            case 0x207dd4: ctx->pc = 0; goto label_207dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x207c88: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x207c8c: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x207c90: 0xffbf0040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 31));
    // 0x207c94: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x207c98: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x207c9c: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x207ca0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x207ca4: 0x3c037fff
    SET_GPR_U32(ctx, 3, ((uint32_t)32767 << 16));
    // 0x207ca8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x207cac: 0x3c023f49
    SET_GPR_U32(ctx, 2, ((uint32_t)16201 << 16));
    // 0x207cb0: 0x2438024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x207cb4: 0x34420fd8
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4056));
    // 0x207cb8: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207cbc: 0x14400006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207cd8;
    }
    // 0x207cc4: 0xe62c0000
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x207cc8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x207ccc: 0x100000e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x208050; return;
    }
    // 0x207cd4: 0x0
    // NOP
label_207cd8:
    // 0x207cd8: 0x3c024016
    SET_GPR_U32(ctx, 2, ((uint32_t)16406 << 16));
    // 0x207cdc: 0x3442cbe3
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 52195));
    // 0x207ce0: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207ce4: 0x1440003b
    SET_GPR_U32(ctx, 2, ((uint32_t)17225 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_207dd4;
    }
    // 0x207cec: 0x1a40001d
    SET_GPR_U32(ctx, 3, ((uint32_t)16329 << 16));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_207d64;
    }
    // 0x207cf4: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x207cf8: 0x34210f80
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 3968));
    // 0x207cfc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207d00: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x207d04: 0x3442fff0
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65520));
    // 0x207d08: 0x2021024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x207d0c: 0x34630fd0
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 4048));
    // 0x207d10: 0x10430006
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_207d2c;
    }
    // 0x207d18: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207d1c: 0x34214443
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17475));
    // 0x207d20: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207d24: 0x10000009
    ctx->f[1] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207d4c;
    }
label_207d2c:
    // 0x207d2c: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207d30: 0x34214400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17408));
    // 0x207d34: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207d38: 0x3c012e85
    SET_GPR_U32(ctx, 1, ((uint32_t)11909 << 16));
    // 0x207d3c: 0x3421a308
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41736));
    // 0x207d40: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207d44: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x207d48: 0x46026041
    ctx->f[1] = FPU_SUB_S(ctx->f[12], ctx->f[2]);
label_207d4c:
    // 0x207d4c: 0x46016001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x207d50: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x207d54: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x207d58: 0xe6200004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x207d5c: 0x100000bc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x208050; return;
    }
label_207d64:
    // 0x207d64: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x207d68: 0x34210f80
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 3968));
    // 0x207d6c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207d70: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x207d74: 0x3442fff0
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65520));
    // 0x207d78: 0x2021024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x207d7c: 0x34630fd0
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 4048));
    // 0x207d80: 0x10430006
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_207d9c;
    }
    // 0x207d88: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207d8c: 0x34214443
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17475));
    // 0x207d90: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207d94: 0x10000009
    ctx->f[1] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207dbc;
    }
label_207d9c:
    // 0x207d9c: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207da0: 0x34214400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17408));
    // 0x207da4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207da8: 0x3c012e85
    SET_GPR_U32(ctx, 1, ((uint32_t)11909 << 16));
    // 0x207dac: 0x3421a308
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41736));
    // 0x207db0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207db4: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x207db8: 0x46026040
    ctx->f[1] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
label_207dbc:
    // 0x207dbc: 0x46016001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x207dc0: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x207dc4: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x207dc8: 0xe6200004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x207dcc: 0x100000a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x208050; return;
    }
label_207dd4:
    // 0x207dd4: 0x34420f80
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 3968));
    // 0x207dd8: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207ddc: 0x1440005e
    SET_GPR_U32(ctx, 2, ((uint32_t)32639 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x207F58; return;
    }
    // 0x207de4: 0xc0814be
    SET_GPR_U32(ctx, 31, 0x207dec);
    fabsf(rdram, ctx, runtime); return;
}


// Function: entry_207dec
// Address: 0x207dec - 0x208024

void entry_207dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x207dec) {
        switch (ctx->pc) {
            case 0x207e7c: ctx->pc = 0; goto label_207e7c;
            case 0x207e80: ctx->pc = 0; goto label_207e80;
            case 0x207f38: ctx->pc = 0; goto label_207f38;
            case 0x207f3c: ctx->pc = 0; goto label_207f3c;
            case 0x207f58: ctx->pc = 0; goto label_207f58;
            case 0x207f78: ctx->pc = 0; goto label_207f78;
            case 0x207fa0: ctx->pc = 0; goto label_207fa0;
            case 0x207fe8: ctx->pc = 0; goto label_207fe8;
            case 0x20800c: ctx->pc = 0; goto label_20800c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x207dec: 0x3c013f22
    SET_GPR_U32(ctx, 1, ((uint32_t)16162 << 16));
    // 0x207df0: 0x3421f984
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63876));
    // 0x207df4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207df8: 0x46000146
    ctx->f[5] = FPU_MOV_S(ctx->f[0]);
    // 0x207dfc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x207e00: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207e04: 0x46012842
    ctx->f[1] = FPU_MUL_S(ctx->f[5], ctx->f[1]);
    // 0x207e08: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x207e0c: 0x34210f80
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 3968));
    // 0x207e10: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207e14: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207e18: 0x34214443
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17475));
    // 0x207e1c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x207e20: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x207e24: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x207e28: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x207e2c: 0x44853000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 5);
    // 0x207e30: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x207e34: 0x28a20020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 32));
    // 0x207e38: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x207e3c: 0x460330c2
    ctx->f[3] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x207e40: 0x1040000e
    ctx->f[4] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207e7c;
    }
    // 0x207e48: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x207e4c: 0x24a3ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x207e50: 0x2484fdf0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294966768));
    // 0x207e54: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x207e58: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x207e5c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x207e60: 0x3442ff00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65280));
    // 0x207e64: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x207e68: 0x2021024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x207e6c: 0x10440004
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_207e80;
    }
    // 0x207e74: 0x10000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_207f38;
    }
label_207e7c:
    // 0x207e7c: 0x46032001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
label_207e80:
    // 0x207e80: 0x1025c3
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 16), 23));
    // 0x207e84: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x207e88: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x207e8c: 0x21dc2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 23));
    // 0x207e90: 0x306300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 255));
    // 0x207e94: 0x831823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x207e98: 0x28620009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    // 0x207e9c: 0x54400027
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
        goto label_207f3c;
    }
    // 0x207ea4: 0x3c013735
    SET_GPR_U32(ctx, 1, ((uint32_t)14133 << 16));
    // 0x207ea8: 0x34214400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17408));
    // 0x207eac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207eb0: 0x46002146
    ctx->f[5] = FPU_MOV_S(ctx->f[4]);
    // 0x207eb4: 0x3c012e85
    SET_GPR_U32(ctx, 1, ((uint32_t)11909 << 16));
    // 0x207eb8: 0x3421a308
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41736));
    // 0x207ebc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x207ec0: 0x460030c2
    ctx->f[3] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x207ec4: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x207ec8: 0x46032101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    // 0x207ecc: 0x46042801
    ctx->f[0] = FPU_SUB_S(ctx->f[5], ctx->f[4]);
    // 0x207ed0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x207ed4: 0x460008c1
    ctx->f[3] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x207ed8: 0x46032081
    ctx->f[2] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    // 0x207edc: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x207ee0: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x207ee4: 0x21dc2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 2), 23));
    // 0x207ee8: 0x306300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 255));
    // 0x207eec: 0x831823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x207ef0: 0x2862001a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 26));
    // 0x207ef4: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
        goto label_207f3c;
    }
    // 0x207efc: 0x3c012e85
    SET_GPR_U32(ctx, 1, ((uint32_t)11909 << 16));
    // 0x207f00: 0x3421a300
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41728));
    // 0x207f04: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x207f08: 0x46002146
    ctx->f[5] = FPU_MOV_S(ctx->f[4]);
    // 0x207f0c: 0x3c01248d
    SET_GPR_U32(ctx, 1, ((uint32_t)9357 << 16));
    // 0x207f10: 0x34213132
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 12594));
    // 0x207f14: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207f18: 0x460030c2
    ctx->f[3] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x207f1c: 0x46023082
    ctx->f[2] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x207f20: 0x46032101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    // 0x207f24: 0x46042801
    ctx->f[0] = FPU_SUB_S(ctx->f[5], ctx->f[4]);
    // 0x207f28: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x207f2c: 0x460010c1
    ctx->f[3] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x207f30: 0x46032041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    // 0x207f34: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_207f38:
    // 0x207f38: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
label_207f3c:
    // 0x207f3c: 0x46012001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x207f40: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x207f44: 0x6410041
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x20804C; return;
    }
    // 0x207f4c: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x207f50: 0x1000003a
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20803C; return;
    }
label_207f58:
    // 0x207f58: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x207f5c: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x207f60: 0x10400005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_207f78;
    }
    // 0x207f68: 0x460c6001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[12]);
    // 0x207f6c: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x207f70: 0x10000037
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x208050; return;
    }
label_207f78:
    // 0x207f78: 0x101dc3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 16), 23));
    // 0x207f7c: 0x2466ff7a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4294967162));
    // 0x207f80: 0x615c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 23));
    // 0x207f84: 0x2028023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x207f88: 0x44906000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 16);
    // 0x207f8c: 0x3c014380
    SET_GPR_U32(ctx, 1, ((uint32_t)17280 << 16));
    // 0x207f90: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x207f94: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x207f98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x207f9c: 0x0
    // NOP
label_207fa0:
    // 0x207fa0: 0x46006024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[12]);
    // 0x207fa4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x207fa8: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x207fac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x207fb0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x207fb4: 0x46006041
    ctx->f[1] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x207fb8: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x207fbc: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x207fc0: 0x461fff7
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_207fa0;
    }
    // 0x207fc8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x207fcc: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x207fd0: 0x46016032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x207fd4: 0x0
    // NOP
    // 0x207fd8: 0x4500000c
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_20800c;
    }
    // 0x207fe0: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x207fe4: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_207fe8:
    // 0x207fe8: 0x24e2ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x207fec: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x207ff0: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x207ff4: 0x3a31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    // 0x207ff8: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x207ffc: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x208000: 0x0
    // NOP
    // 0x208004: 0x4503fff8
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
        goto label_207fe8;
    }
label_20800c:
    // 0x20800c: 0x3c090025
    SET_GPR_U32(ctx, 9, ((uint32_t)37 << 16));
    // 0x208010: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x208014: 0x2529fad8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294965976));
    // 0x208018: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20801c: 0xc0820be
    SET_GPR_U32(ctx, 31, 0x208024);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    fn___kernel_rem_pio2f(rdram, ctx, runtime); return;
}


// Function: entry_208024
// Address: 0x208024 - 0x208068

void entry_208024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x208024) {
        switch (ctx->pc) {
            case 0x20803c: ctx->pc = 0; goto label_20803c;
            case 0x20804c: ctx->pc = 0; goto label_20804c;
            case 0x208050: ctx->pc = 0; goto label_208050;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x208024: 0x6410009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_20804c;
    }
    // 0x20802c: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x208030: 0x51023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
    // 0x208034: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x208038: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
label_20803c:
    // 0x20803c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x208040: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x208044: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208050;
    }
label_20804c:
    // 0x20804c: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_208050:
    // 0x208050: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x208054: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x208058: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20805c: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x208060: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___ieee754_sqrtf
// Address: 0x208068 - 0x2081a0

void entry_208510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x208510: 0x3c013e00
    SET_GPR_U32(ctx, 1, ((uint32_t)15872 << 16));
    // 0x208514: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x208518: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x20851c: 0xafa0014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 0));
    // 0x208520: 0xc0814c6
    SET_GPR_U32(ctx, 31, 0x208528);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    floorf(rdram, ctx, runtime); return;
}


// Function: entry_208528
// Address: 0x208528 - 0x20869c

void entry_208528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x208528) {
        switch (ctx->pc) {
            case 0x208590: ctx->pc = 0; goto label_208590;
            case 0x2085b0: ctx->pc = 0; goto label_2085b0;
            case 0x2085cc: ctx->pc = 0; goto label_2085cc;
            case 0x2085f8: ctx->pc = 0; goto label_2085f8;
            case 0x208610: ctx->pc = 0; goto label_208610;
            case 0x208614: ctx->pc = 0; goto label_208614;
            case 0x208618: ctx->pc = 0; goto label_208618;
            case 0x208624: ctx->pc = 0; goto label_208624;
            case 0x208644: ctx->pc = 0; goto label_208644;
            case 0x20865c: ctx->pc = 0; goto label_20865c;
            case 0x208670: ctx->pc = 0; goto label_208670;
            case 0x208674: ctx->pc = 0; goto label_208674;
            case 0x20867c: ctx->pc = 0; goto label_20867c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x208528: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x20852c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x208530: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x208534: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x208538: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x20853c: 0x44130000
    SET_GPR_U32(ctx, 19, *(uint32_t*)&ctx->f[0]);
    // 0x208540: 0x44930000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 19);
    // 0x208544: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x208548: 0x1a400011
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_208590;
    }
    // 0x208550: 0x2602ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x208554: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x208558: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20855c: 0x721823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x208560: 0x3a22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208564: 0x24040007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 7));
    // 0x208568: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20856c: 0x922023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x208570: 0x623007
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 2), GPR_U32(ctx, 3) & 0x1F));
    // 0x208574: 0x661804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), GPR_U32(ctx, 3) & 0x1F));
    // 0x208578: 0x2669821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 6)));
    // 0x20857c: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x208580: 0x822007
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), GPR_U32(ctx, 4) & 0x1F));
    // 0x208584: 0xafa4014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 4));
    // 0x208588: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2085cc;
    }
label_208590:
    // 0x208590: 0x16400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_2085b0;
    }
    // 0x208598: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20859c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x2085a0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x2085a4: 0x42203
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 8));
    // 0x2085a8: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2085cc;
    }
label_2085b0:
    // 0x2085b0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x2085b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2085b8: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2085bc: 0x0
    // NOP
    // 0x2085c0: 0x45000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_2085cc;
    }
    // 0x2085c8: 0xafa2014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 2));
label_2085cc:
    // 0x2085cc: 0x8fa3014c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x2085d0: 0x18600033
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x2086A0; return;
    }
    // 0x2085d8: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x2085dc: 0x1a000011
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_208624;
    }
    // 0x2085e4: 0x24080100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 256));
    // 0x2085e8: 0x240400ff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 255));
    // 0x2085ec: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x2085f0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2085f4: 0x0
    // NOP
label_2085f8:
    // 0x2085f8: 0x14e00005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        goto label_208610;
    }
    // 0x208600: 0x10a00005
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 8), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_208618;
    }
    // 0x208608: 0x10000002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208614;
    }
label_208610:
    // 0x208610: 0x851023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
label_208614:
    // 0x208614: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_208618:
    // 0x208618: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x20861c: 0x14c0fff6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_2085f8;
    }
label_208624:
    // 0x208624: 0x1a400013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_208674;
    }
    // 0x20862c: 0x12420005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_208644;
    }
    // 0x208634: 0x12420009
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_20865c;
    }
    // 0x20863c: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20867c;
    }
label_208644:
    // 0x208644: 0x2602ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x208648: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20864c: 0x3a22021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208650: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x208654: 0x10000006
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 127));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208670;
    }
label_20865c:
    // 0x20865c: 0x2602ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x208660: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x208664: 0x3a22021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208668: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20866c: 0x3063003f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 63));
label_208670:
    // 0x208670: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
label_208674:
    // 0x208674: 0x8fa4014c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x208678: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_20867c:
    // 0x20867c: 0x14820008
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x2086A0; return;
    }
    // 0x208684: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x208688: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x20868c: 0x10e00004
    ctx->f[20] = FPU_SUB_S(ctx->f[12], ctx->f[20]);
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2086A0; return;
    }
    // 0x208694: 0xc082498
    SET_GPR_U32(ctx, 31, 0x20869c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    scalbnf(rdram, ctx, runtime); return;
}


// Function: entry_20869c
// Address: 0x20869c - 0x20884c

void entry_20869c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20869c) {
        switch (ctx->pc) {
            case 0x2086a0: ctx->pc = 0; goto label_2086a0;
            case 0x2086c8: ctx->pc = 0; goto label_2086c8;
            case 0x2086e4: ctx->pc = 0; goto label_2086e4;
            case 0x208708: ctx->pc = 0; goto label_208708;
            case 0x20872c: ctx->pc = 0; goto label_20872c;
            case 0x208734: ctx->pc = 0; goto label_208734;
            case 0x208750: ctx->pc = 0; goto label_208750;
            case 0x208790: ctx->pc = 0; goto label_208790;
            case 0x2087cc: ctx->pc = 0; goto label_2087cc;
            case 0x2087d8: ctx->pc = 0; goto label_2087d8;
            case 0x2087f0: ctx->pc = 0; goto label_2087f0;
            case 0x2087fc: ctx->pc = 0; goto label_2087fc;
            case 0x208820: ctx->pc = 0; goto label_208820;
            case 0x208844: ctx->pc = 0; goto label_208844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20869c: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
label_2086a0:
    // 0x2086a0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2086a4: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2086a8: 0x0
    // NOP
    // 0x2086ac: 0x45000053
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_2087fc;
    }
    // 0x2086b4: 0xd4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 20)));
    // 0x2086b8: 0x1440000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2086e4;
    }
    // 0x2086c0: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x2086c4: 0x5d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
label_2086c8:
    // 0x2086c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x2086cc: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x2086d0: 0x2484fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967292));
    // 0x2086d4: 0xd4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 20)));
    // 0x2086d8: 0xa32825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x2086dc: 0x1040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2086c8;
    }
label_2086e4:
    // 0x2086e4: 0x14a00042
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294967295));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_2087f0;
    }
    // 0x2086ec: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x2086f0: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x2086f4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x2086f8: 0x1480000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_20872c;
    }
    // 0x208700: 0x26050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1));
    // 0x208704: 0x0
    // NOP
label_208708:
    // 0x208708: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x20870c: 0x2881023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 8)));
    // 0x208710: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x208714: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208718: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20871c: 0x1080fffa
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_208708;
    }
    // 0x208724: 0x10000003
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208734;
    }
label_20872c:
    // 0x20872c: 0x26050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1));
    // 0x208730: 0x2082021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 8)));
label_208734:
    // 0x208734: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x208738: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x20873c: 0x1440ff55
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x208494; return;
    }
    // 0x208744: 0x27a90050
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 80));
    // 0x208748: 0x2a2b0000
    SET_GPR_U32(ctx, 11, SLT32(GPR_S32(ctx, 17), 0));
    // 0x20874c: 0x0
    // NOP
label_208750:
    // 0x208750: 0x8fa50148
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 328)));
    // 0x208754: 0x2c61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 6)));
    // 0x208758: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20875c: 0x2265021
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 6)));
    // 0x208760: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x208764: 0xa1880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 10), 2));
    // 0x208768: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x20876c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x208770: 0x1231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x208774: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x208778: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x20877c: 0x15600013
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 11) != GPR_U32(ctx, 0)) {
        goto label_2087cc;
    }
    // 0x208784: 0x24c80001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 6), 1));
    // 0x208788: 0x63880
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 6), 2));
    // 0x20878c: 0x0
    // NOP
label_208790:
    // 0x208790: 0x1451023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 10), GPR_U32(ctx, 5)));
    // 0x208794: 0x8fa60140
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x208798: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x20879c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x2087a0: 0x1221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x2087a4: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x2087a8: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x2087ac: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x2087b0: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x2087b4: 0x225102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 5)));
    // 0x2087b8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x2087bc: 0x1040fff4
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_208790;
    }
    // 0x2087c4: 0x10000004
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 7)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2087d8;
    }
label_2087cc:
    // 0x2087cc: 0x24c80001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 6), 1));
    // 0x2087d0: 0x63880
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 6), 2));
    // 0x2087d4: 0x2a71821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 7)));
label_2087d8:
    // 0x2087d8: 0x100302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x2087dc: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x2087e0: 0x1040ffdb
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_208750;
    }
    // 0x2087e8: 0x1000ff2a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x208494; return;
    }
label_2087f0:
    // 0x2087f0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x2087f4: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x2087f8: 0x0
    // NOP
label_2087fc:
    // 0x2087fc: 0x45000011
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_208844;
    }
    // 0x208804: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x208808: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x20880c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208810: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x208814: 0x1480002c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967288));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2088C8; return;
    }
    // 0x20881c: 0x32710007
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 19), 7));
label_208820:
    // 0x208820: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x208824: 0x2652fff8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967288));
    // 0x208828: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x20882c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208830: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x208834: 0x1080fffa
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_208820;
    }
    // 0x20883c: 0x10000023
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2088CC; return;
    }
label_208844:
    // 0x208844: 0xc082498
    SET_GPR_U32(ctx, 31, 0x20884c);
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 18)));
    scalbnf(rdram, ctx, runtime); return;
}


// Function: entry_20884c
// Address: 0x20884c - 0x2088dc

void entry_20884c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20884c) {
        switch (ctx->pc) {
            case 0x2088b4: ctx->pc = 0; goto label_2088b4;
            case 0x2088c8: ctx->pc = 0; goto label_2088c8;
            case 0x2088cc: ctx->pc = 0; goto label_2088cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20884c: 0x3c014380
    SET_GPR_U32(ctx, 1, ((uint32_t)17280 << 16));
    // 0x208850: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x208854: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x208858: 0x46140836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x20885c: 0x0
    // NOP
    // 0x208860: 0x45000014
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 30)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_2088b4;
    }
    // 0x208868: 0x3c013b80
    SET_GPR_U32(ctx, 1, ((uint32_t)15232 << 16));
    // 0x20886c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x208870: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x208874: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x208878: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x20887c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x208880: 0x32710007
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 19), 7));
    // 0x208884: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x208888: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x20888c: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x208890: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x208894: 0x46011002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x208898: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x20889c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x2088a0: 0xe4810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x2088a4: 0x46001024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[2]);
    // 0x2088a8: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x2088ac: 0x10000007
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2088cc;
    }
label_2088b4:
    // 0x2088b4: 0x3be1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 30)));
    // 0x2088b8: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x2088bc: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x2088c0: 0x10000002
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 19), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2088cc;
    }
label_2088c8:
    // 0x2088c8: 0x32710007
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 19), 7));
label_2088cc:
    // 0x2088cc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x2088d0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x2088d4: 0xc082498
    SET_GPR_U32(ctx, 31, 0x2088dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    scalbnf(rdram, ctx, runtime); return;
}


// Function: entry_2088dc
// Address: 0x2088dc - 0x208c48

void entry_2088dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2088dc) {
        switch (ctx->pc) {
            case 0x208900: ctx->pc = 0; goto label_208900;
            case 0x208928: ctx->pc = 0; goto label_208928;
            case 0x208938: ctx->pc = 0; goto label_208938;
            case 0x208960: ctx->pc = 0; goto label_208960;
            case 0x2089a8: ctx->pc = 0; goto label_2089a8;
            case 0x2089ac: ctx->pc = 0; goto label_2089ac;
            case 0x2089b0: ctx->pc = 0; goto label_2089b0;
            case 0x2089b8: ctx->pc = 0; goto label_2089b8;
            case 0x2089c8: ctx->pc = 0; goto label_2089c8;
            case 0x2089e8: ctx->pc = 0; goto label_2089e8;
            case 0x208a00: ctx->pc = 0; goto label_208a00;
            case 0x208a18: ctx->pc = 0; goto label_208a18;
            case 0x208a38: ctx->pc = 0; goto label_208a38;
            case 0x208a50: ctx->pc = 0; goto label_208a50;
            case 0x208a68: ctx->pc = 0; goto label_208a68;
            case 0x208a8c: ctx->pc = 0; goto label_208a8c;
            case 0x208a94: ctx->pc = 0; goto label_208a94;
            case 0x208aac: ctx->pc = 0; goto label_208aac;
            case 0x208ab8: ctx->pc = 0; goto label_208ab8;
            case 0x208ad8: ctx->pc = 0; goto label_208ad8;
            case 0x208af4: ctx->pc = 0; goto label_208af4;
            case 0x208b08: ctx->pc = 0; goto label_208b08;
            case 0x208b48: ctx->pc = 0; goto label_208b48;
            case 0x208b58: ctx->pc = 0; goto label_208b58;
            case 0x208b98: ctx->pc = 0; goto label_208b98;
            case 0x208bb0: ctx->pc = 0; goto label_208bb0;
            case 0x208bd8: ctx->pc = 0; goto label_208bd8;
            case 0x208be0: ctx->pc = 0; goto label_208be0;
            case 0x208bf8: ctx->pc = 0; goto label_208bf8;
            case 0x208c0c: ctx->pc = 0; goto label_208c0c;
            case 0x208c10: ctx->pc = 0; goto label_208c10;
            case 0x208c14: ctx->pc = 0; goto label_208c14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2088dc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2088e0: 0x4c00011
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (GPR_S32(ctx, 6) < 0) {
        goto label_208928;
    }
    // 0x2088e8: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x2088ec: 0x3c013b80
    SET_GPR_U32(ctx, 1, ((uint32_t)15232 << 16));
    // 0x2088f0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x2088f4: 0x5d1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x2088f8: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x2088fc: 0x0
    // NOP
label_208900:
    // 0x208900: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208904: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x208908: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x20890c: 0x2463fffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967292));
    // 0x208910: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x208914: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x208918: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x20891c: 0x4c1fff8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967292));
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_208900;
    }
    // 0x208924: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_208928:
    // 0x208928: 0x4c20027
    if (GPR_S32(ctx, 6) < 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 336)));
        goto label_2089c8;
    }
    // 0x208930: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208934: 0x0
    // NOP
label_208938:
    // 0x208938: 0x8fa20154
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 340)));
    // 0x20893c: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x208940: 0x14400019
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2089a8;
    }
    // 0x208948: 0x2064823
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 6)));
    // 0x20894c: 0x5200017
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 9) < 0) {
        goto label_2089ac;
    }
    // 0x208954: 0x24c5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208958: 0x3c0b0025
    SET_GPR_U32(ctx, 11, ((uint32_t)37 << 16));
    // 0x20895c: 0x0
    // NOP
label_208960:
    // 0x208960: 0xc81821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x208964: 0x82080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 8), 2));
    // 0x208968: 0x2562fed0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 11), 4294966992));
    // 0x20896c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x208970: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x208974: 0x2a31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 3)));
    // 0x208978: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x20897c: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x208980: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x208984: 0x288102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 8)));
    // 0x208988: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x20898c: 0x14400008
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_2089b0;
    }
    // 0x208994: 0x148102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 8)));
    // 0x208998: 0x1040fff1
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_208960;
    }
    // 0x2089a0: 0x10000005
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2089b8;
    }
label_2089a8:
    // 0x2089a8: 0x2064823
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 6)));
label_2089ac:
    // 0x2089ac: 0x24c5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 4294967295));
label_2089b0:
    // 0x2089b0: 0x91080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 2));
    // 0x2089b4: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_2089b8:
    // 0x2089b8: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x2089bc: 0x4c1ffde
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_208938;
    }
    // 0x2089c4: 0x8fa30150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 336)));
label_2089c8:
    // 0x2089c8: 0x10600007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_2089e8;
    }
    // 0x2089d0: 0x5c80001f
    if (GPR_S32(ctx, 4) > 0) {
        SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_208a50;
    }
    // 0x2089d8: 0x10800009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_208a00;
    }
    // 0x2089e0: 0x1000008c
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208c14;
    }
label_2089e8:
    // 0x2089e8: 0x8fa50144
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x2089ec: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x2089f0: 0x10a20040
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_208af4;
    }
    // 0x2089f8: 0x10000086
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208c14;
    }
label_208a00:
    // 0x208a00: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x208a04: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x208a08: 0x4c2000b
    if (GPR_S32(ctx, 6) < 0) {
        { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
        goto label_208a38;
    }
    // 0x208a10: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208a14: 0x0
    // NOP
label_208a18:
    // 0x208a18: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208a1c: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208a20: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208a24: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208a28: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x208a2c: 0x4c1fffa
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_208a18;
    }
    // 0x208a34: 0xe6e20000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
label_208a38:
    // 0x208a38: 0x8fa6014c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x208a3c: 0x10c00074
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_208c10;
    }
    // 0x208a44: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x208a48: 0x10000071
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208c10;
    }
label_208a50:
    // 0x208a50: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x208a54: 0x4c0000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[3] = *(float*)&val; }
    if (GPR_S32(ctx, 6) < 0) {
        goto label_208a8c;
    }
    // 0x208a5c: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208a60: 0x28c30001
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 1));
    // 0x208a64: 0x0
    // NOP
label_208a68:
    // 0x208a68: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208a6c: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208a70: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208a74: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208a78: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x208a7c: 0x4c1fffa
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_208a68;
    }
    // 0x208a84: 0x10000003
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208a94;
    }
label_208a8c:
    // 0x208a8c: 0x28c30001
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 1));
    // 0x208a90: 0xe6e20000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
label_208a94:
    // 0x208a94: 0x8fa8014c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x208a98: 0x51000004
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->f[2] = FPU_SUB_S(ctx->f[3], ctx->f[2]);
        goto label_208aac;
    }
    // 0x208aa0: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x208aa4: 0xe6e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
    // 0x208aa8: 0x46021881
    ctx->f[2] = FPU_SUB_S(ctx->f[3], ctx->f[2]);
label_208aac:
    // 0x208aac: 0x1460000a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_208ad8;
    }
    // 0x208ab4: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
label_208ab8:
    // 0x208ab8: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208abc: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208ac0: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x208ac4: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208ac8: 0x206182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 6)));
    // 0x208acc: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x208ad0: 0x1060fff9
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_208ab8;
    }
label_208ad8:
    // 0x208ad8: 0xe6e20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 4), *(uint32_t*)&val); }
    // 0x208adc: 0x8fa2014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x208ae0: 0x1040004b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_208c10;
    }
    // 0x208ae8: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x208aec: 0x10000048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 23), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208c10;
    }
label_208af4:
    // 0x208af4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x208af8: 0x18c00013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 2));
    if (GPR_S32(ctx, 6) <= 0) {
        goto label_208b48;
    }
    // 0x208b00: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208b04: 0x0
    // NOP
label_208b08:
    // 0x208b08: 0x24c4ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208b0c: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208b10: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x208b14: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208b18: 0xe31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x208b1c: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x208b20: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208b24: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x208b28: 0x46010080
    ctx->f[2] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x208b2c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x208b30: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x208b34: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x208b38: 0x1cc0fff3
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 6) > 0) {
        goto label_208b08;
    }
    // 0x208b40: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x208b44: 0x28c20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 2));
label_208b48:
    // 0x208b48: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_208b98;
    }
    // 0x208b50: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208b54: 0x0
    // NOP
label_208b58:
    // 0x208b58: 0x24c4ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208b5c: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208b60: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x208b64: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208b68: 0xe31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x208b6c: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x208b70: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208b74: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x208b78: 0x28c50002
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 6), 2));
    // 0x208b7c: 0x46010080
    ctx->f[2] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x208b80: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x208b84: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x208b88: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x208b8c: 0x10a0fff2
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_208b58;
    }
    // 0x208b94: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_208b98:
    // 0x208b98: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x208b9c: 0x28c20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 2));
    // 0x208ba0: 0x1440000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[3] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_208bd8;
    }
    // 0x208ba8: 0x27a700a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 160));
    // 0x208bac: 0xc7a100a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[1] = *(float*)&val; }
label_208bb0:
    // 0x208bb0: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x208bb4: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x208bb8: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x208bbc: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x208bc0: 0x28c30002
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 2));
    // 0x208bc4: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x208bc8: 0x1060fff9
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_208bb0;
    }
    // 0x208bd0: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208be0;
    }
label_208bd8:
    // 0x208bd8: 0xc7a100a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[1] = *(float*)&val; }
    // 0x208bdc: 0x8fa3014c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 332)));
label_208be0:
    // 0x208be0: 0x54600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->f[0] = FPU_NEG_S(ctx->f[3]);
        goto label_208bf8;
    }
    // 0x208be8: 0xe6e20008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 8), *(uint32_t*)&val); }
    // 0x208bec: 0xe6e30000
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
    // 0x208bf0: 0x10000006
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 23), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208c0c;
    }
label_208bf8:
    // 0x208bf8: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x208bfc: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x208c00: 0xe6e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 23), 0), *(uint32_t*)&val); }
    // 0x208c04: 0xe6e10004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 23), 4), *(uint32_t*)&val); }
    // 0x208c08: 0xe6e20008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 23), 8), *(uint32_t*)&val); }
label_208c0c:
    // 0x208c0c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_208c10:
    // 0x208c10: 0xdfbf01f0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 496)));
label_208c14:
    // 0x208c14: 0xdfbe01e0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x208c18: 0xdfb701d0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x208c1c: 0xdfb601c0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x208c20: 0xdfb501b0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x208c24: 0xdfb401a0
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x208c28: 0xdfb30190
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x208c2c: 0xdfb20180
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x208c30: 0xdfb10170
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x208c34: 0xdfb00160
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x208c38: 0xc7b40200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 512)); ctx->f[20] = *(float*)&val; }
    // 0x208c3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 528));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x208c44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x208c48; return;
}


// Function: fn___kernel_sinf
// Address: 0x208c48 - 0x208d50

void entry_208da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x208da8) {
        switch (ctx->pc) {
            case 0x208dc8: ctx->pc = 0; goto label_208dc8;
            case 0x208dec: ctx->pc = 0; goto label_208dec;
            case 0x208df4: ctx->pc = 0; goto label_208df4;
            case 0x208df8: ctx->pc = 0; goto label_208df8;
            case 0x208e18: ctx->pc = 0; goto label_208e18;
            case 0x208e44: ctx->pc = 0; goto label_208e44;
            case 0x208f58: ctx->pc = 0; goto label_208f58;
            case 0x208fd8: ctx->pc = 0; goto label_208fd8;
            case 0x208fdc: ctx->pc = 0; goto label_208fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x208da8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x208dac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x208db0: 0x0
    // NOP
    // 0x208db4: 0x0
    // NOP
    // 0x208db8: 0x46000803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
    // 0x208dbc: 0x10000087
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208fdc;
    }
    // 0x208dc4: 0x0
    // NOP
label_208dc8:
    // 0x208dc8: 0x10820008
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_208dec;
    }
    // 0x208dd0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x208dd4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x208dd8: 0x0
    // NOP
    // 0x208ddc: 0x0
    // NOP
    // 0x208de0: 0x460c0003
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[12];
    // 0x208de4: 0x1000007d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208fdc;
    }
label_208dec:
    // 0x208dec: 0x1000007a
    ctx->f[0] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208fd8;
    }
label_208df4:
    // 0x208df4: 0x3c023f2c
    SET_GPR_U32(ctx, 2, ((uint32_t)16172 << 16));
label_208df8:
    // 0x208df8: 0x3442a13f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 41279));
    // 0x208dfc: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x208e00: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[14] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
        goto label_208e44;
    }
    // 0x208e08: 0x4c10003
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_208e18;
    }
    // 0x208e10: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x208e14: 0x46006b47
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
label_208e18:
    // 0x208e18: 0x3c013f49
    SET_GPR_U32(ctx, 1, ((uint32_t)16201 << 16));
    // 0x208e1c: 0x34210fda
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4058));
    // 0x208e20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x208e24: 0x3c013322
    SET_GPR_U32(ctx, 1, ((uint32_t)13090 << 16));
    // 0x208e28: 0x34212168
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 8552));
    // 0x208e2c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x208e30: 0x460c0381
    ctx->f[14] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x208e34: 0x460d0ac1
    ctx->f[11] = FPU_SUB_S(ctx->f[1], ctx->f[13]);
    // 0x208e38: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x208e3c: 0x460b7300
    ctx->f[12] = FPU_ADD_S(ctx->f[14], ctx->f[11]);
    // 0x208e40: 0x460c6382
    ctx->f[14] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
label_208e44:
    // 0x208e44: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x208e48: 0x2462ff38
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967096));
    // 0x208e4c: 0xc469ff38
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294967096)); ctx->f[9] = *(float*)&val; }
    // 0x208e50: 0xc4440030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 48)); ctx->f[4] = *(float*)&val; }
    // 0x208e54: 0x3c033f2c
    SET_GPR_U32(ctx, 3, ((uint32_t)16172 << 16));
    // 0x208e58: 0x460e72c2
    ctx->f[11] = FPU_MUL_S(ctx->f[14], ctx->f[14]);
    // 0x208e5c: 0xc445002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 44)); ctx->f[5] = *(float*)&val; }
    // 0x208e60: 0xc4460028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[6] = *(float*)&val; }
    // 0x208e64: 0x460c73c2
    ctx->f[15] = FPU_MUL_S(ctx->f[14], ctx->f[12]);
    // 0x208e68: 0xc4420024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 36)); ctx->f[2] = *(float*)&val; }
    // 0x208e6c: 0x3463a13f
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 41279));
    // 0x208e70: 0x46045902
    ctx->f[4] = FPU_MUL_S(ctx->f[11], ctx->f[4]);
    // 0x208e74: 0xc4430020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[3] = *(float*)&val; }
    // 0x208e78: 0x46055942
    ctx->f[5] = FPU_MUL_S(ctx->f[11], ctx->f[5]);
    // 0x208e7c: 0xc440001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[0] = *(float*)&val; }
    // 0x208e80: 0xc4470018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[7] = *(float*)&val; }
    // 0x208e84: 0x460f4a42
    ctx->f[9] = FPU_MUL_S(ctx->f[9], ctx->f[15]);
    // 0x208e88: 0x46043180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[4]);
    // 0x208e8c: 0xc4410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[1] = *(float*)&val; }
    // 0x208e90: 0x46051080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[5]);
    // 0x208e94: 0xc4440010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[4] = *(float*)&val; }
    // 0x208e98: 0xc445000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[5] = *(float*)&val; }
    // 0x208e9c: 0x65182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x208ea0: 0x46065982
    ctx->f[6] = FPU_MUL_S(ctx->f[11], ctx->f[6]);
    // 0x208ea4: 0xc4480008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[8] = *(float*)&val; }
    // 0x208ea8: 0x46025882
    ctx->f[2] = FPU_MUL_S(ctx->f[11], ctx->f[2]);
    // 0x208eac: 0xc44a0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[10] = *(float*)&val; }
    // 0x208eb0: 0x460618c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[6]);
    // 0x208eb4: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x208eb8: 0x460358c2
    ctx->f[3] = FPU_MUL_S(ctx->f[11], ctx->f[3]);
    // 0x208ebc: 0x46005802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[0]);
    // 0x208ec0: 0x460339c0
    ctx->f[7] = FPU_ADD_S(ctx->f[7], ctx->f[3]);
    // 0x208ec4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x208ec8: 0x460759c2
    ctx->f[7] = FPU_MUL_S(ctx->f[11], ctx->f[7]);
    // 0x208ecc: 0x46015842
    ctx->f[1] = FPU_MUL_S(ctx->f[11], ctx->f[1]);
    // 0x208ed0: 0x46072100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[7]);
    // 0x208ed4: 0x46012940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x208ed8: 0x46045902
    ctx->f[4] = FPU_MUL_S(ctx->f[11], ctx->f[4]);
    // 0x208edc: 0x46055942
    ctx->f[5] = FPU_MUL_S(ctx->f[11], ctx->f[5]);
    // 0x208ee0: 0x46044200
    ctx->f[8] = FPU_ADD_S(ctx->f[8], ctx->f[4]);
    // 0x208ee4: 0x460550c0
    ctx->f[3] = FPU_ADD_S(ctx->f[10], ctx->f[5]);
    // 0x208ee8: 0x46087102
    ctx->f[4] = FPU_MUL_S(ctx->f[14], ctx->f[8]);
    // 0x208eec: 0x46041800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x208ef0: 0x46007802
    ctx->f[0] = FPU_MUL_S(ctx->f[15], ctx->f[0]);
    // 0x208ef4: 0x460d0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[13]);
    // 0x208ef8: 0x46007002
    ctx->f[0] = FPU_MUL_S(ctx->f[14], ctx->f[0]);
    // 0x208efc: 0x460068c0
    ctx->f[3] = FPU_ADD_S(ctx->f[13], ctx->f[0]);
    // 0x208f00: 0x460918c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[9]);
    // 0x208f04: 0x10600014
    ctx->f[11] = FPU_ADD_S(ctx->f[12], ctx->f[3]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_208f58;
    }
    // 0x208f0c: 0x44842000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 4);
    // 0x208f10: 0x46802120
    ctx->f[4] = FPU_CVT_S_W(*(int32_t*)&ctx->f[4]);
    // 0x208f14: 0x61f83
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 6), 30));
    // 0x208f18: 0x460b5802
    ctx->f[0] = FPU_MUL_S(ctx->f[11], ctx->f[11]);
    // 0x208f1c: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x208f20: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x208f24: 0x46045840
    ctx->f[1] = FPU_ADD_S(ctx->f[11], ctx->f[4]);
    // 0x208f28: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x208f2c: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x208f30: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x208f34: 0x0
    // NOP
    // 0x208f38: 0x0
    // NOP
    // 0x208f3c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x208f40: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x208f44: 0x46006001
    ctx->f[0] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x208f48: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x208f4c: 0x46002001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x208f50: 0x10000021
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_208fd8;
    }
label_208f58:
    // 0x208f58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x208f5c: 0x1082001e
    ctx->f[0] = FPU_MOV_S(ctx->f[11]);
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_208fd8;
    }
    // 0x208f64: 0x44025800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[11]);
    // 0x208f68: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x208f6c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x208f70: 0x3442f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 61440));
    // 0x208f74: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x208f78: 0x44837000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 3);
    // 0x208f7c: 0x460c7041
    ctx->f[1] = FPU_SUB_S(ctx->f[14], ctx->f[12]);
    // 0x208f80: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x208f84: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x208f88: 0x0
    // NOP
    // 0x208f8c: 0x0
    // NOP
    // 0x208f90: 0x460b0003
    if (ctx->f[11] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[11];
    // 0x208f94: 0x46011901
    ctx->f[4] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x208f98: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x208f9c: 0x80182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x208fa0: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x208fa4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x208fa8: 0x460e0042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[14]);
    // 0x208fac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x208fb0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x208fb4: 0x46000bc0
    ctx->f[15] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x208fb8: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x208fbc: 0x46040802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x208fc0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x208fc4: 0x46007800
    ctx->f[0] = FPU_ADD_S(ctx->f[15], ctx->f[0]);
    // 0x208fc8: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x208fcc: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x208fd0: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x208fd4: 0x0
    // NOP
label_208fd8:
    // 0x208fd8: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_208fdc:
    // 0x208fdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x208fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x208fe8; return;
}


// Function: fn_matherr
// Address: 0x208fe8 - 0x208ffc

void entry_208ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x208ffc: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x209000: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x209004: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20900c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209010; return;
}


// Function: rint
// Address: 0x209010 - 0x2090d4

void entry_2090d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2090d4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x2090d8: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x2090e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_2090e0
// Address: 0x2090e0 - 0x209174

void entry_2090e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2090e0) {
        switch (ctx->pc) {
            case 0x209108: ctx->pc = 0; goto label_209108;
            case 0x209140: ctx->pc = 0; goto label_209140;
            case 0x209154: ctx->pc = 0; goto label_209154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2090e0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2090e4: 0x2303f
    SET_GPR_S64(ctx, 6, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x2090e8: 0xd21824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    // 0x2090ec: 0x1317c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 31));
    // 0x2090f0: 0x912024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 17)));
    // 0x2090f4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x2090f8: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x2090fc: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x209100: 0x1000003b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2091f0(rdram, ctx, runtime); return;
    }
label_209108:
    // 0x209108: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x20910c: 0x1022007
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), GPR_U32(ctx, 8) & 0x1F));
    // 0x209110: 0xc41824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x209114: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x209118: 0x1060001e
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209194; return;
    }
    // 0x209120: 0xc41024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x209124: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x209128: 0x10400023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2091B8; return;
    }
    // 0x209130: 0x15020003
    SET_GPR_U32(ctx, 3, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 2)) {
        goto label_209140;
    }
    // 0x209138: 0x1000001f
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2091B8; return;
    }
label_209140:
    // 0x209140: 0x3c020002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
    // 0x209144: 0xc31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x209148: 0x1021007
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), GPR_U32(ctx, 8) & 0x1F));
    // 0x20914c: 0x1000001a
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2091B8; return;
    }
label_209154:
    // 0x209154: 0x29020034
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), 52));
    // 0x209158: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 4294966253));
        ctx->pc = 0x20917C; return;
    }
    // 0x209160: 0x24020400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x209164: 0x15020022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 2)) {
        entry_2091f0(rdram, ctx, runtime); return;
    }
    // 0x20916c: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x209174);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_209174
// Address: 0x209174 - 0x2091e4

void entry_209174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209174) {
        switch (ctx->pc) {
            case 0x20917c: ctx->pc = 0; goto label_20917c;
            case 0x209194: ctx->pc = 0; goto label_209194;
            case 0x20919c: ctx->pc = 0; goto label_20919c;
            case 0x2091b8: ctx->pc = 0; goto label_2091b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209174: 0x1000001f
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2091F4; return;
    }
label_20917c:
    // 0x20917c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x209180: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x209184: 0x1022006
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 2), GPR_U32(ctx, 8) & 0x1F));
    // 0x209188: 0xe41824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x20918c: 0x14600003
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_20919c;
    }
label_209194:
    // 0x209194: 0x10000016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2091f0(rdram, ctx, runtime); return;
    }
label_20919c:
    // 0x20919c: 0xe41024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x2091a0: 0x10400005
    SET_GPR_U32(ctx, 3, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_2091b8;
    }
    // 0x2091a8: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x2091ac: 0xe31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x2091b0: 0x1021007
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), GPR_U32(ctx, 8) & 0x1F));
    // 0x2091b4: 0x623825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_2091b8:
    // 0x2091b8: 0x7103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) << (32 + 0));
    // 0x2091bc: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x2091c0: 0x6483c
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) << (32 + 0));
    // 0x2091c4: 0x1222825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x2091c8: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x2091cc: 0x2463ff80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967168));
    // 0x2091d0: 0x1310c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 3));
    // 0x2091d4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x2091d8: 0xdc500000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x2091dc: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x2091e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_2091e4
// Address: 0x2091e4 - 0x2091f0

void entry_2091e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2091e4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2091e8: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x2091f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_2091f0
// Address: 0x2091f0 - 0x209210

void entry_2091f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2091f0) {
        switch (ctx->pc) {
            case 0x2091f4: ctx->pc = 0; goto label_2091f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2091f0: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
label_2091f4:
    // 0x2091f4: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x2091f8: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2091fc: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209200: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209204: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20920c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209210; return;
}


// Function: finitef
// Address: 0x209210 - 0x209238

void entry_20937c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20937c) {
        switch (ctx->pc) {
            case 0x209384: ctx->pc = 0; goto label_209384;
            case 0x2093b0: ctx->pc = 0; goto label_2093b0;
            case 0x2093b8: ctx->pc = 0; goto label_2093b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20937c: 0x1000000c
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2093b0;
    }
label_209384:
    // 0x209384: 0x24630019
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 25));
    // 0x209388: 0x3c02807f
    SET_GPR_U32(ctx, 2, ((uint32_t)32895 << 16));
    // 0x20938c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x209390: 0x31dc0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 23));
    // 0x209394: 0xc21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x209398: 0x432825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20939c: 0x3c013300
    SET_GPR_U32(ctx, 1, ((uint32_t)13056 << 16));
    // 0x2093a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x2093a4: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x2093a8: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x2093ac: 0x0
    // NOP
label_2093b0:
    // 0x2093b0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x2093b4: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
label_2093b8:
    // 0x2093b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: copysignf
// Address: 0x2093c0 - 0x2093f0

void entry_209438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209438) {
        switch (ctx->pc) {
            case 0x20943c: ctx->pc = 0; goto label_20943c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209438: 0xaea2aecc
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294946508), GPR_U32(ctx, 2));
label_20943c:
    // 0x20943c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x209440: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x209444: 0xc0826e0
    SET_GPR_U32(ctx, 31, 0x20944c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    wait_for_sif_rpc_done_2QMARK(rdram, ctx, runtime); return;
}


// Function: entry_20944c
// Address: 0x20944c - 0x209454

void entry_20944c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20944c: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x209454);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_209454
// Address: 0x209454 - 0x20945c

void entry_209454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209454: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x20945c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_20945c
// Address: 0x20945c - 0x2094a8

void entry_20945c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20945c) {
        switch (ctx->pc) {
            case 0x209470: ctx->pc = 0; goto label_209470;
            case 0x209478: ctx->pc = 0; goto label_209478;
            case 0x209494: ctx->pc = 0; goto label_209494;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20945c: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x209460: 0x3c160063
    SET_GPR_U32(ctx, 22, ((uint32_t)99 << 16));
    // 0x209464: 0x1000000b
    SET_GPR_U32(ctx, 20, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209494;
    }
    // 0x20946c: 0x0
    // NOP
label_209470:
    // 0x209470: 0x3c020010
    SET_GPR_U32(ctx, 2, ((uint32_t)16 << 16));
    // 0x209474: 0x0
    // NOP
label_209478:
    // 0x209478: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20947c: 0x0
    // NOP
    // 0x209480: 0x0
    // NOP
    // 0x209484: 0x0
    // NOP
    // 0x209488: 0x0
    // NOP
    // 0x20948c: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_209478;
    }
label_209494:
    // 0x209494: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x209498: 0x2604ad40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294946112));
    // 0x20949c: 0x34a50400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1024));
    // 0x2094a0: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x2094a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_2094a8
// Address: 0x2094a8 - 0x2094bc

void entry_2094a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2094a8: 0x441000c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 4294946112));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x2094DC; return;
    }
    // 0x2094b0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x2094b4: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x2094bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967200));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_2094bc
// Address: 0x2094bc - 0x209514

void entry_2094bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2094bc) {
        switch (ctx->pc) {
            case 0x2094c0: ctx->pc = 0; goto label_2094c0;
            case 0x2094dc: ctx->pc = 0; goto label_2094dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2094bc: 0x0
    // NOP
label_2094c0:
    // 0x2094c0: 0x0
    // NOP
    // 0x2094c4: 0x0
    // NOP
    // 0x2094c8: 0x0
    // NOP
    // 0x2094cc: 0x0
    // NOP
    // 0x2094d0: 0x0
    // NOP
    // 0x2094d4: 0x1000fffa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_2094c0;
    }
label_2094dc:
    // 0x2094dc: 0x8e420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 36)));
    // 0x2094e0: 0x1040ffe3
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209470; return;
    }
    // 0x2094e8: 0x2691c300
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 4294951680));
    // 0x2094ec: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x2094f0: 0x26c7adc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 22), 4294946240));
    // 0x2094f4: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x2094f8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x2094fc: 0x240500fe
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 254));
    // 0x209500: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x209504: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x209508: 0x240a000c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 12));
    // 0x20950c: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209514);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209514
// Address: 0x209514 - 0x209520

void entry_209514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209514: 0x8ea4aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    // 0x209518: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209520);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209520
// Address: 0x209520 - 0x209548

void entry_209520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209520) {
        switch (ctx->pc) {
            case 0x209534: ctx->pc = 0; goto label_209534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209520: 0x6030004
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_209534;
    }
    // 0x209528: 0xae600024
    WRITE32(ADD32(GPR_U32(ctx, 19), 36), GPR_U32(ctx, 0));
    // 0x20952c: 0x10000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20957C; return;
    }
label_209534:
    // 0x209534: 0x2842020a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 522));
    // 0x209538: 0x10400006
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209554; return;
    }
    // 0x209540: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x209548);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967224));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_209548
// Address: 0x209548 - 0x20956c

void entry_209548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209548) {
        switch (ctx->pc) {
            case 0x209554: ctx->pc = 0; goto label_209554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209548: 0xae600024
    WRITE32(ADD32(GPR_U32(ctx, 19), 36), GPR_U32(ctx, 0));
    // 0x20954c: 0x1000000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967176));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20957C; return;
    }
label_209554:
    // 0x209554: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x209558: 0x2842020e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 526));
    // 0x20955c: 0x10400006
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209578; return;
    }
    // 0x209564: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x20956c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967264));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_20956c
// Address: 0x20956c - 0x2095b0

void entry_20956c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20956c) {
        switch (ctx->pc) {
            case 0x209578: ctx->pc = 0; goto label_209578;
            case 0x20957c: ctx->pc = 0; goto label_20957c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20956c: 0xae400024
    WRITE32(ADD32(GPR_U32(ctx, 18), 36), GPR_U32(ctx, 0));
    // 0x209570: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967175));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20957c;
    }
label_209578:
    // 0x209578: 0x8e82c300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294951680)));
label_20957c:
    // 0x20957c: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x209580: 0xdfb60090
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x209584: 0xdfb50080
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x209588: 0xdfb40070
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20958c: 0xdfb30060
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209590: 0xdfb20050
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209594: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209598: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20959c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2095a4: 0x0
    // NOP
    // 0x2095a8: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x2095ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2095b0; return;
}


// Function: FUN_002095b0
// Address: 0x2095b0 - 0x2095f0

void FUN_002095b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2095b0: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x2095b4: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x2095b8: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x2095bc: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x2095c0: 0x3c120028
    SET_GPR_U32(ctx, 18, ((uint32_t)40 << 16));
    // 0x2095c4: 0xffb60070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 22));
    // 0x2095c8: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x2095cc: 0xa0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x2095d0: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x2095d4: 0xe0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x2095d8: 0x8e44aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294946508)));
    // 0x2095dc: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x2095e0: 0xffbf0080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 31));
    // 0x2095e4: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x2095e8: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x2095f0);
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_2095f0
// Address: 0x2095f0 - 0x209618

void entry_2095f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2095f0) {
        switch (ctx->pc) {
            case 0x209600: ctx->pc = 0; goto label_209600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2095f0: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_209600;
    }
    // 0x2095f8: 0x10000030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2096BC; return;
    }
label_209600:
    // 0x209600: 0x2454ad40
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x209604: 0x8e830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x209608: 0x14600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209620; return;
    }
    // 0x209610: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209618);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209618
// Address: 0x209618 - 0x20963c

void entry_209618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209618) {
        switch (ctx->pc) {
            case 0x209620: ctx->pc = 0; goto label_209620;
            case 0x209634: ctx->pc = 0; goto label_209634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209618: 0x10000028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2096BC; return;
    }
label_209620:
    // 0x209620: 0x12200004
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_209634;
    }
    // 0x209628: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x20962c: 0x14400005
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209644; return;
    }
label_209634:
    // 0x209634: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x20963c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_20963c
// Address: 0x20963c - 0x209658

void entry_20963c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20963c) {
        switch (ctx->pc) {
            case 0x209644: ctx->pc = 0; goto label_209644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20963c: 0x1000001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967086));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2096BC; return;
    }
label_209644:
    // 0x209644: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x209648: 0x2610ae04
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294946308));
    // 0x20964c: 0x240603ff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1023));
    // 0x209650: 0xc0805c8
    SET_GPR_U32(ctx, 31, 0x209658);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strncpy(rdram, ctx, runtime); return;
}


// Function: entry_209658
// Address: 0x209658 - 0x209698

void entry_209658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209658: 0x2603ffec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967276));
    // 0x20965c: 0xae15ffec
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967276), GPR_U32(ctx, 21));
    // 0x209660: 0xac730008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 19));
    // 0x209664: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x209668: 0xac760004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 22));
    // 0x20966c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x209670: 0xa0600413
    WRITE8(ADD32(GPR_U32(ctx, 3), 1043), (uint8_t)GPR_U32(ctx, 0));
    // 0x209674: 0x60382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x209678: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x20967c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x209680: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x209684: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209688: 0x24080414
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1044));
    // 0x20968c: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x209690: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209698);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209698
// Address: 0x209698 - 0x2096b8

void entry_209698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209698) {
        switch (ctx->pc) {
            case 0x2096b0: ctx->pc = 0; goto label_2096b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209698: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20969c: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_2096b0;
    }
    // 0x2096a4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x2096a8: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2096b8(rdram, ctx, runtime); return;
    }
label_2096b0:
    // 0x2096b0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2096b8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2096b8
// Address: 0x2096b8 - 0x2096e8

void entry_2096b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2096b8) {
        switch (ctx->pc) {
            case 0x2096bc: ctx->pc = 0; goto label_2096bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2096b8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2096bc:
    // 0x2096bc: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x2096c0: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x2096c4: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x2096c8: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x2096cc: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x2096d0: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2096d4: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2096d8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2096dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2096e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x2096e8; return;
}


// Function: FUN_002096e8
// Address: 0x2096e8 - 0x2096f8

void FUN_002096e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x2096e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x2096ec: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x2096f0: 0xc08256c
    SET_GPR_U32(ctx, 31, 0x2096f8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    FUN_002095b0(rdram, ctx, runtime); return;
}


// Function: entry_2096f8
// Address: 0x2096f8 - 0x209720

void entry_2096f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2096f8) {
        switch (ctx->pc) {
            case 0x209710: ctx->pc = 0; goto label_209710;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2096f8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2096fc: 0x14800004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_209710;
    }
    // 0x209704: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x209708: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x20970c: 0xac62aec8
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
label_209710:
    // 0x209710: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20971c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209720; return;
}


// Function: FUN_00209720
// Address: 0x209720 - 0x209740

void FUN_00209720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209720: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x209724: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x209728: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x20972c: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x209730: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209734: 0xffbf0030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 31));
    // 0x209738: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x209740);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_209740
// Address: 0x209740 - 0x209768

void entry_209740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209740) {
        switch (ctx->pc) {
            case 0x209750: ctx->pc = 0; goto label_209750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209740: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_209750;
    }
    // 0x209748: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2097C0; return;
    }
label_209750:
    // 0x209750: 0x2444ad40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x209754: 0x8c830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 36)));
    // 0x209758: 0x14600005
    SET_GPR_U32(ctx, 7, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209770; return;
    }
    // 0x209760: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209768);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209768
// Address: 0x209768 - 0x20979c

void entry_209768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209768) {
        switch (ctx->pc) {
            case 0x209770: ctx->pc = 0; goto label_209770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209768: 0x10000015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x2097C0; return;
    }
label_209770:
    // 0x209770: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x209774: 0xacf0adc0
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294946240), GPR_U32(ctx, 16));
    // 0x209778: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x20977c: 0x24e7adc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294946240));
    // 0x209780: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x209784: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x209788: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20978c: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x209790: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x209794: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x20979c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_20979c
// Address: 0x20979c - 0x2097bc

void entry_20979c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20979c) {
        switch (ctx->pc) {
            case 0x2097b4: ctx->pc = 0; goto label_2097b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20979c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x2097a0: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_2097b4;
    }
    // 0x2097a8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x2097ac: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_2097bc(rdram, ctx, runtime); return;
    }
label_2097b4:
    // 0x2097b4: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2097bc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2097bc
// Address: 0x2097bc - 0x209870

void entry_2097bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2097bc) {
        switch (ctx->pc) {
            case 0x2097c0: ctx->pc = 0; goto label_2097c0;
            case 0x209808: ctx->pc = 0; goto label_209808;
            case 0x209828: ctx->pc = 0; goto label_209828;
            case 0x20982c: ctx->pc = 0; goto label_20982c;
            case 0x209848: ctx->pc = 0; goto label_209848;
            case 0x209868: ctx->pc = 0; goto label_209868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2097bc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_2097c0:
    // 0x2097c0: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x2097c4: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x2097c8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x2097cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x2097d4: 0x0
    // NOP
    // 0x2097d8: 0x27bd0060
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    // 0x2097dc: 0x0
    // NOP
    // 0x2097e0: 0x3c022000
    SET_GPR_U32(ctx, 2, ((uint32_t)8192 << 16));
    // 0x2097e4: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x2097e8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x2097ec: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        goto label_20982c;
    }
    // 0x2097f4: 0x8c860008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x2097f8: 0x1840000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_209828;
    }
    // 0x209800: 0x24870010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 16));
    // 0x209804: 0x0
    // NOP
label_209808:
    // 0x209808: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x20980c: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x209810: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x209814: 0xa0c30000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x209818: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20981c: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x209820: 0x1440fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_209808;
    }
label_209828:
    // 0x209828: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
label_20982c:
    // 0x20982c: 0x1040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_209868;
    }
    // 0x209834: 0x8c86000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x209838: 0x1840000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_209868;
    }
    // 0x209840: 0x24870050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 80));
    // 0x209844: 0x0
    // NOP
label_209848:
    // 0x209848: 0xe51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x20984c: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x209850: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x209854: 0xa0c30000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x209858: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20985c: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x209860: 0x1440fff9
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_209848;
    }
label_209868:
    // 0x209868: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00209870
// Address: 0x209870 - 0x2098ac

void FUN_00209870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209870: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x209874: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x209878: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x20987c: 0x3c150028
    SET_GPR_U32(ctx, 21, ((uint32_t)40 << 16));
    // 0x209880: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209884: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x209888: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x20988c: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x209890: 0x8ea4aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    // 0x209894: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x209898: 0xffbf0080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 31));
    // 0x20989c: 0xffb60070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 22));
    // 0x2098a0: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x2098a4: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x2098ac);
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_2098ac
// Address: 0x2098ac - 0x2098d4

void entry_2098ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2098ac) {
        switch (ctx->pc) {
            case 0x2098bc: ctx->pc = 0; goto label_2098bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2098ac: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_2098bc;
    }
    // 0x2098b4: 0x1000002b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209964; return;
    }
label_2098bc:
    // 0x2098bc: 0x2456ad40
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x2098c0: 0x8ec30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 36)));
    // 0x2098c4: 0x14600005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2098DC; return;
    }
    // 0x2098cc: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2098d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2098d4
// Address: 0x2098d4 - 0x209904

void entry_2098d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2098d4) {
        switch (ctx->pc) {
            case 0x2098dc: ctx->pc = 0; goto label_2098dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2098d4: 0x10000023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209964; return;
    }
label_2098dc:
    // 0x2098dc: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x2098e0: 0x2610b240
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294947392));
    // 0x2098e4: 0x2451adc0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294946240));
    // 0x2098e8: 0xac54adc0
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294946240), GPR_U32(ctx, 20));
    // 0x2098ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x2098f0: 0xae30001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 16));
    // 0x2098f4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x2098f8: 0xae320018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 18));
    // 0x2098fc: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x209904);
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 19));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_209904
// Address: 0x209904 - 0x209910

void entry_209904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209904: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x209908: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x209910);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 192));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_209910
// Address: 0x209910 - 0x209940

void entry_209910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209910: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x209914: 0x3c0b0021
    SET_GPR_U32(ctx, 11, ((uint32_t)33 << 16));
    // 0x209918: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x20991c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x209920: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x209924: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x209928: 0x256b97e0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294940640));
    // 0x20992c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x209930: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209934: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x209938: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209940);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209940
// Address: 0x209940 - 0x209960

void entry_209940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209940) {
        switch (ctx->pc) {
            case 0x209958: ctx->pc = 0; goto label_209958;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209940: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x209944: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_209958;
    }
    // 0x20994c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x209950: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_209960(rdram, ctx, runtime); return;
    }
label_209958:
    // 0x209958: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209960);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209960
// Address: 0x209960 - 0x209990

void entry_209960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209960) {
        switch (ctx->pc) {
            case 0x209964: ctx->pc = 0; goto label_209964;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209960: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_209964:
    // 0x209964: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x209968: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20996c: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209970: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209974: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209978: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20997c: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209980: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209984: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20998c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209990; return;
}


// Function: FUN_00209990
// Address: 0x209990 - 0x2099c8

void FUN_00209990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209990: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x209994: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x209998: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x20999c: 0x3c140028
    SET_GPR_U32(ctx, 20, ((uint32_t)40 << 16));
    // 0x2099a0: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x2099a4: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x2099a8: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x2099ac: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x2099b0: 0x8e84aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4294946508)));
    // 0x2099b4: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x2099b8: 0xffbf0070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 31));
    // 0x2099bc: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x2099c0: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x2099c8);
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_2099c8
// Address: 0x2099c8 - 0x2099f0

void entry_2099c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2099c8) {
        switch (ctx->pc) {
            case 0x2099d8: ctx->pc = 0; goto label_2099d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2099c8: 0x4410003
    SET_GPR_U32(ctx, 21, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_2099d8;
    }
    // 0x2099d0: 0x10000045
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209AE8; return;
    }
label_2099d8:
    // 0x2099d8: 0x26a2ad40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 4294946112));
    // 0x2099dc: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x2099e0: 0x14600005
    SET_GPR_U32(ctx, 18, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x2099F8; return;
    }
    // 0x2099e8: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x2099f0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_2099f0
// Address: 0x2099f0 - 0x209a9c

void entry_2099f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x2099f0) {
        switch (ctx->pc) {
            case 0x2099f8: ctx->pc = 0; goto label_2099f8;
            case 0x209a18: ctx->pc = 0; goto label_209a18;
            case 0x209a44: ctx->pc = 0; goto label_209a44;
            case 0x209a68: ctx->pc = 0; goto label_209a68;
            case 0x209a90: ctx->pc = 0; goto label_209a90;
            case 0x209a94: ctx->pc = 0; goto label_209a94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x2099f0: 0x1000003d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209AE8; return;
    }
label_2099f8:
    // 0x2099f8: 0x2a020011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 17));
    // 0x2099fc: 0x2646adc0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 4294946240));
    // 0x209a00: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294946240), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_209a18;
    }
    // 0x209a08: 0xacd00014
    WRITE32(ADD32(GPR_U32(ctx, 6), 20), GPR_U32(ctx, 16));
    // 0x209a0c: 0xacc00018
    WRITE32(ADD32(GPR_U32(ctx, 6), 24), GPR_U32(ctx, 0));
    // 0x209a10: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209a44;
    }
label_209a18:
    // 0x209a18: 0x3c03ffff
    SET_GPR_U32(ctx, 3, ((uint32_t)65535 << 16));
    // 0x209a1c: 0x2622ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x209a20: 0x3463fff0
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65520));
    // 0x209a24: 0x2624fff0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294967280));
    // 0x209a28: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x209a2c: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x209a30: 0x2022823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x209a34: 0x2221821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x209a38: 0xacc30018
    WRITE32(ADD32(GPR_U32(ctx, 6), 24), GPR_U32(ctx, 3));
    // 0x209a3c: 0xacc5000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    // 0x209a40: 0xacc20014
    WRITE32(ADD32(GPR_U32(ctx, 6), 20), GPR_U32(ctx, 2));
label_209a44:
    // 0x209a44: 0x2642adc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294946240));
    // 0x209a48: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x209a4c: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x209a50: 0x1060000f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_209a90;
    }
    // 0x209a58: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
    // 0x209a5c: 0x2261021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 6)));
    // 0x209a60: 0x24e4adc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 7), 4294946240));
    // 0x209a64: 0x0
    // NOP
label_209a68:
    // 0x209a68: 0x90450000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x209a6c: 0x861821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x209a70: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x209a74: 0xa0650020
    WRITE8(ADD32(GPR_U32(ctx, 3), 32), (uint8_t)GPR_U32(ctx, 5));
    // 0x209a78: 0x8c820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x209a7c: 0xc2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x209a80: 0x1440fff9
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_209a68;
    }
    // 0x209a88: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209a94;
    }
label_209a90:
    // 0x209a90: 0x3c100063
    SET_GPR_U32(ctx, 16, ((uint32_t)99 << 16));
label_209a94:
    // 0x209a94: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x209a9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_209a9c
// Address: 0x209a9c - 0x209ac4

void entry_209a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209a9c: 0x2609c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 4294951680));
    // 0x209aa0: 0x26a4ad40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4294946112));
    // 0x209aa4: 0x2647adc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 4294946240));
    // 0x209aa8: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x209aac: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x209ab0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209ab4: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x209ab8: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x209abc: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209ac4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209ac4
// Address: 0x209ac4 - 0x209ae4

void entry_209ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209ac4) {
        switch (ctx->pc) {
            case 0x209adc: ctx->pc = 0; goto label_209adc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209ac4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x209ac8: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_209adc;
    }
    // 0x209ad0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x209ad4: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_209ae4(rdram, ctx, runtime); return;
    }
label_209adc:
    // 0x209adc: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209ae4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209ae4
// Address: 0x209ae4 - 0x209b10

void entry_209ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209ae4) {
        switch (ctx->pc) {
            case 0x209ae8: ctx->pc = 0; goto label_209ae8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209ae4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_209ae8:
    // 0x209ae8: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x209aec: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209af0: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209af4: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209af8: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x209afc: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209b00: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209b04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209b0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209b10; return;
}


// Function: FUN_00209b10
// Address: 0x209b10 - 0x209b20

void FUN_00209b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209b10: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x209b14: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x209b18: 0xc07dc74
    SET_GPR_U32(ctx, 31, 0x209b20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    iWakeupThread(rdram, ctx, runtime); return;
}


// Function: entry_209b20
// Address: 0x209b20 - 0x209b38

void entry_209b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209b20: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x209b24: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x209b28: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x209b2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209b34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209b38; return;
}


// Function: FUN_00209b38
// Address: 0x209b38 - 0x209b58

void FUN_00209b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209b38: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x209b3c: 0xffb00000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 16));
    // 0x209b40: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x209b44: 0x3c100021
    SET_GPR_U32(ctx, 16, ((uint32_t)33 << 16));
    // 0x209b48: 0x3091ffff
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 4), 65535));
    // 0x209b4c: 0xffbf0020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 31));
    // 0x209b50: 0xc07daa4
    SET_GPR_U32(ctx, 31, 0x209b58);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294941456));
    GetThreadId(rdram, ctx, runtime); return;
}


// Function: entry_209b58
// Address: 0x209b58 - 0x209b68

void entry_209b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209b58: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x209b5c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x209b60: 0xc07da78
    SET_GPR_U32(ctx, 31, 0x209b68);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetAlarm(rdram, ctx, runtime); return;
}


// Function: entry_209b68
// Address: 0x209b68 - 0x209b80

void entry_209b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209b68: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209b6c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209b70: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x209b74: 0x807daac
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = 0x1f6ab0; return;
    // 0x209b7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209b80; return;
}


// Function: wait_for_sif_rpc_done_2QMARK
// Address: 0x209b80 - 0x209bcc

void entry_209bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209bcc) {
        switch (ctx->pc) {
            case 0x209be8: ctx->pc = 0; goto label_209be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209bcc: 0x1640000c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209C00; return;
    }
    // 0x209bd4: 0x1200000a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209C00; return;
    }
    // 0x209bdc: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_209bf0(rdram, ctx, runtime); return;
    }
    // 0x209be4: 0x0
    // NOP
label_209be8:
    // 0x209be8: 0xc0826ce
    SET_GPR_U32(ctx, 31, 0x209bf0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 60));
    FUN_00209b38(rdram, ctx, runtime); return;
}


// Function: entry_209bf0
// Address: 0x209bf0 - 0x209bf8

void entry_209bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209bf0: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x209bf8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294946112));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_209bf8
// Address: 0x209bf8 - 0x209c38

void entry_209bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209bf8) {
        switch (ctx->pc) {
            case 0x209c00: ctx->pc = 0; goto label_209c00;
            case 0x209c10: ctx->pc = 0; goto label_209c10;
            case 0x209c2c: ctx->pc = 0; goto label_209c2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209bf8: 0x1440fffb
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209BE8; return;
    }
label_209c00:
    // 0x209c00: 0x12800003
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_209c10;
    }
    // 0x209c08: 0x8e62aec8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4294946504)));
    // 0x209c0c: 0xae820000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
label_209c10:
    // 0x209c10: 0x1200000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209C3C; return;
    }
    // 0x209c18: 0x12a00004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294946504), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_209c2c;
    }
    // 0x209c20: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x209c24: 0x8c43c300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294951680)));
    // 0x209c28: 0xaea30000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 3));
label_209c2c:
    // 0x209c2c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x209c30: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209c38);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209c38
// Address: 0x209c38 - 0x209cb8

void entry_209c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209c38) {
        switch (ctx->pc) {
            case 0x209c3c: ctx->pc = 0; goto label_209c3c;
            case 0x209c7c: ctx->pc = 0; goto label_209c7c;
            case 0x209c98: ctx->pc = 0; goto label_209c98;
            case 0x209cac: ctx->pc = 0; goto label_209cac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209c38: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_209c3c:
    // 0x209c3c: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209c40: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209c44: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209c48: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x209c4c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209c50: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209c54: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x209c58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209c60: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x209c64: 0x3c032000
    SET_GPR_U32(ctx, 3, ((uint32_t)8192 << 16));
    // 0x209c68: 0x8c45ad68
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294946152)));
    // 0x209c6c: 0x10a00003
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_209c7c;
    }
    // 0x209c74: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x209c78: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
label_209c7c:
    // 0x209c7c: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x209c80: 0x8c43ad6c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294946156)));
    // 0x209c84: 0x10600004
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_209c98;
    }
    // 0x209c8c: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x209c90: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x209c94: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
label_209c98:
    // 0x209c98: 0x8c43ad70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294946160)));
    // 0x209c9c: 0x10600003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_209cac;
    }
    // 0x209ca4: 0x8c820090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 144)));
    // 0x209ca8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_209cac:
    // 0x209cac: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209cb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209cb8; return;
}


// Function: FUN_00209cb8
// Address: 0x209cb8 - 0x209d00

void FUN_00209cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209cb8: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x209cbc: 0xffb60070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 22));
    // 0x209cc0: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x209cc4: 0x3c160028
    SET_GPR_U32(ctx, 22, ((uint32_t)40 << 16));
    // 0x209cc8: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209ccc: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x209cd0: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x209cd4: 0x100a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x209cd8: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x209cdc: 0xe0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x209ce0: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x209ce4: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x209ce8: 0x8ec4aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4294946508)));
    // 0x209cec: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x209cf0: 0xffbf0090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 31));
    // 0x209cf4: 0xffb70080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 23));
    // 0x209cf8: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x209d00);
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_209d00
// Address: 0x209d00 - 0x209d28

void entry_209d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209d00) {
        switch (ctx->pc) {
            case 0x209d10: ctx->pc = 0; goto label_209d10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209d00: 0x4410003
    SET_GPR_U32(ctx, 23, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_209d10;
    }
    // 0x209d08: 0x10000041
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209E10; return;
    }
label_209d10:
    // 0x209d10: 0x26e2ad40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294946112));
    // 0x209d14: 0x8c430024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x209d18: 0x14600005
    SET_GPR_U32(ctx, 17, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209D30; return;
    }
    // 0x209d20: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209d28);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209d28
// Address: 0x209d28 - 0x209dbc

void entry_209d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209d28) {
        switch (ctx->pc) {
            case 0x209d30: ctx->pc = 0; goto label_209d30;
            case 0x209d58: ctx->pc = 0; goto label_209d58;
            case 0x209d5c: ctx->pc = 0; goto label_209d5c;
            case 0x209d70: ctx->pc = 0; goto label_209d70;
            case 0x209d78: ctx->pc = 0; goto label_209d78;
            case 0x209d8c: ctx->pc = 0; goto label_209d8c;
            case 0x209d94: ctx->pc = 0; goto label_209d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209d28: 0x10000039
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209E10; return;
    }
label_209d30:
    // 0x209d30: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x209d34: 0x2623adc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294946240));
    // 0x209d38: 0x2482b240
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294947392));
    // 0x209d3c: 0xac720004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 18));
    // 0x209d40: 0xac700008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 16));
    // 0x209d44: 0x12600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 28), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_209d58;
    }
    // 0x209d4c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209d50: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209d5c;
    }
label_209d58:
    // 0x209d58: 0xac600014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 0));
label_209d5c:
    // 0x209d5c: 0x12800004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294946240));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_209d70;
    }
    // 0x209d64: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209d68: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209d78;
    }
label_209d70:
    // 0x209d70: 0x2622adc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294946240));
    // 0x209d74: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
label_209d78:
    // 0x209d78: 0x12a00004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294946240));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_209d8c;
    }
    // 0x209d80: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209d84: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_209d94;
    }
label_209d8c:
    // 0x209d8c: 0x2622adc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294946240));
    // 0x209d90: 0xac40000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 0));
label_209d94:
    // 0x209d94: 0x2490b240
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 4294947392));
    // 0x209d98: 0x3c020063
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    // 0x209d9c: 0x3c030063
    SET_GPR_U32(ctx, 3, ((uint32_t)99 << 16));
    // 0x209da0: 0x3c060063
    SET_GPR_U32(ctx, 6, ((uint32_t)99 << 16));
    // 0x209da4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x209da8: 0xac53ad68
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294946152), GPR_U32(ctx, 19));
    // 0x209dac: 0xac74ad6c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946156), GPR_U32(ctx, 20));
    // 0x209db0: 0x240500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 192));
    // 0x209db4: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x209dbc);
    WRITE32(ADD32(GPR_U32(ctx, 6), 4294946160), GPR_U32(ctx, 21));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_209dbc
// Address: 0x209dbc - 0x209dec

void entry_209dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209dbc: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x209dc0: 0x3c0b0021
    SET_GPR_U32(ctx, 11, ((uint32_t)33 << 16));
    // 0x209dc4: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x209dc8: 0x26e4ad40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 4294946112));
    // 0x209dcc: 0x2627adc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 4294946240));
    // 0x209dd0: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x209dd4: 0x256b9c60
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294941792));
    // 0x209dd8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209ddc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209de0: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x209de4: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209dec);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209dec
// Address: 0x209dec - 0x209e0c

void entry_209dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209dec) {
        switch (ctx->pc) {
            case 0x209e04: ctx->pc = 0; goto label_209e04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209dec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x209df0: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_209e04;
    }
    // 0x209df8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209dfc: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_209e0c(rdram, ctx, runtime); return;
    }
label_209e04:
    // 0x209e04: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209e0c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209e0c
// Address: 0x209e0c - 0x209e48

void entry_209e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209e0c) {
        switch (ctx->pc) {
            case 0x209e10: ctx->pc = 0; goto label_209e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209e0c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_209e10:
    // 0x209e10: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x209e14: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x209e18: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x209e1c: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209e20: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209e24: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209e28: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x209e2c: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209e30: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209e34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209e3c: 0x0
    // NOP
    // 0x209e40: 0x27bd0030
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    // 0x209e44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209e48; return;
}


// Function: FUN_00209e48
// Address: 0x209e48 - 0x209e94

void FUN_00209e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209e48: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x209e4c: 0xffb60070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 22));
    // 0x209e50: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x209e54: 0x80b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209e58: 0x3c150028
    SET_GPR_U32(ctx, 21, ((uint32_t)40 << 16));
    // 0x209e5c: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x209e60: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x209e64: 0xe0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x209e68: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x209e6c: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x209e70: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x209e74: 0x120902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x209e78: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x209e7c: 0x100882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x209e80: 0x8ea4aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    // 0x209e84: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x209e88: 0xffbf0090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 31));
    // 0x209e8c: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x209e94);
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 23));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_209e94
// Address: 0x209e94 - 0x209ebc

void entry_209e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209e94) {
        switch (ctx->pc) {
            case 0x209ea4: ctx->pc = 0; goto label_209ea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209e94: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_209ea4;
    }
    // 0x209e9c: 0x10000035
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209F74; return;
    }
label_209ea4:
    // 0x209ea4: 0x2457ad40
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x209ea8: 0x8ee30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 36)));
    // 0x209eac: 0x14600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209EC4; return;
    }
    // 0x209eb4: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209ebc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209ebc
// Address: 0x209ebc - 0x209ee0

void entry_209ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209ebc) {
        switch (ctx->pc) {
            case 0x209ec4: ctx->pc = 0; goto label_209ec4;
            case 0x209ed8: ctx->pc = 0; goto label_209ed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209ebc: 0x1000002d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209F74; return;
    }
label_209ec4:
    // 0x209ec4: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_209ed8;
    }
    // 0x209ecc: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x209ed0: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x209EE8; return;
    }
label_209ed8:
    // 0x209ed8: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209ee0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209ee0
// Address: 0x209ee0 - 0x209f10

void entry_209ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209ee0) {
        switch (ctx->pc) {
            case 0x209ee8: ctx->pc = 0; goto label_209ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209ee0: 0x10000024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967086));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x209F74; return;
    }
label_209ee8:
    // 0x209ee8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x209eec: 0x2450adf0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294946288));
    // 0x209ef0: 0xac56adf0
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294946288), GPR_U32(ctx, 22));
    // 0x209ef4: 0xae130004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 19));
    // 0x209ef8: 0x26040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 20));
    // 0x209efc: 0xae140008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 20));
    // 0x209f00: 0x240603ff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1023));
    // 0x209f04: 0xae11000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
    // 0x209f08: 0xc0805c8
    SET_GPR_U32(ctx, 31, 0x209f10);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 18));
    strncpy(rdram, ctx, runtime); return;
}


// Function: entry_209f10
// Address: 0x209f10 - 0x209f24

void entry_209f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209f10: 0x6200004
    WRITE8(ADD32(GPR_U32(ctx, 16), 1043), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 17) < 0) {
        entry_209f24(rdram, ctx, runtime); return;
    }
    // 0x209f18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x209f1c: 0xc07e9f6
    SET_GPR_U32(ctx, 31, 0x209f24);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 6));
    sceSifWriteBackDCache(rdram, ctx, runtime); return;
}


// Function: entry_209f24
// Address: 0x209f24 - 0x209f50

void entry_209f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209f24: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x209f28: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x209f2c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x209f30: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x209f34: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x209f38: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x209f3c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x209f40: 0x24080414
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1044));
    // 0x209f44: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x209f48: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x209f50);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_209f50
// Address: 0x209f50 - 0x209f70

void entry_209f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209f50) {
        switch (ctx->pc) {
            case 0x209f68: ctx->pc = 0; goto label_209f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209f50: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x209f54: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_209f68;
    }
    // 0x209f5c: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x209f60: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_209f70(rdram, ctx, runtime); return;
    }
label_209f68:
    // 0x209f68: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209f70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209f70
// Address: 0x209f70 - 0x209fa8

void entry_209f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209f70) {
        switch (ctx->pc) {
            case 0x209f74: ctx->pc = 0; goto label_209f74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209f70: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_209f74:
    // 0x209f74: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x209f78: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x209f7c: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x209f80: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x209f84: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x209f88: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x209f8c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x209f90: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x209f94: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x209f98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x209fa0: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x209fa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x209fa8; return;
}


// Function: FUN_00209fa8
// Address: 0x209fa8 - 0x209fd0

void FUN_00209fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x209fa8: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x209fac: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x209fb0: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x209fb4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x209fb8: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x209fbc: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x209fc0: 0x8e24aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    // 0x209fc4: 0xffbf0040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 31));
    // 0x209fc8: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x209fd0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_209fd0
// Address: 0x209fd0 - 0x209ff8

void entry_209fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209fd0) {
        switch (ctx->pc) {
            case 0x209fe0: ctx->pc = 0; goto label_209fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209fd0: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_209fe0;
    }
    // 0x209fd8: 0x1000001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A058; return;
    }
label_209fe0:
    // 0x209fe0: 0x2444ad40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x209fe4: 0x8c830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 36)));
    // 0x209fe8: 0x14600005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A000; return;
    }
    // 0x209ff0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x209ff8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_209ff8
// Address: 0x209ff8 - 0x20a034

void entry_209ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x209ff8) {
        switch (ctx->pc) {
            case 0x20a000: ctx->pc = 0; goto label_20a000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x209ff8: 0x10000017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A058; return;
    }
label_20a000:
    // 0x20a000: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x20a004: 0x2442adc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946240));
    // 0x20a008: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x20a00c: 0xac500008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 16));
    // 0x20a010: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a014: 0xac520004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 18));
    // 0x20a018: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x20a01c: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x20a020: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a024: 0x24080030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 48));
    // 0x20a028: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x20a02c: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x20a034);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_20a034
// Address: 0x20a034 - 0x20a054

void entry_20a034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a034) {
        switch (ctx->pc) {
            case 0x20a04c: ctx->pc = 0; goto label_20a04c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a034: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a038: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_20a04c;
    }
    // 0x20a040: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x20a044: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20a054(rdram, ctx, runtime); return;
    }
label_20a04c:
    // 0x20a04c: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x20a054);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_20a054
// Address: 0x20a054 - 0x20a078

void entry_20a054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a054) {
        switch (ctx->pc) {
            case 0x20a058: ctx->pc = 0; goto label_20a058;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a054: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20a058:
    // 0x20a058: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20a05c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20a060: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20a064: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20a068: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20a070: 0x27bd0040
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    // 0x20a074: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20a078; return;
}


// Function: FUN_0020a078
// Address: 0x20a078 - 0x20a0ac

void FUN_0020a078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a078: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x20a07c: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x20a080: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x20a084: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20a088: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x20a08c: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x20a090: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x20a094: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x20a098: 0x8e24aecc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    // 0x20a09c: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x20a0a0: 0xffbf0060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 31));
    // 0x20a0a4: 0xc07dadc
    SET_GPR_U32(ctx, 31, 0x20a0ac);
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    PollSema(rdram, ctx, runtime); return;
}


// Function: entry_20a0ac
// Address: 0x20a0ac - 0x20a0d4

void entry_20a0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a0ac) {
        switch (ctx->pc) {
            case 0x20a0bc: ctx->pc = 0; goto label_20a0bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a0ac: 0x4410003
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_20a0bc;
    }
    // 0x20a0b4: 0x1000002e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967096));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A170; return;
    }
label_20a0bc:
    // 0x20a0bc: 0x2454ad40
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 4294946112));
    // 0x20a0c0: 0x8e830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x20a0c4: 0x14600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A0DC; return;
    }
    // 0x20a0cc: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x20a0d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_20a0d4
// Address: 0x20a0d4 - 0x20a0f8

void entry_20a0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a0d4) {
        switch (ctx->pc) {
            case 0x20a0dc: ctx->pc = 0; goto label_20a0dc;
            case 0x20a0f0: ctx->pc = 0; goto label_20a0f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a0d4: 0x10000026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A170; return;
    }
label_20a0dc:
    // 0x20a0dc: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_20a0f0;
    }
    // 0x20a0e4: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20a0e8: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)99 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A100; return;
    }
label_20a0f0:
    // 0x20a0f0: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x20a0f8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_20a0f8
// Address: 0x20a0f8 - 0x20a11c

void entry_20a0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a0f8) {
        switch (ctx->pc) {
            case 0x20a100: ctx->pc = 0; goto label_20a100;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a0f8: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967086));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A170; return;
    }
label_20a100:
    // 0x20a100: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20a104: 0x2450adf0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294946288));
    // 0x20a108: 0xac53adf0
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294946288), GPR_U32(ctx, 19));
    // 0x20a10c: 0xae120004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
    // 0x20a110: 0x26040014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 20));
    // 0x20a114: 0xc0805c8
    SET_GPR_U32(ctx, 31, 0x20a11c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1023));
    strncpy(rdram, ctx, runtime); return;
}


// Function: entry_20a11c
// Address: 0x20a11c - 0x20a14c

void entry_20a11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a11c: 0xa2000413
    WRITE8(ADD32(GPR_U32(ctx, 16), 1043), (uint8_t)GPR_U32(ctx, 0));
    // 0x20a120: 0x3c090063
    SET_GPR_U32(ctx, 9, ((uint32_t)99 << 16));
    // 0x20a124: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20a128: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x20a12c: 0x2529c300
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294951680));
    // 0x20a130: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x20a134: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x20a138: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a13c: 0x24080414
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1044));
    // 0x20a140: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x20a144: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x20a14c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_20a14c
// Address: 0x20a14c - 0x20a16c

void entry_20a14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a14c) {
        switch (ctx->pc) {
            case 0x20a164: ctx->pc = 0; goto label_20a164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a14c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a150: 0x16000004
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_20a164;
    }
    // 0x20a158: 0x24020012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    // 0x20a15c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294946504), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20a16c(rdram, ctx, runtime); return;
    }
label_20a164:
    // 0x20a164: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x20a16c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294946508)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_20a16c
// Address: 0x20a16c - 0x20a190

void entry_20a16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a16c) {
        switch (ctx->pc) {
            case 0x20a170: ctx->pc = 0; goto label_20a170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a16c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20a170:
    // 0x20a170: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20a174: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20a178: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20a17c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20a180: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20a184: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20a188: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _type2id
// Address: 0x20a190 - 0x20a220

void entry_20a280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a280) {
        switch (ctx->pc) {
            case 0x20a2a0: ctx->pc = 0; goto label_20a2a0;
            case 0x20a2d4: ctx->pc = 0; goto label_20a2d4;
            case 0x20a2f0: ctx->pc = 0; goto label_20a2f0;
            case 0x20a2f8: ctx->pc = 0; goto label_20a2f8;
            case 0x20a2fc: ctx->pc = 0; goto label_20a2fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a280: 0xafa000a4
    WRITE32(ADD32(GPR_U32(ctx, 29), 164), GPR_U32(ctx, 0));
    // 0x20a284: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x20a288: 0x8e840048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 72)));
    // 0x20a28c: 0xafa000ac
    WRITE32(ADD32(GPR_U32(ctx, 29), 172), GPR_U32(ctx, 0));
    // 0x20a290: 0x18800017
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_20a2f0;
    }
    // 0x20a298: 0x10b0c0
    SET_GPR_U32(ctx, 22, SLL32(GPR_U32(ctx, 16), 3));
    // 0x20a29c: 0x8fa300a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 168)));
label_20a2a0:
    // 0x20a2a0: 0x24020018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    // 0x20a2a4: 0x3404bdff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 48639));
    // 0x20a2a8: 0x42638
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 24);
    // 0x20a2ac: 0x600013
    ctx->lo = GPR_U32(ctx, 3);
    // 0x20a2b0: 0x72621000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20a2b4: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20a2b8: 0x54640006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
        goto label_20a2d4;
    }
    // 0x20a2c0: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x20a2c4: 0xafa300a4
    WRITE32(ADD32(GPR_U32(ctx, 29), 164), GPR_U32(ctx, 3));
    // 0x20a2c8: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x20a2cc: 0xafa200a0
    WRITE32(ADD32(GPR_U32(ctx, 29), 160), GPR_U32(ctx, 2));
    // 0x20a2d0: 0x8fa200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
label_20a2d4:
    // 0x20a2d4: 0x14400008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20a2f8;
    }
    // 0x20a2dc: 0x265102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 5)));
    // 0x20a2e0: 0x1440ffef
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 168)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20a2a0;
    }
    // 0x20a2e8: 0x10000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20a2fc;
    }
label_20a2f0:
    // 0x20a2f0: 0x10b0c0
    SET_GPR_U32(ctx, 22, SLL32(GPR_U32(ctx, 16), 3));
    // 0x20a2f4: 0x0
    // NOP
label_20a2f8:
    // 0x20a2f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_20a2fc:
    // 0x20a2fc: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a304);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a304
// Address: 0x20a304 - 0x20a31c

void entry_20a304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a304: 0x240301ba
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 442));
    // 0x20a308: 0x14430055
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x20A460; return;
    }
    // 0x20a310: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a314: 0xc08298c
    SET_GPR_U32(ctx, 31, 0x20a31c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    _pack_header(rdram, ctx, runtime); return;
}


// Function: entry_20a31c
// Address: 0x20a31c - 0x20a334

void entry_20a31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a31c) {
        switch (ctx->pc) {
            case 0x20a328: ctx->pc = 0; goto label_20a328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a31c: 0x10000050
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A460; return;
    }
    // 0x20a324: 0x0
    // NOP
label_20a328:
    // 0x20a328: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a32c: 0xc0845e8
    SET_GPR_U32(ctx, 31, 0x20a334);
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 30));
    _sysbitPtr(rdram, ctx, runtime); return;
}


// Function: entry_20a334
// Address: 0x20a334 - 0x20a344

void entry_20a334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a334: 0x8e450038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x20a338: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a33c: 0xc0845e8
    SET_GPR_U32(ctx, 31, 0x20a344);
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 2));
    _sysbitPtr(rdram, ctx, runtime); return;
}


// Function: entry_20a344
// Address: 0x20a344 - 0x20a374

void entry_20a344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a344: 0xde430028
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 40)));
    // 0x20a348: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20a34c: 0x8e48003c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x20a350: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x20a354: 0xffa30090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 3));
    // 0x20a358: 0xde430030
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x20a35c: 0x8e060014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x20a360: 0x8e070010
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x20a364: 0xafa20088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 2));
    // 0x20a368: 0xafa8008c
    WRITE32(ADD32(GPR_U32(ctx, 29), 140), GPR_U32(ctx, 8));
    // 0x20a36c: 0xe0f809
    SET_GPR_U32(ctx, 31, 0x20a374);
    WRITE64(ADD32(GPR_U32(ctx, 29), 152), GPR_U64(ctx, 3));
    ctx->pc = GPR_U32(ctx, 7); return;
}


// Function: entry_20a374
// Address: 0x20a374 - 0x20a38c

void entry_20a374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a374) {
        switch (ctx->pc) {
            case 0x20a380: ctx->pc = 0; goto label_20a380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a374: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a378: 0x1000001b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 72)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A3E8; return;
    }
label_20a380:
    // 0x20a380: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a384: 0xc0829fc
    SET_GPR_U32(ctx, 31, 0x20a38c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 24));
    fn__PES_packet(rdram, ctx, runtime); return;
}


// Function: entry_20a38c
// Address: 0x20a38c - 0x20a404

void entry_20a38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a38c) {
        switch (ctx->pc) {
            case 0x20a3b8: ctx->pc = 0; goto label_20a3b8;
            case 0x20a3e8: ctx->pc = 0; goto label_20a3e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a38c: 0xde230018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x20a390: 0x203182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x20a394: 0x14600033
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A464; return;
    }
    // 0x20a39c: 0x8e840048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 72)));
    // 0x20a3a0: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20a3a4: 0x18800010
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_20a3e8;
    }
    // 0x20a3ac: 0xde450018
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x20a3b0: 0x8fa300a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 168)));
    // 0x20a3b4: 0x0
    // NOP
label_20a3b8:
    // 0x20a3b8: 0x24020018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    // 0x20a3bc: 0x600013
    ctx->lo = GPR_U32(ctx, 3);
    // 0x20a3c0: 0x72628000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20a3c4: 0xde030008
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x20a3c8: 0xde020000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20a3cc: 0xa31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20a3d0: 0x5043ffd5
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 64)));
        ctx->pc = 0x20A328; return;
    }
    // 0x20a3d8: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x20a3dc: 0x266102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 6)));
    // 0x20a3e0: 0x1440fff5
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 168)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20a3b8;
    }
label_20a3e8:
    // 0x20a3e8: 0x16640017
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x20A448; return;
    }
    // 0x20a3f0: 0x10400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A448; return;
    }
    // 0x20a3f8: 0x8e450040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x20a3fc: 0xc0845e8
    SET_GPR_U32(ctx, 31, 0x20a404);
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 30));
    _sysbitPtr(rdram, ctx, runtime); return;
}


// Function: entry_20a404
// Address: 0x20a404 - 0x20a414

void entry_20a404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a404: 0x8e450038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 56)));
    // 0x20a408: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a40c: 0xc0845e8
    SET_GPR_U32(ctx, 31, 0x20a414);
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 2));
    _sysbitPtr(rdram, ctx, runtime); return;
}


// Function: entry_20a414
// Address: 0x20a414 - 0x20a444

void entry_20a414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a414: 0xde430028
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 40)));
    // 0x20a418: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20a41c: 0x8e47003c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x20a420: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x20a424: 0xffa30090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 3));
    // 0x20a428: 0xafa20088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 2));
    // 0x20a42c: 0xde420030
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x20a430: 0x8fa600a4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    // 0x20a434: 0x8fa300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20a438: 0xafa7008c
    WRITE32(ADD32(GPR_U32(ctx, 29), 140), GPR_U32(ctx, 7));
    // 0x20a43c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x20a444);
    WRITE64(ADD32(GPR_U32(ctx, 29), 152), GPR_U64(ctx, 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_20a444
// Address: 0x20a444 - 0x20a46c

void entry_20a444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a444) {
        switch (ctx->pc) {
            case 0x20a448: ctx->pc = 0; goto label_20a448;
            case 0x20a460: ctx->pc = 0; goto label_20a460;
            case 0x20a464: ctx->pc = 0; goto label_20a464;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a444: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_20a448:
    // 0x20a448: 0x12a00006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_20a464;
    }
    // 0x20a450: 0xde220018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x20a454: 0x21778
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 29);
    // 0x20a458: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20a45c: 0xafa200ac
    WRITE32(ADD32(GPR_U32(ctx, 29), 172), GPR_U32(ctx, 2));
label_20a460:
    // 0x20a460: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_20a464:
    // 0x20a464: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a46c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a46c
// Address: 0x20a46c - 0x20a480

void entry_20a46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a46c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a470: 0x14430013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x20A4C0; return;
    }
    // 0x20a478: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a480);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a480
// Address: 0x20a480 - 0x20a494

void entry_20a480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a480: 0x240301ba
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 442));
    // 0x20a484: 0x1043000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x20A4C0; return;
    }
    // 0x20a48c: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a494);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a494
// Address: 0x20a494 - 0x20a4d8

void entry_20a494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a494) {
        switch (ctx->pc) {
            case 0x20a4c0: ctx->pc = 0; goto label_20a4c0;
            case 0x20a4c8: ctx->pc = 0; goto label_20a4c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a494: 0x240301b9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 441));
    // 0x20a498: 0x10430009
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_20a4c0;
    }
    // 0x20a4a0: 0xde230018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x20a4a4: 0x70102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x20a4a8: 0x10400007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20a4c8;
    }
    // 0x20a4b0: 0x16a0ffb3
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A380; return;
    }
    // 0x20a4b8: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20a4c8;
    }
label_20a4c0:
    // 0x20a4c0: 0xde230018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x20a4c4: 0x2c3102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 3)));
label_20a4c8:
    // 0x20a4c8: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A4E4; return;
    }
    // 0x20a4d0: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a4d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a4d8
// Address: 0x20a4d8 - 0x20a518

void entry_20a4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a4d8) {
        switch (ctx->pc) {
            case 0x20a4e4: ctx->pc = 0; goto label_20a4e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a4d8: 0x240301ba
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 442));
    // 0x20a4dc: 0x1043ff87
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x20A2FC; return;
    }
label_20a4e4:
    // 0x20a4e4: 0x8fa200ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 172)));
    // 0x20a4e8: 0xdfbf0140
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x20a4ec: 0xdfbe0130
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x20a4f0: 0xdfb70120
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x20a4f4: 0xdfb60110
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x20a4f8: 0xdfb50100
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x20a4fc: 0xdfb400f0
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x20a500: 0xdfb300e0
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x20a504: 0xdfb200d0
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x20a508: 0xdfb100c0
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x20a50c: 0xdfb000b0
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20a510: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceMpegDemuxPss
// Address: 0x20a518 - 0x20a52c

void entry_20a52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a52c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20a530: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: sceMpegAddStrCallback
// Address: 0x20a538 - 0x20a57c

void entry_20a57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a57c) {
        switch (ctx->pc) {
            case 0x20a5a0: ctx->pc = 0; goto label_20a5a0;
            case 0x20a5c4: ctx->pc = 0; goto label_20a5c4;
            case 0x20a604: ctx->pc = 0; goto label_20a604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a57c: 0x8e450048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x20a580: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a584: 0x18a0000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_20a5c4;
    }
    // 0x20a58c: 0xde020000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20a590: 0x54c20003
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_20a5a0;
    }
    // 0x20a598: 0x1000000a
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20a5c4;
    }
label_20a5a0:
    // 0x20a5a0: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x20a5a4: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20a5c4;
    }
    // 0x20a5ac: 0x821818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20a5b0: 0x701021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x20a5b4: 0xdc430000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20a5b8: 0x54c3fff9
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_20a5a0;
    }
    // 0x20a5c0: 0x8c510010
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 16)));
label_20a5c4:
    // 0x20a5c4: 0x28820040
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 64));
    // 0x20a5c8: 0x1040000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 24));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20a604;
    }
    // 0x20a5d0: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x20a5d4: 0x833818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20a5d8: 0x2442aed0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946512));
    // 0x20a5dc: 0x132100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 19), 4));
    // 0x20a5e0: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x20a5e4: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20a5e8: 0xae450048
    WRITE32(ADD32(GPR_U32(ctx, 18), 72), GPR_U32(ctx, 5));
    // 0x20a5ec: 0xf01821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 16)));
    // 0x20a5f0: 0xfc660000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 6));
    // 0x20a5f4: 0xac740014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 20));
    // 0x20a5f8: 0xdc440008
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x20a5fc: 0xac750010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 21));
    // 0x20a600: 0xfc640008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 4));
label_20a604:
    // 0x20a604: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20a608: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20a60c: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20a610: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20a614: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20a618: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20a61c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20a620: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20a624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20a62c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20a630; return;
}


// Function: _pack_header
// Address: 0x20a630 - 0x20a668

void entry_20a668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a668: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a66c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a674);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a674
// Address: 0x20a674 - 0x20a680

void entry_20a674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a674: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a678: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a680);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a680
// Address: 0x20a680 - 0x20a68c

void entry_20a680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a680: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a684: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a68c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a68c
// Address: 0x20a68c - 0x20a698

void entry_20a68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a68c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a690: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a698);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a698
// Address: 0x20a698 - 0x20a6a4

void entry_20a698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a698: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a69c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a6a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a6a4
// Address: 0x20a6a4 - 0x20a6b0

void entry_20a6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a6a4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a6a8: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a6b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a6b0
// Address: 0x20a6b0 - 0x20a6bc

void entry_20a6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a6b0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a6b4: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a6bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a6bc
// Address: 0x20a6bc - 0x20a6cc

void entry_20a6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a6bc: 0xaec20000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    // 0x20a6c0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a6c4: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a6cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 30));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a6cc
// Address: 0x20a6cc - 0x20a6d8

void entry_20a6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a6cc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a6d0: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a6d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a6d8
// Address: 0x20a6d8 - 0x20a710

void entry_20a6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a6d8) {
        switch (ctx->pc) {
            case 0x20a708: ctx->pc = 0; goto label_20a708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a6d8: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a6dc: 0x118bc0
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 15));
    // 0x20a6e0: 0x101780
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 30));
    // 0x20a6e4: 0x108082
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 16), 2));
    // 0x20a6e8: 0x511025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x20a6ec: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x20a6f0: 0x521025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x20a6f4: 0xaed00008
    WRITE32(ADD32(GPR_U32(ctx, 22), 8), GPR_U32(ctx, 16));
    // 0x20a6f8: 0x12800009
    WRITE32(ADD32(GPR_U32(ctx, 22), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A720; return;
    }
    // 0x20a700: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a704: 0x0
    // NOP
label_20a708:
    // 0x20a708: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a710);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a710
// Address: 0x20a710 - 0x20a72c

void entry_20a710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a710) {
        switch (ctx->pc) {
            case 0x20a720: ctx->pc = 0; goto label_20a720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a710: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x20a714: 0x2b4102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), GPR_U32(ctx, 20)));
    // 0x20a718: 0x1440fffb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A708; return;
    }
label_20a720:
    // 0x20a720: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a724: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a72c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a72c
// Address: 0x20a72c - 0x20a74c

void entry_20a72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a72c: 0x240301bb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 443));
    // 0x20a730: 0x54430008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 22), 12), GPR_U32(ctx, 0));
        ctx->pc = 0x20A754; return;
    }
    // 0x20a738: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a73c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a740: 0xaec2000c
    WRITE32(ADD32(GPR_U32(ctx, 22), 12), GPR_U32(ctx, 2));
    // 0x20a744: 0xc0829e0
    SET_GPR_U32(ctx, 31, 0x20a74c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _system_header(rdram, ctx, runtime); return;
}


// Function: entry_20a74c
// Address: 0x20a74c - 0x20a780

void entry_20a74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a74c) {
        switch (ctx->pc) {
            case 0x20a754: ctx->pc = 0; goto label_20a754;
            case 0x20a758: ctx->pc = 0; goto label_20a758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a74c: 0x10000002
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20a758;
    }
label_20a754:
    // 0x20a754: 0xdfbf0070
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
label_20a758:
    // 0x20a758: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a75c: 0xdfb60060
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20a760: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20a764: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20a768: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20a76c: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20a770: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20a774: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20a778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _system_header
// Address: 0x20a780 - 0x20a79c

void entry_20a79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a79c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a7a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20a7a4: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a7ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 40));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a7ac
// Address: 0x20a7ac - 0x20a7c4

void entry_20a7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a7ac) {
        switch (ctx->pc) {
            case 0x20a7b8: ctx->pc = 0; goto label_20a7b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a7ac: 0x10000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20A7C8; return;
    }
    // 0x20a7b4: 0x0
    // NOP
label_20a7b8:
    // 0x20a7b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20a7bc: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a7c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a7c4
// Address: 0x20a7c4 - 0x20a7d0

void entry_20a7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a7c4) {
        switch (ctx->pc) {
            case 0x20a7c8: ctx->pc = 0; goto label_20a7c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a7c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20a7c8:
    // 0x20a7c8: 0xc08457e
    SET_GPR_U32(ctx, 31, 0x20a7d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitNext(rdram, ctx, runtime); return;
}


// Function: entry_20a7d0
// Address: 0x20a7d0 - 0x20a7f0

void entry_20a7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a7d0: 0x1051fff9
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x20A7B8; return;
    }
    // 0x20a7d8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20a7dc: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20a7e0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20a7e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20a7ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20a7f0; return;
}


// Function: fn__PES_packet
// Address: 0x20a7f0 - 0x20a864

void entry_20a864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a864: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a868: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a870);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a870
// Address: 0x20a870 - 0x20a884

void entry_20a870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a870: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20a874: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a878: 0xfe820000
    WRITE64(ADD32(GPR_U32(ctx, 20), 0), GPR_U64(ctx, 2));
    // 0x20a87c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a884);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a884
// Address: 0x20a884 - 0x20a924

void entry_20a884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a884: 0xde840000
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x20a888: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20a88c: 0xae820008
    WRITE32(ADD32(GPR_U32(ctx, 20), 8), GPR_U32(ctx, 2));
    // 0x20a890: 0x3402bc00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48128));
    // 0x20a894: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a898: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20a89c: 0xfe830010
    WRITE64(ADD32(GPR_U32(ctx, 20), 16), GPR_U64(ctx, 3));
    // 0x20a8a0: 0x10820115
    WRITE64(ADD32(GPR_U32(ctx, 20), 24), GPR_U64(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20ACF8; return;
    }
    // 0x20a8a8: 0x3402be00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48640));
    // 0x20a8ac: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a8b0: 0x108200f5
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a8b8: 0x3402bf00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48896));
    // 0x20a8bc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a8c0: 0x108200f1
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a8c8: 0x3402f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61440));
    // 0x20a8cc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a8d0: 0x108200ed
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a8d8: 0x3402f100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61696));
    // 0x20a8dc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a8e0: 0x108200e9
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a8e8: 0x3402ff00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65280));
    // 0x20a8ec: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a8f0: 0x108200e5
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a8f8: 0x3402f200
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61952));
    // 0x20a8fc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a900: 0x108200e1
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a908: 0x3402f800
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 63488));
    // 0x20a90c: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20a910: 0x108200dd
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AC88; return;
    }
    // 0x20a918: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a91c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a924);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a924
// Address: 0x20a924 - 0x20a930

void entry_20a924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a924: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a928: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a930);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a930
// Address: 0x20a930 - 0x20a940

void entry_20a930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a930: 0xae82000c
    WRITE32(ADD32(GPR_U32(ctx, 20), 12), GPR_U32(ctx, 2));
    // 0x20a934: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a938: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a940);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a940
// Address: 0x20a940 - 0x20a94c

void entry_20a940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a940: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a944: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a94c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a94c
// Address: 0x20a94c - 0x20a95c

void entry_20a94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a94c: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a950: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a954: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a95c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a95c
// Address: 0x20a95c - 0x20a96c

void entry_20a95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a95c: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x20a960: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a964: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a96c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a96c
// Address: 0x20a96c - 0x20a97c

void entry_20a96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a96c: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a970: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a974: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a97c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a97c
// Address: 0x20a97c - 0x20a98c

void entry_20a97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a97c: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a980: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a984: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a98c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a98c
// Address: 0x20a98c - 0x20a9b4

void entry_20a98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a98c: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x20a990: 0x32e30002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 23), 2));
    // 0x20a994: 0xde620018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x20a998: 0x2b03c
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20a99c: 0x16b03f
    SET_GPR_S64(ctx, 22, GPR_S64(ctx, 22) >> (32 + 0));
    // 0x20a9a0: 0x10600022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AA2C; return;
    }
    // 0x20a9a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a9ac: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a9b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a9b4
// Address: 0x20a9b4 - 0x20a9c0

void entry_20a9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9b4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a9b8: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a9c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a9c0
// Address: 0x20a9c0 - 0x20a9cc

void entry_20a9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9c0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a9c4: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a9cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a9cc
// Address: 0x20a9cc - 0x20a9d8

void entry_20a9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9cc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a9d0: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a9d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a9d8
// Address: 0x20a9d8 - 0x20a9e4

void entry_20a9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9d8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a9dc: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a9e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a9e4
// Address: 0x20a9e4 - 0x20a9f0

void entry_20a9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9e4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20a9e8: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20a9f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20a9f0
// Address: 0x20a9f0 - 0x20a9fc

void entry_20a9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20a9f0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20a9f4: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20a9fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20a9fc
// Address: 0x20a9fc - 0x20aa40

void entry_20a9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20a9fc) {
        switch (ctx->pc) {
            case 0x20aa2c: ctx->pc = 0; goto label_20aa2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20a9fc: 0x101780
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 30));
    // 0x20aa00: 0x118bc0
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 15));
    // 0x20aa04: 0x511025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x20aa08: 0x108082
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 16), 2));
    // 0x20aa0c: 0x521025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x20aa10: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x20aa14: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20aa18: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x20aa1c: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x20aa20: 0x2028025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20aa24: 0xfe900010
    WRITE64(ADD32(GPR_U32(ctx, 20), 16), GPR_U64(ctx, 16));
    // 0x20aa28: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_20aa2c:
    // 0x20aa2c: 0x16e20022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AAB8; return;
    }
    // 0x20aa34: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aa38: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aa40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aa40
// Address: 0x20aa40 - 0x20aa4c

void entry_20aa40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa40: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aa44: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aa4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aa4c
// Address: 0x20aa4c - 0x20aa58

void entry_20aa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa4c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20aa50: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20aa58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20aa58
// Address: 0x20aa58 - 0x20aa64

void entry_20aa58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa58: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aa5c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aa64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aa64
// Address: 0x20aa64 - 0x20aa70

void entry_20aa64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa64: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20aa68: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20aa70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20aa70
// Address: 0x20aa70 - 0x20aa7c

void entry_20aa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa70: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aa74: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aa7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aa7c
// Address: 0x20aa7c - 0x20aa88

void entry_20aa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aa7c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20aa80: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20aa88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20aa88
// Address: 0x20aa88 - 0x20aacc

void entry_20aa88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20aa88) {
        switch (ctx->pc) {
            case 0x20aab8: ctx->pc = 0; goto label_20aab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20aa88: 0x101780
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 30));
    // 0x20aa8c: 0x118bc0
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 15));
    // 0x20aa90: 0x511025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x20aa94: 0x108082
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 16), 2));
    // 0x20aa98: 0x521025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x20aa9c: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x20aaa0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20aaa4: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x20aaa8: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x20aaac: 0x2028025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20aab0: 0xfe900018
    WRITE64(ADD32(GPR_U32(ctx, 20), 24), GPR_U64(ctx, 16));
    // 0x20aab4: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_20aab8:
    // 0x20aab8: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20aabc: 0x14500003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        entry_20aacc(rdram, ctx, runtime); return;
    }
    // 0x20aac4: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aacc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 48));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aacc
// Address: 0x20aacc - 0x20aae0

void entry_20aacc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aacc: 0x13c00004
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 30)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_20aae0(rdram, ctx, runtime); return;
    }
    // 0x20aad4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aad8: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aae0);
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aae0
// Address: 0x20aae0 - 0x20aaf4

void entry_20aae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aae0: 0x16b00045
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x20ABF8; return;
    }
    // 0x20aae8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aaec: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aaf4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aaf4
// Address: 0x20aaf4 - 0x20ab04

void entry_20aaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aaf4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20aaf8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20aafc: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab04
// Address: 0x20ab04 - 0x20ab14

void entry_20ab04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab04: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20ab08: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab0c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab14
// Address: 0x20ab14 - 0x20ab24

void entry_20ab14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab14: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20ab18: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab1c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab24
// Address: 0x20ab24 - 0x20ab34

void entry_20ab24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab24: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20ab28: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab2c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab34
// Address: 0x20ab34 - 0x20ab40

void entry_20ab34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab34: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab38: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab40
// Address: 0x20ab40 - 0x20ab54

void entry_20ab40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab40: 0x1615000a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 21)) {
        entry_20ab6c(rdram, ctx, runtime); return;
    }
    // 0x20ab48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab4c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 48));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab54
// Address: 0x20ab54 - 0x20ab60

void entry_20ab54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab54: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab58: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 48));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab60
// Address: 0x20ab60 - 0x20ab6c

void entry_20ab60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab60: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ab64: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab6c
// Address: 0x20ab6c - 0x20ab80

void entry_20ab6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab6c: 0x17d50006
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x20AB88; return;
    }
    // 0x20ab74: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20ab78: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20ab80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 56));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20ab80
// Address: 0x20ab80 - 0x20ab98

void entry_20ab80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ab80) {
        switch (ctx->pc) {
            case 0x20ab88: ctx->pc = 0; goto label_20ab88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ab80: 0x1000007b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD70; return;
    }
label_20ab88:
    // 0x20ab88: 0x16550003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 21)) {
        entry_20ab98(rdram, ctx, runtime); return;
    }
    // 0x20ab90: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ab98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ab98
// Address: 0x20ab98 - 0x20aba8

void entry_20ab98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ab98: 0x16f50003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 21)) {
        entry_20aba8(rdram, ctx, runtime); return;
    }
    // 0x20aba0: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20aba8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20aba8
// Address: 0x20aba8 - 0x20abbc

void entry_20aba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aba8: 0x16350013
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x20ABF8; return;
    }
    // 0x20abb0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20abb4: 0xc0845c0
    SET_GPR_U32(ctx, 31, 0x20abbc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _sysbitMarker(rdram, ctx, runtime); return;
}


// Function: entry_20abbc
// Address: 0x20abbc - 0x20abc8

void entry_20abbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20abbc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20abc0: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20abc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20abc8
// Address: 0x20abc8 - 0x20abe0

void entry_20abc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20abc8) {
        switch (ctx->pc) {
            case 0x20abd8: ctx->pc = 0; goto label_20abd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20abc8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20abcc: 0x1220000a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20ABF8; return;
    }
    // 0x20abd4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_20abd8:
    // 0x20abd8: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20abe0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20abe0
// Address: 0x20abe0 - 0x20ac20

void entry_20abe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20abe0) {
        switch (ctx->pc) {
            case 0x20abf8: ctx->pc = 0; goto label_20abf8;
            case 0x20abfc: ctx->pc = 0; goto label_20abfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20abe0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x20abe4: 0x211102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x20abe8: 0x1440fffb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20ABD8; return;
    }
    // 0x20abf0: 0x10000002
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20abfc;
    }
label_20abf8:
    // 0x20abf8: 0xde620018
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 24)));
label_20abfc:
    // 0x20abfc: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x20ac00: 0x52102f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) - GPR_U64(ctx, 18));
    // 0x20ac04: 0x21778
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 29);
    // 0x20ac08: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20ac0c: 0x622823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20ac10: 0x50a00004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 24)));
        ctx->pc = 0x20AC24; return;
    }
    // 0x20ac18: 0xc0845d2
    SET_GPR_U32(ctx, 31, 0x20ac20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitJump(rdram, ctx, runtime); return;
}


// Function: entry_20ac20
// Address: 0x20ac20 - 0x20ac58

void entry_20ac20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ac20) {
        switch (ctx->pc) {
            case 0x20ac24: ctx->pc = 0; goto label_20ac24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ac20: 0x8fa50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 24)));
label_20ac24:
    // 0x20ac24: 0x3404bd00
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 48384));
    // 0x20ac28: 0x42638
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 24);
    // 0x20ac2c: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x20ac30: 0xde830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x20ac34: 0x458023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x20ac38: 0x2605fffd
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4294967293));
    // 0x20ac3c: 0xae850024
    WRITE32(ADD32(GPR_U32(ctx, 20), 36), GPR_U32(ctx, 5));
    // 0x20ac40: 0x8e620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x20ac44: 0x1464000a
    WRITE32(ADD32(GPR_U32(ctx, 20), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x20AC70; return;
    }
    // 0x20ac4c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ac50: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ac58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ac58
// Address: 0x20ac58 - 0x20ac80

void entry_20ac58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ac58) {
        switch (ctx->pc) {
            case 0x20ac70: ctx->pc = 0; goto label_20ac70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ac58: 0xde830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x20ac5c: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20ac60: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x20ac64: 0x2605fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4294967289));
    // 0x20ac68: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20ac6c: 0xfe830000
    WRITE64(ADD32(GPR_U32(ctx, 20), 0), GPR_U64(ctx, 3));
label_20ac70:
    // 0x20ac70: 0x10a0003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD70; return;
    }
    // 0x20ac78: 0xc0845d2
    SET_GPR_U32(ctx, 31, 0x20ac80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitJump(rdram, ctx, runtime); return;
}


// Function: entry_20ac80
// Address: 0x20ac80 - 0x20ad14

void entry_20ac80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ac80) {
        switch (ctx->pc) {
            case 0x20ac88: ctx->pc = 0; goto label_20ac88;
            case 0x20acf8: ctx->pc = 0; goto label_20acf8;
            case 0x20ad00: ctx->pc = 0; goto label_20ad00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ac80: 0x1000003b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD70; return;
    }
label_20ac88:
    // 0x20ac88: 0x3402bc00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48128));
    // 0x20ac8c: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20ac90: 0x10a20019
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_20acf8;
    }
    // 0x20ac98: 0x3402bf00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48896));
    // 0x20ac9c: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20aca0: 0x10820017
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_20ad00;
    }
    // 0x20aca8: 0x3402f000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61440));
    // 0x20acac: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20acb0: 0x10820011
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_20acf8;
    }
    // 0x20acb8: 0x3402f100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61696));
    // 0x20acbc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20acc0: 0x1082000d
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_20acf8;
    }
    // 0x20acc8: 0x3402ff00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65280));
    // 0x20accc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20acd0: 0x10820009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_20acf8;
    }
    // 0x20acd8: 0x3402f200
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 61952));
    // 0x20acdc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20ace0: 0x10820005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_20acf8;
    }
    // 0x20ace8: 0x3402f800
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 63488));
    // 0x20acec: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20acf0: 0x14820015
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AD48; return;
    }
label_20acf8:
    // 0x20acf8: 0x3402bf00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48896));
    // 0x20acfc: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
label_20ad00:
    // 0x20ad00: 0x14a2000a
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AD2C; return;
    }
    // 0x20ad08: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ad0c: 0xc0845ac
    SET_GPR_U32(ctx, 31, 0x20ad14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sysbitGet(rdram, ctx, runtime); return;
}


// Function: entry_20ad14
// Address: 0x20ad14 - 0x20ad40

void entry_20ad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ad14) {
        switch (ctx->pc) {
            case 0x20ad2c: ctx->pc = 0; goto label_20ad2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ad14: 0x2610fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967292));
    // 0x20ad18: 0xde830000
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x20ad1c: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20ad20: 0x2103e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 0));
    // 0x20ad24: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20ad28: 0xfe830000
    WRITE64(ADD32(GPR_U32(ctx, 20), 0), GPR_U64(ctx, 3));
label_20ad2c:
    // 0x20ad2c: 0x12000010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD70; return;
    }
    // 0x20ad34: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ad38: 0xc0845d2
    SET_GPR_U32(ctx, 31, 0x20ad40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sysbitJump(rdram, ctx, runtime); return;
}


// Function: entry_20ad40
// Address: 0x20ad40 - 0x20ad6c

void entry_20ad40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ad40) {
        switch (ctx->pc) {
            case 0x20ad48: ctx->pc = 0; goto label_20ad48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ad40: 0x1000000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD70; return;
    }
label_20ad48:
    // 0x20ad48: 0x3402be00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 48640));
    // 0x20ad4c: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x20ad50: 0x14820007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20AD70; return;
    }
    // 0x20ad58: 0x8e850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x20ad5c: 0x10a00005
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AD74; return;
    }
    // 0x20ad64: 0xc0845d2
    SET_GPR_U32(ctx, 31, 0x20ad6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _sysbitJump(rdram, ctx, runtime); return;
}


// Function: entry_20ad6c
// Address: 0x20ad6c - 0x20ada0

void entry_20ad6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ad6c) {
        switch (ctx->pc) {
            case 0x20ad70: ctx->pc = 0; goto label_20ad70;
            case 0x20ad74: ctx->pc = 0; goto label_20ad74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ad6c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_20ad70:
    // 0x20ad70: 0xdfbf00b0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 176)));
label_20ad74:
    // 0x20ad74: 0xdfbe00a0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20ad78: 0xdfb70090
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20ad7c: 0xdfb60080
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20ad80: 0xdfb50070
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20ad84: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20ad88: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20ad8c: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20ad90: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20ad94: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20ad98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0020ada0
// Address: 0x20ada0 - 0x20adb0

void FUN_0020ada0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ada0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x20ada4: 0xffbf0000
    WRITE64(ADD32(GPR_U32(ctx, 29), 0), GPR_U64(ctx, 31));
    // 0x20ada8: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x20adb0);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_20adb0
// Address: 0x20adb0 - 0x20ae18

void entry_20adb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20adb0: 0x3c081000
    SET_GPR_U32(ctx, 8, ((uint32_t)4096 << 16));
    // 0x20adb4: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x20adb8: 0x3508f520
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 62752));
    // 0x20adbc: 0x3c091000
    SET_GPR_U32(ctx, 9, ((uint32_t)4096 << 16));
    // 0x20adc0: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x20adc4: 0x3529f590
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 9), 62864));
    // 0x20adc8: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x20adcc: 0x3c07ffff
    SET_GPR_U32(ctx, 7, ((uint32_t)65535 << 16));
    // 0x20add0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20add4: 0x34a5b000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 45056));
    // 0x20add8: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x20addc: 0x34e7feff
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65279));
    // 0x20ade0: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20ade4: 0x3c06fffe
    SET_GPR_U32(ctx, 6, ((uint32_t)65534 << 16));
    // 0x20ade8: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20adec: 0x3484b400
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 46080));
    // 0x20adf0: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x20adf4: 0x671824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x20adf8: 0xaca30000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 3));
    // 0x20adfc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20ae00: 0x471024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x20ae04: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x20ae08: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x20ae0c: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x20ae10: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x20ae18);
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 3));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_20ae18
// Address: 0x20ae18 - 0x20ae40

void entry_20ae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ae18: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20ae1c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20ae20: 0x3463b020
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 45088));
    // 0x20ae24: 0x3442b420
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 46112));
    // 0x20ae28: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x20ae2c: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20ae30: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x20ae34: 0x80846ea
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = 0x211ba8; return;
    // 0x20ae3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20ae40; return;
}


// Function: sceMpegCreate
// Address: 0x20ae40 - 0x20ae70

void entry_20ae70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ae70: 0x26030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 3));
    // 0x20ae74: 0x31882
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 2));
    // 0x20ae78: 0x39080
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 3), 2));
    // 0x20ae7c: 0x2508023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x20ae80: 0x2303023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x20ae84: 0x2cc210c0
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4288));
    // 0x20ae88: 0x10400006
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20AEA4; return;
    }
    // 0x20ae90: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20ae94: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20ae9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 112));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20ae9c
// Address: 0x20ae9c - 0x20aec0

void entry_20ae9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ae9c) {
        switch (ctx->pc) {
            case 0x20aea4: ctx->pc = 0; goto label_20aea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ae9c: 0x10000063
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B02C; return;
    }
label_20aea4:
    // 0x20aea4: 0x26510108
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 264));
    // 0x20aea8: 0xae720040
    WRITE32(ADD32(GPR_U32(ctx, 19), 64), GPR_U32(ctx, 18));
    // 0x20aeac: 0x24c6ef40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294963008));
    // 0x20aeb0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20aeb4: 0x264510c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 4288));
    // 0x20aeb8: 0xc082c90
    SET_GPR_U32(ctx, 31, 0x20aec0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    _alalcInit(rdram, ctx, runtime); return;
}


// Function: entry_20aec0
// Address: 0x20aec0 - 0x20af68

void entry_20aec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20aec0: 0xae600000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 0));
    // 0x20aec4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20aec8: 0xae600004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 0));
    // 0x20aecc: 0x3c030021
    SET_GPR_U32(ctx, 3, ((uint32_t)33 << 16));
    // 0x20aed0: 0xae600008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 0));
    // 0x20aed4: 0x3c080021
    SET_GPR_U32(ctx, 8, ((uint32_t)33 << 16));
    // 0x20aed8: 0x2463c178
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294951288));
    // 0x20aedc: 0x2508c188
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294951304));
    // 0x20aee0: 0xfe620010
    WRITE64(ADD32(GPR_U32(ctx, 19), 16), GPR_U64(ctx, 2));
    // 0x20aee4: 0x24070008
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20aee8: 0xfe620018
    WRITE64(ADD32(GPR_U32(ctx, 19), 24), GPR_U64(ctx, 2));
    // 0x20aeec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20aef0: 0xfe600020
    WRITE64(ADD32(GPR_U32(ctx, 19), 32), GPR_U64(ctx, 0));
    // 0x20aef4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20aef8: 0xfe620028
    WRITE64(ADD32(GPR_U32(ctx, 19), 40), GPR_U64(ctx, 2));
    // 0x20aefc: 0x24060600
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1536));
    // 0x20af00: 0xfe620030
    WRITE64(ADD32(GPR_U32(ctx, 19), 48), GPR_U64(ctx, 2));
    // 0x20af04: 0xfe600038
    WRITE64(ADD32(GPR_U32(ctx, 19), 56), GPR_U64(ctx, 0));
    // 0x20af08: 0xae4000b4
    WRITE32(ADD32(GPR_U32(ctx, 18), 180), GPR_U32(ctx, 0));
    // 0x20af0c: 0xae4000b8
    WRITE32(ADD32(GPR_U32(ctx, 18), 184), GPR_U32(ctx, 0));
    // 0x20af10: 0xae4000bc
    WRITE32(ADD32(GPR_U32(ctx, 18), 188), GPR_U32(ctx, 0));
    // 0x20af14: 0xae4000c0
    WRITE32(ADD32(GPR_U32(ctx, 18), 192), GPR_U32(ctx, 0));
    // 0x20af18: 0xae4000c4
    WRITE32(ADD32(GPR_U32(ctx, 18), 196), GPR_U32(ctx, 0));
    // 0x20af1c: 0xae4000c8
    WRITE32(ADD32(GPR_U32(ctx, 18), 200), GPR_U32(ctx, 0));
    // 0x20af20: 0xae4000cc
    WRITE32(ADD32(GPR_U32(ctx, 18), 204), GPR_U32(ctx, 0));
    // 0x20af24: 0xae4000d0
    WRITE32(ADD32(GPR_U32(ctx, 18), 208), GPR_U32(ctx, 0));
    // 0x20af28: 0xae4000d4
    WRITE32(ADD32(GPR_U32(ctx, 18), 212), GPR_U32(ctx, 0));
    // 0x20af2c: 0xae4000d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 216), GPR_U32(ctx, 0));
    // 0x20af30: 0xae4000dc
    WRITE32(ADD32(GPR_U32(ctx, 18), 220), GPR_U32(ctx, 0));
    // 0x20af34: 0xae4000e0
    WRITE32(ADD32(GPR_U32(ctx, 18), 224), GPR_U32(ctx, 0));
    // 0x20af38: 0xae4000e4
    WRITE32(ADD32(GPR_U32(ctx, 18), 228), GPR_U32(ctx, 0));
    // 0x20af3c: 0xae4000e8
    WRITE32(ADD32(GPR_U32(ctx, 18), 232), GPR_U32(ctx, 0));
    // 0x20af40: 0xae4000f8
    WRITE32(ADD32(GPR_U32(ctx, 18), 248), GPR_U32(ctx, 0));
    // 0x20af44: 0xae40000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 0));
    // 0x20af48: 0xae400014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 0));
    // 0x20af4c: 0xae40002c
    WRITE32(ADD32(GPR_U32(ctx, 18), 44), GPR_U32(ctx, 0));
    // 0x20af50: 0xae400034
    WRITE32(ADD32(GPR_U32(ctx, 18), 52), GPR_U32(ctx, 0));
    // 0x20af54: 0xae40003c
    WRITE32(ADD32(GPR_U32(ctx, 18), 60), GPR_U32(ctx, 0));
    // 0x20af58: 0xfe4200f0
    WRITE64(ADD32(GPR_U32(ctx, 18), 240), GPR_U64(ctx, 2));
    // 0x20af5c: 0xae43001c
    WRITE32(ADD32(GPR_U32(ctx, 18), 28), GPR_U32(ctx, 3));
    // 0x20af60: 0xc082c9e
    SET_GPR_U32(ctx, 31, 0x20af68);
    WRITE32(ADD32(GPR_U32(ctx, 18), 36), GPR_U32(ctx, 8));
    _alalcAlloc(rdram, ctx, runtime); return;
}


// Function: entry_20af68
// Address: 0x20af68 - 0x20afb4

void entry_20af68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20af68: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20af6c: 0xae400048
    WRITE32(ADD32(GPR_U32(ctx, 18), 72), GPR_U32(ctx, 0));
    // 0x20af70: 0xae4000fc
    WRITE32(ADD32(GPR_U32(ctx, 18), 252), GPR_U32(ctx, 0));
    // 0x20af74: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20af78: 0xae400100
    WRITE32(ADD32(GPR_U32(ctx, 18), 256), GPR_U32(ctx, 0));
    // 0x20af7c: 0xae400104
    WRITE32(ADD32(GPR_U32(ctx, 18), 260), GPR_U32(ctx, 0));
    // 0x20af80: 0xae400070
    WRITE32(ADD32(GPR_U32(ctx, 18), 112), GPR_U32(ctx, 0));
    // 0x20af84: 0xfe400078
    WRITE64(ADD32(GPR_U32(ctx, 18), 120), GPR_U64(ctx, 0));
    // 0x20af88: 0xae500080
    WRITE32(ADD32(GPR_U32(ctx, 18), 128), GPR_U32(ctx, 16));
    // 0x20af8c: 0xfe400088
    WRITE64(ADD32(GPR_U32(ctx, 18), 136), GPR_U64(ctx, 0));
    // 0x20af90: 0xae400090
    WRITE32(ADD32(GPR_U32(ctx, 18), 144), GPR_U32(ctx, 0));
    // 0x20af94: 0xae4000ac
    WRITE32(ADD32(GPR_U32(ctx, 18), 172), GPR_U32(ctx, 0));
    // 0x20af98: 0xae500094
    WRITE32(ADD32(GPR_U32(ctx, 18), 148), GPR_U32(ctx, 16));
    // 0x20af9c: 0xae500098
    WRITE32(ADD32(GPR_U32(ctx, 18), 152), GPR_U32(ctx, 16));
    // 0x20afa0: 0xae50009c
    WRITE32(ADD32(GPR_U32(ctx, 18), 156), GPR_U32(ctx, 16));
    // 0x20afa4: 0xae530858
    WRITE32(ADD32(GPR_U32(ctx, 18), 2136), GPR_U32(ctx, 19));
    // 0x20afa8: 0xae420044
    WRITE32(ADD32(GPR_U32(ctx, 18), 68), GPR_U32(ctx, 2));
    // 0x20afac: 0xc082e04
    SET_GPR_U32(ctx, 31, 0x20afb4);
    WRITE32(ADD32(GPR_U32(ctx, 18), 176), GPR_U32(ctx, 3));
    _clearOnce(rdram, ctx, runtime); return;
}


// Function: entry_20afb4
// Address: 0x20afb4 - 0x20afbc

void entry_20afb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20afb4: 0xc082c30
    SET_GPR_U32(ctx, 31, 0x20afbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    sceMpegReset(rdram, ctx, runtime); return;
}


// Function: entry_20afbc
// Address: 0x20afbc - 0x20afc4

void entry_20afbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20afbc: 0xc082c44
    SET_GPR_U32(ctx, 31, 0x20afc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    sceMpegClearRefBuff(rdram, ctx, runtime); return;
}


// Function: entry_20afc4
// Address: 0x20afc4 - 0x20b014

void entry_20afc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20afc4: 0x264301e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 488));
    // 0x20afc8: 0x26420250
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 592));
    // 0x20afcc: 0x264502b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 696));
    // 0x20afd0: 0x26460320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 800));
    // 0x20afd4: 0x26470388
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 904));
    // 0x20afd8: 0x264803f0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 1008));
    // 0x20afdc: 0x26490458
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 1112));
    // 0x20afe0: 0x264a04c0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 18), 1216));
    // 0x20afe4: 0x264b0528
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 18), 1320));
    // 0x20afe8: 0xae4301b8
    WRITE32(ADD32(GPR_U32(ctx, 18), 440), GPR_U32(ctx, 3));
    // 0x20afec: 0xae4201bc
    WRITE32(ADD32(GPR_U32(ctx, 18), 444), GPR_U32(ctx, 2));
    // 0x20aff0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20aff4: 0xae4501c4
    WRITE32(ADD32(GPR_U32(ctx, 18), 452), GPR_U32(ctx, 5));
    // 0x20aff8: 0xae4601c8
    WRITE32(ADD32(GPR_U32(ctx, 18), 456), GPR_U32(ctx, 6));
    // 0x20affc: 0xae4701cc
    WRITE32(ADD32(GPR_U32(ctx, 18), 460), GPR_U32(ctx, 7));
    // 0x20b000: 0xae4801d4
    WRITE32(ADD32(GPR_U32(ctx, 18), 468), GPR_U32(ctx, 8));
    // 0x20b004: 0xae4901d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 472), GPR_U32(ctx, 9));
    // 0x20b008: 0xae4a01dc
    WRITE32(ADD32(GPR_U32(ctx, 18), 476), GPR_U32(ctx, 10));
    // 0x20b00c: 0xc082c96
    SET_GPR_U32(ctx, 31, 0x20b014);
    WRITE32(ADD32(GPR_U32(ctx, 18), 484), GPR_U32(ctx, 11));
    _alalcSetDynamic(rdram, ctx, runtime); return;
}


// Function: entry_20b014
// Address: 0x20b014 - 0x20b048

void entry_20b014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b014) {
        switch (ctx->pc) {
            case 0x20b02c: ctx->pc = 0; goto label_20b02c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b014: 0x3c027000
    SET_GPR_U32(ctx, 2, ((uint32_t)28672 << 16));
    // 0x20b018: 0xae500850
    WRITE32(ADD32(GPR_U32(ctx, 18), 2128), GPR_U32(ctx, 16));
    // 0x20b01c: 0x34423600
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 13824));
    // 0x20b020: 0xae400854
    WRITE32(ADD32(GPR_U32(ctx, 18), 2132), GPR_U32(ctx, 0));
    // 0x20b024: 0xae42081c
    WRITE32(ADD32(GPR_U32(ctx, 18), 2076), GPR_U32(ctx, 2));
    // 0x20b028: 0xae40084c
    WRITE32(ADD32(GPR_U32(ctx, 18), 2124), GPR_U32(ctx, 0));
label_20b02c:
    // 0x20b02c: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20b030: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20b034: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b038: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b03c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b040: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SyncVBlank1
// Address: 0x20b048 - 0x20b058

void entry_20b094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b094: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b0a0: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x20b0a4: 0x0
    // NOP
    // 0x20b0a8: 0xac460098
    WRITE32(ADD32(GPR_U32(ctx, 2), 152), GPR_U32(ctx, 6));
    // 0x20b0ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b0b0; return;
}


// Function: sceMpegIsEnd
// Address: 0x20b0b0 - 0x20b0c0

void entry_20b0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b0f8: 0xae000118
    WRITE32(ADD32(GPR_U32(ctx, 16), 280), GPR_U32(ctx, 0));
    // 0x20b0fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20b100: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b104: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b108: 0x8082de0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = 0x20b780; return;
}


// Function: sceMpegClearRefBuff
// Address: 0x20b110 - 0x20b168

void entry_20b1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b1cc) {
        switch (ctx->pc) {
            case 0x20b1d0: ctx->pc = 0; goto label_20b1d0;
            case 0x20b1d4: ctx->pc = 0; goto label_20b1d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b1cc: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_20b1d0:
    // 0x20b1d0: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_20b1d4:
    // 0x20b1d4: 0xe0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x20b1d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _dispatchMpegCbNodata
// Address: 0x20b1e0 - 0x20b1f8

void entry_20b1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b1f8: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b1fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b204: 0x0
    // NOP
    // 0x20b208: 0xac430070
    WRITE32(ADD32(GPR_U32(ctx, 2), 112), GPR_U32(ctx, 3));
    // 0x20b20c: 0x0
    // NOP
    // 0x20b210: 0xac4500d8
    WRITE32(ADD32(GPR_U32(ctx, 2), 216), GPR_U32(ctx, 5));
    // 0x20b214: 0x0
    // NOP
    // 0x20b218: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x20b21c: 0x0
    // NOP
    // 0x20b220: 0x8c6200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x20b224: 0x0
    // NOP
    // 0x20b228: 0x244200b4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 180));
    // 0x20b22c: 0x0
    // NOP
    // 0x20b230: 0x244200b4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 180));
    // 0x20b234: 0x0
    // NOP
    // 0x20b238: 0xfc6500f0
    WRITE64(ADD32(GPR_U32(ctx, 3), 240), GPR_U64(ctx, 5));
    // 0x20b23c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b240; return;
}


// Function: _alalcInit
// Address: 0x20b240 - 0x20b258

void entry_20b2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b2d4) {
        switch (ctx->pc) {
            case 0x20b2d8: ctx->pc = 0; goto label_20b2d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b2d4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20b2d8:
    // 0x20b2d8: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b2dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b2e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b2e8; return;
}


// Function: _getpic
// Address: 0x20b2e8 - 0x20b330

void entry_20b330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b330) {
        switch (ctx->pc) {
            case 0x20b338: ctx->pc = 0; goto label_20b338;
            case 0x20b340: ctx->pc = 0; goto label_20b340;
            case 0x20b348: ctx->pc = 0; goto label_20b348;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b330: 0x10000042
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B43C; return;
    }
label_20b338:
    // 0x20b338: 0xae000820
    WRITE32(ADD32(GPR_U32(ctx, 16), 2080), GPR_U32(ctx, 0));
    // 0x20b33c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20b340:
    // 0x20b340: 0x1242000d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20B378; return;
    }
label_20b348:
    // 0x20b348: 0xc083dfc
    SET_GPR_U32(ctx, 31, 0x20b350);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _nextHeader(rdram, ctx, runtime); return;
}


// Function: entry_20b350
// Address: 0x20b350 - 0x20b3a0

void entry_20b350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b350) {
        switch (ctx->pc) {
            case 0x20b378: ctx->pc = 0; goto label_20b378;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b350: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20b354: 0x12600008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_20b378;
    }
    // 0x20b35c: 0x8e030174
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20b360: 0x8e0200d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 212)));
    // 0x20b364: 0x10620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_20b378;
    }
    // 0x20b36c: 0x8e020848
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2120)));
    // 0x20b370: 0x1440fff5
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B348; return;
    }
label_20b378:
    // 0x20b378: 0x10400029
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B420; return;
    }
    // 0x20b380: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x20b384: 0x24420100
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 256));
    // 0x20b388: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20b38c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20b390: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x20b398: 0xc082dc6
    SET_GPR_U32(ctx, 31, 0x20b3a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _sceMpegFlush(rdram, ctx, runtime); return;
}


// Function: entry_20b3a0
// Address: 0x20b3a0 - 0x20b3c8

void entry_20b3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b3a0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20b3a4: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B420; return;
    }
    // 0x20b3ac: 0xae0000a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 168), GPR_U32(ctx, 0));
    // 0x20b3b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20b3b4: 0xae0000a4
    WRITE32(ADD32(GPR_U32(ctx, 16), 164), GPR_U32(ctx, 0));
    // 0x20b3b8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20b3bc: 0xae0000a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 160), GPR_U32(ctx, 0));
    // 0x20b3c0: 0xc082d5c
    SET_GPR_U32(ctx, 31, 0x20b3c8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 148)));
    _decodeOrSkip(rdram, ctx, runtime); return;
}


// Function: entry_20b3c8
// Address: 0x20b3c8 - 0x20b3ec

void entry_20b3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b3c8: 0x8e0300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x20b3cc: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20b3d0: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x20b3d4: 0x10000012
    WRITE32(ADD32(GPR_U32(ctx, 16), 160), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B420; return;
    }
    // 0x20b3dc: 0x8e0500a4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 164)));
    // 0x20b3e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20b3e4: 0xc082d5c
    SET_GPR_U32(ctx, 31, 0x20b3ec);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 152)));
    _decodeOrSkip(rdram, ctx, runtime); return;
}


// Function: entry_20b3ec
// Address: 0x20b3ec - 0x20b410

void entry_20b3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b3ec: 0x8e0300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 164)));
    // 0x20b3f0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20b3f4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x20b3f8: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 16), 164), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B420; return;
    }
    // 0x20b400: 0x8e0500a8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x20b404: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20b408: 0xc082d5c
    SET_GPR_U32(ctx, 31, 0x20b410);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    _decodeOrSkip(rdram, ctx, runtime); return;
}


// Function: entry_20b410
// Address: 0x20b410 - 0x20b458

void entry_20b410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b410) {
        switch (ctx->pc) {
            case 0x20b420: ctx->pc = 0; goto label_20b420;
            case 0x20b43c: ctx->pc = 0; goto label_20b43c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b410: 0x8e0300a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x20b414: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20b418: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x20b41c: 0xae0300a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 168), GPR_U32(ctx, 3));
label_20b420:
    // 0x20b420: 0x8e020820
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2080)));
    // 0x20b424: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20b43c;
    }
    // 0x20b42c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20b430: 0x1040ffc3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B340; return;
    }
    // 0x20b438: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_20b43c:
    // 0x20b43c: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20b440: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20b444: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b448: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b44c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b450: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _decodeOrSkipFrame
// Address: 0x20b458 - 0x20b4b0

void entry_20b4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b4b0: 0x10400004
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B4C4; return;
    }
    // 0x20b4b8: 0xc084024
    SET_GPR_U32(ctx, 31, 0x20b4c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _decPicture(rdram, ctx, runtime); return;
}


// Function: entry_20b4c0
// Address: 0x20b4c0 - 0x20b4d4

void entry_20b4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b4c0) {
        switch (ctx->pc) {
            case 0x20b4c4: ctx->pc = 0; goto label_20b4c4;
            case 0x20b4cc: ctx->pc = 0; goto label_20b4cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b4c0: 0x2182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_20b4c4:
    // 0x20b4c4: 0x10000007
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20b4e4(rdram, ctx, runtime); return;
    }
label_20b4cc:
    // 0x20b4cc: 0xc08407c
    SET_GPR_U32(ctx, 31, 0x20b4d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _updateRefImage(rdram, ctx, runtime); return;
}


// Function: entry_20b4d4
// Address: 0x20b4d4 - 0x20b4e4

void entry_20b4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b4d4: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20b4d8: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20b4dc: 0xc082c78
    SET_GPR_U32(ctx, 31, 0x20b4e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _dispatchMpegCbNodata(rdram, ctx, runtime); return;
}


// Function: entry_20b4e4
// Address: 0x20b4e4 - 0x20b4f4

void entry_20b4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b4e4: 0x8e050118
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b4e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20b4ec: 0xc084058
    SET_GPR_U32(ctx, 31, 0x20b4f4);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    _outputFrame(rdram, ctx, runtime); return;
}


// Function: entry_20b4f4
// Address: 0x20b4f4 - 0x20b570

void entry_20b4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b4f4) {
        switch (ctx->pc) {
            case 0x20b51c: ctx->pc = 0; goto label_20b51c;
            case 0x20b550: ctx->pc = 0; goto label_20b550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b4f4: 0x8e030174
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20b4f8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20b4fc: 0x50620007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 172)));
        goto label_20b51c;
    }
    // 0x20b504: 0x56600005
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 172)));
        goto label_20b51c;
    }
    // 0x20b50c: 0x8e020120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x20b510: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x20b514: 0xae020120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 2));
    // 0x20b518: 0x8e0300ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 172)));
label_20b51c:
    // 0x20b51c: 0x8e020118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b520: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20b524: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x20b528: 0x8e030120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x20b52c: 0x14600008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_20b550;
    }
    // 0x20b534: 0x8e020118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b538: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x20b53c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x20b540: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x20b544: 0xae020118
    WRITE32(ADD32(GPR_U32(ctx, 16), 280), GPR_U32(ctx, 2));
    // 0x20b548: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x20b54c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_20b550:
    // 0x20b550: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20b554: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20b558: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b55c: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b560: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b56c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b570; return;
}


// Function: _decodeOrSkip
// Address: 0x20b570 - 0x20b598

void entry_20b598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b598) {
        switch (ctx->pc) {
            case 0x20b5a0: ctx->pc = 0; goto label_20b5a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b598: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B5AC; return;
    }
label_20b5a0:
    // 0x20b5a0: 0xc082d16
    SET_GPR_U32(ctx, 31, 0x20b5a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    _decodeOrSkipFrame(rdram, ctx, runtime); return;
}


// Function: entry_20b5a8
// Address: 0x20b5a8 - 0x20b5b8

void entry_20b5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b5a8) {
        switch (ctx->pc) {
            case 0x20b5ac: ctx->pc = 0; goto label_20b5ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b5a8: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
label_20b5ac:
    // 0x20b5ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b5b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b5b8; return;
}


// Function: _decodeOrSkipField
// Address: 0x20b5b8 - 0x20b61c

void entry_20b61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b61c: 0x10400006
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B638; return;
    }
    // 0x20b624: 0x12600005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B63C; return;
    }
    // 0x20b62c: 0xc084024
    SET_GPR_U32(ctx, 31, 0x20b634);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _decPicture(rdram, ctx, runtime); return;
}


// Function: entry_20b634
// Address: 0x20b634 - 0x20b644

void entry_20b634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b634) {
        switch (ctx->pc) {
            case 0x20b638: ctx->pc = 0; goto label_20b638;
            case 0x20b63c: ctx->pc = 0; goto label_20b63c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b634: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
label_20b638:
    // 0x20b638: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20b63c:
    // 0x20b63c: 0xc083dfc
    SET_GPR_U32(ctx, 31, 0x20b644);
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 17));
    _nextHeader(rdram, ctx, runtime); return;
}


// Function: entry_20b644
// Address: 0x20b644 - 0x20b654

void entry_20b644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b644: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 212)));
        ctx->pc = 0x20B660; return;
    }
    // 0x20b64c: 0xc082dc6
    SET_GPR_U32(ctx, 31, 0x20b654);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    _sceMpegFlush(rdram, ctx, runtime); return;
}


// Function: entry_20b654
// Address: 0x20b654 - 0x20b684

void entry_20b654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b654) {
        switch (ctx->pc) {
            case 0x20b660: ctx->pc = 0; goto label_20b660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b654: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x20b658: 0x10000026
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B6F4; return;
    }
label_20b660:
    // 0x20b660: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20b664: 0x8e040174
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20b668: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x20b66c: 0x222180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 17));
    // 0x20b670: 0x14830020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x20B6F4; return;
    }
    // 0x20b678: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20b67c: 0xc08407c
    SET_GPR_U32(ctx, 31, 0x20b684);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _updateRefImage(rdram, ctx, runtime); return;
}


// Function: entry_20b684
// Address: 0x20b684 - 0x20b6a4

void entry_20b684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b684: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20b688: 0x222180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 17));
    // 0x20b68c: 0x10600006
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B6A8; return;
    }
    // 0x20b694: 0x52600005
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 280)));
        ctx->pc = 0x20B6AC; return;
    }
    // 0x20b69c: 0xc084024
    SET_GPR_U32(ctx, 31, 0x20b6a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _decPicture(rdram, ctx, runtime); return;
}


// Function: entry_20b6a4
// Address: 0x20b6a4 - 0x20b6b8

void entry_20b6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b6a4) {
        switch (ctx->pc) {
            case 0x20b6a8: ctx->pc = 0; goto label_20b6a8;
            case 0x20b6ac: ctx->pc = 0; goto label_20b6ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b6a4: 0x222a00b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 17));
label_20b6a8:
    // 0x20b6a8: 0x8e050118
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 280)));
label_20b6ac:
    // 0x20b6ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20b6b0: 0xc084058
    SET_GPR_U32(ctx, 31, 0x20b6b8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    _outputFrame(rdram, ctx, runtime); return;
}


// Function: entry_20b6b8
// Address: 0x20b6b8 - 0x20b6f0

void entry_20b6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b6b8: 0x8e020118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b6bc: 0x8e0300ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 172)));
    // 0x20b6c0: 0xae000120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
    // 0x20b6c4: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20b6c8: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x20b6cc: 0x8e030118
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b6d0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x20b6d4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x20b6d8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x20b6dc: 0xae030118
    WRITE32(ADD32(GPR_U32(ctx, 16), 280), GPR_U32(ctx, 3));
    // 0x20b6e0: 0x16600003
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        entry_20b6f0(rdram, ctx, runtime); return;
    }
    // 0x20b6e8: 0xc082c78
    SET_GPR_U32(ctx, 31, 0x20b6f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    _dispatchMpegCbNodata(rdram, ctx, runtime); return;
}


// Function: entry_20b6f0
// Address: 0x20b6f0 - 0x20b718

void entry_20b6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b6f0) {
        switch (ctx->pc) {
            case 0x20b6f4: ctx->pc = 0; goto label_20b6f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b6f0: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_20b6f4:
    // 0x20b6f4: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20b6f8: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20b6fc: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20b700: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b704: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b708: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b70c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b714: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b718; return;
}


// Function: _sceMpegFlush
// Address: 0x20b718 - 0x20b750

void entry_20b750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b750) {
        switch (ctx->pc) {
            case 0x20b768: ctx->pc = 0; goto label_20b768;
            case 0x20b76c: ctx->pc = 0; goto label_20b76c;
            case 0x20b780: ctx->pc = 0; goto label_20b780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b750: 0x8e020118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x20b754: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20b758: 0x8e0300ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 172)));
    // 0x20b75c: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20b760: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x20b764: 0xae000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
label_20b768:
    // 0x20b768: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
label_20b76c:
    // 0x20b76c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20b770: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b774: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
label_20b780:
    // 0x20b780: 0xac800848
    WRITE32(ADD32(GPR_U32(ctx, 4), 2120), GPR_U32(ctx, 0));
    // 0x20b784: 0x80837ba
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    _ipuSetMPEG1(rdram, ctx, runtime); return;
    // 0x20b78c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b790; return;
}


// Function: _lastFrame
// Address: 0x20b790 - 0x20b7b8

void entry_20b7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b7b8) {
        switch (ctx->pc) {
            case 0x20b7c0: ctx->pc = 0; goto label_20b7c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b7b8: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B7FC; return;
    }
label_20b7c0:
    // 0x20b7c0: 0x8e030174
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20b7c4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20b7c8: 0x14620007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20B7E8; return;
    }
    // 0x20b7d0: 0x8e0501bc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 444)));
    // 0x20b7d4: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x20b7d8: 0xc08425c
    SET_GPR_U32(ctx, 31, 0x20b7e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _dispRefImage(rdram, ctx, runtime); return;
}


// Function: entry_20b7e0
// Address: 0x20b7e0 - 0x20b7f8

void entry_20b7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b7e0) {
        switch (ctx->pc) {
            case 0x20b7e8: ctx->pc = 0; goto label_20b7e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b7e0: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B7FC; return;
    }
label_20b7e8:
    // 0x20b7e8: 0x8e0501cc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 460)));
    // 0x20b7ec: 0x8e0601dc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 476)));
    // 0x20b7f0: 0xc0842a0
    SET_GPR_U32(ctx, 31, 0x20b7f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _dispRefImageField(rdram, ctx, runtime); return;
}


// Function: entry_20b7f8
// Address: 0x20b7f8 - 0x20b810

void entry_20b7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b7f8) {
        switch (ctx->pc) {
            case 0x20b7fc: ctx->pc = 0; goto label_20b7fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b7f8: 0xae000120
    WRITE32(ADD32(GPR_U32(ctx, 16), 288), GPR_U32(ctx, 0));
label_20b7fc:
    // 0x20b7fc: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b800: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b804: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b80c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b810; return;
}


// Function: _clearOnce
// Address: 0x20b810 - 0x20b82c

void entry_20b82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b82c: 0x3c117000
    SET_GPR_U32(ctx, 17, ((uint32_t)28672 << 16));
    // 0x20b830: 0x3c027000
    SET_GPR_U32(ctx, 2, ((uint32_t)28672 << 16));
    // 0x20b834: 0x3c037000
    SET_GPR_U32(ctx, 3, ((uint32_t)28672 << 16));
    // 0x20b838: 0x3c047000
    SET_GPR_U32(ctx, 4, ((uint32_t)28672 << 16));
    // 0x20b83c: 0x34421800
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 6144));
    // 0x20b840: 0x34631b00
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 6912));
    // 0x20b844: 0x34843300
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 13056));
    // 0x20b848: 0xae110590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 17));
    // 0x20b84c: 0xae020594
    WRITE32(ADD32(GPR_U32(ctx, 16), 1428), GPR_U32(ctx, 2));
    // 0x20b850: 0xae0306d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1744), GPR_U32(ctx, 3));
    // 0x20b854: 0xae0406d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1748), GPR_U32(ctx, 4));
    // 0x20b858: 0xae000810
    WRITE32(ADD32(GPR_U32(ctx, 16), 2064), GPR_U32(ctx, 0));
    // 0x20b85c: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20b860: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20b864: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b868: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _clearEach
// Address: 0x20b870 - 0x20b888

void entry_20b888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b888: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x20b88c: 0x3c070001
    SET_GPR_U32(ctx, 7, ((uint32_t)1 << 16));
    // 0x20b890: 0x34a5f520
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 62752));
    // 0x20b894: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x20b898: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20b89c: 0x34c6f590
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 62864));
    // 0x20b8a0: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20b8a4: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20b8a8: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x20b8ac: 0x3463b000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 45056));
    // 0x20b8b0: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x20b8b4: 0x3484b400
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 46080));
    // 0x20b8b8: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x20b8bc: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20b8c0: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x20b8c4: 0x3442d400
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 54272));
    // 0x20b8c8: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x20b8cc: 0x3c03fffe
    SET_GPR_U32(ctx, 3, ((uint32_t)65534 << 16));
    // 0x20b8d0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x20b8d4: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20b8d8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20b8dc: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x20b8e4);
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_20b8e4
// Address: 0x20b8e4 - 0x20b930

void entry_20b8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b8e4: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20b8e8: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20b8ec: 0x3463b020
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 45088));
    // 0x20b8f0: 0x3484b420
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 46112));
    // 0x20b8f4: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x20b8f8: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20b8fc: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x20b900: 0x3442d420
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 54304));
    // 0x20b904: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x20b908: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20b90c: 0x34632010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8208));
    // 0x20b910: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x20b914: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20b918: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20b91c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x20b920: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20b924: 0x80846b6
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = 0x211ad8; return;
    // 0x20b92c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b930; return;
}


// Function: fn__ErrMessage
// Address: 0x20b930 - 0x20b940

void entry_20b958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b958: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20b95c: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20b964);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20b964
// Address: 0x20b964 - 0x20b978

void entry_20b964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20b964: 0xdfbf0110
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x20b968: 0xdfb00100
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x20b96c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b974: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b978; return;
}


// Function: fn__Error
// Address: 0x20b978 - 0x20b9b0

void entry_20b9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b9b0) {
        switch (ctx->pc) {
            case 0x20b9b8: ctx->pc = 0; goto label_20b9b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b9b0: 0x10000004
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20B9C4; return;
    }
label_20b9b8:
    // 0x20b9b8: 0xc082e4c
    SET_GPR_U32(ctx, 31, 0x20b9c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    fn__ErrMessage(rdram, ctx, runtime); return;
}


// Function: entry_20b9c0
// Address: 0x20b9c0 - 0x20b9d0

void entry_20b9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20b9c0) {
        switch (ctx->pc) {
            case 0x20b9c4: ctx->pc = 0; goto label_20b9c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20b9c0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_20b9c4:
    // 0x20b9c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20b9cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20b9d0; return;
}


// Function: fn__RefImageInit
// Address: 0x20b9d0 - 0x20b9f0

void entry_20ba0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba0c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20ba10: 0x31202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), 8));
    // 0x20ba14: 0x30420fff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4095));
    // 0x20ba18: 0x31d02
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 20));
    // 0x20ba1c: 0xae030124
    WRITE32(ADD32(GPR_U32(ctx, 16), 292), GPR_U32(ctx, 3));
    // 0x20ba20: 0x28440af1
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 2), 2801));
    // 0x20ba24: 0x14800005
    WRITE32(ADD32(GPR_U32(ctx, 16), 296), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        entry_20ba3c(rdram, ctx, runtime); return;
    }
    // 0x20ba2c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20ba30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ba34: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20ba3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 328));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20ba3c
// Address: 0x20ba3c - 0x20ba48

void entry_20ba3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ba40: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ba48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 30));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ba48
// Address: 0x20ba48 - 0x20ba6c

void entry_20ba48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba48: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20ba4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ba50: 0x31042
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), 1));
    // 0x20ba54: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20ba58: 0x31b02
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 12));
    // 0x20ba5c: 0x304203ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1023));
    // 0x20ba60: 0xae030134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 3));
    // 0x20ba64: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ba6c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 312), GPR_U32(ctx, 2));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ba6c
// Address: 0x20ba6c - 0x20ba7c

void entry_20ba6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba6c: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 2112), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20BA98; return;
    }
    // 0x20ba74: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20ba7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20ba7c
// Address: 0x20ba7c - 0x20ba88

void entry_20ba7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ba80: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20ba88);
    SET_GPR_U32(ctx, 5, ((uint32_t)20480 << 16));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20ba88
// Address: 0x20ba88 - 0x20ba90

void entry_20ba88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ba88: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20ba90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20ba90
// Address: 0x20ba90 - 0x20baac

void entry_20ba90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ba90) {
        switch (ctx->pc) {
            case 0x20ba98: ctx->pc = 0; goto label_20ba98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ba90: 0x10000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20BAB0; return;
    }
label_20ba98:
    // 0x20ba98: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20ba9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20baa0: 0x24c6af80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294946688));
    // 0x20baa4: 0xc082fa8
    SET_GPR_U32(ctx, 31, 0x20baac);
    SET_GPR_U32(ctx, 5, ((uint32_t)20480 << 16));
    _setDefaultQM(rdram, ctx, runtime); return;
}


// Function: entry_20baac
// Address: 0x20baac - 0x20bab8

void entry_20baac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20baac) {
        switch (ctx->pc) {
            case 0x20bab0: ctx->pc = 0; goto label_20bab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20baac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20bab0:
    // 0x20bab0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20bab8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20bab8
// Address: 0x20bab8 - 0x20bac8

void entry_20bab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bab8: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 2116), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20BAE4; return;
    }
    // 0x20bac0: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20bac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20bac8
// Address: 0x20bac8 - 0x20bad4

void entry_20bac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bac8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20bacc: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20bad4);
    SET_GPR_U32(ctx, 5, ((uint32_t)22528 << 16));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20bad4
// Address: 0x20bad4 - 0x20badc

void entry_20bad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bad4: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20badc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20badc
// Address: 0x20badc - 0x20baf8

void entry_20badc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20badc) {
        switch (ctx->pc) {
            case 0x20bae4: ctx->pc = 0; goto label_20bae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20badc: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20baf8(rdram, ctx, runtime); return;
    }
label_20bae4:
    // 0x20bae4: 0x3c060028
    SET_GPR_U32(ctx, 6, ((uint32_t)40 << 16));
    // 0x20bae8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20baec: 0x24c6afc0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294946752));
    // 0x20baf0: 0xc082fa8
    SET_GPR_U32(ctx, 31, 0x20baf8);
    SET_GPR_U32(ctx, 5, ((uint32_t)22528 << 16));
    _setDefaultQM(rdram, ctx, runtime); return;
}


// Function: entry_20baf8
// Address: 0x20baf8 - 0x20bb00

void entry_20baf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20baf8: 0xc083e72
    SET_GPR_U32(ctx, 31, 0x20bb00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _extensionAndUserData(rdram, ctx, runtime); return;
}


// Function: entry_20bb00
// Address: 0x20bb00 - 0x20bc40

void entry_20bb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20bb00) {
        switch (ctx->pc) {
            case 0x20bb18: ctx->pc = 0; goto label_20bb18;
            case 0x20bb80: ctx->pc = 0; goto label_20bb80;
            case 0x20bbac: ctx->pc = 0; goto label_20bbac;
            case 0x20bbb0: ctx->pc = 0; goto label_20bbb0;
            case 0x20bbb8: ctx->pc = 0; goto label_20bbb8;
            case 0x20bbe0: ctx->pc = 0; goto label_20bbe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20bb00: 0x8e040858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2136)));
    // 0x20bb04: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20bb08: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20bb0c: 0x8082ec6
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = 0x20bb18; return;
    // 0x20bb14: 0x0
    // NOP
label_20bb18:
    // 0x20bb18: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x20bb1c: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20bb20: 0xffbf00e0
    WRITE64(ADD32(GPR_U32(ctx, 29), 224), GPR_U64(ctx, 31));
    // 0x20bb24: 0xffb700c0
    WRITE64(ADD32(GPR_U32(ctx, 29), 192), GPR_U64(ctx, 23));
    // 0x20bb28: 0xffb600b0
    WRITE64(ADD32(GPR_U32(ctx, 29), 176), GPR_U64(ctx, 22));
    // 0x20bb2c: 0xffb500a0
    WRITE64(ADD32(GPR_U32(ctx, 29), 160), GPR_U64(ctx, 21));
    // 0x20bb30: 0xffb40090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 20));
    // 0x20bb34: 0xffb30080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 19));
    // 0x20bb38: 0xffb20070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 18));
    // 0x20bb3c: 0xffb10060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 17));
    // 0x20bb40: 0xffb00050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 16));
    // 0x20bb44: 0xffbe00d0
    WRITE64(ADD32(GPR_U32(ctx, 29), 208), GPR_U64(ctx, 30));
    // 0x20bb48: 0x8cbe0040
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x20bb4c: 0x8fc60848
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 2120)));
    // 0x20bb50: 0x54c0000b
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 292)));
        goto label_20bb80;
    }
    // 0x20bb58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20bb5c: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20bb60: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x20bb64: 0xafc30174
    WRITE32(ADD32(GPR_U32(ctx, 30), 372), GPR_U32(ctx, 3));
    // 0x20bb68: 0xafc2017c
    WRITE32(ADD32(GPR_U32(ctx, 30), 380), GPR_U32(ctx, 2));
    // 0x20bb6c: 0xafc40144
    WRITE32(ADD32(GPR_U32(ctx, 30), 324), GPR_U32(ctx, 4));
    // 0x20bb70: 0xafc2013c
    WRITE32(ADD32(GPR_U32(ctx, 30), 316), GPR_U32(ctx, 2));
    // 0x20bb74: 0xafc20140
    WRITE32(ADD32(GPR_U32(ctx, 30), 320), GPR_U32(ctx, 2));
    // 0x20bb78: 0xafc20188
    WRITE32(ADD32(GPR_U32(ctx, 30), 392), GPR_U32(ctx, 2));
    // 0x20bb7c: 0x8fc20124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 292)));
label_20bb80:
    // 0x20bb80: 0x2442000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15));
    // 0x20bb84: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x20bb88: 0x10c00008
    WRITE32(ADD32(GPR_U32(ctx, 30), 300), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_20bbac;
    }
    // 0x20bb90: 0x8fc2013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 316)));
    // 0x20bb94: 0x14400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 296)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20bbb0;
    }
    // 0x20bb9c: 0x2442001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 31));
    // 0x20bba0: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x20bba4: 0x10000004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20bbb8;
    }
label_20bbac:
    // 0x20bbac: 0x8fc20128
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 296)));
label_20bbb0:
    // 0x20bbb0: 0x2442000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15));
    // 0x20bbb4: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
label_20bbb8:
    // 0x20bbb8: 0xafc20130
    WRITE32(ADD32(GPR_U32(ctx, 30), 304), GPR_U32(ctx, 2));
    // 0x20bbbc: 0x2b100
    SET_GPR_U32(ctx, 22, SLL32(GPR_U32(ctx, 2), 4));
    // 0x20bbc0: 0x8fc2012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 300)));
    // 0x20bbc4: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20bbc8: 0x2b900
    SET_GPR_U32(ctx, 23, SLL32(GPR_U32(ctx, 2), 4));
    // 0x20bbcc: 0x16e30004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1320));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 3)) {
        goto label_20bbe0;
    }
    // 0x20bbd4: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x20bbd8: 0x12c2006d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1320));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x20BD90; return;
    }
label_20bbe0:
    // 0x20bbe0: 0xacb60004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 22));
    // 0x20bbe4: 0x24100180
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 384));
    // 0x20bbe8: 0xacb70000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 23));
    // 0x20bbec: 0x2d08018
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20bbf0: 0xafa20044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    // 0x20bbf4: 0x27d10108
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 30), 264));
    // 0x20bbf8: 0x27c20320
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 800));
    // 0x20bbfc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bc00: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x20bc04: 0x27d301e8
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 30), 488));
    // 0x20bc08: 0x27c20388
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 904));
    // 0x20bc0c: 0x2f08018
    { int64_t result = (int64_t)GPR_S32(ctx, 23) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20bc10: 0xafa20034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 2));
    // 0x20bc14: 0x27d40250
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 30), 592));
    // 0x20bc18: 0x27c203f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1008));
    // 0x20bc1c: 0x27d502b8
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 30), 696));
    // 0x20bc20: 0xafa20038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 2));
    // 0x20bc24: 0x169043
    SET_GPR_S32(ctx, 18, SRA32(GPR_S32(ctx, 22), 1));
    // 0x20bc28: 0x27c20458
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1112));
    // 0x20bc2c: 0x108202
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 16), 8));
    // 0x20bc30: 0xafa2003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
    // 0x20bc34: 0x27c204c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 1216));
    // 0x20bc38: 0xc082c9a
    SET_GPR_U32(ctx, 31, 0x20bc40);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    _alalcFree(rdram, ctx, runtime); return;
}


// Function: entry_20bc40
// Address: 0x20bc40 - 0x20bc54

void entry_20bc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bc40: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20bc44: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bc48: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20bc4c: 0xc082c9e
    SET_GPR_U32(ctx, 31, 0x20bc54);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    _alalcAlloc(rdram, ctx, runtime); return;
}


// Function: entry_20bc54
// Address: 0x20bc54 - 0x20bc6c

void entry_20bc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bc54: 0xafc200fc
    WRITE32(ADD32(GPR_U32(ctx, 30), 252), GPR_U32(ctx, 2));
    // 0x20bc58: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20bc5c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bc60: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20bc64: 0xc082c9e
    SET_GPR_U32(ctx, 31, 0x20bc6c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    _alalcAlloc(rdram, ctx, runtime); return;
}


// Function: entry_20bc6c
// Address: 0x20bc6c - 0x20bc84

void entry_20bc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bc6c: 0xafc20100
    WRITE32(ADD32(GPR_U32(ctx, 30), 256), GPR_U32(ctx, 2));
    // 0x20bc70: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bc74: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20bc78: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20bc7c: 0xc082c9e
    SET_GPR_U32(ctx, 31, 0x20bc84);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    _alalcAlloc(rdram, ctx, runtime); return;
}


// Function: entry_20bc84
// Address: 0x20bc84 - 0x20bcd4

void entry_20bc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bc84: 0x8fa80034
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x20bc88: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20bc8c: 0x8fa90038
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x20bc90: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x20bc94: 0x8faa003c
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x20bc98: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20bc9c: 0x8fab0040
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20bca0: 0xafc20104
    WRITE32(ADD32(GPR_U32(ctx, 30), 260), GPR_U32(ctx, 2));
    // 0x20bca4: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x20bca8: 0x8fa70030
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20bcac: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20bcb0: 0x8fc200fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 252)));
    // 0x20bcb4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20bcb8: 0x8fc30100
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 256)));
    // 0x20bcbc: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x20bcc0: 0x8fc20104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 260)));
    // 0x20bcc4: 0xafb70020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 23));
    // 0x20bcc8: 0xafb60028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 22));
    // 0x20bccc: 0xc082f70
    SET_GPR_U32(ctx, 31, 0x20bcd4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    _initRefImages(rdram, ctx, runtime); return;
}


// Function: entry_20bcd4
// Address: 0x20bcd4 - 0x20bce4

void entry_20bcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bcd4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20bcd8: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bcdc: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bce4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bce4
// Address: 0x20bce4 - 0x20bcf4

void entry_20bce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bce4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x20bce8: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bcec: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bcf4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bcf4
// Address: 0x20bcf4 - 0x20bd04

void entry_20bcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bcf4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20bcf8: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bcfc: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd04);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd04
// Address: 0x20bd04 - 0x20bd14

void entry_20bd04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bd04: 0x8fa40030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20bd08: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd0c: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd14);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd14
// Address: 0x20bd14 - 0x20bd24

void entry_20bd14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bd14: 0x8fa40034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x20bd18: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd1c: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd24);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd24
// Address: 0x20bd24 - 0x20bd34

void entry_20bd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bd24: 0x8fa40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x20bd28: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd2c: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd34
// Address: 0x20bd34 - 0x20bd44

void entry_20bd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bd34: 0x8fa4003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x20bd38: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd3c: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd44);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd44
// Address: 0x20bd44 - 0x20bd54

void entry_20bd44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bd44: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20bd48: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd4c: 0xc082e74
    SET_GPR_U32(ctx, 31, 0x20bd54);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__RefImageInit(rdram, ctx, runtime); return;
}


// Function: entry_20bd54
// Address: 0x20bd54 - 0x20bdc0

void entry_20bd54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20bd54) {
        switch (ctx->pc) {
            case 0x20bd90: ctx->pc = 0; goto label_20bd90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20bd54: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20bd58: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20bd5c: 0x8fa40044
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x20bd60: 0xdfbf00e0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x20bd64: 0xdfbe00d0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x20bd68: 0xdfb700c0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x20bd6c: 0xdfb600b0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20bd70: 0xdfb500a0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20bd74: 0xdfb40090
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20bd78: 0xdfb30080
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20bd7c: 0xdfb20070
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20bd80: 0xdfb10060
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20bd84: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20bd88: 0x8082e74
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    fn__RefImageInit(rdram, ctx, runtime); return;
label_20bd90:
    // 0x20bd90: 0xdfbf00e0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x20bd94: 0xdfbe00d0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x20bd98: 0xdfb700c0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x20bd9c: 0xdfb600b0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20bda0: 0xdfb500a0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20bda4: 0xdfb40090
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20bda8: 0xdfb30080
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20bdac: 0xdfb20070
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20bdb0: 0xdfb10060
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20bdb4: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20bdb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _initRefImages
// Address: 0x20bdc0 - 0x20bea0

void entry_20bed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bed4: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20bedc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20bedc
// Address: 0x20bedc - 0x20bef0

void entry_20bedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bedc: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20bee0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bee4: 0x34422000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8192));
    // 0x20bee8: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20bef0);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20bef0
// Address: 0x20bef0 - 0x20bef8

void entry_20bef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bef0: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x20bef8);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_20bef8
// Address: 0x20bef8 - 0x20bf34

void entry_20bef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bef8: 0x3c030fff
    SET_GPR_U32(ctx, 3, ((uint32_t)4095 << 16));
    // 0x20befc: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20bf00: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x20bf04: 0x3442b410
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 46096));
    // 0x20bf08: 0x2038024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x20bf0c: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20bf10: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x20bf14: 0x3484b420
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 46112));
    // 0x20bf18: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x20bf1c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20bf20: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x20bf24: 0x3442b400
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 46080));
    // 0x20bf28: 0x24030101
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 257));
    // 0x20bf2c: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x20bf34);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_20bf34
// Address: 0x20bf34 - 0x20bf40

void entry_20bf34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bf34: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20bf38: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20bf40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20bf40
// Address: 0x20bf40 - 0x20bf48

void entry_20bf40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bf40: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20bf48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20bf48
// Address: 0x20bf48 - 0x20bf5c

void entry_20bf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bf48: 0x8e240858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2136)));
    // 0x20bf4c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20bf50: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20bf54: 0xc082c64
    SET_GPR_U32(ctx, 31, 0x20bf5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    _dispatchMpegCallback(rdram, ctx, runtime); return;
}


// Function: entry_20bf5c
// Address: 0x20bf5c - 0x20bf78

void entry_20bf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bf5c: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20bf60: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20bf64: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20bf68: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20bf6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20bf74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20bf78; return;
}


// Function: _sequenceExtension
// Address: 0x20bf78 - 0x20bfac

void entry_20bfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bfac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bfb0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20bfb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 28));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20bfb8
// Address: 0x20bfb8 - 0x20bff4

void entry_20bfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bfb8: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20bfbc: 0x121842
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 18), 1));
    // 0x20bfc0: 0x121442
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 18), 17));
    // 0x20bfc4: 0x30750fff
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 3), 4095));
    // 0x20bfc8: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x20bfcc: 0x122342
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 18), 13));
    // 0x20bfd0: 0x121bc2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 18), 15));
    // 0x20bfd4: 0x30940003
    SET_GPR_U32(ctx, 20, AND32(GPR_U32(ctx, 4), 3));
    // 0x20bfd8: 0x30730003
    SET_GPR_U32(ctx, 19, AND32(GPR_U32(ctx, 3), 3));
    // 0x20bfdc: 0x10500005
    WRITE32(ADD32(GPR_U32(ctx, 17), 320), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        entry_20bff4(rdram, ctx, runtime); return;
    }
    // 0x20bfe4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20bfe8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bfec: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20bff4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 352));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20bff4
// Address: 0x20bff4 - 0x20c010

void entry_20bff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20bff4: 0x1214c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 18), 19));
    // 0x20bff8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20bffc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x20c000: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x20c004: 0xae22013c
    WRITE32(ADD32(GPR_U32(ctx, 17), 316), GPR_U32(ctx, 2));
    // 0x20c008: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c010);
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 18), 20));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c010
// Address: 0x20c010 - 0x20c03c

void entry_20c010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c010: 0x29202
    SET_GPR_U32(ctx, 18, SRL32(GPR_U32(ctx, 2), 8));
    // 0x20c014: 0x24020048
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 72));
    // 0x20c018: 0x12020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 88));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_20c03c(rdram, ctx, runtime); return;
    }
    // 0x20c020: 0x12020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 68));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_20c03c(rdram, ctx, runtime); return;
    }
    // 0x20c028: 0x12020004
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_20c03c(rdram, ctx, runtime); return;
    }
    // 0x20c030: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c034: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20c03c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 392));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20c03c
// Address: 0x20c03c - 0x20c0a8

void entry_20c03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c03c: 0x8e240124
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 292)));
    // 0x20c040: 0x154480
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 21), 18));
    // 0x20c044: 0x8e230128
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 296)));
    // 0x20c048: 0x124a80
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 18), 10));
    // 0x20c04c: 0x8e260134
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 308)));
    // 0x20c050: 0x133b00
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 19), 12));
    // 0x20c054: 0x8e220138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 312)));
    // 0x20c058: 0x142b00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 20), 12));
    // 0x20c05c: 0x30840fff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 4095));
    // 0x20c060: 0x30630fff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4095));
    // 0x20c064: 0xe43825
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x20c068: 0xa32825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20c06c: 0xc83021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x20c070: 0x491021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x20c074: 0xae220138
    WRITE32(ADD32(GPR_U32(ctx, 17), 312), GPR_U32(ctx, 2));
    // 0x20c078: 0xae270124
    WRITE32(ADD32(GPR_U32(ctx, 17), 292), GPR_U32(ctx, 7));
    // 0x20c07c: 0xae250128
    WRITE32(ADD32(GPR_U32(ctx, 17), 296), GPR_U32(ctx, 5));
    // 0x20c080: 0xae260134
    WRITE32(ADD32(GPR_U32(ctx, 17), 308), GPR_U32(ctx, 6));
    // 0x20c084: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20c088: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20c08c: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20c090: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20c094: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20c098: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20c09c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20c0a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _sequenceDisplayExtension
// Address: 0x20c0a8 - 0x20c0c0

void entry_20c0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c0c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c0c4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c0cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c0cc
// Address: 0x20c0cc - 0x20c0dc

void entry_20c0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c0cc: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C0F8; return;
    }
    // 0x20c0d4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c0dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c0dc
// Address: 0x20c0dc - 0x20c0e8

void entry_20c0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c0dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c0e0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c0e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c0e8
// Address: 0x20c0e8 - 0x20c0f4

void entry_20c0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c0e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c0ec: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c0f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c0f4
// Address: 0x20c0f4 - 0x20c104

void entry_20c0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c0f4) {
        switch (ctx->pc) {
            case 0x20c0f8: ctx->pc = 0; goto label_20c0f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c0f4: 0xae020144
    WRITE32(ADD32(GPR_U32(ctx, 16), 324), GPR_U32(ctx, 2));
label_20c0f8:
    // 0x20c0f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c0fc: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c104);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c104
// Address: 0x20c104 - 0x20c114

void entry_20c104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c104: 0xae020148
    WRITE32(ADD32(GPR_U32(ctx, 16), 328), GPR_U32(ctx, 2));
    // 0x20c108: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c10c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c114);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c114
// Address: 0x20c114 - 0x20c120

void entry_20c114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c114: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20c118: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20c120);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20c120
// Address: 0x20c120 - 0x20c274

void entry_20c120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c120) {
        switch (ctx->pc) {
            case 0x20c1a0: ctx->pc = 0; goto label_20c1a0;
            case 0x20c1f0: ctx->pc = 0; goto label_20c1f0;
            case 0x20c220: ctx->pc = 0; goto label_20c220;
            case 0x20c250: ctx->pc = 0; goto label_20c250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c120: 0xae02014c
    WRITE32(ADD32(GPR_U32(ctx, 16), 332), GPR_U32(ctx, 2));
    // 0x20c124: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20c128: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20c12c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20c134: 0x0
    // NOP
    // 0x20c138: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20c13c: 0x8082e5e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 424));
    fn__Error(rdram, ctx, runtime); return;
    // 0x20c144: 0x0
    // NOP
    // 0x20c148: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20c14c: 0x8082e5e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 472));
    fn__Error(rdram, ctx, runtime); return;
    // 0x20c154: 0x0
    // NOP
    // 0x20c158: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20c15c: 0x8082e5e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 496));
    fn__Error(rdram, ctx, runtime); return;
    // 0x20c164: 0x0
    // NOP
    // 0x20c168: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20c16c: 0x8082e5e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 552));
    fn__Error(rdram, ctx, runtime); return;
    // 0x20c174: 0x0
    // NOP
    // 0x20c178: 0x8c840040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x20c17c: 0x8084628
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 76));
    ctx->pc = 0x2118a0; return;
    // 0x20c184: 0x0
    // NOP
    // 0x20c188: 0x8c840040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x20c18c: 0x8084662
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 76));
    sceIpuRestartDMA(rdram, ctx, runtime); return;
    // 0x20c194: 0x0
    // NOP
    // 0x20c198: 0x0
    // NOP
    // 0x20c19c: 0x0
    // NOP
label_20c1a0:
    // 0x20c1a0: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x20c1a4: 0xffbe0090
    WRITE64(ADD32(GPR_U32(ctx, 29), 144), GPR_U64(ctx, 30));
    // 0x20c1a8: 0xffb70080
    WRITE64(ADD32(GPR_U32(ctx, 29), 128), GPR_U64(ctx, 23));
    // 0x20c1ac: 0xc0f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x20c1b0: 0xffb60070
    WRITE64(ADD32(GPR_U32(ctx, 29), 112), GPR_U64(ctx, 22));
    // 0x20c1b4: 0xffb50060
    WRITE64(ADD32(GPR_U32(ctx, 29), 96), GPR_U64(ctx, 21));
    // 0x20c1b8: 0xffb00010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 16));
    // 0x20c1bc: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x20c1c0: 0xffbf00a0
    WRITE64(ADD32(GPR_U32(ctx, 29), 160), GPR_U64(ctx, 31));
    // 0x20c1c4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20c1c8: 0xffb40050
    WRITE64(ADD32(GPR_U32(ctx, 29), 80), GPR_U64(ctx, 20));
    // 0x20c1cc: 0x32a30001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 21), 1));
    // 0x20c1d0: 0xffb30040
    WRITE64(ADD32(GPR_U32(ctx, 29), 64), GPR_U64(ctx, 19));
    // 0x20c1d4: 0xffb20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 18));
    // 0x20c1d8: 0xffb10020
    WRITE64(ADD32(GPR_U32(ctx, 29), 32), GPR_U64(ctx, 17));
    // 0x20c1dc: 0x8e02012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 300)));
    // 0x20c1e0: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c1e4: 0xa2001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 5) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,5) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x20c1e8: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_20c1f0;
    }
label_20c1f0:
    // 0x20c1f0: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20c1f4: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x20c1f8: 0xb812
    SET_GPR_U32(ctx, 23, ctx->lo);
    // 0x20c1fc: 0x60b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x20c200: 0x173100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 23), 4));
    // 0x20c204: 0x10400012
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 22), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20c250;
    }
    // 0x20c20c: 0x8e040810
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c210: 0x261106c8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1736));
    // 0x20c214: 0x261206c4
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1732));
    // 0x20c218: 0x261306c0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1728));
    // 0x20c21c: 0x261406b8
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1720));
label_20c220:
    // 0x20c220: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20c224: 0x3442d400
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 54272));
    // 0x20c228: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20c22c: 0x31a02
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 8));
    // 0x20c230: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x20c234: 0x1460fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_20c220;
    }
    // 0x20c23c: 0x24020140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20c240: 0x821818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c244: 0x711021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x20c248: 0x10000026
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C2E4; return;
    }
label_20c250:
    // 0x20c250: 0x2502ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x20c254: 0x2c420003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 3));
    // 0x20c258: 0x1440000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C284; return;
    }
    // 0x20c260: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20c264: 0x100302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x20c268: 0x24a50260
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 608));
    // 0x20c26c: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20c274);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20c274
// Address: 0x20c274 - 0x20c28c

void entry_20c274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c274) {
        switch (ctx->pc) {
            case 0x20c284: ctx->pc = 0; goto label_20c284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c274: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c278: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c27c: 0x10000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C3C0; return;
    }
label_20c284:
    // 0x20c284: 0xc0830fc
    SET_GPR_U32(ctx, 31, 0x20c28c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    _getAllRefs(rdram, ctx, runtime); return;
}


// Function: entry_20c28c
// Address: 0x20c28c - 0x20c2cc

void entry_20c28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c28c) {
        switch (ctx->pc) {
            case 0x20c2a8: ctx->pc = 0; goto label_20c2a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c28c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20c290: 0x261106c8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1736));
    // 0x20c294: 0x261206c4
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1732));
    // 0x20c298: 0x261306c0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1728));
    // 0x20c29c: 0x261406b8
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1720));
    // 0x20c2a0: 0x3463d400
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 54272));
    // 0x20c2a4: 0x0
    // NOP
label_20c2a8:
    // 0x20c2a8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20c2ac: 0x21202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 8));
    // 0x20c2b0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x20c2b4: 0x0
    // NOP
    // 0x20c2b8: 0x0
    // NOP
    // 0x20c2bc: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20c2a8;
    }
    // 0x20c2c4: 0xc08430e
    SET_GPR_U32(ctx, 31, 0x20c2cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dmaRefImage(rdram, ctx, runtime); return;
}


// Function: entry_20c2cc
// Address: 0x20c2cc - 0x20c3f0

void entry_20c2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c2cc) {
        switch (ctx->pc) {
            case 0x20c2e4: ctx->pc = 0; goto label_20c2e4;
            case 0x20c310: ctx->pc = 0; goto label_20c310;
            case 0x20c314: ctx->pc = 0; goto label_20c314;
            case 0x20c324: ctx->pc = 0; goto label_20c324;
            case 0x20c380: ctx->pc = 0; goto label_20c380;
            case 0x20c38c: ctx->pc = 0; goto label_20c38c;
            case 0x20c3bc: ctx->pc = 0; goto label_20c3bc;
            case 0x20c3c0: ctx->pc = 0; goto label_20c3c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c2cc: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c2d0: 0x24030140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20c2d4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c2d8: 0x432818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c2dc: 0xb11021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 17)));
    // 0x20c2e0: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
label_20c2e4:
    // 0x20c2e4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c2e8: 0x57c2000a
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
        goto label_20c314;
    }
    // 0x20c2f0: 0x32a20002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
    // 0x20c2f4: 0x10400006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20c310;
    }
    // 0x20c2fc: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c300: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c304: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x20c308: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20c324;
    }
label_20c310:
    // 0x20c310: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
label_20c314:
    // 0x20c314: 0x24030140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20c318: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c31c: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x20c320: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
label_20c324:
    // 0x20c324: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c328: 0x24070140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20c32c: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20c330: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20c334: 0x472018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c338: 0x931021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
    // 0x20c33c: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x20c340: 0x8e040174
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20c344: 0x1483000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_20c380;
    }
    // 0x20c34c: 0x8e040810
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c350: 0x24060180
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 384));
    // 0x20c354: 0x8e0501c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 448)));
    // 0x20c358: 0x871818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c35c: 0x8ca20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x20c360: 0x742021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x20c364: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20c368: 0x2c22818
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c36c: 0xb71021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 23)));
    // 0x20c370: 0x461018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c374: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20c378: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20c3bc;
    }
label_20c380:
    // 0x20c380: 0x54820002
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 464)));
        goto label_20c38c;
    }
    // 0x20c388: 0x8e0201e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 480)));
label_20c38c:
    // 0x20c38c: 0x8c430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x20c390: 0x24060180
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 384));
    // 0x20c394: 0x8e040810
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20c398: 0x24050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20c39c: 0x2c33818
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c3a0: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20c3a4: 0xf71821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 23)));
    // 0x20c3a8: 0x853818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c3ac: 0x661818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20c3b0: 0xf42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 20)));
    // 0x20c3b4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20c3b8: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
label_20c3bc:
    // 0x20c3bc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_20c3c0:
    // 0x20c3c0: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20c3c4: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20c3c8: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20c3cc: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20c3d0: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20c3d4: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20c3d8: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20c3dc: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20c3e0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20c3e4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20c3e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _getAllRefs
// Address: 0x20c3f0 - 0x20c50c

void entry_20c50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c50c: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x20c510: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c514: 0x8e430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x20c518: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c51c: 0x8e2501b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 440)));
    // 0x20c520: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20c524: 0x8fc60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 8)));
    // 0x20c528: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c52c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c530: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c534: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c538: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c53c: 0xafb40010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 20));
    // 0x20c540: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20c544: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c54c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c54c
// Address: 0x20c54c - 0x20c578

void entry_20c54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c54c) {
        switch (ctx->pc) {
            case 0x20c554: ctx->pc = 0; goto label_20c554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c54c: 0x100000e1
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8D4; return;
    }
label_20c554:
    // 0x20c554: 0x16830045
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x20C66C; return;
    }
    // 0x20c55c: 0x8e480004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c560: 0x160302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x20c564: 0x8e470000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c568: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c56c: 0x84043
    SET_GPR_S32(ctx, 8, SRA32(GPR_S32(ctx, 8), 1));
    // 0x20c570: 0xc083848
    SET_GPR_U32(ctx, 31, 0x20c578);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    _dualPrimeVector(rdram, ctx, runtime); return;
}


// Function: entry_20c578
// Address: 0x20c578 - 0x20c5b8

void entry_20c578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c578: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c57c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c580: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c584: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c588: 0x8e2501b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 440)));
    // 0x20c58c: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20c590: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c594: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c598: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c59c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c5a0: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x20c5a4: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c5a8: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x20c5ac: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c5b0: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c5b8);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c5b8
// Address: 0x20c5b8 - 0x20c5f4

void entry_20c5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c5b8: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20c5bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c5c0: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x20c5c4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c5c8: 0x8e2501b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 440)));
    // 0x20c5cc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c5d0: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20c5d4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c5d8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x20c5dc: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c5e0: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x20c5e4: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c5e8: 0xafb30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 19));
    // 0x20c5ec: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c5f4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c5f4
// Address: 0x20c5f4 - 0x20c634

void entry_20c5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c5f4: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c5f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c5fc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c600: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c604: 0x8e2501b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 440)));
    // 0x20c608: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20c60c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c610: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c614: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c618: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c61c: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x20c620: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c624: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x20c628: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c62c: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c634);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c634
// Address: 0x20c634 - 0x20c67c

void entry_20c634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c634) {
        switch (ctx->pc) {
            case 0x20c66c: ctx->pc = 0; goto label_20c66c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c634: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x20c638: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c63c: 0x8fa3002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x20c640: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c644: 0x8e2501b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 440)));
    // 0x20c648: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c64c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20c650: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c654: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x20c658: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c65c: 0xafb30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 19));
    // 0x20c660: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c664: 0x10000092
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8B0; return;
    }
label_20c66c:
    // 0x20c66c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c670: 0x24a50288
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 648));
    // 0x20c674: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20c67c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20c67c
// Address: 0x20c67c - 0x20c780

void entry_20c67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c67c) {
        switch (ctx->pc) {
            case 0x20c684: ctx->pc = 0; goto label_20c684;
            case 0x20c6d0: ctx->pc = 0; goto label_20c6d0;
            case 0x20c6d4: ctx->pc = 0; goto label_20c6d4;
            case 0x20c6e8: ctx->pc = 0; goto label_20c6e8;
            case 0x20c724: ctx->pc = 0; goto label_20c724;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c67c: 0x10000095
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8D4; return;
    }
label_20c684:
    // 0x20c684: 0x8e2701c8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 456)));
    // 0x20c688: 0x8e2501d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 472)));
    // 0x20c68c: 0x2c570001
    SET_GPR_U32(ctx, 23, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x20c690: 0x8e2401cc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 460)));
    // 0x20c694: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20c698: 0x8e2301dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 476)));
    // 0x20c69c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c6a0: 0x8e220150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x20c6a4: 0xafa70030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 7));
    // 0x20c6a8: 0xafa50034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 5));
    // 0x20c6ac: 0xafa40038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 4));
    // 0x20c6b0: 0x14460007
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        goto label_20c6d0;
    }
    // 0x20c6b8: 0x8e220120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x20c6bc: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20c6d4;
    }
    // 0x20c6c4: 0x8fc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x20c6c8: 0x2e21026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x20c6cc: 0x2982b
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_20c6d0:
    // 0x20c6d0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_20c6d4:
    // 0x20c6d4: 0x52820004
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 0)));
        goto label_20c6e8;
    }
    // 0x20c6dc: 0x15800011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20c724;
    }
    // 0x20c6e4: 0x8fc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 0)));
label_20c6e8:
    // 0x20c6e8: 0x1318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 3));
    // 0x20c6ec: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c6f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c6f4: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c6f8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20c6fc: 0xafa60000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 6));
    // 0x20c700: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20c704: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x20c708: 0xafa50008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 5));
    // 0x20c70c: 0x8c650030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x20c710: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c714: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c718: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c71c: 0x10000061
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8A4; return;
    }
label_20c724:
    // 0x20c724: 0x16820033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20C7F4; return;
    }
    // 0x20c72c: 0x8fc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x20c730: 0x1328c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 19), 3));
    // 0x20c734: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c738: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x20c73c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c740: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20c744: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x20c748: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x20c74c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c750: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20c754: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c758: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c75c: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20c760: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c764: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c768: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c76c: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x20c770: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c774: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c778: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c780);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c780
// Address: 0x20c780 - 0x20c820

void entry_20c780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c780) {
        switch (ctx->pc) {
            case 0x20c7a8: ctx->pc = 0; goto label_20c7a8;
            case 0x20c7ac: ctx->pc = 0; goto label_20c7ac;
            case 0x20c7f4: ctx->pc = 0; goto label_20c7f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c780: 0x8e220150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x20c784: 0x14540008
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_20c7a8;
    }
    // 0x20c78c: 0x8e220120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x20c790: 0x10400006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 8)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20c7ac;
    }
    // 0x20c798: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c79c: 0x2e31026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 23), GPR_U32(ctx, 3)));
    // 0x20c7a0: 0x10000002
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20c7ac;
    }
label_20c7a8:
    // 0x20c7a8: 0x8fc30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 8)));
label_20c7ac:
    // 0x20c7ac: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x20c7b0: 0x8e460010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x20c7b4: 0x1318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 3));
    // 0x20c7b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c7bc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x20c7c0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c7c4: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20c7c8: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x20c7cc: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20c7d0: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c7d4: 0xafa60000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 6));
    // 0x20c7d8: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c7dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c7e0: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x20c7e4: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c7e8: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c7ec: 0x10000030
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8B0; return;
    }
label_20c7f4:
    // 0x20c7f4: 0x16820032
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20C8C0; return;
    }
    // 0x20c7fc: 0x8e220120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x20c800: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c804: 0x8e470000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c808: 0x160302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x20c80c: 0x8e480004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c810: 0x2980a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 0));
    // 0x20c814: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c818: 0xc083848
    SET_GPR_U32(ctx, 31, 0x20c820);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    _dualPrimeVector(rdram, ctx, runtime); return;
}


// Function: entry_20c820
// Address: 0x20c820 - 0x20c868

void entry_20c820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20c820: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x20c824: 0x171080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 23), 2));
    // 0x20c828: 0x8e480004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20c82c: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20c830: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20c834: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c838: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20c83c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c840: 0xafa80008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 8));
    // 0x20c844: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c848: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c84c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c850: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c854: 0x24090010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 16));
    // 0x20c858: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x20c85c: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c860: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c868);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c868
// Address: 0x20c868 - 0x20c8b8

void entry_20c868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c868) {
        switch (ctx->pc) {
            case 0x20c8a4: ctx->pc = 0; goto label_20c8a4;
            case 0x20c8b0: ctx->pc = 0; goto label_20c8b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c868: 0x1318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 3));
    // 0x20c86c: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20c870: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x20c874: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x20c878: 0x77100b
    if (GPR_U32(ctx, 23) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    // 0x20c87c: 0xafa40000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 4));
    // 0x20c880: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x20c884: 0xafa50008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 5));
    // 0x20c888: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20c88c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c890: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c894: 0xafa30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 3));
    // 0x20c898: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c89c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c8a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20c8a4:
    // 0x20c8a4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c8a8: 0x24090010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 16));
    // 0x20c8ac: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_20c8b0:
    // 0x20c8b0: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c8b8);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c8b8
// Address: 0x20c8b8 - 0x20c8d0

void entry_20c8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c8b8) {
        switch (ctx->pc) {
            case 0x20c8c0: ctx->pc = 0; goto label_20c8c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c8b8: 0x10000006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C8D4; return;
    }
label_20c8c0:
    // 0x20c8c0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c8c4: 0x24a502a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 680));
    // 0x20c8c8: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20c8d0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20c8d0
// Address: 0x20c8d0 - 0x20c974

void entry_20c8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c8d0) {
        switch (ctx->pc) {
            case 0x20c8d4: ctx->pc = 0; goto label_20c8d4;
            case 0x20c8d8: ctx->pc = 0; goto label_20c8d8;
            case 0x20c934: ctx->pc = 0; goto label_20c934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c8d0: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
label_20c8d4:
    // 0x20c8d4: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
label_20c8d8:
    // 0x20c8d8: 0x30820004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 4));
    // 0x20c8dc: 0x10400079
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20cac4(rdram, ctx, runtime); return;
    }
    // 0x20c8e4: 0x8e230174
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 372)));
    // 0x20c8e8: 0x14620034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20C9BC; return;
    }
    // 0x20c8f0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20c8f4: 0x1682000f
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        goto label_20c934;
    }
    // 0x20c8fc: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x20c900: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c904: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x20c908: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c90c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c910: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20c914: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c918: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c91c: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x20c920: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c924: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20c928: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c92c: 0x1000001f
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20C9AC; return;
    }
label_20c934:
    // 0x20c934: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x20c938: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c93c: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x20c940: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c944: 0x8e2501bc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 444)));
    // 0x20c948: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20c94c: 0x8fc60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x20c950: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c954: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c958: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c95c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c960: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c964: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x20c968: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20c96c: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c974);
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c974
// Address: 0x20c974 - 0x20c9b4

void entry_20c974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c974) {
        switch (ctx->pc) {
            case 0x20c9ac: ctx->pc = 0; goto label_20c9ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c974: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x20c978: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c97c: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x20c980: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c984: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20c988: 0xafb30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 19));
    // 0x20c98c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c990: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20c994: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c998: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20c99c: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x20c9a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c9a4: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20c9a8: 0x8fc6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 12)));
label_20c9ac:
    // 0x20c9ac: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20c9b4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 444)));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20c9b4
// Address: 0x20c9b4 - 0x20ca0c

void entry_20c9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20c9b4) {
        switch (ctx->pc) {
            case 0x20c9bc: ctx->pc = 0; goto label_20c9bc;
            case 0x20c9d4: ctx->pc = 0; goto label_20c9d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20c9b4: 0x10000044
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20CAC8; return;
    }
label_20c9bc:
    // 0x20c9bc: 0x16820015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20CA14; return;
    }
    // 0x20c9c4: 0x8fc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x20c9c8: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 460)));
        goto label_20c9d4;
    }
    // 0x20c9d0: 0x8e2501dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 476)));
label_20c9d4:
    // 0x20c9d4: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x20c9d8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20c9dc: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x20c9e0: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20c9e4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20c9e8: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20c9ec: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20c9f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c9f4: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x20c9f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20c9fc: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20ca00: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca04: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20ca0c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 16));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20ca0c
// Address: 0x20ca0c - 0x20ca64

void entry_20ca0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ca0c) {
        switch (ctx->pc) {
            case 0x20ca14: ctx->pc = 0; goto label_20ca14;
            case 0x20ca2c: ctx->pc = 0; goto label_20ca2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ca0c: 0x1000002e
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20CAC8; return;
    }
label_20ca14:
    // 0x20ca14: 0x16820027
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20CAB4; return;
    }
    // 0x20ca1c: 0x8fc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x20ca20: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 460)));
        goto label_20ca2c;
    }
    // 0x20ca28: 0x8e2501dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 476)));
label_20ca2c:
    // 0x20ca2c: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x20ca30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20ca34: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x20ca38: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca3c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20ca40: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca44: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x20ca48: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca4c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20ca50: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20ca54: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x20ca58: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20ca5c: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20ca64);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20ca64
// Address: 0x20ca64 - 0x20caac

void entry_20ca64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ca64) {
        switch (ctx->pc) {
            case 0x20ca74: ctx->pc = 0; goto label_20ca74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ca64: 0x8fc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 12)));
    // 0x20ca68: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 460)));
        goto label_20ca74;
    }
    // 0x20ca70: 0x8e2501dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 476)));
label_20ca74:
    // 0x20ca74: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x20ca78: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20ca7c: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x20ca80: 0x2a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20ca84: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x20ca88: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20ca8c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x20ca90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca94: 0xafb00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 16));
    // 0x20ca98: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20ca9c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x20caa0: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20caa4: 0xc0832be
    SET_GPR_U32(ctx, 31, 0x20caac);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
    _getRef0(rdram, ctx, runtime); return;
}


// Function: entry_20caac
// Address: 0x20caac - 0x20cac4

void entry_20caac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20caac) {
        switch (ctx->pc) {
            case 0x20cab4: ctx->pc = 0; goto label_20cab4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20caac: 0x10000006
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20CAC8; return;
    }
label_20cab4:
    // 0x20cab4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20cab8: 0x24a502c8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 712));
    // 0x20cabc: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20cac4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20cac4
// Address: 0x20cac4 - 0x20caf8

void entry_20cac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20cac4) {
        switch (ctx->pc) {
            case 0x20cac8: ctx->pc = 0; goto label_20cac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20cac4: 0xdfbf00e0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 224)));
label_20cac8:
    // 0x20cac8: 0xdfbe00d0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x20cacc: 0xdfb700c0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x20cad0: 0xdfb600b0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20cad4: 0xdfb500a0
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20cad8: 0xdfb40090
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20cadc: 0xdfb30080
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20cae0: 0xdfb20070
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20cae4: 0xdfb10060
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20cae8: 0xdfb00050
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20caec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20caf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20caf8; return;
}


// Function: _getRef0
// Address: 0x20caf8 - 0x20cf18

void entry_20cfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20cfc8: 0x2d08021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    // 0x20cfcc: 0x267300b8
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 184));
    // 0x20cfd0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20cfd4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x20cfdc);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_20cfdc
// Address: 0x20cfdc - 0x20d050

void entry_20cfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20cfdc) {
        switch (ctx->pc) {
            case 0x20cffc: ctx->pc = 0; goto label_20cffc;
            case 0x20d00c: ctx->pc = 0; goto label_20d00c;
            case 0x20d018: ctx->pc = 0; goto label_20d018;
            case 0x20d01c: ctx->pc = 0; goto label_20d01c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20cfdc: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x20cfe0: 0x718821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x20cfe4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x20cfe8: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x20cfec: 0x1440ffe8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20CF90; return;
    }
    // 0x20cff4: 0x10000009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20d01c;
    }
label_20cffc:
    // 0x20cffc: 0x268206c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 1728));
    // 0x20d000: 0x269e06b8
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 20), 1720));
    // 0x20d004: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20d018;
    }
label_20d00c:
    // 0x20d00c: 0x268306c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 1728));
    // 0x20d010: 0x269e06b8
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 20), 1720));
    // 0x20d014: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
label_20d018:
    // 0x20d018: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_20d01c:
    // 0x20d01c: 0x24020140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20d020: 0x622018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20d024: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x20d028: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20d02c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20d030: 0x10400007
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20d050(rdram, ctx, runtime); return;
    }
    // 0x20d038: 0x8c4306cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1740)));
    // 0x20d03c: 0x10600004
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_20d050(rdram, ctx, runtime); return;
    }
    // 0x20d044: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x20d048: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20d050);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 744));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20d050
// Address: 0x20d050 - 0x20dee8

void entry_20d050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20d050) {
        switch (ctx->pc) {
            case 0x20d0b0: ctx->pc = 0; goto label_20d0b0;
            case 0x20d0f4: ctx->pc = 0; goto label_20d0f4;
            case 0x20d15c: ctx->pc = 0; goto label_20d15c;
            case 0x20d1d0: ctx->pc = 0; goto label_20d1d0;
            case 0x20d1d8: ctx->pc = 0; goto label_20d1d8;
            case 0x20d28c: ctx->pc = 0; goto label_20d28c;
            case 0x20d2dc: ctx->pc = 0; goto label_20d2dc;
            case 0x20d328: ctx->pc = 0; goto label_20d328;
            case 0x20d348: ctx->pc = 0; goto label_20d348;
            case 0x20d384: ctx->pc = 0; goto label_20d384;
            case 0x20d3fc: ctx->pc = 0; goto label_20d3fc;
            case 0x20d4a8: ctx->pc = 0; goto label_20d4a8;
            case 0x20d4b0: ctx->pc = 0; goto label_20d4b0;
            case 0x20d59c: ctx->pc = 0; goto label_20d59c;
            case 0x20d610: ctx->pc = 0; goto label_20d610;
            case 0x20d658: ctx->pc = 0; goto label_20d658;
            case 0x20d690: ctx->pc = 0; goto label_20d690;
            case 0x20d6e4: ctx->pc = 0; goto label_20d6e4;
            case 0x20d754: ctx->pc = 0; goto label_20d754;
            case 0x20d7f0: ctx->pc = 0; goto label_20d7f0;
            case 0x20d7f8: ctx->pc = 0; goto label_20d7f8;
            case 0x20d8c4: ctx->pc = 0; goto label_20d8c4;
            case 0x20d93c: ctx->pc = 0; goto label_20d93c;
            case 0x20d988: ctx->pc = 0; goto label_20d988;
            case 0x20d9a8: ctx->pc = 0; goto label_20d9a8;
            case 0x20d9fc: ctx->pc = 0; goto label_20d9fc;
            case 0x20da74: ctx->pc = 0; goto label_20da74;
            case 0x20db48: ctx->pc = 0; goto label_20db48;
            case 0x20db50: ctx->pc = 0; goto label_20db50;
            case 0x20dc54: ctx->pc = 0; goto label_20dc54;
            case 0x20dcf0: ctx->pc = 0; goto label_20dcf0;
            case 0x20dd38: ctx->pc = 0; goto label_20dd38;
            case 0x20dd70: ctx->pc = 0; goto label_20dd70;
            case 0x20dddc: ctx->pc = 0; goto label_20dddc;
            case 0x20de28: ctx->pc = 0; goto label_20de28;
            case 0x20de38: ctx->pc = 0; goto label_20de38;
            case 0x20de88: ctx->pc = 0; goto label_20de88;
            case 0x20de98: ctx->pc = 0; goto label_20de98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20d050: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20d054: 0x24020140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20d058: 0x622818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20d05c: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x20d060: 0x451821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x20d064: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20d068: 0x10400011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20d0b0;
    }
    // 0x20d070: 0x3c51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 5)));
    // 0x20d074: 0x2851821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 5)));
    // 0x20d078: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20d07c: 0x8c650594
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 1428)));
    // 0x20d080: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20d084: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20d088: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20d08c: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20d090: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20d094: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20d098: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20d09c: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20d0a0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20d0a4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20d0a8: 0x80837a2
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = 0x20de88; return;
label_20d0b0:
    // 0x20d0b0: 0x8c4306cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1740)));
    // 0x20d0b4: 0x1060000f
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_20d0f4;
    }
    // 0x20d0bc: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20d0c0: 0x8e85081c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 2076)));
    // 0x20d0c4: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20d0c8: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20d0cc: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20d0d0: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20d0d4: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20d0d8: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20d0dc: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20d0e0: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20d0e4: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20d0e8: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20d0ec: 0x80837a2
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = 0x20de88; return;
label_20d0f4:
    // 0x20d0f4: 0x2851821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 5)));
    // 0x20d0f8: 0x8e85081c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 2076)));
    // 0x20d0fc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20d100: 0x8c660594
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 1428)));
    // 0x20d104: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20d108: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20d10c: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20d110: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20d114: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20d118: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20d11c: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20d120: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20d124: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20d128: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20d12c: 0x808378a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = 0x20de28; return;
    // 0x20d134: 0x0
    // NOP
    // 0x20d138: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d13c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d140: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d144: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d148: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d14c: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d150: 0xc5840
    SET_GPR_U32(ctx, 11, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d154: 0x240fffff
    SET_GPR_S32(ctx, 15, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d158: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
label_20d15c:
    // 0x20d15c: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d160: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d164: 0x78c90000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d168: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d16c: 0x712856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 9);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d170: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d174: 0x700a4ea8
    SET_GPR_VEC(ctx, 9, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d178: 0x7dc80000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 8));
    // 0x20d17c: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d180: 0x7dc90010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 9));
    // 0x20d184: 0x1ce0fff5
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 11)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d15c;
    }
    // 0x20d18c: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d190: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d194: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d198: 0x1e75024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 15), GPR_U32(ctx, 7)));
    // 0x20d19c: 0x1540ffef
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d15c;
    }
    // 0x20d1a4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d1ac: 0x0
    // NOP
    // 0x20d1b0: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d1b4: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d1b8: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d1bc: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d1c0: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d1c4: 0xc5840
    SET_GPR_U32(ctx, 11, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d1c8: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d1cc: 0x2418ffff
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20d1d0:
    // 0x20d1d0: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d1d4: 0x240fffff
    SET_GPR_S32(ctx, 15, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20d1d8:
    // 0x20d1d8: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d1dc: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d1e0: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d1e4: 0x71084ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 9, result); 
}
    // 0x20d1e8: 0x70094688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 9)));
    // 0x20d1ec: 0x7dc80000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 8));
    // 0x20d1f0: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d1f4: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d1f8: 0x1cb7021
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 11)));
    // 0x20d1fc: 0x1ce0fff6
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d1d8;
    }
    // 0x20d204: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20d208: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20d20c: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d210: 0x1e75024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 15), GPR_U32(ctx, 7)));
    // 0x20d214: 0x1540fff0
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d1d8;
    }
    // 0x20d21c: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d220: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d224: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d228: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20d22c: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20d230: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20d234: 0x1700ffe6
    SET_GPR_U64(ctx, 24, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 24) != GPR_U32(ctx, 0)) {
        goto label_20d1d0;
    }
    // 0x20d23c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d244: 0x0
    // NOP
    // 0x20d248: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d24c: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d250: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d254: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d258: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d25c: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d260: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d264: 0x8c980010
    SET_GPR_U32(ctx, 24, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d268: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d26c: 0x186040
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 24), 1));
    // 0x20d270: 0x78c90000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d274: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d278: 0x712856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 9);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d27c: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d280: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d284: 0x10e00015
    SET_GPR_VEC(ctx, 9, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d2dc;
    }
label_20d28c:
    // 0x20d28c: 0xb82821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 24)));
    // 0x20d290: 0xd83021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 24)));
    // 0x20d294: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d298: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d29c: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20d2a0: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d2a4: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d2a8: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d2ac: 0x710a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20d2b0: 0x712f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    // 0x20d2b4: 0x714044a9
    SET_GPR_VEC(ctx, 8, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d2b8: 0x71e04ca9
    SET_GPR_VEC(ctx, 9, PS2_POR(GPR_VEC(ctx, 15), GPR_VEC(ctx, 0)));
    // 0x20d2bc: 0x70591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20d2c0: 0x70791908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20d2c4: 0x70021076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 1));
    // 0x20d2c8: 0x70031876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 1));
    // 0x20d2cc: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20d2d0: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20d2d4: 0x1ce0ffed
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 12)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d28c;
    }
label_20d2dc:
    // 0x20d2dc: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d2e0: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d2e4: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d2e8: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d2ec: 0x1540ffe7
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d28c;
    }
    // 0x20d2f4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d2fc: 0x0
    // NOP
    // 0x20d300: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d304: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d308: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d30c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d310: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d314: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d318: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d31c: 0x240b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d320: 0xcc040
    SET_GPR_U32(ctx, 24, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d324: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
label_20d328:
    // 0x20d328: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d32c: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d330: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d334: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d338: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d33c: 0x356b8000
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 11), 32768));
    // 0x20d340: 0x10e00010
    SET_GPR_VEC(ctx, 15, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d384;
    }
label_20d348:
    // 0x20d348: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d34c: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d350: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d354: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d358: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d35c: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d360: 0x70085688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d364: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d368: 0x714f4908
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 15)));
    // 0x20d36c: 0x71407ca9
    SET_GPR_VEC(ctx, 15, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d370: 0x71395108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 25)));
    // 0x20d374: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d378: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20d37c: 0x1ce0fff2
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 24)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d348;
    }
label_20d384:
    // 0x20d384: 0x700b53f7
    SET_GPR_VEC(ctx, 10, _mm_srai_epi16(GPR_VEC(ctx, 11), 15));
    // 0x20d388: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20d38c: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d390: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20d394: 0x1475024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    // 0x20d398: 0x1540ffeb
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 32767));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d348;
    }
    // 0x20d3a0: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d3a4: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d3a8: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d3ac: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20d3b0: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20d3b4: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20d3b8: 0x316a0001
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), 1));
    // 0x20d3bc: 0x1540ffda
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 65534));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d328;
    }
    // 0x20d3c4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d3cc: 0x0
    // NOP
    // 0x20d3d0: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d3d4: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d3d8: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d3dc: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d3e0: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d3e4: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d3e8: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d3ec: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d3f0: 0x8c890010
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d3f4: 0x94040
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 9), 1));
    // 0x20d3f8: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20d3fc:
    // 0x20d3fc: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d400: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d404: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d408: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20d40c: 0x714f1ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 15);
    __m128i val_rs = GPR_VEC(ctx, 10);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20d410: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d414: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d418: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d41c: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d420: 0x70621ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 2);
    __m128i val_rs = GPR_VEC(ctx, 3);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20d424: 0x70031688
    SET_GPR_VEC(ctx, 2, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20d428: 0x70031ea8
    SET_GPR_VEC(ctx, 3, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20d42c: 0x71425108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 2)));
    // 0x20d430: 0x71e37908
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 3)));
    // 0x20d434: 0x71591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 25)));
    // 0x20d438: 0x71f91908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 25)));
    // 0x20d43c: 0x70021076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 1));
    // 0x20d440: 0x70031876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 1));
    // 0x20d444: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20d448: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20d44c: 0xa92821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x20d450: 0xc93021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 9)));
    // 0x20d454: 0x1ce0ffe9
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 8)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d3fc;
    }
    // 0x20d45c: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d460: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d464: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d468: 0x1676024
    SET_GPR_U32(ctx, 12, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d46c: 0x1580ffe3
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20d3fc;
    }
    // 0x20d474: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d47c: 0x0
    // NOP
    // 0x20d480: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d484: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d488: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d48c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d490: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d494: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d498: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d49c: 0x240cffff
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d4a0: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d4a4: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
label_20d4a8:
    // 0x20d4a8: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d4ac: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20d4b0:
    // 0x20d4b0: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d4b4: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d4b8: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d4bc: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d4c0: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d4c4: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d4c8: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d4cc: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20d4d0: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20d4d4: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d4d8: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d4dc: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d4e0: 0x71285108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d4e4: 0x71595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 25)));
    // 0x20d4e8: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d4ec: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20d4f0: 0x1ce0ffef
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d4b0;
    }
    // 0x20d4f8: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20d4fc: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20d500: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d504: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d508: 0x1540ffe9
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d4b0;
    }
    // 0x20d510: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d514: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d518: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d51c: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20d520: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20d524: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20d528: 0x1580ffdf
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20d4a8;
    }
    // 0x20d530: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d538: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d53c: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d540: 0x7019c874
    SET_GPR_VEC(ctx, 25, _mm_slli_epi16(GPR_VEC(ctx, 25), 1));
    // 0x20d544: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d548: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d54c: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d550: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d554: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d558: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d55c: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d560: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d564: 0x78c90000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d568: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d56c: 0x712856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 9);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d570: 0x71097ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 9);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 15, result); 
}
    // 0x20d574: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d578: 0x700a4ea8
    SET_GPR_VEC(ctx, 9, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d57c: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d580: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d584: 0x71ea7ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 15, result); 
}
    // 0x20d588: 0x700f5688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 15)));
    // 0x20d58c: 0x700f7ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 15)));
    // 0x20d590: 0x710a4108
    SET_GPR_VEC(ctx, 8, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20d594: 0x10e0001e
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d610;
    }
label_20d59c:
    // 0x20d59c: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d5a0: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d5a4: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d5a8: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d5ac: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d5b0: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20d5b4: 0x714f1ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 15);
    __m128i val_rs = GPR_VEC(ctx, 10);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20d5b8: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d5bc: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d5c0: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d5c4: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d5c8: 0x70621ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 2);
    __m128i val_rs = GPR_VEC(ctx, 3);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20d5cc: 0x70031688
    SET_GPR_VEC(ctx, 2, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20d5d0: 0x70031ea8
    SET_GPR_VEC(ctx, 3, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20d5d4: 0x71425108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 2)));
    // 0x20d5d8: 0x71e37908
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 3)));
    // 0x20d5dc: 0x710a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20d5e0: 0x712f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    // 0x20d5e4: 0x714044a9
    SET_GPR_VEC(ctx, 8, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d5e8: 0x71e04ca9
    SET_GPR_VEC(ctx, 9, PS2_POR(GPR_VEC(ctx, 15), GPR_VEC(ctx, 0)));
    // 0x20d5ec: 0x70591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20d5f0: 0x70791908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20d5f4: 0x700210b6
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 2));
    // 0x20d5f8: 0x700318b6
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 2));
    // 0x20d5fc: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20d600: 0xc5040
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d604: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20d608: 0x1ce0ffe4
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 10)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d59c;
    }
label_20d610:
    // 0x20d610: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d614: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d618: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d61c: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d620: 0x1540ffde
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d59c;
    }
    // 0x20d628: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d630: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d634: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d638: 0x7019c874
    SET_GPR_VEC(ctx, 25, _mm_slli_epi16(GPR_VEC(ctx, 25), 1));
    // 0x20d63c: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d640: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d644: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d648: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d64c: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d650: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d654: 0x240b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 1));
label_20d658:
    // 0x20d658: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d65c: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d660: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d664: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d668: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d66c: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d670: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d674: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d678: 0x356b8000
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 11), 32768));
    // 0x20d67c: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d680: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d684: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d688: 0x10e00016
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d6e4;
    }
label_20d690:
    // 0x20d690: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d694: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d698: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d69c: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d6a0: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d6a4: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d6a8: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d6ac: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d6b0: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d6b4: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20d6b8: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d6bc: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d6c0: 0x71285108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d6c4: 0x714f4908
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 15)));
    // 0x20d6c8: 0x71407ca9
    SET_GPR_VEC(ctx, 15, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d6cc: 0x71395108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 25)));
    // 0x20d6d0: 0xc4040
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d6d4: 0x700a50b6
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 2));
    // 0x20d6d8: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20d6dc: 0x1ce0ffec
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 8)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d690;
    }
label_20d6e4:
    // 0x20d6e4: 0x700b53f7
    SET_GPR_VEC(ctx, 10, _mm_srai_epi16(GPR_VEC(ctx, 11), 15));
    // 0x20d6e8: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20d6ec: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d6f0: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20d6f4: 0x1475024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    // 0x20d6f8: 0x1540ffe5
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 32767));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d690;
    }
    // 0x20d700: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d704: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d708: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d70c: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20d710: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20d714: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20d718: 0x316a0001
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), 1));
    // 0x20d71c: 0x1540ffce
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 65534));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d658;
    }
    // 0x20d724: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d72c: 0x0
    // NOP
    // 0x20d730: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d734: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d738: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d73c: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d740: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d744: 0x8c890010
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d748: 0x94040
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 9), 1));
    // 0x20d74c: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d750: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
label_20d754:
    // 0x20d754: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d758: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d75c: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20d760: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d764: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d768: 0x79c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20d76c: 0x79c30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 14), 16)));
    // 0x20d770: 0x704a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 10)));
    // 0x20d774: 0x706f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 15)));
    // 0x20d778: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d77c: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d780: 0x70595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20d784: 0x700a1076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d788: 0x70795108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20d78c: 0x700a1876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d790: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20d794: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20d798: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d79c: 0xa92821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x20d7a0: 0x1c87021
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 8)));
    // 0x20d7a4: 0x1ce0ffeb
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 9)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d754;
    }
    // 0x20d7ac: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d7b0: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d7b4: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d7b8: 0x1676024
    SET_GPR_U32(ctx, 12, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d7bc: 0x1580ffe5
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20d754;
    }
    // 0x20d7c4: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d7cc: 0x0
    // NOP
    // 0x20d7d0: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d7d4: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d7d8: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d7dc: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d7e0: 0x240cffff
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d7e4: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d7e8: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
    // 0x20d7ec: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
label_20d7f0:
    // 0x20d7f0: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d7f4: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20d7f8:
    // 0x20d7f8: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d7fc: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d800: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d804: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d808: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d80c: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d810: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20d814: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20d818: 0x79c80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20d81c: 0x71285108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d820: 0x71404988
    SET_GPR_VEC(ctx, 9, PS2_PCGTH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d824: 0x70094bf6
    SET_GPR_VEC(ctx, 9, _mm_srli_epi16(GPR_VEC(ctx, 9), 15));
    // 0x20d828: 0x71495108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 9)));
    // 0x20d82c: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d830: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20d834: 0x1ce0fff0
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d7f8;
    }
    // 0x20d83c: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20d840: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20d844: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d848: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d84c: 0x1540ffea
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d7f8;
    }
    // 0x20d854: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d858: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d85c: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d860: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20d864: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20d868: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20d86c: 0x1580ffe0
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20d7f0;
    }
    // 0x20d874: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d87c: 0x0
    // NOP
    // 0x20d880: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d884: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d888: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d88c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d890: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d894: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d898: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d89c: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d8a0: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d8a4: 0x78c90000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d8a8: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20d8ac: 0x712856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 9);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20d8b0: 0xcc040
    SET_GPR_U32(ctx, 24, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d8b4: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20d8b8: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20d8bc: 0x10e0001f
    SET_GPR_VEC(ctx, 9, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d93c;
    }
label_20d8c4:
    // 0x20d8c4: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d8c8: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d8cc: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d8d0: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d8d4: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20d8d8: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d8dc: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d8e0: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20d8e4: 0x710a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20d8e8: 0x712f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    // 0x20d8ec: 0x714044a9
    SET_GPR_VEC(ctx, 8, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d8f0: 0x71e04ca9
    SET_GPR_VEC(ctx, 9, PS2_POR(GPR_VEC(ctx, 15), GPR_VEC(ctx, 0)));
    // 0x20d8f4: 0x70591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20d8f8: 0x70791908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20d8fc: 0x70021076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 1));
    // 0x20d900: 0x70031876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 1));
    // 0x20d904: 0x79ca0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20d908: 0x79cf0010
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 14), 16)));
    // 0x20d90c: 0x704a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 10)));
    // 0x20d910: 0x706f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 15)));
    // 0x20d914: 0x70595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20d918: 0x700a1076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d91c: 0x70605188
    SET_GPR_VEC(ctx, 10, PS2_PCGTH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 0)));
    // 0x20d920: 0x700a53f6
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 15));
    // 0x20d924: 0x706a5108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 10)));
    // 0x20d928: 0x700a1876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d92c: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20d930: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20d934: 0x1ce0ffe3
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 24)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d8c4;
    }
label_20d93c:
    // 0x20d93c: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20d940: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20d944: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20d948: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20d94c: 0x1540ffdd
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d8c4;
    }
    // 0x20d954: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20d95c: 0x0
    // NOP
    // 0x20d960: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20d964: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20d968: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20d96c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20d970: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20d974: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20d978: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20d97c: 0x240b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20d980: 0xcc040
    SET_GPR_U32(ctx, 24, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20d984: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
label_20d988:
    // 0x20d988: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20d98c: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d990: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d994: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d998: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d99c: 0x356b8000
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 11), 32768));
    // 0x20d9a0: 0x10e00016
    SET_GPR_VEC(ctx, 15, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20d9fc;
    }
label_20d9a8:
    // 0x20d9a8: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20d9ac: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20d9b0: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20d9b4: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20d9b8: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20d9bc: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20d9c0: 0x70085688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20d9c4: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20d9c8: 0x714f4908
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 15)));
    // 0x20d9cc: 0x71407ca9
    SET_GPR_VEC(ctx, 15, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d9d0: 0x71395108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 25)));
    // 0x20d9d4: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d9d8: 0x79c80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20d9dc: 0x71485108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 8)));
    // 0x20d9e0: 0x71404988
    SET_GPR_VEC(ctx, 9, PS2_PCGTH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20d9e4: 0x70094bf6
    SET_GPR_VEC(ctx, 9, _mm_srli_epi16(GPR_VEC(ctx, 9), 15));
    // 0x20d9e8: 0x71495108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 9)));
    // 0x20d9ec: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20d9f0: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20d9f4: 0x1ce0ffec
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 24)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20d9a8;
    }
label_20d9fc:
    // 0x20d9fc: 0x700b53f7
    SET_GPR_VEC(ctx, 10, _mm_srai_epi16(GPR_VEC(ctx, 11), 15));
    // 0x20da00: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20da04: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20da08: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20da0c: 0x1475024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    // 0x20da10: 0x1540ffe5
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 32767));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d9a8;
    }
    // 0x20da18: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20da1c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20da20: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20da24: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20da28: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20da2c: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20da30: 0x316a0001
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), 1));
    // 0x20da34: 0x1540ffd4
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 65534));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20d988;
    }
    // 0x20da3c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20da44: 0x0
    // NOP
    // 0x20da48: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20da4c: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20da50: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20da54: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20da58: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20da5c: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20da60: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20da64: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20da68: 0x8c890010
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20da6c: 0x94040
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 9), 1));
    // 0x20da70: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20da74:
    // 0x20da74: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20da78: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20da7c: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20da80: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20da84: 0x714f1ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 15);
    __m128i val_rs = GPR_VEC(ctx, 10);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20da88: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20da8c: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20da90: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20da94: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20da98: 0x70621ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 2);
    __m128i val_rs = GPR_VEC(ctx, 3);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20da9c: 0x70031688
    SET_GPR_VEC(ctx, 2, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20daa0: 0x70031ea8
    SET_GPR_VEC(ctx, 3, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20daa4: 0x71425108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 2)));
    // 0x20daa8: 0x71e37908
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 3)));
    // 0x20daac: 0x71591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 25)));
    // 0x20dab0: 0x71f91908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 25)));
    // 0x20dab4: 0x70021076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 1));
    // 0x20dab8: 0x70031876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 1));
    // 0x20dabc: 0x79ca0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20dac0: 0x79cf0010
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 14), 16)));
    // 0x20dac4: 0x704a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 10)));
    // 0x20dac8: 0x706f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 15)));
    // 0x20dacc: 0x70595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20dad0: 0x700a1076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20dad4: 0x70605188
    SET_GPR_VEC(ctx, 10, PS2_PCGTH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 0)));
    // 0x20dad8: 0x700a53f6
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 15));
    // 0x20dadc: 0x706a5108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 10)));
    // 0x20dae0: 0x700a1876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20dae4: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20dae8: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20daec: 0xa92821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 9)));
    // 0x20daf0: 0xc93021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 9)));
    // 0x20daf4: 0x1ce0ffdf
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 8)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20da74;
    }
    // 0x20dafc: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20db00: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20db04: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20db08: 0x1676024
    SET_GPR_U32(ctx, 12, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20db0c: 0x1580ffd9
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20da74;
    }
    // 0x20db14: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20db1c: 0x0
    // NOP
    // 0x20db20: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20db24: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20db28: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20db2c: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20db30: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20db34: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20db38: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20db3c: 0x240cffff
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20db40: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20db44: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
label_20db48:
    // 0x20db48: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20db4c: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
label_20db50:
    // 0x20db50: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20db54: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20db58: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20db5c: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20db60: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20db64: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20db68: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20db6c: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20db70: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20db74: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20db78: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20db7c: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20db80: 0x71285108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20db84: 0x71595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 25)));
    // 0x20db88: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20db8c: 0x79c80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20db90: 0x71485108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 8)));
    // 0x20db94: 0x71404988
    SET_GPR_VEC(ctx, 9, PS2_PCGTH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20db98: 0x70094bf6
    SET_GPR_VEC(ctx, 9, _mm_srli_epi16(GPR_VEC(ctx, 9), 15));
    // 0x20db9c: 0x71495108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 9)));
    // 0x20dba0: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20dba4: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20dba8: 0x1ce0ffe9
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20db50;
    }
    // 0x20dbb0: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20dbb4: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20dbb8: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20dbbc: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20dbc0: 0x1540ffe3
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20db50;
    }
    // 0x20dbc8: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20dbcc: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20dbd0: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20dbd4: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20dbd8: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20dbdc: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20dbe0: 0x1580ffd9
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20db48;
    }
    // 0x20dbe8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20dbf0: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20dbf4: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20dbf8: 0x7019c874
    SET_GPR_VEC(ctx, 25, _mm_slli_epi16(GPR_VEC(ctx, 25), 1));
    // 0x20dbfc: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20dc00: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20dc04: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20dc08: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20dc0c: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20dc10: 0x8c980010
    SET_GPR_U32(ctx, 24, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20dc14: 0x240c0001
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20dc18: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20dc1c: 0x78c90000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20dc20: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20dc24: 0x712856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 9);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20dc28: 0x71097ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 9);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 15, result); 
}
    // 0x20dc2c: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20dc30: 0x700a4ea8
    SET_GPR_VEC(ctx, 9, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20dc34: 0x240bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x20dc38: 0x5980000
    ctx->sa = (GPR_U32(ctx, 12) + 0) & 0xF;
    // 0x20dc3c: 0x71ea7ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 15, result); 
}
    // 0x20dc40: 0x700f5688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 15)));
    // 0x20dc44: 0x700f7ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 15)));
    // 0x20dc48: 0x710a4108
    SET_GPR_VEC(ctx, 8, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20dc4c: 0x10e00028
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20dcf0;
    }
label_20dc54:
    // 0x20dc54: 0xb82821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 24)));
    // 0x20dc58: 0xd83021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 24)));
    // 0x20dc5c: 0x78aa0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20dc60: 0x78cf0000
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20dc64: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20dc68: 0x71ea16e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 10);
    __m128i val_rs = GPR_VEC(ctx, 15);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 2, result); 
}
    // 0x20dc6c: 0x714f1ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 15);
    __m128i val_rs = GPR_VEC(ctx, 10);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20dc70: 0x70025688
    SET_GPR_VEC(ctx, 10, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20dc74: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20dc78: 0x70027ea8
    SET_GPR_VEC(ctx, 15, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x20dc7c: 0x5980000
    ctx->sa = (GPR_U32(ctx, 12) + 0) & 0xF;
    // 0x20dc80: 0x70621ee8
    { 
    __m128i val_rt = GPR_VEC(ctx, 2);
    __m128i val_rs = GPR_VEC(ctx, 3);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 3, result); 
}
    // 0x20dc84: 0x70031688
    SET_GPR_VEC(ctx, 2, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20dc88: 0x70031ea8
    SET_GPR_VEC(ctx, 3, PS2_PEXTUB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x20dc8c: 0x71425108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 2)));
    // 0x20dc90: 0x71e37908
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 15), GPR_VEC(ctx, 3)));
    // 0x20dc94: 0x710a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 10)));
    // 0x20dc98: 0x712f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 15)));
    // 0x20dc9c: 0x714044a9
    SET_GPR_VEC(ctx, 8, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20dca0: 0x71e04ca9
    SET_GPR_VEC(ctx, 9, PS2_POR(GPR_VEC(ctx, 15), GPR_VEC(ctx, 0)));
    // 0x20dca4: 0x70591108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20dca8: 0x70791908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20dcac: 0x700210b6
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 2), 2));
    // 0x20dcb0: 0x700318b6
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 3), 2));
    // 0x20dcb4: 0x79ca0000
    SET_GPR_VEC(ctx, 10, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20dcb8: 0x79cf0010
    SET_GPR_VEC(ctx, 15, READ128(ADD32(GPR_U32(ctx, 14), 16)));
    // 0x20dcbc: 0x704a1108
    SET_GPR_VEC(ctx, 2, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 10)));
    // 0x20dcc0: 0x706f1908
    SET_GPR_VEC(ctx, 3, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 15)));
    // 0x20dcc4: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20dcc8: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20dccc: 0x70595108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 2), GPR_VEC(ctx, 25)));
    // 0x20dcd0: 0x700a1076
    SET_GPR_VEC(ctx, 2, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20dcd4: 0x70795108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 3), GPR_VEC(ctx, 25)));
    // 0x20dcd8: 0x700a1876
    SET_GPR_VEC(ctx, 3, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20dcdc: 0x7dc20000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 2));
    // 0x20dce0: 0x185040
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 24), 1));
    // 0x20dce4: 0x7dc30010
    WRITE128(ADD32(GPR_U32(ctx, 14), 16), GPR_VEC(ctx, 3));
    // 0x20dce8: 0x1ce0ffda
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 10)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20dc54;
    }
label_20dcf0:
    // 0x20dcf0: 0x24a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 128));
    // 0x20dcf4: 0x24c60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 128));
    // 0x20dcf8: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20dcfc: 0x1675024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), GPR_U32(ctx, 7)));
    // 0x20dd00: 0x1540ffd4
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20dc54;
    }
    // 0x20dd08: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20dd10: 0x7000cce9
    SET_GPR_VEC(ctx, 25, PS2_PNOR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x20dd14: 0x7019cbf6
    SET_GPR_VEC(ctx, 25, _mm_srli_epi16(GPR_VEC(ctx, 25), 15));
    // 0x20dd18: 0x7019c874
    SET_GPR_VEC(ctx, 25, _mm_slli_epi16(GPR_VEC(ctx, 25), 1));
    // 0x20dd1c: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20dd20: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20dd24: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20dd28: 0x8c8d0004
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x20dd2c: 0x8c8c0010
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x20dd30: 0x24180001
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20dd34: 0x240b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 1));
label_20dd38:
    // 0x20dd38: 0x8c870008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x20dd3c: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20dd40: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20dd44: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20dd48: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20dd4c: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20dd50: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20dd54: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20dd58: 0x356b8000
    SET_GPR_U32(ctx, 11, OR32(GPR_U32(ctx, 11), 32768));
    // 0x20dd5c: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20dd60: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20dd64: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20dd68: 0x10e0001c
    SET_GPR_VEC(ctx, 15, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20dddc;
    }
label_20dd70:
    // 0x20dd70: 0xcc3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 12)));
    // 0x20dd74: 0xdca80000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20dd78: 0xdcc90000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20dd7c: 0x71284389
    SET_GPR_VEC(ctx, 8, _mm_unpacklo_epi64(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20dd80: 0x5b80000
    ctx->sa = (GPR_U32(ctx, 13) + 0) & 0xF;
    // 0x20dd84: 0x710846e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 8);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 8, result); 
}
    // 0x20dd88: 0x70084e88
    SET_GPR_VEC(ctx, 9, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 8)));
    // 0x20dd8c: 0x20e7ffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 7), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 7, (int32_t)tmp); }
    // 0x20dd90: 0xac2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 12)));
    // 0x20dd94: 0x7180000
    ctx->sa = (GPR_U32(ctx, 24) + 0) & 0xF;
    // 0x20dd98: 0x700856e8
    { 
    __m128i val_rt = GPR_VEC(ctx, 8);
    __m128i val_rs = GPR_VEC(ctx, 0);
    uint32_t shift_amount = ctx->sa & 0x7F; 
    uint64_t rt_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rt, 8));
    uint64_t rt_lo = _mm_cvtsi128_si64(val_rt);
    uint64_t rs_hi = _mm_cvtsi128_si64(_mm_srli_si128(val_rs, 8));
    uint64_t rs_lo = _mm_cvtsi128_si64(val_rs);
    __m128i result; 
    if (shift_amount == 0) { 
        result = val_rs; 
    } else if (shift_amount < 64) { 
        uint64_t res_lo = (rs_lo >> shift_amount) | (rs_hi << (64 - shift_amount)); 
        uint64_t res_hi = (rs_hi >> shift_amount) | (rt_lo << (64 - shift_amount)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else if (shift_amount == 64) { 
        result = _mm_set_epi64x(rt_lo, rs_hi); 
    } else if (shift_amount < 128) { 
        uint32_t sub_shift = shift_amount - 64; 
        uint64_t res_lo = (rs_hi >> sub_shift) | (rt_lo << (64 - sub_shift)); 
        uint64_t res_hi = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
        result = _mm_set_epi64x(res_hi, res_lo); 
    } else { // shift_amount >= 128 
         uint32_t sub_shift = shift_amount - 128; 
         uint64_t res_lo = (rt_lo >> sub_shift) | (rt_hi << (64 - sub_shift)); 
         uint64_t res_hi = (rt_hi >> sub_shift); 
         result = _mm_set_epi64x(res_hi, res_lo); 
    } 
    SET_GPR_VEC(ctx, 10, result); 
}
    // 0x20dd9c: 0x700a4688
    SET_GPR_VEC(ctx, 8, PS2_PEXTLB(GPR_VEC(ctx, 0), GPR_VEC(ctx, 10)));
    // 0x20dda0: 0x71285108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20dda4: 0x714f4908
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 15)));
    // 0x20dda8: 0x71407ca9
    SET_GPR_VEC(ctx, 15, PS2_POR(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20ddac: 0x71395108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 25)));
    // 0x20ddb0: 0x700a50b6
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 2));
    // 0x20ddb4: 0x79c80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 14), 0)));
    // 0x20ddb8: 0x71485108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 8)));
    // 0x20ddbc: 0x71404988
    SET_GPR_VEC(ctx, 9, PS2_PCGTH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 0)));
    // 0x20ddc0: 0x70094bf6
    SET_GPR_VEC(ctx, 9, _mm_srli_epi16(GPR_VEC(ctx, 9), 15));
    // 0x20ddc4: 0x71495108
    SET_GPR_VEC(ctx, 10, PS2_PADDH(GPR_VEC(ctx, 10), GPR_VEC(ctx, 9)));
    // 0x20ddc8: 0xc4040
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 12), 1));
    // 0x20ddcc: 0x700a5076
    SET_GPR_VEC(ctx, 10, _mm_srli_epi16(GPR_VEC(ctx, 10), 1));
    // 0x20ddd0: 0x7dca0000
    WRITE128(ADD32(GPR_U32(ctx, 14), 0), GPR_VEC(ctx, 10));
    // 0x20ddd4: 0x1ce0ffe6
    SET_GPR_U32(ctx, 14, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 8)));
    if (GPR_S32(ctx, 7) > 0) {
        goto label_20dd70;
    }
label_20dddc:
    // 0x20dddc: 0x700b53f7
    SET_GPR_VEC(ctx, 10, _mm_srai_epi16(GPR_VEC(ctx, 11), 15));
    // 0x20dde0: 0x24a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    // 0x20dde4: 0x8c87000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x20dde8: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x20ddec: 0x1475024
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    // 0x20ddf0: 0x1540ffdf
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 32767));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20dd70;
    }
    // 0x20ddf8: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x20ddfc: 0x8c860018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x20de00: 0x8c8e0000
    SET_GPR_U32(ctx, 14, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20de04: 0x24a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    // 0x20de08: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x20de0c: 0x25ce0080
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 14), 128));
    // 0x20de10: 0x316a0001
    SET_GPR_U32(ctx, 10, AND32(GPR_U32(ctx, 11), 1));
    // 0x20de14: 0x1540ffc8
    SET_GPR_U32(ctx, 11, AND32(GPR_U32(ctx, 11), 65534));
    if (GPR_U32(ctx, 10) != GPR_U32(ctx, 0)) {
        goto label_20dd38;
    }
    // 0x20de1c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20de24: 0x0
    // NOP
label_20de28:
    // 0x20de28: 0x240c0018
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 24));
    // 0x20de2c: 0x3c0a0021
    SET_GPR_U32(ctx, 10, ((uint32_t)33 << 16));
    // 0x20de30: 0x254aded0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294958800));
    // 0x20de34: 0x794b0000
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 10), 0)));
label_20de38:
    // 0x20de38: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20de3c: 0x218cffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 12), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 12, (int32_t)tmp); }
    // 0x20de40: 0x78cd0000
    SET_GPR_VEC(ctx, 13, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x20de44: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    // 0x20de48: 0x78a90010
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x20de4c: 0x710d4108
    SET_GPR_VEC(ctx, 8, PS2_PADDH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 13)));
    // 0x20de50: 0x78c20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x20de54: 0x710b41e8
    SET_GPR_VEC(ctx, 8, PS2_PMINH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 11)));
    // 0x20de58: 0x71224908
    SET_GPR_VEC(ctx, 9, PS2_PADDH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 2)));
    // 0x20de5c: 0x710041c8
    SET_GPR_VEC(ctx, 8, PS2_PMAXH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 0)));
    // 0x20de60: 0x712b49e8
    SET_GPR_VEC(ctx, 9, PS2_PMINH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 11)));
    // 0x20de64: 0x24a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    // 0x20de68: 0x712049c8
    SET_GPR_VEC(ctx, 9, PS2_PMAXH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 0)));
    // 0x20de6c: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x20de70: 0x712856c8
    SET_GPR_VEC(ctx, 10, PS2_PPACB(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20de74: 0x1580fff0
    WRITE128(ADD32(GPR_U32(ctx, 4), 4294967280), GPR_VEC(ctx, 10));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20de38;
    }
    // 0x20de7c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20de84: 0x0
    // NOP
label_20de88:
    // 0x20de88: 0x240c0018
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 24));
    // 0x20de8c: 0x3c0a0021
    SET_GPR_U32(ctx, 10, ((uint32_t)33 << 16));
    // 0x20de90: 0x254aded0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294958800));
    // 0x20de94: 0x794b0000
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 10), 0)));
label_20de98:
    // 0x20de98: 0x78a80000
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20de9c: 0x218cffff
    { uint32_t tmp; bool ov; ADD32_OV(GPR_U32(ctx, 12), (int32_t)4294967295, tmp, ov); if (ov) runtime->SignalException(ctx, EXCEPTION_INTEGER_OVERFLOW); else SET_GPR_S32(ctx, 12, (int32_t)tmp); }
    // 0x20dea0: 0x710b41e8
    SET_GPR_VEC(ctx, 8, PS2_PMINH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 11)));
    // 0x20dea4: 0x78a90010
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x20dea8: 0x710041c8
    SET_GPR_VEC(ctx, 8, PS2_PMAXH(GPR_VEC(ctx, 8), GPR_VEC(ctx, 0)));
    // 0x20deac: 0x712b49e8
    SET_GPR_VEC(ctx, 9, PS2_PMINH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 11)));
    // 0x20deb0: 0x24a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    // 0x20deb4: 0x712049c8
    SET_GPR_VEC(ctx, 9, PS2_PMAXH(GPR_VEC(ctx, 9), GPR_VEC(ctx, 0)));
    // 0x20deb8: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    // 0x20debc: 0x712856c8
    SET_GPR_VEC(ctx, 10, PS2_PPACB(GPR_VEC(ctx, 9), GPR_VEC(ctx, 8)));
    // 0x20dec0: 0x1580fff5
    WRITE128(ADD32(GPR_U32(ctx, 4), 4294967280), GPR_VEC(ctx, 10));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_20de98;
    }
    // 0x20dec8: 0x0
    // NOP
    // 0x20decc: 0x0
    // NOP
    // 0x20ded0: 0xff00ff
    SET_GPR_S64(ctx, 0, GPR_S64(ctx, 31) >> (32 + 3));
    // 0x20ded4: 0xff00ff
    SET_GPR_S64(ctx, 0, GPR_S64(ctx, 31) >> (32 + 3));
    // 0x20ded8: 0xff00ff
    SET_GPR_S64(ctx, 0, GPR_S64(ctx, 31) >> (32 + 3));
    // 0x20dedc: 0xff00ff
    SET_GPR_S64(ctx, 0, GPR_S64(ctx, 31) >> (32 + 3));
    // 0x20dee0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _ipuSetMPEG1
// Address: 0x20dee8 - 0x20df10

void entry_20df40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20df40) {
        switch (ctx->pc) {
            case 0x20df90: ctx->pc = 0; goto label_20df90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20df40: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20df44: 0x3442b020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 45088));
    // 0x20df48: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20df4c: 0x10600021
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20DFD4; return;
    }
    // 0x20df54: 0x34422010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8208));
    // 0x20df58: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20df5c: 0x30634000
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 16384));
    // 0x20df60: 0x1460001d
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20DFD8; return;
    }
    // 0x20df68: 0x3c141000
    SET_GPR_U32(ctx, 20, ((uint32_t)4096 << 16));
    // 0x20df6c: 0x3c121000
    SET_GPR_U32(ctx, 18, ((uint32_t)4096 << 16));
    // 0x20df70: 0x3c111000
    SET_GPR_U32(ctx, 17, ((uint32_t)4096 << 16));
    // 0x20df74: 0x3c101000
    SET_GPR_U32(ctx, 16, ((uint32_t)4096 << 16));
    // 0x20df78: 0x3694b420
    SET_GPR_U32(ctx, 20, OR32(GPR_U32(ctx, 20), 46112));
    // 0x20df7c: 0x3652b400
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 18), 46080));
    // 0x20df80: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20df84: 0x3631b020
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), 45088));
    // 0x20df88: 0x36102010
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 8208));
    // 0x20df8c: 0x0
    // NOP
label_20df90:
    // 0x20df90: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x20df94: 0x14400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_20dfb8(rdram, ctx, runtime); return;
    }
    // 0x20df9c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20dfa0: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x20dfa4: 0x14400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_20dfb8(rdram, ctx, runtime); return;
    }
    // 0x20dfac: 0x8e640858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2136)));
    // 0x20dfb0: 0xc082c64
    SET_GPR_U32(ctx, 31, 0x20dfb8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 21));
    _dispatchMpegCallback(rdram, ctx, runtime); return;
}


// Function: entry_20dfb8
// Address: 0x20dfb8 - 0x20e044

void entry_20dfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20dfb8) {
        switch (ctx->pc) {
            case 0x20dfd4: ctx->pc = 0; goto label_20dfd4;
            case 0x20dfd8: ctx->pc = 0; goto label_20dfd8;
            case 0x20e00c: ctx->pc = 0; goto label_20e00c;
            case 0x20e014: ctx->pc = 0; goto label_20e014;
            case 0x20e018: ctx->pc = 0; goto label_20e018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20dfb8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x20dfbc: 0x10400006
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20dfd8;
    }
    // 0x20dfc4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20dfc8: 0x30424000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16384));
    // 0x20dfcc: 0x1040fff0
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20DF90; return;
    }
label_20dfd4:
    // 0x20dfd4: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
label_20dfd8:
    // 0x20dfd8: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20dfdc: 0xdc842030
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 4), 8240)));
    // 0x20dfe0: 0x34422020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8224));
    // 0x20dfe4: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20dfe8: 0x4183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) << (32 + 0));
    // 0x20dfec: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x20dff0: 0x4810008
    WRITE32(ADD32(GPR_U32(ctx, 19), 2104), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_20e014;
    }
    // 0x20dff8: 0x3043001f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 31));
    // 0x20dffc: 0x10600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_20e00c;
    }
    // 0x20e004: 0x10000004
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e018;
    }
label_20e00c:
    // 0x20e00c: 0x10000002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e018;
    }
label_20e014:
    // 0x20e014: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
label_20e018:
    // 0x20e018: 0xae62083c
    WRITE32(ADD32(GPR_U32(ctx, 19), 2108), GPR_U32(ctx, 2));
    // 0x20e01c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20e020: 0x34422010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8208));
    // 0x20e024: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20e028: 0x30634000
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 16384));
    // 0x20e02c: 0x10600029
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E0D4; return;
    }
    // 0x20e034: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20e038: 0x24a50300
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 768));
    // 0x20e03c: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20e044);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20e044
// Address: 0x20e044 - 0x20e05c

void entry_20e044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e044: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x20e048: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20e04c: 0x8e640858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2136)));
    // 0x20e050: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e054: 0xc082c64
    SET_GPR_U32(ctx, 31, 0x20e05c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    _dispatchMpegCallback(rdram, ctx, runtime); return;
}


// Function: entry_20e05c
// Address: 0x20e05c - 0x20e07c

void entry_20e05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e05c: 0x3c034000
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    // 0x20e060: 0x8e640858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2136)));
    // 0x20e064: 0x3c011000
    SET_GPR_U32(ctx, 1, ((uint32_t)4096 << 16));
    // 0x20e068: 0xac232010
    WRITE32(ADD32(GPR_U32(ctx, 1), 8208), GPR_U32(ctx, 3));
    // 0x20e06c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20e070: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x20e074: 0xc082c64
    SET_GPR_U32(ctx, 31, 0x20e07c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _dispatchMpegCallback(rdram, ctx, runtime); return;
}


// Function: entry_20e07c
// Address: 0x20e07c - 0x20e084

void entry_20e07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e07c: 0xc07e758
    SET_GPR_U32(ctx, 31, 0x20e084);
    DIntr(rdram, ctx, runtime); return;
}


// Function: entry_20e084
// Address: 0x20e084 - 0x20e0c8

void entry_20e084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e084: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x20e088: 0x3c070001
    SET_GPR_U32(ctx, 7, ((uint32_t)1 << 16));
    // 0x20e08c: 0x34a5f520
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 62752));
    // 0x20e090: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x20e094: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20e098: 0x34c6f590
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 62864));
    // 0x20e09c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20e0a0: 0x3c04fffe
    SET_GPR_U32(ctx, 4, ((uint32_t)65534 << 16));
    // 0x20e0a4: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x20e0a8: 0x3463b000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 45056));
    // 0x20e0ac: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x20e0b0: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x20e0b4: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x20e0b8: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20e0bc: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20e0c0: 0xc07e76a
    SET_GPR_U32(ctx, 31, 0x20e0c8);
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    EIntr(rdram, ctx, runtime); return;
}


// Function: entry_20e0c8
// Address: 0x20e0c8 - 0x20e100

void entry_20e0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e0c8) {
        switch (ctx->pc) {
            case 0x20e0d4: ctx->pc = 0; goto label_20e0d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e0c8: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20e0cc: 0x3463b020
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 45088));
    // 0x20e0d0: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
label_20e0d4:
    // 0x20e0d4: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20e0d8: 0xdfbf00b0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20e0dc: 0xdfb600a0
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20e0e0: 0xdfb50090
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20e0e4: 0xdfb40080
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20e0e8: 0xdfb30070
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20e0ec: 0xdfb20060
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20e0f0: 0xdfb10050
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20e0f4: 0xdfb00040
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e0f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _dmVector
// Address: 0x20e100 - 0x20e110

void entry_20e110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e110: 0xdfbf0000
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20e114: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20e11c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20e120; return;
}


// Function: _dualPrimeVector
// Address: 0x20e120 - 0x20e2a8

void entry_20e2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e2f8) {
        switch (ctx->pc) {
            case 0x20e31c: ctx->pc = 0; goto label_20e31c;
            case 0x20e330: ctx->pc = 0; goto label_20e330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e2f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e2fc: 0x12160017
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 35));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 22)) {
        entry_20e35c(rdram, ctx, runtime); return;
    }
    // 0x20e304: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20e31c;
    }
    // 0x20e30c: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_20e330;
    }
    // 0x20e314: 0x10000019
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E37C; return;
    }
label_20e31c:
    // 0x20e31c: 0x56150017
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
        ctx->pc = 0x20E37C; return;
    }
    // 0x20e324: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e328: 0x10000015
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E380; return;
    }
label_20e330:
    // 0x20e330: 0xc083cf0
    SET_GPR_U32(ctx, 31, 0x20e338);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    _peepBit(rdram, ctx, runtime); return;
}


// Function: entry_20e338
// Address: 0x20e338 - 0x20e35c

void entry_20e338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e338: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e33c: 0x8e220848
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2120)));
    // 0x20e340: 0x10400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 800));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E364; return;
    }
    // 0x20e348: 0x14730007
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 19)) {
        ctx->pc = 0x20E368; return;
    }
    // 0x20e350: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20e354: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20e35c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20e35c
// Address: 0x20e35c - 0x20e370

void entry_20e35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e35c) {
        switch (ctx->pc) {
            case 0x20e364: ctx->pc = 0; goto label_20e364;
            case 0x20e368: ctx->pc = 0; goto label_20e368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e35c: 0x10000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E380; return;
    }
label_20e364:
    // 0x20e364: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20e368:
    // 0x20e368: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20e370);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20e370
// Address: 0x20e370 - 0x20e3b8

void entry_20e370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e370) {
        switch (ctx->pc) {
            case 0x20e37c: ctx->pc = 0; goto label_20e37c;
            case 0x20e380: ctx->pc = 0; goto label_20e380;
            case 0x20e38c: ctx->pc = 0; goto label_20e38c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e370: 0xae37011c
    WRITE32(ADD32(GPR_U32(ctx, 17), 284), GPR_U32(ctx, 23));
    // 0x20e374: 0x10000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e38c;
    }
label_20e37c:
    // 0x20e37c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20e380:
    // 0x20e380: 0x1440ffdb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E2F0; return;
    }
    // 0x20e388: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_20e38c:
    // 0x20e38c: 0xdfbf0080
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20e390: 0xdfb70070
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20e394: 0xdfb60060
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20e398: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20e39c: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e3a0: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20e3a4: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20e3a8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20e3ac: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20e3b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _pictureData0
// Address: 0x20e3b8 - 0x20e414

void entry_20e414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e414: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e418: 0x1214fffc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x20E40C; return;
    }
    // 0x20e420: 0x1213fff9
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x20E408; return;
    }
    // 0x20e428: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20e430);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20e430
// Address: 0x20e430 - 0x20e438

void entry_20e430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e430: 0xc0837c4
    SET_GPR_U32(ctx, 31, 0x20e438);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    _waitBdecOut(rdram, ctx, runtime); return;
}


// Function: entry_20e438
// Address: 0x20e438 - 0x20e484

void entry_20e438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e438) {
        switch (ctx->pc) {
            case 0x20e450: ctx->pc = 0; goto label_20e450;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e438: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20e43c: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20e440: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x20e444: 0x3484d400
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 54272));
    // 0x20e448: 0x2611ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x20e44c: 0x2e130001
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 16), 1));
label_20e450:
    // 0x20e450: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20e454: 0x21202
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 8));
    // 0x20e458: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x20e45c: 0x0
    // NOP
    // 0x20e460: 0x0
    // NOP
    // 0x20e464: 0x1440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20e450;
    }
    // 0x20e46c: 0x16000006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E488; return;
    }
    // 0x20e474: 0x8e450810
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 2064)));
    // 0x20e478: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20e47c: 0xc0833c6
    SET_GPR_U32(ctx, 31, 0x20e484);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    _doMC(rdram, ctx, runtime); return;
}


// Function: entry_20e484
// Address: 0x20e484 - 0x20e49c

void entry_20e484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e484) {
        switch (ctx->pc) {
            case 0x20e488: ctx->pc = 0; goto label_20e488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e484: 0x2e220002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 2));
label_20e488:
    // 0x20e488: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20e49c(rdram, ctx, runtime); return;
    }
    // 0x20e490: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20e494: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20e49c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 856));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20e49c
// Address: 0x20e49c - 0x20e4c0

void entry_20e49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e49c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20e4a0: 0xdfbf0050
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20e4a4: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e4a8: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20e4ac: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20e4b0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20e4b4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20e4b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _sliceA0
// Address: 0x20e4c0 - 0x20e4f8

void entry_20e4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e4f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e4fc: 0xc083cf0
    SET_GPR_U32(ctx, 31, 0x20e504);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _peepBit(rdram, ctx, runtime); return;
}


// Function: entry_20e504
// Address: 0x20e504 - 0x20e528

void entry_20e504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e504: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e508: 0x2642feff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294967039));
    // 0x20e50c: 0x2c4200af
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 175));
    // 0x20e510: 0x14400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E530; return;
    }
    // 0x20e518: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20e51c: 0x24a50378
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 888));
    // 0x20e520: 0xc082e50
    SET_GPR_U32(ctx, 31, 0x20e528);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn__Error1(rdram, ctx, runtime); return;
}


// Function: entry_20e528
// Address: 0x20e528 - 0x20e538

void entry_20e528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e528) {
        switch (ctx->pc) {
            case 0x20e530: ctx->pc = 0; goto label_20e530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e528: 0x10000027
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E5C8; return;
    }
label_20e530:
    // 0x20e530: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20e538);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20e538
// Address: 0x20e538 - 0x20e540

void entry_20e538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e538: 0xc083de2
    SET_GPR_U32(ctx, 31, 0x20e540);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sliceB(rdram, ctx, runtime); return;
}


// Function: entry_20e540
// Address: 0x20e540 - 0x20e54c

void entry_20e540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e540: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e544: 0xc0838aa
    SET_GPR_U32(ctx, 31, 0x20e54c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _mbAddressIncrement(rdram, ctx, runtime); return;
}


// Function: entry_20e54c
// Address: 0x20e54c - 0x20e56c

void entry_20e54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e54c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e550: 0xae860000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 6));
    // 0x20e554: 0x8e02011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    // 0x20e558: 0x10400006
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E574; return;
    }
    // 0x20e560: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e564: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20e56c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 928));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20e56c
// Address: 0x20e56c - 0x20e5f0

void entry_20e56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e56c) {
        switch (ctx->pc) {
            case 0x20e574: ctx->pc = 0; goto label_20e574;
            case 0x20e5c8: ctx->pc = 0; goto label_20e5c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e56c: 0x10000016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e5c8;
    }
label_20e574:
    // 0x20e574: 0x324200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 255));
    // 0x20e578: 0x1319c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 7));
    // 0x20e57c: 0x8e04012c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 300)));
    // 0x20e580: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20e584: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x20e588: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e58c: 0x641018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20e590: 0x461821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x20e594: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x20e598: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20e59c: 0xaea30000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 3));
    // 0x20e5a0: 0xae850000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 5));
    // 0x20e5a4: 0xae0501b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 432), GPR_U32(ctx, 5));
    // 0x20e5a8: 0xae200008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 0));
    // 0x20e5ac: 0xae200014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 0));
    // 0x20e5b0: 0xae200010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
    // 0x20e5b4: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    // 0x20e5b8: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x20e5bc: 0xae20001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 0));
    // 0x20e5c0: 0xae200018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 0));
    // 0x20e5c4: 0xae20000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 0));
label_20e5c8:
    // 0x20e5c8: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20e5cc: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20e5d0: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e5d4: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20e5d8: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20e5dc: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20e5e0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20e5e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20e5ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20e5f0; return;
}


// Function: _slice0
// Address: 0x20e5f0 - 0x20e628

void entry_20e628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e628) {
        switch (ctx->pc) {
            case 0x20e638: ctx->pc = 0; goto label_20e638;
            case 0x20e650: ctx->pc = 0; goto label_20e650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e628: 0x14400067
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C8; return;
    }
    // 0x20e630: 0xae00011c
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 0));
    // 0x20e634: 0x0
    // NOP
label_20e638:
    // 0x20e638: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e63c: 0x53102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 19)));
    // 0x20e640: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
        goto label_20e650;
    }
    // 0x20e648: 0x1000005e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e650:
    // 0x20e650: 0x24030140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 320));
    // 0x20e654: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e658: 0x432818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20e65c: 0xb01021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    // 0x20e660: 0xc0837c4
    SET_GPR_U32(ctx, 31, 0x20e668);
    WRITE32(ADD32(GPR_U32(ctx, 2), 1740), GPR_U32(ctx, 0));
    _waitBdecOut(rdram, ctx, runtime); return;
}


// Function: entry_20e668
// Address: 0x20e668 - 0x20e68c

void entry_20e668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e668) {
        switch (ctx->pc) {
            case 0x20e678: ctx->pc = 0; goto label_20e678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e668: 0x14400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20e678;
    }
    // 0x20e670: 0x10000054
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e678:
    // 0x20e678: 0x14400012
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E6C4; return;
    }
    // 0x20e680: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e684: 0xc083cf0
    SET_GPR_U32(ctx, 31, 0x20e68c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    _peepBit(rdram, ctx, runtime); return;
}


// Function: entry_20e68c
// Address: 0x20e68c - 0x20e6b4

void entry_20e68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e68c) {
        switch (ctx->pc) {
            case 0x20e6a4: ctx->pc = 0; goto label_20e6a4;
            case 0x20e6ac: ctx->pc = 0; goto label_20e6ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e68c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 0));
        goto label_20e6a4;
    }
    // 0x20e694: 0x8e02011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    // 0x20e698: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20e6ac;
    }
    // 0x20e6a0: 0xae00011c
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 0));
label_20e6a4:
    // 0x20e6a4: 0x10000047
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e6ac:
    // 0x20e6ac: 0xc0838aa
    SET_GPR_U32(ctx, 31, 0x20e6b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _mbAddressIncrement(rdram, ctx, runtime); return;
}


// Function: entry_20e6b4
// Address: 0x20e6b4 - 0x20e6e0

void entry_20e6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e6b4) {
        switch (ctx->pc) {
            case 0x20e6c4: ctx->pc = 0; goto label_20e6c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e6b4: 0x8e03011c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    // 0x20e6b8: 0x14600019
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E720; return;
    }
    // 0x20e6c0: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
label_20e6c4:
    // 0x20e6c4: 0x53102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 19)));
    // 0x20e6c8: 0x14400007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E6E8; return;
    }
    // 0x20e6d0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20e6d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e6d8: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20e6e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 960));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20e6e0
// Address: 0x20e6e0 - 0x20e718

void entry_20e6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e6e0) {
        switch (ctx->pc) {
            case 0x20e6e8: ctx->pc = 0; goto label_20e6e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e6e0: 0x10000038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e6e8:
    // 0x20e6e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e6ec: 0x1462000f
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20E72C; return;
    }
    // 0x20e6f4: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x20e6f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e6fc: 0x27a50048
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 72));
    // 0x20e700: 0x27a6004c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 76));
    // 0x20e704: 0x27a70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    // 0x20e708: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x20e70c: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20e710: 0xc083a28
    SET_GPR_U32(ctx, 31, 0x20e718);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _decMB0(rdram, ctx, runtime); return;
}


// Function: entry_20e718
// Address: 0x20e718 - 0x20e744

void entry_20e718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e718) {
        switch (ctx->pc) {
            case 0x20e720: ctx->pc = 0; goto label_20e720;
            case 0x20e72c: ctx->pc = 0; goto label_20e72c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e718: 0x1440000d
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E750; return;
    }
label_20e720:
    // 0x20e720: 0xae00011c
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 0));
    // 0x20e724: 0x10000027
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e72c:
    // 0x20e72c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e730: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x20e734: 0x27a6004c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 76));
    // 0x20e738: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20e73c: 0xc0839f8
    SET_GPR_U32(ctx, 31, 0x20e744);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 72));
    _skipMB0(rdram, ctx, runtime); return;
}


// Function: entry_20e744
// Address: 0x20e744 - 0x20e770

void entry_20e744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e744) {
        switch (ctx->pc) {
            case 0x20e750: ctx->pc = 0; goto label_20e750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e744: 0x1040000c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E778; return;
    }
    // 0x20e74c: 0x8fa50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
label_20e750:
    // 0x20e750: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20e754: 0x8fa60044
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x20e758: 0x220582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20e75c: 0x8fa70048
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x20e760: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e764: 0x8fa8004c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x20e768: 0xc083068
    SET_GPR_U32(ctx, 31, 0x20e770);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = 0x20c1a0; return;
}


// Function: entry_20e770
// Address: 0x20e770 - 0x20e79c

void entry_20e770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e770) {
        switch (ctx->pc) {
            case 0x20e778: ctx->pc = 0; goto label_20e778;
            case 0x20e784: ctx->pc = 0; goto label_20e784;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e770: 0x14400004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20e784;
    }
label_20e778:
    // 0x20e778: 0xae00011c
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 0));
    // 0x20e77c: 0x10000011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E7C4; return;
    }
label_20e784:
    // 0x20e784: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
        ctx->pc = 0x20E7A4; return;
    }
    // 0x20e78c: 0x8e050810
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20e790: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e794: 0xc0833c6
    SET_GPR_U32(ctx, 31, 0x20e79c);
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 1));
    _doMC(rdram, ctx, runtime); return;
}


// Function: entry_20e79c
// Address: 0x20e79c - 0x20e7e0

void entry_20e79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e79c) {
        switch (ctx->pc) {
            case 0x20e7a4: ctx->pc = 0; goto label_20e7a4;
            case 0x20e7c4: ctx->pc = 0; goto label_20e7c4;
            case 0x20e7c8: ctx->pc = 0; goto label_20e7c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e79c: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20e7a0: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
label_20e7a4:
    // 0x20e7a4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x20e7a8: 0x8fa30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x20e7ac: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x20e7b0: 0xafa40040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 4));
    // 0x20e7b4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x20e7b8: 0xae020810
    WRITE32(ADD32(GPR_U32(ctx, 16), 2064), GPR_U32(ctx, 2));
    // 0x20e7bc: 0x1000ff9e
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E638; return;
    }
label_20e7c4:
    // 0x20e7c4: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
label_20e7c8:
    // 0x20e7c8: 0xdfb30090
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20e7cc: 0xdfb20080
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20e7d0: 0xdfb10070
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20e7d4: 0xdfb00060
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20e7d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _skipMB0
// Address: 0x20e7e0 - 0x20e874

void entry_20e874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e874) {
        switch (ctx->pc) {
            case 0x20e87c: ctx->pc = 0; goto label_20e87c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e874: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20e878: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_20e87c:
    // 0x20e87c: 0x2404fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x20e880: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20e884: 0x120102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x20e888: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x20e88c: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x20e890: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20e894: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20e89c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20e8a0; return;
}


// Function: _decMB0
// Address: 0x20e8a0 - 0x20e91c

void entry_20e91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20e91c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20e920: 0x14600009
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E948; return;
    }
    // 0x20e928: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20e92c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20e930: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20e938);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1040));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20e938
// Address: 0x20e938 - 0x20e97c

void entry_20e938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e938) {
        switch (ctx->pc) {
            case 0x20e948: ctx->pc = 0; goto label_20e948;
            case 0x20e974: ctx->pc = 0; goto label_20e974;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e938: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e93c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20e940: 0x100000f5
    WRITE32(ADD32(GPR_U32(ctx, 16), 284), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20ED18; return;
    }
label_20e948:
    // 0x20e948: 0x3062000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 12));
    // 0x20e94c: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E984; return;
    }
    // 0x20e954: 0x8e030174
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20e958: 0x14620006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_20e974;
    }
    // 0x20e960: 0x8e02017c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 380)));
    // 0x20e964: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20e974;
    }
    // 0x20e96c: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20E9B0; return;
    }
label_20e974:
    // 0x20e974: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20e97c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20e97c
// Address: 0x20e97c - 0x20ea38

void entry_20e97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20e97c) {
        switch (ctx->pc) {
            case 0x20e984: ctx->pc = 0; goto label_20e984;
            case 0x20e9b0: ctx->pc = 0; goto label_20e9b0;
            case 0x20e9b4: ctx->pc = 0; goto label_20e9b4;
            case 0x20e9dc: ctx->pc = 0; goto label_20e9dc;
            case 0x20e9f0: ctx->pc = 0; goto label_20e9f0;
            case 0x20ea08: ctx->pc = 0; goto label_20ea08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20e97c: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e9b0;
    }
label_20e984:
    // 0x20e984: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x20e988: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 372)));
        goto label_20e9b4;
    }
    // 0x20e990: 0x8e020180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 384)));
    // 0x20e994: 0x10400006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20e9b0;
    }
    // 0x20e99c: 0x8e020174
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20e9a0: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20e9a4: 0x38420003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 3));
    // 0x20e9a8: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x20e9ac: 0xaea30000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 3));
label_20e9b0:
    // 0x20e9b0: 0x8e060174
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 372)));
label_20e9b4:
    // 0x20e9b4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20e9b8: 0x14c20008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_20e9dc;
    }
    // 0x20e9c0: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e9c4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20e9c8: 0x38a30001
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 5), 1));
    // 0x20e9cc: 0x38a40002
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 5), 2));
    // 0x20e9d0: 0x43980a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 2));
    // 0x20e9d4: 0x10000006
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20e9f0;
    }
label_20e9dc:
    // 0x20e9dc: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20e9e0: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20e9e4: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20e9e8: 0x38a20002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), 2));
    // 0x20e9ec: 0x62980a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 3));
label_20e9f0:
    // 0x20e9f0: 0x38a20003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), 3));
    // 0x20e9f4: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20e9f8: 0x16800003
    SET_GPR_U32(ctx, 30, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_20ea08;
    }
    // 0x20ea00: 0x38c20003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 6), 3));
    // 0x20ea04: 0x2c570001
    SET_GPR_U32(ctx, 23, SLTU32(GPR_U32(ctx, 2), 1));
label_20ea08:
    // 0x20ea08: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20ea0c: 0x14c2000d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20EA44; return;
    }
    // 0x20ea14: 0x8e02017c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 380)));
    // 0x20ea18: 0x1440000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EA44; return;
    }
    // 0x20ea20: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ea24: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x20ea28: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EA40; return;
    }
    // 0x20ea30: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ea38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ea38
// Address: 0x20ea38 - 0x20ea64

void entry_20ea38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ea38) {
        switch (ctx->pc) {
            case 0x20ea40: ctx->pc = 0; goto label_20ea40;
            case 0x20ea44: ctx->pc = 0; goto label_20ea44;
            case 0x20ea48: ctx->pc = 0; goto label_20ea48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ea38: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20ea48;
    }
label_20ea40:
    // 0x20ea40: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20ea44:
    // 0x20ea44: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_20ea48:
    // 0x20ea48: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x20ea4c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ea50: 0x30620010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    // 0x20ea54: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EA6C; return;
    }
    // 0x20ea5c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ea64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ea64
// Address: 0x20ea64 - 0x20ead4

void entry_20ea64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ea64) {
        switch (ctx->pc) {
            case 0x20ea6c: ctx->pc = 0; goto label_20ea6c;
            case 0x20ea94: ctx->pc = 0; goto label_20ea94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ea64: 0xae0201b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 436), GPR_U32(ctx, 2));
    // 0x20ea68: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_20ea6c:
    // 0x20ea6c: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x20ea70: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2120)));
        goto label_20ea94;
    }
    // 0x20ea78: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x20ea7c: 0x50400021
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
        ctx->pc = 0x20EB04; return;
    }
    // 0x20ea84: 0x8e020180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 384)));
    // 0x20ea88: 0x5040001e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
        ctx->pc = 0x20EB04; return;
    }
    // 0x20ea90: 0x8e020848
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2120)));
label_20ea94:
    // 0x20ea94: 0x10400011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EADC; return;
    }
    // 0x20ea9c: 0x8e020168
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 360)));
    // 0x20eaa0: 0x8e0b0164
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 16), 356)));
    // 0x20eaa4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20eaa8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20eaac: 0x8fa70024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x20eab0: 0xafbe0008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 30));
    // 0x20eab4: 0x256bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294967295));
    // 0x20eab8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20eabc: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20eac0: 0xafb70010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 23));
    // 0x20eac4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20eac8: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20eacc: 0xc083b74
    SET_GPR_U32(ctx, 31, 0x20ead4);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    _motionVectors(rdram, ctx, runtime); return;
}


// Function: entry_20ead4
// Address: 0x20ead4 - 0x20eb00

void entry_20ead4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ead4) {
        switch (ctx->pc) {
            case 0x20eadc: ctx->pc = 0; goto label_20eadc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ead4: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EB04; return;
    }
label_20eadc:
    // 0x20eadc: 0x8e070158
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 344)));
    // 0x20eae0: 0x8e0b0154
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 16), 340)));
    // 0x20eae4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20eae8: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x20eaec: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20eaf0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20eaf4: 0xe0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x20eaf8: 0xc083bdc
    SET_GPR_U32(ctx, 31, 0x20eb00);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _motionVector(rdram, ctx, runtime); return;
}


// Function: entry_20eb00
// Address: 0x20eb00 - 0x20eb60

void entry_20eb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20eb00) {
        switch (ctx->pc) {
            case 0x20eb04: ctx->pc = 0; goto label_20eb04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20eb00: 0x8e03011c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
label_20eb04:
    // 0x20eb04: 0x14600084
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20ED18; return;
    }
    // 0x20eb0c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20eb10: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x20eb14: 0x1040001e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EB90; return;
    }
    // 0x20eb1c: 0x8e020848
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2120)));
    // 0x20eb20: 0x10400011
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EB68; return;
    }
    // 0x20eb28: 0x8e020170
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 368)));
    // 0x20eb2c: 0x8e0b016c
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 16), 364)));
    // 0x20eb30: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20eb34: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x20eb38: 0x8fa70024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x20eb3c: 0xafb70010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 23));
    // 0x20eb40: 0x280502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x20eb44: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x20eb48: 0x256bffff
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4294967295));
    // 0x20eb4c: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x20eb50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20eb54: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20eb58: 0xc083b74
    SET_GPR_U32(ctx, 31, 0x20eb60);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    _motionVectors(rdram, ctx, runtime); return;
}


// Function: entry_20eb60
// Address: 0x20eb60 - 0x20eb8c

void entry_20eb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20eb60) {
        switch (ctx->pc) {
            case 0x20eb68: ctx->pc = 0; goto label_20eb68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20eb60: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EB90; return;
    }
label_20eb68:
    // 0x20eb68: 0x8e070160
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x20eb6c: 0x8e0b015c
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 16), 348)));
    // 0x20eb70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20eb74: 0x24e7ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x20eb78: 0x26250008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    // 0x20eb7c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20eb80: 0xe0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x20eb84: 0xc083bdc
    SET_GPR_U32(ctx, 31, 0x20eb8c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _motionVector(rdram, ctx, runtime); return;
}


// Function: entry_20eb8c
// Address: 0x20eb8c - 0x20ebbc

void entry_20eb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20eb8c) {
        switch (ctx->pc) {
            case 0x20eb90: ctx->pc = 0; goto label_20eb90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20eb8c: 0x8e03011c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 284)));
label_20eb90:
    // 0x20eb90: 0x14600061
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20ED18; return;
    }
    // 0x20eb98: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20eb9c: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x20eba0: 0x10400008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EBC4; return;
    }
    // 0x20eba8: 0x8e020180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 384)));
    // 0x20ebac: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EBC0; return;
    }
    // 0x20ebb4: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20ebbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20ebbc
// Address: 0x20ebbc - 0x20ebe4

void entry_20ebbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ebbc) {
        switch (ctx->pc) {
            case 0x20ebc0: ctx->pc = 0; goto label_20ebc0;
            case 0x20ebc4: ctx->pc = 0; goto label_20ebc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ebbc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_20ebc0:
    // 0x20ebc0: 0x30620003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 3));
label_20ebc4:
    // 0x20ebc4: 0x1040001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EC38; return;
    }
    // 0x20ebcc: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20ebd0: 0x24050300
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 768));
    // 0x20ebd4: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20ebd8: 0x901021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x20ebdc: 0xc084364
    SET_GPR_U32(ctx, 31, 0x20ebe4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1428)));
    receiveDataFromIPU(rdram, ctx, runtime); return;
}


// Function: entry_20ebe4
// Address: 0x20ebe4 - 0x20ebec

void entry_20ebe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ebe4: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20ebec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20ebec
// Address: 0x20ebec - 0x20ec30

void entry_20ebec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ebec: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ebf0: 0x3c072000
    SET_GPR_U32(ctx, 7, ((uint32_t)8192 << 16));
    // 0x20ebf4: 0x8e0601b4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 436)));
    // 0x20ebf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ebfc: 0x8e0301b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 432)));
    // 0x20ec00: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x20ec04: 0x8fa80020
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20ec08: 0x52ec0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 27));
    // 0x20ec0c: 0x63400
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 16));
    // 0x20ec10: 0x31e80
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 26));
    // 0x20ec14: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x20ec18: 0xa62825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x20ec1c: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x20ec20: 0xa32825
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x20ec24: 0x21640
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 25));
    // 0x20ec28: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20ec30);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20ec30
// Address: 0x20ec30 - 0x20ed48

void entry_20ec30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ec30) {
        switch (ctx->pc) {
            case 0x20ec38: ctx->pc = 0; goto label_20ec38;
            case 0x20ec50: ctx->pc = 0; goto label_20ec50;
            case 0x20ec60: ctx->pc = 0; goto label_20ec60;
            case 0x20ec8c: ctx->pc = 0; goto label_20ec8c;
            case 0x20ecb8: ctx->pc = 0; goto label_20ecb8;
            case 0x20ecfc: ctx->pc = 0; goto label_20ecfc;
            case 0x20ed14: ctx->pc = 0; goto label_20ed14;
            case 0x20ed18: ctx->pc = 0; goto label_20ed18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ec30: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20ec50;
    }
label_20ec38:
    // 0x20ec38: 0x8e020810
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2064)));
    // 0x20ec3c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20ec40: 0x432818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x20ec44: 0xb01021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    // 0x20ec48: 0xac4406cc
    WRITE32(ADD32(GPR_U32(ctx, 2), 1740), GPR_U32(ctx, 4));
    // 0x20ec4c: 0x8e02011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 284)));
label_20ec50:
    // 0x20ec50: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 432), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20ec60;
    }
    // 0x20ec58: 0x1000002f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20ed18;
    }
label_20ec60:
    // 0x20ec60: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ec64: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x20ec68: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 384)));
        goto label_20ec8c;
    }
    // 0x20ec70: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20ec74: 0xae0301b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 432), GPR_U32(ctx, 3));
    // 0x20ec78: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ec7c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x20ec80: 0x5040000d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 336)));
        goto label_20ecb8;
    }
    // 0x20ec88: 0x8e020180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 384)));
label_20ec8c:
    // 0x20ec8c: 0x5440000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 336)));
        goto label_20ecb8;
    }
    // 0x20ec94: 0xae200014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 0));
    // 0x20ec98: 0xae200010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
    // 0x20ec9c: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    // 0x20eca0: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x20eca4: 0xae20001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 0));
    // 0x20eca8: 0xae200018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 0));
    // 0x20ecac: 0xae20000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 0));
    // 0x20ecb0: 0xae200008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 0));
    // 0x20ecb4: 0x8e040150
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 336)));
label_20ecb8:
    // 0x20ecb8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20ecbc: 0x14820016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_20ed18;
    }
    // 0x20ecc4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x20ecc8: 0x30420009
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 9));
    // 0x20eccc: 0x14400012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20ed18;
    }
    // 0x20ecd4: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x20ecd8: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20ecdc: 0xae200014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 0));
    // 0x20ece0: 0xae200010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
    // 0x20ece4: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    // 0x20ece8: 0x8e020174
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20ecec: 0x14430003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_20ecfc;
    }
    // 0x20ecf4: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20ed14;
    }
label_20ecfc:
    // 0x20ecfc: 0xaea30000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 3));
    // 0x20ed00: 0x8e020174
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 372)));
    // 0x20ed04: 0x8fa80024
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x20ed08: 0x38420002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 2));
    // 0x20ed0c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x20ed10: 0xad020000
    WRITE32(ADD32(GPR_U32(ctx, 8), 0), GPR_U32(ctx, 2));
label_20ed14:
    // 0x20ed14: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_20ed18:
    // 0x20ed18: 0xdfbf00c0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x20ed1c: 0xdfbe00b0
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x20ed20: 0xdfb700a0
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20ed24: 0xdfb60090
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20ed28: 0xdfb50080
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20ed2c: 0xdfb40070
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20ed30: 0xdfb30060
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20ed34: 0xdfb20050
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20ed38: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20ed3c: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20ed40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _decode_motion_vector
// Address: 0x20ed48 - 0x20edd0

void entry_20ee40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ee40) {
        switch (ctx->pc) {
            case 0x20ee58: ctx->pc = 0; goto label_20ee58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ee40: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20ee44: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x20ee48: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x20ee4c: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
    // 0x20ee50: 0x1000002b
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EF00; return;
    }
label_20ee58:
    // 0x20ee58: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20ee5c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ee64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ee64
// Address: 0x20ee64 - 0x20ee9c

void entry_20ee64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ee64: 0x1088c0
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 16), 3));
    // 0x20ee68: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20ee6c: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x20ee70: 0x2912821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x20ee74: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20ee78: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x20ee7c: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20ee80: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x20ee84: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20ee88: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20ee8c: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ee90: 0x3c0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20ee94: 0xc083bdc
    SET_GPR_U32(ctx, 31, 0x20ee9c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _motionVector(rdram, ctx, runtime); return;
}


// Function: entry_20ee9c
// Address: 0x20ee9c - 0x20eea8

void entry_20ee9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ee9c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20eea0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20eea8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20eea8
// Address: 0x20eea8 - 0x20ef2c

void entry_20eea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20eea8) {
        switch (ctx->pc) {
            case 0x20ef00: ctx->pc = 0; goto label_20ef00;
            case 0x20ef04: ctx->pc = 0; goto label_20ef04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20eea8: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x20eeac: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x20eeb0: 0x2912821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x20eeb4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20eeb8: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20eebc: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20eec0: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20eec4: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20eec8: 0x3c0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20eecc: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20eed0: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20eed4: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20eed8: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20eedc: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20eee0: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20eee4: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20eee8: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20eeec: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20eef0: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20eef4: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20eef8: 0x8083bdc
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    _motionVector(rdram, ctx, runtime); return;
label_20ef00:
    // 0x20ef00: 0x1080c0
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 3));
label_20ef04:
    // 0x20ef04: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20ef08: 0x2908021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x20ef0c: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x20ef10: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20ef14: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x20ef18: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x20ef1c: 0x3c0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x20ef20: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20ef24: 0xc083bdc
    SET_GPR_U32(ctx, 31, 0x20ef2c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _motionVector(rdram, ctx, runtime); return;
}


// Function: entry_20ef2c
// Address: 0x20ef2c - 0x20ef70

void entry_20ef2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ef2c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20ef30: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x20ef34: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x20ef38: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x20ef3c: 0xdfbf00a0
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x20ef40: 0xdfbe0090
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20ef44: 0xdfb70080
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20ef48: 0xdfb60070
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20ef4c: 0xdfb50060
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20ef50: 0xdfb40050
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20ef54: 0xdfb30040
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20ef58: 0xdfb20030
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20ef5c: 0xdfb10020
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20ef60: 0xdfb00010
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20ef64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20ef6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20ef70; return;
}


// Function: _motionVector
// Address: 0x20ef70 - 0x20efc4

void entry_20efc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20efc4: 0x12200007
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EFE4; return;
    }
    // 0x20efcc: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20EFE4; return;
    }
    // 0x20efd4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20efdc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20efdc
// Address: 0x20efdc - 0x20effc

void entry_20efdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20efdc) {
        switch (ctx->pc) {
            case 0x20efe4: ctx->pc = 0; goto label_20efe4;
            case 0x20efe8: ctx->pc = 0; goto label_20efe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20efdc: 0x10000002
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20efe8;
    }
label_20efe4:
    // 0x20efe4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20efe8:
    // 0x20efe8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20efec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20eff0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20eff4: 0xc083b52
    SET_GPR_U32(ctx, 31, 0x20effc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    _decode_motion_vector(rdram, ctx, runtime); return;
}


// Function: entry_20effc
// Address: 0x20effc - 0x20f00c

void entry_20effc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20effc: 0x12e00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F014; return;
    }
    // 0x20f004: 0xc083840
    SET_GPR_U32(ctx, 31, 0x20f00c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _dmVector(rdram, ctx, runtime); return;
}


// Function: entry_20f00c
// Address: 0x20f00c - 0x20f01c

void entry_20f00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f00c) {
        switch (ctx->pc) {
            case 0x20f014: ctx->pc = 0; goto label_20f014;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f00c: 0xafc20000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 2));
    // 0x20f010: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_20f014:
    // 0x20f014: 0xc083c92
    SET_GPR_U32(ctx, 31, 0x20f01c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _ipuVdec(rdram, ctx, runtime); return;
}


// Function: entry_20f01c
// Address: 0x20f01c - 0x20f034

void entry_20f01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f01c: 0x12800007
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F03C; return;
    }
    // 0x20f024: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F03C; return;
    }
    // 0x20f02c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f034);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f034
// Address: 0x20f034 - 0x20f064

void entry_20f034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f034) {
        switch (ctx->pc) {
            case 0x20f03c: ctx->pc = 0; goto label_20f03c;
            case 0x20f040: ctx->pc = 0; goto label_20f040;
            case 0x20f054: ctx->pc = 0; goto label_20f054;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f034: 0x10000002
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f040;
    }
label_20f03c:
    // 0x20f03c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f040:
    // 0x20f040: 0x12c00004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_20f054;
    }
    // 0x20f048: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20f04c: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x20f050: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
label_20f054:
    // 0x20f054: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f058: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x20f05c: 0xc083b52
    SET_GPR_U32(ctx, 31, 0x20f064);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4));
    _decode_motion_vector(rdram, ctx, runtime); return;
}


// Function: entry_20f064
// Address: 0x20f064 - 0x20f088

void entry_20f064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f064) {
        switch (ctx->pc) {
            case 0x20f078: ctx->pc = 0; goto label_20f078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f064: 0x12c00004
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_20f078;
    }
    // 0x20f06c: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x20f070: 0x21040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    // 0x20f074: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
label_20f078:
    // 0x20f078: 0x12e00005
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F090; return;
    }
    // 0x20f080: 0xc083840
    SET_GPR_U32(ctx, 31, 0x20f088);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    _dmVector(rdram, ctx, runtime); return;
}


// Function: entry_20f088
// Address: 0x20f088 - 0x20f0c0

void entry_20f088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f088) {
        switch (ctx->pc) {
            case 0x20f090: ctx->pc = 0; goto label_20f090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f088: 0xafc20004
    WRITE32(ADD32(GPR_U32(ctx, 30), 4), GPR_U32(ctx, 2));
    // 0x20f08c: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
label_20f090:
    // 0x20f090: 0xdfbe0080
    SET_GPR_U64(ctx, 30, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20f094: 0xdfb70070
    SET_GPR_U64(ctx, 23, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20f098: 0xdfb60060
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20f09c: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20f0a0: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20f0a4: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f0a8: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f0ac: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f0b0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f0b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20f0bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f0c0; return;
}


// Function: _sendIpuCommand
// Address: 0x20f0c0 - 0x20f0f0

void entry_20f164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f164) {
        switch (ctx->pc) {
            case 0x20f168: ctx->pc = 0; goto label_20f168;
            case 0x20f17c: ctx->pc = 0; goto label_20f17c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f164: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f168:
    // 0x20f168: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x20f16c: 0x501024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x20f170: 0x1053fff7
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x20F150; return;
    }
    // 0x20f178: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
label_20f17c:
    // 0x20f17c: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f180: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f184: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f188: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f18c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20f194: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f198; return;
}


// Function: _waitIpuIdle64
// Address: 0x20f198 - 0x20f20c

void entry_20f20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f20c) {
        switch (ctx->pc) {
            case 0x20f210: ctx->pc = 0; goto label_20f210;
            case 0x20f230: ctx->pc = 0; goto label_20f230;
            case 0x20f234: ctx->pc = 0; goto label_20f234;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f20c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f210:
    // 0x20f210: 0xde240000
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x20f214: 0x4810006
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_20f230;
    }
    // 0x20f21c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20f220: 0x30424000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16384));
    // 0x20f224: 0x1040fff4
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F1F8; return;
    }
    // 0x20f22c: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
label_20f230:
    // 0x20f230: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_20f234:
    // 0x20f234: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f238: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f23c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f240: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _ipuVdec
// Address: 0x20f248 - 0x20f2b0

void entry_20f2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f2b0) {
        switch (ctx->pc) {
            case 0x20f2b4: ctx->pc = 0; goto label_20f2b4;
            case 0x20f2e0: ctx->pc = 0; goto label_20f2e0;
            case 0x20f2ec: ctx->pc = 0; goto label_20f2ec;
            case 0x20f328: ctx->pc = 0; goto label_20f328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f2b0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f2b4:
    // 0x20f2b4: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20f2b8: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x20f2bc: 0x34632010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8208));
    // 0x20f2c0: 0x34844000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16384));
    // 0x20f2c4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20f2c8: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x20f2cc: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20f2d0: 0x1045fff1
    SET_GPR_U32(ctx, 3, ((uint32_t)12288 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x20F298; return;
    }
    // 0x20f2d8: 0x10000004
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f2ec;
    }
label_20f2e0:
    // 0x20f2e0: 0x3c130028
    SET_GPR_U32(ctx, 19, ((uint32_t)40 << 16));
    // 0x20f2e4: 0x3c033000
    SET_GPR_U32(ctx, 3, ((uint32_t)12288 << 16));
    // 0x20f2e8: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
label_20f2ec:
    // 0x20f2ec: 0x2031825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x20f2f0: 0x34842000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 8192));
    // 0x20f2f4: 0x31703
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 3), 28));
    // 0x20f2f8: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x20f2fc: 0x2665b040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4294946880));
    // 0x20f300: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20f304: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x20f308: 0xdc860000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x20f30c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20f310: 0x4c1000e
    WRITE32(ADD32(GPR_U32(ctx, 17), 2072), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 6) >= 0) {
        ctx->pc = 0x20F34C; return;
    }
    // 0x20f318: 0x3c101000
    SET_GPR_U32(ctx, 16, ((uint32_t)4096 << 16));
    // 0x20f31c: 0x36102000
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 8192));
    // 0x20f320: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x20f324: 0x0
    // NOP
label_20f328:
    // 0x20f328: 0x28421389
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 5001));
    // 0x20f32c: 0x14400004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_20f340(rdram, ctx, runtime); return;
    }
    // 0x20f334: 0x8e240858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2136)));
    // 0x20f338: 0xc082c78
    SET_GPR_U32(ctx, 31, 0x20f340);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    _dispatchMpegCbNodata(rdram, ctx, runtime); return;
}


// Function: entry_20f340
// Address: 0x20f340 - 0x20f3c0

void entry_20f340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f340) {
        switch (ctx->pc) {
            case 0x20f34c: ctx->pc = 0; goto label_20f34c;
            case 0x20f380: ctx->pc = 0; goto label_20f380;
            case 0x20f384: ctx->pc = 0; goto label_20f384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f340: 0xde060000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x20f344: 0x4c0fff8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 6) < 0) {
        ctx->pc = 0x20F328; return;
    }
label_20f34c:
    // 0x20f34c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20f350: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x20f354: 0xdc842030
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 4), 8240)));
    // 0x20f358: 0x34422020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8224));
    // 0x20f35c: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20f360: 0x4183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) << (32 + 0));
    // 0x20f364: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x20f368: 0x4810005
    WRITE32(ADD32(GPR_U32(ctx, 17), 2104), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_20f380;
    }
    // 0x20f370: 0x3042001f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 31));
    // 0x20f374: 0x21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x20f378: 0x10000002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 31));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f384;
    }
label_20f380:
    // 0x20f380: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
label_20f384:
    // 0x20f384: 0xae22083c
    WRITE32(ADD32(GPR_U32(ctx, 17), 2108), GPR_U32(ctx, 2));
    // 0x20f388: 0x6183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 6) << (32 + 0));
    // 0x20f38c: 0x3183f
    SET_GPR_S64(ctx, 3, GPR_S64(ctx, 3) >> (32 + 0));
    // 0x20f390: 0x30c2ffff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 6), 65535));
    // 0x20f394: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x20f398: 0x21400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 16));
    // 0x20f39c: 0xae23011c
    WRITE32(ADD32(GPR_U32(ctx, 17), 284), GPR_U32(ctx, 3));
    // 0x20f3a0: 0x21403
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 16));
    // 0x20f3a4: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20f3a8: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f3ac: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f3b0: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f3b4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f3b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _peepBit
// Address: 0x20f3c0 - 0x20f438

void entry_20f438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f438) {
        switch (ctx->pc) {
            case 0x20f43c: ctx->pc = 0; goto label_20f43c;
            case 0x20f468: ctx->pc = 0; goto label_20f468;
            case 0x20f474: ctx->pc = 0; goto label_20f474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f438: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f43c:
    // 0x20f43c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20f440: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x20f444: 0x34632010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8208));
    // 0x20f448: 0x34844000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16384));
    // 0x20f44c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20f450: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x20f454: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20f458: 0x1045fff1
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x20F420; return;
    }
    // 0x20f460: 0x10000004
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f474;
    }
label_20f468:
    // 0x20f468: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x20f46c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20f470: 0x3c034000
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
label_20f474:
    // 0x20f474: 0x34422000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8192));
    // 0x20f478: 0x2625b040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 4294946880));
    // 0x20f47c: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x20f480: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f484: 0x8ca20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x20f488: 0xc083c66
    SET_GPR_U32(ctx, 31, 0x20f490);
    WRITE32(ADD32(GPR_U32(ctx, 16), 2072), GPR_U32(ctx, 2));
    _waitIpuIdle64(rdram, ctx, runtime); return;
}


// Function: entry_20f490
// Address: 0x20f490 - 0x20f4c8

void entry_20f490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f490) {
        switch (ctx->pc) {
            case 0x20f4a8: ctx->pc = 0; goto label_20f4a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f490: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20f494: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20f498: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x20f49c: 0xae020838
    WRITE32(ADD32(GPR_U32(ctx, 16), 2104), GPR_U32(ctx, 2));
    // 0x20f4a0: 0xae03083c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2108), GPR_U32(ctx, 3));
    // 0x20f4a4: 0x8e030838
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2104)));
label_20f4a8:
    // 0x20f4a8: 0x121023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 18)));
    // 0x20f4ac: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f4b0: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f4b4: 0x431006
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 3), GPR_U32(ctx, 2) & 0x1F));
    // 0x20f4b8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f4bc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f4c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _flushBuf
// Address: 0x20f4c8 - 0x20f528

void entry_20f528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f528) {
        switch (ctx->pc) {
            case 0x20f52c: ctx->pc = 0; goto label_20f52c;
            case 0x20f558: ctx->pc = 0; goto label_20f558;
            case 0x20f560: ctx->pc = 0; goto label_20f560;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f528: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f52c:
    // 0x20f52c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20f530: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x20f534: 0x34632010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8208));
    // 0x20f538: 0x34844000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16384));
    // 0x20f53c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20f540: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x20f544: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20f548: 0x1045fff1
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x20F510; return;
    }
    // 0x20f550: 0x10000003
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f560;
    }
label_20f558:
    // 0x20f558: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x20f55c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
label_20f560:
    // 0x20f560: 0x2221025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x20f564: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x20f568: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x20f56c: 0x22f02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 2), 28));
    // 0x20f570: 0x2642b040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294946880));
    // 0x20f574: 0x52880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 2));
    // 0x20f578: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x20f57c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f580: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x20f584: 0xc083c66
    SET_GPR_U32(ctx, 31, 0x20f58c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 2072), GPR_U32(ctx, 2));
    _waitIpuIdle64(rdram, ctx, runtime); return;
}


// Function: entry_20f58c
// Address: 0x20f58c - 0x20f5b8

void entry_20f58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f58c: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20f590: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20f594: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x20f598: 0xae03083c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2108), GPR_U32(ctx, 3));
    // 0x20f59c: 0xae020838
    WRITE32(ADD32(GPR_U32(ctx, 16), 2104), GPR_U32(ctx, 2));
    // 0x20f5a0: 0xdfbf0030
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f5a4: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f5a8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f5ac: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f5b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _sceMpegNextBit
// Address: 0x20f5b8 - 0x20f61c

void entry_20f61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f61c) {
        switch (ctx->pc) {
            case 0x20f620: ctx->pc = 0; goto label_20f620;
            case 0x20f64c: ctx->pc = 0; goto label_20f64c;
            case 0x20f650: ctx->pc = 0; goto label_20f650;
            case 0x20f668: ctx->pc = 0; goto label_20f668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f61c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_20f620:
    // 0x20f620: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x20f624: 0x3c048000
    SET_GPR_U32(ctx, 4, ((uint32_t)32768 << 16));
    // 0x20f628: 0x34632010
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8208));
    // 0x20f62c: 0x34844000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16384));
    // 0x20f630: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20f634: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x20f638: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x20f63c: 0x1045fff2
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x20F608; return;
    }
    // 0x20f644: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2072)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_20f650;
    }
label_20f64c:
    // 0x20f64c: 0x8e220818
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2072)));
label_20f650:
    // 0x20f650: 0x14400005
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20f668;
    }
    // 0x20f658: 0x8e22083c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2108)));
    // 0x20f65c: 0x52102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 18)));
    // 0x20f660: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F694; return;
    }
label_20f668:
    // 0x20f668: 0x3c034000
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    // 0x20f66c: 0x34422000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8192));
    // 0x20f670: 0x2665b040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4294946880));
    // 0x20f674: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x20f678: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20f67c: 0x8ca20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x20f680: 0xc083c66
    SET_GPR_U32(ctx, 31, 0x20f688);
    WRITE32(ADD32(GPR_U32(ctx, 17), 2072), GPR_U32(ctx, 2));
    _waitIpuIdle64(rdram, ctx, runtime); return;
}


// Function: entry_20f688
// Address: 0x20f688 - 0x20f6dc

void entry_20f688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f688) {
        switch (ctx->pc) {
            case 0x20f694: ctx->pc = 0; goto label_20f694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f688: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20f68c: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20f690: 0xae220838
    WRITE32(ADD32(GPR_U32(ctx, 17), 2104), GPR_U32(ctx, 2));
label_20f694:
    // 0x20f694: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x20f698: 0x3c044000
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    // 0x20f69c: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20f6a0: 0x2442025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    // 0x20f6a4: 0xae25083c
    WRITE32(ADD32(GPR_U32(ctx, 17), 2108), GPR_U32(ctx, 5));
    // 0x20f6a8: 0x34422000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8192));
    // 0x20f6ac: 0x8e300838
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 2104)));
    // 0x20f6b0: 0x41f02
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 4), 28));
    // 0x20f6b4: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x20f6b8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x20f6bc: 0x2662b040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4294946880));
    // 0x20f6c0: 0xb22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 18)));
    // 0x20f6c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20f6c8: 0xb08006
    SET_GPR_U32(ctx, 16, SRL32(GPR_U32(ctx, 16), GPR_U32(ctx, 5) & 0x1F));
    // 0x20f6cc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20f6d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20f6d4: 0xc083c66
    SET_GPR_U32(ctx, 31, 0x20f6dc);
    WRITE32(ADD32(GPR_U32(ctx, 17), 2072), GPR_U32(ctx, 2));
    _waitIpuIdle64(rdram, ctx, runtime); return;
}


// Function: entry_20f6dc
// Address: 0x20f6dc - 0x20f708

void entry_20f6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f6dc: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x20f6e0: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x20f6e4: 0xdfbf0040
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20f6e8: 0xae220838
    WRITE32(ADD32(GPR_U32(ctx, 17), 2104), GPR_U32(ctx, 2));
    // 0x20f6ec: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f6f0: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f6f4: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f6f8: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f6fc: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f700: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _nextStartCode
// Address: 0x20f708 - 0x20f720

void entry_20f720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f720: 0x3c021000
    SET_GPR_U32(ctx, 2, ((uint32_t)4096 << 16));
    // 0x20f724: 0x34422020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8224));
    // 0x20f728: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x20f72c: 0x30630007
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 7));
    // 0x20f730: 0x31823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x20f734: 0x30650007
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 3), 7));
    // 0x20f738: 0x10a00007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_20f758(rdram, ctx, runtime); return;
    }
    // 0x20f740: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20f748);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20f748
// Address: 0x20f748 - 0x20f758

void entry_20f748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f748) {
        switch (ctx->pc) {
            case 0x20f750: ctx->pc = 0; goto label_20f750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f748: 0x10000003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_20f758(rdram, ctx, runtime); return;
    }
label_20f750:
    // 0x20f750: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20f758);
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20f758
// Address: 0x20f758 - 0x20f764

void entry_20f758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f758: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f75c: 0xc083cf0
    SET_GPR_U32(ctx, 31, 0x20f764);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    _peepBit(rdram, ctx, runtime); return;
}


// Function: entry_20f764
// Address: 0x20f764 - 0x20f788

void entry_20f764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f764: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f768: 0x1451fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x20F750; return;
    }
    // 0x20f770: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f774: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f778: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f77c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20f784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f788; return;
}


// Function: _sliceB
// Address: 0x20f788 - 0x20f7a0

void entry_20f7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f7a0: 0xae0201b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 436), GPR_U32(ctx, 2));
    // 0x20f7a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f7a8: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f7b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f7b0
// Address: 0x20f7b0 - 0x20f7c4

void entry_20f7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f7b0: 0x1040000a
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F7DC; return;
    }
    // 0x20f7b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f7bc: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f7c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f7c4
// Address: 0x20f7c4 - 0x20f7d0

void entry_20f7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f7c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f7c8: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20f7d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20f7d0
// Address: 0x20f7d0 - 0x20f7d8

void entry_20f7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f7d0: 0xc083f38
    SET_GPR_U32(ctx, 31, 0x20f7d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _extrainfo(rdram, ctx, runtime); return;
}


// Function: entry_20f7d8
// Address: 0x20f7d8 - 0x20f7f0

void entry_20f7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f7d8) {
        switch (ctx->pc) {
            case 0x20f7dc: ctx->pc = 0; goto label_20f7dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f7d8: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
label_20f7dc:
    // 0x20f7dc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20f7e0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f7e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20f7ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f7f0; return;
}


// Function: _nextHeader
// Address: 0x20f7f0 - 0x20f838

void entry_20f838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f838: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f83c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f844);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f844
// Address: 0x20f844 - 0x20f888

void entry_20f844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f844) {
        switch (ctx->pc) {
            case 0x20f868: ctx->pc = 0; goto label_20f868;
            case 0x20f880: ctx->pc = 0; goto label_20f880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f844: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20f848: 0x1075000d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 436));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 21)) {
        goto label_20f880;
    }
    // 0x20f850: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20f868;
    }
    // 0x20f858: 0x10740011
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x20F8A0; return;
    }
    // 0x20f860: 0x1000fff3
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F830; return;
    }
label_20f868:
    // 0x20f868: 0x1073001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x20F8D4; return;
    }
    // 0x20f870: 0x10720007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x20F890; return;
    }
    // 0x20f878: 0x1000ffed
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F830; return;
    }
label_20f880:
    // 0x20f880: 0xc082e7c
    SET_GPR_U32(ctx, 31, 0x20f888);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _sequenceHeader(rdram, ctx, runtime); return;
}


// Function: entry_20f888
// Address: 0x20f888 - 0x20f898

void entry_20f888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f888) {
        switch (ctx->pc) {
            case 0x20f890: ctx->pc = 0; goto label_20f890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f888: 0x1000ffe9
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F830; return;
    }
label_20f890:
    // 0x20f890: 0xc083f68
    SET_GPR_U32(ctx, 31, 0x20f898);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _groupOfPicturesHeader(rdram, ctx, runtime); return;
}


// Function: entry_20f898
// Address: 0x20f898 - 0x20f8a8

void entry_20f898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f898) {
        switch (ctx->pc) {
            case 0x20f8a0: ctx->pc = 0; goto label_20f8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f898: 0x1000ffe5
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F830; return;
    }
label_20f8a0:
    // 0x20f8a0: 0xc083e40
    SET_GPR_U32(ctx, 31, 0x20f8a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _pictureHeader(rdram, ctx, runtime); return;
}


// Function: entry_20f8a8
// Address: 0x20f8a8 - 0x20f8c0

void entry_20f8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f8a8: 0x8e040858
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2136)));
    // 0x20f8ac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x20f8b0: 0xafb60000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 22));
    // 0x20f8b4: 0xffb10010
    WRITE64(ADD32(GPR_U32(ctx, 29), 16), GPR_U64(ctx, 17));
    // 0x20f8b8: 0xc082c64
    SET_GPR_U32(ctx, 31, 0x20f8c0);
    WRITE64(ADD32(GPR_U32(ctx, 29), 8), GPR_U64(ctx, 17));
    _dispatchMpegCallback(rdram, ctx, runtime); return;
}


// Function: entry_20f8c0
// Address: 0x20f8c0 - 0x20f900

void entry_20f8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f8c0) {
        switch (ctx->pc) {
            case 0x20f8d4: ctx->pc = 0; goto label_20f8d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f8c0: 0xdfa20010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f8c4: 0xdfa30008
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x20f8c8: 0xfe020830
    WRITE64(ADD32(GPR_U32(ctx, 16), 2096), GPR_U64(ctx, 2));
    // 0x20f8cc: 0xfe030828
    WRITE64(ADD32(GPR_U32(ctx, 16), 2088), GPR_U64(ctx, 3));
    // 0x20f8d0: 0x8e020150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 336)));
label_20f8d4:
    // 0x20f8d4: 0xdfbf0090
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x20f8d8: 0xdfb60080
    SET_GPR_U64(ctx, 22, READ64(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x20f8dc: 0xdfb50070
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x20f8e0: 0xdfb40060
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20f8e4: 0xdfb30050
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20f8e8: 0xdfb20040
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20f8ec: 0xdfb10030
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20f8f0: 0xdfb00020
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f8f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20f8fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f900; return;
}


// Function: _pictureHeader
// Address: 0x20f900 - 0x20f91c

void entry_20f91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f91c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20f920: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f924: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f92c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f92c
// Address: 0x20f92c - 0x20f93c

void entry_20f92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f92c: 0xae020150
    WRITE32(ADD32(GPR_U32(ctx, 16), 336), GPR_U32(ctx, 2));
    // 0x20f930: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f934: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f93c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f93c
// Address: 0x20f93c - 0x20f958

void entry_20f93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f93c: 0x8e030150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x20f940: 0x2462fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967294));
    // 0x20f944: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x20f948: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20F970; return;
    }
    // 0x20f950: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f958);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f958
// Address: 0x20f958 - 0x20f968

void entry_20f958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f958: 0xae020154
    WRITE32(ADD32(GPR_U32(ctx, 16), 340), GPR_U32(ctx, 2));
    // 0x20f95c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f960: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f968);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f968
// Address: 0x20f968 - 0x20f984

void entry_20f968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f968) {
        switch (ctx->pc) {
            case 0x20f970: ctx->pc = 0; goto label_20f970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f968: 0xae020158
    WRITE32(ADD32(GPR_U32(ctx, 16), 344), GPR_U32(ctx, 2));
    // 0x20f96c: 0x8e030150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 336)));
label_20f970:
    // 0x20f970: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20f974: 0x14620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x20F998; return;
    }
    // 0x20f97c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f984);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f984
// Address: 0x20f984 - 0x20f994

void entry_20f984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f984: 0xae02015c
    WRITE32(ADD32(GPR_U32(ctx, 16), 348), GPR_U32(ctx, 2));
    // 0x20f988: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f98c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20f994);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20f994
// Address: 0x20f994 - 0x20f9a0

void entry_20f994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20f994) {
        switch (ctx->pc) {
            case 0x20f998: ctx->pc = 0; goto label_20f998;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20f994: 0xae020160
    WRITE32(ADD32(GPR_U32(ctx, 16), 352), GPR_U32(ctx, 2));
label_20f998:
    // 0x20f998: 0xc083f38
    SET_GPR_U32(ctx, 31, 0x20f9a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _extrainfo(rdram, ctx, runtime); return;
}


// Function: entry_20f9a0
// Address: 0x20f9a0 - 0x20f9a8

void entry_20f9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f9a0: 0xc083e72
    SET_GPR_U32(ctx, 31, 0x20f9a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _extensionAndUserData(rdram, ctx, runtime); return;
}


// Function: entry_20f9a8
// Address: 0x20f9a8 - 0x20f9c8

void entry_20f9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20f9a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20f9ac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20f9b0: 0xdfbf0020
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20f9b4: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20f9b8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20f9bc: 0x8083f4a
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = 0x20fd28; return;
    // 0x20f9c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20f9c8; return;
}


// Function: _extensionAndUserData
// Address: 0x20f9c8 - 0x20fa54

void entry_20fa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fa54) {
        switch (ctx->pc) {
            case 0x20fa60: ctx->pc = 0; goto label_20fa60;
            case 0x20fa68: ctx->pc = 0; goto label_20fa68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fa54: 0x10000019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20FABC; return;
    }
    // 0x20fa5c: 0x0
    // NOP
label_20fa60:
    // 0x20fa60: 0x54510011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x20FAA8; return;
    }
label_20fa68:
    // 0x20fa68: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20fa70);
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20fa70
// Address: 0x20fa70 - 0x20fa7c

void entry_20fa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fa70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fa74: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fa7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fa7c
// Address: 0x20fa7c - 0x20fa98

void entry_20fa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fa7c: 0x242182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x20fa80: 0x3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x20fa84: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x20fa88: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x20fa8c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x20fa90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x20fa98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_20fa98
// Address: 0x20fa98 - 0x20faa0

void entry_20fa98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fa98: 0xc083dc2
    SET_GPR_U32(ctx, 31, 0x20faa0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _nextStartCode(rdram, ctx, runtime); return;
}


// Function: entry_20faa0
// Address: 0x20faa0 - 0x20fab0

void entry_20faa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20faa0) {
        switch (ctx->pc) {
            case 0x20faa8: ctx->pc = 0; goto label_20faa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20faa0: 0x10000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20FABC; return;
    }
label_20faa8:
    // 0x20faa8: 0xc083d32
    SET_GPR_U32(ctx, 31, 0x20fab0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _flushBuf(rdram, ctx, runtime); return;
}


// Function: entry_20fab0
// Address: 0x20fab0 - 0x20fab8

void entry_20fab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fab0: 0xc083dc2
    SET_GPR_U32(ctx, 31, 0x20fab8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _nextStartCode(rdram, ctx, runtime); return;
}


// Function: entry_20fab8
// Address: 0x20fab8 - 0x20fac4

void entry_20fab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fab8) {
        switch (ctx->pc) {
            case 0x20fabc: ctx->pc = 0; goto label_20fabc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fab8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_20fabc:
    // 0x20fabc: 0xc083cf0
    SET_GPR_U32(ctx, 31, 0x20fac4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    _peepBit(rdram, ctx, runtime); return;
}


// Function: entry_20fac4
// Address: 0x20fac4 - 0x20faf0

void entry_20fac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fac4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fac8: 0x1051ffe7
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x20FA68; return;
    }
    // 0x20fad0: 0x1053ffe3
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x20FA60; return;
    }
    // 0x20fad8: 0xdfb30060
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20fadc: 0xdfb20050
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20fae0: 0xdfb10040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20fae4: 0xdfb00030
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20fae8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _pictureCodingExtension
// Address: 0x20faf0 - 0x20fb08

void entry_20fb08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb08: 0xae020164
    WRITE32(ADD32(GPR_U32(ctx, 16), 356), GPR_U32(ctx, 2));
    // 0x20fb0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb10: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb18
// Address: 0x20fb18 - 0x20fb28

void entry_20fb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb18: 0xae020168
    WRITE32(ADD32(GPR_U32(ctx, 16), 360), GPR_U32(ctx, 2));
    // 0x20fb1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb20: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb28
// Address: 0x20fb28 - 0x20fb38

void entry_20fb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb28: 0xae02016c
    WRITE32(ADD32(GPR_U32(ctx, 16), 364), GPR_U32(ctx, 2));
    // 0x20fb2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb30: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb38
// Address: 0x20fb38 - 0x20fb48

void entry_20fb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb38: 0xae020170
    WRITE32(ADD32(GPR_U32(ctx, 16), 368), GPR_U32(ctx, 2));
    // 0x20fb3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb40: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb48
// Address: 0x20fb48 - 0x20fb78

void entry_20fb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb48: 0x3c071000
    SET_GPR_U32(ctx, 7, ((uint32_t)4096 << 16));
    // 0x20fb4c: 0x3c06fffc
    SET_GPR_U32(ctx, 6, ((uint32_t)65532 << 16));
    // 0x20fb50: 0x34e72010
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 8208));
    // 0x20fb54: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x20fb58: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x20fb5c: 0x21400
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 16));
    // 0x20fb60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb64: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x20fb68: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x20fb6c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x20fb70: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb78);
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 3));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb78
// Address: 0x20fb78 - 0x20fb98

void entry_20fb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fb78) {
        switch (ctx->pc) {
            case 0x20fb8c: ctx->pc = 0; goto label_20fb8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fb78: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x20fb7c: 0x8e0200d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 212)));
    // 0x20fb80: 0x14400002
    WRITE32(ADD32(GPR_U32(ctx, 16), 372), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_20fb8c;
    }
    // 0x20fb88: 0xae0300d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 212), GPR_U32(ctx, 3));
label_20fb8c:
    // 0x20fb8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fb90: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fb98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fb98
// Address: 0x20fb98 - 0x20fba8

void entry_20fb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fb98: 0xae020178
    WRITE32(ADD32(GPR_U32(ctx, 16), 376), GPR_U32(ctx, 2));
    // 0x20fb9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fba0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fba8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fba8
// Address: 0x20fba8 - 0x20fbb8

void entry_20fba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fba8: 0xae02017c
    WRITE32(ADD32(GPR_U32(ctx, 16), 380), GPR_U32(ctx, 2));
    // 0x20fbac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fbb0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fbb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fbb8
// Address: 0x20fbb8 - 0x20fbc8

void entry_20fbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fbb8: 0xae020180
    WRITE32(ADD32(GPR_U32(ctx, 16), 384), GPR_U32(ctx, 2));
    // 0x20fbbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fbc0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fbc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fbc8
// Address: 0x20fbc8 - 0x20fbf8

void entry_20fbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fbc8: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x20fbcc: 0x8cc62010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8208)));
    // 0x20fbd0: 0x3c03ffbf
    SET_GPR_U32(ctx, 3, ((uint32_t)65471 << 16));
    // 0x20fbd4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x20fbd8: 0x21580
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 22));
    // 0x20fbdc: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20fbe0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fbe4: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x20fbe8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20fbec: 0x3c011000
    SET_GPR_U32(ctx, 1, ((uint32_t)4096 << 16));
    // 0x20fbf0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fbf8);
    WRITE32(ADD32(GPR_U32(ctx, 1), 8208), GPR_U32(ctx, 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fbf8
// Address: 0x20fbf8 - 0x20fc28

void entry_20fbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fbf8: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x20fbfc: 0x8cc62010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8208)));
    // 0x20fc00: 0x3c03ffdf
    SET_GPR_U32(ctx, 3, ((uint32_t)65503 << 16));
    // 0x20fc04: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x20fc08: 0x21540
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 21));
    // 0x20fc0c: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20fc10: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc14: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x20fc18: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20fc1c: 0x3c011000
    SET_GPR_U32(ctx, 1, ((uint32_t)4096 << 16));
    // 0x20fc20: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc28);
    WRITE32(ADD32(GPR_U32(ctx, 1), 8208), GPR_U32(ctx, 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc28
// Address: 0x20fc28 - 0x20fc58

void entry_20fc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc28: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x20fc2c: 0x8cc62010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8208)));
    // 0x20fc30: 0x3c03ffef
    SET_GPR_U32(ctx, 3, ((uint32_t)65519 << 16));
    // 0x20fc34: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x20fc38: 0x21500
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 20));
    // 0x20fc3c: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x20fc40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc44: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x20fc48: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x20fc4c: 0x3c011000
    SET_GPR_U32(ctx, 1, ((uint32_t)4096 << 16));
    // 0x20fc50: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc58);
    WRITE32(ADD32(GPR_U32(ctx, 1), 8208), GPR_U32(ctx, 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc58
// Address: 0x20fc58 - 0x20fc68

void entry_20fc58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc58: 0xae020184
    WRITE32(ADD32(GPR_U32(ctx, 16), 388), GPR_U32(ctx, 2));
    // 0x20fc5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc60: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc68
// Address: 0x20fc68 - 0x20fc74

void entry_20fc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc6c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc74
// Address: 0x20fc74 - 0x20fc84

void entry_20fc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc74: 0xae020188
    WRITE32(ADD32(GPR_U32(ctx, 16), 392), GPR_U32(ctx, 2));
    // 0x20fc78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc7c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc84
// Address: 0x20fc84 - 0x20fc98

void entry_20fc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc84: 0x10400013
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x20FCD4; return;
    }
    // 0x20fc8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc90: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fc98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fc98
// Address: 0x20fc98 - 0x20fca4

void entry_20fc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fc98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fc9c: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fca4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fca4
// Address: 0x20fca4 - 0x20fcb0

void entry_20fca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fca4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fca8: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fcb0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fcb0
// Address: 0x20fcb0 - 0x20fcbc

void entry_20fcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fcb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fcb4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fcbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fcbc
// Address: 0x20fcbc - 0x20fce0

void entry_20fcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fcbc) {
        switch (ctx->pc) {
            case 0x20fcd4: ctx->pc = 0; goto label_20fcd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fcbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fcc0: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20fcc4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fcc8: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x20fccc: 0x8083d6e
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    _sceMpegNextBit(rdram, ctx, runtime); return;
label_20fcd4:
    // 0x20fcd4: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fcd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: _extrainfo
// Address: 0x20fce0 - 0x20fd00

void entry_20fd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fd00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fd04: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fd0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fd0c
// Address: 0x20fd0c - 0x20fda0

void entry_20fd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fd0c) {
        switch (ctx->pc) {
            case 0x20fd28: ctx->pc = 0; goto label_20fd28;
            case 0x20fd5c: ctx->pc = 0; goto label_20fd5c;
            case 0x20fd60: ctx->pc = 0; goto label_20fd60;
            case 0x20fd64: ctx->pc = 0; goto label_20fd64;
            case 0x20fd84: ctx->pc = 0; goto label_20fd84;
            case 0x20fd88: ctx->pc = 0; goto label_20fd88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fd0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fd10: 0x1440fff9
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20FCF8; return;
    }
    // 0x20fd18: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20fd1c: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fd20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
label_20fd28:
    // 0x20fd28: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x20fd2c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x20fd30: 0x8cc30150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 336)));
    // 0x20fd34: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x20fd38: 0x10620009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_20fd60;
    }
    // 0x20fd40: 0x50a00008
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2124)));
        goto label_20fd64;
    }
    // 0x20fd48: 0x4a30004
    if (GPR_S32(ctx, 5) >= 0) {
        WRITE32(ADD32(GPR_U32(ctx, 6), 2132), GPR_U32(ctx, 0));
        goto label_20fd5c;
    }
    // 0x20fd50: 0x8cc20854
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2132)));
    // 0x20fd54: 0x2c470001
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x20fd58: 0xacc00854
    WRITE32(ADD32(GPR_U32(ctx, 6), 2132), GPR_U32(ctx, 0));
label_20fd5c:
    // 0x20fd5c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_20fd60:
    // 0x20fd60: 0x8cc2084c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2124)));
label_20fd64:
    // 0x20fd64: 0x451821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x20fd68: 0x10e00006
    WRITE32(ADD32(GPR_U32(ctx, 6), 428), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_20fd84;
    }
    // 0x20fd70: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x20fd74: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2128)));
        goto label_20fd88;
    }
    // 0x20fd7c: 0x24620400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1024));
    // 0x20fd80: 0xacc201ac
    WRITE32(ADD32(GPR_U32(ctx, 6), 428), GPR_U32(ctx, 2));
label_20fd84:
    // 0x20fd84: 0x8cc20850
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2128)));
label_20fd88:
    // 0x20fd88: 0x8cc401ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 428)));
    // 0x20fd8c: 0x44182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x20fd90: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x20fd94: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 6), 2128), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20fd9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20fda0; return;
}


// Function: _groupOfPicturesHeader
// Address: 0x20fda0 - 0x20fdd0

void entry_20fdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fdd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fdd4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fddc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fddc
// Address: 0x20fddc - 0x20fde8

void entry_20fddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fddc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fde0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fde8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fde8
// Address: 0x20fde8 - 0x20fdf4

void entry_20fde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fde8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fdec: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fdf4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fdf4
// Address: 0x20fdf4 - 0x20fe00

void entry_20fdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fdf4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fdf8: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fe00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fe00
// Address: 0x20fe00 - 0x20fe0c

void entry_20fe00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe04: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fe0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fe0c
// Address: 0x20fe0c - 0x20fe18

void entry_20fe0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe10: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fe18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fe18
// Address: 0x20fe18 - 0x20fe28

void entry_20fe18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe18: 0xae0201a4
    WRITE32(ADD32(GPR_U32(ctx, 16), 420), GPR_U32(ctx, 2));
    // 0x20fe1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe20: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fe28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fe28
// Address: 0x20fe28 - 0x20fe40

void entry_20fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe28: 0xae0201a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 424), GPR_U32(ctx, 2));
    // 0x20fe2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe30: 0xdfbf0010
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20fe34: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fe38: 0x8083e72
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    _extensionAndUserData(rdram, ctx, runtime); return;
}


// Function: _quantMatrixExtension
// Address: 0x20fe40 - 0x20fe58

void entry_20fe58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe58: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 16), 2112), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20fe7c(rdram, ctx, runtime); return;
    }
    // 0x20fe60: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20fe68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20fe68
// Address: 0x20fe68 - 0x20fe74

void entry_20fe68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe6c: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20fe74);
    SET_GPR_U32(ctx, 5, ((uint32_t)20480 << 16));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20fe74
// Address: 0x20fe74 - 0x20fe7c

void entry_20fe74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe74: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20fe7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20fe7c
// Address: 0x20fe7c - 0x20fe88

void entry_20fe7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe80: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fe88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fe88
// Address: 0x20fe88 - 0x20fe98

void entry_20fe88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe88: 0x10400008
    WRITE32(ADD32(GPR_U32(ctx, 16), 2116), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20feac(rdram, ctx, runtime); return;
    }
    // 0x20fe90: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20fe98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20fe98
// Address: 0x20fe98 - 0x20fea4

void entry_20fe98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fe98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fe9c: 0xc083c30
    SET_GPR_U32(ctx, 31, 0x20fea4);
    SET_GPR_U32(ctx, 5, ((uint32_t)22528 << 16));
    _sendIpuCommand(rdram, ctx, runtime); return;
}


// Function: entry_20fea4
// Address: 0x20fea4 - 0x20feac

void entry_20fea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fea4: 0xc083c3c
    SET_GPR_U32(ctx, 31, 0x20feac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    _waitIpuIdle(rdram, ctx, runtime); return;
}


// Function: entry_20feac
// Address: 0x20feac - 0x20feb8

void entry_20feac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20feac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20feb0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20feb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20feb8
// Address: 0x20feb8 - 0x20fecc

void entry_20feb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20feb8: 0x10400004
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_20fecc(rdram, ctx, runtime); return;
    }
    // 0x20fec0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fec4: 0xc082e5e
    SET_GPR_U32(ctx, 31, 0x20fecc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1120));
    fn__Error(rdram, ctx, runtime); return;
}


// Function: entry_20fecc
// Address: 0x20fecc - 0x20fed8

void entry_20fecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20fecc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fed0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20fed8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20fed8
// Address: 0x20fed8 - 0x20ff08

void entry_20fed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20fed8) {
        switch (ctx->pc) {
            case 0x20fef8: ctx->pc = 0; goto label_20fef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20fed8: 0x10400007
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_20fef8;
    }
    // 0x20fee0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x20fee4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x20fee8: 0x24a50488
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1160));
    // 0x20feec: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fef0: 0x8082e5e
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    fn__Error(rdram, ctx, runtime); return;
label_20fef8:
    // 0x20fef8: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fefc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20ff04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x20ff08; return;
}


// Function: _pictureDisplayExtension
// Address: 0x20ff08 - 0x20ff90

void entry_20ff90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ff90: 0x128080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 18), 2));
    // 0x20ff94: 0x2b01821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 16)));
    // 0x20ff98: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20ff9c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x20ffa0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ffa8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ffa8
// Address: 0x20ffa8 - 0x20ffb8

void entry_20ffa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ffa8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x20ffac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20ffb0: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ffb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ffb8
// Address: 0x20ffb8 - 0x20ffcc

void entry_20ffb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x20ffb8: 0x2908021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x20ffbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x20ffc0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x20ffc4: 0xc083d6e
    SET_GPR_U32(ctx, 31, 0x20ffcc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    _sceMpegNextBit(rdram, ctx, runtime); return;
}


// Function: entry_20ffcc
// Address: 0x20ffcc - 0x210000

void entry_20ffcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x20ffcc) {
        switch (ctx->pc) {
            case 0x20ffd8: ctx->pc = 0; goto label_20ffd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x20ffcc: 0x253182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x20ffd0: 0x1460ffed
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x20FF88; return;
    }
label_20ffd8:
    // 0x20ffd8: 0xdfbf0060
    SET_GPR_U64(ctx, 31, READ64(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x20ffdc: 0xdfb50050
    SET_GPR_U64(ctx, 21, READ64(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x20ffe0: 0xdfb40040
    SET_GPR_U64(ctx, 20, READ64(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x20ffe4: 0xdfb30030
    SET_GPR_U64(ctx, 19, READ64(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x20ffe8: 0xdfb20020
    SET_GPR_U64(ctx, 18, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x20ffec: 0xdfb10010
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x20fff0: 0xdfb00000
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x20fff4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x20fffc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x210000; return;
}


// Function: _copyrightExtension
// Address: 0x210000 - 0x210018

void entry_200080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200080 inside entry_200074 (0x200074 - 0x2000a4)
    ctx->pc = 0x200080;
    entry_200074(rdram, ctx, runtime);
}

void entry_2000d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2000d8 inside entry_2000d0 (0x2000d0 - 0x200118)
    ctx->pc = 0x2000d8;
    entry_2000d0(rdram, ctx, runtime);
}

void entry_2000e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2000e0 inside entry_2000d0 (0x2000d0 - 0x200118)
    ctx->pc = 0x2000e0;
    entry_2000d0(rdram, ctx, runtime);
}

void entry_20010c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20010c inside entry_2000d0 (0x2000d0 - 0x200118)
    ctx->pc = 0x20010c;
    entry_2000d0(rdram, ctx, runtime);
}

void entry_200130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200130 inside FUN_00200118 (0x200118 - 0x200138)
    ctx->pc = 0x200130;
    FUN_00200118(rdram, ctx, runtime);
}

void entry_20014c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20014c inside FUN_00200138 (0x200138 - 0x200158)
    ctx->pc = 0x20014c;
    FUN_00200138(rdram, ctx, runtime);
}

void entry_200288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200288 inside entry_200268 (0x200268 - 0x20030c)
    ctx->pc = 0x200288;
    entry_200268(rdram, ctx, runtime);
}

void entry_2002b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2002b0 inside entry_200268 (0x200268 - 0x20030c)
    ctx->pc = 0x2002b0;
    entry_200268(rdram, ctx, runtime);
}

void entry_2002b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2002b8 inside entry_200268 (0x200268 - 0x20030c)
    ctx->pc = 0x2002b8;
    entry_200268(rdram, ctx, runtime);
}

void entry_2002e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2002e0 inside entry_200268 (0x200268 - 0x20030c)
    ctx->pc = 0x2002e0;
    entry_200268(rdram, ctx, runtime);
}

void entry_200328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200328 inside entry_20030c (0x20030c - 0x20035c)
    ctx->pc = 0x200328;
    entry_20030c(rdram, ctx, runtime);
}

void entry_2003a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003a0 inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003a0;
    entry_200388(rdram, ctx, runtime);
}

void entry_2003a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003a8 inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003a8;
    entry_200388(rdram, ctx, runtime);
}

void entry_2003ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003ac inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003ac;
    entry_200388(rdram, ctx, runtime);
}

void entry_2003b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003b0 inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003b0;
    entry_200388(rdram, ctx, runtime);
}

void entry_2003c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003c4 inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003c4;
    entry_200388(rdram, ctx, runtime);
}

void entry_2003c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2003c8 inside entry_200388 (0x200388 - 0x200418)
    ctx->pc = 0x2003c8;
    entry_200388(rdram, ctx, runtime);
}

void entry_2007cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2007cc inside entry_2007b4 (0x2007b4 - 0x2007f8)
    ctx->pc = 0x2007cc;
    entry_2007b4(rdram, ctx, runtime);
}

void entry_2007fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2007fc inside entry_2007f8 (0x2007f8 - 0x20083c)
    ctx->pc = 0x2007fc;
    entry_2007f8(rdram, ctx, runtime);
}

void entry_200814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200814 inside entry_2007f8 (0x2007f8 - 0x20083c)
    ctx->pc = 0x200814;
    entry_2007f8(rdram, ctx, runtime);
}

void entry_200840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200840 inside entry_20083c (0x20083c - 0x20087c)
    ctx->pc = 0x200840;
    entry_20083c(rdram, ctx, runtime);
}

void entry_2008d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2008d0 inside entry_2008c0 (0x2008c0 - 0x200904)
    ctx->pc = 0x2008d0;
    entry_2008c0(rdram, ctx, runtime);
}

void entry_200914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200914 inside entry_200904 (0x200904 - 0x200948)
    ctx->pc = 0x200914;
    entry_200904(rdram, ctx, runtime);
}

void entry_2009a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2009a4 inside entry_20099c (0x20099c - 0x2009dc)
    ctx->pc = 0x2009a4;
    entry_20099c(rdram, ctx, runtime);
}

void entry_2009b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2009b4 inside entry_20099c (0x20099c - 0x2009dc)
    ctx->pc = 0x2009b4;
    entry_20099c(rdram, ctx, runtime);
}

void entry_2009e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2009e0 inside entry_2009dc (0x2009dc - 0x200a10)
    ctx->pc = 0x2009e0;
    entry_2009dc(rdram, ctx, runtime);
}

void entry_2009ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2009ec inside entry_2009dc (0x2009dc - 0x200a10)
    ctx->pc = 0x2009ec;
    entry_2009dc(rdram, ctx, runtime);
}

void entry_200a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200a18 inside entry_200a10 (0x200a10 - 0x200a50)
    ctx->pc = 0x200a18;
    entry_200a10(rdram, ctx, runtime);
}

void entry_200a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200a28 inside entry_200a10 (0x200a10 - 0x200a50)
    ctx->pc = 0x200a28;
    entry_200a10(rdram, ctx, runtime);
}

void entry_200a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200a54 inside entry_200a50 (0x200a50 - 0x200a94)
    ctx->pc = 0x200a54;
    entry_200a50(rdram, ctx, runtime);
}

void entry_200a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200a6c inside entry_200a50 (0x200a50 - 0x200a94)
    ctx->pc = 0x200a6c;
    entry_200a50(rdram, ctx, runtime);
}

void entry_200a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200a98 inside entry_200a94 (0x200a94 - 0x200ae8)
    ctx->pc = 0x200a98;
    entry_200a94(rdram, ctx, runtime);
}

void entry_200ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ab8 inside entry_200a94 (0x200a94 - 0x200ae8)
    ctx->pc = 0x200ab8;
    entry_200a94(rdram, ctx, runtime);
}

void entry_200ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ac8 inside entry_200a94 (0x200a94 - 0x200ae8)
    ctx->pc = 0x200ac8;
    entry_200a94(rdram, ctx, runtime);
}

void entry_200aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200aec inside entry_200ae8 (0x200ae8 - 0x200b1c)
    ctx->pc = 0x200aec;
    entry_200ae8(rdram, ctx, runtime);
}

void entry_200afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200afc inside entry_200ae8 (0x200ae8 - 0x200b1c)
    ctx->pc = 0x200afc;
    entry_200ae8(rdram, ctx, runtime);
}

void entry_200b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200b20 inside entry_200b1c (0x200b1c - 0x200b6c)
    ctx->pc = 0x200b20;
    entry_200b1c(rdram, ctx, runtime);
}

void entry_200b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200b40 inside entry_200b1c (0x200b1c - 0x200b6c)
    ctx->pc = 0x200b40;
    entry_200b1c(rdram, ctx, runtime);
}

void entry_200b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200b7c inside entry_200b6c (0x200b6c - 0x200ba8)
    ctx->pc = 0x200b7c;
    entry_200b6c(rdram, ctx, runtime);
}

void entry_200bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200bb8 inside entry_200ba8 (0x200ba8 - 0x200c00)
    ctx->pc = 0x200bb8;
    entry_200ba8(rdram, ctx, runtime);
}

void entry_200bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200bf8 inside entry_200ba8 (0x200ba8 - 0x200c00)
    ctx->pc = 0x200bf8;
    entry_200ba8(rdram, ctx, runtime);
}

void entry_200c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200c08 inside entry_200c00 (0x200c00 - 0x200c40)
    ctx->pc = 0x200c08;
    entry_200c00(rdram, ctx, runtime);
}

void entry_200c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200c0c inside entry_200c00 (0x200c00 - 0x200c40)
    ctx->pc = 0x200c0c;
    entry_200c00(rdram, ctx, runtime);
}

void entry_200c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200c10 inside entry_200c00 (0x200c00 - 0x200c40)
    ctx->pc = 0x200c10;
    entry_200c00(rdram, ctx, runtime);
}

void entry_200ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ca8 inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200ca8;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ccc inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200ccc;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200cec inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200cec;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200d0c inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200d0c;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200d2c inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200d2c;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200d4c inside entry_200c80 (0x200c80 - 0x200d58)
    ctx->pc = 0x200d4c;
    entry_200c80(rdram, ctx, runtime);
}

void entry_200e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200e34 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200e34;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200e6c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200e6c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ea4 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200ea4;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200edc inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200edc;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200f14 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200f14;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200f4c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200f4c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200f84 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200f84;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200fbc inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200fbc;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_200ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x200ff4 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x200ff4;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_20102c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20102c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x20102c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_201064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201064 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x201064;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_20109c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20109c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x20109c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_2010d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2010d4 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x2010d4;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_20110c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20110c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x20110c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_201144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201144 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x201144;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_20117c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20117c inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x20117c;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_2011b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2011b4 inside FUN_00200e08 (0x200e08 - 0x2011c0)
    ctx->pc = 0x2011b4;
    FUN_00200e08(rdram, ctx, runtime);
}

void entry_2014d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2014d8 inside abort (0x2014d0 - 0x2014e0)
    ctx->pc = 0x2014d8;
    abort(rdram, ctx, runtime);
}

void entry_201534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201534 inside entry_201524 (0x201524 - 0x201578)
    ctx->pc = 0x201534;
    entry_201524(rdram, ctx, runtime);
}

void entry_201540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201540 inside entry_201524 (0x201524 - 0x201578)
    ctx->pc = 0x201540;
    entry_201524(rdram, ctx, runtime);
}

void entry_201560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201560 inside entry_201524 (0x201524 - 0x201578)
    ctx->pc = 0x201560;
    entry_201524(rdram, ctx, runtime);
}

void entry_2015b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2015b0 inside _raise_r (0x201578 - 0x2015c4)
    ctx->pc = 0x2015b0;
    _raise_r(rdram, ctx, runtime);
}

void entry_2015d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2015d4 inside entry_2015c4 (0x2015c4 - 0x201618)
    ctx->pc = 0x2015d4;
    entry_2015c4(rdram, ctx, runtime);
}

void entry_201600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201600 inside entry_2015c4 (0x2015c4 - 0x201618)
    ctx->pc = 0x201600;
    entry_2015c4(rdram, ctx, runtime);
}

void entry_201610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201610 inside entry_2015c4 (0x2015c4 - 0x201618)
    ctx->pc = 0x201610;
    entry_2015c4(rdram, ctx, runtime);
}

void entry_201630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201630 inside entry_201628 (0x201628 - 0x20164c)
    ctx->pc = 0x201630;
    entry_201628(rdram, ctx, runtime);
}

void entry_201640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201640 inside entry_201628 (0x201628 - 0x20164c)
    ctx->pc = 0x201640;
    entry_201628(rdram, ctx, runtime);
}

void entry_201650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201650 inside entry_20164c (0x20164c - 0x201668)
    ctx->pc = 0x201650;
    entry_20164c(rdram, ctx, runtime);
}

void entry_201654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201654 inside entry_20164c (0x20164c - 0x201668)
    ctx->pc = 0x201654;
    entry_20164c(rdram, ctx, runtime);
}

void entry_2016a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2016a0 inside entry_201684 (0x201684 - 0x2016c8)
    ctx->pc = 0x2016a0;
    entry_201684(rdram, ctx, runtime);
}

void entry_2016e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2016e8 inside entry_2016c8 (0x2016c8 - 0x201700)
    ctx->pc = 0x2016e8;
    entry_2016c8(rdram, ctx, runtime);
}

void entry_2017f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2017f4 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x2017f4;
    strncpy(rdram, ctx, runtime);
}

void entry_201850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201850 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x201850;
    strncpy(rdram, ctx, runtime);
}

void entry_201884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201884 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x201884;
    strncpy(rdram, ctx, runtime);
}

void entry_201888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201888 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x201888;
    strncpy(rdram, ctx, runtime);
}

void entry_2018b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2018b8 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x2018b8;
    strncpy(rdram, ctx, runtime);
}

void entry_2018d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2018d4 inside strncpy (0x201720 - 0x2018e8)
    ctx->pc = 0x2018d4;
    strncpy(rdram, ctx, runtime);
}

void entry_201924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201924 inside sceGsResetPath (0x2018e8 - 0x201988)
    ctx->pc = 0x201924;
    sceGsResetPath(rdram, ctx, runtime);
}

void entry_2019b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2019b0 inside sceGsSyncPath (0x201988 - 0x201a18)
    ctx->pc = 0x2019b0;
    sceGsSyncPath(rdram, ctx, runtime);
}

void entry_201a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201a74 inside sceGsResetGraph (0x201a18 - 0x201a8c)
    ctx->pc = 0x201a74;
    sceGsResetGraph(rdram, ctx, runtime);
}

void entry_201a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201a84 inside sceGsResetGraph (0x201a18 - 0x201a8c)
    ctx->pc = 0x201a84;
    sceGsResetGraph(rdram, ctx, runtime);
}

void entry_201af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201af0 inside entry_201ae8 (0x201ae8 - 0x201b38)
    ctx->pc = 0x201af0;
    entry_201ae8(rdram, ctx, runtime);
}

void entry_201b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201b18 inside entry_201ae8 (0x201ae8 - 0x201b38)
    ctx->pc = 0x201b18;
    entry_201ae8(rdram, ctx, runtime);
}

void entry_201b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201b30 inside entry_201ae8 (0x201ae8 - 0x201b38)
    ctx->pc = 0x201b30;
    entry_201ae8(rdram, ctx, runtime);
}

void entry_201b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201b90 inside entry_201b38 (0x201b38 - 0x201ba8)
    ctx->pc = 0x201b90;
    entry_201b38(rdram, ctx, runtime);
}

void entry_201b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201b94 inside entry_201b38 (0x201b38 - 0x201ba8)
    ctx->pc = 0x201b94;
    entry_201b38(rdram, ctx, runtime);
}

void entry_201c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201c1c inside entry_201bcc (0x201bcc - 0x201c78)
    ctx->pc = 0x201c1c;
    entry_201bcc(rdram, ctx, runtime);
}

void entry_201c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201c68 inside entry_201bcc (0x201bcc - 0x201c78)
    ctx->pc = 0x201c68;
    entry_201bcc(rdram, ctx, runtime);
}

void entry_201cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201cb0 inside sceGsPutDrawEnv (0x201c78 - 0x201d24)
    ctx->pc = 0x201cb0;
    sceGsPutDrawEnv(rdram, ctx, runtime);
}

void entry_201ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201ccc inside sceGsPutDrawEnv (0x201c78 - 0x201d24)
    ctx->pc = 0x201ccc;
    sceGsPutDrawEnv(rdram, ctx, runtime);
}

void entry_201d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201d18 inside sceGsPutDrawEnv (0x201c78 - 0x201d24)
    ctx->pc = 0x201d18;
    sceGsPutDrawEnv(rdram, ctx, runtime);
}

void entry_201d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201d2c inside entry_201d24 (0x201d24 - 0x201d60)
    ctx->pc = 0x201d2c;
    entry_201d24(rdram, ctx, runtime);
}

void entry_201d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201d3c inside entry_201d24 (0x201d24 - 0x201d60)
    ctx->pc = 0x201d3c;
    entry_201d24(rdram, ctx, runtime);
}

void entry_201d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201d54 inside entry_201d24 (0x201d24 - 0x201d60)
    ctx->pc = 0x201d54;
    entry_201d24(rdram, ctx, runtime);
}

void entry_201f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201f90 inside entry_201f54 (0x201f54 - 0x201ff8)
    ctx->pc = 0x201f90;
    entry_201f54(rdram, ctx, runtime);
}

void entry_201fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x201fcc inside entry_201f54 (0x201f54 - 0x201ff8)
    ctx->pc = 0x201fcc;
    entry_201f54(rdram, ctx, runtime);
}

void entry_202038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202038 inside entry_202030 (0x202030 - 0x202040)
    ctx->pc = 0x202038;
    entry_202030(rdram, ctx, runtime);
}

void entry_202044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202044 inside entry_202040 (0x202040 - 0x202058)
    ctx->pc = 0x202044;
    entry_202040(rdram, ctx, runtime);
}

void entry_202110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202110 inside sceGsSetHalfOffset (0x202098 - 0x202120)
    ctx->pc = 0x202110;
    sceGsSetHalfOffset(rdram, ctx, runtime);
}

void entry_202114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202114 inside sceGsSetHalfOffset (0x202098 - 0x202120)
    ctx->pc = 0x202114;
    sceGsSetHalfOffset(rdram, ctx, runtime);
}

void entry_2021bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2021bc inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x2021bc;
    entry_202190(rdram, ctx, runtime);
}

void entry_2021c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2021c0 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x2021c0;
    entry_202190(rdram, ctx, runtime);
}

void entry_20221c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20221c inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x20221c;
    entry_202190(rdram, ctx, runtime);
}

void entry_20225c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20225c inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x20225c;
    entry_202190(rdram, ctx, runtime);
}

void entry_202274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202274 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202274;
    entry_202190(rdram, ctx, runtime);
}

void entry_202294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202294 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202294;
    entry_202190(rdram, ctx, runtime);
}

void entry_2022c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2022c4 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x2022c4;
    entry_202190(rdram, ctx, runtime);
}

void entry_202304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202304 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202304;
    entry_202190(rdram, ctx, runtime);
}

void entry_20230c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20230c inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x20230c;
    entry_202190(rdram, ctx, runtime);
}

void entry_202324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202324 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202324;
    entry_202190(rdram, ctx, runtime);
}

void entry_20233c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20233c inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x20233c;
    entry_202190(rdram, ctx, runtime);
}

void entry_202358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202358 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202358;
    entry_202190(rdram, ctx, runtime);
}

void entry_202380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202380 inside entry_202190 (0x202190 - 0x202388)
    ctx->pc = 0x202380;
    entry_202190(rdram, ctx, runtime);
}

void entry_20241c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20241c inside entry_2023e0 (0x2023e0 - 0x202478)
    ctx->pc = 0x20241c;
    entry_2023e0(rdram, ctx, runtime);
}

void entry_202430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202430 inside entry_2023e0 (0x2023e0 - 0x202478)
    ctx->pc = 0x202430;
    entry_2023e0(rdram, ctx, runtime);
}

void entry_202458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202458 inside entry_2023e0 (0x2023e0 - 0x202478)
    ctx->pc = 0x202458;
    entry_2023e0(rdram, ctx, runtime);
}

void entry_20245c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20245c inside entry_2023e0 (0x2023e0 - 0x202478)
    ctx->pc = 0x20245c;
    entry_2023e0(rdram, ctx, runtime);
}

void entry_20252c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20252c inside entry_202508 (0x202508 - 0x20253c)
    ctx->pc = 0x20252c;
    entry_202508(rdram, ctx, runtime);
}

void entry_202550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202550 inside entry_20253c (0x20253c - 0x202660)
    ctx->pc = 0x202550;
    entry_20253c(rdram, ctx, runtime);
}

void entry_2025f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2025f8 inside entry_20253c (0x20253c - 0x202660)
    ctx->pc = 0x2025f8;
    entry_20253c(rdram, ctx, runtime);
}

void entry_202604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202604 inside entry_20253c (0x20253c - 0x202660)
    ctx->pc = 0x202604;
    entry_20253c(rdram, ctx, runtime);
}

void entry_202628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202628 inside entry_20253c (0x20253c - 0x202660)
    ctx->pc = 0x202628;
    entry_20253c(rdram, ctx, runtime);
}

void entry_20262c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20262c inside entry_20253c (0x20253c - 0x202660)
    ctx->pc = 0x20262c;
    entry_20253c(rdram, ctx, runtime);
}

void entry_202754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202754 inside sceGsSetDefClear (0x202660 - 0x202768)
    ctx->pc = 0x202754;
    sceGsSetDefClear(rdram, ctx, runtime);
}

void entry_202758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202758 inside sceGsSetDefClear (0x202660 - 0x202768)
    ctx->pc = 0x202758;
    sceGsSetDefClear(rdram, ctx, runtime);
}

void entry_202778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202778 inside memclr (0x202768 - 0x2027a0)
    ctx->pc = 0x202778;
    memclr(rdram, ctx, runtime);
}

void entry_202794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202794 inside memclr (0x202768 - 0x2027a0)
    ctx->pc = 0x202794;
    memclr(rdram, ctx, runtime);
}

void entry_2027c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2027c0 inside sceDmaGetChan (0x2027a0 - 0x2027c8)
    ctx->pc = 0x2027c0;
    sceDmaGetChan(rdram, ctx, runtime);
}

void entry_202800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202800 inside sceDmaReset (0x2027c8 - 0x202864)
    ctx->pc = 0x202800;
    sceDmaReset(rdram, ctx, runtime);
}

void entry_20282c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20282c inside sceDmaReset (0x2027c8 - 0x202864)
    ctx->pc = 0x20282c;
    sceDmaReset(rdram, ctx, runtime);
}

void entry_202890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202890 inside entry_20286c (0x20286c - 0x2028a8)
    ctx->pc = 0x202890;
    entry_20286c(rdram, ctx, runtime);
}

void entry_202900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202900 inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x202900;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_202914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202914 inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x202914;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_202928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202928 inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x202928;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_20293c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20293c inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x20293c;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_2029d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2029d8 inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x2029d8;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_2029e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2029e4 inside sceDmaPutEnv (0x2028a8 - 0x202a80)
    ctx->pc = 0x2029e4;
    sceDmaPutEnv(rdram, ctx, runtime);
}

void entry_202ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ab8 inside sceDmaSend (0x202a80 - 0x202ac8)
    ctx->pc = 0x202ab8;
    sceDmaSend(rdram, ctx, runtime);
}

void entry_202ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ae0 inside entry_202ac8 (0x202ac8 - 0x202b68)
    ctx->pc = 0x202ae0;
    entry_202ac8(rdram, ctx, runtime);
}

void entry_202b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202b00 inside entry_202ac8 (0x202ac8 - 0x202b68)
    ctx->pc = 0x202b00;
    entry_202ac8(rdram, ctx, runtime);
}

void entry_202b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202b10 inside entry_202ac8 (0x202ac8 - 0x202b68)
    ctx->pc = 0x202b10;
    entry_202ac8(rdram, ctx, runtime);
}

void entry_202b24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202b24 inside entry_202ac8 (0x202ac8 - 0x202b68)
    ctx->pc = 0x202b24;
    entry_202ac8(rdram, ctx, runtime);
}

void entry_202b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202b98 inside sceDmaRecv (0x202b68 - 0x202ba8)
    ctx->pc = 0x202b98;
    sceDmaRecv(rdram, ctx, runtime);
}

void entry_202bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202bc0 inside entry_202ba8 (0x202ba8 - 0x202c38)
    ctx->pc = 0x202bc0;
    entry_202ba8(rdram, ctx, runtime);
}

void entry_202be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202be0 inside entry_202ba8 (0x202ba8 - 0x202c38)
    ctx->pc = 0x202be0;
    entry_202ba8(rdram, ctx, runtime);
}

void entry_202bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202bf0 inside entry_202ba8 (0x202ba8 - 0x202c38)
    ctx->pc = 0x202bf0;
    entry_202ba8(rdram, ctx, runtime);
}

void entry_202c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202c6c inside sceDmaSync (0x202c38 - 0x202c98)
    ctx->pc = 0x202c6c;
    sceDmaSync(rdram, ctx, runtime);
}

void entry_202c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202c88 inside sceDmaSync (0x202c38 - 0x202c98)
    ctx->pc = 0x202c88;
    sceDmaSync(rdram, ctx, runtime);
}

void entry_202cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202cb0 inside entry_202c98 (0x202c98 - 0x202d08)
    ctx->pc = 0x202cb0;
    entry_202c98(rdram, ctx, runtime);
}

void entry_202cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202cd0 inside entry_202c98 (0x202c98 - 0x202d08)
    ctx->pc = 0x202cd0;
    entry_202c98(rdram, ctx, runtime);
}

void entry_202ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ce0 inside entry_202c98 (0x202c98 - 0x202d08)
    ctx->pc = 0x202ce0;
    entry_202c98(rdram, ctx, runtime);
}

void entry_202ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ce4 inside entry_202c98 (0x202c98 - 0x202d08)
    ctx->pc = 0x202ce4;
    entry_202c98(rdram, ctx, runtime);
}

void entry_202da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202da0 inside entry_202d84 (0x202d84 - 0x202df4)
    ctx->pc = 0x202da0;
    entry_202d84(rdram, ctx, runtime);
}

void entry_202de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202de8 inside entry_202d84 (0x202d84 - 0x202df4)
    ctx->pc = 0x202de8;
    entry_202d84(rdram, ctx, runtime);
}

void entry_202e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202e24 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202e24;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202e2c inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202e2c;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202e34 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202e34;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202e80 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202e80;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ea8 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202ea8;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202eac inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202eac;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ec8 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202ec8;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202ee8 inside entry_202e1c (0x202e1c - 0x202ef0)
    ctx->pc = 0x202ee8;
    entry_202e1c(rdram, ctx, runtime);
}

void entry_202f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202f28 inside cmd_sem_init (0x202ef0 - 0x202f44)
    ctx->pc = 0x202f28;
    cmd_sem_init(rdram, ctx, runtime);
}

void entry_202f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202f30 inside cmd_sem_init (0x202ef0 - 0x202f44)
    ctx->pc = 0x202f30;
    cmd_sem_init(rdram, ctx, runtime);
}

void entry_202f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202f74 inside entry_202f60 (0x202f60 - 0x202f88)
    ctx->pc = 0x202f74;
    entry_202f60(rdram, ctx, runtime);
}

void entry_202fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202fc0 inside entry_202fb8 (0x202fb8 - 0x202fd0)
    ctx->pc = 0x202fc0;
    entry_202fb8(rdram, ctx, runtime);
}

void entry_202fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x202fc8 inside entry_202fb8 (0x202fb8 - 0x202fd0)
    ctx->pc = 0x202fc8;
    entry_202fb8(rdram, ctx, runtime);
}

void entry_203044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203044 inside entry_203040 (0x203040 - 0x203050)
    ctx->pc = 0x203044;
    entry_203040(rdram, ctx, runtime);
}

void entry_203120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203120 inside entry_203118 (0x203118 - 0x20313c)
    ctx->pc = 0x203120;
    entry_203118(rdram, ctx, runtime);
}

void entry_203160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203160 inside entry_203158 (0x203158 - 0x203168)
    ctx->pc = 0x203160;
    entry_203158(rdram, ctx, runtime);
}

void entry_203180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203180 inside entry_203168 (0x203168 - 0x2031bc)
    ctx->pc = 0x203180;
    entry_203168(rdram, ctx, runtime);
}

void entry_203188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203188 inside entry_203168 (0x203168 - 0x2031bc)
    ctx->pc = 0x203188;
    entry_203168(rdram, ctx, runtime);
}

void entry_2031a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2031a4 inside entry_203168 (0x203168 - 0x2031bc)
    ctx->pc = 0x2031a4;
    entry_203168(rdram, ctx, runtime);
}

void entry_2031a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2031a8 inside entry_203168 (0x203168 - 0x2031bc)
    ctx->pc = 0x2031a8;
    entry_203168(rdram, ctx, runtime);
}

void entry_2031e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2031e4 inside entry_2031e0 (0x2031e0 - 0x203230)
    ctx->pc = 0x2031e4;
    entry_2031e0(rdram, ctx, runtime);
}

void entry_2031e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2031e8 inside entry_2031e0 (0x2031e0 - 0x203230)
    ctx->pc = 0x2031e8;
    entry_2031e0(rdram, ctx, runtime);
}

void entry_20320c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20320c inside entry_2031e0 (0x2031e0 - 0x203230)
    ctx->pc = 0x20320c;
    entry_2031e0(rdram, ctx, runtime);
}

void entry_203218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203218 inside entry_2031e0 (0x2031e0 - 0x203230)
    ctx->pc = 0x203218;
    entry_2031e0(rdram, ctx, runtime);
}

void entry_203254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203254 inside entry_203244 (0x203244 - 0x203284)
    ctx->pc = 0x203254;
    entry_203244(rdram, ctx, runtime);
}

void entry_2032a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2032a0 inside entry_203298 (0x203298 - 0x2032b4)
    ctx->pc = 0x2032a0;
    entry_203298(rdram, ctx, runtime);
}

void entry_2032b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2032b8 inside entry_2032b4 (0x2032b4 - 0x2032c8)
    ctx->pc = 0x2032b8;
    entry_2032b4(rdram, ctx, runtime);
}

void entry_203300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203300 inside entry_2032f4 (0x2032f4 - 0x203308)
    ctx->pc = 0x203300;
    entry_2032f4(rdram, ctx, runtime);
}

void entry_20332c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20332c inside entry_20331c (0x20331c - 0x203348)
    ctx->pc = 0x20332c;
    entry_20331c(rdram, ctx, runtime);
}

void entry_203354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203354 inside entry_203348 (0x203348 - 0x203368)
    ctx->pc = 0x203354;
    entry_203348(rdram, ctx, runtime);
}

void entry_203358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203358 inside entry_203348 (0x203348 - 0x203368)
    ctx->pc = 0x203358;
    entry_203348(rdram, ctx, runtime);
}

void entry_203398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203398 inside entry_203390 (0x203390 - 0x2033a0)
    ctx->pc = 0x203398;
    entry_203390(rdram, ctx, runtime);
}

void entry_2033b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2033b8 inside entry_2033a8 (0x2033a8 - 0x2033c4)
    ctx->pc = 0x2033b8;
    entry_2033a8(rdram, ctx, runtime);
}

void entry_2033c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2033c8 inside entry_2033c4 (0x2033c4 - 0x2033d8)
    ctx->pc = 0x2033c8;
    entry_2033c4(rdram, ctx, runtime);
}

void entry_203438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203438 inside entry_203430 (0x203430 - 0x203454)
    ctx->pc = 0x203438;
    entry_203430(rdram, ctx, runtime);
}

void entry_203478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203478 inside entry_203470 (0x203470 - 0x203480)
    ctx->pc = 0x203478;
    entry_203470(rdram, ctx, runtime);
}

void entry_203498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203498 inside entry_203480 (0x203480 - 0x2034d4)
    ctx->pc = 0x203498;
    entry_203480(rdram, ctx, runtime);
}

void entry_2034a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2034a0 inside entry_203480 (0x203480 - 0x2034d4)
    ctx->pc = 0x2034a0;
    entry_203480(rdram, ctx, runtime);
}

void entry_2034bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2034bc inside entry_203480 (0x203480 - 0x2034d4)
    ctx->pc = 0x2034bc;
    entry_203480(rdram, ctx, runtime);
}

void entry_2034c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2034c0 inside entry_203480 (0x203480 - 0x2034d4)
    ctx->pc = 0x2034c0;
    entry_203480(rdram, ctx, runtime);
}

void entry_2034fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2034fc inside entry_2034f8 (0x2034f8 - 0x203548)
    ctx->pc = 0x2034fc;
    entry_2034f8(rdram, ctx, runtime);
}

void entry_203500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203500 inside entry_2034f8 (0x2034f8 - 0x203548)
    ctx->pc = 0x203500;
    entry_2034f8(rdram, ctx, runtime);
}

void entry_203524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203524 inside entry_2034f8 (0x2034f8 - 0x203548)
    ctx->pc = 0x203524;
    entry_2034f8(rdram, ctx, runtime);
}

void entry_203530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203530 inside entry_2034f8 (0x2034f8 - 0x203548)
    ctx->pc = 0x203530;
    entry_2034f8(rdram, ctx, runtime);
}

void entry_203610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203610 inside entry_20359c (0x20359c - 0x203624)
    ctx->pc = 0x203610;
    entry_20359c(rdram, ctx, runtime);
}

void entry_203650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203650 inside entry_203644 (0x203644 - 0x20368c)
    ctx->pc = 0x203650;
    entry_203644(rdram, ctx, runtime);
}

void entry_203674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203674 inside entry_203644 (0x203644 - 0x20368c)
    ctx->pc = 0x203674;
    entry_203644(rdram, ctx, runtime);
}

void entry_2036cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2036cc inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x2036cc;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_2036d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2036d8 inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x2036d8;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_2036fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2036fc inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x2036fc;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_203748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203748 inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x203748;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_203784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203784 inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x203784;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_203788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203788 inside entry_2036b8 (0x2036b8 - 0x2037b8)
    ctx->pc = 0x203788;
    entry_2036b8(rdram, ctx, runtime);
}

void entry_2037e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2037e4 inside entry_2037c0 (0x2037c0 - 0x2037ec)
    ctx->pc = 0x2037e4;
    entry_2037c0(rdram, ctx, runtime);
}

void entry_2037f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2037f8 inside entry_2037f4 (0x2037f4 - 0x203828)
    ctx->pc = 0x2037f8;
    entry_2037f4(rdram, ctx, runtime);
}

void entry_2038c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2038c0 inside entry_2038a4 (0x2038a4 - 0x2038fc)
    ctx->pc = 0x2038c0;
    entry_2038a4(rdram, ctx, runtime);
}

void entry_2038c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2038c8 inside entry_2038a4 (0x2038a4 - 0x2038fc)
    ctx->pc = 0x2038c8;
    entry_2038a4(rdram, ctx, runtime);
}

void entry_2038e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2038e4 inside entry_2038a4 (0x2038a4 - 0x2038fc)
    ctx->pc = 0x2038e4;
    entry_2038a4(rdram, ctx, runtime);
}

void entry_2038e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2038e8 inside entry_2038a4 (0x2038a4 - 0x2038fc)
    ctx->pc = 0x2038e8;
    entry_2038a4(rdram, ctx, runtime);
}

void entry_203920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203920 inside entry_20391c (0x20391c - 0x203978)
    ctx->pc = 0x203920;
    entry_20391c(rdram, ctx, runtime);
}

void entry_203928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203928 inside entry_20391c (0x20391c - 0x203978)
    ctx->pc = 0x203928;
    entry_20391c(rdram, ctx, runtime);
}

void entry_20394c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20394c inside entry_20391c (0x20391c - 0x203978)
    ctx->pc = 0x20394c;
    entry_20391c(rdram, ctx, runtime);
}

void entry_20395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20395c inside entry_20391c (0x20391c - 0x203978)
    ctx->pc = 0x20395c;
    entry_20391c(rdram, ctx, runtime);
}

void entry_203964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203964 inside entry_20391c (0x20391c - 0x203978)
    ctx->pc = 0x203964;
    entry_20391c(rdram, ctx, runtime);
}

void entry_2039ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2039ac inside entry_2039a4 (0x2039a4 - 0x2039b8)
    ctx->pc = 0x2039ac;
    entry_2039a4(rdram, ctx, runtime);
}

void entry_2039cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2039cc inside entry_2039b8 (0x2039b8 - 0x2039dc)
    ctx->pc = 0x2039cc;
    entry_2039b8(rdram, ctx, runtime);
}

void entry_2039f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2039f4 inside entry_2039f0 (0x2039f0 - 0x203a20)
    ctx->pc = 0x2039f4;
    entry_2039f0(rdram, ctx, runtime);
}

void entry_203a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203a58 inside entry_203a48 (0x203a48 - 0x203a64)
    ctx->pc = 0x203a58;
    entry_203a48(rdram, ctx, runtime);
}

void entry_203ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203ab4 inside entry_203aac (0x203aac - 0x203ac8)
    ctx->pc = 0x203ab4;
    entry_203aac(rdram, ctx, runtime);
}

void entry_203acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203acc inside entry_203ac8 (0x203ac8 - 0x203ae8)
    ctx->pc = 0x203acc;
    entry_203ac8(rdram, ctx, runtime);
}

void entry_203b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203b10 inside sceCdGetReadPos (0x203ae8 - 0x203b18)
    ctx->pc = 0x203b10;
    sceCdGetReadPos(rdram, ctx, runtime);
}

void entry_203b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203b74 inside entry_203b68 (0x203b68 - 0x203b7c)
    ctx->pc = 0x203b74;
    entry_203b68(rdram, ctx, runtime);
}

void entry_203be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203be8 inside entry_203b7c (0x203b7c - 0x203c14)
    ctx->pc = 0x203be8;
    entry_203b7c(rdram, ctx, runtime);
}

void entry_203bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203bf4 inside entry_203b7c (0x203b7c - 0x203c14)
    ctx->pc = 0x203bf4;
    entry_203b7c(rdram, ctx, runtime);
}

void entry_203bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203bf8 inside entry_203b7c (0x203b7c - 0x203c14)
    ctx->pc = 0x203bf8;
    entry_203b7c(rdram, ctx, runtime);
}

void entry_203cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203cbc inside entry_203cb4 (0x203cb4 - 0x203cd0)
    ctx->pc = 0x203cbc;
    entry_203cb4(rdram, ctx, runtime);
}

void entry_203cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203cd4 inside entry_203cd0 (0x203cd0 - 0x203cf8)
    ctx->pc = 0x203cd4;
    entry_203cd0(rdram, ctx, runtime);
}

void entry_203d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203d1c inside entry_203d0c (0x203d0c - 0x203d4c)
    ctx->pc = 0x203d1c;
    entry_203d0c(rdram, ctx, runtime);
}

void entry_203d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203d68 inside entry_203d60 (0x203d60 - 0x203d7c)
    ctx->pc = 0x203d68;
    entry_203d60(rdram, ctx, runtime);
}

void entry_203d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203d80 inside entry_203d7c (0x203d7c - 0x203d90)
    ctx->pc = 0x203d80;
    entry_203d7c(rdram, ctx, runtime);
}

void entry_203db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203db4 inside entry_203da4 (0x203da4 - 0x203de4)
    ctx->pc = 0x203db4;
    entry_203da4(rdram, ctx, runtime);
}

void entry_203e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203e00 inside entry_203df8 (0x203df8 - 0x203e14)
    ctx->pc = 0x203e00;
    entry_203df8(rdram, ctx, runtime);
}

void entry_203e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203e18 inside entry_203e14 (0x203e14 - 0x203e28)
    ctx->pc = 0x203e18;
    entry_203e14(rdram, ctx, runtime);
}

void entry_203e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203e50 inside entry_203e40 (0x203e40 - 0x203e8c)
    ctx->pc = 0x203e50;
    entry_203e40(rdram, ctx, runtime);
}

void entry_203eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203eac inside entry_203ea0 (0x203ea0 - 0x203ec8)
    ctx->pc = 0x203eac;
    entry_203ea0(rdram, ctx, runtime);
}

void entry_203ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203ecc inside entry_203ec8 (0x203ec8 - 0x203ee0)
    ctx->pc = 0x203ecc;
    entry_203ec8(rdram, ctx, runtime);
}

void entry_203f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203f20 inside entry_203f10 (0x203f10 - 0x203f2c)
    ctx->pc = 0x203f20;
    entry_203f10(rdram, ctx, runtime);
}

void entry_203f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203f7c inside entry_203f74 (0x203f74 - 0x203fac)
    ctx->pc = 0x203f7c;
    entry_203f74(rdram, ctx, runtime);
}

void entry_203f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203f94 inside entry_203f74 (0x203f74 - 0x203fac)
    ctx->pc = 0x203f94;
    entry_203f74(rdram, ctx, runtime);
}

void entry_203fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x203fb0 inside entry_203fac (0x203fac - 0x203fd0)
    ctx->pc = 0x203fb0;
    entry_203fac(rdram, ctx, runtime);
}

void entry_204030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204030 inside entry_204028 (0x204028 - 0x204074)
    ctx->pc = 0x204030;
    entry_204028(rdram, ctx, runtime);
}

void entry_2040a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2040a4 inside entry_204094 (0x204094 - 0x2040b8)
    ctx->pc = 0x2040a4;
    entry_204094(rdram, ctx, runtime);
}

void entry_2040c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2040c0 inside entry_2040b8 (0x2040b8 - 0x2040e8)
    ctx->pc = 0x2040c0;
    entry_2040b8(rdram, ctx, runtime);
}

void entry_2040c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2040c8 inside entry_2040b8 (0x2040b8 - 0x2040e8)
    ctx->pc = 0x2040c8;
    entry_2040b8(rdram, ctx, runtime);
}

void entry_204118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204118 inside scePadInit (0x2040e8 - 0x204154)
    ctx->pc = 0x204118;
    scePadInit(rdram, ctx, runtime);
}

void entry_204120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204120 inside scePadInit (0x2040e8 - 0x204154)
    ctx->pc = 0x204120;
    scePadInit(rdram, ctx, runtime);
}

void entry_20413c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20413c inside scePadInit (0x2040e8 - 0x204154)
    ctx->pc = 0x20413c;
    scePadInit(rdram, ctx, runtime);
}

void entry_204170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204170 inside entry_204154 (0x204154 - 0x2041a8)
    ctx->pc = 0x204170;
    entry_204154(rdram, ctx, runtime);
}

void entry_204178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204178 inside entry_204154 (0x204154 - 0x2041a8)
    ctx->pc = 0x204178;
    entry_204154(rdram, ctx, runtime);
}

void entry_204194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204194 inside entry_204154 (0x204154 - 0x2041a8)
    ctx->pc = 0x204194;
    entry_204154(rdram, ctx, runtime);
}

void entry_204208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204208 inside entry_204200 (0x204200 - 0x204210)
    ctx->pc = 0x204208;
    entry_204200(rdram, ctx, runtime);
}

void entry_204248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204248 inside scePadInit2 (0x204228 - 0x2042a8)
    ctx->pc = 0x204248;
    scePadInit2(rdram, ctx, runtime);
}

void entry_2042b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2042b4 inside entry_2042a8 (0x2042a8 - 0x2042c8)
    ctx->pc = 0x2042b4;
    entry_2042a8(rdram, ctx, runtime);
}

void entry_20432c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20432c inside entry_204324 (0x204324 - 0x20437c)
    ctx->pc = 0x20432c;
    entry_204324(rdram, ctx, runtime);
}

void entry_204384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204384 inside entry_20437c (0x20437c - 0x2043bc)
    ctx->pc = 0x204384;
    entry_20437c(rdram, ctx, runtime);
}

void entry_204398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204398 inside entry_20437c (0x20437c - 0x2043bc)
    ctx->pc = 0x204398;
    entry_20437c(rdram, ctx, runtime);
}

void entry_204414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204414 inside entry_20440c (0x20440c - 0x2044b0)
    ctx->pc = 0x204414;
    entry_20440c(rdram, ctx, runtime);
}

void entry_20441c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20441c inside entry_20440c (0x20440c - 0x2044b0)
    ctx->pc = 0x20441c;
    entry_20440c(rdram, ctx, runtime);
}

void entry_20447c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20447c inside entry_20440c (0x20440c - 0x2044b0)
    ctx->pc = 0x20447c;
    entry_20440c(rdram, ctx, runtime);
}

void entry_204558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204558 inside scePadRead (0x204510 - 0x204560)
    ctx->pc = 0x204558;
    scePadRead(rdram, ctx, runtime);
}

void entry_204578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204578 inside entry_204574 (0x204574 - 0x204590)
    ctx->pc = 0x204578;
    entry_204574(rdram, ctx, runtime);
}

void entry_2045fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2045fc inside entry_2045d0 (0x2045d0 - 0x204610)
    ctx->pc = 0x2045fc;
    entry_2045d0(rdram, ctx, runtime);
}

void entry_204600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204600 inside entry_2045d0 (0x2045d0 - 0x204610)
    ctx->pc = 0x204600;
    entry_2045d0(rdram, ctx, runtime);
}

void entry_204654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204654 inside scePadSetReqState (0x204610 - 0x20465c)
    ctx->pc = 0x204654;
    scePadSetReqState(rdram, ctx, runtime);
}

void entry_204664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204664 inside entry_20465c (0x20465c - 0x204678)
    ctx->pc = 0x204664;
    entry_20465c(rdram, ctx, runtime);
}

void entry_2046bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2046bc inside entry_2046b8 (0x2046b8 - 0x2046d0)
    ctx->pc = 0x2046bc;
    entry_2046b8(rdram, ctx, runtime);
}

void entry_204760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204760 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x204760;
    entry_20471c(rdram, ctx, runtime);
}

void entry_204780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204780 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x204780;
    entry_20471c(rdram, ctx, runtime);
}

void entry_204798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204798 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x204798;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047a8 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047a8;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047b8 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047b8;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047c8 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047c8;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047d8 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047d8;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047dc inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047dc;
    entry_20471c(rdram, ctx, runtime);
}

void entry_2047e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2047e0 inside entry_20471c (0x20471c - 0x2047f8)
    ctx->pc = 0x2047e0;
    entry_20471c(rdram, ctx, runtime);
}

void entry_204888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204888 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x204888;
    entry_204844(rdram, ctx, runtime);
}

void entry_2048a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2048a0 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x2048a0;
    entry_204844(rdram, ctx, runtime);
}

void entry_2048b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2048b8 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x2048b8;
    entry_204844(rdram, ctx, runtime);
}

void entry_2048d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2048d0 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x2048d0;
    entry_204844(rdram, ctx, runtime);
}

void entry_2048e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2048e4 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x2048e4;
    entry_204844(rdram, ctx, runtime);
}

void entry_204900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204900 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x204900;
    entry_204844(rdram, ctx, runtime);
}

void entry_20490c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20490c inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x20490c;
    entry_204844(rdram, ctx, runtime);
}

void entry_204918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204918 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x204918;
    entry_204844(rdram, ctx, runtime);
}

void entry_20491c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20491c inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x20491c;
    entry_204844(rdram, ctx, runtime);
}

void entry_204920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204920 inside entry_204844 (0x204844 - 0x204930)
    ctx->pc = 0x204920;
    entry_204844(rdram, ctx, runtime);
}

void entry_2049a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2049a8 inside entry_204998 (0x204998 - 0x2049c4)
    ctx->pc = 0x2049a8;
    entry_204998(rdram, ctx, runtime);
}

void entry_2049cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2049cc inside entry_2049c4 (0x2049c4 - 0x2049e8)
    ctx->pc = 0x2049cc;
    entry_2049c4(rdram, ctx, runtime);
}

void entry_204a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204a48 inside entry_204a0c (0x204a0c - 0x204a84)
    ctx->pc = 0x204a48;
    entry_204a0c(rdram, ctx, runtime);
}

void entry_204a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204a90 inside entry_204a84 (0x204a84 - 0x204aa8)
    ctx->pc = 0x204a90;
    entry_204a84(rdram, ctx, runtime);
}

void entry_204ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204ae8 inside scePadSetActAlign (0x204aa8 - 0x204b34)
    ctx->pc = 0x204ae8;
    scePadSetActAlign(rdram, ctx, runtime);
}

void entry_204b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204b44 inside entry_204b34 (0x204b34 - 0x204b60)
    ctx->pc = 0x204b44;
    entry_204b34(rdram, ctx, runtime);
}

void entry_204b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204b68 inside entry_204b60 (0x204b60 - 0x204b80)
    ctx->pc = 0x204b68;
    entry_204b60(rdram, ctx, runtime);
}

void entry_204bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204bdc inside entry_204bc0 (0x204bc0 - 0x204c38)
    ctx->pc = 0x204bdc;
    entry_204bc0(rdram, ctx, runtime);
}

void entry_204c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204c28 inside entry_204bc0 (0x204bc0 - 0x204c38)
    ctx->pc = 0x204c28;
    entry_204bc0(rdram, ctx, runtime);
}

void entry_204cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204cac inside entry_204c9c (0x204c9c - 0x204cc8)
    ctx->pc = 0x204cac;
    entry_204c9c(rdram, ctx, runtime);
}

void entry_204cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204cd0 inside entry_204cc8 (0x204cc8 - 0x204ce8)
    ctx->pc = 0x204cd0;
    entry_204cc8(rdram, ctx, runtime);
}

void entry_204d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204d38 inside entry_204d28 (0x204d28 - 0x204d48)
    ctx->pc = 0x204d38;
    entry_204d28(rdram, ctx, runtime);
}

void entry_204d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204d88 inside scePadEnterPressMode (0x204d48 - 0x204d90)
    ctx->pc = 0x204d88;
    scePadEnterPressMode(rdram, ctx, runtime);
}

void entry_204e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204e0c inside entry_204e00 (0x204e00 - 0x204e20)
    ctx->pc = 0x204e0c;
    entry_204e00(rdram, ctx, runtime);
}

void entry_204e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204e30 inside _sceSDC (0x204e20 - 0x204ec8)
    ctx->pc = 0x204e30;
    _sceSDC(rdram, ctx, runtime);
}

void entry_204e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204e6c inside _sceSDC (0x204e20 - 0x204ec8)
    ctx->pc = 0x204e6c;
    _sceSDC(rdram, ctx, runtime);
}

void entry_204ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204ea8 inside _sceSDC (0x204e20 - 0x204ec8)
    ctx->pc = 0x204ea8;
    _sceSDC(rdram, ctx, runtime);
}

void entry_204f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204f30 inside entry_204f14 (0x204f14 - 0x204f68)
    ctx->pc = 0x204f30;
    entry_204f14(rdram, ctx, runtime);
}

void entry_204fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204fb8 inside atanf (0x204f68 - 0x205048)
    ctx->pc = 0x204fb8;
    atanf(rdram, ctx, runtime);
}

void entry_204fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204fd4 inside atanf (0x204f68 - 0x205048)
    ctx->pc = 0x204fd4;
    atanf(rdram, ctx, runtime);
}

void entry_204fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x204fec inside atanf (0x204f68 - 0x205048)
    ctx->pc = 0x204fec;
    atanf(rdram, ctx, runtime);
}

void entry_205040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205040 inside atanf (0x204f68 - 0x205048)
    ctx->pc = 0x205040;
    atanf(rdram, ctx, runtime);
}

void entry_2050a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2050a0 inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x2050a0;
    entry_205048(rdram, ctx, runtime);
}

void entry_2050c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2050c4 inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x2050c4;
    entry_205048(rdram, ctx, runtime);
}

void entry_205108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205108 inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x205108;
    entry_205048(rdram, ctx, runtime);
}

void entry_20511c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20511c inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x20511c;
    entry_205048(rdram, ctx, runtime);
}

void entry_205120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205120 inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x205120;
    entry_205048(rdram, ctx, runtime);
}

void entry_2051bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2051bc inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x2051bc;
    entry_205048(rdram, ctx, runtime);
}

void entry_2051fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2051fc inside entry_205048 (0x205048 - 0x205210)
    ctx->pc = 0x2051fc;
    entry_205048(rdram, ctx, runtime);
}

void entry_205250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205250 inside entry_205248 (0x205248 - 0x205274)
    ctx->pc = 0x205250;
    entry_205248(rdram, ctx, runtime);
}

void entry_20526c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20526c inside entry_205248 (0x205248 - 0x205274)
    ctx->pc = 0x20526c;
    entry_205248(rdram, ctx, runtime);
}

void entry_20529c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20529c inside entry_205274 (0x205274 - 0x2052b4)
    ctx->pc = 0x20529c;
    entry_205274(rdram, ctx, runtime);
}

void entry_2052ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2052ac inside entry_205274 (0x205274 - 0x2052b4)
    ctx->pc = 0x2052ac;
    entry_205274(rdram, ctx, runtime);
}

void entry_2052bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2052bc inside entry_2052b4 (0x2052b4 - 0x2052cc)
    ctx->pc = 0x2052bc;
    entry_2052b4(rdram, ctx, runtime);
}

void entry_2052d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2052d4 inside entry_2052cc (0x2052cc - 0x2052dc)
    ctx->pc = 0x2052d4;
    entry_2052cc(rdram, ctx, runtime);
}

void entry_2052e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2052e4 inside entry_2052dc (0x2052dc - 0x2052ec)
    ctx->pc = 0x2052e4;
    entry_2052dc(rdram, ctx, runtime);
}

void entry_2052f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2052f0 inside entry_2052ec (0x2052ec - 0x2052f8)
    ctx->pc = 0x2052f0;
    entry_2052ec(rdram, ctx, runtime);
}

void entry_205370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205370 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x205370;
    floorf(rdram, ctx, runtime);
}

void entry_205384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205384 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x205384;
    floorf(rdram, ctx, runtime);
}

void entry_205398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205398 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x205398;
    floorf(rdram, ctx, runtime);
}

void entry_2053a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2053a0 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x2053a0;
    floorf(rdram, ctx, runtime);
}

void entry_2053d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2053d8 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x2053d8;
    floorf(rdram, ctx, runtime);
}

void entry_2053e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2053e0 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x2053e0;
    floorf(rdram, ctx, runtime);
}

void entry_2053f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2053f0 inside floorf (0x205318 - 0x205400)
    ctx->pc = 0x2053f0;
    floorf(rdram, ctx, runtime);
}

void entry_205440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205440 inside entry_205438 (0x205438 - 0x205464)
    ctx->pc = 0x205440;
    entry_205438(rdram, ctx, runtime);
}

void entry_20545c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20545c inside entry_205438 (0x205438 - 0x205464)
    ctx->pc = 0x20545c;
    entry_205438(rdram, ctx, runtime);
}

void entry_20548c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20548c inside entry_205464 (0x205464 - 0x2054a8)
    ctx->pc = 0x20548c;
    entry_205464(rdram, ctx, runtime);
}

void entry_20549c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20549c inside entry_205464 (0x205464 - 0x2054a8)
    ctx->pc = 0x20549c;
    entry_205464(rdram, ctx, runtime);
}

void entry_2054b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2054b0 inside entry_2054a8 (0x2054a8 - 0x2054bc)
    ctx->pc = 0x2054b0;
    entry_2054a8(rdram, ctx, runtime);
}

void entry_2054c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2054c4 inside entry_2054bc (0x2054bc - 0x2054d0)
    ctx->pc = 0x2054c4;
    entry_2054bc(rdram, ctx, runtime);
}

void entry_2054d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2054d8 inside entry_2054d0 (0x2054d0 - 0x2054e0)
    ctx->pc = 0x2054d8;
    entry_2054d0(rdram, ctx, runtime);
}

void entry_2054e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2054e4 inside entry_2054e0 (0x2054e0 - 0x2054f0)
    ctx->pc = 0x2054e4;
    entry_2054e0(rdram, ctx, runtime);
}

void entry_2054e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2054e8 inside entry_2054e0 (0x2054e0 - 0x2054f0)
    ctx->pc = 0x2054e8;
    entry_2054e0(rdram, ctx, runtime);
}

void entry_205528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205528 inside tanf (0x2054f0 - 0x20554c)
    ctx->pc = 0x205528;
    tanf(rdram, ctx, runtime);
}

void entry_205544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205544 inside tanf (0x2054f0 - 0x20554c)
    ctx->pc = 0x205544;
    tanf(rdram, ctx, runtime);
}

void entry_205564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205564 inside entry_20554c (0x20554c - 0x20556c)
    ctx->pc = 0x205564;
    entry_20554c(rdram, ctx, runtime);
}

void entry_20561c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20561c inside entry_205614 (0x205614 - 0x205624)
    ctx->pc = 0x20561c;
    entry_205614(rdram, ctx, runtime);
}

void entry_205630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205630 inside entry_205624 (0x205624 - 0x205640)
    ctx->pc = 0x205630;
    entry_205624(rdram, ctx, runtime);
}

void entry_205648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205648 inside entry_205640 (0x205640 - 0x205650)
    ctx->pc = 0x205648;
    entry_205640(rdram, ctx, runtime);
}

void entry_205658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205658 inside entry_205650 (0x205650 - 0x205678)
    ctx->pc = 0x205658;
    entry_205650(rdram, ctx, runtime);
}

void entry_20565c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20565c inside entry_205650 (0x205650 - 0x205678)
    ctx->pc = 0x20565c;
    entry_205650(rdram, ctx, runtime);
}

void entry_205660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205660 inside entry_205650 (0x205650 - 0x205678)
    ctx->pc = 0x205660;
    entry_205650(rdram, ctx, runtime);
}

void entry_20571c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20571c inside entry_205714 (0x205714 - 0x205724)
    ctx->pc = 0x20571c;
    entry_205714(rdram, ctx, runtime);
}

void entry_205730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205730 inside entry_205724 (0x205724 - 0x205740)
    ctx->pc = 0x205730;
    entry_205724(rdram, ctx, runtime);
}

void entry_205748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205748 inside entry_205740 (0x205740 - 0x205750)
    ctx->pc = 0x205748;
    entry_205740(rdram, ctx, runtime);
}

void entry_205758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205758 inside entry_205750 (0x205750 - 0x205778)
    ctx->pc = 0x205758;
    entry_205750(rdram, ctx, runtime);
}

void entry_20575c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20575c inside entry_205750 (0x205750 - 0x205778)
    ctx->pc = 0x20575c;
    entry_205750(rdram, ctx, runtime);
}

void entry_205760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205760 inside entry_205750 (0x205750 - 0x205778)
    ctx->pc = 0x205760;
    entry_205750(rdram, ctx, runtime);
}

void entry_205844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205844 inside entry_20583c (0x20583c - 0x20584c)
    ctx->pc = 0x205844;
    entry_20583c(rdram, ctx, runtime);
}

void entry_205858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205858 inside entry_20584c (0x20584c - 0x205868)
    ctx->pc = 0x205858;
    entry_20584c(rdram, ctx, runtime);
}

void entry_205870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205870 inside entry_205868 (0x205868 - 0x205878)
    ctx->pc = 0x205870;
    entry_205868(rdram, ctx, runtime);
}

void entry_205880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205880 inside entry_205878 (0x205878 - 0x2058a0)
    ctx->pc = 0x205880;
    entry_205878(rdram, ctx, runtime);
}

void entry_205884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205884 inside entry_205878 (0x205878 - 0x2058a0)
    ctx->pc = 0x205884;
    entry_205878(rdram, ctx, runtime);
}

void entry_205888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205888 inside entry_205878 (0x205878 - 0x2058a0)
    ctx->pc = 0x205888;
    entry_205878(rdram, ctx, runtime);
}

void entry_205950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205950 inside entry_205948 (0x205948 - 0x205974)
    ctx->pc = 0x205950;
    entry_205948(rdram, ctx, runtime);
}

void entry_20595c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20595c inside entry_205948 (0x205948 - 0x205974)
    ctx->pc = 0x20595c;
    entry_205948(rdram, ctx, runtime);
}

void entry_20597c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20597c inside entry_205974 (0x205974 - 0x205984)
    ctx->pc = 0x20597c;
    entry_205974(rdram, ctx, runtime);
}

void entry_205990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205990 inside entry_205984 (0x205984 - 0x2059a0)
    ctx->pc = 0x205990;
    entry_205984(rdram, ctx, runtime);
}

void entry_2059a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2059a8 inside entry_2059a0 (0x2059a0 - 0x2059b0)
    ctx->pc = 0x2059a8;
    entry_2059a0(rdram, ctx, runtime);
}

void entry_2059b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2059b8 inside entry_2059b0 (0x2059b0 - 0x2059e0)
    ctx->pc = 0x2059b8;
    entry_2059b0(rdram, ctx, runtime);
}

void entry_2059bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2059bc inside entry_2059b0 (0x2059b0 - 0x2059e0)
    ctx->pc = 0x2059bc;
    entry_2059b0(rdram, ctx, runtime);
}

void entry_2059c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2059c0 inside entry_2059b0 (0x2059b0 - 0x2059e0)
    ctx->pc = 0x2059c0;
    entry_2059b0(rdram, ctx, runtime);
}

void entry_205a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205a38 inside entry_205a1c (0x205a1c - 0x205a54)
    ctx->pc = 0x205a38;
    entry_205a1c(rdram, ctx, runtime);
}

void entry_205a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205a40 inside entry_205a1c (0x205a1c - 0x205a54)
    ctx->pc = 0x205a40;
    entry_205a1c(rdram, ctx, runtime);
}

void entry_205a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205a70 inside entry_205a54 (0x205a54 - 0x205a80)
    ctx->pc = 0x205a70;
    entry_205a54(rdram, ctx, runtime);
}

void entry_205a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205a84 inside entry_205a80 (0x205a80 - 0x205aac)
    ctx->pc = 0x205a84;
    entry_205a80(rdram, ctx, runtime);
}

void entry_205ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205ab4 inside entry_205aac (0x205aac - 0x205ad0)
    ctx->pc = 0x205ab4;
    entry_205aac(rdram, ctx, runtime);
}

void entry_205ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205ac8 inside entry_205aac (0x205aac - 0x205ad0)
    ctx->pc = 0x205ac8;
    entry_205aac(rdram, ctx, runtime);
}

void entry_205ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205ad8 inside entry_205ad0 (0x205ad0 - 0x205ae0)
    ctx->pc = 0x205ad8;
    entry_205ad0(rdram, ctx, runtime);
}

void entry_205ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205ae4 inside entry_205ae0 (0x205ae0 - 0x205afc)
    ctx->pc = 0x205ae4;
    entry_205ae0(rdram, ctx, runtime);
}

void entry_205aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205aec inside entry_205ae0 (0x205ae0 - 0x205afc)
    ctx->pc = 0x205aec;
    entry_205ae0(rdram, ctx, runtime);
}

void entry_205b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205b04 inside entry_205afc (0x205afc - 0x205b0c)
    ctx->pc = 0x205b04;
    entry_205afc(rdram, ctx, runtime);
}

void entry_205bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205bb0 inside entry_205b94 (0x205b94 - 0x205bc0)
    ctx->pc = 0x205bb0;
    entry_205b94(rdram, ctx, runtime);
}

void entry_205bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205bc4 inside entry_205bc0 (0x205bc0 - 0x205bec)
    ctx->pc = 0x205bc4;
    entry_205bc0(rdram, ctx, runtime);
}

void entry_205bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205bf4 inside entry_205bec (0x205bec - 0x205c10)
    ctx->pc = 0x205bf4;
    entry_205bec(rdram, ctx, runtime);
}

void entry_205c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c08 inside entry_205bec (0x205bec - 0x205c10)
    ctx->pc = 0x205c08;
    entry_205bec(rdram, ctx, runtime);
}

void entry_205c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c18 inside entry_205c10 (0x205c10 - 0x205c20)
    ctx->pc = 0x205c18;
    entry_205c10(rdram, ctx, runtime);
}

void entry_205c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c24 inside entry_205c20 (0x205c20 - 0x205c3c)
    ctx->pc = 0x205c24;
    entry_205c20(rdram, ctx, runtime);
}

void entry_205c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c2c inside entry_205c20 (0x205c20 - 0x205c3c)
    ctx->pc = 0x205c2c;
    entry_205c20(rdram, ctx, runtime);
}

void entry_205c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c44 inside entry_205c3c (0x205c3c - 0x205c4c)
    ctx->pc = 0x205c44;
    entry_205c3c(rdram, ctx, runtime);
}

void entry_205c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c54 inside entry_205c4c (0x205c4c - 0x205c78)
    ctx->pc = 0x205c54;
    entry_205c4c(rdram, ctx, runtime);
}

void entry_205c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c58 inside entry_205c4c (0x205c4c - 0x205c78)
    ctx->pc = 0x205c58;
    entry_205c4c(rdram, ctx, runtime);
}

void entry_205c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205c5c inside entry_205c4c (0x205c4c - 0x205c78)
    ctx->pc = 0x205c5c;
    entry_205c4c(rdram, ctx, runtime);
}

void entry_205d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205d38 inside entry_205d28 (0x205d28 - 0x205d50)
    ctx->pc = 0x205d38;
    entry_205d28(rdram, ctx, runtime);
}

void entry_205d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205d48 inside entry_205d28 (0x205d28 - 0x205d50)
    ctx->pc = 0x205d48;
    entry_205d28(rdram, ctx, runtime);
}

void entry_205d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205d68 inside entry_205d60 (0x205d60 - 0x205da4)
    ctx->pc = 0x205d68;
    entry_205d60(rdram, ctx, runtime);
}

void entry_205de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205de0 inside entry_205dd8 (0x205dd8 - 0x205de8)
    ctx->pc = 0x205de0;
    entry_205dd8(rdram, ctx, runtime);
}

void entry_205e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205e3c inside entry_205e28 (0x205e28 - 0x205e4c)
    ctx->pc = 0x205e3c;
    entry_205e28(rdram, ctx, runtime);
}

void entry_205e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205e50 inside entry_205e4c (0x205e4c - 0x205e68)
    ctx->pc = 0x205e50;
    entry_205e4c(rdram, ctx, runtime);
}

void entry_205e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205e70 inside entry_205e68 (0x205e68 - 0x205e78)
    ctx->pc = 0x205e70;
    entry_205e68(rdram, ctx, runtime);
}

void entry_205e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205e80 inside entry_205e78 (0x205e78 - 0x205e88)
    ctx->pc = 0x205e80;
    entry_205e78(rdram, ctx, runtime);
}

void entry_205efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205efc inside entry_205ee8 (0x205ee8 - 0x205f20)
    ctx->pc = 0x205efc;
    entry_205ee8(rdram, ctx, runtime);
}

void entry_205f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205f08 inside entry_205ee8 (0x205ee8 - 0x205f20)
    ctx->pc = 0x205f08;
    entry_205ee8(rdram, ctx, runtime);
}

void entry_205f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205f28 inside entry_205f20 (0x205f20 - 0x205f30)
    ctx->pc = 0x205f28;
    entry_205f20(rdram, ctx, runtime);
}

void entry_205f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205f38 inside entry_205f30 (0x205f30 - 0x205f54)
    ctx->pc = 0x205f38;
    entry_205f30(rdram, ctx, runtime);
}

void entry_205ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x205ff4 inside entry_205fdc (0x205fdc - 0x20600c)
    ctx->pc = 0x205ff4;
    entry_205fdc(rdram, ctx, runtime);
}

void entry_206080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206080 inside entry_20607c (0x20607c - 0x2060a8)
    ctx->pc = 0x206080;
    entry_20607c(rdram, ctx, runtime);
}

void entry_206084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206084 inside entry_20607c (0x20607c - 0x2060a8)
    ctx->pc = 0x206084;
    entry_20607c(rdram, ctx, runtime);
}

void entry_20608c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20608c inside entry_20607c (0x20607c - 0x2060a8)
    ctx->pc = 0x20608c;
    entry_20607c(rdram, ctx, runtime);
}

void entry_2060fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2060fc inside entry_2060e8 (0x2060e8 - 0x20610c)
    ctx->pc = 0x2060fc;
    entry_2060e8(rdram, ctx, runtime);
}

void entry_206114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206114 inside entry_20610c (0x20610c - 0x20611c)
    ctx->pc = 0x206114;
    entry_20610c(rdram, ctx, runtime);
}

void entry_206120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206120 inside entry_20611c (0x20611c - 0x206138)
    ctx->pc = 0x206120;
    entry_20611c(rdram, ctx, runtime);
}

void entry_206124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206124 inside entry_20611c (0x20611c - 0x206138)
    ctx->pc = 0x206124;
    entry_20611c(rdram, ctx, runtime);
}

void entry_206128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206128 inside entry_20611c (0x20611c - 0x206138)
    ctx->pc = 0x206128;
    entry_20611c(rdram, ctx, runtime);
}

void entry_206140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206140 inside entry_206138 (0x206138 - 0x206148)
    ctx->pc = 0x206140;
    entry_206138(rdram, ctx, runtime);
}

void entry_206150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206150 inside entry_206148 (0x206148 - 0x206180)
    ctx->pc = 0x206150;
    entry_206148(rdram, ctx, runtime);
}

void entry_206154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206154 inside entry_206148 (0x206148 - 0x206180)
    ctx->pc = 0x206154;
    entry_206148(rdram, ctx, runtime);
}

void entry_206158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206158 inside entry_206148 (0x206148 - 0x206180)
    ctx->pc = 0x206158;
    entry_206148(rdram, ctx, runtime);
}

void entry_20620c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20620c inside entry_2061f4 (0x2061f4 - 0x206230)
    ctx->pc = 0x20620c;
    entry_2061f4(rdram, ctx, runtime);
}

void entry_206218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206218 inside entry_2061f4 (0x2061f4 - 0x206230)
    ctx->pc = 0x206218;
    entry_2061f4(rdram, ctx, runtime);
}

void entry_206238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206238 inside entry_206230 (0x206230 - 0x206240)
    ctx->pc = 0x206238;
    entry_206230(rdram, ctx, runtime);
}

void entry_20624c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20624c inside entry_206240 (0x206240 - 0x20625c)
    ctx->pc = 0x20624c;
    entry_206240(rdram, ctx, runtime);
}

void entry_206264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206264 inside entry_20625c (0x20625c - 0x20626c)
    ctx->pc = 0x206264;
    entry_20625c(rdram, ctx, runtime);
}

void entry_206274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206274 inside entry_20626c (0x20626c - 0x206298)
    ctx->pc = 0x206274;
    entry_20626c(rdram, ctx, runtime);
}

void entry_206278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206278 inside entry_20626c (0x20626c - 0x206298)
    ctx->pc = 0x206278;
    entry_20626c(rdram, ctx, runtime);
}

void entry_20627c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20627c inside entry_20626c (0x20626c - 0x206298)
    ctx->pc = 0x20627c;
    entry_20626c(rdram, ctx, runtime);
}

void entry_2062f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2062f0 inside FUN_00206298 (0x206298 - 0x206538)
    ctx->pc = 0x2062f0;
    FUN_00206298(rdram, ctx, runtime);
}

void entry_206314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206314 inside FUN_00206298 (0x206298 - 0x206538)
    ctx->pc = 0x206314;
    FUN_00206298(rdram, ctx, runtime);
}

void entry_206348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206348 inside FUN_00206298 (0x206298 - 0x206538)
    ctx->pc = 0x206348;
    FUN_00206298(rdram, ctx, runtime);
}

void entry_20644c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20644c inside FUN_00206298 (0x206298 - 0x206538)
    ctx->pc = 0x20644c;
    FUN_00206298(rdram, ctx, runtime);
}

void entry_206578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206578 inside entry_206538 (0x206538 - 0x206598)
    ctx->pc = 0x206578;
    entry_206538(rdram, ctx, runtime);
}

void entry_2066b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2066b0 inside entry_206598 (0x206598 - 0x2066c8)
    ctx->pc = 0x2066b0;
    entry_206598(rdram, ctx, runtime);
}

void entry_2066b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2066b4 inside entry_206598 (0x206598 - 0x2066c8)
    ctx->pc = 0x2066b4;
    entry_206598(rdram, ctx, runtime);
}

void entry_2066b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2066b8 inside entry_206598 (0x206598 - 0x2066c8)
    ctx->pc = 0x2066b8;
    entry_206598(rdram, ctx, runtime);
}

void entry_206728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206728 inside __ieee754_asinf (0x2066c8 - 0x206888)
    ctx->pc = 0x206728;
    fn___ieee754_asinf(rdram, ctx, runtime);
}

void entry_20674c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20674c inside __ieee754_asinf (0x2066c8 - 0x206888)
    ctx->pc = 0x20674c;
    fn___ieee754_asinf(rdram, ctx, runtime);
}

void entry_20679c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20679c inside __ieee754_asinf (0x2066c8 - 0x206888)
    ctx->pc = 0x20679c;
    fn___ieee754_asinf(rdram, ctx, runtime);
}

void entry_206880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206880 inside __ieee754_asinf (0x2066c8 - 0x206888)
    ctx->pc = 0x206880;
    fn___ieee754_asinf(rdram, ctx, runtime);
}

void entry_2069bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2069bc inside entry_20696c (0x20696c - 0x206a68)
    ctx->pc = 0x2069bc;
    entry_20696c(rdram, ctx, runtime);
}

void entry_206a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206a38 inside entry_20696c (0x20696c - 0x206a68)
    ctx->pc = 0x206a38;
    entry_20696c(rdram, ctx, runtime);
}

void entry_206a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206a44 inside entry_20696c (0x20696c - 0x206a68)
    ctx->pc = 0x206a44;
    entry_20696c(rdram, ctx, runtime);
}

void entry_206a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206a4c inside entry_20696c (0x20696c - 0x206a68)
    ctx->pc = 0x206a4c;
    entry_20696c(rdram, ctx, runtime);
}

void entry_206ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ab0 inside __ieee754_atan2f (0x206a68 - 0x206acc)
    ctx->pc = 0x206ab0;
    fn___ieee754_atan2f(rdram, ctx, runtime);
}

void entry_206abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206abc inside __ieee754_atan2f (0x206a68 - 0x206acc)
    ctx->pc = 0x206abc;
    fn___ieee754_atan2f(rdram, ctx, runtime);
}

void entry_206ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ad4 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206ad4;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b08 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b08;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b10 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b10;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b18 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b18;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b40 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b40;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b70 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b70;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b88 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b88;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206b9c inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206b9c;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206bb0 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206bb0;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206bc4 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206bc4;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206bd8 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206bd8;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206bf8 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206bf8;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c10 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c10;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c1c inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c1c;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c28 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c28;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c3c inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c3c;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c50 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c50;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c78 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c78;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206c88 inside entry_206acc (0x206acc - 0x206ca0)
    ctx->pc = 0x206c88;
    entry_206acc(rdram, ctx, runtime);
}

void entry_206cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206cac inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206cac;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206cb0 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206cb0;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206cd0 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206cd0;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ce0 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206ce0;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ce8 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206ce8;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206cf4 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206cf4;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206d1c inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206d1c;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206d40 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206d40;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206d44 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206d44;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206d48 inside entry_206ca8 (0x206ca8 - 0x206d50)
    ctx->pc = 0x206d48;
    entry_206ca8(rdram, ctx, runtime);
}

void entry_206da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206da0 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206da0;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206dc0 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206dc0;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206dd4 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206dd4;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ddc inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ddc;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206df8 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206df8;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e18 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e18;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e3c inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e3c;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e40 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e40;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e44 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e44;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e68 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e68;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e8c inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e8c;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e98 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e98;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206e9c inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206e9c;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ebc inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ebc;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ec4 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ec4;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ee8 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ee8;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ef0 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ef0;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206ef8 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206ef8;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206f0c inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206f0c;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206f48 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206f48;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206f68 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206f68;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206f88 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206f88;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206f90 inside __ieee754_fmodf (0x206d50 - 0x206fa0)
    ctx->pc = 0x206f90;
    fn___ieee754_fmodf(rdram, ctx, runtime);
}

void entry_206fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x206fd8 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x206fd8;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207000 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x207000;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207018 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x207018;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207038 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x207038;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_2070e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2070e0 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x2070e0;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_20710c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20710c inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x20710c;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207144 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x207144;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_20723c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20723c inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x20723c;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207278 inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x207278;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_20728c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20728c inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x20728c;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_2072bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2072bc inside __ieee754_logf (0x206fa0 - 0x2072c8)
    ctx->pc = 0x2072bc;
    fn___ieee754_logf(rdram, ctx, runtime);
}

void entry_207310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207310 inside FUN_002072c8 (0x2072c8 - 0x2073b0)
    ctx->pc = 0x207310;
    FUN_002072c8(rdram, ctx, runtime);
}

void entry_207338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207338 inside FUN_002072c8 (0x2072c8 - 0x2073b0)
    ctx->pc = 0x207338;
    FUN_002072c8(rdram, ctx, runtime);
}

void entry_207350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207350 inside FUN_002072c8 (0x2072c8 - 0x2073b0)
    ctx->pc = 0x207350;
    FUN_002072c8(rdram, ctx, runtime);
}

void entry_207370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207370 inside FUN_002072c8 (0x2072c8 - 0x2073b0)
    ctx->pc = 0x207370;
    FUN_002072c8(rdram, ctx, runtime);
}

void entry_2073e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2073e8 inside entry_2073b0 (0x2073b0 - 0x2073f8)
    ctx->pc = 0x2073e8;
    entry_2073b0(rdram, ctx, runtime);
}

void entry_2073ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2073ec inside entry_2073b0 (0x2073b0 - 0x2073f8)
    ctx->pc = 0x2073ec;
    entry_2073b0(rdram, ctx, runtime);
}

void entry_207458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207458 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x207458;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_20747c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20747c inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x20747c;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_2074a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2074a0 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x2074a0;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_2074d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2074d4 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x2074d4;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_2074d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2074d8 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x2074d8;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_2074f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2074f0 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x2074f0;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_20750c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20750c inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x20750c;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_207520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207520 inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x207520;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_20754c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20754c inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x20754c;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_20755c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20755c inside FUN_002073f8 (0x2073f8 - 0x207574)
    ctx->pc = 0x20755c;
    FUN_002073f8(rdram, ctx, runtime);
}

void entry_20757c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20757c inside entry_207574 (0x207574 - 0x207584)
    ctx->pc = 0x20757c;
    entry_207574(rdram, ctx, runtime);
}

void entry_2075a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2075a4 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x2075a4;
    entry_207584(rdram, ctx, runtime);
}

void entry_2075c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2075c0 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x2075c0;
    entry_207584(rdram, ctx, runtime);
}

void entry_2075f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2075f4 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x2075f4;
    entry_207584(rdram, ctx, runtime);
}

void entry_2075fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2075fc inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x2075fc;
    entry_207584(rdram, ctx, runtime);
}

void entry_207604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207604 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207604;
    entry_207584(rdram, ctx, runtime);
}

void entry_20762c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20762c inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x20762c;
    entry_207584(rdram, ctx, runtime);
}

void entry_207650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207650 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207650;
    entry_207584(rdram, ctx, runtime);
}

void entry_207658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207658 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207658;
    entry_207584(rdram, ctx, runtime);
}

void entry_207670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207670 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207670;
    entry_207584(rdram, ctx, runtime);
}

void entry_20767c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20767c inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x20767c;
    entry_207584(rdram, ctx, runtime);
}

void entry_207718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207718 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207718;
    entry_207584(rdram, ctx, runtime);
}

void entry_207740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207740 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207740;
    entry_207584(rdram, ctx, runtime);
}

void entry_20776c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20776c inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x20776c;
    entry_207584(rdram, ctx, runtime);
}

void entry_207790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207790 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207790;
    entry_207584(rdram, ctx, runtime);
}

void entry_207988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207988 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207988;
    entry_207584(rdram, ctx, runtime);
}

void entry_2079ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2079ac inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x2079ac;
    entry_207584(rdram, ctx, runtime);
}

void entry_207a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207a10 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207a10;
    entry_207584(rdram, ctx, runtime);
}

void entry_207a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207a50 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207a50;
    entry_207584(rdram, ctx, runtime);
}

void entry_207a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207a88 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207a88;
    entry_207584(rdram, ctx, runtime);
}

void entry_207a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207a98 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207a98;
    entry_207584(rdram, ctx, runtime);
}

void entry_207aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207aa0 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207aa0;
    entry_207584(rdram, ctx, runtime);
}

void entry_207aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207aa4 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207aa4;
    entry_207584(rdram, ctx, runtime);
}

void entry_207b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207b20 inside entry_207584 (0x207584 - 0x207c44)
    ctx->pc = 0x207b20;
    entry_207584(rdram, ctx, runtime);
}

void entry_207c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207c50 inside entry_207c44 (0x207c44 - 0x207c88)
    ctx->pc = 0x207c50;
    entry_207c44(rdram, ctx, runtime);
}

void entry_207c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207c58 inside entry_207c44 (0x207c44 - 0x207c88)
    ctx->pc = 0x207c58;
    entry_207c44(rdram, ctx, runtime);
}

void entry_207c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207c5c inside entry_207c44 (0x207c44 - 0x207c88)
    ctx->pc = 0x207c5c;
    entry_207c44(rdram, ctx, runtime);
}

void entry_207c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207c60 inside entry_207c44 (0x207c44 - 0x207c88)
    ctx->pc = 0x207c60;
    entry_207c44(rdram, ctx, runtime);
}

void entry_207cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207cd8 inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207cd8;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207d2c inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207d2c;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207d4c inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207d4c;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207d64 inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207d64;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207d9c inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207d9c;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207dbc inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207dbc;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207dd4 inside FUN_00207c88 (0x207c88 - 0x207dec)
    ctx->pc = 0x207dd4;
    FUN_00207c88(rdram, ctx, runtime);
}

void entry_207e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207e7c inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207e7c;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207e80 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207e80;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207f38 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207f38;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207f3c inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207f3c;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207f58 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207f58;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207f78 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207f78;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207fa0 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207fa0;
    entry_207dec(rdram, ctx, runtime);
}

void entry_207fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x207fe8 inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x207fe8;
    entry_207dec(rdram, ctx, runtime);
}

void entry_20800c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20800c inside entry_207dec (0x207dec - 0x208024)
    ctx->pc = 0x20800c;
    entry_207dec(rdram, ctx, runtime);
}

void entry_20803c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20803c inside entry_208024 (0x208024 - 0x208068)
    ctx->pc = 0x20803c;
    entry_208024(rdram, ctx, runtime);
}

void entry_20804c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20804c inside entry_208024 (0x208024 - 0x208068)
    ctx->pc = 0x20804c;
    entry_208024(rdram, ctx, runtime);
}

void entry_208050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208050 inside entry_208024 (0x208024 - 0x208068)
    ctx->pc = 0x208050;
    entry_208024(rdram, ctx, runtime);
}

void entry_208090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208090 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208090;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_2080c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2080c4 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x2080c4;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_2080cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2080cc inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x2080cc;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_2080e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2080e8 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x2080e8;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_20810c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20810c inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x20810c;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_208114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208114 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208114;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_208118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208118 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208118;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_208150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208150 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208150;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_208170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208170 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208170;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_208184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208184 inside __ieee754_sqrtf (0x208068 - 0x2081a0)
    ctx->pc = 0x208184;
    fn___ieee754_sqrtf(rdram, ctx, runtime);
}

void entry_2081f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2081f0 inside __kernel_cosf (0x2081a0 - 0x2082f8)
    ctx->pc = 0x2081f0;
    fn___kernel_cosf(rdram, ctx, runtime);
}

void entry_2082a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2082a0 inside __kernel_cosf (0x2081a0 - 0x2082f8)
    ctx->pc = 0x2082a0;
    fn___kernel_cosf(rdram, ctx, runtime);
}

void entry_2082bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2082bc inside __kernel_cosf (0x2081a0 - 0x2082f8)
    ctx->pc = 0x2082bc;
    fn___kernel_cosf(rdram, ctx, runtime);
}

void entry_2082c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2082c0 inside __kernel_cosf (0x2081a0 - 0x2082f8)
    ctx->pc = 0x2082c0;
    fn___kernel_cosf(rdram, ctx, runtime);
}

void entry_2083a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2083a8 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x2083a8;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_2083d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2083d0 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x2083d0;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_2083d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2083d4 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x2083d4;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_2083ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2083ec inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x2083ec;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208408 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208408;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208418 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208418;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208438 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208438;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208474 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208474;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208480 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208480;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208490 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208490;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208494 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208494;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_2084c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2084c8 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x2084c8;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208504 inside __kernel_rem_pio2f (0x2082f8 - 0x208510)
    ctx->pc = 0x208504;
    fn___kernel_rem_pio2f(rdram, ctx, runtime);
}

void entry_208590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208590 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208590;
    entry_208528(rdram, ctx, runtime);
}

void entry_2085b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2085b0 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x2085b0;
    entry_208528(rdram, ctx, runtime);
}

void entry_2085cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2085cc inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x2085cc;
    entry_208528(rdram, ctx, runtime);
}

void entry_2085f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2085f8 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x2085f8;
    entry_208528(rdram, ctx, runtime);
}

void entry_208610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208610 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208610;
    entry_208528(rdram, ctx, runtime);
}

void entry_208614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208614 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208614;
    entry_208528(rdram, ctx, runtime);
}

void entry_208618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208618 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208618;
    entry_208528(rdram, ctx, runtime);
}

void entry_208624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208624 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208624;
    entry_208528(rdram, ctx, runtime);
}

void entry_208644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208644 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208644;
    entry_208528(rdram, ctx, runtime);
}

void entry_20865c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20865c inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x20865c;
    entry_208528(rdram, ctx, runtime);
}

void entry_208670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208670 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208670;
    entry_208528(rdram, ctx, runtime);
}

void entry_208674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208674 inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x208674;
    entry_208528(rdram, ctx, runtime);
}

void entry_20867c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20867c inside entry_208528 (0x208528 - 0x20869c)
    ctx->pc = 0x20867c;
    entry_208528(rdram, ctx, runtime);
}

void entry_2086a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2086a0 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2086a0;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2086c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2086c8 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2086c8;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2086e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2086e4 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2086e4;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208708 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208708;
    entry_20869c(rdram, ctx, runtime);
}

void entry_20872c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20872c inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x20872c;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208734 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208734;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208750 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208750;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208790 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208790;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2087cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2087cc inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2087cc;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2087d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2087d8 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2087d8;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2087f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2087f0 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2087f0;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2087fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2087fc inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x2087fc;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208820 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208820;
    entry_20869c(rdram, ctx, runtime);
}

void entry_208844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208844 inside entry_20869c (0x20869c - 0x20884c)
    ctx->pc = 0x208844;
    entry_20869c(rdram, ctx, runtime);
}

void entry_2088b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2088b4 inside entry_20884c (0x20884c - 0x2088dc)
    ctx->pc = 0x2088b4;
    entry_20884c(rdram, ctx, runtime);
}

void entry_2088c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2088c8 inside entry_20884c (0x20884c - 0x2088dc)
    ctx->pc = 0x2088c8;
    entry_20884c(rdram, ctx, runtime);
}

void entry_2088cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2088cc inside entry_20884c (0x20884c - 0x2088dc)
    ctx->pc = 0x2088cc;
    entry_20884c(rdram, ctx, runtime);
}

void entry_208900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208900 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208900;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208928 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208928;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208938 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208938;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208960 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208960;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089a8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089a8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089ac inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089ac;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089b0 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089b0;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089b8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089b8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089c8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089c8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_2089e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2089e8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x2089e8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a00 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a00;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a18 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a18;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a38 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a38;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a50 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a50;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a68 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a68;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a8c inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a8c;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208a94 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208a94;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208aac inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208aac;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208ab8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208ab8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208ad8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208ad8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208af4 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208af4;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208b08 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208b08;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208b48 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208b48;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208b58 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208b58;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208b98 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208b98;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208bb0 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208bb0;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208bd8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208bd8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208be0 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208be0;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208bf8 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208bf8;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208c0c inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208c0c;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208c10 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208c10;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208c14 inside entry_2088dc (0x2088dc - 0x208c48)
    ctx->pc = 0x208c14;
    entry_2088dc(rdram, ctx, runtime);
}

void entry_208c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208c90 inside __kernel_sinf (0x208c48 - 0x208d50)
    ctx->pc = 0x208c90;
    fn___kernel_sinf(rdram, ctx, runtime);
}

void entry_208d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208d14 inside __kernel_sinf (0x208c48 - 0x208d50)
    ctx->pc = 0x208d14;
    fn___kernel_sinf(rdram, ctx, runtime);
}

void entry_208dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208dc8 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208dc8;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208dec inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208dec;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208df4 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208df4;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208df8 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208df8;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208e18 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208e18;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208e44 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208e44;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208f58 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208f58;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208fd8 inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208fd8;
    entry_208da8(rdram, ctx, runtime);
}

void entry_208fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x208fdc inside entry_208da8 (0x208da8 - 0x208fe8)
    ctx->pc = 0x208fdc;
    entry_208da8(rdram, ctx, runtime);
}

void entry_209108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209108 inside entry_2090e0 (0x2090e0 - 0x209174)
    ctx->pc = 0x209108;
    entry_2090e0(rdram, ctx, runtime);
}

void entry_209140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209140 inside entry_2090e0 (0x2090e0 - 0x209174)
    ctx->pc = 0x209140;
    entry_2090e0(rdram, ctx, runtime);
}

void entry_209154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209154 inside entry_2090e0 (0x2090e0 - 0x209174)
    ctx->pc = 0x209154;
    entry_2090e0(rdram, ctx, runtime);
}

void entry_20917c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20917c inside entry_209174 (0x209174 - 0x2091e4)
    ctx->pc = 0x20917c;
    entry_209174(rdram, ctx, runtime);
}

void entry_209194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209194 inside entry_209174 (0x209174 - 0x2091e4)
    ctx->pc = 0x209194;
    entry_209174(rdram, ctx, runtime);
}

void entry_20919c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20919c inside entry_209174 (0x209174 - 0x2091e4)
    ctx->pc = 0x20919c;
    entry_209174(rdram, ctx, runtime);
}

void entry_2091b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2091b8 inside entry_209174 (0x209174 - 0x2091e4)
    ctx->pc = 0x2091b8;
    entry_209174(rdram, ctx, runtime);
}

void entry_2091f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2091f4 inside entry_2091f0 (0x2091f0 - 0x209210)
    ctx->pc = 0x2091f4;
    entry_2091f0(rdram, ctx, runtime);
}

void entry_2092a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2092a8 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x2092a8;
    scalbnf(rdram, ctx, runtime);
}

void entry_2092f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2092f0 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x2092f0;
    scalbnf(rdram, ctx, runtime);
}

void entry_209308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209308 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x209308;
    scalbnf(rdram, ctx, runtime);
}

void entry_209340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209340 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x209340;
    scalbnf(rdram, ctx, runtime);
}

void entry_209364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209364 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x209364;
    scalbnf(rdram, ctx, runtime);
}

void entry_209370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209370 inside scalbnf (0x209260 - 0x20937c)
    ctx->pc = 0x209370;
    scalbnf(rdram, ctx, runtime);
}

void entry_209384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209384 inside entry_20937c (0x20937c - 0x2093c0)
    ctx->pc = 0x209384;
    entry_20937c(rdram, ctx, runtime);
}

void entry_2093b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2093b0 inside entry_20937c (0x20937c - 0x2093c0)
    ctx->pc = 0x2093b0;
    entry_20937c(rdram, ctx, runtime);
}

void entry_2093b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2093b8 inside entry_20937c (0x20937c - 0x2093c0)
    ctx->pc = 0x2093b8;
    entry_20937c(rdram, ctx, runtime);
}

void entry_20943c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20943c inside entry_209438 (0x209438 - 0x20944c)
    ctx->pc = 0x20943c;
    entry_209438(rdram, ctx, runtime);
}

void entry_209470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209470 inside entry_20945c (0x20945c - 0x2094a8)
    ctx->pc = 0x209470;
    entry_20945c(rdram, ctx, runtime);
}

void entry_209478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209478 inside entry_20945c (0x20945c - 0x2094a8)
    ctx->pc = 0x209478;
    entry_20945c(rdram, ctx, runtime);
}

void entry_209494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209494 inside entry_20945c (0x20945c - 0x2094a8)
    ctx->pc = 0x209494;
    entry_20945c(rdram, ctx, runtime);
}

void entry_2094c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2094c0 inside entry_2094bc (0x2094bc - 0x209514)
    ctx->pc = 0x2094c0;
    entry_2094bc(rdram, ctx, runtime);
}

void entry_2094dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2094dc inside entry_2094bc (0x2094bc - 0x209514)
    ctx->pc = 0x2094dc;
    entry_2094bc(rdram, ctx, runtime);
}

void entry_209534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209534 inside entry_209520 (0x209520 - 0x209548)
    ctx->pc = 0x209534;
    entry_209520(rdram, ctx, runtime);
}

void entry_209554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209554 inside entry_209548 (0x209548 - 0x20956c)
    ctx->pc = 0x209554;
    entry_209548(rdram, ctx, runtime);
}

void entry_209578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209578 inside entry_20956c (0x20956c - 0x2095b0)
    ctx->pc = 0x209578;
    entry_20956c(rdram, ctx, runtime);
}

void entry_20957c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20957c inside entry_20956c (0x20956c - 0x2095b0)
    ctx->pc = 0x20957c;
    entry_20956c(rdram, ctx, runtime);
}

void entry_209600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209600 inside entry_2095f0 (0x2095f0 - 0x209618)
    ctx->pc = 0x209600;
    entry_2095f0(rdram, ctx, runtime);
}

void entry_209620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209620 inside entry_209618 (0x209618 - 0x20963c)
    ctx->pc = 0x209620;
    entry_209618(rdram, ctx, runtime);
}

void entry_209634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209634 inside entry_209618 (0x209618 - 0x20963c)
    ctx->pc = 0x209634;
    entry_209618(rdram, ctx, runtime);
}

void entry_209644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209644 inside entry_20963c (0x20963c - 0x209658)
    ctx->pc = 0x209644;
    entry_20963c(rdram, ctx, runtime);
}

void entry_2096b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2096b0 inside entry_209698 (0x209698 - 0x2096b8)
    ctx->pc = 0x2096b0;
    entry_209698(rdram, ctx, runtime);
}

void entry_2096bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2096bc inside entry_2096b8 (0x2096b8 - 0x2096e8)
    ctx->pc = 0x2096bc;
    entry_2096b8(rdram, ctx, runtime);
}

void entry_209710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209710 inside entry_2096f8 (0x2096f8 - 0x209720)
    ctx->pc = 0x209710;
    entry_2096f8(rdram, ctx, runtime);
}

void entry_209750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209750 inside entry_209740 (0x209740 - 0x209768)
    ctx->pc = 0x209750;
    entry_209740(rdram, ctx, runtime);
}

void entry_209770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209770 inside entry_209768 (0x209768 - 0x20979c)
    ctx->pc = 0x209770;
    entry_209768(rdram, ctx, runtime);
}

void entry_2097b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2097b4 inside entry_20979c (0x20979c - 0x2097bc)
    ctx->pc = 0x2097b4;
    entry_20979c(rdram, ctx, runtime);
}

void entry_2097c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2097c0 inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x2097c0;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_209808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209808 inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x209808;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_209828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209828 inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x209828;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_20982c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20982c inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x20982c;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_209848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209848 inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x209848;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_209868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209868 inside entry_2097bc (0x2097bc - 0x209870)
    ctx->pc = 0x209868;
    entry_2097bc(rdram, ctx, runtime);
}

void entry_2098bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2098bc inside entry_2098ac (0x2098ac - 0x2098d4)
    ctx->pc = 0x2098bc;
    entry_2098ac(rdram, ctx, runtime);
}

void entry_2098dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2098dc inside entry_2098d4 (0x2098d4 - 0x209904)
    ctx->pc = 0x2098dc;
    entry_2098d4(rdram, ctx, runtime);
}

void entry_209958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209958 inside entry_209940 (0x209940 - 0x209960)
    ctx->pc = 0x209958;
    entry_209940(rdram, ctx, runtime);
}

void entry_209964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209964 inside entry_209960 (0x209960 - 0x209990)
    ctx->pc = 0x209964;
    entry_209960(rdram, ctx, runtime);
}

void entry_2099d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2099d8 inside entry_2099c8 (0x2099c8 - 0x2099f0)
    ctx->pc = 0x2099d8;
    entry_2099c8(rdram, ctx, runtime);
}

void entry_2099f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x2099f8 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x2099f8;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209a18 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x209a18;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209a44 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x209a44;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209a68 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x209a68;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209a90 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x209a90;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209a94 inside entry_2099f0 (0x2099f0 - 0x209a9c)
    ctx->pc = 0x209a94;
    entry_2099f0(rdram, ctx, runtime);
}

void entry_209adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209adc inside entry_209ac4 (0x209ac4 - 0x209ae4)
    ctx->pc = 0x209adc;
    entry_209ac4(rdram, ctx, runtime);
}

void entry_209ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209ae8 inside entry_209ae4 (0x209ae4 - 0x209b10)
    ctx->pc = 0x209ae8;
    entry_209ae4(rdram, ctx, runtime);
}

void entry_209bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209bc0 inside wait_for_sif_rpc_done_2QMARK (0x209b80 - 0x209bcc)
    ctx->pc = 0x209bc0;
    wait_for_sif_rpc_done_2QMARK(rdram, ctx, runtime);
}

void entry_209be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209be8 inside entry_209bcc (0x209bcc - 0x209bf0)
    ctx->pc = 0x209be8;
    entry_209bcc(rdram, ctx, runtime);
}

void entry_209c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c00 inside entry_209bf8 (0x209bf8 - 0x209c38)
    ctx->pc = 0x209c00;
    entry_209bf8(rdram, ctx, runtime);
}

void entry_209c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c10 inside entry_209bf8 (0x209bf8 - 0x209c38)
    ctx->pc = 0x209c10;
    entry_209bf8(rdram, ctx, runtime);
}

void entry_209c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c2c inside entry_209bf8 (0x209bf8 - 0x209c38)
    ctx->pc = 0x209c2c;
    entry_209bf8(rdram, ctx, runtime);
}

void entry_209c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c3c inside entry_209c38 (0x209c38 - 0x209cb8)
    ctx->pc = 0x209c3c;
    entry_209c38(rdram, ctx, runtime);
}

void entry_209c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c7c inside entry_209c38 (0x209c38 - 0x209cb8)
    ctx->pc = 0x209c7c;
    entry_209c38(rdram, ctx, runtime);
}

void entry_209c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209c98 inside entry_209c38 (0x209c38 - 0x209cb8)
    ctx->pc = 0x209c98;
    entry_209c38(rdram, ctx, runtime);
}

void entry_209cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209cac inside entry_209c38 (0x209c38 - 0x209cb8)
    ctx->pc = 0x209cac;
    entry_209c38(rdram, ctx, runtime);
}

void entry_209d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d10 inside entry_209d00 (0x209d00 - 0x209d28)
    ctx->pc = 0x209d10;
    entry_209d00(rdram, ctx, runtime);
}

void entry_209d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d30 inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d30;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d58 inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d58;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d5c inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d5c;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d70 inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d70;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d78 inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d78;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d8c inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d8c;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209d94 inside entry_209d28 (0x209d28 - 0x209dbc)
    ctx->pc = 0x209d94;
    entry_209d28(rdram, ctx, runtime);
}

void entry_209e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209e04 inside entry_209dec (0x209dec - 0x209e0c)
    ctx->pc = 0x209e04;
    entry_209dec(rdram, ctx, runtime);
}

void entry_209e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209e10 inside entry_209e0c (0x209e0c - 0x209e48)
    ctx->pc = 0x209e10;
    entry_209e0c(rdram, ctx, runtime);
}

void entry_209ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209ea4 inside entry_209e94 (0x209e94 - 0x209ebc)
    ctx->pc = 0x209ea4;
    entry_209e94(rdram, ctx, runtime);
}

void entry_209ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209ec4 inside entry_209ebc (0x209ebc - 0x209ee0)
    ctx->pc = 0x209ec4;
    entry_209ebc(rdram, ctx, runtime);
}

void entry_209ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209ed8 inside entry_209ebc (0x209ebc - 0x209ee0)
    ctx->pc = 0x209ed8;
    entry_209ebc(rdram, ctx, runtime);
}

void entry_209ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209ee8 inside entry_209ee0 (0x209ee0 - 0x209f10)
    ctx->pc = 0x209ee8;
    entry_209ee0(rdram, ctx, runtime);
}

void entry_209f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209f68 inside entry_209f50 (0x209f50 - 0x209f70)
    ctx->pc = 0x209f68;
    entry_209f50(rdram, ctx, runtime);
}

void entry_209f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209f74 inside entry_209f70 (0x209f70 - 0x209fa8)
    ctx->pc = 0x209f74;
    entry_209f70(rdram, ctx, runtime);
}

void entry_209fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x209fe0 inside entry_209fd0 (0x209fd0 - 0x209ff8)
    ctx->pc = 0x209fe0;
    entry_209fd0(rdram, ctx, runtime);
}

void entry_20a000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a000 inside entry_209ff8 (0x209ff8 - 0x20a034)
    ctx->pc = 0x20a000;
    entry_209ff8(rdram, ctx, runtime);
}

void entry_20a04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a04c inside entry_20a034 (0x20a034 - 0x20a054)
    ctx->pc = 0x20a04c;
    entry_20a034(rdram, ctx, runtime);
}

void entry_20a058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a058 inside entry_20a054 (0x20a054 - 0x20a078)
    ctx->pc = 0x20a058;
    entry_20a054(rdram, ctx, runtime);
}

void entry_20a0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a0bc inside entry_20a0ac (0x20a0ac - 0x20a0d4)
    ctx->pc = 0x20a0bc;
    entry_20a0ac(rdram, ctx, runtime);
}

void entry_20a0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a0dc inside entry_20a0d4 (0x20a0d4 - 0x20a0f8)
    ctx->pc = 0x20a0dc;
    entry_20a0d4(rdram, ctx, runtime);
}

void entry_20a0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a0f0 inside entry_20a0d4 (0x20a0d4 - 0x20a0f8)
    ctx->pc = 0x20a0f0;
    entry_20a0d4(rdram, ctx, runtime);
}

void entry_20a100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a100 inside entry_20a0f8 (0x20a0f8 - 0x20a11c)
    ctx->pc = 0x20a100;
    entry_20a0f8(rdram, ctx, runtime);
}

void entry_20a164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a164 inside entry_20a14c (0x20a14c - 0x20a16c)
    ctx->pc = 0x20a164;
    entry_20a14c(rdram, ctx, runtime);
}

void entry_20a170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a170 inside entry_20a16c (0x20a16c - 0x20a190)
    ctx->pc = 0x20a170;
    entry_20a16c(rdram, ctx, runtime);
}

void entry_20a1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a1ec inside _type2id (0x20a190 - 0x20a220)
    ctx->pc = 0x20a1ec;
    _type2id(rdram, ctx, runtime);
}

void entry_20a1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a1f4 inside _type2id (0x20a190 - 0x20a220)
    ctx->pc = 0x20a1f4;
    _type2id(rdram, ctx, runtime);
}

void entry_20a1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a1f8 inside _type2id (0x20a190 - 0x20a220)
    ctx->pc = 0x20a1f8;
    _type2id(rdram, ctx, runtime);
}

void entry_20a200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a200 inside _type2id (0x20a190 - 0x20a220)
    ctx->pc = 0x20a200;
    _type2id(rdram, ctx, runtime);
}

void entry_20a20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a20c inside _type2id (0x20a190 - 0x20a220)
    ctx->pc = 0x20a20c;
    _type2id(rdram, ctx, runtime);
}

void entry_20a2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a2a0 inside entry_20a280 (0x20a280 - 0x20a304)
    ctx->pc = 0x20a2a0;
    entry_20a280(rdram, ctx, runtime);
}

void entry_20a2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a2d4 inside entry_20a280 (0x20a280 - 0x20a304)
    ctx->pc = 0x20a2d4;
    entry_20a280(rdram, ctx, runtime);
}

void entry_20a2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a2f0 inside entry_20a280 (0x20a280 - 0x20a304)
    ctx->pc = 0x20a2f0;
    entry_20a280(rdram, ctx, runtime);
}

void entry_20a2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a2f8 inside entry_20a280 (0x20a280 - 0x20a304)
    ctx->pc = 0x20a2f8;
    entry_20a280(rdram, ctx, runtime);
}

void entry_20a2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a2fc inside entry_20a280 (0x20a280 - 0x20a304)
    ctx->pc = 0x20a2fc;
    entry_20a280(rdram, ctx, runtime);
}

void entry_20a328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a328 inside entry_20a31c (0x20a31c - 0x20a334)
    ctx->pc = 0x20a328;
    entry_20a31c(rdram, ctx, runtime);
}

void entry_20a380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a380 inside entry_20a374 (0x20a374 - 0x20a38c)
    ctx->pc = 0x20a380;
    entry_20a374(rdram, ctx, runtime);
}

void entry_20a3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a3b8 inside entry_20a38c (0x20a38c - 0x20a404)
    ctx->pc = 0x20a3b8;
    entry_20a38c(rdram, ctx, runtime);
}

void entry_20a3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a3e8 inside entry_20a38c (0x20a38c - 0x20a404)
    ctx->pc = 0x20a3e8;
    entry_20a38c(rdram, ctx, runtime);
}

void entry_20a448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a448 inside entry_20a444 (0x20a444 - 0x20a46c)
    ctx->pc = 0x20a448;
    entry_20a444(rdram, ctx, runtime);
}

void entry_20a460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a460 inside entry_20a444 (0x20a444 - 0x20a46c)
    ctx->pc = 0x20a460;
    entry_20a444(rdram, ctx, runtime);
}

void entry_20a464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a464 inside entry_20a444 (0x20a444 - 0x20a46c)
    ctx->pc = 0x20a464;
    entry_20a444(rdram, ctx, runtime);
}

void entry_20a4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a4c0 inside entry_20a494 (0x20a494 - 0x20a4d8)
    ctx->pc = 0x20a4c0;
    entry_20a494(rdram, ctx, runtime);
}

void entry_20a4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a4c8 inside entry_20a494 (0x20a494 - 0x20a4d8)
    ctx->pc = 0x20a4c8;
    entry_20a494(rdram, ctx, runtime);
}

void entry_20a4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a4e4 inside entry_20a4d8 (0x20a4d8 - 0x20a518)
    ctx->pc = 0x20a4e4;
    entry_20a4d8(rdram, ctx, runtime);
}

void entry_20a5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a5a0 inside entry_20a57c (0x20a57c - 0x20a630)
    ctx->pc = 0x20a5a0;
    entry_20a57c(rdram, ctx, runtime);
}

void entry_20a5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a5c4 inside entry_20a57c (0x20a57c - 0x20a630)
    ctx->pc = 0x20a5c4;
    entry_20a57c(rdram, ctx, runtime);
}

void entry_20a604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a604 inside entry_20a57c (0x20a57c - 0x20a630)
    ctx->pc = 0x20a604;
    entry_20a57c(rdram, ctx, runtime);
}

void entry_20a708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a708 inside entry_20a6d8 (0x20a6d8 - 0x20a710)
    ctx->pc = 0x20a708;
    entry_20a6d8(rdram, ctx, runtime);
}

void entry_20a720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a720 inside entry_20a710 (0x20a710 - 0x20a72c)
    ctx->pc = 0x20a720;
    entry_20a710(rdram, ctx, runtime);
}

void entry_20a754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a754 inside entry_20a74c (0x20a74c - 0x20a780)
    ctx->pc = 0x20a754;
    entry_20a74c(rdram, ctx, runtime);
}

void entry_20a758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a758 inside entry_20a74c (0x20a74c - 0x20a780)
    ctx->pc = 0x20a758;
    entry_20a74c(rdram, ctx, runtime);
}

void entry_20a7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a7b8 inside entry_20a7ac (0x20a7ac - 0x20a7c4)
    ctx->pc = 0x20a7b8;
    entry_20a7ac(rdram, ctx, runtime);
}

void entry_20a7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20a7c8 inside entry_20a7c4 (0x20a7c4 - 0x20a7d0)
    ctx->pc = 0x20a7c8;
    entry_20a7c4(rdram, ctx, runtime);
}

void entry_20aa2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20aa2c inside entry_20a9fc (0x20a9fc - 0x20aa40)
    ctx->pc = 0x20aa2c;
    entry_20a9fc(rdram, ctx, runtime);
}

void entry_20aab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20aab8 inside entry_20aa88 (0x20aa88 - 0x20aacc)
    ctx->pc = 0x20aab8;
    entry_20aa88(rdram, ctx, runtime);
}

void entry_20ab88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ab88 inside entry_20ab80 (0x20ab80 - 0x20ab98)
    ctx->pc = 0x20ab88;
    entry_20ab80(rdram, ctx, runtime);
}

void entry_20abd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20abd8 inside entry_20abc8 (0x20abc8 - 0x20abe0)
    ctx->pc = 0x20abd8;
    entry_20abc8(rdram, ctx, runtime);
}

void entry_20abf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20abf8 inside entry_20abe0 (0x20abe0 - 0x20ac20)
    ctx->pc = 0x20abf8;
    entry_20abe0(rdram, ctx, runtime);
}

void entry_20abfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20abfc inside entry_20abe0 (0x20abe0 - 0x20ac20)
    ctx->pc = 0x20abfc;
    entry_20abe0(rdram, ctx, runtime);
}

void entry_20ac24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ac24 inside entry_20ac20 (0x20ac20 - 0x20ac58)
    ctx->pc = 0x20ac24;
    entry_20ac20(rdram, ctx, runtime);
}

void entry_20ac70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ac70 inside entry_20ac58 (0x20ac58 - 0x20ac80)
    ctx->pc = 0x20ac70;
    entry_20ac58(rdram, ctx, runtime);
}

void entry_20ac88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ac88 inside entry_20ac80 (0x20ac80 - 0x20ad14)
    ctx->pc = 0x20ac88;
    entry_20ac80(rdram, ctx, runtime);
}

void entry_20acf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20acf8 inside entry_20ac80 (0x20ac80 - 0x20ad14)
    ctx->pc = 0x20acf8;
    entry_20ac80(rdram, ctx, runtime);
}

void entry_20ad00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ad00 inside entry_20ac80 (0x20ac80 - 0x20ad14)
    ctx->pc = 0x20ad00;
    entry_20ac80(rdram, ctx, runtime);
}

void entry_20ad2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ad2c inside entry_20ad14 (0x20ad14 - 0x20ad40)
    ctx->pc = 0x20ad2c;
    entry_20ad14(rdram, ctx, runtime);
}

void entry_20ad48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ad48 inside entry_20ad40 (0x20ad40 - 0x20ad6c)
    ctx->pc = 0x20ad48;
    entry_20ad40(rdram, ctx, runtime);
}

void entry_20ad70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ad70 inside entry_20ad6c (0x20ad6c - 0x20ada0)
    ctx->pc = 0x20ad70;
    entry_20ad6c(rdram, ctx, runtime);
}

void entry_20ad74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ad74 inside entry_20ad6c (0x20ad6c - 0x20ada0)
    ctx->pc = 0x20ad74;
    entry_20ad6c(rdram, ctx, runtime);
}

void entry_20aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20aea4 inside entry_20ae9c (0x20ae9c - 0x20aec0)
    ctx->pc = 0x20aea4;
    entry_20ae9c(rdram, ctx, runtime);
}

void entry_20b02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b02c inside entry_20b014 (0x20b014 - 0x20b048)
    ctx->pc = 0x20b02c;
    entry_20b014(rdram, ctx, runtime);
}

void entry_20b120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b120 inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b120;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b12c inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b12c;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b138 inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b138;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b144 inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b144;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b150 inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b150;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b15c inside sceMpegClearRefBuff (0x20b110 - 0x20b168)
    ctx->pc = 0x20b15c;
    sceMpegClearRefBuff(rdram, ctx, runtime);
}

void entry_20b1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b1d0 inside entry_20b1cc (0x20b1cc - 0x20b1e0)
    ctx->pc = 0x20b1d0;
    entry_20b1cc(rdram, ctx, runtime);
}

void entry_20b1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b1d4 inside entry_20b1cc (0x20b1cc - 0x20b1e0)
    ctx->pc = 0x20b1d4;
    entry_20b1cc(rdram, ctx, runtime);
}

void entry_20b28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b28c inside _alalcAlloc (0x20b278 - 0x20b2d4)
    ctx->pc = 0x20b28c;
    _alalcAlloc(rdram, ctx, runtime);
}

void entry_20b2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b2c8 inside _alalcAlloc (0x20b278 - 0x20b2d4)
    ctx->pc = 0x20b2c8;
    _alalcAlloc(rdram, ctx, runtime);
}

void entry_20b2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b2d8 inside entry_20b2d4 (0x20b2d4 - 0x20b2e8)
    ctx->pc = 0x20b2d8;
    entry_20b2d4(rdram, ctx, runtime);
}

void entry_20b338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b338 inside entry_20b330 (0x20b330 - 0x20b350)
    ctx->pc = 0x20b338;
    entry_20b330(rdram, ctx, runtime);
}

void entry_20b340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b340 inside entry_20b330 (0x20b330 - 0x20b350)
    ctx->pc = 0x20b340;
    entry_20b330(rdram, ctx, runtime);
}

void entry_20b348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b348 inside entry_20b330 (0x20b330 - 0x20b350)
    ctx->pc = 0x20b348;
    entry_20b330(rdram, ctx, runtime);
}

void entry_20b378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b378 inside entry_20b350 (0x20b350 - 0x20b3a0)
    ctx->pc = 0x20b378;
    entry_20b350(rdram, ctx, runtime);
}

void entry_20b420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b420 inside entry_20b410 (0x20b410 - 0x20b458)
    ctx->pc = 0x20b420;
    entry_20b410(rdram, ctx, runtime);
}

void entry_20b43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b43c inside entry_20b410 (0x20b410 - 0x20b458)
    ctx->pc = 0x20b43c;
    entry_20b410(rdram, ctx, runtime);
}

void entry_20b490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b490 inside _decodeOrSkipFrame (0x20b458 - 0x20b4b0)
    ctx->pc = 0x20b490;
    _decodeOrSkipFrame(rdram, ctx, runtime);
}

void entry_20b4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b4a8 inside _decodeOrSkipFrame (0x20b458 - 0x20b4b0)
    ctx->pc = 0x20b4a8;
    _decodeOrSkipFrame(rdram, ctx, runtime);
}

void entry_20b4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b4c4 inside entry_20b4c0 (0x20b4c0 - 0x20b4d4)
    ctx->pc = 0x20b4c4;
    entry_20b4c0(rdram, ctx, runtime);
}

void entry_20b4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b4cc inside entry_20b4c0 (0x20b4c0 - 0x20b4d4)
    ctx->pc = 0x20b4cc;
    entry_20b4c0(rdram, ctx, runtime);
}

void entry_20b51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b51c inside entry_20b4f4 (0x20b4f4 - 0x20b570)
    ctx->pc = 0x20b51c;
    entry_20b4f4(rdram, ctx, runtime);
}

void entry_20b550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b550 inside entry_20b4f4 (0x20b4f4 - 0x20b570)
    ctx->pc = 0x20b550;
    entry_20b4f4(rdram, ctx, runtime);
}

void entry_20b5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b5a0 inside entry_20b598 (0x20b598 - 0x20b5a8)
    ctx->pc = 0x20b5a0;
    entry_20b598(rdram, ctx, runtime);
}

void entry_20b5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b5ac inside entry_20b5a8 (0x20b5a8 - 0x20b5b8)
    ctx->pc = 0x20b5ac;
    entry_20b5a8(rdram, ctx, runtime);
}

void entry_20b5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b5f8 inside _decodeOrSkipField (0x20b5b8 - 0x20b61c)
    ctx->pc = 0x20b5f8;
    _decodeOrSkipField(rdram, ctx, runtime);
}

void entry_20b600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b600 inside _decodeOrSkipField (0x20b5b8 - 0x20b61c)
    ctx->pc = 0x20b600;
    _decodeOrSkipField(rdram, ctx, runtime);
}

void entry_20b614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b614 inside _decodeOrSkipField (0x20b5b8 - 0x20b61c)
    ctx->pc = 0x20b614;
    _decodeOrSkipField(rdram, ctx, runtime);
}

void entry_20b638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b638 inside entry_20b634 (0x20b634 - 0x20b644)
    ctx->pc = 0x20b638;
    entry_20b634(rdram, ctx, runtime);
}

void entry_20b63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b63c inside entry_20b634 (0x20b634 - 0x20b644)
    ctx->pc = 0x20b63c;
    entry_20b634(rdram, ctx, runtime);
}

void entry_20b660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b660 inside entry_20b654 (0x20b654 - 0x20b684)
    ctx->pc = 0x20b660;
    entry_20b654(rdram, ctx, runtime);
}

void entry_20b6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b6a8 inside entry_20b6a4 (0x20b6a4 - 0x20b6b8)
    ctx->pc = 0x20b6a8;
    entry_20b6a4(rdram, ctx, runtime);
}

void entry_20b6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b6ac inside entry_20b6a4 (0x20b6a4 - 0x20b6b8)
    ctx->pc = 0x20b6ac;
    entry_20b6a4(rdram, ctx, runtime);
}

void entry_20b6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b6f4 inside entry_20b6f0 (0x20b6f0 - 0x20b718)
    ctx->pc = 0x20b6f4;
    entry_20b6f0(rdram, ctx, runtime);
}

void entry_20b768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b768 inside entry_20b750 (0x20b750 - 0x20b790)
    ctx->pc = 0x20b768;
    entry_20b750(rdram, ctx, runtime);
}

void entry_20b76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b76c inside entry_20b750 (0x20b750 - 0x20b790)
    ctx->pc = 0x20b76c;
    entry_20b750(rdram, ctx, runtime);
}

void entry_20b780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b780 inside entry_20b750 (0x20b750 - 0x20b790)
    ctx->pc = 0x20b780;
    entry_20b750(rdram, ctx, runtime);
}

void entry_20b7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b7c0 inside entry_20b7b8 (0x20b7b8 - 0x20b7e0)
    ctx->pc = 0x20b7c0;
    entry_20b7b8(rdram, ctx, runtime);
}

void entry_20b7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b7e8 inside entry_20b7e0 (0x20b7e0 - 0x20b7f8)
    ctx->pc = 0x20b7e8;
    entry_20b7e0(rdram, ctx, runtime);
}

void entry_20b7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b7fc inside entry_20b7f8 (0x20b7f8 - 0x20b810)
    ctx->pc = 0x20b7fc;
    entry_20b7f8(rdram, ctx, runtime);
}

void entry_20b9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b9b8 inside entry_20b9b0 (0x20b9b0 - 0x20b9c0)
    ctx->pc = 0x20b9b8;
    entry_20b9b0(rdram, ctx, runtime);
}

void entry_20b9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20b9c4 inside entry_20b9c0 (0x20b9c0 - 0x20b9d0)
    ctx->pc = 0x20b9c4;
    entry_20b9c0(rdram, ctx, runtime);
}

void entry_20ba98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ba98 inside entry_20ba90 (0x20ba90 - 0x20baac)
    ctx->pc = 0x20ba98;
    entry_20ba90(rdram, ctx, runtime);
}

void entry_20bab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bab0 inside entry_20baac (0x20baac - 0x20bab8)
    ctx->pc = 0x20bab0;
    entry_20baac(rdram, ctx, runtime);
}

void entry_20bae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bae4 inside entry_20badc (0x20badc - 0x20baf8)
    ctx->pc = 0x20bae4;
    entry_20badc(rdram, ctx, runtime);
}

void entry_20bb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bb18 inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bb18;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bb80 inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bb80;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bbac inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bbac;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bbb0 inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bbb0;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bbb8 inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bbb8;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bbe0 inside entry_20bb00 (0x20bb00 - 0x20bc40)
    ctx->pc = 0x20bbe0;
    entry_20bb00(rdram, ctx, runtime);
}

void entry_20bd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20bd90 inside entry_20bd54 (0x20bd54 - 0x20bdc0)
    ctx->pc = 0x20bd90;
    entry_20bd54(rdram, ctx, runtime);
}

void entry_20c0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c0f8 inside entry_20c0f4 (0x20c0f4 - 0x20c104)
    ctx->pc = 0x20c0f8;
    entry_20c0f4(rdram, ctx, runtime);
}

void entry_20c1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c1a0 inside entry_20c120 (0x20c120 - 0x20c274)
    ctx->pc = 0x20c1a0;
    entry_20c120(rdram, ctx, runtime);
}

void entry_20c1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c1f0 inside entry_20c120 (0x20c120 - 0x20c274)
    ctx->pc = 0x20c1f0;
    entry_20c120(rdram, ctx, runtime);
}

void entry_20c220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c220 inside entry_20c120 (0x20c120 - 0x20c274)
    ctx->pc = 0x20c220;
    entry_20c120(rdram, ctx, runtime);
}

void entry_20c250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c250 inside entry_20c120 (0x20c120 - 0x20c274)
    ctx->pc = 0x20c250;
    entry_20c120(rdram, ctx, runtime);
}

void entry_20c284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c284 inside entry_20c274 (0x20c274 - 0x20c28c)
    ctx->pc = 0x20c284;
    entry_20c274(rdram, ctx, runtime);
}

void entry_20c2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c2a8 inside entry_20c28c (0x20c28c - 0x20c2cc)
    ctx->pc = 0x20c2a8;
    entry_20c28c(rdram, ctx, runtime);
}

void entry_20c2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c2e4 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c2e4;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c310 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c310;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c314 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c314;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c324 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c324;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c380 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c380;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c38c inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c38c;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c3bc inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c3bc;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c3c0 inside entry_20c2cc (0x20c2cc - 0x20c3f0)
    ctx->pc = 0x20c3c0;
    entry_20c2cc(rdram, ctx, runtime);
}

void entry_20c46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c46c inside _getAllRefs (0x20c3f0 - 0x20c50c)
    ctx->pc = 0x20c46c;
    _getAllRefs(rdram, ctx, runtime);
}

void entry_20c494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c494 inside _getAllRefs (0x20c3f0 - 0x20c50c)
    ctx->pc = 0x20c494;
    _getAllRefs(rdram, ctx, runtime);
}

void entry_20c4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c4c8 inside _getAllRefs (0x20c3f0 - 0x20c50c)
    ctx->pc = 0x20c4c8;
    _getAllRefs(rdram, ctx, runtime);
}

void entry_20c554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c554 inside entry_20c54c (0x20c54c - 0x20c578)
    ctx->pc = 0x20c554;
    entry_20c54c(rdram, ctx, runtime);
}

void entry_20c66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c66c inside entry_20c634 (0x20c634 - 0x20c67c)
    ctx->pc = 0x20c66c;
    entry_20c634(rdram, ctx, runtime);
}

void entry_20c684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c684 inside entry_20c67c (0x20c67c - 0x20c780)
    ctx->pc = 0x20c684;
    entry_20c67c(rdram, ctx, runtime);
}

void entry_20c6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c6d0 inside entry_20c67c (0x20c67c - 0x20c780)
    ctx->pc = 0x20c6d0;
    entry_20c67c(rdram, ctx, runtime);
}

void entry_20c6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c6d4 inside entry_20c67c (0x20c67c - 0x20c780)
    ctx->pc = 0x20c6d4;
    entry_20c67c(rdram, ctx, runtime);
}

void entry_20c6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c6e8 inside entry_20c67c (0x20c67c - 0x20c780)
    ctx->pc = 0x20c6e8;
    entry_20c67c(rdram, ctx, runtime);
}

void entry_20c724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c724 inside entry_20c67c (0x20c67c - 0x20c780)
    ctx->pc = 0x20c724;
    entry_20c67c(rdram, ctx, runtime);
}

void entry_20c7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c7a8 inside entry_20c780 (0x20c780 - 0x20c820)
    ctx->pc = 0x20c7a8;
    entry_20c780(rdram, ctx, runtime);
}

void entry_20c7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c7ac inside entry_20c780 (0x20c780 - 0x20c820)
    ctx->pc = 0x20c7ac;
    entry_20c780(rdram, ctx, runtime);
}

void entry_20c7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c7f4 inside entry_20c780 (0x20c780 - 0x20c820)
    ctx->pc = 0x20c7f4;
    entry_20c780(rdram, ctx, runtime);
}

void entry_20c8a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c8a4 inside entry_20c868 (0x20c868 - 0x20c8b8)
    ctx->pc = 0x20c8a4;
    entry_20c868(rdram, ctx, runtime);
}

void entry_20c8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c8b0 inside entry_20c868 (0x20c868 - 0x20c8b8)
    ctx->pc = 0x20c8b0;
    entry_20c868(rdram, ctx, runtime);
}

void entry_20c8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c8c0 inside entry_20c8b8 (0x20c8b8 - 0x20c8d0)
    ctx->pc = 0x20c8c0;
    entry_20c8b8(rdram, ctx, runtime);
}

void entry_20c8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c8d4 inside entry_20c8d0 (0x20c8d0 - 0x20c974)
    ctx->pc = 0x20c8d4;
    entry_20c8d0(rdram, ctx, runtime);
}

void entry_20c8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c8d8 inside entry_20c8d0 (0x20c8d0 - 0x20c974)
    ctx->pc = 0x20c8d8;
    entry_20c8d0(rdram, ctx, runtime);
}

void entry_20c934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c934 inside entry_20c8d0 (0x20c8d0 - 0x20c974)
    ctx->pc = 0x20c934;
    entry_20c8d0(rdram, ctx, runtime);
}

void entry_20c9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c9ac inside entry_20c974 (0x20c974 - 0x20c9b4)
    ctx->pc = 0x20c9ac;
    entry_20c974(rdram, ctx, runtime);
}

void entry_20c9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c9bc inside entry_20c9b4 (0x20c9b4 - 0x20ca0c)
    ctx->pc = 0x20c9bc;
    entry_20c9b4(rdram, ctx, runtime);
}

void entry_20c9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20c9d4 inside entry_20c9b4 (0x20c9b4 - 0x20ca0c)
    ctx->pc = 0x20c9d4;
    entry_20c9b4(rdram, ctx, runtime);
}

void entry_20ca14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ca14 inside entry_20ca0c (0x20ca0c - 0x20ca64)
    ctx->pc = 0x20ca14;
    entry_20ca0c(rdram, ctx, runtime);
}

void entry_20ca2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ca2c inside entry_20ca0c (0x20ca0c - 0x20ca64)
    ctx->pc = 0x20ca2c;
    entry_20ca0c(rdram, ctx, runtime);
}

void entry_20ca74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ca74 inside entry_20ca64 (0x20ca64 - 0x20caac)
    ctx->pc = 0x20ca74;
    entry_20ca64(rdram, ctx, runtime);
}

void entry_20cab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cab4 inside entry_20caac (0x20caac - 0x20cac4)
    ctx->pc = 0x20cab4;
    entry_20caac(rdram, ctx, runtime);
}

void entry_20cac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cac8 inside entry_20cac4 (0x20cac4 - 0x20caf8)
    ctx->pc = 0x20cac8;
    entry_20cac4(rdram, ctx, runtime);
}

void entry_20cbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cbb0 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cbb0;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cbb8 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cbb8;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cc48 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cc48;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cc7c inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cc7c;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cc80 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cc80;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cd34 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cd34;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cd48 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cd48;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cdc4 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cdc4;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cdf8 inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cdf8;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cdfc inside _getRef0 (0x20caf8 - 0x20cf18)
    ctx->pc = 0x20cdfc;
    _getRef0(rdram, ctx, runtime);
}

void entry_20cf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cf90 inside _doMC (0x20cf18 - 0x20cfc8)
    ctx->pc = 0x20cf90;
    _doMC(rdram, ctx, runtime);
}

void entry_20cffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20cffc inside entry_20cfdc (0x20cfdc - 0x20d050)
    ctx->pc = 0x20cffc;
    entry_20cfdc(rdram, ctx, runtime);
}

void entry_20d00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d00c inside entry_20cfdc (0x20cfdc - 0x20d050)
    ctx->pc = 0x20d00c;
    entry_20cfdc(rdram, ctx, runtime);
}

void entry_20d018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d018 inside entry_20cfdc (0x20cfdc - 0x20d050)
    ctx->pc = 0x20d018;
    entry_20cfdc(rdram, ctx, runtime);
}

void entry_20d01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d01c inside entry_20cfdc (0x20cfdc - 0x20d050)
    ctx->pc = 0x20d01c;
    entry_20cfdc(rdram, ctx, runtime);
}

void entry_20d0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d0b0 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d0b0;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d0f4 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d0f4;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d15c inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d15c;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d1d0 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d1d0;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d1d8 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d1d8;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d28c inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d28c;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d2dc inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d2dc;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d328 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d328;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d348 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d348;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d384 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d384;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d3fc inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d3fc;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d4a8 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d4a8;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d4b0 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d4b0;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d59c inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d59c;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d610 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d610;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d658 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d658;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d690 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d690;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d6e4 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d6e4;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d754 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d754;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d7f0 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d7f0;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d7f8 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d7f8;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d8c4 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d8c4;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d93c inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d93c;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d988 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d988;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d9a8 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d9a8;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20d9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20d9fc inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20d9fc;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20da74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20da74 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20da74;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20db48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20db48 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20db48;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20db50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20db50 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20db50;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20dc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dc54 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20dc54;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20dcf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dcf0 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20dcf0;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20dd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dd38 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20dd38;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20dd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dd70 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20dd70;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20dddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dddc inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20dddc;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20de28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20de28 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20de28;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20de38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20de38 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20de38;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20de88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20de88 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20de88;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20de98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20de98 inside entry_20d050 (0x20d050 - 0x20dee8)
    ctx->pc = 0x20de98;
    entry_20d050(rdram, ctx, runtime);
}

void entry_20df90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20df90 inside entry_20df40 (0x20df40 - 0x20dfb8)
    ctx->pc = 0x20df90;
    entry_20df40(rdram, ctx, runtime);
}

void entry_20dfd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dfd4 inside entry_20dfb8 (0x20dfb8 - 0x20e044)
    ctx->pc = 0x20dfd4;
    entry_20dfb8(rdram, ctx, runtime);
}

void entry_20dfd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20dfd8 inside entry_20dfb8 (0x20dfb8 - 0x20e044)
    ctx->pc = 0x20dfd8;
    entry_20dfb8(rdram, ctx, runtime);
}

void entry_20e00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e00c inside entry_20dfb8 (0x20dfb8 - 0x20e044)
    ctx->pc = 0x20e00c;
    entry_20dfb8(rdram, ctx, runtime);
}

void entry_20e014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e014 inside entry_20dfb8 (0x20dfb8 - 0x20e044)
    ctx->pc = 0x20e014;
    entry_20dfb8(rdram, ctx, runtime);
}

void entry_20e018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e018 inside entry_20dfb8 (0x20dfb8 - 0x20e044)
    ctx->pc = 0x20e018;
    entry_20dfb8(rdram, ctx, runtime);
}

void entry_20e0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e0d4 inside entry_20e0c8 (0x20e0c8 - 0x20e100)
    ctx->pc = 0x20e0d4;
    entry_20e0c8(rdram, ctx, runtime);
}

void entry_20e150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e150 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e150;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e154 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e154;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e170 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e170;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e174 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e174;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e194 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e194;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e1b4 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e1b4;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e1b8 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e1b8;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e1c8 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e1c8;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e1d8 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e1d8;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e1f8 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e1f8;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e21c inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e21c;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e220 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e220;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e238 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e238;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e240 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e240;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e254 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e254;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e258 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e258;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e274 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e274;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e278 inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e278;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e29c inside _dualPrimeVector (0x20e120 - 0x20e2a8)
    ctx->pc = 0x20e29c;
    _dualPrimeVector(rdram, ctx, runtime);
}

void entry_20e2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e2f0 inside _mbAddressIncrement (0x20e2a8 - 0x20e2f8)
    ctx->pc = 0x20e2f0;
    _mbAddressIncrement(rdram, ctx, runtime);
}

void entry_20e31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e31c inside entry_20e2f8 (0x20e2f8 - 0x20e338)
    ctx->pc = 0x20e31c;
    entry_20e2f8(rdram, ctx, runtime);
}

void entry_20e330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e330 inside entry_20e2f8 (0x20e2f8 - 0x20e338)
    ctx->pc = 0x20e330;
    entry_20e2f8(rdram, ctx, runtime);
}

void entry_20e364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e364 inside entry_20e35c (0x20e35c - 0x20e370)
    ctx->pc = 0x20e364;
    entry_20e35c(rdram, ctx, runtime);
}

void entry_20e368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e368 inside entry_20e35c (0x20e35c - 0x20e370)
    ctx->pc = 0x20e368;
    entry_20e35c(rdram, ctx, runtime);
}

void entry_20e37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e37c inside entry_20e370 (0x20e370 - 0x20e3b8)
    ctx->pc = 0x20e37c;
    entry_20e370(rdram, ctx, runtime);
}

void entry_20e380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e380 inside entry_20e370 (0x20e370 - 0x20e3b8)
    ctx->pc = 0x20e380;
    entry_20e370(rdram, ctx, runtime);
}

void entry_20e38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e38c inside entry_20e370 (0x20e370 - 0x20e3b8)
    ctx->pc = 0x20e38c;
    entry_20e370(rdram, ctx, runtime);
}

void entry_20e408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e408 inside _pictureData0 (0x20e3b8 - 0x20e414)
    ctx->pc = 0x20e408;
    _pictureData0(rdram, ctx, runtime);
}

void entry_20e40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e40c inside _pictureData0 (0x20e3b8 - 0x20e414)
    ctx->pc = 0x20e40c;
    _pictureData0(rdram, ctx, runtime);
}

void entry_20e450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e450 inside entry_20e438 (0x20e438 - 0x20e484)
    ctx->pc = 0x20e450;
    entry_20e438(rdram, ctx, runtime);
}

void entry_20e488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e488 inside entry_20e484 (0x20e484 - 0x20e49c)
    ctx->pc = 0x20e488;
    entry_20e484(rdram, ctx, runtime);
}

void entry_20e530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e530 inside entry_20e528 (0x20e528 - 0x20e538)
    ctx->pc = 0x20e530;
    entry_20e528(rdram, ctx, runtime);
}

void entry_20e574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e574 inside entry_20e56c (0x20e56c - 0x20e5f0)
    ctx->pc = 0x20e574;
    entry_20e56c(rdram, ctx, runtime);
}

void entry_20e5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e5c8 inside entry_20e56c (0x20e56c - 0x20e5f0)
    ctx->pc = 0x20e5c8;
    entry_20e56c(rdram, ctx, runtime);
}

void entry_20e638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e638 inside entry_20e628 (0x20e628 - 0x20e668)
    ctx->pc = 0x20e638;
    entry_20e628(rdram, ctx, runtime);
}

void entry_20e650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e650 inside entry_20e628 (0x20e628 - 0x20e668)
    ctx->pc = 0x20e650;
    entry_20e628(rdram, ctx, runtime);
}

void entry_20e678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e678 inside entry_20e668 (0x20e668 - 0x20e68c)
    ctx->pc = 0x20e678;
    entry_20e668(rdram, ctx, runtime);
}

void entry_20e6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e6a4 inside entry_20e68c (0x20e68c - 0x20e6b4)
    ctx->pc = 0x20e6a4;
    entry_20e68c(rdram, ctx, runtime);
}

void entry_20e6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e6ac inside entry_20e68c (0x20e68c - 0x20e6b4)
    ctx->pc = 0x20e6ac;
    entry_20e68c(rdram, ctx, runtime);
}

void entry_20e6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e6c4 inside entry_20e6b4 (0x20e6b4 - 0x20e6e0)
    ctx->pc = 0x20e6c4;
    entry_20e6b4(rdram, ctx, runtime);
}

void entry_20e6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e6e8 inside entry_20e6e0 (0x20e6e0 - 0x20e718)
    ctx->pc = 0x20e6e8;
    entry_20e6e0(rdram, ctx, runtime);
}

void entry_20e720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e720 inside entry_20e718 (0x20e718 - 0x20e744)
    ctx->pc = 0x20e720;
    entry_20e718(rdram, ctx, runtime);
}

void entry_20e72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e72c inside entry_20e718 (0x20e718 - 0x20e744)
    ctx->pc = 0x20e72c;
    entry_20e718(rdram, ctx, runtime);
}

void entry_20e750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e750 inside entry_20e744 (0x20e744 - 0x20e770)
    ctx->pc = 0x20e750;
    entry_20e744(rdram, ctx, runtime);
}

void entry_20e778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e778 inside entry_20e770 (0x20e770 - 0x20e79c)
    ctx->pc = 0x20e778;
    entry_20e770(rdram, ctx, runtime);
}

void entry_20e784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e784 inside entry_20e770 (0x20e770 - 0x20e79c)
    ctx->pc = 0x20e784;
    entry_20e770(rdram, ctx, runtime);
}

void entry_20e7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e7a4 inside entry_20e79c (0x20e79c - 0x20e7e0)
    ctx->pc = 0x20e7a4;
    entry_20e79c(rdram, ctx, runtime);
}

void entry_20e7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e7c4 inside entry_20e79c (0x20e79c - 0x20e7e0)
    ctx->pc = 0x20e7c4;
    entry_20e79c(rdram, ctx, runtime);
}

void entry_20e7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e7c8 inside entry_20e79c (0x20e79c - 0x20e7e0)
    ctx->pc = 0x20e7c8;
    entry_20e79c(rdram, ctx, runtime);
}

void entry_20e830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e830 inside _skipMB0 (0x20e7e0 - 0x20e874)
    ctx->pc = 0x20e830;
    _skipMB0(rdram, ctx, runtime);
}

void entry_20e844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e844 inside _skipMB0 (0x20e7e0 - 0x20e874)
    ctx->pc = 0x20e844;
    _skipMB0(rdram, ctx, runtime);
}

void entry_20e858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e858 inside _skipMB0 (0x20e7e0 - 0x20e874)
    ctx->pc = 0x20e858;
    _skipMB0(rdram, ctx, runtime);
}

void entry_20e87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e87c inside entry_20e874 (0x20e874 - 0x20e8a0)
    ctx->pc = 0x20e87c;
    entry_20e874(rdram, ctx, runtime);
}

void entry_20e948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e948 inside entry_20e938 (0x20e938 - 0x20e97c)
    ctx->pc = 0x20e948;
    entry_20e938(rdram, ctx, runtime);
}

void entry_20e974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e974 inside entry_20e938 (0x20e938 - 0x20e97c)
    ctx->pc = 0x20e974;
    entry_20e938(rdram, ctx, runtime);
}

void entry_20e984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e984 inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20e984;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e9b0 inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20e9b0;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20e9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e9b4 inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20e9b4;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20e9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e9dc inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20e9dc;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20e9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20e9f0 inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20e9f0;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20ea08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea08 inside entry_20e97c (0x20e97c - 0x20ea38)
    ctx->pc = 0x20ea08;
    entry_20e97c(rdram, ctx, runtime);
}

void entry_20ea40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea40 inside entry_20ea38 (0x20ea38 - 0x20ea64)
    ctx->pc = 0x20ea40;
    entry_20ea38(rdram, ctx, runtime);
}

void entry_20ea44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea44 inside entry_20ea38 (0x20ea38 - 0x20ea64)
    ctx->pc = 0x20ea44;
    entry_20ea38(rdram, ctx, runtime);
}

void entry_20ea48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea48 inside entry_20ea38 (0x20ea38 - 0x20ea64)
    ctx->pc = 0x20ea48;
    entry_20ea38(rdram, ctx, runtime);
}

void entry_20ea6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea6c inside entry_20ea64 (0x20ea64 - 0x20ead4)
    ctx->pc = 0x20ea6c;
    entry_20ea64(rdram, ctx, runtime);
}

void entry_20ea94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ea94 inside entry_20ea64 (0x20ea64 - 0x20ead4)
    ctx->pc = 0x20ea94;
    entry_20ea64(rdram, ctx, runtime);
}

void entry_20eadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20eadc inside entry_20ead4 (0x20ead4 - 0x20eb00)
    ctx->pc = 0x20eadc;
    entry_20ead4(rdram, ctx, runtime);
}

void entry_20eb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20eb04 inside entry_20eb00 (0x20eb00 - 0x20eb60)
    ctx->pc = 0x20eb04;
    entry_20eb00(rdram, ctx, runtime);
}

void entry_20eb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20eb68 inside entry_20eb60 (0x20eb60 - 0x20eb8c)
    ctx->pc = 0x20eb68;
    entry_20eb60(rdram, ctx, runtime);
}

void entry_20eb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20eb90 inside entry_20eb8c (0x20eb8c - 0x20ebbc)
    ctx->pc = 0x20eb90;
    entry_20eb8c(rdram, ctx, runtime);
}

void entry_20ebc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ebc0 inside entry_20ebbc (0x20ebbc - 0x20ebe4)
    ctx->pc = 0x20ebc0;
    entry_20ebbc(rdram, ctx, runtime);
}

void entry_20ebc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ebc4 inside entry_20ebbc (0x20ebbc - 0x20ebe4)
    ctx->pc = 0x20ebc4;
    entry_20ebbc(rdram, ctx, runtime);
}

void entry_20ec38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ec38 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ec38;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ec50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ec50 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ec50;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ec60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ec60 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ec60;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ec8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ec8c inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ec8c;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ecb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ecb8 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ecb8;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ecfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ecfc inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ecfc;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ed14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ed14 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ed14;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ed18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ed18 inside entry_20ec30 (0x20ec30 - 0x20ed48)
    ctx->pc = 0x20ed18;
    entry_20ec30(rdram, ctx, runtime);
}

void entry_20ed90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ed90 inside _decode_motion_vector (0x20ed48 - 0x20edd0)
    ctx->pc = 0x20ed90;
    _decode_motion_vector(rdram, ctx, runtime);
}

void entry_20edc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20edc0 inside _decode_motion_vector (0x20ed48 - 0x20edd0)
    ctx->pc = 0x20edc0;
    _decode_motion_vector(rdram, ctx, runtime);
}

void entry_20edc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20edc4 inside _decode_motion_vector (0x20ed48 - 0x20edd0)
    ctx->pc = 0x20edc4;
    _decode_motion_vector(rdram, ctx, runtime);
}

void entry_20ee58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ee58 inside entry_20ee40 (0x20ee40 - 0x20ee64)
    ctx->pc = 0x20ee58;
    entry_20ee40(rdram, ctx, runtime);
}

void entry_20ef00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ef00 inside entry_20eea8 (0x20eea8 - 0x20ef2c)
    ctx->pc = 0x20ef00;
    entry_20eea8(rdram, ctx, runtime);
}

void entry_20ef04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ef04 inside entry_20eea8 (0x20eea8 - 0x20ef2c)
    ctx->pc = 0x20ef04;
    entry_20eea8(rdram, ctx, runtime);
}

void entry_20efe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20efe4 inside entry_20efdc (0x20efdc - 0x20effc)
    ctx->pc = 0x20efe4;
    entry_20efdc(rdram, ctx, runtime);
}

void entry_20efe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20efe8 inside entry_20efdc (0x20efdc - 0x20effc)
    ctx->pc = 0x20efe8;
    entry_20efdc(rdram, ctx, runtime);
}

void entry_20f014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f014 inside entry_20f00c (0x20f00c - 0x20f01c)
    ctx->pc = 0x20f014;
    entry_20f00c(rdram, ctx, runtime);
}

void entry_20f03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f03c inside entry_20f034 (0x20f034 - 0x20f064)
    ctx->pc = 0x20f03c;
    entry_20f034(rdram, ctx, runtime);
}

void entry_20f040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f040 inside entry_20f034 (0x20f034 - 0x20f064)
    ctx->pc = 0x20f040;
    entry_20f034(rdram, ctx, runtime);
}

void entry_20f054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f054 inside entry_20f034 (0x20f034 - 0x20f064)
    ctx->pc = 0x20f054;
    entry_20f034(rdram, ctx, runtime);
}

void entry_20f078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f078 inside entry_20f064 (0x20f064 - 0x20f088)
    ctx->pc = 0x20f078;
    entry_20f064(rdram, ctx, runtime);
}

void entry_20f090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f090 inside entry_20f088 (0x20f088 - 0x20f0c0)
    ctx->pc = 0x20f090;
    entry_20f088(rdram, ctx, runtime);
}

void entry_20f150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f150 inside _waitIpuIdle (0x20f0f0 - 0x20f164)
    ctx->pc = 0x20f150;
    _waitIpuIdle(rdram, ctx, runtime);
}

void entry_20f168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f168 inside entry_20f164 (0x20f164 - 0x20f198)
    ctx->pc = 0x20f168;
    entry_20f164(rdram, ctx, runtime);
}

void entry_20f17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f17c inside entry_20f164 (0x20f164 - 0x20f198)
    ctx->pc = 0x20f17c;
    entry_20f164(rdram, ctx, runtime);
}

void entry_20f1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f1f8 inside _waitIpuIdle64 (0x20f198 - 0x20f20c)
    ctx->pc = 0x20f1f8;
    _waitIpuIdle64(rdram, ctx, runtime);
}

void entry_20f210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f210 inside entry_20f20c (0x20f20c - 0x20f248)
    ctx->pc = 0x20f210;
    entry_20f20c(rdram, ctx, runtime);
}

void entry_20f230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f230 inside entry_20f20c (0x20f20c - 0x20f248)
    ctx->pc = 0x20f230;
    entry_20f20c(rdram, ctx, runtime);
}

void entry_20f234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f234 inside entry_20f20c (0x20f20c - 0x20f248)
    ctx->pc = 0x20f234;
    entry_20f20c(rdram, ctx, runtime);
}

void entry_20f298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f298 inside _ipuVdec (0x20f248 - 0x20f2b0)
    ctx->pc = 0x20f298;
    _ipuVdec(rdram, ctx, runtime);
}

void entry_20f2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f2b4 inside entry_20f2b0 (0x20f2b0 - 0x20f340)
    ctx->pc = 0x20f2b4;
    entry_20f2b0(rdram, ctx, runtime);
}

void entry_20f2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f2e0 inside entry_20f2b0 (0x20f2b0 - 0x20f340)
    ctx->pc = 0x20f2e0;
    entry_20f2b0(rdram, ctx, runtime);
}

void entry_20f2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f2ec inside entry_20f2b0 (0x20f2b0 - 0x20f340)
    ctx->pc = 0x20f2ec;
    entry_20f2b0(rdram, ctx, runtime);
}

void entry_20f328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f328 inside entry_20f2b0 (0x20f2b0 - 0x20f340)
    ctx->pc = 0x20f328;
    entry_20f2b0(rdram, ctx, runtime);
}

void entry_20f34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f34c inside entry_20f340 (0x20f340 - 0x20f3c0)
    ctx->pc = 0x20f34c;
    entry_20f340(rdram, ctx, runtime);
}

void entry_20f380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f380 inside entry_20f340 (0x20f340 - 0x20f3c0)
    ctx->pc = 0x20f380;
    entry_20f340(rdram, ctx, runtime);
}

void entry_20f384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f384 inside entry_20f340 (0x20f340 - 0x20f3c0)
    ctx->pc = 0x20f384;
    entry_20f340(rdram, ctx, runtime);
}

void entry_20f3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f3f4 inside _peepBit (0x20f3c0 - 0x20f438)
    ctx->pc = 0x20f3f4;
    _peepBit(rdram, ctx, runtime);
}

void entry_20f420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f420 inside _peepBit (0x20f3c0 - 0x20f438)
    ctx->pc = 0x20f420;
    _peepBit(rdram, ctx, runtime);
}

void entry_20f43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f43c inside entry_20f438 (0x20f438 - 0x20f490)
    ctx->pc = 0x20f43c;
    entry_20f438(rdram, ctx, runtime);
}

void entry_20f468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f468 inside entry_20f438 (0x20f438 - 0x20f490)
    ctx->pc = 0x20f468;
    entry_20f438(rdram, ctx, runtime);
}

void entry_20f474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f474 inside entry_20f438 (0x20f438 - 0x20f490)
    ctx->pc = 0x20f474;
    entry_20f438(rdram, ctx, runtime);
}

void entry_20f4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f4a8 inside entry_20f490 (0x20f490 - 0x20f4c8)
    ctx->pc = 0x20f4a8;
    entry_20f490(rdram, ctx, runtime);
}

void entry_20f510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f510 inside _flushBuf (0x20f4c8 - 0x20f528)
    ctx->pc = 0x20f510;
    _flushBuf(rdram, ctx, runtime);
}

void entry_20f52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f52c inside entry_20f528 (0x20f528 - 0x20f58c)
    ctx->pc = 0x20f52c;
    entry_20f528(rdram, ctx, runtime);
}

void entry_20f558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f558 inside entry_20f528 (0x20f528 - 0x20f58c)
    ctx->pc = 0x20f558;
    entry_20f528(rdram, ctx, runtime);
}

void entry_20f560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f560 inside entry_20f528 (0x20f528 - 0x20f58c)
    ctx->pc = 0x20f560;
    entry_20f528(rdram, ctx, runtime);
}

void entry_20f608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f608 inside _sceMpegNextBit (0x20f5b8 - 0x20f61c)
    ctx->pc = 0x20f608;
    _sceMpegNextBit(rdram, ctx, runtime);
}

void entry_20f620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f620 inside entry_20f61c (0x20f61c - 0x20f688)
    ctx->pc = 0x20f620;
    entry_20f61c(rdram, ctx, runtime);
}

void entry_20f64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f64c inside entry_20f61c (0x20f61c - 0x20f688)
    ctx->pc = 0x20f64c;
    entry_20f61c(rdram, ctx, runtime);
}

void entry_20f650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f650 inside entry_20f61c (0x20f61c - 0x20f688)
    ctx->pc = 0x20f650;
    entry_20f61c(rdram, ctx, runtime);
}

void entry_20f668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f668 inside entry_20f61c (0x20f61c - 0x20f688)
    ctx->pc = 0x20f668;
    entry_20f61c(rdram, ctx, runtime);
}

void entry_20f694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f694 inside entry_20f688 (0x20f688 - 0x20f6dc)
    ctx->pc = 0x20f694;
    entry_20f688(rdram, ctx, runtime);
}

void entry_20f750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f750 inside entry_20f748 (0x20f748 - 0x20f758)
    ctx->pc = 0x20f750;
    entry_20f748(rdram, ctx, runtime);
}

void entry_20f7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f7dc inside entry_20f7d8 (0x20f7d8 - 0x20f7f0)
    ctx->pc = 0x20f7dc;
    entry_20f7d8(rdram, ctx, runtime);
}

void entry_20f830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f830 inside _nextHeader (0x20f7f0 - 0x20f838)
    ctx->pc = 0x20f830;
    _nextHeader(rdram, ctx, runtime);
}

void entry_20f868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f868 inside entry_20f844 (0x20f844 - 0x20f888)
    ctx->pc = 0x20f868;
    entry_20f844(rdram, ctx, runtime);
}

void entry_20f880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f880 inside entry_20f844 (0x20f844 - 0x20f888)
    ctx->pc = 0x20f880;
    entry_20f844(rdram, ctx, runtime);
}

void entry_20f890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f890 inside entry_20f888 (0x20f888 - 0x20f898)
    ctx->pc = 0x20f890;
    entry_20f888(rdram, ctx, runtime);
}

void entry_20f8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f8a0 inside entry_20f898 (0x20f898 - 0x20f8a8)
    ctx->pc = 0x20f8a0;
    entry_20f898(rdram, ctx, runtime);
}

void entry_20f8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f8d4 inside entry_20f8c0 (0x20f8c0 - 0x20f900)
    ctx->pc = 0x20f8d4;
    entry_20f8c0(rdram, ctx, runtime);
}

void entry_20f970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f970 inside entry_20f968 (0x20f968 - 0x20f984)
    ctx->pc = 0x20f970;
    entry_20f968(rdram, ctx, runtime);
}

void entry_20f998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20f998 inside entry_20f994 (0x20f994 - 0x20f9a0)
    ctx->pc = 0x20f998;
    entry_20f994(rdram, ctx, runtime);
}

void entry_20fa60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fa60 inside entry_20fa54 (0x20fa54 - 0x20fa70)
    ctx->pc = 0x20fa60;
    entry_20fa54(rdram, ctx, runtime);
}

void entry_20fa68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fa68 inside entry_20fa54 (0x20fa54 - 0x20fa70)
    ctx->pc = 0x20fa68;
    entry_20fa54(rdram, ctx, runtime);
}

void entry_20faa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20faa8 inside entry_20faa0 (0x20faa0 - 0x20fab0)
    ctx->pc = 0x20faa8;
    entry_20faa0(rdram, ctx, runtime);
}

void entry_20fabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fabc inside entry_20fab8 (0x20fab8 - 0x20fac4)
    ctx->pc = 0x20fabc;
    entry_20fab8(rdram, ctx, runtime);
}

void entry_20fb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fb8c inside entry_20fb78 (0x20fb78 - 0x20fb98)
    ctx->pc = 0x20fb8c;
    entry_20fb78(rdram, ctx, runtime);
}

void entry_20fcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fcd4 inside entry_20fcbc (0x20fcbc - 0x20fce0)
    ctx->pc = 0x20fcd4;
    entry_20fcbc(rdram, ctx, runtime);
}

void entry_20fcf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fcf8 inside _extrainfo (0x20fce0 - 0x20fd00)
    ctx->pc = 0x20fcf8;
    _extrainfo(rdram, ctx, runtime);
}

void entry_20fd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd28 inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd28;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd5c inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd5c;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd60 inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd60;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd64 inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd64;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd84 inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd84;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fd88 inside entry_20fd0c (0x20fd0c - 0x20fda0)
    ctx->pc = 0x20fd88;
    entry_20fd0c(rdram, ctx, runtime);
}

void entry_20fef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20fef8 inside entry_20fed8 (0x20fed8 - 0x20ff08)
    ctx->pc = 0x20fef8;
    entry_20fed8(rdram, ctx, runtime);
}

void entry_20ff54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ff54 inside _pictureDisplayExtension (0x20ff08 - 0x20ff90)
    ctx->pc = 0x20ff54;
    _pictureDisplayExtension(rdram, ctx, runtime);
}

void entry_20ff60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ff60 inside _pictureDisplayExtension (0x20ff08 - 0x20ff90)
    ctx->pc = 0x20ff60;
    _pictureDisplayExtension(rdram, ctx, runtime);
}

void entry_20ff68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ff68 inside _pictureDisplayExtension (0x20ff08 - 0x20ff90)
    ctx->pc = 0x20ff68;
    _pictureDisplayExtension(rdram, ctx, runtime);
}

void entry_20ff70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ff70 inside _pictureDisplayExtension (0x20ff08 - 0x20ff90)
    ctx->pc = 0x20ff70;
    _pictureDisplayExtension(rdram, ctx, runtime);
}

void entry_20ff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ff88 inside _pictureDisplayExtension (0x20ff08 - 0x20ff90)
    ctx->pc = 0x20ff88;
    _pictureDisplayExtension(rdram, ctx, runtime);
}

void entry_20ffd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x20ffd8 inside entry_20ffcc (0x20ffcc - 0x210000)
    ctx->pc = 0x20ffd8;
    entry_20ffcc(rdram, ctx, runtime);
}

