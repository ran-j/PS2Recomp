// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1c0024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0024: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1c0028: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c002c: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0034);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0034
// Address: 0x1c0034 - 0x1c0044

void entry_1c0034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0034: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1c0038: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c003c: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0044);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0044
// Address: 0x1c0044 - 0x1c0058

void entry_1c0044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0044: 0x12000004
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1c0058(rdram, ctx, runtime); return;
    }
    // 0x1c004c: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1c0050: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0058);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0058
// Address: 0x1c0058 - 0x1c0070

void entry_1c0058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0058: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c005c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0060: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1c0064: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c006c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0070; return;
}


// Function: UpdateSounds__Fv
// Address: 0x1c0070 - 0x1c00a0

void entry_1c00a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c00a0: 0x1440013f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C05A0; return;
    }
    // 0x1c00a8: 0xc06fcf4
    SET_GPR_U32(ctx, 31, 0x1c00b0);
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    PposEar__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c00b0
// Address: 0x1c00b0 - 0x1c00b8

void entry_1c00b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c00b0: 0xc06fd5e
    SET_GPR_U32(ctx, 31, 0x1c00b8);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PfneardistGet__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c00b8
// Address: 0x1c00b8 - 0x1c00fc

void entry_1c00b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c00b8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c00bc: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c00c0: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1c00c4: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1c00c8: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1c00cc: 0x80b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c00d0: 0x24421bac
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7084));
    // 0x1c00d4: 0x8e26472c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 18220)));
    // 0x1c00d8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1c00dc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c00e0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1c00e4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1c00e8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1c00ec: 0x10c0001a
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0158; return;
    }
    // 0x1c00f4: 0xc0475c2
    SET_GPR_U32(ctx, 31, 0x1c00fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    snd_SoundIsStillPlaying(rdram, ctx, runtime); return;
}


// Function: entry_1c00fc
// Address: 0x1c00fc - 0x1c0128

void entry_1c00fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c00fc: 0x14400017
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C015C; return;
    }
    // 0x1c0104: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1c0108: 0x8e024744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18244)));
    // 0x1c010c: 0x1040000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c0148(rdram, ctx, runtime); return;
    }
    // 0x1c0114: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c0118: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1c011c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c0120: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0128);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0128
// Address: 0x1c0128 - 0x1c0138

void entry_1c0128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0128: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1c012c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0130: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0138);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0138
// Address: 0x1c0138 - 0x1c0148

void entry_1c0138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0138: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c013c: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1c0140: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0148);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0148
// Address: 0x1c0148 - 0x1c0190

void entry_1c0148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0148) {
        switch (ctx->pc) {
            case 0x1c0158: ctx->pc = 0; goto label_1c0158;
            case 0x1c015c: ctx->pc = 0; goto label_1c015c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0148: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c014c: 0xae20472c
    WRITE32(ADD32(GPR_U32(ctx, 17), 18220), GPR_U32(ctx, 0));
    // 0x1c0150: 0xae004744
    WRITE32(ADD32(GPR_U32(ctx, 16), 18244), GPR_U32(ctx, 0));
    // 0x1c0154: 0xac404730
    WRITE32(ADD32(GPR_U32(ctx, 2), 18224), GPR_U32(ctx, 0));
label_1c0158:
    // 0x1c0158: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1c015c:
    // 0x1c015c: 0x2403ff9c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967196));
    // 0x1c0160: 0x8c454738
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 18232)));
    // 0x1c0164: 0x10a3005f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1C02E4; return;
    }
    // 0x1c016c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c0170: 0x8c444734
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 18228)));
    // 0x1c0174: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c0178: 0x1880000f
    SET_GPR_U32(ctx, 18, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1C01B8; return;
    }
    // 0x1c0180: 0x1240000e
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C01BC; return;
    }
    // 0x1c0188: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1c0190);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1c0190
// Address: 0x1c0190 - 0x1c01ac

void entry_1c0190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0190: 0x8e224734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 18228)));
    // 0x1c0194: 0x24040007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1c0198: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c019c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c01a0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c01a4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c01ac);
    WRITE32(ADD32(GPR_U32(ctx, 16), 18232), GPR_U32(ctx, 2));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c01ac
// Address: 0x1c01ac - 0x1c0200

void entry_1c01ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c01ac) {
        switch (ctx->pc) {
            case 0x1c01b8: ctx->pc = 0; goto label_1c01b8;
            case 0x1c01bc: ctx->pc = 0; goto label_1c01bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c01ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c01b0: 0x10000036
    WRITE32(ADD32(GPR_U32(ctx, 2), 18668), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C028C; return;
    }
label_1c01b8:
    // 0x1c01b8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
label_1c01bc:
    // 0x1c01bc: 0x8c624754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 18260)));
    // 0x1c01c0: 0x60982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1c01c4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c01c8: 0x4410030
    WRITE32(ADD32(GPR_U32(ctx, 3), 18260), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1C028C; return;
    }
    // 0x1c01d0: 0x8e044738
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 18232)));
    // 0x1c01d4: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1c01d8: 0x8e224734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 18228)));
    // 0x1c01dc: 0x2486ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1c01e0: 0x24830001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1c01e4: 0x44102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x1c01e8: 0xc2180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 6));
    // 0x1c01ec: 0x32fc2
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 3), 31));
    // 0x1c01f0: 0x24640014
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 20));
    // 0x1c01f4: 0xace548ec
    WRITE32(ADD32(GPR_U32(ctx, 7), 18668), GPR_U32(ctx, 5));
    // 0x1c01f8: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1c0200);
    WRITE32(ADD32(GPR_U32(ctx, 16), 18232), GPR_U32(ctx, 3));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1c0200
// Address: 0x1c0200 - 0x1c0280

void entry_1c0200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0200) {
        switch (ctx->pc) {
            case 0x1c0254: ctx->pc = 0; goto label_1c0254;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0200: 0x8e024738
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18232)));
    // 0x1c0204: 0x443001f
    if (GPR_S32(ctx, 2) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 18260)));
        ctx->pc = 0x1C0284; return;
    }
    // 0x1c020c: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1c0210: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1c0214: 0x3c01bd4c
    SET_GPR_U32(ctx, 1, ((uint32_t)48460 << 16));
    // 0x1c0218: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1c021c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c0220: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1c0224: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c0228: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c022c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1c0230: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c0234: 0x0
    // NOP
    // 0x1c0238: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c0254;
    }
    // 0x1c0240: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c0244: 0x0
    // NOP
    // 0x1c0248: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c0254;
    }
    // 0x1c0250: 0x46001846
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
label_1c0254:
    // 0x1c0254: 0x3c013f2a
    SET_GPR_U32(ctx, 1, ((uint32_t)16170 << 16));
    // 0x1c0258: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1c025c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c0260: 0x24040007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1c0264: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c0268: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c026c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c0270: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1c0274: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x1c0278: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1c0280);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1c0280
// Address: 0x1c0280 - 0x1c02dc

void entry_1c0280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0280) {
        switch (ctx->pc) {
            case 0x1c0284: ctx->pc = 0; goto label_1c0284;
            case 0x1c028c: ctx->pc = 0; goto label_1c028c;
            case 0x1c02ac: ctx->pc = 0; goto label_1c02ac;
            case 0x1c02c0: ctx->pc = 0; goto label_1c02c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0280: 0x8e624754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 18260)));
label_1c0284:
    // 0x1c0284: 0x24420003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3));
    // 0x1c0288: 0xae624754
    WRITE32(ADD32(GPR_U32(ctx, 19), 18260), GPR_U32(ctx, 2));
label_1c028c:
    // 0x1c028c: 0x12400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18232)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1c02ac;
    }
    // 0x1c0294: 0x8e234734
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 18228)));
    // 0x1c0298: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1c029c: 0x10400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c02c0;
    }
    // 0x1c02a4: 0x10000011
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C02EC; return;
    }
label_1c02ac:
    // 0x1c02ac: 0x8e034738
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 18232)));
    // 0x1c02b0: 0x8e224734
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 18228)));
    // 0x1c02b4: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1c02b8: 0x1440000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C02E8; return;
    }
label_1c02c0:
    // 0x1c02c0: 0x8e024738
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 18232)));
    // 0x1c02c4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c02c8: 0x8e244734
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 18228)));
    // 0x1c02cc: 0x217c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 31));
    // 0x1c02d0: 0xac6248ec
    WRITE32(ADD32(GPR_U32(ctx, 3), 18668), GPR_U32(ctx, 2));
    // 0x1c02d4: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1c02dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20));
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1c02dc
// Address: 0x1c02dc - 0x1c032c

void entry_1c02dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c02dc) {
        switch (ctx->pc) {
            case 0x1c02e4: ctx->pc = 0; goto label_1c02e4;
            case 0x1c02e8: ctx->pc = 0; goto label_1c02e8;
            case 0x1c02ec: ctx->pc = 0; goto label_1c02ec;
            case 0x1c0318: ctx->pc = 0; goto label_1c0318;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c02dc: 0x2402ff9c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    // 0x1c02e0: 0xae024738
    WRITE32(ADD32(GPR_U32(ctx, 16), 18232), GPR_U32(ctx, 2));
label_1c02e4:
    // 0x1c02e4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1c02e8:
    // 0x1c02e8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_1c02ec:
    // 0x1c02ec: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c02f0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1c02f4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c02f8: 0x120000a4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C058C; return;
    }
    // 0x1c0300: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x1c0304: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1c0308: 0x24565024
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 20516));
    // 0x1c030c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c0310: 0x3c13001c
    SET_GPR_U32(ctx, 19, ((uint32_t)28 << 16));
    // 0x1c0314: 0x0
    // NOP
label_1c0318:
    // 0x1c0318: 0x8e040030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1c031c: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
        ctx->pc = 0x1C0338; return;
    }
    // 0x1c0324: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1c032c);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c032c
// Address: 0x1c032c - 0x1c037c

void entry_1c032c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c032c) {
        switch (ctx->pc) {
            case 0x1c0338: ctx->pc = 0; goto label_1c0338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c032c: 0x1040006f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C04EC; return;
    }
    // 0x1c0334: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
label_1c0338:
    // 0x1c0338: 0x5440002a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1C03E4; return;
    }
    // 0x1c0340: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x1c0344: 0x50400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 76)));
        ctx->pc = 0x1C03A0; return;
    }
    // 0x1c034c: 0xc6000078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[0] = *(float*)&val; }
    // 0x1c0350: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c0354: 0x0
    // NOP
    // 0x1c0358: 0x4503000e
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
        ctx->pc = 0x1C0394; return;
    }
    // 0x1c0360: 0x8e040030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1c0364: 0x10800005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1c037c(rdram, ctx, runtime); return;
    }
    // 0x1c036c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c0370: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1c0374: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c037c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c037c
// Address: 0x1c037c - 0x1c0390

void entry_1c037c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c037c: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1c0380: 0x1040005a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C04EC; return;
    }
    // 0x1c0388: 0xc047580
    SET_GPR_U32(ctx, 31, 0x1c0390);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    snd_StopSound(rdram, ctx, runtime); return;
}


// Function: entry_1c0390
// Address: 0x1c0390 - 0x1c03e0

void entry_1c0390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0390) {
        switch (ctx->pc) {
            case 0x1c0394: ctx->pc = 0; goto label_1c0394;
            case 0x1c03a0: ctx->pc = 0; goto label_1c03a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0390: 0xae000018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
label_1c0394:
    // 0x1c0394: 0xae120040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 18));
    // 0x1c0398: 0x10000075
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c0570(rdram, ctx, runtime); return;
    }
label_1c03a0:
    // 0x1c03a0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c03a4: 0x24440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c03a8: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1c03ac: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1c03b0: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x1c03b4: 0x304201fc
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 508));
    // 0x1c03b8: 0x822023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c03bc: 0x308300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 255));
    // 0x1c03c0: 0x14600007
    WRITE8(ADD32(GPR_U32(ctx, 16), 76), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_1c03e0(rdram, ctx, runtime); return;
    }
    // 0x1c03c8: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c03cc: 0x2665ffc8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4294967240));
    // 0x1c03d0: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1c03d4: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x1c03d8: 0xc0475cc
    SET_GPR_U32(ctx, 31, 0x1c03e0);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 6)));
    snd_SoundIsStillPlaying_CB(rdram, ctx, runtime); return;
}


// Function: entry_1c03e0
// Address: 0x1c03e0 - 0x1c0428

void entry_1c03e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c03e0) {
        switch (ctx->pc) {
            case 0x1c03e4: ctx->pc = 0; goto label_1c03e4;
            case 0x1c0420: ctx->pc = 0; goto label_1c0420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c03e0: 0xc6000078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[0] = *(float*)&val; }
label_1c03e4:
    // 0x1c03e4: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c03e8: 0x0
    // NOP
    // 0x1c03ec: 0x4500001b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C045C; return;
    }
    // 0x1c03f4: 0xc6010074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 116)); ctx->f[1] = *(float*)&val; }
    // 0x1c03f8: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1c03fc: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c0400: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c0404: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c0420;
    }
    // 0x1c040c: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1c0410: 0x14400058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0574; return;
    }
    // 0x1c0418: 0x10000011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0460; return;
    }
label_1c0420:
    // 0x1c0420: 0xc06fefe
    SET_GPR_U32(ctx, 31, 0x1c0428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ScheduleNextIntermittentSound__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1c0428
// Address: 0x1c0428 - 0x1c0480

void entry_1c0428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0428) {
        switch (ctx->pc) {
            case 0x1c045c: ctx->pc = 0; goto label_1c045c;
            case 0x1c0460: ctx->pc = 0; goto label_1c0460;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0428: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1c042c: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c045c;
    }
    // 0x1c0434: 0xc6220004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1c0438: 0xc4404750
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18256)); ctx->f[0] = *(float*)&val; }
    // 0x1c043c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c0440: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c0444: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1c0448: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c044c: 0x0
    // NOP
    // 0x1c0450: 0x45030048
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x1C0574; return;
    }
    // 0x1c0458: 0xe4424750
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 18256), *(uint32_t*)&val); }
label_1c045c:
    // 0x1c045c: 0x8e020044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
label_1c0460:
    // 0x1c0460: 0x10400043
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c0570(rdram, ctx, runtime); return;
    }
    // 0x1c0468: 0x8e030030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1c046c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c0470: 0x24620140
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 320));
    // 0x1c0474: 0x43880b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
    // 0x1c0478: 0x2a0f809
    SET_GPR_U32(ctx, 31, 0x1c0480);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 21); return;
}


// Function: entry_1c0480
// Address: 0x1c0480 - 0x1c04e0

void entry_1c0480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0480) {
        switch (ctx->pc) {
            case 0x1c04d8: ctx->pc = 0; goto label_1c04d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0480: 0xc60e0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[14] = *(float*)&val; }
    // 0x1c0484: 0x46007034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c0488: 0x0
    // NOP
    // 0x1c048c: 0x4502001b
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[13] = *(float*)&val; }
        ctx->pc = 0x1C04FC; return;
    }
    // 0x1c0494: 0xc6000078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[0] = *(float*)&val; }
    // 0x1c0498: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c049c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c04a0: 0x0
    // NOP
    // 0x1c04a4: 0x45010033
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C0574; return;
    }
    // 0x1c04ac: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1c04b0: 0x14400030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0574; return;
    }
    // 0x1c04b8: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1c04bc: 0x14400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c04d8;
    }
    // 0x1c04c4: 0xc6000074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 116)); ctx->f[0] = *(float*)&val; }
    // 0x1c04c8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c04cc: 0x0
    // NOP
    // 0x1c04d0: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C04EC; return;
    }
label_1c04d8:
    // 0x1c04d8: 0xc047580
    SET_GPR_U32(ctx, 31, 0x1c04e0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    snd_StopSound(rdram, ctx, runtime); return;
}


// Function: entry_1c04e0
// Address: 0x1c04e0 - 0x1c04f4

void entry_1c04e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c04e0) {
        switch (ctx->pc) {
            case 0x1c04ec: ctx->pc = 0; goto label_1c04ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c04e0: 0xae120040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 18));
    // 0x1c04e4: 0x10000022
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c0570(rdram, ctx, runtime); return;
    }
label_1c04ec:
    // 0x1c04ec: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x1c04f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_1c04f4
// Address: 0x1c04f4 - 0x1c0514

void entry_1c04f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c04f4) {
        switch (ctx->pc) {
            case 0x1c04fc: ctx->pc = 0; goto label_1c04fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c04f4: 0x1000001f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0574; return;
    }
label_1c04fc:
    // 0x1c04fc: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c0500: 0xc60f0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[15] = *(float*)&val; }
    // 0x1c0504: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c0508: 0x26050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 80));
    // 0x1c050c: 0xc06fc80
    SET_GPR_U32(ctx, 31, 0x1c0514);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 84));
    CalculateVolPan__FfP6VECTORPfT2fff(rdram, ctx, runtime); return;
}


// Function: entry_1c0514
// Address: 0x1c0514 - 0x1c054c

void entry_1c0514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0514: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1c0518: 0x1040000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0554; return;
    }
    // 0x1c0520: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c0524: 0x1062000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C0554; return;
    }
    // 0x1c052c: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1c0530: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1c0534: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0538: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c053c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0540: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0544: 0xc047566
    SET_GPR_U32(ctx, 31, 0x1c054c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_PlaySoundVolPanPMPB(rdram, ctx, runtime); return;
}


// Function: entry_1c054c
// Address: 0x1c054c - 0x1c055c

void entry_1c054c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c054c) {
        switch (ctx->pc) {
            case 0x1c0554: ctx->pc = 0; goto label_1c0554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c054c: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x1c0550: 0xae000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 0));
label_1c0554:
    // 0x1c0554: 0xc06fd0a
    SET_GPR_U32(ctx, 31, 0x1c055c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetDoppler__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1c055c
// Address: 0x1c055c - 0x1c0568

void entry_1c055c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c055c: 0xc60c0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[12] = *(float*)&val; }
    // 0x1c0560: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x1c0568);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1c0568
// Address: 0x1c0568 - 0x1c0570

void entry_1c0568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0568: 0xc06fa18
    SET_GPR_U32(ctx, 31, 0x1c0570);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefreshPambVolPan__FP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1c0570
// Address: 0x1c0570 - 0x1c0594

void entry_1c0570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0570) {
        switch (ctx->pc) {
            case 0x1c0574: ctx->pc = 0; goto label_1c0574;
            case 0x1c058c: ctx->pc = 0; goto label_1c058c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0570: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1c0574:
    // 0x1c0574: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1c0578: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c057c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1c0580: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c0584: 0x1600ff64
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0318; return;
    }
label_1c058c:
    // 0x1c058c: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1c0594);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1c0594
// Address: 0x1c0594 - 0x1c05d0

void entry_1c0594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0594) {
        switch (ctx->pc) {
            case 0x1c05a0: ctx->pc = 0; goto label_1c05a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0594: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1c0598: 0xaee3b314
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294947604), GPR_U32(ctx, 3));
    // 0x1c059c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1c05a0:
    // 0x1c05a0: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c05a4: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c05a8: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c05ac: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c05b0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c05b4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c05b8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c05bc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c05c0: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1c05c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c05cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c05d0; return;
}


// Function: SetMvgkUvol__Ff
// Address: 0x1c05d0 - 0x1c05f4

void entry_1c05f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c05f4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c05f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MvgkUnknown1__F4MVGK
// Address: 0x1c0600 - 0x1c0690

void entry_1c0690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0690: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0694: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c069c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c06a0; return;
}


// Function: SetMvgkRvol__Fi4MVGKf
// Address: 0x1c06a0 - 0x1c06cc

void entry_1c06cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c06cc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c06d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MvgkUnknown2__Fv
// Address: 0x1c06d8 - 0x1c0704

void entry_1c0704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0704: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c0708: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c070c: 0xc070174
    SET_GPR_U32(ctx, 31, 0x1c0714);
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    SetMvgkUvol__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c0714
// Address: 0x1c0714 - 0x1c0720

void entry_1c0714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0714) {
        switch (ctx->pc) {
            case 0x1c0718: ctx->pc = 0; goto label_1c0718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0714: 0x0
    // NOP
label_1c0718:
    // 0x1c0718: 0xc070180
    SET_GPR_U32(ctx, 31, 0x1c0720);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MvgkUnknown1__F4MVGK(rdram, ctx, runtime); return;
}


// Function: entry_1c0720
// Address: 0x1c0720 - 0x1c073c

void entry_1c0720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0720: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1c0724: 0x2a020004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 4));
    // 0x1c0728: 0x1440fffb
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0718; return;
    }
    // 0x1c0730: 0x8c4419ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6636)));
    // 0x1c0734: 0xc0701d8
    SET_GPR_U32(ctx, 31, 0x1c073c);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 128));
    MvgkUnknown3(rdram, ctx, runtime); return;
}


// Function: entry_1c073c
// Address: 0x1c073c - 0x1c074c

void entry_1c073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c073c: 0x8e2223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    // 0x1c0740: 0x8c4419ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6636)));
    // 0x1c0744: 0xc0701e4
    SET_GPR_U32(ctx, 31, 0x1c074c);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 64));
    MvgkUnknown4(rdram, ctx, runtime); return;
}


// Function: entry_1c074c
// Address: 0x1c074c - 0x1c0760

void entry_1c074c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c074c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c0750: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0754: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0758: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MvgkUnknown3
// Address: 0x1c0760 - 0x1c0784

void entry_1c0784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0784: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0788: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MvgkUnknown4
// Address: 0x1c0790 - 0x1c07a0

void entry_1c07a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c07a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c07ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c07b0; return;
}


// Function: KillSoundSystem__Fv
// Address: 0x1c07b0 - 0x1c07c0

void entry_1c07c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07c0: 0xc070202
    SET_GPR_U32(ctx, 31, 0x1c07c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    KillSounds__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1c07c8
// Address: 0x1c07c8 - 0x1c07d0

void entry_1c07c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07c8: 0xc06fb92
    SET_GPR_U32(ctx, 31, 0x1c07d0);
    KillExcitement__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c07d0
// Address: 0x1c07d0 - 0x1c07d8

void entry_1c07d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07d0: 0xc07032c
    SET_GPR_U32(ctx, 31, 0x1c07d8);
    FUN_001c0cb0__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c07d8
// Address: 0x1c07d8 - 0x1c07e0

void entry_1c07d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07d8: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1c07e0);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1c07e0
// Address: 0x1c07e0 - 0x1c07f0

void entry_1c07e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07e0: 0x1440fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c07d8(rdram, ctx, runtime); return;
    }
    // 0x1c07e8: 0xc047844
    SET_GPR_U32(ctx, 31, 0x1c07f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCheckCDIdle(rdram, ctx, runtime); return;
}


// Function: entry_1c07f0
// Address: 0x1c07f0 - 0x1c07f8

void entry_1c07f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07f0: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x1c07f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_1c07f8
// Address: 0x1c07f8 - 0x1c0808

void entry_1c07f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c07f8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c07fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c0804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0808; return;
}


// Function: KillSounds__Fi
// Address: 0x1c0808 - 0x1c086c

void entry_1c086c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c086c) {
        switch (ctx->pc) {
            case 0x1c0888: ctx->pc = 0; goto label_1c0888;
            case 0x1c0890: ctx->pc = 0; goto label_1c0890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c086c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1c0870: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1c0874: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c0878: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1c087c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c0880: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0860; return;
    }
label_1c0888:
    // 0x1c0888: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1c088c: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
label_1c0890:
    // 0x1c0890: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1c0898);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1c0898
// Address: 0x1c0898 - 0x1c08b0

void entry_1c0898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0898: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c089c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c08a0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c08a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c08ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c08b0; return;
}


// Function: PushSwReverb__FP2SW7REVERBKi
// Address: 0x1c08b0 - 0x1c08f8

void entry_1c08f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c08f8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c08fc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c0900: 0xc0478d8
    SET_GPR_U32(ctx, 31, 0x1c0908);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    snd_SetReverbDepth(rdram, ctx, runtime); return;
}


// Function: entry_1c0908
// Address: 0x1c0908 - 0x1c0950

void entry_1c0908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0908) {
        switch (ctx->pc) {
            case 0x1c0934: ctx->pc = 0; goto label_1c0934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0908: 0x8e022348
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9032)));
    // 0x1c090c: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1c0910: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1c0914: 0xac522328
    WRITE32(ADD32(GPR_U32(ctx, 2), 9000), GPR_U32(ctx, 18));
    // 0x1c0918: 0x8e032348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9032)));
    // 0x1c091c: 0x318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1c0920: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1c0924: 0xac71232c
    WRITE32(ADD32(GPR_U32(ctx, 3), 9004), GPR_U32(ctx, 17));
    // 0x1c0928: 0x8e022348
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9032)));
    // 0x1c092c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c0930: 0xae022348
    WRITE32(ADD32(GPR_U32(ctx, 16), 9032), GPR_U32(ctx, 2));
label_1c0934:
    // 0x1c0934: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c0938: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c093c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0940: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c094c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0950; return;
}


// Function: PopSwReverb__FP2SW
// Address: 0x1c0950 - 0x1c09a4

void entry_1c09a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c09a4: 0x8e022348
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9032)));
    // 0x1c09a8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c09ac: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c09b0: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1c09b4: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1c09b8: 0x8c45232c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9004)));
    // 0x1c09bc: 0xc0478d8
    SET_GPR_U32(ctx, 31, 0x1c09c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    snd_SetReverbDepth(rdram, ctx, runtime); return;
}


// Function: entry_1c09c4
// Address: 0x1c09c4 - 0x1c09d8

void entry_1c09c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c09c4) {
        switch (ctx->pc) {
            case 0x1c09c8: ctx->pc = 0; goto label_1c09c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c09c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c09c8:
    // 0x1c09c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c09cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c09d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c09d8; return;
}


// Function: SetSwDefaultReverb__FP2SW7REVERBKi
// Address: 0x1c09d8 - 0x1c0a14

void entry_1c0a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0a14: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c0a18: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c0a1c: 0xc0478d8
    SET_GPR_U32(ctx, 31, 0x1c0a24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    snd_SetReverbDepth(rdram, ctx, runtime); return;
}


// Function: entry_1c0a24
// Address: 0x1c0a24 - 0x1c0a50

void entry_1c0a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0a24: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c0a28: 0xae322328
    WRITE32(ADD32(GPR_U32(ctx, 17), 9000), GPR_U32(ctx, 18));
    // 0x1c0a2c: 0xae30232c
    WRITE32(ADD32(GPR_U32(ctx, 17), 9004), GPR_U32(ctx, 16));
    // 0x1c0a30: 0xae222348
    WRITE32(ADD32(GPR_U32(ctx, 17), 9032), GPR_U32(ctx, 2));
    // 0x1c0a34: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c0a38: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c0a3c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0a40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0a44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c0a4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0a50; return;
}


// Function: FUN_001C0A50
// Address: 0x1c0a50 - 0x1c0ab8

void FUN_001C0A50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0a50) {
        switch (ctx->pc) {
            case 0x1c0ab0: ctx->pc = 0; goto label_1c0ab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0a50: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c0a54: 0x8cc41d80
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 7552)));
    // 0x1c0a58: 0x28820010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 16));
    // 0x1c0a5c: 0x10400014
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c0ab0;
    }
    // 0x1c0a64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c0a68: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c0a6c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c0a70: 0x24631d84
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 7556));
    // 0x1c0a74: 0xc31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1c0a78: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x1c0a7c: 0x24494820
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 2), 18464));
    // 0x1c0a80: 0x69250007
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1c0a84: 0x6d250000
    { uint32_t addr = ADD32(GPR_U32(ctx, 9), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1c0a88: 0xb065000b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 11); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c0a8c: 0xb4650004
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 4); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c0a90: 0x24884828
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 4), 18472));
    // 0x1c0a94: 0x69020007
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c0a98: 0x6d020000
    { uint32_t addr = ADD32(GPR_U32(ctx, 8), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c0a9c: 0xb0620013
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 19); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c0aa0: 0xb462000c
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 12); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c0aa4: 0x8cc21d80
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 7552)));
    // 0x1c0aa8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c0aac: 0xacc21d80
    WRITE32(ADD32(GPR_U32(ctx, 6), 7552), GPR_U32(ctx, 2));
label_1c0ab0:
    // 0x1c0ab0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001C0AB8
// Address: 0x1c0ab8 - 0x1c0b08

void FUN_001C0AB8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0ab8) {
        switch (ctx->pc) {
            case 0x1c0b00: ctx->pc = 0; goto label_1c0b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0ab8: 0x8c831d80
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 7552)));
    // 0x1c0abc: 0x10600010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c0b00;
    }
    // 0x1c0ac4: 0xc4a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c0ac8: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1c0acc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c0ad0: 0x621018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c0ad4: 0x3c0145fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17914 << 16));
    // 0x1c0ad8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c0adc: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1c0ae0: 0x24421d70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7536));
    // 0x1c0ae4: 0x46011041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1c0ae8: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c0aec: 0xe441000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x1c0af0: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1c0af4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1c0af8: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1c0afc: 0xe4420010
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
label_1c0b00:
    // 0x1c0b00: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001C0B08
// Address: 0x1c0b08 - 0x1c0b38

void FUN_001C0B08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0b08) {
        switch (ctx->pc) {
            case 0x1c0b30: ctx->pc = 0; goto label_1c0b30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0b08: 0x8c831d80
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 7552)));
    // 0x1c0b0c: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c0b30;
    }
    // 0x1c0b14: 0x621018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c0b18: 0x24421d70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 7536));
    // 0x1c0b1c: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c0b20: 0x68a30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c0b24: 0x6ca30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c0b28: 0xb043000b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 11); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c0b2c: 0xb4430004
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 4); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
label_1c0b30:
    // 0x1c0b30: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartSwIntermittentSounds__FP2SW
// Address: 0x1c0b38 - 0x1c0bc4

void entry_1c0bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0bc4) {
        switch (ctx->pc) {
            case 0x1c0bdc: ctx->pc = 0; goto label_1c0bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0bc4: 0x26520014
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 20));
    // 0x1c0bc8: 0x8e821d80
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 7552)));
    // 0x1c0bcc: 0x26310014
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 20));
    // 0x1c0bd0: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1c0bd4: 0x1440ffea
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0B80; return;
    }
label_1c0bdc:
    // 0x1c0bdc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c0be0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c0be4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c0be8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c0bec: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c0bf0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0bf4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0bf8: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1c0bfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c0c04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0c08; return;
}


// Function: FUN_001c0c08
// Address: 0x1c0c08 - 0x1c0c44

void FUN_001c0c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0c08: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1c0c0c: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c0c10: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x1c0c14: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1c0c18: 0x244253e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 21472));
    // 0x1c0c1c: 0x71880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1c0c20: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c0c24: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c0c28: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c0c2c: 0x10c20005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        entry_1c0c44(rdram, ctx, runtime); return;
    }
    // 0x1c0c34: 0xac660000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 6));
    // 0x1c0c38: 0x8c444728
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 18216)));
    // 0x1c0c3c: 0xc04762c
    SET_GPR_U32(ctx, 31, 0x1c0c44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    snd_SetMIDIRegister(rdram, ctx, runtime); return;
}


// Function: entry_1c0c44
// Address: 0x1c0c44 - 0x1c0c50

void entry_1c0c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0c44: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0c48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c0c50
// Address: 0x1c0c50 - 0x1c0c68

void FUN_001c0c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0c50: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x1c0c54: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c0c58: 0x244253e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 21472));
    // 0x1c0c5c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c0c60: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c0c68
// Address: 0x1c0c68 - 0x1c0c88

void FUN_001c0c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0c68: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c0c6c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c0c70: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c0c74: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c0c78: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c0c7c: 0x8c444728
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 18216)));
    // 0x1c0c80: 0xc04763c
    SET_GPR_U32(ctx, 31, 0x1c0c88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    snd_GetMIDIRegister(rdram, ctx, runtime); return;
}


// Function: entry_1c0c88
// Address: 0x1c0c88 - 0x1c0cb0

void entry_1c0c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0c88: 0x3c030060
    SET_GPR_U32(ctx, 3, ((uint32_t)96 << 16));
    // 0x1c0c8c: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1c0c90: 0x246353e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 21472));
    // 0x1c0c94: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0c98: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1c0c9c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1c0ca0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0ca4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c0cac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0cb0; return;
}


// Function: FUN_001c0cb0__Fv
// Address: 0x1c0cb0 - 0x1c0cd0

void FUN_001c0cb0__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c0cb0) {
        switch (ctx->pc) {
            case 0x1c0cc8: ctx->pc = 0; goto label_1c0cc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c0cb0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c0cb4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c0cb8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c0cbc: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0cc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c0cc4: 0x0
    // NOP
label_1c0cc8:
    // 0x1c0cc8: 0xc070302
    SET_GPR_U32(ctx, 31, 0x1c0cd0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001c0c08(rdram, ctx, runtime); return;
}


// Function: entry_1c0cd0
// Address: 0x1c0cd0 - 0x1c0cf0

void entry_1c0cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0cd0: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1c0cd4: 0x2a020008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 8));
    // 0x1c0cd8: 0x1440fffb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C0CC8; return;
    }
    // 0x1c0ce0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0ce4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0ce8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HsNextFootFall__Fv
// Address: 0x1c0cf0 - 0x1c0e70

void entry_1c0e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0e70: 0x8e254830
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 18480)));
    // 0x1c0e74: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1c0e78: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1c0e7c: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1c0e80: 0x24a3000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 12));
    // 0x1c0e84: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c0e88: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1c0e8c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c0e90: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1c0e94: 0x862018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c0e98: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1c0e9c: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1c0ea0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c0ea4: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1c0ea8: 0xae254830
    WRITE32(ADD32(GPR_U32(ctx, 17), 18480), GPR_U32(ctx, 5));
    // 0x1c0eac: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c0eb0: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1c0eb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c0ebc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c0ec0; return;
}


// Function: NextSneakyFootstep__Fv
// Address: 0x1c0ec0 - 0x1c0edc

void entry_1c0edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0edc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c0ee0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1c0ee4: 0x3c013daa
    SET_GPR_U32(ctx, 1, ((uint32_t)15786 << 16));
    // 0x1c0ee8: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1c0eec: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1c0ef0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1c0ef4: 0x24040077
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 119));
    // 0x1c0ef8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c0efc: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1c0f00: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0f04: 0x460f03c2
    ctx->f[15] = FPU_MUL_S(ctx->f[0], ctx->f[15]);
    // 0x1c0f08: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0f0c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0f10: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1c0f14: 0x46006406
    ctx->f[16] = FPU_MOV_S(ctx->f[12]);
    // 0x1c0f18: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c0f1c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1c0f24);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1c0f24
// Address: 0x1c0f24 - 0x1c0f30

void entry_1c0f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0f24: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c0f28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSpeaker__FP7SPEAKER
// Address: 0x1c0f30 - 0x1c0f44

void entry_1c0f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c0f44: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1c0f48: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c0f4c: 0x3c028080
    SET_GPR_U32(ctx, 2, ((uint32_t)32896 << 16));
    // 0x1c0f50: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c0f54: 0x34428080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32896));
    // 0x1c0f58: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1c0f5c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1c0f60: 0x70642488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1c0f64: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x1c0f68: 0x70642389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1c0f6c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c0f70: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c0f74: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x1c0f78: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1c0f7c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c0f80: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1c0f84: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1c0f88: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1c0f8c: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1c0f90: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c0f94: 0x3c0142a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17056 << 16));
    // 0x1c0f98: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c0f9c: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x1c0fa0: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1c0fa4: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1c0fa8: 0x70c31c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 6), GPR_VEC(ctx, 3)));
    // 0x1c0fac: 0x44061000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[2]);
    // 0x1c0fb0: 0x70c31b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 6), GPR_VEC(ctx, 3)));
    // 0x1c0fb4: 0xae05032c
    WRITE32(ADD32(GPR_U32(ctx, 16), 812), GPR_U32(ctx, 5));
    // 0x1c0fb8: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x1c0fbc: 0xe60502d8
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 728), *(uint32_t*)&val); }
    // 0x1c0fc0: 0xe6040320
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x1c0fc4: 0xe6030324
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 804), *(uint32_t*)&val); }
    // 0x1c0fc8: 0x7e0402f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 752), GPR_VEC(ctx, 4));
    // 0x1c0fcc: 0x7e030300
    WRITE128(ADD32(GPR_U32(ctx, 16), 768), GPR_VEC(ctx, 3));
    // 0x1c0fd0: 0xe60302d4
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 724), *(uint32_t*)&val); }
    // 0x1c0fd4: 0xe60302dc
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 732), *(uint32_t*)&val); }
    // 0x1c0fd8: 0xe60302e0
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 736), *(uint32_t*)&val); }
    // 0x1c0fdc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c0fe0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c0fe4: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1c0fe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSpeakerLoad__FP7SPEAKER
// Address: 0x1c0ff0 - 0x1c1004

void entry_1c1004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1004: 0x8e05032c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 812)));
    // 0x1c1008: 0xc07040c
    SET_GPR_U32(ctx, 31, 0x1c1010);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSpeakerSmIdle__FP7SPEAKER3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c1010
// Address: 0x1c1010 - 0x1c1020

void entry_1c1010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1010: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c1014: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1c1018: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c1020);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c1020
// Address: 0x1c1020 - 0x1c1030

void entry_1c1020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1020: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c1024: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c1028: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSpeakerSmIdle__FP7SPEAKER3OID
// Address: 0x1c1030 - 0x1c1058

void entry_1c1058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1058) {
        switch (ctx->pc) {
            case 0x1c105c: ctx->pc = 0; goto label_1c105c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1058: 0xae000334
    WRITE32(ADD32(GPR_U32(ctx, 16), 820), GPR_U32(ctx, 0));
label_1c105c:
    // 0x1c105c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c1060: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1c1064: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1068: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1c1070);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c1070
// Address: 0x1c1070 - 0x1c108c

void entry_1c1070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1070: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 816), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1090; return;
    }
    // 0x1c1078: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c107c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1080: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c1084: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1c108c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1c108c
// Address: 0x1c108c - 0x1c10a8

void entry_1c108c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c108c) {
        switch (ctx->pc) {
            case 0x1c1090: ctx->pc = 0; goto label_1c1090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c108c: 0xae020334
    WRITE32(ADD32(GPR_U32(ctx, 16), 820), GPR_U32(ctx, 2));
label_1c1090:
    // 0x1c1090: 0xae11032c
    WRITE32(ADD32(GPR_U32(ctx, 16), 812), GPR_U32(ctx, 17));
    // 0x1c1094: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c1098: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c109c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c10a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSpire__FP5SPIRE
// Address: 0x1c10a8 - 0x1c10bc

void entry_1c10bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c10bc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c10c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c10c4: 0xc440d3b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294955956)); ctx->f[0] = *(float*)&val; }
    // 0x1c10c8: 0xe6000058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x1c10cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c10d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnSpireAdd__FP5SPIRE
// Address: 0x1c10d8 - 0x1c10ec

void entry_1c10ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c10ec: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c10f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c10f4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1c10fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7300));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1c10fc
// Address: 0x1c10fc - 0x1c1110

void entry_1c10fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c10fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c1100: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c1104: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c110c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c1110; return;
}


// Function: OnSpireRemove__FP5SPIRE
// Address: 0x1c1110 - 0x1c1124

void entry_1c1124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1124: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c1128: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c112c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1c1134);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7300));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1c1134
// Address: 0x1c1134 - 0x1c1148

void entry_1c1134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1134: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c1138: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c113c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c1144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c1148; return;
}


// Function: CloneSpire__FP5SPIRET0
// Address: 0x1c1148 - 0x1c1170

void entry_1c1170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1170: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c1174: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c1178: 0xb2020057
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 87); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c117c: 0xb6020050
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 80); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1180: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c1184: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c1188: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadSwSpliceFromBrx__FP2SWP18CBinaryInputStream
// Address: 0x1c1190 - 0x1c11d0

void entry_1c11d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c11d0: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1c11d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c11d8
// Address: 0x1c11d8 - 0x1c11e4

void entry_1c11d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c11d8: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1c11dc: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1c11e4);
    WRITE32(ADD32(GPR_U32(ctx, 19), 7920), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1c11e4
// Address: 0x1c11e4 - 0x1c11f0

void entry_1c11e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c11e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c11e8: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1c11f0);
    WRITE32(ADD32(GPR_U32(ctx, 19), 7924), GPR_U32(ctx, 2));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c11f0
// Address: 0x1c11f0 - 0x1c11fc

void entry_1c11f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c11f0: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c11f4: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1c11fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c11fc
// Address: 0x1c11fc - 0x1c1220

void entry_1c11fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c11fc) {
        switch (ctx->pc) {
            case 0x1c1210: ctx->pc = 0; goto label_1c1210;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c11fc: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1200: 0x8e621ef0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 7920)));
    // 0x1c1204: 0x18400015
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1C125C; return;
    }
    // 0x1c120c: 0x8e701ef4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 7924)));
label_1c1210:
    // 0x1c1210: 0x1210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 3));
    // 0x1c1214: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1218: 0xc046e8a
    SET_GPR_U32(ctx, 31, 0x1c1220);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    PpairSerializeIn__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c1220
// Address: 0x1c1220 - 0x1c1238

void entry_1c1220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1220: 0x8ec35714
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 22292)));
    // 0x1c1224: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1c1228: 0x10600007
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1c1248(rdram, ctx, runtime); return;
    }
    // 0x1c1230: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1c1238);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c1238
// Address: 0x1c1238 - 0x1c1240

void entry_1c1238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1238: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1c1240);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c1240
// Address: 0x1c1240 - 0x1c1248

void entry_1c1240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1240: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1c1248);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c1248
// Address: 0x1c1248 - 0x1c1280

void entry_1c1248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1248) {
        switch (ctx->pc) {
            case 0x1c125c: ctx->pc = 0; goto label_1c125c;
            case 0x1c1278: ctx->pc = 0; goto label_1c1278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1248: 0x8e621ef0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 7920)));
    // 0x1c124c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1c1250: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c1254: 0x5440ffee
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 7924)));
        ctx->pc = 0x1C1210; return;
    }
label_1c125c:
    // 0x1c125c: 0x8ec25714
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 22292)));
    // 0x1c1260: 0x10400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C12A8; return;
    }
    // 0x1c1268: 0x1a800007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1C1288; return;
    }
    // 0x1c1270: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c1274: 0x0
    // NOP
label_1c1278:
    // 0x1c1278: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1c1280);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c1280
// Address: 0x1c1280 - 0x1c12a0

void entry_1c1280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1280) {
        switch (ctx->pc) {
            case 0x1c1288: ctx->pc = 0; goto label_1c1288;
            case 0x1c1298: ctx->pc = 0; goto label_1c1298;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1280: 0x1600fffd
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1278; return;
    }
label_1c1288:
    // 0x1c1288: 0x1ae00007
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x1C12A8; return;
    }
    // 0x1c1290: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1294: 0x0
    // NOP
label_1c1298:
    // 0x1c1298: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1c12a0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1c12a0
// Address: 0x1c12a0 - 0x1c12b0

void entry_1c12a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c12a0) {
        switch (ctx->pc) {
            case 0x1c12a8: ctx->pc = 0; goto label_1c12a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c12a0: 0x5600fffd
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C1298; return;
    }
label_1c12a8:
    // 0x1c12a8: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x1c12b0);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c12b0
// Address: 0x1c12b0 - 0x1c12c4

void entry_1c12b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c12b0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c12b4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c12b8: 0xae62002c
    WRITE32(ADD32(GPR_U32(ctx, 19), 44), GPR_U32(ctx, 2));
    // 0x1c12bc: 0xc0469b0
    SET_GPR_U32(ctx, 31, 0x1c12c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    AddRootFrame__3CGcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1c12c4
// Address: 0x1c12c4 - 0x1c12d4

void entry_1c12c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c12c4: 0xae741ef8
    WRITE32(ADD32(GPR_U32(ctx, 19), 7928), GPR_U32(ctx, 20));
    // 0x1c12c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c12cc: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1c12d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1c12d4
// Address: 0x1c12d4 - 0x1c12e8

void entry_1c12d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c12d4: 0x8e65002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 44)));
    // 0x1c12d8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c12dc: 0x8e661ef8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 7928)));
    // 0x1c12e0: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x1c12e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c12e8
// Address: 0x1c12e8 - 0x1c12f4

void entry_1c12e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c12e8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c12ec: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c12f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c12f4
// Address: 0x1c12f4 - 0x1c1310

void entry_1c12f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c12f4) {
        switch (ctx->pc) {
            case 0x1c1308: ctx->pc = 0; goto label_1c1308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c12f4: 0x8e621ef0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 7920)));
    // 0x1c12f8: 0x18400017
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1C1358; return;
    }
    // 0x1c1300: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c1304: 0x0
    // NOP
label_1c1308:
    // 0x1c1308: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c1310);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1310
// Address: 0x1c1310 - 0x1c1324

void entry_1c1310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1310: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c1314: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c1318: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c131c: 0xc0704fa
    SET_GPR_U32(ctx, 31, 0x1c1324);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    RefEvalModule__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1c1324
// Address: 0x1c1324 - 0x1c1330

void entry_1c1324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1324: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1328: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1330);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1330
// Address: 0x1c1330 - 0x1c133c

void entry_1c1330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1330: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1334: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c133c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c133c
// Address: 0x1c133c - 0x1c1348

void entry_1c133c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c133c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1340: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1348);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1348
// Address: 0x1c1348 - 0x1c1364

void entry_1c1348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1348) {
        switch (ctx->pc) {
            case 0x1c1358: ctx->pc = 0; goto label_1c1358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1348: 0x8e621ef0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 7920)));
    // 0x1c134c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c1350: 0x1440ffed
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1308; return;
    }
label_1c1358:
    // 0x1c1358: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c135c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1364);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1364
// Address: 0x1c1364 - 0x1c1390

void entry_1c1364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1364: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c1368: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c136c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c1370: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c1374: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c1378: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c137c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c1380: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1384: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c1388: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PframeFromIsplice__FiP2SW
// Address: 0x1c1390 - 0x1c13d0

void entry_1c13d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c13d0) {
        switch (ctx->pc) {
            case 0x1c13d4: ctx->pc = 0; goto label_1c13d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c13d0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c13d4:
    // 0x1c13d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c13d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c13dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c13e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c13e8; return;
}


// Function: RefEvalModule__FiP2SW
// Address: 0x1c13e8 - 0x1c1414

void entry_1c1414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1414: 0x8e231ef4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 7924)));
    // 0x1c1418: 0x2431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1c141c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c1420: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C1480; return;
    }
    // 0x1c1428: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1c142c: 0x54400014
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C1480; return;
    }
    // 0x1c1434: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x1c143c);
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c143c
// Address: 0x1c143c - 0x1c1464

void entry_1c143c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c143c: 0x8e231ef4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 7924)));
    // 0x1c1440: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c1444: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1448: 0x2431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1c144c: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x1c1450: 0x8e221ef4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 7924)));
    // 0x1c1454: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1c1458: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c145c: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1c1464);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1c1464
// Address: 0x1c1464 - 0x1c1470

void entry_1c1464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1464: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1468: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1470);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1470
// Address: 0x1c1470 - 0x1c147c

void entry_1c1470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1470: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1474: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c147c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c147c
// Address: 0x1c147c - 0x1c1488

void entry_1c147c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c147c) {
        switch (ctx->pc) {
            case 0x1c1480: ctx->pc = 0; goto label_1c1480;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c147c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c1480:
    // 0x1c1480: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1c1488);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1c1488
// Address: 0x1c1488 - 0x1c1494

void entry_1c1488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1488: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c148c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c1494);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1494
// Address: 0x1c1494 - 0x1c14a0

void entry_1c1494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1494: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1498: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c14a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c14a0
// Address: 0x1c14a0 - 0x1c14c0

void entry_1c14a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c14a0: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c14a4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c14a8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c14ac: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c14b0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c14b4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c14b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PeopidFind__FP5BASICi
// Address: 0x1c14c0 - 0x1c1530

void entry_1c1560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1560: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c1564: 0xafb10010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 17));
    // 0x1c1568: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c156c: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x1c1570: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1578);
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1578
// Address: 0x1c1578 - 0x1c158c

void entry_1c1578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1578: 0x8fa50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1c157c: 0x10a00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1594; return;
    }
    // 0x1c1584: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1c158c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1c158c
// Address: 0x1c158c - 0x1c159c

void entry_1c158c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c158c) {
        switch (ctx->pc) {
            case 0x1c1594: ctx->pc = 0; goto label_1c1594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c158c: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C15A0; return;
    }
label_1c1594:
    // 0x1c1594: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1c159c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1c159c
// Address: 0x1c159c - 0x1c15a8

void entry_1c159c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c159c) {
        switch (ctx->pc) {
            case 0x1c15a0: ctx->pc = 0; goto label_1c15a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c159c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c15a0:
    // 0x1c15a0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c15a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c15a8
// Address: 0x1c15a8 - 0x1c15b4

void entry_1c15a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c15a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c15ac: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c15b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c15b4
// Address: 0x1c15b4 - 0x1c15d8

void entry_1c15b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c15b4: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c15b8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c15bc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c15c0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c15c4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c15c8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c15cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c15d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c15d8; return;
}


// Function: RefGetPeopid__FP5BASICP5EOPID
// Address: 0x1c15d8 - 0x1c1608

void entry_1c1608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1608: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c160c: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x1c1610: 0x1040000d
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1648; return;
    }
    // 0x1c1618: 0xc046b9e
    SET_GPR_U32(ctx, 31, 0x1c1620);
    PmethodNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1620
// Address: 0x1c1620 - 0x1c1640

void entry_1c1620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1620: 0xac530000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 19));
    // 0x1c1624: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1628: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c162c: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1c1630: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x1c1634: 0x8e060014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c1638: 0xc046e3a
    SET_GPR_U32(ctx, 31, 0x1c1640);
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 6));
    SetMethod__4CRefP7CMethod(rdram, ctx, runtime); return;
}


// Function: entry_1c1640
// Address: 0x1c1640 - 0x1c1664

void entry_1c1640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1640) {
        switch (ctx->pc) {
            case 0x1c1648: ctx->pc = 0; goto label_1c1648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1640: 0x100000ea
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c1648:
    // 0x1c1648: 0x1040005a
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4096));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C17B4; return;
    }
    // 0x1c1650: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1670; return;
    }
    // 0x1c1658: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1c165c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c1664);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c1664
// Address: 0x1c1664 - 0x1c16c4

void entry_1c1664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1664) {
        switch (ctx->pc) {
            case 0x1c1670: ctx->pc = 0; goto label_1c1670;
            case 0x1c1678: ctx->pc = 0; goto label_1c1678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1664: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1c1668: 0x10000003
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1678;
    }
label_1c1670:
    // 0x1c1670: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1c1674: 0x2628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
label_1c1678:
    // 0x1c1678: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c167c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1680: 0x2c420012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 18));
    // 0x1c1684: 0x1040003f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1784; return;
    }
    // 0x1c168c: 0x71880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1c1690: 0x2442d3c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955968));
    // 0x1c1694: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c1698: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c169c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c16a4: 0x100000c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19B8; return;
    }
    // 0x1c16ac: 0x10000066
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1848; return;
    }
    // 0x1c16b4: 0x1000006c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1868; return;
    }
    // 0x1c16bc: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1c16c4);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c16c4
// Address: 0x1c16c4 - 0x1c16d8

void entry_1c16c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c16c4: 0x7a230000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c16c8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c16cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c16d0: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1c16d8);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c16d8
// Address: 0x1c16d8 - 0x1c16e8

void entry_1c16d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c16d8: 0x100000c4
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c16e0: 0xc047186
    SET_GPR_U32(ctx, 31, 0x1c16e8);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c16e8
// Address: 0x1c16e8 - 0x1c16f8

void entry_1c16e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c16e8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c16ec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c16f0: 0xc062138
    SET_GPR_U32(ctx, 31, 0x1c16f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__7MATRIX4RC7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c16f8
// Address: 0x1c16f8 - 0x1c1708

void entry_1c16f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c16f8: 0x10000073
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C18C8; return;
    }
    // 0x1c1700: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x1c1708);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1708
// Address: 0x1c1708 - 0x1c171c

void entry_1c1708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1708: 0x7a230000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c170c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1710: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1714: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x1c171c);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_1c171c
// Address: 0x1c171c - 0x1c172c

void entry_1c171c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c171c: 0x100000b3
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1724: 0xc047216
    SET_GPR_U32(ctx, 31, 0x1c172c);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c172c
// Address: 0x1c172c - 0x1c1748

void entry_1c172c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c172c: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1730: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1734: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1738: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c173c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1740: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x1c1748);
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1c1748
// Address: 0x1c1748 - 0x1c1758

void entry_1c1748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1748: 0x100000a8
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1750: 0xc04725a
    SET_GPR_U32(ctx, 31, 0x1c1758);
    PsmpNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1758
// Address: 0x1c1758 - 0x1c177c

void entry_1c1758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1758: 0x6a230007
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c175c: 0x6e230000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1760: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1c1764: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1768: 0xb4430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c176c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1770: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1774: 0xc046e18
    SET_GPR_U32(ctx, 31, 0x1c177c);
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 6));
    SetSmp__4CRefP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1c177c
// Address: 0x1c177c - 0x1c17ac

void entry_1c177c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c177c) {
        switch (ctx->pc) {
            case 0x1c1784: ctx->pc = 0; goto label_1c1784;
            case 0x1c1798: ctx->pc = 0; goto label_1c1798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c177c: 0x1000009b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c1784:
    // 0x1c1784: 0x30e21000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 4096));
    // 0x1c1788: 0x10400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 8192));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c1798;
    }
    // 0x1c1790: 0x10000089
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19B8; return;
    }
label_1c1798:
    // 0x1c1798: 0x50400094
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c17a0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c17a4: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x1c17ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_1c17ac
// Address: 0x1c17ac - 0x1c17c8

void entry_1c17ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c17ac) {
        switch (ctx->pc) {
            case 0x1c17b4: ctx->pc = 0; goto label_1c17b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c17ac: 0x1000008f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c17b4:
    // 0x1c17b4: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C17D0; return;
    }
    // 0x1c17bc: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1c17c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c17c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c17c8
// Address: 0x1c17c8 - 0x1c1830

void entry_1c17c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c17c8) {
        switch (ctx->pc) {
            case 0x1c17d0: ctx->pc = 0; goto label_1c17d0;
            case 0x1c17d4: ctx->pc = 0; goto label_1c17d4;
            case 0x1c17ec: ctx->pc = 0; goto label_1c17ec;
            case 0x1c17f8: ctx->pc = 0; goto label_1c17f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c17c8: 0x10000002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c17d4;
    }
label_1c17d0:
    // 0x1c17d0: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1c17d4:
    // 0x1c17d4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c17d8: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1c17dc: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        goto label_1c17ec;
    }
    // 0x1c17e4: 0x10000004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c17f8;
    }
label_1c17ec:
    // 0x1c17ec: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1c17f0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c17f4: 0x8c520000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1c17f8:
    // 0x1c17f8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c17fc: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1800: 0x2c420012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 18));
    // 0x1c1804: 0x10400055
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C195C; return;
    }
    // 0x1c180c: 0x71880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1c1810: 0x2442d410
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956048));
    // 0x1c1814: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c1818: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c181c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c1824: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1828: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1830);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1830
// Address: 0x1c1830 - 0x1c1844

void entry_1c1830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1830: 0x10000061
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19B8; return;
    }
    // 0x1c1838: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c183c: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1844);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 36));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1844
// Address: 0x1c1844 - 0x1c1850

void entry_1c1844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1844) {
        switch (ctx->pc) {
            case 0x1c1848: ctx->pc = 0; goto label_1c1848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1844: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
label_1c1848:
    // 0x1c1848: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1c1850);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1c1850
// Address: 0x1c1850 - 0x1c1864

void entry_1c1850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1850: 0x10000066
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1858: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c185c: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1864);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 40));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1864
// Address: 0x1c1864 - 0x1c1870

void entry_1c1864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1864) {
        switch (ctx->pc) {
            case 0x1c1868: ctx->pc = 0; goto label_1c1868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1864: 0x8fa50028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 40)));
label_1c1868:
    // 0x1c1868: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1c1870);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1c1870
// Address: 0x1c1870 - 0x1c1880

void entry_1c1870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1870: 0x1000005e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1878: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1c1880);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1880
// Address: 0x1c1880 - 0x1c1890

void entry_1c1880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1880: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1884: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1888: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1890);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1890
// Address: 0x1c1890 - 0x1c189c

void entry_1c1890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1890: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1894: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1c189c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c189c
// Address: 0x1c189c - 0x1c18ac

void entry_1c189c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c189c: 0x10000053
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c18a4: 0xc047186
    SET_GPR_U32(ctx, 31, 0x1c18ac);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c18ac
// Address: 0x1c18ac - 0x1c18bc

void entry_1c18ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18ac: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c18b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c18b4: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c18bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c18bc
// Address: 0x1c18bc - 0x1c18c4

void entry_1c18bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18bc: 0xc062130
    SET_GPR_U32(ctx, 31, 0x1c18c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1c18c4
// Address: 0x1c18c4 - 0x1c18d0

void entry_1c18c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c18c4) {
        switch (ctx->pc) {
            case 0x1c18c8: ctx->pc = 0; goto label_1c18c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c18c4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c18c8:
    // 0x1c18c8: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x1c18d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1c18d0
// Address: 0x1c18d0 - 0x1c18e0

void entry_1c18d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18d0: 0x10000046
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c18d8: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x1c18e0);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c18e0
// Address: 0x1c18e0 - 0x1c18f0

void entry_1c18e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c18e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c18e8: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c18f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c18f0
// Address: 0x1c18f0 - 0x1c18fc

void entry_1c18f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c18f4: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x1c18fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_1c18fc
// Address: 0x1c18fc - 0x1c190c

void entry_1c18fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c18fc: 0x1000003b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1904: 0xc047216
    SET_GPR_U32(ctx, 31, 0x1c190c);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c190c
// Address: 0x1c190c - 0x1c191c

void entry_1c190c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c190c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1910: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1914: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c191c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c191c
// Address: 0x1c191c - 0x1c1928

void entry_1c191c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c191c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1920: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x1c1928);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1c1928
// Address: 0x1c1928 - 0x1c1938

void entry_1c1928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1928: 0x10000030
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c1930: 0xc04725a
    SET_GPR_U32(ctx, 31, 0x1c1938);
    PsmpNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1938
// Address: 0x1c1938 - 0x1c1948

void entry_1c1938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1938: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c193c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1940: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c1948);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c1948
// Address: 0x1c1948 - 0x1c1954

void entry_1c1948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1948: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c194c: 0xc046e18
    SET_GPR_U32(ctx, 31, 0x1c1954);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetSmp__4CRefP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1c1954
// Address: 0x1c1954 - 0x1c1984

void entry_1c1954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1954) {
        switch (ctx->pc) {
            case 0x1c195c: ctx->pc = 0; goto label_1c195c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1954: 0x10000025
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c195c:
    // 0x1c195c: 0x4e10011
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 4096));
    if (GPR_S32(ctx, 7) >= 0) {
        ctx->pc = 0x1C19A4; return;
    }
    // 0x1c1964: 0x3c067fff
    SET_GPR_U32(ctx, 6, ((uint32_t)32767 << 16));
    // 0x1c1968: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c196c: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x1c1970: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c1974: 0xe63024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x1c1978: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c197c: 0xc07054c
    SET_GPR_U32(ctx, 31, 0x1c1984);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefGetObjectList__FP5BASIC4OTYPPFPv_v(rdram, ctx, runtime); return;
}


// Function: entry_1c1984
// Address: 0x1c1984 - 0x1c1990

void entry_1c1984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1984: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1988: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1990);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1990
// Address: 0x1c1990 - 0x1c199c

void entry_1c1990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1990: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1994: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c199c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c199c
// Address: 0x1c199c - 0x1c19b4

void entry_1c199c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c199c) {
        switch (ctx->pc) {
            case 0x1c19a4: ctx->pc = 0; goto label_1c19a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c199c: 0x10000013
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c19a4:
    // 0x1c19a4: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19C8; return;
    }
    // 0x1c19ac: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c19b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 44));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c19b4
// Address: 0x1c19b4 - 0x1c19c0

void entry_1c19b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c19b4) {
        switch (ctx->pc) {
            case 0x1c19b8: ctx->pc = 0; goto label_1c19b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c19b4: 0x8fa5002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 44)));
label_1c19b8:
    // 0x1c19b8: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1c19c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1c19c0
// Address: 0x1c19c0 - 0x1c19dc

void entry_1c19c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c19c0) {
        switch (ctx->pc) {
            case 0x1c19c8: ctx->pc = 0; goto label_1c19c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c19c0: 0x1000000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C19EC; return;
    }
label_1c19c8:
    // 0x1c19c8: 0x30e22000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), 8192));
    // 0x1c19cc: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C19EC; return;
    }
    // 0x1c19d4: 0x240f809
    SET_GPR_U32(ctx, 31, 0x1c19dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 18); return;
}


// Function: entry_1c19dc
// Address: 0x1c19dc - 0x1c19e8

void entry_1c19dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c19dc: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c19e0: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x1c19e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_1c19e8
// Address: 0x1c19e8 - 0x1c19f4

void entry_1c19e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c19e8) {
        switch (ctx->pc) {
            case 0x1c19ec: ctx->pc = 0; goto label_1c19ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c19e8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c19ec:
    // 0x1c19ec: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c19f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c19f4
// Address: 0x1c19f4 - 0x1c1a00

void entry_1c19f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c19f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c19f8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1a00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1a00
// Address: 0x1c1a00 - 0x1c1a28

void entry_1c1a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1a00: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c1a04: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c1a08: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c1a0c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c1a10: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c1a14: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c1a18: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1a1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c1a24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c1a28; return;
}


// Function: FAppendSpliceListElement__FPvT0
// Address: 0x1c1a28 - 0x1c1a58

void entry_1c1a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1a58: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1c1a5c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c1a60: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c1a64: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1c1a68: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1c1a70);
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c1a70
// Address: 0x1c1a70 - 0x1c1a88

void entry_1c1a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1a70: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c1a74: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1a78: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1a7c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1a80: 0xc070576
    SET_GPR_U32(ctx, 31, 0x1c1a88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefGetPeopid__FP5BASICP5EOPID(rdram, ctx, runtime); return;
}


// Function: entry_1c1a88
// Address: 0x1c1a88 - 0x1c1a94

void entry_1c1a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1a88: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c1a8c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1a94);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1a94
// Address: 0x1c1a94 - 0x1c1aa0

void entry_1c1a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1a94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1a98: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1aa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1aa0
// Address: 0x1c1aa0 - 0x1c1ad8

void entry_1c1aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1aa0) {
        switch (ctx->pc) {
            case 0x1c1ab4: ctx->pc = 0; goto label_1c1ab4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1aa0: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1c1aa4: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 18));
        goto label_1c1ab4;
    }
    // 0x1c1aac: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1c1ab0: 0xac520008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 18));
label_1c1ab4:
    // 0x1c1ab4: 0xae720008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 18));
    // 0x1c1ab8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c1abc: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c1ac0: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c1ac4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c1ac8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1acc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c1ad0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FSpliceListElementExists__FPvT0
// Address: 0x1c1ad8 - 0x1c1afc

void entry_1c1afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1afc: 0x8e500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1c1b00: 0x52000033
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C1BD0; return;
    }
    // 0x1c1b08: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c1b0c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c1b10: 0x2c420012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 18));
    // 0x1c1b14: 0x10400011
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1B5C; return;
    }
    // 0x1c1b1c: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1c1b20: 0x2442d460
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956128));
    // 0x1c1b24: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c1b28: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c1b2c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c1b34: 0xc62c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1c1b38: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1c1b40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1c1b40
// Address: 0x1c1b40 - 0x1c1b54

void entry_1c1b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1b40: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c1ba0(rdram, ctx, runtime); return;
    }
    // 0x1c1b48: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c1b4c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1c1b54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1c1b54
// Address: 0x1c1b54 - 0x1c1b74

void entry_1c1b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1b54) {
        switch (ctx->pc) {
            case 0x1c1b5c: ctx->pc = 0; goto label_1c1b5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1b54: 0x10000012
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c1ba0(rdram, ctx, runtime); return;
    }
label_1c1b5c:
    // 0x1c1b5c: 0x30a21000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 4096));
    // 0x1c1b60: 0x1040000a
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 8192));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1B8C; return;
    }
    // 0x1c1b68: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c1b6c: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1c1b74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1c1b74
// Address: 0x1c1b74 - 0x1c1b84

void entry_1c1b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1b74) {
        switch (ctx->pc) {
            case 0x1c1b7c: ctx->pc = 0; goto label_1c1b7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1b74: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c1ba0(rdram, ctx, runtime); return;
    }
label_1c1b7c:
    // 0x1c1b7c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1b84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1b84
// Address: 0x1c1b84 - 0x1c1ba0

void entry_1c1b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1b84) {
        switch (ctx->pc) {
            case 0x1c1b8c: ctx->pc = 0; goto label_1c1b8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1b84: 0x10000015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1BDC; return;
    }
label_1c1b8c:
    // 0x1c1b8c: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c1ba0(rdram, ctx, runtime); return;
    }
    // 0x1c1b94: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c1b98: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x1c1ba0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_1c1ba0
// Address: 0x1c1ba0 - 0x1c1bb8

void entry_1c1ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1ba0) {
        switch (ctx->pc) {
            case 0x1c1bb0: ctx->pc = 0; goto label_1c1bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1ba0: 0x1200000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1BD0; return;
    }
    // 0x1c1ba8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1bac: 0x0
    // NOP
label_1c1bb0:
    // 0x1c1bb0: 0xc046c3e
    SET_GPR_U32(ctx, 31, 0x1c1bb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___eq__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1bb8
// Address: 0x1c1bb8 - 0x1c1bd8

void entry_1c1bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1bb8) {
        switch (ctx->pc) {
            case 0x1c1bd0: ctx->pc = 0; goto label_1c1bd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1bb8: 0x1440fff0
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1B7C; return;
    }
    // 0x1c1bc0: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1c1bc4: 0x1600fffa
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1BB0; return;
    }
    // 0x1c1bcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c1bd0:
    // 0x1c1bd0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1bd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1bd8
// Address: 0x1c1bd8 - 0x1c1bf8

void entry_1c1bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1bd8) {
        switch (ctx->pc) {
            case 0x1c1bdc: ctx->pc = 0; goto label_1c1bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1bd8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1c1bdc:
    // 0x1c1bdc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1be0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c1be4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c1be8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c1bec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c1bf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c1bf8; return;
}


// Function: RefSetPvsFromSplice__FiP4CRefP4OTYPPPv
// Address: 0x1c1bf8 - 0x1c1c44

void entry_1c1c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1c44) {
        switch (ctx->pc) {
            case 0x1c1c50: ctx->pc = 0; goto label_1c1c50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1c44: 0x1a80006b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1C1DF4; return;
    }
    // 0x1c1c4c: 0x1328c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 19), 3));
label_1c1c50:
    // 0x1c1c50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1c54: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1c5c);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 5)));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1c5c
// Address: 0x1c1c5c - 0x1c1cac

void entry_1c1c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1c5c: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x1c1c60: 0x761021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 22)));
    // 0x1c1c64: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c1c68: 0x751821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1c1c6c: 0x2ca20015
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 21));
    // 0x1c1c70: 0x10400053
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1DC0; return;
    }
    // 0x1c1c78: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c1c7c: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1c1c80: 0x2442d4b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956208));
    // 0x1c1c84: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c1c88: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c1c8c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c1c94: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c1c98: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1c1c9c: 0x1062004e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C1DD8; return;
    }
    // 0x1c1ca4: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c1cac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1cac
// Address: 0x1c1cac - 0x1c1cbc

void entry_1c1cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1cac: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c1cb0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1cb4: 0xc046e4a
    SET_GPR_U32(ctx, 31, 0x1c1cbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceS32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1cbc
// Address: 0x1c1cbc - 0x1c1cc8

void entry_1c1cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1cbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1cc0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1cc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1cc8
// Address: 0x1c1cc8 - 0x1c1cd4

void entry_1c1cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1cc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1ccc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1cd4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1cd4
// Address: 0x1c1cd4 - 0x1c1ce8

void entry_1c1cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1cd4: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1c1cd8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1cdc: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c1ce0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1ce8);
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1ce8
// Address: 0x1c1ce8 - 0x1c1d14

void entry_1c1ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1ce8) {
        switch (ctx->pc) {
            case 0x1c1d0c: ctx->pc = 0; goto label_1c1d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1ce8: 0x1000003e
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1DE4; return;
    }
    // 0x1c1cf0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c1cf4: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1c1cf8: 0x14620004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c1d0c;
    }
    // 0x1c1d00: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c1d04: 0x10000036
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1DE0; return;
    }
label_1c1d0c:
    // 0x1c1d0c: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c1d14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1d14
// Address: 0x1c1d14 - 0x1c1d24

void entry_1c1d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1d14: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c1d18: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1d1c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1c1d24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1d24
// Address: 0x1c1d24 - 0x1c1d30

void entry_1c1d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1d24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1d28: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1d30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1d30
// Address: 0x1c1d30 - 0x1c1d3c

void entry_1c1d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1d30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1d34: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1d3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1d3c
// Address: 0x1c1d3c - 0x1c1d50

void entry_1c1d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1d3c: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1c1d40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1d44: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c1d48: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1d50);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1d50
// Address: 0x1c1d50 - 0x1c1dfc

void entry_1c1d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1d50) {
        switch (ctx->pc) {
            case 0x1c1dc0: ctx->pc = 0; goto label_1c1dc0;
            case 0x1c1dd8: ctx->pc = 0; goto label_1c1dd8;
            case 0x1c1ddc: ctx->pc = 0; goto label_1c1ddc;
            case 0x1c1de0: ctx->pc = 0; goto label_1c1de0;
            case 0x1c1de4: ctx->pc = 0; goto label_1c1de4;
            case 0x1c1df4: ctx->pc = 0; goto label_1c1df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1d50: 0x10000024
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1de4;
    }
    // 0x1c1d58: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1c1d5c: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c1d60: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x1c1d64: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1c1d68: 0x7e430010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 3));
    // 0x1c1d6c: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1c1d70: 0x1000001b
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1de0;
    }
    // 0x1c1d78: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1c1d7c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c1d80: 0x10000017
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1de0;
    }
    // 0x1c1d88: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1c1d8c: 0x68430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1d90: 0x6c430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1d94: 0xb2430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1d98: 0x10000011
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1de0;
    }
    // 0x1c1da0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1c1da4: 0x68430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1da8: 0x6c430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c1dac: 0x8c440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1c1db0: 0xb2430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1db4: 0xb6430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c1db8: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1de0;
    }
label_1c1dc0:
    // 0x1c1dc0: 0x30a21000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 4096));
    // 0x1c1dc4: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c1ddc;
    }
    // 0x1c1dcc: 0x30a22000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 8192));
    // 0x1c1dd0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        goto label_1c1de4;
    }
label_1c1dd8:
    // 0x1c1dd8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1c1ddc:
    // 0x1c1ddc: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_1c1de0:
    // 0x1c1de0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1c1de4:
    // 0x1c1de4: 0x274102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 20)));
    // 0x1c1de8: 0x5440ff99
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 19), 3));
        ctx->pc = 0x1C1C50; return;
    }
    // 0x1c1df0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c1df4:
    // 0x1c1df4: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1c1dfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1c1dfc
// Address: 0x1c1dfc - 0x1c1e08

void entry_1c1dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1dfc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1e00: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c1e08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1e08
// Address: 0x1c1e08 - 0x1c1e14

void entry_1c1e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1e08: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1e0c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1e14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1e14
// Address: 0x1c1e14 - 0x1c1e48

void entry_1c1e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1e14: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1c1e18: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c1e1c: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1c1e20: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c1e24: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c1e28: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c1e2c: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c1e30: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c1e34: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c1e38: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c1e3c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1e40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefSetArgListFromPvs__FiP4OTYPPPv
// Address: 0x1c1e48 - 0x1c1e7c

void entry_1c1e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1e7c) {
        switch (ctx->pc) {
            case 0x1c1e98: ctx->pc = 0; goto label_1c1e98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1e7c: 0xafa00014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    // 0x1c1e80: 0x1a60000e
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x1C1EBC; return;
    }
    // 0x1c1e88: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1e8c: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c1e90: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c1e94: 0x0
    // NOP
label_1c1e98:
    // 0x1c1e98: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c1e9c: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c1ea0: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1c1ea4: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x1c1ea8: 0xc07068a
    SET_GPR_U32(ctx, 31, 0x1c1eb0);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    FAppendSpliceListElement__FPvT0(rdram, ctx, runtime); return;
}


// Function: entry_1c1eb0
// Address: 0x1c1eb0 - 0x1c1ed0

void entry_1c1eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1eb0) {
        switch (ctx->pc) {
            case 0x1c1ebc: ctx->pc = 0; goto label_1c1ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1eb0: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1c1eb4: 0x5600fff8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1C1E98; return;
    }
label_1c1ebc:
    // 0x1c1ebc: 0x8fa50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1c1ec0: 0x10a00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1ED8; return;
    }
    // 0x1c1ec8: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1c1ed0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1c1ed0
// Address: 0x1c1ed0 - 0x1c1ee0

void entry_1c1ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1ed0) {
        switch (ctx->pc) {
            case 0x1c1ed8: ctx->pc = 0; goto label_1c1ed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1ed0: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1EE4; return;
    }
label_1c1ed8:
    // 0x1c1ed8: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1c1ee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1c1ee0
// Address: 0x1c1ee0 - 0x1c1eec

void entry_1c1ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1ee0) {
        switch (ctx->pc) {
            case 0x1c1ee4: ctx->pc = 0; goto label_1c1ee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1ee0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c1ee4:
    // 0x1c1ee4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c1eec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1eec
// Address: 0x1c1eec - 0x1c1ef8

void entry_1c1eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1eec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1ef0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1ef8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1ef8
// Address: 0x1c1ef8 - 0x1c1f20

void entry_1c1ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1ef8: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c1efc: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c1f00: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c1f04: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c1f08: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c1f0c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c1f10: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c1f14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c1f1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c1f20; return;
}


// Function: RefSetPeopid__FP5BASICP5EOPIDP4CRef
// Address: 0x1c1f20 - 0x1c1f5c

void entry_1c1f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1f5c: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1c1f60: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    // 0x1c1f64: 0x30830010
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 16));
    // 0x1c1f68: 0x1060001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1FDC; return;
    }
    // 0x1c1f70: 0x30821000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 4096));
    // 0x1c1f74: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1F94; return;
    }
    // 0x1c1f7c: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1c1f80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c1f88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c1f88
// Address: 0x1c1f88 - 0x1c1fbc

void entry_1c1f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1f88) {
        switch (ctx->pc) {
            case 0x1c1f94: ctx->pc = 0; goto label_1c1f94;
            case 0x1c1f9c: ctx->pc = 0; goto label_1c1f9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1f88: 0x8e230014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1c1f8c: 0x10000003
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c1f9c;
    }
label_1c1f94:
    // 0x1c1f94: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1c1f98: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
label_1c1f9c:
    // 0x1c1f9c: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x1c1fa0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c1fa4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c1fa8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c1fac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1fb0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c1fb4: 0xc0706fe
    SET_GPR_U32(ctx, 31, 0x1c1fbc);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    RefSetPvsFromSplice__FiP4CRefP4OTYPPPv(rdram, ctx, runtime); return;
}


// Function: entry_1c1fbc
// Address: 0x1c1fbc - 0x1c1fc8

void entry_1c1fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1fbc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c1fc0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c1fc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c1fc8
// Address: 0x1c1fc8 - 0x1c1fd4

void entry_1c1fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c1fc8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c1fcc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c1fd4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c1fd4
// Address: 0x1c1fd4 - 0x1c1ff4

void entry_1c1fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1fd4) {
        switch (ctx->pc) {
            case 0x1c1fdc: ctx->pc = 0; goto label_1c1fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1fd4: 0x10000062
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2160; return;
    }
label_1c1fdc:
    // 0x1c1fdc: 0x30821000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 4096));
    // 0x1c1fe0: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C1FFC; return;
    }
    // 0x1c1fe8: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1c1fec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c1ff4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c1ff4
// Address: 0x1c1ff4 - 0x1c2070

void entry_1c1ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c1ff4) {
        switch (ctx->pc) {
            case 0x1c1ffc: ctx->pc = 0; goto label_1c1ffc;
            case 0x1c2000: ctx->pc = 0; goto label_1c2000;
            case 0x1c2018: ctx->pc = 0; goto label_1c2018;
            case 0x1c2024: ctx->pc = 0; goto label_1c2024;
            case 0x1c2068: ctx->pc = 0; goto label_1c2068;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c1ff4: 0x10000002
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2000;
    }
label_1c1ffc:
    // 0x1c1ffc: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c2000:
    // 0x1c2000: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1c2004: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1c2008: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1c2018;
    }
    // 0x1c2010: 0x10000004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2024;
    }
label_1c2018:
    // 0x1c2018: 0x8e230014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1c201c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c2020: 0x8c540000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1c2024:
    // 0x1c2024: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c2028: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c202c: 0x2c420012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 18));
    // 0x1c2030: 0x1040003d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2128; return;
    }
    // 0x1c2038: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1c203c: 0x2442d510
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956304));
    // 0x1c2040: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c2044: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c2048: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c2050: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c2054: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1c2058: 0x14620003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c2068;
    }
    // 0x1c2060: 0x10000011
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c20a8(rdram, ctx, runtime); return;
    }
label_1c2068:
    // 0x1c2068: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c2070);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2070
// Address: 0x1c2070 - 0x1c2080

void entry_1c2070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2070: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c2074: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c2078: 0xc046e4a
    SET_GPR_U32(ctx, 31, 0x1c2080);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefCoerceS32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2080
// Address: 0x1c2080 - 0x1c208c

void entry_1c2080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2080: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c2084: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c208c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c208c
// Address: 0x1c208c - 0x1c2098

void entry_1c208c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c208c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c2090: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c2098);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c2098
// Address: 0x1c2098 - 0x1c20a8

void entry_1c2098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2098: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c209c: 0x8fb00014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1c20a0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c20a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c20a8
// Address: 0x1c20a8 - 0x1c20b4

void entry_1c20a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c20a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c20ac: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1c20b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1c20b4
// Address: 0x1c20b4 - 0x1c20dc

void entry_1c20b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c20b4) {
        switch (ctx->pc) {
            case 0x1c20d4: ctx->pc = 0; goto label_1c20d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c20b4: 0x1000002a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2160; return;
    }
    // 0x1c20bc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c20c0: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1c20c4: 0x14620003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c20d4;
    }
    // 0x1c20cc: 0x10000011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c2114(rdram, ctx, runtime); return;
    }
label_1c20d4:
    // 0x1c20d4: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c20dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c20dc
// Address: 0x1c20dc - 0x1c20ec

void entry_1c20dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c20dc: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c20e0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c20e4: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1c20ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c20ec
// Address: 0x1c20ec - 0x1c20f8

void entry_1c20ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c20ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c20f0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1c20f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c20f8
// Address: 0x1c20f8 - 0x1c2104

void entry_1c20f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c20f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c20fc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c2104);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c2104
// Address: 0x1c2104 - 0x1c2114

void entry_1c2104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2104: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c2108: 0xc7b40014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[20] = *(float*)&val; }
    // 0x1c210c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c2114);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c2114
// Address: 0x1c2114 - 0x1c2120

void entry_1c2114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2114: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c2118: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1c2120);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1c2120
// Address: 0x1c2120 - 0x1c2140

void entry_1c2120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2120) {
        switch (ctx->pc) {
            case 0x1c2128: ctx->pc = 0; goto label_1c2128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2120: 0x1000000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2160; return;
    }
label_1c2128:
    // 0x1c2128: 0x30a21000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 4096));
    // 0x1c212c: 0x10400006
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 8192));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2148; return;
    }
    // 0x1c2134: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1c2138: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1c2140);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1c2140
// Address: 0x1c2140 - 0x1c215c

void entry_1c2140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2140) {
        switch (ctx->pc) {
            case 0x1c2148: ctx->pc = 0; goto label_1c2148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2140: 0x10000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2160; return;
    }
label_1c2148:
    // 0x1c2148: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C2160; return;
    }
    // 0x1c2150: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1c2154: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1c215c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1c215c
// Address: 0x1c215c - 0x1c2168

void entry_1c215c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c215c) {
        switch (ctx->pc) {
            case 0x1c2160: ctx->pc = 0; goto label_1c2160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c215c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c2160:
    // 0x1c2160: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c2168);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2168
// Address: 0x1c2168 - 0x1c2174

void entry_1c2168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2168: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c216c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c2174);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c2174
// Address: 0x1c2174 - 0x1c21a0

void entry_1c2174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2174: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c2178: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c217c: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c2180: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c2184: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c2188: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c218c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c2190: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c2194: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1c2198: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefGetOption__FP5BASICi
// Address: 0x1c21a0 - 0x1c21d4

void entry_1c21d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c21d4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c21d8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c21dc: 0xc070576
    SET_GPR_U32(ctx, 31, 0x1c21e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefGetPeopid__FP5BASICP5EOPID(rdram, ctx, runtime); return;
}


// Function: entry_1c21e4
// Address: 0x1c21e4 - 0x1c21f4

void entry_1c21e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c21e4) {
        switch (ctx->pc) {
            case 0x1c21ec: ctx->pc = 0; goto label_1c21ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c21e4: 0x1000000e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2220; return;
    }
label_1c21ec:
    // 0x1c21ec: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1c21f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c21f4
// Address: 0x1c21f4 - 0x1c2204

void entry_1c21f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c21f4: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c21f8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c21fc: 0xc046fa4
    SET_GPR_U32(ctx, 31, 0x1c2204);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2204
// Address: 0x1c2204 - 0x1c2210

void entry_1c2204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2204: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c2208: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1c2210);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2210
// Address: 0x1c2210 - 0x1c221c

void entry_1c2210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2210: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c2214: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1c221c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1c221c
// Address: 0x1c221c - 0x1c2238

void entry_1c221c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c221c) {
        switch (ctx->pc) {
            case 0x1c2220: ctx->pc = 0; goto label_1c2220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c221c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1c2220:
    // 0x1c2220: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c2224: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c2228: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c222c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c2230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefSetOption__FP5BASICiP4CRef
// Address: 0x1c2238 - 0x1c226c

void entry_1c226c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c226c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c2270: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c2274: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c2278: 0xc0707c8
    SET_GPR_U32(ctx, 31, 0x1c2280);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefSetPeopid__FP5BASICP5EOPIDP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2280
// Address: 0x1c2280 - 0x1c2298

void entry_1c2280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2280) {
        switch (ctx->pc) {
            case 0x1c2288: ctx->pc = 0; goto label_1c2288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2280: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C229C; return;
    }
label_1c2288:
    // 0x1c2288: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c228c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c2290: 0xc046f74
    SET_GPR_U32(ctx, 31, 0x1c2298);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefSetBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2298
// Address: 0x1c2298 - 0x1c22b8

void entry_1c2298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2298) {
        switch (ctx->pc) {
            case 0x1c229c: ctx->pc = 0; goto label_1c229c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2298: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1c229c:
    // 0x1c229c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c22a0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c22a4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c22a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c22ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c22b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c22b8; return;
}


// Function: RefAddOption__FP5BASICiP4CRef
// Address: 0x1c22b8 - 0x1c22e8

void entry_1c22e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c22e8: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c22ec: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c22f0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c22f4: 0xc046f4a
    SET_GPR_U32(ctx, 31, 0x1c22fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefAddBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c22fc
// Address: 0x1c22fc - 0x1c2320

void entry_1c22fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c22fc: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c2300: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c2304: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c2308: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c230c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c2310: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c2314: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c231c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c2320; return;
}


// Function: RefEnsureOption__FP5BASICiP4CRef
// Address: 0x1c2320 - 0x1c2350

void entry_1c2350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2350: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c2354: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c2358: 0xc046fa4
    SET_GPR_U32(ctx, 31, 0x1c2360);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FFindBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2360
// Address: 0x1c2360 - 0x1c2378

void entry_1c2360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2360: 0x10400007
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2380; return;
    }
    // 0x1c2368: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c236c: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c2370: 0xc046f74
    SET_GPR_U32(ctx, 31, 0x1c2378);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefSetBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2378
// Address: 0x1c2378 - 0x1c2390

void entry_1c2378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2378) {
        switch (ctx->pc) {
            case 0x1c2380: ctx->pc = 0; goto label_1c2380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2378: 0x10000006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C2394; return;
    }
label_1c2380:
    // 0x1c2380: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c2384: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c2388: 0xc046f4a
    SET_GPR_U32(ctx, 31, 0x1c2390);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefAddBinding__8CSidebagiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1c2390
// Address: 0x1c2390 - 0x1c23b0

void entry_1c2390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2390) {
        switch (ctx->pc) {
            case 0x1c2394: ctx->pc = 0; goto label_1c2394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2390: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1c2394:
    // 0x1c2394: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c2398: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c239c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c23a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c23a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c23a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefSetArgsFromSplice__FiP4CRefP4OTYPe
// Address: 0x1c23b0 - 0x1c2418

void entry_1c2418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2418: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c241c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c2420: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c2424: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c242c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c2430; return;
}


// Function: LoadSprBuf__Fie
// Address: 0x1c2430 - 0x1c24c8

void entry_1c24c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c24c8) {
        switch (ctx->pc) {
            case 0x1c24e8: ctx->pc = 0; goto label_1c24e8;
            case 0x1c2530: ctx->pc = 0; goto label_1c2530;
            case 0x1c2538: ctx->pc = 0; goto label_1c2538;
            case 0x1c254c: ctx->pc = 0; goto label_1c254c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c24c8: 0xae54004c
    WRITE32(ADD32(GPR_U32(ctx, 18), 76), GPR_U32(ctx, 20));
    // 0x1c24cc: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1c24d0: 0x1200001e
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 4294967288)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1c254c;
    }
    // 0x1c24d8: 0x240bfff0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 4294967280));
    // 0x1c24dc: 0x3c0a3000
    SET_GPR_U32(ctx, 10, ((uint32_t)12288 << 16));
    // 0x1c24e0: 0x26460008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 8));
    // 0x1c24e4: 0x0
    // NOP
label_1c24e8:
    // 0x1c24e8: 0x24a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    // 0x1c24ec: 0x2602000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 15));
    // 0x1c24f0: 0x8ca9fff8
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 5), 4294967288)));
    // 0x1c24f4: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1c24f8: 0x4b8024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x1c24fc: 0xacd10000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 17));
    // 0x1c2500: 0xacd00020
    WRITE32(ADD32(GPR_U32(ctx, 6), 32), GPR_U32(ctx, 16));
    // 0x1c2504: 0x24a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    // 0x1c2508: 0x2308821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1c250c: 0x1100000a
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 5), 4294967288)));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        goto label_1c2538;
    }
    // 0x1c2514: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c2518: 0x132100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 19), 4));
    // 0x1c251c: 0x101903
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 16), 4));
    // 0x1c2520: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c2524: 0x10e00002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) << (32 + 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_1c2530;
    }
    // 0x1c252c: 0x4a1025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
label_1c2530:
    // 0x1c2530: 0x621025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c2534: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
label_1c2538:
    // 0x1c2538: 0xe0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1c253c: 0x120802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1c2540: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1c2544: 0x1600ffe8
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1c24e8;
    }
label_1c254c:
    // 0x1c254c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c2550: 0x3c060fff
    SET_GPR_U32(ctx, 6, ((uint32_t)4095 << 16));
    // 0x1c2554: 0x8c451f24
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 7972)));
    // 0x1c2558: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x1c255c: 0xae530048
    WRITE32(ADD32(GPR_U32(ctx, 18), 72), GPR_U32(ctx, 19));
    // 0x1c2560: 0x3c078000
    SET_GPR_U32(ctx, 7, ((uint32_t)32768 << 16));
    // 0x1c2564: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c2568: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c256c: 0x34420040
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 64));
    // 0x1c2570: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1c2574: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1c2578: 0x661824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1c257c: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1c2580: 0xaca30080
    WRITE32(ADD32(GPR_U32(ctx, 5), 128), GPR_U32(ctx, 3));
    // 0x1c2584: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c2588: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x1c2590);
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_1c2590
// Address: 0x1c2590 - 0x1c25b0

void entry_1c2590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2590: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c2594: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c2598: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c259c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c25a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c25a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c25a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SaveSprBuf__FPve
// Address: 0x1c25b0 - 0x1c2644

void entry_1c2644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2644) {
        switch (ctx->pc) {
            case 0x1c2650: ctx->pc = 0; goto label_1c2650;
            case 0x1c266c: ctx->pc = 0; goto label_1c266c;
            case 0x1c26a0: ctx->pc = 0; goto label_1c26a0;
            case 0x1c26e4: ctx->pc = 0; goto label_1c26e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2644: 0x12200009
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 216));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1c266c;
    }
    // 0x1c264c: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c2650:
    // 0x1c2650: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x1c2654: 0x24630008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1c2658: 0x8c71fff8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 4294967288)));
    // 0x1c265c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1c2660: 0x0
    // NOP
    // 0x1c2664: 0x1620fffa
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_1c2650;
    }
label_1c266c:
    // 0x1c266c: 0x8e630048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 72)));
    // 0x1c2670: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c2674: 0x266a0008
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1c2678: 0x2462ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1c267c: 0x729023
    SET_GPR_U32(ctx, 18, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x1c2680: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c2684: 0x10400017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 40));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c26e4;
    }
    // 0x1c268c: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1c2690: 0x3c0b1000
    SET_GPR_U32(ctx, 11, ((uint32_t)4096 << 16));
    // 0x1c2694: 0x4a4021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x1c2698: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c269c: 0x453021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
label_1c26a0:
    // 0x1c26a0: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1c26a4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1c26a8: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1c26ac: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1c26b0: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1c26b4: 0x8d040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1c26b8: 0x4b1025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x1c26bc: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1c26c0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c26c4: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1c26c8: 0xfc82fff0
    WRITE64(ADD32(GPR_U32(ctx, 4), 4294967280), GPR_U64(ctx, 2));
    // 0x1c26cc: 0x24e70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    // 0x1c26d0: 0x8e620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 72)));
    // 0x1c26d4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c26d8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c26dc: 0x1440fff0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c26a0;
    }
label_1c26e4:
    // 0x1c26e4: 0x122080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1c26e8: 0x91880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 9), 2));
    // 0x1c26ec: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1c26f0: 0x3a33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    // 0x1c26f4: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c26f8: 0x1442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 4)));
    // 0x1c26fc: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1c2700: 0x3c057000
    SET_GPR_U32(ctx, 5, ((uint32_t)28672 << 16));
    // 0x1c2704: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1c2708: 0x8c870000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c270c: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1c2710: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1c2714: 0x8e061f20
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 7968)));
    // 0x1c2718: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c271c: 0xfce2fff0
    WRITE64(ADD32(GPR_U32(ctx, 7), 4294967280), GPR_U64(ctx, 2));
    // 0x1c2720: 0x2408ffbf
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967231));
    // 0x1c2724: 0x3c050fff
    SET_GPR_U32(ctx, 5, ((uint32_t)4095 << 16));
    // 0x1c2728: 0x3c078000
    SET_GPR_U32(ctx, 7, ((uint32_t)32768 << 16));
    // 0x1c272c: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1c2730: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x1c2734: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1c2738: 0x681824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1c273c: 0xacc30000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 3));
    // 0x1c2740: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1c2744: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1c2748: 0x471023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1c274c: 0xc080ada
    SET_GPR_U32(ctx, 31, 0x1c2754);
    WRITE32(ADD32(GPR_U32(ctx, 6), 128), GPR_U32(ctx, 2));
    sceDmaRecv(rdram, ctx, runtime); return;
}


// Function: entry_1c2754
// Address: 0x1c2754 - 0x1c27a8

void entry_1c2754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2754) {
        switch (ctx->pc) {
            case 0x1c2780: ctx->pc = 0; goto label_1c2780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2754: 0x8ea34990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 18832)));
    // 0x1c2758: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c275c: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1c2760: 0x268548f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 18672));
    // 0x1c2764: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c2768: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c276c: 0x441018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c2770: 0x459821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1c2774: 0x8e63004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 76)));
    // 0x1c2778: 0x50660001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 6)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 76), GPR_U32(ctx, 0));
        goto label_1c2780;
    }
label_1c2780:
    // 0x1c2780: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c2784: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c2788: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c278c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c2790: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c2794: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c2798: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c279c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c27a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c27a8; return;
}


// Function: junk_001C27A8
// Address: 0x1c27a8 - 0x1c27b0

void entry_1c27e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c27e8) {
        switch (ctx->pc) {
            case 0x1c2820: ctx->pc = 0; goto label_1c2820;
            case 0x1c2874: ctx->pc = 0; goto label_1c2874;
            case 0x1c2880: ctx->pc = 0; goto label_1c2880;
            case 0x1c28ac: ctx->pc = 0; goto label_1c28ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c27e8: 0x3c030060
    SET_GPR_U32(ctx, 3, ((uint32_t)96 << 16));
    // 0x1c27ec: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1c27f0: 0x24635440
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 21568));
    // 0x1c27f4: 0x3c027000
    SET_GPR_U32(ctx, 2, ((uint32_t)28672 << 16));
    // 0x1c27f8: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1c27fc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c2800: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1c2804: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c2808: 0x32220007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 7));
    // 0x1c280c: 0x10400019
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c2874;
    }
    // 0x1c2814: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1c2818: 0x3c120060
    SET_GPR_U32(ctx, 18, ((uint32_t)96 << 16));
    // 0x1c281c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c2820:
    // 0x1c2820: 0x68640007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1c2824: 0x6c640000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1c2828: 0x6865000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1c282c: 0x6c650008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1c2830: 0x68660017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c2834: 0x6c660010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c2838: 0x6868001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c283c: 0x6c680018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c2840: 0xb0e40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2844: 0xb4e40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2848: 0xb0e5000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c284c: 0xb4e50008
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2850: 0xb0e60017
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2854: 0xb4e60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2858: 0xb0e8001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c285c: 0xb4e80018
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2860: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1c2864: 0x1462ffee
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c2820;
    }
    // 0x1c286c: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c28ac;
    }
label_1c2874:
    // 0x1c2874: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1c2878: 0x3c120060
    SET_GPR_U32(ctx, 18, ((uint32_t)96 << 16));
    // 0x1c287c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c2880:
    // 0x1c2880: 0xdc690000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c2884: 0xdc6a0008
    SET_GPR_U64(ctx, 10, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1c2888: 0xdc640010
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1c288c: 0xdc650018
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1c2890: 0xfce90000
    WRITE64(ADD32(GPR_U32(ctx, 7), 0), GPR_U64(ctx, 9));
    // 0x1c2894: 0xfcea0008
    WRITE64(ADD32(GPR_U32(ctx, 7), 8), GPR_U64(ctx, 10));
    // 0x1c2898: 0xfce40010
    WRITE64(ADD32(GPR_U32(ctx, 7), 16), GPR_U64(ctx, 4));
    // 0x1c289c: 0xfce50018
    WRITE64(ADD32(GPR_U32(ctx, 7), 24), GPR_U64(ctx, 5));
    // 0x1c28a0: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1c28a4: 0x1462fff6
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c2880;
    }
label_1c28ac:
    // 0x1c28ac: 0x68680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c28b0: 0x6c680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c28b4: 0x6869000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1c28b8: 0x6c690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x1c28bc: 0xb0e80007
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c28c0: 0xb4e80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c28c4: 0xb0e9000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c28c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c28cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c28d0: 0xb4e90008
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c28d4: 0x24060050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1c28d8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1c28e0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 80));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1c28e0
// Address: 0x1c28e0 - 0x1c29c8

void entry_1c28e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c28e0) {
        switch (ctx->pc) {
            case 0x1c290c: ctx->pc = 0; goto label_1c290c;
            case 0x1c2960: ctx->pc = 0; goto label_1c2960;
            case 0x1c298c: ctx->pc = 0; goto label_1c298c;
            case 0x1c29ac: ctx->pc = 0; goto label_1c29ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c28e0: 0x3c042000
    SET_GPR_U32(ctx, 4, ((uint32_t)8192 << 16));
    // 0x1c28e4: 0x264254c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 21696));
    // 0x1c28e8: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1c28ec: 0x3c037000
    SET_GPR_U32(ctx, 3, ((uint32_t)28672 << 16));
    // 0x1c28f0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c28f4: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1c28f8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1c28fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c2900: 0x30a20007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), 7));
    // 0x1c2904: 0x10400016
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c2960;
    }
label_1c290c:
    // 0x1c290c: 0x68830007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c2910: 0x6c830000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1c2914: 0x6886000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c2918: 0x6c860008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c291c: 0x68870017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1c2920: 0x6c870010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1c2924: 0x6888001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c2928: 0x6c880018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c292c: 0xb0a30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2930: 0xb4a30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2934: 0xb0a6000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2938: 0xb4a60008
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c293c: 0xb0a70017
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2940: 0xb4a70010
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2944: 0xb0a8001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c2948: 0xb4a80018
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c294c: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1c2950: 0x1490ffee
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 16)) {
        goto label_1c290c;
    }
    // 0x1c2958: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c298c;
    }
label_1c2960:
    // 0x1c2960: 0xdc890000
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c2964: 0xdc8a0008
    SET_GPR_U64(ctx, 10, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1c2968: 0xdc820010
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1c296c: 0xdc830018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1c2970: 0xfca90000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 9));
    // 0x1c2974: 0xfcaa0008
    WRITE64(ADD32(GPR_U32(ctx, 5), 8), GPR_U64(ctx, 10));
    // 0x1c2978: 0xfca20010
    WRITE64(ADD32(GPR_U32(ctx, 5), 16), GPR_U64(ctx, 2));
    // 0x1c297c: 0xfca30018
    WRITE64(ADD32(GPR_U32(ctx, 5), 24), GPR_U64(ctx, 3));
    // 0x1c2980: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1c2984: 0x1490fff6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 16)) {
        goto label_1c2960;
    }
label_1c298c:
    // 0x1c298c: 0x68860007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c2990: 0x6c860000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1c2994: 0x6887000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1c2998: 0x6c870008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1c299c: 0xb0a60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c29a0: 0xb4a60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c29a4: 0xb0a7000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c29a8: 0xb4a70008
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
label_1c29ac:
    // 0x1c29ac: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c29b0: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c29b4: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c29b8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c29bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c29c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c29c8; return;
}


// Function: FUN_001c29c8
// Address: 0x1c29c8 - 0x1c29dc

void FUN_001c29c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c29c8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1c29cc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c29d0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1c29d4: 0xc0709ec
    SET_GPR_U32(ctx, 31, 0x1c29dc);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    sprbuf__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_1c29dc
// Address: 0x1c29dc - 0x1c29e8

void entry_1c29dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c29dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c29e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c29e8
// Address: 0x1c29e8 - 0x1c29f8

void FUN_001c29e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c29e8: 0xac800008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 0));
    // 0x1c29ec: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c29f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c29f8; return;
}


// Function: UpdateSqtrm__FP5SQTRMP6VECTORP7MATRIX3ff
// Address: 0x1c29f8 - 0x1c2af0

void entry_1c2af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2af0) {
        switch (ctx->pc) {
            case 0x1c2b00: ctx->pc = 0; goto label_1c2b00;
            case 0x1c2b58: ctx->pc = 0; goto label_1c2b58;
            case 0x1c2ba8: ctx->pc = 0; goto label_1c2ba8;
            case 0x1c2bd0: ctx->pc = 0; goto label_1c2bd0;
            case 0x1c2c08: ctx->pc = 0; goto label_1c2c08;
            case 0x1c2c10: ctx->pc = 0; goto label_1c2c10;
            case 0x1c2c58: ctx->pc = 0; goto label_1c2c58;
            case 0x1c2c68: ctx->pc = 0; goto label_1c2c68;
            case 0x1c2c70: ctx->pc = 0; goto label_1c2c70;
            case 0x1c2c74: ctx->pc = 0; goto label_1c2c74;
            case 0x1c2cc0: ctx->pc = 0; goto label_1c2cc0;
            case 0x1c2d18: ctx->pc = 0; goto label_1c2d18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2af0: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c2af4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1c2af8: 0x5440ffe7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
        ctx->pc = 0x1C2A98; return;
    }
label_1c2b00:
    // 0x1c2b00: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c2b04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c2b08: 0x14620013
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c2b58;
    }
    // 0x1c2b10: 0xc6400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1c2b14: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c2b18: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b1c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b20: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b24: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2b28: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c2b2c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b30: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c2b34: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c2b38: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2b3c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c2b40: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1c2b44: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1c2b48: 0x45030017
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[1]);
        goto label_1c2ba8;
    }
    // 0x1c2b50: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2ba8;
    }
label_1c2b58:
    // 0x1c2b58: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c2b5c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b60: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b64: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b68: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2b6c: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b70: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b74: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b78: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2b7c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b80: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c2b84: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c2b88: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c2b8c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c2b90: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c2b94: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c2b98: 0x48261000
    SET_GPR_VEC(ctx, 6, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c2b9c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1c2ba0: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x1c2ba4: 0x460100e8
    ctx->f[3] = std::max(ctx->f[0], ctx->f[1]);
label_1c2ba8:
    // 0x1c2ba8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c2bac: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2bb0: 0x45010017
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c2c10;
    }
    // 0x1c2bb8: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c2bbc: 0x18400012
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1c2c08;
    }
    // 0x1c2bc4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c2bc8: 0x26420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1c2bcc: 0x0
    // NOP
label_1c2bd0:
    // 0x1c2bd0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c2bd4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1c2bd8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2bdc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c2be0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2be4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2be8: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1c2bec: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2bf0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c2bf4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c2bf8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c2bfc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c2c00: 0x1600fff3
    ctx->f[12] = std::max(ctx->f[0], ctx->f[12]);
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1c2bd0;
    }
label_1c2c08:
    // 0x1c2c08: 0x460ca002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    // 0x1c2c0c: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
label_1c2c10:
    // 0x1c2c10: 0x16e00017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 64));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_1c2c70;
    }
    // 0x1c2c18: 0xc6420040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 64)); ctx->f[2] = *(float*)&val; }
    // 0x1c2c1c: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c2c20: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c2c24: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c2c28: 0x24645c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1c2c2c: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1c2c30: 0xc4645c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c2c34: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c2c38: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1c2c3c: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c2c40: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2c44: 0x0
    // NOP
    // 0x1c2c48: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c2c58;
    }
    // 0x1c2c50: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2c68;
    }
label_1c2c58:
    // 0x1c2c58: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2c5c: 0x0
    // NOP
    // 0x1c2c60: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[5]);
        goto label_1c2c68;
    }
label_1c2c68:
    // 0x1c2c68: 0x10000002
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2c74;
    }
label_1c2c70:
    // 0x1c2c70: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
label_1c2c74:
    // 0x1c2c74: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c2c78: 0x4601a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2c7c: 0x0
    // NOP
    // 0x1c2c80: 0x4502000f
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
        goto label_1c2cc0;
    }
    // 0x1c2c88: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c2c8c: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2c90: 0x104300cf
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 63));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1C2FD0; return;
    }
    // 0x1c2c98: 0x3042003f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 63));
    // 0x1c2c9c: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1c2ca0: 0x432018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c2ca4: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1c2ca8: 0xc4400064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 100)); ctx->f[0] = *(float*)&val; }
    // 0x1c2cac: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2cb0: 0x0
    // NOP
    // 0x1c2cb4: 0x450300c7
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
        ctx->pc = 0x1C2FD4; return;
    }
    // 0x1c2cbc: 0xc6400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[0] = *(float*)&val; }
label_1c2cc0:
    // 0x1c2cc0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2cc4: 0x0
    // NOP
    // 0x1c2cc8: 0x45000013
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c2d18;
    }
    // 0x1c2cd0: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1c2cd4: 0x48a61800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x1c2cd8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1c2cdc: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c2ce0: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1c2ce4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c2ce8: 0xd86100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x1c2cec: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c2cf0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c2cf4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2cf8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c2cfc: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c2d00: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c2d04: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c2d08: 0xd86200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x1c2d0c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c2d10: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2d14: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c2d18:
    // 0x1c2d18: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1c2d1c: 0x26440c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 3184));
    // 0x1c2d20: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c2d24: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1c2d2c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1c2d2c
// Address: 0x1c2d2c - 0x1c2d40

void entry_1c2d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2d2c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1c2d30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c2d34: 0x27a50170
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1c2d38: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1c2d40);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c2d40
// Address: 0x1c2d40 - 0x1c2db4

void entry_1c2d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c2d40: 0xc7ac0170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[12] = *(float*)&val; }
    // 0x1c2d44: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1c2d48: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1c2d4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c2d50: 0x46006045
    ctx->f[1] = FPU_ABS_S(ctx->f[12]);
    // 0x1c2d54: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c2d58: 0x0
    // NOP
    // 0x1c2d5c: 0x45000081
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C2F64; return;
    }
    // 0x1c2d64: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c2d68: 0x1062007e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C2F64; return;
    }
    // 0x1c2d70: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1c2d74: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c2d78: 0x7a460c70
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 18), 3184)));
    // 0x1c2d7c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c2d80: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1c2d84: 0x7a420c80
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 3200)));
    // 0x1c2d88: 0x7a430c90
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 3216)));
    // 0x1c2d8c: 0x7fa60080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 6));
    // 0x1c2d90: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1c2d94: 0x44070800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[1]);
    // 0x1c2d98: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x1c2d9c: 0x7fa300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    // 0x1c2da0: 0x24f10001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1c2da4: 0x4491a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 17);
    // 0x1c2da8: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1c2dac: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1c2db4);
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[20];
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c2db4
// Address: 0x1c2db4 - 0x1c3028

void entry_1c2db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c2db4) {
        switch (ctx->pc) {
            case 0x1c2e18: ctx->pc = 0; goto label_1c2e18;
            case 0x1c2ea8: ctx->pc = 0; goto label_1c2ea8;
            case 0x1c2ee4: ctx->pc = 0; goto label_1c2ee4;
            case 0x1c2f28: ctx->pc = 0; goto label_1c2f28;
            case 0x1c2f4c: ctx->pc = 0; goto label_1c2f4c;
            case 0x1c2f50: ctx->pc = 0; goto label_1c2f50;
            case 0x1c2f64: ctx->pc = 0; goto label_1c2f64;
            case 0x1c2fac: ctx->pc = 0; goto label_1c2fac;
            case 0x1c2fd0: ctx->pc = 0; goto label_1c2fd0;
            case 0x1c2fd4: ctx->pc = 0; goto label_1c2fd4;
            case 0x1c2ff0: ctx->pc = 0; goto label_1c2ff0;
            case 0x1c2ff4: ctx->pc = 0; goto label_1c2ff4;
            case 0x1c2ff8: ctx->pc = 0; goto label_1c2ff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c2db4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c2db8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c2dbc: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c2dc0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c2dc4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c2dc8: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1c2dcc: 0xda440c60
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 3168)));
    // 0x1c2dd0: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x1c2dd4: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c2dd8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c2ddc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c2de0: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1c2de4: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c2de8: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1c2dec: 0xdac10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1c2df0: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c2df4: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2df8: 0xfba30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c2dfc: 0x1a200074
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1c2fd0;
    }
    // 0x1c2e04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c2e08: 0x24070030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1c2e0c: 0x24461858
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1c2e10: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c2e14: 0x0
    // NOP
label_1c2e18:
    // 0x1c2e18: 0x24650001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1c2e1c: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c2e20: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c2e24: 0xdba70080
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c2e28: 0xdba80090
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c2e2c: 0x4bc729bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1c2e30: 0x4bc718bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1c2e34: 0x4bc711ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2e38: 0x4bc829bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1c2e3c: 0x4bc818bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1c2e40: 0x4bc8120a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2e44: 0xdba600a0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c2e48: 0xdba400e0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c2e4c: 0x4bc629bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1c2e50: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1c2e54: 0x4bc6114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2e58: 0xdba100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c2e5c: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c2e60: 0x4be12128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1c2e64: 0xfba70080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c2e68: 0xfba80090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c2e6c: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c2e70: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c2e74: 0xfba70140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c2e78: 0xfba70110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c2e7c: 0xfba80150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c2e80: 0xfba80120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c2e84: 0xfba50160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c2e88: 0xfba50130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c2e8c: 0xfba700b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c2e90: 0xfba800c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c2e94: 0x18400013
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1c2ee4;
    }
    // 0x1c2e9c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c2ea0: 0x26430020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1c2ea4: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1c2ea8:
    // 0x1c2ea8: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c2eac: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1c2eb0: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c2eb4: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c2eb8: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1c2ebc: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c2ec0: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c2ec4: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c2ec8: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c2ecc: 0xf8420000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c2ed0: 0xdba100e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c2ed4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c2ed8: 0xf8410000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c2edc: 0x1600fff2
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1c2ea8;
    }
label_1c2ee4:
    // 0x1c2ee4: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2ee8: 0xc4c00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c2eec: 0x471018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c2ef0: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
    // 0x1c2ef4: 0x2422021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1c2ef8: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1c2efc: 0xe4950004
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 4), 4), *(uint32_t*)&val); }
    // 0x1c2f00: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c2f04: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1c2f08: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c2f0c: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    // 0x1c2f10: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2f14: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c2f18: 0x2c430040
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 64));
    // 0x1c2f1c: 0x14600002
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c2f28;
    }
    // 0x1c2f24: 0xae40000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 0));
label_1c2f28:
    // 0x1c2f28: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2f2c: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c2f30: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
        goto label_1c2f50;
    }
    // 0x1c2f38: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1c2f3c: 0x2c430040
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 64));
    // 0x1c2f40: 0x14600002
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c2f4c;
    }
    // 0x1c2f48: 0xae400008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 0));
label_1c2f4c:
    // 0x1c2f4c: 0xa0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_1c2f50:
    // 0x1c2f50: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x1c2f54: 0x1440ffb0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c2e18;
    }
    // 0x1c2f5c: 0x1000001d
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c2fd4;
    }
label_1c2f64:
    // 0x1c2f64: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1c2f68: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c2f6c: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c2f70: 0xc480185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c2f74: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
    // 0x1c2f78: 0x2422021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1c2f7c: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1c2f80: 0xe4950004
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 4), 4), *(uint32_t*)&val); }
    // 0x1c2f84: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c2f88: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1c2f8c: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c2f90: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    // 0x1c2f94: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2f98: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c2f9c: 0x2c430040
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 64));
    // 0x1c2fa0: 0x14600002
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c2fac;
    }
    // 0x1c2fa8: 0xae40000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 0));
label_1c2fac:
    // 0x1c2fac: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1c2fb0: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c2fb4: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
        goto label_1c2fd4;
    }
    // 0x1c2fbc: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1c2fc0: 0x2c430040
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 64));
    // 0x1c2fc4: 0x14600002
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c2fd0;
    }
    // 0x1c2fcc: 0xae400008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 0));
label_1c2fd0:
    // 0x1c2fd0: 0x7ac20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
label_1c2fd4:
    // 0x1c2fd4: 0x7e420c60
    WRITE128(ADD32(GPR_U32(ctx, 18), 3168), GPR_VEC(ctx, 2));
    // 0x1c2fd8: 0x7aa30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1c2fdc: 0x7e430c70
    WRITE128(ADD32(GPR_U32(ctx, 18), 3184), GPR_VEC(ctx, 3));
    // 0x1c2fe0: 0x7aa20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1c2fe4: 0x7e420c80
    WRITE128(ADD32(GPR_U32(ctx, 18), 3200), GPR_VEC(ctx, 2));
    // 0x1c2fe8: 0x7aa30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1c2fec: 0x7e430c90
    WRITE128(ADD32(GPR_U32(ctx, 18), 3216), GPR_VEC(ctx, 3));
label_1c2ff0:
    // 0x1c2ff0: 0x7bbf0200
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 512)));
label_1c2ff4:
    // 0x1c2ff4: 0x7bb701f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 496)));
label_1c2ff8:
    // 0x1c2ff8: 0x7bb601e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x1c2ffc: 0x7bb501d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1c3000: 0x7bb401c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1c3004: 0x7bb301b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1c3008: 0x7bb201a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1c300c: 0x7bb10190
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1c3010: 0x7bb00180
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1c3014: 0xc7b50218
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 536)); ctx->f[21] = *(float*)&val; }
    // 0x1c3018: 0xc7b40210
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 528)); ctx->f[20] = *(float*)&val; }
    // 0x1c301c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 544));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3024: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c3028; return;
}


// Function: RenderSqtrm__FP5SQTRMP2CM
// Address: 0x1c3028 - 0x1c3074

void entry_1c3074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3074: 0x3c03001c
    SET_GPR_U32(ctx, 3, ((uint32_t)28 << 16));
    // 0x1c3078: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1c307c: 0x246330e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 12520));
    // 0x1c3080: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1c3084: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1c3088: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c308c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c3090: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c3094: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3098: 0xda230040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x1c309c: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1c30a0: 0xda210080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1c30a4: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c30a8: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c30ac: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c30b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c30b4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c30b8: 0xafb00060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 16));
    // 0x1c30bc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c30c0: 0xe7a10050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1c30c4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c30c8: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c30cc: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1c30d4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1c30d4
// Address: 0x1c30d4 - 0x1c30e8

void entry_1c30d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c30d4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c30d8: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c30dc: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c30e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawSqtrm__FP3RPL
// Address: 0x1c30e8 - 0x1c3134

void entry_1c3134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3134: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1c3138: 0x260422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x1c313c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1c3140: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1c3148);
    WRITE32(ADD32(GPR_U32(ctx, 29), 6224), GPR_U32(ctx, 2));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1c3148
// Address: 0x1c3148 - 0x1c3168

void entry_1c3148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3148: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1c314c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1c3150: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1c3154: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3158: 0x24c683d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294935504));
    // 0x1c315c: 0xafa00098
    WRITE32(ADD32(GPR_U32(ctx, 29), 152), GPR_U32(ctx, 0));
    // 0x1c3160: 0xc0586ac
    SET_GPR_U32(ctx, 31, 0x1c3168);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTransform__4GLBSP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c3168
// Address: 0x1c3168 - 0x1c3174

void entry_1c3168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3168: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1c316c: 0xc0586ec
    SET_GPR_U32(ctx, 31, 0x1c3174);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BeginStrip__4GLBSP3SHD(rdram, ctx, runtime); return;
}


// Function: entry_1c3174
// Address: 0x1c3174 - 0x1c3188

void entry_1c3174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3174: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c3178: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c317c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3180: 0xc0586c4
    SET_GPR_U32(ctx, 31, 0x1c3188);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 680)); ctx->f[12] = *(float*)&val; }
    FindLights__4GLBSP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_1c3188
// Address: 0x1c3188 - 0x1c327c

void entry_1c3188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3188) {
        switch (ctx->pc) {
            case 0x1c31b8: ctx->pc = 0; goto label_1c31b8;
            case 0x1c3218: ctx->pc = 0; goto label_1c3218;
            case 0x1c3228: ctx->pc = 0; goto label_1c3228;
            case 0x1c3264: ctx->pc = 0; goto label_1c3264;
            case 0x1c3268: ctx->pc = 0; goto label_1c3268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3188: 0x8e300008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1c318c: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1c3190: 0x12020064
    SET_GPR_U32(ctx, 23, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C3324; return;
    }
    // 0x1c3198: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1c319c: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1c31a0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1c31a4: 0x26340050
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 80));
    // 0x1c31a8: 0x27b31860
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 6240));
    // 0x1c31ac: 0x3c1e0027
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    // 0x1c31b0: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1c31b4: 0x0
    // NOP
label_1c31b8:
    // 0x1c31b8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1c31bc: 0x2031018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c31c0: 0x24c61858
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 6232));
    // 0x1c31c4: 0xc4c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c31c8: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1c31cc: 0xc6820008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1c31d0: 0x24e75c60
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 23648));
    // 0x1c31d4: 0xc6830004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1c31d8: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
    // 0x1c31dc: 0xc6240050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 80)); ctx->f[4] = *(float*)&val; }
    // 0x1c31e0: 0x2229021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1c31e4: 0xc6e55c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1c31e8: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1c31ec: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1c31f0: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1c31f4: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1c31f8: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1c31fc: 0x46012100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x1c3200: 0x46052034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3204: 0x0
    // NOP
    // 0x1c3208: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[6] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c3218;
    }
    // 0x1c3210: 0x10000005
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3228;
    }
label_1c3218:
    // 0x1c3218: 0x46043034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c321c: 0x0
    // NOP
    // 0x1c3220: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_MOV_S(ctx->f[6]);
        goto label_1c3228;
    }
label_1c3228:
    // 0x1c3228: 0xc6c00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 80)); ctx->f[0] = *(float*)&val; }
    // 0x1c322c: 0xc6410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c3230: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c3234: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1c3238: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c323c: 0x0
    // NOP
    // 0x1c3240: 0x45000008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c3264;
    }
    // 0x1c3248: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1c324c: 0x75102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 21)));
    // 0x1c3250: 0x202a80a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 21, GPR_U32(ctx, 16));
    // 0x1c3254: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1c3258: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1c325c: 0x10000002
    WRITE8(ADD32(GPR_U32(ctx, 29), 6227), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3268;
    }
label_1c3264:
    // 0x1c3264: 0xa3a01853
    WRITE8(ADD32(GPR_U32(ctx, 29), 6227), (uint8_t)GPR_U32(ctx, 0));
label_1c3268:
    // 0x1c3268: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c326c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3270: 0x24454998
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 18840));
    // 0x1c3274: 0xc0589b0
    SET_GPR_U32(ctx, 31, 0x1c327c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    SetUv__4GLBSP3UVF(rdram, ctx, runtime); return;
}


// Function: entry_1c327c
// Address: 0x1c327c - 0x1c3298

void entry_1c327c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c327c: 0x8ba31853
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6227); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1c3280: 0x9ba31850
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6224); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1c3284: 0xaba31863
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6243); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c3288: 0xbba31860
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6240); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c328c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3290: 0xc0589aa
    SET_GPR_U32(ctx, 31, 0x1c3298);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetRgba__4GLBSG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1c3298
// Address: 0x1c3298 - 0x1c32a4

void entry_1c3298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3298: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c329c: 0xc0589a0
    SET_GPR_U32(ctx, 31, 0x1c32a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 16));
    SetNormal__4GLBSP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c32a4
// Address: 0x1c32a4 - 0x1c32b0

void entry_1c32a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c32a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c32a8: 0xc0589b6
    SET_GPR_U32(ctx, 31, 0x1c32b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVtx__4GLBSi(rdram, ctx, runtime); return;
}


// Function: entry_1c32b0
// Address: 0x1c32b0 - 0x1c32dc

void entry_1c32b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c32b0: 0x93a21853
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 6227)));
    // 0x1c32b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c32b8: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1c32bc: 0x27c549a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 18848));
    // 0x1c32c0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c32c4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1c32c8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c32cc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1c32d0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c32d4: 0xc0589b0
    SET_GPR_U32(ctx, 31, 0x1c32dc);
    WRITE8(ADD32(GPR_U32(ctx, 29), 6227), (uint8_t)GPR_U32(ctx, 2));
    SetUv__4GLBSP3UVF(rdram, ctx, runtime); return;
}


// Function: entry_1c32dc
// Address: 0x1c32dc - 0x1c32f8

void entry_1c32dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c32dc: 0x8ba21853
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6227); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1c32e0: 0x9ba21850
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6224); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1c32e4: 0xaba21863
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6243); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c32e8: 0xbba21860
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 6240); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c32ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c32f0: 0xc0589aa
    SET_GPR_U32(ctx, 31, 0x1c32f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetRgba__4GLBSG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1c32f8
// Address: 0x1c32f8 - 0x1c3304

void entry_1c32f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c32f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c32fc: 0xc0589a0
    SET_GPR_U32(ctx, 31, 0x1c3304);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 32));
    SetNormal__4GLBSP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c3304
// Address: 0x1c3304 - 0x1c3310

void entry_1c3304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3304: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3308: 0xc0589b6
    SET_GPR_U32(ctx, 31, 0x1c3310);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVtx__4GLBSi(rdram, ctx, runtime); return;
}


// Function: entry_1c3310
// Address: 0x1c3310 - 0x1c3340

void entry_1c3310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3310) {
        switch (ctx->pc) {
            case 0x1c3324: ctx->pc = 0; goto label_1c3324;
            case 0x1c3334: ctx->pc = 0; goto label_1c3334;
            case 0x1c3338: ctx->pc = 0; goto label_1c3338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3310: 0x2e020040
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 64));
    // 0x1c3314: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1c3318: 0x2800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x1c331c: 0x1603ffa6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1C31B8; return;
    }
label_1c3324:
    // 0x1c3324: 0x6a20003
    if (GPR_S32(ctx, 21) < 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        goto label_1c3334;
    }
    // 0x1c332c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3338;
    }
label_1c3334:
    // 0x1c3334: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
label_1c3338:
    // 0x1c3338: 0xc058942
    SET_GPR_U32(ctx, 31, 0x1c3340);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndStrip__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_1c3340
// Address: 0x1c3340 - 0x1c334c

void entry_1c3340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3340: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c3344: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1c334c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 8872));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1c334c
// Address: 0x1c334c - 0x1c3358

void entry_1c334c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c334c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3350: 0xc0586a2
    SET_GPR_U32(ctx, 31, 0x1c3358);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_00161a88(rdram, ctx, runtime); return;
}


// Function: entry_1c3358
// Address: 0x1c3358 - 0x1c3390

void entry_1c3358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3358: 0x7bbf1900
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 6400)));
    // 0x1c335c: 0x7bbe18f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 6384)));
    // 0x1c3360: 0x7bb718e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 6368)));
    // 0x1c3364: 0x7bb618d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 6352)));
    // 0x1c3368: 0x7bb518c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 6336)));
    // 0x1c336c: 0x7bb418b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 6320)));
    // 0x1c3370: 0x7bb318a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 6304)));
    // 0x1c3374: 0x7bb21890
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 6288)));
    // 0x1c3378: 0x7bb11880
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 6272)));
    // 0x1c337c: 0x7bb01870
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 6256)));
    // 0x1c3380: 0xc7b51918
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 6424)); ctx->f[21] = *(float*)&val; }
    // 0x1c3384: 0xc7b41910
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 6416)); ctx->f[20] = *(float*)&val; }
    // 0x1c3388: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 6432));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3390
// Address: 0x1c3390 - 0x1c33a4

void FUN_001c3390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3390: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c3394: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c3398: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c339c: 0xc06486a
    SET_GPR_U32(ctx, 31, 0x1c33a4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1c33a4
// Address: 0x1c33a4 - 0x1c33c8

void entry_1c33a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c33a4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c33a8: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1c33ac: 0xae020694
    WRITE32(ADD32(GPR_U32(ctx, 16), 1684), GPR_U32(ctx, 2));
    // 0x1c33b0: 0xae030610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 3));
    // 0x1c33b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c33b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c33bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c33c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c33c8; return;
}


// Function: FUN_001c33c8
// Address: 0x1c33c8 - 0x1c33dc

void FUN_001c33c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c33c8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c33cc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c33d0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c33d4: 0xc049292
    SET_GPR_U32(ctx, 31, 0x1c33dc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c33dc
// Address: 0x1c33dc - 0x1c33f8

void entry_1c33dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c33dc: 0xc60003cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 972)); ctx->f[0] = *(float*)&val; }
    // 0x1c33e0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c33e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c33e8: 0x24c649b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 18864));
    // 0x1c33ec: 0xe600068c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1676), *(uint32_t*)&val); }
    // 0x1c33f0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1c33f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1c33f8
// Address: 0x1c33f8 - 0x1c340c

void entry_1c33f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c33f8: 0x8e040664
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x1c33fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3400: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c3404: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1c340c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1c340c
// Address: 0x1c340c - 0x1c341c

void entry_1c340c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c340c: 0xc60c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1c3410: 0xc60d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1c3414: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c341c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1640), GPR_U32(ctx, 2));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c341c
// Address: 0x1c341c - 0x1c3430

void entry_1c341c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c341c: 0x8e020660
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1632)));
    // 0x1c3420: 0xe6000644
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1604), *(uint32_t*)&val); }
    // 0x1c3424: 0xc44d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1c3428: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c3430);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 212)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c3430
// Address: 0x1c3430 - 0x1c3494

void entry_1c3430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3430: 0x8e07062c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1580)));
    // 0x1c3434: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c3438: 0xe6000648
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1608), *(uint32_t*)&val); }
    // 0x1c343c: 0x2484dd48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958408));
    // 0x1c3440: 0x68e802e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 739); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c3444: 0x6ce802dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 732); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1c3448: 0xb2080637
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1591); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c344c: 0xb6080630
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1584); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c3450: 0x26050690
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1680));
    // 0x1c3454: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c3458: 0xa8850267
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 615); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c345c: 0xb8850264
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 612); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c3460: 0x2463dfc8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294959048));
    // 0x1c3464: 0x26060694
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 1684));
    // 0x1c3468: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c346c: 0xa8660267
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 615); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c3470: 0xb8660264
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 612); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1c3474: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1c3478: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c347c: 0x24424a40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x1c3480: 0xac820268
    WRITE32(ADD32(GPR_U32(ctx, 4), 616), GPR_U32(ctx, 2));
    // 0x1c3484: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3488: 0xe460026c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 620), *(uint32_t*)&val); }
    // 0x1c348c: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1c3494);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1c3494
// Address: 0x1c3494 - 0x1c34b8

void entry_1c3494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3494: 0x8e03071c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1820)));
    // 0x1c3498: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c349c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c34a0: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c34a4: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1c34a8: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1c34ac: 0xac500720
    WRITE32(ADD32(GPR_U32(ctx, 2), 1824), GPR_U32(ctx, 16));
    // 0x1c34b0: 0xc070ff2
    SET_GPR_U32(ctx, 31, 0x1c34b8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1820), GPR_U32(ctx, 3));
    FUN_001c3fc8(rdram, ctx, runtime); return;
}


// Function: entry_1c34b8
// Address: 0x1c34b8 - 0x1c34c8

void entry_1c34b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c34b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c34bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c34c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c34c8
// Address: 0x1c34c8 - 0x1c34e8

void FUN_001c34c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c34c8: 0x27bdff40
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967104));
    // 0x1c34cc: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x1c34d0: 0xe7b400b0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x1c34d4: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c34d8: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x1c34dc: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x1c34e0: 0xc064ad6
    SET_GPR_U32(ctx, 31, 0x1c34e8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    UpdatePo__FP2POf(rdram, ctx, runtime); return;
}


// Function: entry_1c34e8
// Address: 0x1c34e8 - 0x1c3500

void entry_1c34e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c34e8: 0x8e270688
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1672)));
    // 0x1c34ec: 0x10e00011
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3534; return;
    }
    // 0x1c34f4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1c34f8: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1c3500);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 119));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c3500
// Address: 0x1c3500 - 0x1c3510

void entry_1c3500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3500: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
        ctx->pc = 0x1C3514; return;
    }
    // 0x1c3508: 0xc0561cc
    SET_GPR_U32(ctx, 31, 0x1c3510);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ExplodeExpl__FP4EXPL(rdram, ctx, runtime); return;
}


// Function: entry_1c3510
// Address: 0x1c3510 - 0x1c3530

void entry_1c3510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3510) {
        switch (ctx->pc) {
            case 0x1c3514: ctx->pc = 0; goto label_1c3514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3510: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
label_1c3514:
    // 0x1c3514: 0x8e250688
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1672)));
    // 0x1c3518: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c351c: 0xae220690
    WRITE32(ADD32(GPR_U32(ctx, 17), 1680), GPR_U32(ctx, 2));
    // 0x1c3520: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c3524: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1c3528: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1c3530);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1c3530
// Address: 0x1c3530 - 0x1c3548

void entry_1c3530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3530) {
        switch (ctx->pc) {
            case 0x1c3534: ctx->pc = 0; goto label_1c3534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3530: 0xae200688
    WRITE32(ADD32(GPR_U32(ctx, 17), 1672), GPR_U32(ctx, 0));
label_1c3534:
    // 0x1c3534: 0x8e250684
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1668)));
    // 0x1c3538: 0x50a00005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
        ctx->pc = 0x1C3550; return;
    }
    // 0x1c3540: 0xc070fda
    SET_GPR_U32(ctx, 31, 0x1c3548);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001c3f68(rdram, ctx, runtime); return;
}


// Function: entry_1c3548
// Address: 0x1c3548 - 0x1c3578

void entry_1c3548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3548) {
        switch (ctx->pc) {
            case 0x1c3550: ctx->pc = 0; goto label_1c3550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3548: 0xae200684
    WRITE32(ADD32(GPR_U32(ctx, 17), 1668), GPR_U32(ctx, 0));
    // 0x1c354c: 0x8e24067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
label_1c3550:
    // 0x1c3550: 0x5080000b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
        ctx->pc = 0x1C3580; return;
    }
    // 0x1c3558: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1c355c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c3560: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3564: 0x0
    // NOP
    // 0x1c3568: 0x45020015
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
        ctx->pc = 0x1C35C0; return;
    }
    // 0x1c3570: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c3578);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c3578
// Address: 0x1c3578 - 0x1c35a4

void entry_1c3578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3578) {
        switch (ctx->pc) {
            case 0x1c3580: ctx->pc = 0; goto label_1c3580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3578: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 17), 1660), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C35BC; return;
    }
label_1c3580:
    // 0x1c3580: 0x1040000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C35BC; return;
    }
    // 0x1c3588: 0x8e240678
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1656)));
    // 0x1c358c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1c3590: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c3594: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c3598: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c359c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1c35a4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 1660));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c35a4
// Address: 0x1c35a4 - 0x1c36b8

void entry_1c35a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c35a4) {
        switch (ctx->pc) {
            case 0x1c35bc: ctx->pc = 0; goto label_1c35bc;
            case 0x1c35c0: ctx->pc = 0; goto label_1c35c0;
            case 0x1c3620: ctx->pc = 0; goto label_1c3620;
            case 0x1c3630: ctx->pc = 0; goto label_1c3630;
            case 0x1c363c: ctx->pc = 0; goto label_1c363c;
            case 0x1c3650: ctx->pc = 0; goto label_1c3650;
            case 0x1c36ac: ctx->pc = 0; goto label_1c36ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c35a4: 0x8e220694
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1684)));
    // 0x1c35a8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c35ac: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c35b0: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c35b4: 0xae220694
    WRITE32(ADD32(GPR_U32(ctx, 17), 1684), GPR_U32(ctx, 2));
    // 0x1c35b8: 0xac83e228
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294959656), GPR_U32(ctx, 3));
label_1c35bc:
    // 0x1c35bc: 0x8e23067c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
label_1c35c0:
    // 0x1c35c0: 0x1060001e
    WRITE32(ADD32(GPR_U32(ctx, 17), 1664), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c363c;
    }
    // 0x1c35c8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1c35cc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1c35d0: 0xc4630014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[3] = *(float*)&val; }
    // 0x1c35d4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c35d8: 0xc4420034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[2] = *(float*)&val; }
    // 0x1c35dc: 0x24a34a50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 19024));
    // 0x1c35e0: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c35e4: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1c35e8: 0x460218c3
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[3] * 0.0f); } else ctx->f[3] = ctx->f[3] / ctx->f[2];
    // 0x1c35ec: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c35f0: 0xc4a24a50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 19024)); ctx->f[2] = *(float*)&val; }
    // 0x1c35f4: 0xc4845c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c35f8: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1c35fc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c3600: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1c3604: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c3608: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c360c: 0x0
    // NOP
    // 0x1c3610: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c3620;
    }
    // 0x1c3618: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3630;
    }
label_1c3620:
    // 0x1c3620: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3624: 0x0
    // NOP
    // 0x1c3628: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[5]);
        goto label_1c3630;
    }
label_1c3630:
    // 0x1c3630: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c3634: 0x10000006
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 6228), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3650;
    }
label_1c363c:
    // 0x1c363c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c3640: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c3644: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c3648: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1c364c: 0xe4401854
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 6228), *(uint32_t*)&val); }
label_1c3650:
    // 0x1c3650: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c3654: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c3658: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c365c: 0xc4404a44
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19012)); ctx->f[0] = *(float*)&val; }
    // 0x1c3660: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1c3664: 0xc622068c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1676)); ctx->f[2] = *(float*)&val; }
    // 0x1c3668: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1c366c: 0x8e220638
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1592)));
    // 0x1c3670: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1c3674: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c3678: 0xe62003cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 972), *(uint32_t*)&val); }
    // 0x1c367c: 0x1040000b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 976), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c36ac;
    }
    // 0x1c3684: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c3688: 0xc6220640
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1600)); ctx->f[2] = *(float*)&val; }
    // 0x1c368c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c3690: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1c3694: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c3698: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1c369c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c36a0: 0x0
    // NOP
    // 0x1c36a4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1592), GPR_U32(ctx, 0));
        goto label_1c36ac;
    }
label_1c36ac:
    // 0x1c36ac: 0xc62d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1c36b0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c36b8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 212)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c36b8
// Address: 0x1c36b8 - 0x1c36d0

void entry_1c36b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c36b8: 0xc62c0648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1608)); ctx->f[12] = *(float*)&val; }
    // 0x1c36bc: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1c36c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c36c4: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1c36c8: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1c36d0);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c36d0
// Address: 0x1c36d0 - 0x1c36f8

void entry_1c36d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c36d0: 0x8e240660
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x1c36d4: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c36d8: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c36dc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c36e0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c36e4: 0x248400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 208));
    // 0x1c36e8: 0x24c64a60
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19040));
    // 0x1c36ec: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c36f0: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x1c36f8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_1c36f8
// Address: 0x1c36f8 - 0x1c370c

void entry_1c36f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c36f8: 0x8e240660
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x1c36fc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c3700: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1c3704: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c370c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c370c
// Address: 0x1c370c - 0x1c3780

void entry_1c370c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c370c) {
        switch (ctx->pc) {
            case 0x1c375c: ctx->pc = 0; goto label_1c375c;
            case 0x1c3764: ctx->pc = 0; goto label_1c3764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c370c: 0x3c038010
    SET_GPR_U32(ctx, 3, ((uint32_t)32784 << 16));
    // 0x1c3710: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x1c3714: 0x8e240638
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1592)));
    // 0x1c3718: 0x3463ff00
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65280));
    // 0x1c371c: 0x344200ff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 255));
    // 0x1c3720: 0xafa30060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 3));
    // 0x1c3724: 0x1080006a
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C38D0; return;
    }
    // 0x1c372c: 0x8e230610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1552)));
    // 0x1c3730: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c3734: 0x10620009
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c375c;
    }
    // 0x1c373c: 0xc6220614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[2] = *(float*)&val; }
    // 0x1c3740: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1c3744: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c3748: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c374c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c3750: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1c3754: 0x10000003
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3764;
    }
label_1c375c:
    // 0x1c375c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1c3760: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
label_1c3764:
    // 0x1c3764: 0xc621063c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1596)); ctx->f[1] = *(float*)&val; }
    // 0x1c3768: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c376c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1c3770: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c3774: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x1c3778: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1c3780);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1c3780
// Address: 0x1c3780 - 0x1c38dc

void entry_1c3780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3780) {
        switch (ctx->pc) {
            case 0x1c37dc: ctx->pc = 0; goto label_1c37dc;
            case 0x1c3820: ctx->pc = 0; goto label_1c3820;
            case 0x1c3830: ctx->pc = 0; goto label_1c3830;
            case 0x1c38d0: ctx->pc = 0; goto label_1c38d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3780: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3784: 0x46000186
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    // 0x1c3788: 0x24434a70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19056));
    // 0x1c378c: 0xc4424a70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19056)); ctx->f[2] = *(float*)&val; }
    // 0x1c3790: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c3794: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3798: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c379c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c37a0: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1c37a4: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c37a8: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1c37ac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c37b0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1c37b4: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c37b8: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c37bc: 0x0
    // NOP
    // 0x1c37c0: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c37dc;
    }
    // 0x1c37c8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c37cc: 0x0
    // NOP
    // 0x1c37d0: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c37dc;
    }
    // 0x1c37d8: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_1c37dc:
    // 0x1c37dc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c37e0: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1c37e4: 0x24434a80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19072));
    // 0x1c37e8: 0xc4424a80
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19072)); ctx->f[2] = *(float*)&val; }
    // 0x1c37ec: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c37f0: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1c37f4: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c37f8: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x1c37fc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c3800: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x1c3804: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c3808: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c380c: 0x0
    // NOP
    // 0x1c3810: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c3820;
    }
    // 0x1c3818: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3830;
    }
label_1c3820:
    // 0x1c3820: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3824: 0x0
    // NOP
    // 0x1c3828: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_1c3830;
    }
label_1c3830:
    // 0x1c3830: 0x93a20060
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c3834: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1c3838: 0x93a30061
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 97)));
    // 0x1c383c: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x1c3840: 0x46802960
    ctx->f[5] = FPU_CVT_S_W(*(int32_t*)&ctx->f[5]);
    // 0x1c3844: 0x93a50070
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c3848: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c384c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c3850: 0x44833800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 3);
    // 0x1c3854: 0x468039e0
    ctx->f[7] = FPU_CVT_S_W(*(int32_t*)&ctx->f[7]);
    // 0x1c3858: 0x93a40062
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 98)));
    // 0x1c385c: 0x44851000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 5);
    // 0x1c3860: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1c3864: 0x93a20072
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 114)));
    // 0x1c3868: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1c386c: 0x93a30071
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 113)));
    // 0x1c3870: 0x44841800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 4);
    // 0x1c3874: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1c3878: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1c387c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1c3880: 0x44833000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 3);
    // 0x1c3884: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x1c3888: 0x46050142
    ctx->f[5] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x1c388c: 0x46022082
    ctx->f[2] = FPU_MUL_S(ctx->f[4], ctx->f[2]);
    // 0x1c3890: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1c3894: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1c3898: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1c389c: 0x46062102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[6]);
    // 0x1c38a0: 0x46022940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[2]);
    // 0x1c38a4: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1c38a8: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1c38ac: 0x46002864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[5]);
    // 0x1c38b0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c38b4: 0x46001864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[3]);
    // 0x1c38b8: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1c38bc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1c38c0: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1c38c4: 0xa3a20060
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    // 0x1c38c8: 0xa3a30062
    WRITE8(ADD32(GPR_U32(ctx, 29), 98), (uint8_t)GPR_U32(ctx, 3));
    // 0x1c38cc: 0xa3a40061
    WRITE8(ADD32(GPR_U32(ctx, 29), 97), (uint8_t)GPR_U32(ctx, 4));
label_1c38d0:
    // 0x1c38d0: 0x8fa50060
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c38d4: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x1c38dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1c38dc
// Address: 0x1c38dc - 0x1c3928

void entry_1c38dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c38dc: 0xc6210630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[1] = *(float*)&val; }
    // 0x1c38e0: 0xc6200670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1648)); ctx->f[0] = *(float*)&val; }
    // 0x1c38e4: 0x8e22062c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x1c38e8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c38ec: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c38f0: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c38f4: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1c38f8: 0xe44002dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 732), *(uint32_t*)&val); }
    // 0x1c38fc: 0xc6210670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1648)); ctx->f[1] = *(float*)&val; }
    // 0x1c3900: 0xc6200634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[0] = *(float*)&val; }
    // 0x1c3904: 0x8e23062c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x1c3908: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1c390c: 0xe46102e0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 736), *(uint32_t*)&val); }
    // 0x1c3910: 0x8e22062c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x1c3914: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c3918: 0xac40032c
    WRITE32(ADD32(GPR_U32(ctx, 2), 812), GPR_U32(ctx, 0));
    // 0x1c391c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3924: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c3928; return;
}


// Function: FUN_001c3928
// Address: 0x1c3928 - 0x1c3938

void FUN_001c3928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3928: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1c392c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1c3930: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1c3938);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c3938
// Address: 0x1c3938 - 0x1c3950

void entry_1c3938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3938: 0x1040000c
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C396C; return;
    }
    // 0x1c3940: 0x8c83dd48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294958408)));
    // 0x1c3944: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1c3948: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3950);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958408));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3950
// Address: 0x1c3950 - 0x1c3964

void entry_1c3950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3950: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c3954: 0x8c83dfc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959048)));
    // 0x1c3958: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1c395c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3964);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959048));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3964
// Address: 0x1c3964 - 0x1c397c

void entry_1c3964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3964) {
        switch (ctx->pc) {
            case 0x1c396c: ctx->pc = 0; goto label_1c396c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3964: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3994; return;
    }
label_1c396c:
    // 0x1c396c: 0x8c83dd48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294958408)));
    // 0x1c3970: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1c3974: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c397c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958408));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c397c
// Address: 0x1c397c - 0x1c3990

void entry_1c397c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c397c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c3980: 0x8c83dfc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959048)));
    // 0x1c3984: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1c3988: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3990);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959048));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3990
// Address: 0x1c3990 - 0x1c39a0

void entry_1c3990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3990) {
        switch (ctx->pc) {
            case 0x1c3994: ctx->pc = 0; goto label_1c3994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3990: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1c3994:
    // 0x1c3994: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c399c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c39a0; return;
}


// Function: FUN_001c39a0
// Address: 0x1c39a0 - 0x1c3a08

void FUN_001c39a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c39a0) {
        switch (ctx->pc) {
            case 0x1c39f8: ctx->pc = 0; goto label_1c39f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c39a0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1c39a4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1c39a8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c39ac: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1c39b0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c39b4: 0xe7b40030
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1c39b8: 0x8e020628
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1576)));
    // 0x1c39bc: 0x10400017
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c3a1c(rdram, ctx, runtime); return;
    }
    // 0x1c39c4: 0xc4410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1c39c8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c39cc: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c39d0: 0x0
    // NOP
    // 0x1c39d4: 0x45000011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1c3a1c(rdram, ctx, runtime); return;
    }
    // 0x1c39dc: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1c39e0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c39f8;
    }
    // 0x1c39e8: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C3A10; return;
    }
    // 0x1c39f0: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3A24; return;
    }
label_1c39f8:
    // 0x1c39f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c39fc: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1c3a00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3a08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3a08
// Address: 0x1c3a08 - 0x1c3a1c

void entry_1c3a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3a08) {
        switch (ctx->pc) {
            case 0x1c3a10: ctx->pc = 0; goto label_1c3a10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3a08: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3A20; return;
    }
label_1c3a10:
    // 0x1c3a10: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3a14: 0xc070ff2
    SET_GPR_U32(ctx, 31, 0x1c3a1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    FUN_001c3fc8(rdram, ctx, runtime); return;
}


// Function: entry_1c3a1c
// Address: 0x1c3a1c - 0x1c3a74

void entry_1c3a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3a1c) {
        switch (ctx->pc) {
            case 0x1c3a20: ctx->pc = 0; goto label_1c3a20;
            case 0x1c3a24: ctx->pc = 0; goto label_1c3a24;
            case 0x1c3a48: ctx->pc = 0; goto label_1c3a48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3a1c: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
label_1c3a20:
    // 0x1c3a20: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c3a24:
    // 0x1c3a24: 0x10620008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c3a48;
    }
    // 0x1c3a2c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1c3a30: 0xc4404a98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19096)); ctx->f[0] = *(float*)&val; }
    // 0x1c3a34: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1c3a38: 0xe600066c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1644), *(uint32_t*)&val); }
    // 0x1c3a3c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c3a40: 0x10000034
    WRITE128(ADD32(GPR_U32(ctx, 16), 1616), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c3b14(rdram, ctx, runtime); return;
    }
label_1c3a48:
    // 0x1c3a48: 0xc6200048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1c3a4c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1c3a50: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3a54: 0x0
    // NOP
    // 0x1c3a58: 0x45000006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1c3a74(rdram, ctx, runtime); return;
    }
    // 0x1c3a60: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3a64: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1c3a68: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c3a6c: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1c3a74);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1604));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1c3a74
// Address: 0x1c3a74 - 0x1c3aa8

void entry_1c3a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3a74: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c3a78: 0xc6210048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1c3a7c: 0xc4604a98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19096)); ctx->f[0] = *(float*)&val; }
    // 0x1c3a80: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3a84: 0xc4424a90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19088)); ctx->f[2] = *(float*)&val; }
    // 0x1c3a88: 0x26040650
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1616));
    // 0x1c3a8c: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1c3a90: 0xc60c0644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1604)); ctx->f[12] = *(float*)&val; }
    // 0x1c3a94: 0xe600066c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1644), *(uint32_t*)&val); }
    // 0x1c3a98: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1c3a9c: 0xc62d0048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[13] = *(float*)&val; }
    // 0x1c3aa0: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1c3aa8);
    ctx->f[13] = FPU_MUL_S(ctx->f[2], ctx->f[13]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1c3aa8
// Address: 0x1c3aa8 - 0x1c3ae4

void entry_1c3aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3aa8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3aac: 0xc6210048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1c3ab0: 0xc4404aa0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19104)); ctx->f[0] = *(float*)&val; }
    // 0x1c3ab4: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1c3ab8: 0xe6000670
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1648), *(uint32_t*)&val); }
    // 0x1c3abc: 0xc621007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1c3ac0: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3ac4: 0x0
    // NOP
    // 0x1c3ac8: 0x4500000d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C3B00; return;
    }
    // 0x1c3ad0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3ad4: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1c3ad8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c3adc: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1c3ae4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1608));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1c3ae4
// Address: 0x1c3ae4 - 0x1c3af8

void entry_1c3ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3ae4: 0x8e040668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x1c3ae8: 0x1080000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3B18; return;
    }
    // 0x1c3af0: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1c3af8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1157));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c3af8
// Address: 0x1c3af8 - 0x1c3b14

void entry_1c3af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3af8) {
        switch (ctx->pc) {
            case 0x1c3b00: ctx->pc = 0; goto label_1c3b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3af8: 0x10000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3B18; return;
    }
label_1c3b00:
    // 0x1c3b00: 0x8e040668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x1c3b04: 0x10800004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3B18; return;
    }
    // 0x1c3b0c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1c3b14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1156));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c3b14
// Address: 0x1c3b14 - 0x1c3b20

void entry_1c3b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3b14) {
        switch (ctx->pc) {
            case 0x1c3b18: ctx->pc = 0; goto label_1c3b18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3b14: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1c3b18:
    // 0x1c3b18: 0xc064a9c
    SET_GPR_U32(ctx, 31, 0x1c3b20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00192a70(rdram, ctx, runtime); return;
}


// Function: entry_1c3b20
// Address: 0x1c3b20 - 0x1c3b28

void entry_1c3b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b20: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1c3b28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c3b28
// Address: 0x1c3b28 - 0x1c3b40

void entry_1c3b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b28: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c3b2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c3b30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c3b34: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1c3b38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3b40
// Address: 0x1c3b40 - 0x1c3b60

void FUN_001c3b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b40: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x1c3b44: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x1c3b48: 0xe7b40080
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x1c3b4c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3b50: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x1c3b54: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x1c3b58: 0xc06e4ce
    SET_GPR_U32(ctx, 31, 0x1c3b60);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    PresetSoAccel__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1c3b60
// Address: 0x1c3b60 - 0x1c3b70

void entry_1c3b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b60: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1c3b64: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3b68: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1c3b70);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1604)); ctx->f[12] = *(float*)&val; }
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c3b70
// Address: 0x1c3b70 - 0x1c3b88

void entry_1c3b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b70: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c3b74: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3b78: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c3b7c: 0x24c64aa8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19112));
    // 0x1c3b80: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1c3b88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1c3b88
// Address: 0x1c3b88 - 0x1c3bbc

void entry_1c3b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3b88: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3b8c: 0xc600066c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1644)); ctx->f[0] = *(float*)&val; }
    // 0x1c3b90: 0xc44c4a9c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19100)); ctx->f[12] = *(float*)&val; }
    // 0x1c3b94: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c3b98: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1c3b9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3ba0: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1c3ba4: 0xda020650
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x1c3ba8: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c3bac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3bb0: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c3bb4: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x1c3bbc);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_1c3bbc
// Address: 0x1c3bbc - 0x1c3be8

void entry_1c3bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3bbc: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1c3bc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3bc4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c3bc8: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c3bcc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c3bd0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c3bd4: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c3bd8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3bdc: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c3be0: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c3be8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c3be8
// Address: 0x1c3be8 - 0x1c3c00

void entry_1c3be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3be8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c3bec: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c3bf0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c3bf4: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1c3bf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3c00
// Address: 0x1c3c00 - 0x1c3c34

void FUN_001c3c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3c00: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1c3c04: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1c3c08: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c3c0c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1c3c10: 0x2463023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 6)));
    // 0x1c3c14: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c3c18: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1c3c1c: 0x63180
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 6));
    // 0x1c3c20: 0xa68021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1c3c24: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3c28: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3c2c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1c3c34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 33));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1c3c34
// Address: 0x1c3c34 - 0x1c3c6c

void entry_1c3c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3c34) {
        switch (ctx->pc) {
            case 0x1c3c50: ctx->pc = 0; goto label_1c3c50;
            case 0x1c3c64: ctx->pc = 0; goto label_1c3c64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3c34: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1c3c64;
    }
    // 0x1c3c3c: 0x8e220694
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1684)));
    // 0x1c3c40: 0x58400003
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
        goto label_1c3c50;
    }
    // 0x1c3c48: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1664), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3C7C; return;
    }
label_1c3c50:
    // 0x1c3c50: 0x1440000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3C80; return;
    }
    // 0x1c3c58: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3c5c: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 17), 1668), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3C80; return;
    }
label_1c3c64:
    // 0x1c3c64: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x1c3c6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1327));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c3c6c
// Address: 0x1c3c6c - 0x1c3d28

void entry_1c3c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3c6c) {
        switch (ctx->pc) {
            case 0x1c3c7c: ctx->pc = 0; goto label_1c3c7c;
            case 0x1c3c80: ctx->pc = 0; goto label_1c3c80;
            case 0x1c3d20: ctx->pc = 0; goto label_1c3d20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3c6c: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c3c80;
    }
    // 0x1c3c74: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3c78: 0xae220688
    WRITE32(ADD32(GPR_U32(ctx, 17), 1672), GPR_U32(ctx, 2));
label_1c3c7c:
    // 0x1c3c7c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1c3c80:
    // 0x1c3c80: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c3c84: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c3c88: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c3c8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3c94: 0x0
    // NOP
    // 0x1c3c98: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3c9c: 0x8ce4067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 1660)));
    // 0x1c3ca0: 0x1080001f
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1c3d20;
    }
    // 0x1c3ca8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3cac: 0xc4e1068c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 1676)); ctx->f[1] = *(float*)&val; }
    // 0x1c3cb0: 0xc4404a44
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19012)); ctx->f[0] = *(float*)&val; }
    // 0x1c3cb4: 0x61980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 6));
    // 0x1c3cb8: 0x8c840008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1c3cbc: 0x651021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1c3cc0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1c3cc4: 0xd8430030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1c3cc8: 0xc4810034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1c3ccc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c3cd0: 0xd8e50140
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 320)));
    // 0x1c3cd4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1c3cd8: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1c3cdc: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1c3ce0: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c3ce4: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c3ce8: 0x4be5086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3cec: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3cf0: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c3cf4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c3cf8: 0x4b02308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c3cfc: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c3d00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c3d04: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c3d08: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c3d0c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c3d10: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c3d14: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1c3d18: 0x4be410c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c3d1c: 0xf8630030
    WRITE128(ADD32(GPR_U32(ctx, 3), 48), _mm_castps_si128(ctx->vu0_vf[3]));
label_1c3d20:
    // 0x1c3d20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3d28
// Address: 0x1c3d28 - 0x1c3d48

void FUN_001c3d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3d28: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1c3d2c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1c3d30: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1c3d34: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1c3d38: 0x14400005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3D50; return;
    }
    // 0x1c3d40: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1c3d48);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1c3d48
// Address: 0x1c3d48 - 0x1c3d60

void entry_1c3d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3d48) {
        switch (ctx->pc) {
            case 0x1c3d50: ctx->pc = 0; goto label_1c3d50;
            case 0x1c3d54: ctx->pc = 0; goto label_1c3d54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3d48: 0x10400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c3d54;
    }
label_1c3d50:
    // 0x1c3d50: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c3d54:
    // 0x1c3d54: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c3d58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3d60
// Address: 0x1c3d60 - 0x1c3d88

void FUN_001c3d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3d60: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1c3d64: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1c3d68: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1c3d6c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c3d70: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1c3d74: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3d78: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3d7c: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x1c3d80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3d88);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3d88
// Address: 0x1c3d88 - 0x1c3db4

void entry_1c3d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3d88: 0x1440002b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3E38; return;
    }
    // 0x1c3d90: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c3d94: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
        ctx->pc = 0x1C3DB8; return;
    }
    // 0x1c3d9c: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1c3da0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
        ctx->pc = 0x1C3DB8; return;
    }
    // 0x1c3da8: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1c3dac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3db4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3db4
// Address: 0x1c3db4 - 0x1c3de0

void entry_1c3db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3db4) {
        switch (ctx->pc) {
            case 0x1c3db8: ctx->pc = 0; goto label_1c3db8;
            case 0x1c3dcc: ctx->pc = 0; goto label_1c3dcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3db4: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
label_1c3db8:
    // 0x1c3db8: 0x28620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    // 0x1c3dbc: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c3dcc;
    }
    // 0x1c3dc4: 0x1040001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3E38; return;
    }
label_1c3dcc:
    // 0x1c3dcc: 0x8e020638
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1592)));
    // 0x1c3dd0: 0x14400019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3E38; return;
    }
    // 0x1c3dd8: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1c3de0);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c3de0
// Address: 0x1c3de0 - 0x1c3df0

void entry_1c3de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3de0: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C3E08; return;
    }
    // 0x1c3de8: 0xc070ff2
    SET_GPR_U32(ctx, 31, 0x1c3df0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_001c3fc8(rdram, ctx, runtime); return;
}


// Function: entry_1c3df0
// Address: 0x1c3df0 - 0x1c3e10

void entry_1c3df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3df0) {
        switch (ctx->pc) {
            case 0x1c3e08: ctx->pc = 0; goto label_1c3e08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3df0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c3df4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1c3df8: 0xae020638
    WRITE32(ADD32(GPR_U32(ctx, 16), 1592), GPR_U32(ctx, 2));
    // 0x1c3dfc: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c3e00: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1596), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c3e10(rdram, ctx, runtime); return;
    }
label_1c3e08:
    // 0x1c3e08: 0xc070ff2
    SET_GPR_U32(ctx, 31, 0x1c3e10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    FUN_001c3fc8(rdram, ctx, runtime); return;
}


// Function: entry_1c3e10
// Address: 0x1c3e10 - 0x1c3e34

void entry_1c3e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3e10: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1c3e14: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3e18: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1c3e1c: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1c3e20: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c3e24: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c3e28: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1c3e2c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1c3e34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1c3e34
// Address: 0x1c3e34 - 0x1c3e80

void entry_1c3e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3e34) {
        switch (ctx->pc) {
            case 0x1c3e38: ctx->pc = 0; goto label_1c3e38;
            case 0x1c3e74: ctx->pc = 0; goto label_1c3e74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3e34: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c3e38:
    // 0x1c3e38: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c3e3c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c3e40: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c3e44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3e4c: 0x0
    // NOP
    // 0x1c3e50: 0x8c830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1552)));
    // 0x1c3e54: 0x28620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    // 0x1c3e58: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1592)));
        goto label_1c3e74;
    }
    // 0x1c3e60: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1c3e64: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1592)));
        goto label_1c3e74;
    }
    // 0x1c3e6c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1c3e74:
    // 0x1c3e74: 0x3e00008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3e7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c3e80; return;
}


// Function: FUN_001c3e80
// Address: 0x1c3e80 - 0x1c3e94

void FUN_001c3e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3e80: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c3e84: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c3e88: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c3e8c: 0xc064b16
    SET_GPR_U32(ctx, 31, 0x1c3e94);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UsePoCharm__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1c3e94
// Address: 0x1c3e94 - 0x1c3ea0

void entry_1c3e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3e94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3e98: 0xc070ff2
    SET_GPR_U32(ctx, 31, 0x1c3ea0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_001c3fc8(rdram, ctx, runtime); return;
}


// Function: entry_1c3ea0
// Address: 0x1c3ea0 - 0x1c3eb0

void entry_1c3ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3ea0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c3ea4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c3ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3eb0
// Address: 0x1c3eb0 - 0x1c3f58

void FUN_001c3eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3eb0) {
        switch (ctx->pc) {
            case 0x1c3f30: ctx->pc = 0; goto label_1c3f30;
            case 0x1c3f3c: ctx->pc = 0; goto label_1c3f3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3eb0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1c3eb4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c3eb8: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1c3ebc: 0x8c424ab4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 19124)));
    // 0x1c3ec0: 0xd8820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x1c3ec4: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c3ec8: 0xd8a10140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
    // 0x1c3ecc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c3ed0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3ed4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c3ed8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c3edc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c3ee0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c3ee4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1c3ee8: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1c3eec: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c3ef0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c3ef4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c3ef8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c3efc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3f00: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c3f04: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3f08: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c3f0c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c3f10: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c3f14: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c3f18: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c3f1c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c3f20: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c3f30;
    }
    // 0x1c3f28: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c3f3c;
    }
label_1c3f30:
    // 0x1c3f30: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c3f34: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c3f38: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1c3f3c:
    // 0x1c3f3c: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c3f40: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c3f44: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c3f48: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c3f4c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1c3f50: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3f58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3f58
// Address: 0x1c3f58 - 0x1c3f68

void entry_1c3f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3f58: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c3f5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c3f64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c3f68; return;
}


// Function: FUN_001c3f68
// Address: 0x1c3f68 - 0x1c3f90

void FUN_001c3f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3f68: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1c3f6c: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1c3f70: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1c3f74: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3f78: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c3f7c: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1c3f80: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c3f84: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c3f88: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1c3f90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c3f90
// Address: 0x1c3f90 - 0x1c3fb4

void entry_1c3f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3f90: 0xafb00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 16));
    // 0x1c3f94: 0x3c02001c
    SET_GPR_U32(ctx, 2, ((uint32_t)28 << 16));
    // 0x1c3f98: 0x24423eb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16048));
    // 0x1c3f9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c3fa0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c3fa4: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1c3fa8: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1c3fac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c3fb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c3fb4
// Address: 0x1c3fb4 - 0x1c3fc8

void entry_1c3fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c3fb4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c3fb8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c3fbc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c3fc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c3fc8
// Address: 0x1c3fc8 - 0x1c4034

void FUN_001c3fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c3fc8) {
        switch (ctx->pc) {
            case 0x1c4010: ctx->pc = 0; goto label_1c4010;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c3fc8: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1c3fcc: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1c3fd0: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1c3fd4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c3fd8: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1c3fdc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c3fe0: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x1c3fe4: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x1c3fe8: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1c3fec: 0x1223005d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1C4164; return;
    }
    // 0x1c3ff4: 0x14620006
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c4010;
    }
    // 0x1c3ffc: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x1c4000: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c4004: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c4008: 0xae030694
    WRITE32(ADD32(GPR_U32(ctx, 16), 1684), GPR_U32(ctx, 3));
    // 0x1c400c: 0xe6000640
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1600), *(uint32_t*)&val); }
label_1c4010:
    // 0x1c4010: 0x2a220004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 4));
    // 0x1c4014: 0x1040002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1648), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c40c8(rdram, ctx, runtime); return;
    }
    // 0x1c401c: 0x2a220002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    // 0x1c4020: 0x14400029
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c40c8(rdram, ctx, runtime); return;
    }
    // 0x1c4028: 0xc60d0150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 336)); ctx->f[13] = *(float*)&val; }
    // 0x1c402c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c4034);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 340)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c4034
// Address: 0x1c4034 - 0x1c4048

void entry_1c4034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4034: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1c4038: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1c403c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c4040: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c4048);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c4048
// Address: 0x1c4048 - 0x1c406c

void entry_1c4048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4048: 0xe6000648
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1608), *(uint32_t*)&val); }
    // 0x1c404c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1c4050: 0xe6000644
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1604), *(uint32_t*)&val); }
    // 0x1c4054: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1c4058: 0xc60c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1c405c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c4060: 0xc60d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1c4064: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c406c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c406c
// Address: 0x1c406c - 0x1c4088

void entry_1c406c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c406c: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1c4070: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c4074: 0xc60d0644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1604)); ctx->f[13] = *(float*)&val; }
    // 0x1c4078: 0x37a50008
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 8));
    // 0x1c407c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c4080: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1c4088);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19112));
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1c4088
// Address: 0x1c4088 - 0x1c409c

void entry_1c4088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4088: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c408c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c4090: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1c4094: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c409c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c409c
// Address: 0x1c409c - 0x1c40c8

void entry_1c409c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c409c: 0xae000694
    WRITE32(ADD32(GPR_U32(ctx, 16), 1684), GPR_U32(ctx, 0));
    // 0x1c40a0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c40a4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c40a8: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c40ac: 0x16230006
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294959656), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        entry_1c40c8(rdram, ctx, runtime); return;
    }
    // 0x1c40b4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c40b8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c40bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c40c0: 0xc054788
    SET_GPR_U32(ctx, 31, 0x1c40c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_1c40c8
// Address: 0x1c40c8 - 0x1c4130

void entry_1c40c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c40c8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1c40cc: 0x2e220005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 5));
    // 0x1c40d0: 0x10400019
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4138; return;
    }
    // 0x1c40d8: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1c40dc: 0x2442d570
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956400));
    // 0x1c40e0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c40e4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c40e8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c40f0: 0x10000011
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1560)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4138; return;
    }
    // 0x1c40f8: 0x1000000f
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4138; return;
    }
    // 0x1c4100: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c4104: 0x8e120620
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1568)));
    // 0x1c4108: 0xc440d560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956384)); ctx->f[0] = *(float*)&val; }
    // 0x1c410c: 0x1000000a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1600), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4138; return;
    }
    // 0x1c4114: 0x10000008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1572)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4138; return;
    }
    // 0x1c411c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c4120: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4124: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1c4128: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1c4130);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 26));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1c4130
// Address: 0x1c4130 - 0x1c4154

void entry_1c4130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4130) {
        switch (ctx->pc) {
            case 0x1c4138: ctx->pc = 0; goto label_1c4138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4130: 0x8e120624
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1572)));
    // 0x1c4134: 0xc64c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[12] = *(float*)&val; }
label_1c4138:
    // 0x1c4138: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c413c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c4140: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c4144: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c4148: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c414c: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1c4154);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1576));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c4154
// Address: 0x1c4154 - 0x1c4180

void entry_1c4154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4154) {
        switch (ctx->pc) {
            case 0x1c4164: ctx->pc = 0; goto label_1c4164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4154: 0xae110610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 17));
    // 0x1c4158: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x1c415c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c4160: 0xe6000614
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1556), *(uint32_t*)&val); }
label_1c4164:
    // 0x1c4164: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c4168: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c416c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c4170: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4174: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c4180
// Address: 0x1c4180 - 0x1c41a0

void FUN_001c4180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4180: 0x8c830698
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1688)));
    // 0x1c4184: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c4188: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c418c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1c4190: 0xac45069c
    WRITE32(ADD32(GPR_U32(ctx, 2), 1692), GPR_U32(ctx, 5));
    // 0x1c4194: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1688), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c419c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c41a0; return;
}


// Function: FUN_001c41a0
// Address: 0x1c41a0 - 0x1c422c

void FUN_001c41a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c41a0) {
        switch (ctx->pc) {
            case 0x1c4200: ctx->pc = 0; goto label_1c4200;
            case 0x1c4218: ctx->pc = 0; goto label_1c4218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c41a0: 0x27bdfef0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967024));
    // 0x1c41a4: 0x7fb400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 20));
    // 0x1c41a8: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x1c41ac: 0xa0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c41b0: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x1c41b4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c41b8: 0x7fbf00f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 31));
    // 0x1c41bc: 0x7fbe00e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 30));
    // 0x1c41c0: 0x7fb700d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 23));
    // 0x1c41c4: 0x7fb600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 22));
    // 0x1c41c8: 0x7fb500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 21));
    // 0x1c41cc: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x1c41d0: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x1c41d4: 0xe7b50108
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 264), *(uint32_t*)&val); }
    // 0x1c41d8: 0xe7b40100
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1c41dc: 0x8e63071c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1820)));
    // 0x1c41e0: 0x1860000d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1c4218;
    }
    // 0x1c41e8: 0x8e620720
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1824)));
    // 0x1c41ec: 0x1054000a
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 19), 1824));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        goto label_1c4218;
    }
    // 0x1c41f4: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1c41f8: 0x2c0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1c41fc: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_1c4200:
    // 0x1c4200: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x1c4204: 0x10400004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c4218;
    }
    // 0x1c420c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c4210: 0x5454fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_1c4200;
    }
label_1c4218:
    // 0x1c4218: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1c421c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c4220: 0xafa20054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    // 0x1c4224: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1c422c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c422c
// Address: 0x1c422c - 0x1c4280

void entry_1c422c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c422c) {
        switch (ctx->pc) {
            case 0x1c4268: ctx->pc = 0; goto label_1c4268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c422c: 0x26760720
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 19), 1824));
    // 0x1c4230: 0x14400072
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c43fc(rdram, ctx, runtime); return;
    }
    // 0x1c4238: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c423c: 0x8e640698
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1688)));
    // 0x1c4240: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1c4244: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1c4248: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c424c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4250: 0x27be0010
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c4254: 0x1880002f
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x1C4314; return;
    }
    // 0x1c425c: 0x2677069c
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 19), 1692));
    // 0x1c4260: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1c4264: 0x0
    // NOP
label_1c4268:
    // 0x1c4268: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c426c: 0x2e21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1c4270: 0x26150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1c4274: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c4278: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1c4280);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c4280
// Address: 0x1c4280 - 0x1c42a4

void entry_1c4280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4280) {
        switch (ctx->pc) {
            case 0x1c4298: ctx->pc = 0; goto label_1c4298;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4280: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1c4284: 0x8e62071c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1820)));
    // 0x1c4288: 0x18400017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294956420)); ctx->f[20] = *(float*)&val; }
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1C42E8; return;
    }
    // 0x1c4290: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1c4294: 0x0
    // NOP
label_1c4298:
    // 0x1c4298: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c429c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1c42a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c42a4
// Address: 0x1c42a4 - 0x1c4324

void entry_1c42a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c42a4) {
        switch (ctx->pc) {
            case 0x1c42d4: ctx->pc = 0; goto label_1c42d4;
            case 0x1c42e8: ctx->pc = 0; goto label_1c42e8;
            case 0x1c4300: ctx->pc = 0; goto label_1c4300;
            case 0x1c4314: ctx->pc = 0; goto label_1c4314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c42a4: 0x1040000b
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c42d4;
    }
    // 0x1c42ac: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1c42b0: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c42b4: 0x4b8210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c42b8: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c42bc: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c42c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c42c4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c42c8: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c42cc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1c42d0: 0x46140529
    ctx->f[20] = std::min(ctx->f[0], ctx->f[20]);
label_1c42d4:
    // 0x1c42d4: 0x8e62071c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1820)));
    // 0x1c42d8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1c42dc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c42e0: 0x1440ffed
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4298; return;
    }
label_1c42e8:
    // 0x1c42e8: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c42ec: 0x0
    // NOP
    // 0x1c42f0: 0x45000003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c4300;
    }
    // 0x1c42f8: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
    // 0x1c42fc: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
label_1c4300:
    // 0x1c4300: 0x8e620698
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1688)));
    // 0x1c4304: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c4308: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1c430c: 0x1440ffd6
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4268; return;
    }
label_1c4314:
    // 0x1c4314: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c4318: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c431c: 0xc049b2e
    SET_GPR_U32(ctx, 31, 0x1c4324);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FadeAloIn__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1c4324
// Address: 0x1c4324 - 0x1c4340

void entry_1c4324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4324: 0xc6800108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1c4328: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1c432c: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1c4330: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1c4334: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1c4338: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c4340);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c4340
// Address: 0x1c4340 - 0x1c434c

void entry_1c4340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4340: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c4344: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1c434c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 33));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1c434c
// Address: 0x1c434c - 0x1c4378

void entry_1c434c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c434c: 0x1040002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4400; return;
    }
    // 0x1c4354: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x1c4358: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1c435c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c4360: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1c4364: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1c4368: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c436c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1c4370: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1c4378);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c4378
// Address: 0x1c4378 - 0x1c4390

void entry_1c4378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4378: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c437c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1c4380: 0x24434ab8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19128));
    // 0x1c4384: 0xc44c4ab8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19128)); ctx->f[12] = *(float*)&val; }
    // 0x1c4388: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1c4390);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c4390
// Address: 0x1c4390 - 0x1c43a4

void entry_1c4390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4390: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x1c4394: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1c4398: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1c439c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1c43a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1c43a4
// Address: 0x1c43a4 - 0x1c43b8

void entry_1c43a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c43a4: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1c43a8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c43ac: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1c43b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c43b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c43b8
// Address: 0x1c43b8 - 0x1c43cc

void entry_1c43b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c43b8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c43bc: 0x24624ac0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 19136));
    // 0x1c43c0: 0xc46c4ac0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19136)); ctx->f[12] = *(float*)&val; }
    // 0x1c43c4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1c43cc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c43cc
// Address: 0x1c43cc - 0x1c43fc

void entry_1c43cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c43cc: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1c43d0: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x1c43d4: 0x70821488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1c43d8: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1c43dc: 0x70821389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1c43e0: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1c43e4: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1c43e8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c43ec: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x1c43f0: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1c43f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c43fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c43fc
// Address: 0x1c43fc - 0x1c4458

void entry_1c43fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c43fc) {
        switch (ctx->pc) {
            case 0x1c4400: ctx->pc = 0; goto label_1c4400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c43fc: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
label_1c4400:
    // 0x1c4400: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c4404: 0x2c31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 3)));
    // 0x1c4408: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c440c: 0xac540000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 20));
    // 0x1c4410: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c4414: 0x8e63071c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1820)));
    // 0x1c4418: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c441c: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1c4420: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1c4424: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c4428: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x1c442c: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c4430: 0xae63071c
    WRITE32(ADD32(GPR_U32(ctx, 19), 1820), GPR_U32(ctx, 3));
    // 0x1c4434: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c4438: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c443c: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c4440: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c4444: 0xc7b50108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[21] = *(float*)&val; }
    // 0x1c4448: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x1c444c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c4454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c4458; return;
}


// Function: InitStep__FP4STEP
// Address: 0x1c4458 - 0x1c446c

void entry_1c446c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c446c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c4470: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c4474: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c4478: 0xc4414b20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19232)); ctx->f[1] = *(float*)&val; }
    // 0x1c447c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c4480: 0xe6000700
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1792), *(uint32_t*)&val); }
    // 0x1c4484: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c4488: 0xc071794
    SET_GPR_U32(ctx, 31, 0x1c4490);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 864), *(uint32_t*)&val); }
    SetStepSpinRatio__FP4STEPf(rdram, ctx, runtime); return;
}


// Function: entry_1c4490
// Address: 0x1c4490 - 0x1c44f0

void entry_1c4490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4490: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c4494: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1c4498: 0x24634b30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 19248));
    // 0x1c449c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c44a0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c44a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c44a8: 0x7e0206f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1776), GPR_VEC(ctx, 2));
    // 0x1c44ac: 0x24a74b40
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 19264));
    // 0x1c44b0: 0x68e20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c44b4: 0x6ce20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c44b8: 0x8ce30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x1c44bc: 0xb2020717
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1815); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c44c0: 0xb6020710
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1808); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c44c4: 0xae030718
    WRITE32(ADD32(GPR_U32(ctx, 16), 1816), GPR_U32(ctx, 3));
    // 0x1c44c8: 0x24864b50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 19280));
    // 0x1c44cc: 0x68c20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c44d0: 0x6cc20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1c44d4: 0x8cc30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1c44d8: 0xb202070b
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1803); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c44dc: 0xb6020704
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1796); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1c44e0: 0xae03070c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1804), GPR_U32(ctx, 3));
    // 0x1c44e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c44e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostStepLoad__FP4STEP
// Address: 0x1c44f0 - 0x1c4504

void entry_1c4504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4504: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c4508: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c450c: 0x24c64ad8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19160));
    // 0x1c4510: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1c4518);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1c4518
// Address: 0x1c4518 - 0x1c4524

void entry_1c4518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4518: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c451c: 0xc07115e
    SET_GPR_U32(ctx, 31, 0x1c4524);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    LimitStepHands__FP4STEPi(rdram, ctx, runtime); return;
}


// Function: entry_1c4524
// Address: 0x1c4524 - 0x1c4578

void entry_1c4524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4524) {
        switch (ctx->pc) {
            case 0x1c4530: ctx->pc = 0; goto label_1c4530;
            case 0x1c4540: ctx->pc = 0; goto label_1c4540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4524: 0x8e020628
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1576)));
    // 0x1c4528: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1568)));
        goto label_1c4530;
    }
label_1c4530:
    // 0x1c4530: 0xae020610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 2));
    // 0x1c4534: 0x8e02062c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1580)));
    // 0x1c4538: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1572)));
        goto label_1c4540;
    }
label_1c4540:
    // 0x1c4540: 0xae020614
    WRITE32(ADD32(GPR_U32(ctx, 16), 1556), GPR_U32(ctx, 2));
    // 0x1c4544: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1c4548: 0x26050660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1c454c: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x1c4550: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4554: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c4558: 0x7e020660
    WRITE128(ADD32(GPR_U32(ctx, 16), 1632), GPR_VEC(ctx, 2));
    // 0x1c455c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4560: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1c4564: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x1c4568: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1c456c: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x1c4570: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LimitStepHands__FP4STEPi
// Address: 0x1c4578 - 0x1c4618

void FUN_001c4618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4618: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x1c461c: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x1c4620: 0x7fb20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 18));
    // 0x1c4624: 0x100882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1c4628: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1c462c: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c4630: 0xe7b40070
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x1c4634: 0xe0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1c4638: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1c463c: 0xae200050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 0));
    // 0x1c4640: 0x8e060224
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x1c4644: 0x10c0004b
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4774; return;
    }
    // 0x1c464c: 0x8cc200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 176)));
    // 0x1c4650: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1c4654: 0x10400047
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4774; return;
    }
    // 0x1c465c: 0x24c60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 96));
    // 0x1c4660: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4664: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1c466c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c466c
// Address: 0x1c466c - 0x1c4790

void entry_1c466c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c466c) {
        switch (ctx->pc) {
            case 0x1c46d4: ctx->pc = 0; goto label_1c46d4;
            case 0x1c46e4: ctx->pc = 0; goto label_1c46e4;
            case 0x1c4774: ctx->pc = 0; goto label_1c4774;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c466c: 0x8e040224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x1c4670: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c4674: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4678: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1c467c: 0x8c830080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 128)));
    // 0x1c4680: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c4684: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c4688: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c468c: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1c4690: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c4694: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c4698: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c469c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c46a0: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c46a4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c46a8: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c46ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c46b0: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c46b4: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c46b8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c46bc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c46c0: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c46d4;
    }
    // 0x1c46c8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c46cc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c46e4;
    }
label_1c46d4:
    // 0x1c46d4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c46d8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c46dc: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c46e0: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c46e4:
    // 0x1c46e4: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x1c46e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c46ec: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c46f0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1c46f4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c46f8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c46fc: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c4700: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1c4704: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4708: 0x0
    // NOP
    // 0x1c470c: 0x45010019
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 128), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c4774;
    }
    // 0x1c4714: 0x4600a047
    ctx->f[1] = FPU_NEG_S(ctx->f[20]);
    // 0x1c4718: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c471c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1c4720: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1c4724: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c4728: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1c472c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c4730: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1c4734: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c4738: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c473c: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c4740: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1c4744: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4748: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c474c: 0xc441d588
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956424)); ctx->f[1] = *(float*)&val; }
    // 0x1c4750: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c4754: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c4758: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c475c: 0x4be40848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c4760: 0xe62100d0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 208), *(uint32_t*)&val); }
    // 0x1c4764: 0xfa210070
    WRITE128(ADD32(GPR_U32(ctx, 17), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c4768: 0xae230050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 3));
    // 0x1c476c: 0xfa220060
    WRITE128(ADD32(GPR_U32(ctx, 17), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c4770: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
label_1c4774:
    // 0x1c4774: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c4778: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c477c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c4780: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c4784: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1c4788: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c4790
// Address: 0x1c4790 - 0x1c47c4

void FUN_001c4790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4790: 0x27bdff00
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967040));
    // 0x1c4794: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c4798: 0x7fb000e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 16));
    // 0x1c479c: 0x7fbf00f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 31));
    // 0x1c47a0: 0xe0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1c47a4: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1c47a8: 0x10400023
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4838; return;
    }
    // 0x1c47b0: 0x26060070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 112));
    // 0x1c47b4: 0x26070060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 96));
    // 0x1c47b8: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c47bc: 0xc050724
    SET_GPR_U32(ctx, 31, 0x1c47c4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ClsgClipEdgeToObjectPruned__FP2SOP3BSPP6VECTORT2iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1c47c4
// Address: 0x1c47c4 - 0x1c4848

void entry_1c47c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c47c4) {
        switch (ctx->pc) {
            case 0x1c47e4: ctx->pc = 0; goto label_1c47e4;
            case 0x1c4814: ctx->pc = 0; goto label_1c4814;
            case 0x1c4838: ctx->pc = 0; goto label_1c4838;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c47c4: 0x18400007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1c47e4;
    }
    // 0x1c47cc: 0xc7a10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1c47d0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c47d4: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c47d8: 0x0
    // NOP
    // 0x1c47dc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1c47e4;
    }
label_1c47e4:
    // 0x1c47e4: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1c47e8: 0x10400013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c4838;
    }
    // 0x1c47f0: 0xc60100d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[1] = *(float*)&val; }
    // 0x1c47f4: 0x622018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c47f8: 0x9d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
    // 0x1c47fc: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1c4800: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4804: 0x0
    // NOP
    // 0x1c4808: 0x4500000b
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 144));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c4838;
    }
    // 0x1c4810: 0x24430060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 96));
label_1c4814:
    // 0x1c4814: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c4818: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c481c: 0x7cc50000
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), GPR_VEC(ctx, 5));
    // 0x1c4820: 0x7cc70010
    WRITE128(ADD32(GPR_U32(ctx, 6), 16), GPR_VEC(ctx, 7));
    // 0x1c4824: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1c4828: 0x1443fffa
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1c4814;
    }
    // 0x1c4830: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c4834: 0x7cc50000
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), GPR_VEC(ctx, 5));
label_1c4838:
    // 0x1c4838: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c483c: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c4840: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c4848
// Address: 0x1c4848 - 0x1c48ec

void FUN_001c4848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4848: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x1c484c: 0x7fb30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 19));
    // 0x1c4850: 0x7fb20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 18));
    // 0x1c4854: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c4858: 0x7fb10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 17));
    // 0x1c485c: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x1c4860: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1c4864: 0x7fb00040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 16));
    // 0x1c4868: 0xe7b40090
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x1c486c: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1c4870: 0x1040004c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c49a4(rdram, ctx, runtime); return;
    }
    // 0x1c4878: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c487c: 0xc62100d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 208)); ctx->f[1] = *(float*)&val; }
    // 0x1c4880: 0xc440d58c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956428)); ctx->f[0] = *(float*)&val; }
    // 0x1c4884: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4888: 0x0
    // NOP
    // 0x1c488c: 0x45010045
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        entry_1c49a4(rdram, ctx, runtime); return;
    }
    // 0x1c4894: 0xda240060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x1c4898: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c489c: 0x8e220080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1c48a0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c48a4: 0xda230070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x1c48a8: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c48ac: 0xda220090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 144)));
    // 0x1c48b0: 0x4be320ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1c48b4: 0x4be410ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c48b8: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1c48bc: 0x4a6503bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1c48c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c48c4: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c48c8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c48cc: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c48d0: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c48d4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c48d8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c48dc: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c48e0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c48e4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1c48ec);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c48ec
// Address: 0x1c48ec - 0x1c4900

void entry_1c48ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c48ec: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c48f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c48f4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1c48f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c4900);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c4900
// Address: 0x1c4900 - 0x1c4924

void entry_1c4900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4900: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c4904: 0x26660140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1c4908: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c490c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4910: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c4914: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4918: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c491c: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1c4924);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1c4924
// Address: 0x1c4924 - 0x1c4968

void entry_1c4924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4924: 0xda2200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 176)));
    // 0x1c4928: 0x262600b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 176));
    // 0x1c492c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4930: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c4934: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c4938: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c493c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c4940: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c4944: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c4948: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1c494c: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4950: 0x0
    // NOP
    // 0x1c4954: 0x45000013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1c49a4(rdram, ctx, runtime); return;
    }
    // 0x1c495c: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1c4960: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1c4968);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c4968
// Address: 0x1c4968 - 0x1c49a4

void entry_1c4968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4968: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
    // 0x1c496c: 0xda420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1c4970: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4974: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c4978: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c497c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c4980: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c4984: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c4988: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c498c: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c4990: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c4994: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c4998: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1c499c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c49a4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c49a4
// Address: 0x1c49a4 - 0x1c49c8

void entry_1c49a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c49a4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c49a8: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c49ac: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c49b0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c49b4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c49b8: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1c49bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c49c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c49c8; return;
}


// Function: RenderStepSelf__FP4STEPP2CMP2RO
// Address: 0x1c49c8 - 0x1c49d8

void entry_1c49d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c49d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c49dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c49e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c49e8; return;
}


// Function: ReadStepJoystick__FP4STEPP3JOY
// Address: 0x1c49e8 - 0x1c4a4c

void entry_1c4a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4a4c) {
        switch (ctx->pc) {
            case 0x1c4a54: ctx->pc = 0; goto label_1c4a54;
            case 0x1c4a60: ctx->pc = 0; goto label_1c4a60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4a4c: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c4a60;
    }
label_1c4a54:
    // 0x1c4a54: 0xc6000638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[0] = *(float*)&val; }
    // 0x1c4a58: 0xe6000630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1584), *(uint32_t*)&val); }
    // 0x1c4a5c: 0xc6200048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
label_1c4a60:
    // 0x1c4a60: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c4a64: 0xe6000634
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1588), *(uint32_t*)&val); }
    // 0x1c4a68: 0xe6404b5c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 19292), *(uint32_t*)&val); }
    // 0x1c4a6c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4a70: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4a74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4a78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStepFootfall__FP4STEPfP3SFF
// Address: 0x1c4a80 - 0x1c4af4

void entry_1c4af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4af4: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4af8: 0x0
    // NOP
    // 0x1c4afc: 0x4500000a
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C4B28; return;
    }
    // 0x1c4b04: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1c4b08: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1c4b10);
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[12]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c4b10
// Address: 0x1c4b10 - 0x1c4b4c

void entry_1c4b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4b10) {
        switch (ctx->pc) {
            case 0x1c4b28: ctx->pc = 0; goto label_1c4b28;
            case 0x1c4b2c: ctx->pc = 0; goto label_1c4b2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4b10: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4b14: 0x0
    // NOP
    // 0x1c4b18: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1732)); ctx->f[0] = *(float*)&val; }
        goto label_1c4b2c;
    }
    // 0x1c4b20: 0x10000016
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C4B7C; return;
    }
label_1c4b28:
    // 0x1c4b28: 0xc62006c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1732)); ctx->f[0] = *(float*)&val; }
label_1c4b2c:
    // 0x1c4b2c: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c4b30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c4b34: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1c4b38: 0x460c0301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x1c4b3c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c4b40: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1c4b44: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1c4b4c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c4b4c
// Address: 0x1c4b4c - 0x1c4b68

void entry_1c4b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4b4c: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4b50: 0x0
    // NOP
    // 0x1c4b54: 0x4500002a
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1c4c00(rdram, ctx, runtime); return;
    }
    // 0x1c4b5c: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c4b60: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1c4b68);
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[12]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c4b68
// Address: 0x1c4b68 - 0x1c4b88

void entry_1c4b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4b68) {
        switch (ctx->pc) {
            case 0x1c4b7c: ctx->pc = 0; goto label_1c4b7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4b68: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c4b6c: 0x0
    // NOP
    // 0x1c4b70: 0x45000024
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C4C04; return;
    }
    // 0x1c4b78: 0xc614000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[20] = *(float*)&val; }
label_1c4b7c:
    // 0x1c4b7c: 0x2405004a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 74));
    // 0x1c4b80: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x1c4b88);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 71));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1c4b88
// Address: 0x1c4b88 - 0x1c4bf8

void entry_1c4b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4b88) {
        switch (ctx->pc) {
            case 0x1c4bbc: ctx->pc = 0; goto label_1c4bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4b88: 0x3c060060
    SET_GPR_U32(ctx, 6, ((uint32_t)96 << 16));
    // 0x1c4b8c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c4b90: 0x8cc25548
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 21832)));
    // 0x1c4b94: 0x14a20009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967226));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1c4bbc;
    }
    // 0x1c4b9c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c4ba0: 0x24a2ffbd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4294967229));
    // 0x1c4ba4: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1c4ba8: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x1c4bac: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1c4bb0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1c4bb4: 0x822023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1c4bb8: 0x24850047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 71));
label_1c4bbc:
    // 0x1c4bbc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1c4bc0: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c4bc4: 0xacc55548
    WRITE32(ADD32(GPR_U32(ctx, 6), 21832), GPR_U32(ctx, 5));
    // 0x1c4bc8: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1c4bcc: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x1c4bd0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c4bd4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1c4bd8: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x1c4bdc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c4be0: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1c4be4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4be8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4bec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c4bf0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1c4bf8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1c4bf8
// Address: 0x1c4bf8 - 0x1c4c00

void entry_1c4bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4bf8: 0xc0703b0
    SET_GPR_U32(ctx, 31, 0x1c4c00);
    NextSneakyFootstep__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c4c00
// Address: 0x1c4c00 - 0x1c4c20

void entry_1c4c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4c00) {
        switch (ctx->pc) {
            case 0x1c4c04: ctx->pc = 0; goto label_1c4c04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4c00: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c4c04:
    // 0x1c4c04: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4c08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4c0c: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x1c4c10: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1c4c14: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1c4c18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStepPhys__FP4STEP
// Address: 0x1c4c20 - 0x1c4cf4

void entry_1c4cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4cf4) {
        switch (ctx->pc) {
            case 0x1c4d34: ctx->pc = 0; goto label_1c4d34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4cf4: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x1c4cf8: 0xc6210000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1c4cfc: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4d00: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1c4d04: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1c4d08: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1c4d0c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1c4d10: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x1c4d14: 0x661ffee
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x1C4CD0; return;
    }
    // 0x1c4d1c: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4d20: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1c4d24: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1c4d28: 0x461ffd5
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) >= 0) {
        ctx->pc = 0x1C4C80; return;
    }
    // 0x1c4d30: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_1c4d34:
    // 0x1c4d34: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c4d38: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c4d3c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c4d40: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c4d44: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c4d48: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c4d4c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c4d50: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c4d54: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c4d58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepPhys__FP4STEPP2SOi
// Address: 0x1c4d60 - 0x1c4e9c

void entry_1c4e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4e9c: 0x8e2203c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 968)));
    // 0x1c4ea0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1756), GPR_U32(ctx, 16));
        ctx->pc = 0x1C4EB8; return;
    }
    // 0x1c4ea8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1c4eac: 0xc06efae
    SET_GPR_U32(ctx, 31, 0x1c4eb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ProjectSoLvo__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1c4eb4
// Address: 0x1c4eb4 - 0x1c4ed0

void entry_1c4eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c4eb4) {
        switch (ctx->pc) {
            case 0x1c4eb8: ctx->pc = 0; goto label_1c4eb8;
            case 0x1c4ebc: ctx->pc = 0; goto label_1c4ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c4eb4: 0xae3006dc
    WRITE32(ADD32(GPR_U32(ctx, 17), 1756), GPR_U32(ctx, 16));
label_1c4eb8:
    // 0x1c4eb8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c4ebc:
    // 0x1c4ebc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4ec0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c4ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c4ed0; return;
}


// Function: UpdateStep__FP4STEPf
// Address: 0x1c4ed0 - 0x1c4ee4

void entry_1c4ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4ee4: 0xc071308
    SET_GPR_U32(ctx, 31, 0x1c4eec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepPhys__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c4eec
// Address: 0x1c4eec - 0x1c4f00

void entry_1c4eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4eec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4ef0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4ef4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c4efc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c4f00; return;
}


// Function: CtTorqueStep__FP4STEP
// Address: 0x1c4f00 - 0x1c4f08

void entry_1c4f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4f54: 0xae020470
    WRITE32(ADD32(GPR_U32(ctx, 16), 1136), GPR_U32(ctx, 2));
    // 0x1c4f58: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c4f5c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c4f60: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c4f64: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c4f68: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c4f6c: 0xc06f20a
    SET_GPR_U32(ctx, 31, 0x1c4f74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PropagateSoForce__FP2SOiP2XPiP2DZP2FX(rdram, ctx, runtime); return;
}


// Function: entry_1c4f74
// Address: 0x1c4f74 - 0x1c4fa0

void entry_1c4f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4f74: 0xae160470
    WRITE32(ADD32(GPR_U32(ctx, 16), 1136), GPR_U32(ctx, 22));
    // 0x1c4f78: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c4f7c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c4f80: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c4f84: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c4f88: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c4f8c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4f90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4f94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4f98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RotateStepToMat__FP4STEPP7MATRIX3
// Address: 0x1c4fa0 - 0x1c4fbc

void entry_1c4fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4fbc: 0xc60d0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[13] = *(float*)&val; }
    // 0x1c4fc0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c4fc8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c4fc8
// Address: 0x1c4fc8 - 0x1c4fe0

void entry_1c4fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4fc8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c4fcc: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x1c4fd0: 0xe6200638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    // 0x1c4fd4: 0x8c620160
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 352)));
    // 0x1c4fd8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c4fe0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c4fe0
// Address: 0x1c4fe0 - 0x1c4ff8

void entry_1c4fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c4fe0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c4fe4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c4fe8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c4fec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c4ff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c4ff8; return;
}


// Function: CloneStepPhys__FP4STEPP2SOi
// Address: 0x1c4ff8 - 0x1c5024

void entry_1c5024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5024: 0x26040140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1c5028: 0x26050110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1c502c: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1c5034);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1c5034
// Address: 0x1c5034 - 0x1c50b4

void entry_1c5034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5034) {
        switch (ctx->pc) {
            case 0x1c5050: ctx->pc = 0; goto label_1c5050;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5034: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c5038: 0x8e030384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 900)));
    // 0x1c503c: 0x1860002e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956432)); ctx->f[20] = *(float*)&val; }
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1C50F8; return;
    }
    // 0x1c5044: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c5048: 0x24538d20
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1c504c: 0x8e040388
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 904)));
label_1c5050:
    // 0x1c5050: 0x113100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 17), 4));
    // 0x1c5054: 0x2462ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1c5058: 0x16220018
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C50BC; return;
    }
    // 0x1c5060: 0xc60006cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1740)); ctx->f[0] = *(float*)&val; }
    // 0x1c5064: 0x121100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 4));
    // 0x1c5068: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1c506c: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1c5070: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1c5074: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c5078: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c507c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c5080: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c5084: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c5088: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c508c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5090: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c5094: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5098: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c509c: 0xae1106d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1744), GPR_U32(ctx, 17));
    // 0x1c50a0: 0x8e0203ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 940)));
    // 0x1c50a4: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1c50a8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c50ac: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x1c50b4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1748), GPR_U32(ctx, 2));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_1c50b4
// Address: 0x1c50b4 - 0x1c5118

void entry_1c50b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c50b4) {
        switch (ctx->pc) {
            case 0x1c50bc: ctx->pc = 0; goto label_1c50bc;
            case 0x1c50e8: ctx->pc = 0; goto label_1c50e8;
            case 0x1c50f8: ctx->pc = 0; goto label_1c50f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c50b4: 0x1000000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 900)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c50e8;
    }
label_1c50bc:
    // 0x1c50bc: 0xc4a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1c50c0: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c50c4: 0x0
    // NOP
    // 0x1c50c8: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 900)));
        goto label_1c50e8;
    }
    // 0x1c50d0: 0x8e0203ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 940)));
    // 0x1c50d4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1c50d8: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c50dc: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1c50e0: 0xae0206d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1752), GPR_U32(ctx, 2));
    // 0x1c50e4: 0x8e030384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 900)));
label_1c50e8:
    // 0x1c50e8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1c50ec: 0x223102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 3)));
    // 0x1c50f0: 0x5440ffd7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 904)));
        ctx->pc = 0x1C5050; return;
    }
label_1c50f8:
    // 0x1c50f8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c50fc: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c5100: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c5104: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c5108: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c510c: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1c5110: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetStepAccel__FP4STEPf
// Address: 0x1c5118 - 0x1c512c

void entry_1c512c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c512c: 0xc071452
    SET_GPR_U32(ctx, 31, 0x1c5134);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PresetStepAccelBase__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c5134
// Address: 0x1c5134 - 0x1c5148

void entry_1c5134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5134: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5138: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c513c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c5144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c5148; return;
}


// Function: PresetStepAccelBase__FP4STEP
// Address: 0x1c5148 - 0x1c5174

void entry_1c5174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5174) {
        switch (ctx->pc) {
            case 0x1c5190: ctx->pc = 0; goto label_1c5190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5174: 0x8e4206dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1756)));
    // 0x1c5178: 0x1040002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5230; return;
    }
    // 0x1c5180: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x1c5184: 0x14400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1696));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c5190;
    }
    // 0x1c518c: 0x8e4306d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1748)));
label_1c5190:
    // 0x1c5190: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c5194: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c5198: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1c519c: 0x26510440
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 1088));
    // 0x1c51a0: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c51a4: 0xda410180
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 384)));
    // 0x1c51a8: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1c51ac: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c51b0: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c51b4: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c51b8: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c51bc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c51c0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c51c4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c51c8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c51cc: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x1c51d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1c51d4
// Address: 0x1c51d4 - 0x1c51e0

void entry_1c51d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c51d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c51d8: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c51e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c51e0
// Address: 0x1c51e0 - 0x1c5220

void entry_1c51e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c51e0: 0xda420160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1c51e4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c51e8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c51ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c51f0: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1c51f4: 0x4bc2086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c51f8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c51fc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c5200: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1c5204: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5208: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c520c: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5210: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5214: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c5218: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x1c5220);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1c5220
// Address: 0x1c5220 - 0x1c522c

void entry_1c5220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5220: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c5224: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c522c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c522c
// Address: 0x1c522c - 0x1c5248

void entry_1c522c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c522c) {
        switch (ctx->pc) {
            case 0x1c5230: ctx->pc = 0; goto label_1c5230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c522c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1c5230:
    // 0x1c5230: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c5234: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c5238: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c523c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c5244: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c5248; return;
}


// Function: FCheckStepXpBase__FP4STEPP2XPi
// Address: 0x1c5248 - 0x1c5338

void entry_1c5354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5354) {
        switch (ctx->pc) {
            case 0x1c536c: ctx->pc = 0; goto label_1c536c;
            case 0x1c5374: ctx->pc = 0; goto label_1c5374;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5354: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c536c;
    }
    // 0x1c535c: 0xc4404b74
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19316)); ctx->f[0] = *(float*)&val; }
    // 0x1c5360: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
    // 0x1c5364: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c5374;
    }
label_1c536c:
    // 0x1c536c: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
    // 0x1c5370: 0xae000094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 0));
label_1c5374:
    // 0x1c5374: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5378: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c537c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c5384: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c5388; return;
}


// Function: AdjustStepDz__FP4STEPiP2DZif
// Address: 0x1c5388 - 0x1c5398

void entry_1c5398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5398: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c539c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c53a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c53a8; return;
}


// Function: AdjustStepDzBase__FP4STEPiP2DZi
// Address: 0x1c53a8 - 0x1c53b0

void entry_1c53d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c53d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c53d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c53dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c53e0; return;
}


// Function: AdjustStepXpVelocity__FP4STEPP2XPi
// Address: 0x1c53e0 - 0x1c540c

void entry_1c540c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c540c: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c5420(rdram, ctx, runtime); return;
    }
    // 0x1c5414: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c5418: 0xc071534
    SET_GPR_U32(ctx, 31, 0x1c5420);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AdjustStepXpVelocityBase__FP4STEPP2XPi(rdram, ctx, runtime); return;
}


// Function: entry_1c5420
// Address: 0x1c5420 - 0x1c5438

void entry_1c5420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5420: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c5424: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5428: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c542c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c5430: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStepXfWorld__FP4STEP
// Address: 0x1c5438 - 0x1c544c

void entry_1c544c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c544c: 0xc60c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1c5450: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c5458);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c5458
// Address: 0x1c5458 - 0x1c5464

void entry_1c5458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5458: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1c545c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c5464);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c5464
// Address: 0x1c5464 - 0x1c54d0

void entry_1c5464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5464) {
        switch (ctx->pc) {
            case 0x1c54ac: ctx->pc = 0; goto label_1c54ac;
            case 0x1c54bc: ctx->pc = 0; goto label_1c54bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5464: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1c5468: 0x260206f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1776));
    // 0x1c546c: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1c5470: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c5474: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c5478: 0x24645c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1c547c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1c5480: 0xc60306f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1776)); ctx->f[3] = *(float*)&val; }
    // 0x1c5484: 0xc4645c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c5488: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1c548c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c5490: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1c5494: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c5498: 0x0
    // NOP
    // 0x1c549c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c54ac;
    }
    // 0x1c54a4: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c54bc;
    }
label_1c54ac:
    // 0x1c54ac: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c54b0: 0x0
    // NOP
    // 0x1c54b4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1c54bc;
    }
label_1c54bc:
    // 0x1c54bc: 0xe603063c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1596), *(uint32_t*)&val); }
    // 0x1c54c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c54c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c54c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustStepXpVelocityBase__FP4STEPP2XPi
// Address: 0x1c54d0 - 0x1c56cc

void entry_1c56cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c56cc: 0xc62d06cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1740)); ctx->f[13] = *(float*)&val; }
    // 0x1c56d0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c56d4: 0xc68e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1c56d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c56dc: 0x46006b47
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
    // 0x1c56e0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1c56e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 84));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1c56e8
// Address: 0x1c56e8 - 0x1c5724

void entry_1c56e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c56e8) {
        switch (ctx->pc) {
            case 0x1c56fc: ctx->pc = 0; goto label_1c56fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c56e8: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x1c56ec: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c56f0: 0x0
    // NOP
    // 0x1c56f4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[21] = FPU_MOV_S(ctx->f[0]);
        goto label_1c56fc;
    }
label_1c56fc:
    // 0x1c56fc: 0xc7a00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1c5700: 0xc7a10034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1c5704: 0xc68d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[13] = *(float*)&val; }
    // 0x1c5708: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1c570c: 0xc7a20038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[2] = *(float*)&val; }
    // 0x1c5710: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x1c5714: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x1c5718: 0x46156301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[21]);
    // 0x1c571c: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1c5724);
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[2];
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c5724
// Address: 0x1c5724 - 0x1c57c8

void entry_1c5724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5724) {
        switch (ctx->pc) {
            case 0x1c5728: ctx->pc = 0; goto label_1c5728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5724: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
label_1c5728:
    // 0x1c5728: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x1c572c: 0xda250660
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x1c5730: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1c5734: 0x4600a807
    ctx->f[0] = FPU_NEG_S(ctx->f[21]);
    // 0x1c5738: 0xda220640
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x1c573c: 0x2531821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    // 0x1c5740: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c5744: 0xda410080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 128)));
    // 0x1c5748: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c574c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5750: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5754: 0x4bc110ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5758: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c575c: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c5760: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5764: 0x8e25063c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1596)));
    // 0x1c5768: 0x4be308d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c576c: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1c5770: 0xda210130
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x1c5774: 0x48a52800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1c5778: 0xd8640030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x1c577c: 0x48a43000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1c5780: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5784: 0xfba60040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1c5788: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1c578c: 0x4be608bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1c5790: 0x4be51108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5794: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c5798: 0xf8640030
    WRITE128(ADD32(GPR_U32(ctx, 3), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c579c: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c57a0: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c57a4: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c57a8: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c57ac: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c57b0: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1c57b4: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1c57b8: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c57bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c57c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c57c8; return;
}


// Function: AdjustStepXps__FP4STEP
// Address: 0x1c57c8 - 0x1c5860

void entry_1c5860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5860) {
        switch (ctx->pc) {
            case 0x1c58f8: ctx->pc = 0; goto label_1c58f8;
            case 0x1c58fc: ctx->pc = 0; goto label_1c58fc;
            case 0x1c5904: ctx->pc = 0; goto label_1c5904;
            case 0x1c5914: ctx->pc = 0; goto label_1c5914;
            case 0x1c5928: ctx->pc = 0; goto label_1c5928;
            case 0x1c5958: ctx->pc = 0; goto label_1c5958;
            case 0x1c597c: ctx->pc = 0; goto label_1c597c;
            case 0x1c5994: ctx->pc = 0; goto label_1c5994;
            case 0x1c59b0: ctx->pc = 0; goto label_1c59b0;
            case 0x1c59c0: ctx->pc = 0; goto label_1c59c0;
            case 0x1c59d8: ctx->pc = 0; goto label_1c59d8;
            case 0x1c59f0: ctx->pc = 0; goto label_1c59f0;
            case 0x1c5a08: ctx->pc = 0; goto label_1c5a08;
            case 0x1c5a14: ctx->pc = 0; goto label_1c5a14;
            case 0x1c5a44: ctx->pc = 0; goto label_1c5a44;
            case 0x1c5a48: ctx->pc = 0; goto label_1c5a48;
            case 0x1c5ad8: ctx->pc = 0; goto label_1c5ad8;
            case 0x1c5ae4: ctx->pc = 0; goto label_1c5ae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5860: 0x10400025
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c58f8;
    }
    // 0x1c5868: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1c586c: 0x921823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1c5870: 0xda230130
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x1c5874: 0x31980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 6));
    // 0x1c5878: 0x701021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x1c587c: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c5880: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5884: 0x4bc310ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5888: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c588c: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c5890: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5894: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5898: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c589c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c58a0: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c58a4: 0x0
    // NOP
    // 0x1c58a8: 0x45020014
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        goto label_1c58fc;
    }
    // 0x1c58b0: 0xae240690
    WRITE32(ADD32(GPR_U32(ctx, 17), 1680), GPR_U32(ctx, 4));
    // 0x1c58b4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1c58b8: 0x702021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x1c58bc: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c58c0: 0xc6a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c58c4: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1c58c8: 0x741821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x1c58cc: 0xe6200694
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1684), *(uint32_t*)&val); }
    // 0x1c58d0: 0x78820010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1c58d4: 0x7e2206a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1696), GPR_VEC(ctx, 2));
    // 0x1c58d8: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c58dc: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c58e0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c58e4: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1c58e8: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c58ec: 0xfa2206b0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1712), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c58f0: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1c58f4: 0xae2206c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1728), GPR_U32(ctx, 2));
label_1c58f8:
    // 0x1c58f8: 0x8e1000d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_1c58fc:
    // 0x1c58fc: 0x5600ffd0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1C5840; return;
    }
label_1c5904:
    // 0x1c5904: 0x52600003
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1756)));
        goto label_1c5914;
    }
    // 0x1c590c: 0x1000ffc4
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5820; return;
    }
label_1c5914:
    // 0x1c5914: 0x104000a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1204));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c5bb8(rdram, ctx, runtime); return;
    }
    // 0x1c591c: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x1c5920: 0xafa30040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 3));
    // 0x1c5924: 0x8c530000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1c5928:
    // 0x1c5928: 0x8fa50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c592c: 0x273280b
    if (GPR_U32(ctx, 19) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 19));
    // 0x1c5930: 0x8cb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c5934: 0x12000097
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5B94; return;
    }
    // 0x1c593c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1c5940: 0x24574ad0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 19152));
    // 0x1c5944: 0x24758d00
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x1c5948: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c594c: 0x24140004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1c5950: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c5954: 0x0
    // NOP
label_1c5958:
    // 0x1c5958: 0x2221026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1c595c: 0x2302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1c5960: 0x61980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 6));
    // 0x1c5964: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1c5968: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1c596c: 0x50510003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 156)));
        goto label_1c597c;
    }
    // 0x1c5974: 0x10000084
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5B88; return;
    }
label_1c597c:
    // 0x1c597c: 0x14920005
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        goto label_1c5994;
    }
    // 0x1c5984: 0x8e0300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1c5988: 0x8e2206d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1752)));
    // 0x1c598c: 0x50620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
        goto label_1c59b0;
    }
label_1c5994:
    // 0x1c5994: 0x1494000a
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 20)) {
        goto label_1c59c0;
    }
    // 0x1c599c: 0x8e0300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 164)));
    // 0x1c59a0: 0x8e2206d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1752)));
    // 0x1c59a4: 0x14620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c59c0;
    }
    // 0x1c59ac: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
label_1c59b0:
    // 0x1c59b0: 0x54400072
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1C5B7C; return;
    }
    // 0x1c59b8: 0x1000006e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5B74; return;
    }
label_1c59c0:
    // 0x1c59c0: 0x14920005
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        goto label_1c59d8;
    }
    // 0x1c59c8: 0x8e0300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1c59cc: 0x8e2206d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1c59d0: 0x1062000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c5a08;
    }
label_1c59d8:
    // 0x1c59d8: 0x14940005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 20)) {
        goto label_1c59f0;
    }
    // 0x1c59e0: 0x8e0300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 164)));
    // 0x1c59e4: 0x8e2206d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1c59e8: 0x10620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c5a08;
    }
label_1c59f0:
    // 0x1c59f0: 0x14820008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1c5a14;
    }
    // 0x1c59f8: 0x8e0300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x1c59fc: 0x8e2206d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1c5a00: 0x14620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c5a14;
    }
label_1c5a08:
    // 0x1c5a08: 0x561e005c
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 30)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x1C5B7C; return;
    }
    // 0x1c5a10: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_1c5a14:
    // 0x1c5a14: 0x5082000c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
        goto label_1c5a48;
    }
    // 0x1c5a1c: 0x14d20055
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 208));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x1C5B74; return;
    }
    // 0x1c5a24: 0x10860008
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 6)) {
        goto label_1c5a48;
    }
    // 0x1c5a2c: 0x10940005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 20)) {
        goto label_1c5a44;
    }
    // 0x1c5a34: 0x10820003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1c5a44;
    }
    // 0x1c5a3c: 0x54820052
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C5B88; return;
    }
label_1c5a44:
    // 0x1c5a44: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
label_1c5a48:
    // 0x1c5a48: 0xc6000088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 136)); ctx->f[0] = *(float*)&val; }
    // 0x1c5a4c: 0x571021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1c5a50: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1c5a54: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1c5a58: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1c5a5c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c5a60: 0x0
    // NOP
    // 0x1c5a64: 0x45000043
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 208));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C5B74; return;
    }
    // 0x1c5a6c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c5a70: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c5a74: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c5a78: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c5a7c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c5a80: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c5a84: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5a88: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1c5a8c: 0x7aa20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1c5a90: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5a94: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5a98: 0xe7a20008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1c5a9c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c5aa0: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c5aa4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c5aa8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5aac: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5ab0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5ab4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c5ab8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c5abc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5ac0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c5ac4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c5ac8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c5ad8;
    }
    // 0x1c5ad0: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c5ae4;
    }
label_1c5ad8:
    // 0x1c5ad8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c5adc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c5ae0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1c5ae4:
    // 0x1c5ae4: 0xf8810000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5ae8: 0x2461823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 6)));
    // 0x1c5aec: 0x31980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 6));
    // 0x1c5af0: 0x61180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 6));
    // 0x1c5af4: 0x702021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x1c5af8: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1c5afc: 0xd8820010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1c5b00: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c5b04: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c5b08: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1c5b0c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5b10: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c5b14: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5b18: 0x4bc408ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5b1c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c5b20: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c5b24: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5b28: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c5b2c: 0x261000d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1c5b30: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c5b34: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1c5b38: 0xd8a10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x1c5b3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c5b40: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c5b44: 0x4be22048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5b48: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5b4c: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5b50: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c5b54: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c5b58: 0x2408000a
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1c5b5c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c5b60: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c5b64: 0x8c650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1c5b68: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1c5b70);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1c5b70
// Address: 0x1c5b70 - 0x1c5bb8

void entry_1c5b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5b70) {
        switch (ctx->pc) {
            case 0x1c5b74: ctx->pc = 0; goto label_1c5b74;
            case 0x1c5b7c: ctx->pc = 0; goto label_1c5b7c;
            case 0x1c5b88: ctx->pc = 0; goto label_1c5b88;
            case 0x1c5b94: ctx->pc = 0; goto label_1c5b94;
            case 0x1c5bb0: ctx->pc = 0; goto label_1c5bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5b70: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c5b74:
    // 0x1c5b74: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c5b88;
    }
label_1c5b7c:
    // 0x1c5b7c: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1c5b80: 0xae1600d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 22));
    // 0x1c5b84: 0x200b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c5b88:
    // 0x1c5b88: 0x8cb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1c5b8c: 0x5600ff72
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1C5958; return;
    }
label_1c5b94:
    // 0x1c5b94: 0x52600006
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_1c5bb0;
    }
    // 0x1c5b9c: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1c5ba0: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1c5ba4: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1c5ba8: 0x1000ff5f
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5928; return;
    }
label_1c5bb0:
    // 0x1c5bb0: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1c5bb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1c5bb8
// Address: 0x1c5bb8 - 0x1c5bf0

void entry_1c5bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5bb8: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c5bbc: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c5bc0: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1c5bc4: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c5bc8: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c5bcc: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c5bd0: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c5bd4: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c5bd8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c5bdc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c5be0: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1c5be4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c5bec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c5bf0; return;
}


// Function: AddStepCustomXps__FP4STEPP2SOiP3BSPT3PP2XP
// Address: 0x1c5bf0 - 0x1c5c04

void entry_1c5c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5c04: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c5c08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddStepCustomXpsBase__FP4STEPP2SOP3BSPPP2XP
// Address: 0x1c5c10 - 0x1c5c54

void entry_1c5c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5c54) {
        switch (ctx->pc) {
            case 0x1c5c9c: ctx->pc = 0; goto label_1c5c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5c54: 0x18400039
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[1] = *(float*)&val; }
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1c5d3c(rdram, ctx, runtime); return;
    }
    // 0x1c5c5c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c5c60: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c5c64: 0x0
    // NOP
    // 0x1c5c68: 0x45000034
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1c5d3c(rdram, ctx, runtime); return;
    }
    // 0x1c5c70: 0x8e0606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1748)));
    // 0x1c5c74: 0xd8c10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1c5c78: 0x4be208ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5c7c: 0x8fa30048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1c5c80: 0x10600006
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c5c9c;
    }
    // 0x1c5c88: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c5c8c: 0x10620014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C5CE0; return;
    }
    // 0x1c5c94: 0x1000002b
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5D44; return;
    }
label_1c5c9c:
    // 0x1c5c9c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5ca0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c5ca4: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5ca8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c5cac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5cb0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5cb4: 0x8faa0050
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c5cb8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5cbc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c5cc0: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1c5cc4: 0x240582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c5cc8: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c5ccc: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c5cd0: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1c5cd8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1c5cd8
// Address: 0x1c5cd8 - 0x1c5d3c

void entry_1c5cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5cd8) {
        switch (ctx->pc) {
            case 0x1c5ce0: ctx->pc = 0; goto label_1c5ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5cd8: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C5D40; return;
    }
label_1c5ce0:
    // 0x1c5ce0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c5ce4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c5ce8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c5cec: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5cf0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c5cf4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c5cf8: 0x240582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c5cfc: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c5d00: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c5d04: 0x4be30858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5d08: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c5d0c: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5d10: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c5d14: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5d18: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c5d1c: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5d20: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5d24: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1c5d28: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1c5d2c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c5d30: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x1c5d34: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1c5d3c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1c5d3c
// Address: 0x1c5d3c - 0x1c5d58

void entry_1c5d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5d3c) {
        switch (ctx->pc) {
            case 0x1c5d40: ctx->pc = 0; goto label_1c5d40;
            case 0x1c5d44: ctx->pc = 0; goto label_1c5d44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5d3c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_1c5d40:
    // 0x1c5d40: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_1c5d44:
    // 0x1c5d44: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c5d48: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c5d4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c5d54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c5d58; return;
}


// Function: FixStepAngularVelocity__FP4STEP
// Address: 0x1c5d58 - 0x1c5d7c

void entry_1c5d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5d7c: 0xc60d0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[13] = *(float*)&val; }
    // 0x1c5d80: 0x260406e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1760));
    // 0x1c5d84: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1c5d88: 0x37a50008
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 8));
    // 0x1c5d8c: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1c5d94);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1c5d94
// Address: 0x1c5d94 - 0x1c5da8

void entry_1c5d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5d94: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c5d98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c5d9c: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1c5da0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c5da8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c5da8
// Address: 0x1c5da8 - 0x1c5db8

void entry_1c5da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5da8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5dac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5db0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PredictStepRotation__FP4STEPfP7MATRIX3P6VECTOR
// Address: 0x1c5db8 - 0x1c5dec

void entry_1c5dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5dec: 0xc60d0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[13] = *(float*)&val; }
    // 0x1c5df0: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1c5df4: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c5df8: 0x260406e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1760));
    // 0x1c5dfc: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1c5e04);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1c5e04
// Address: 0x1c5e04 - 0x1c5e1c

void entry_1c5e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5e04: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1c5e08: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c5e0c: 0x26108d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937888));
    // 0x1c5e10: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c5e14: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1c5e1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c5e1c
// Address: 0x1c5e1c - 0x1c5e50

void entry_1c5e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5e1c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5e20: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c5e24: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c5e28: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5e2c: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5e30: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5e34: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c5e38: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c5e3c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c5e40: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5e44: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1c5e48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepSpinRatio__FP4STEPf
// Address: 0x1c5e50 - 0x1c5ea8

void entry_1c5ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c5ee0: 0xc6000700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1792)); ctx->f[0] = *(float*)&val; }
    // 0x1c5ee4: 0xda020350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1c5ee8: 0x4600a003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[0] = ctx->f[20] / ctx->f[0];
    // 0x1c5eec: 0xe6140700
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 1792), *(uint32_t*)&val); }
    // 0x1c5ef0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5ef4: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1c5ef8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c5efc: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c5f00: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5f04: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5f08: 0xfa020350
    WRITE128(ADD32(GPR_U32(ctx, 16), 848), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5f0c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5f10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActaddPositionGoal__FP6ACTADDfP6VECTORT2
// Address: 0x1c5f18 - 0x1c5fbc

void entry_1c5fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c5fbc) {
        switch (ctx->pc) {
            case 0x1c5fe8: ctx->pc = 0; goto label_1c5fe8;
            case 0x1c5fec: ctx->pc = 0; goto label_1c5fec;
            case 0x1c6000: ctx->pc = 0; goto label_1c6000;
            case 0x1c6004: ctx->pc = 0; goto label_1c6004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c5fbc: 0xda830190
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 400)));
    // 0x1c5fc0: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c5fc4: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1c5fc8: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c5fcc: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c5fd0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5fd4: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c5fd8: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c5fdc: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c5fe0: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c5fe4: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c5fe8:
    // 0x1c5fe8: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_1c5fec:
    // 0x1c5fec: 0x1a200005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_1c6004;
    }
    // 0x1c5ff4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1c5ff8: 0x5600ffe3
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 16)));
        ctx->pc = 0x1C5F88; return;
    }
label_1c6000:
    // 0x1c6000: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1c6004:
    // 0x1c6004: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c6008: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c600c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c6010: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c6014: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c6018: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c601c: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1c6020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetActaddRotationGoal__FP6ACTADDfP7MATRIX3P6VECTOR
// Address: 0x1c6028 - 0x1c60a0

void entry_1c60a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c60a0) {
        switch (ctx->pc) {
            case 0x1c60e0: ctx->pc = 0; goto label_1c60e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c60a0: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c60a4: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1c60a8: 0x7a040020
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1c60ac: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x1c60b0: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1c60b4: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x1c60b8: 0x8e32001c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x1c60bc: 0x1a40003f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1C61BC; return;
    }
    // 0x1c60c4: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1c60c8: 0x1220003c
    SET_GPR_U32(ctx, 2, ((uint32_t)34 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C61BC; return;
    }
    // 0x1c60d0: 0x27b40040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1c60d4: 0x24559560
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 4294940000));
    // 0x1c60d8: 0x92220011
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 17)));
    // 0x1c60dc: 0x0
    // NOP
label_1c60e0:
    // 0x1c60e0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1c60e4: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1c60e8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1c60ec: 0x1440002d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C61A4; return;
    }
    // 0x1c60f4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c60f8: 0x10550029
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1C61A0; return;
    }
    // 0x1c6100: 0x8c420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1c6104: 0x27a600a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1c6108: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c610c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c6114);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c6114
// Address: 0x1c6114 - 0x1c6124

void entry_1c6114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6114: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c6118: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c611c: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1c6124);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1c6124
// Address: 0x1c6124 - 0x1c61e0

void entry_1c6124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6124) {
        switch (ctx->pc) {
            case 0x1c61a0: ctx->pc = 0; goto label_1c61a0;
            case 0x1c61a4: ctx->pc = 0; goto label_1c61a4;
            case 0x1c61bc: ctx->pc = 0; goto label_1c61bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6124: 0xda050000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c6128: 0xda070010
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1c612c: 0xda080020
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1c6130: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c6134: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c6138: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c613c: 0x4bc531bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1c6140: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1c6144: 0x4bc5194a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6148: 0x4bc731bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1c614c: 0x4bc720bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1c6150: 0x4bc719ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6154: 0x4bc831bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1c6158: 0x4bc820bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1c615c: 0x4bc81a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6160: 0xfa050000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c6164: 0xfa070010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c6168: 0xfa080020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c616c: 0xda610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1c6170: 0xdba200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c6174: 0x4bc131bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c6178: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c617c: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6180: 0xfba500e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c6184: 0x4be208a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c6188: 0xfa620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c618c: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c6190: 0xfba700f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c6194: 0xfba700c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1c6198: 0xfba80100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1c619c: 0xfba800d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[8]));
label_1c61a0:
    // 0x1c61a0: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
label_1c61a4:
    // 0x1c61a4: 0x1a400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1c61bc;
    }
    // 0x1c61ac: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1c61b0: 0x5620ffcb
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 17)));
        ctx->pc = 0x1C60E0; return;
    }
    // 0x1c61b8: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
label_1c61bc:
    // 0x1c61bc: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1c61c0: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1c61c4: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1c61c8: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1c61cc: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1c61d0: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1c61d4: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x1c61d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJtJtcs__FP2JT4JTCS
// Address: 0x1c61e0 - 0x1c626c

void entry_1c626c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c626c) {
        switch (ctx->pc) {
            case 0x1c6270: ctx->pc = 0; goto label_1c6270;
            case 0x1c62bc: ctx->pc = 0; goto label_1c62bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c626c: 0x8e032254
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8788)));
label_1c6270:
    // 0x1c6270: 0x2402fffd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1c6274: 0x8e04223c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x1c6278: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c627c: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1c6280: 0x2c82000b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 11));
    // 0x1c6284: 0x10400024
    WRITE32(ADD32(GPR_U32(ctx, 16), 8788), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6318(rdram, ctx, runtime); return;
    }
    // 0x1c628c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c6290: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c6294: 0x2442d5a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956448));
    // 0x1c6298: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c629c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c62a0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c62a8: 0x8e022204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8708)));
    // 0x1c62ac: 0x10000003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 172)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c62bc;
    }
    // 0x1c62b4: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x1c62b8: 0x8c440054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 84)));
label_1c62bc:
    // 0x1c62bc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1c62c0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c62c4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1c62c8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1c62cc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c62d0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c62d4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1c62d8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c62dc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c62e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c62e4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1c62e8: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1c62ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c62f0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1c62f8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1c62f8
// Address: 0x1c62f8 - 0x1c6318

void entry_1c62f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c62f8: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c6318(rdram, ctx, runtime); return;
    }
    // 0x1c6300: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1c6304: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c6318(rdram, ctx, runtime); return;
    }
    // 0x1c630c: 0x8e042234
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8756)));
    // 0x1c6310: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1c6318);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 326));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c6318
// Address: 0x1c6318 - 0x1c6410

void entry_1c6318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6318: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x1c631c: 0x26230001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1c6320: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6324: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6328: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1c632c: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    // 0x1c6330: 0x2413ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c6334: 0x2c62000d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 13));
    // 0x1c6338: 0x104000ba
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
    // 0x1c6340: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c6344: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c6348: 0x2442d5d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956496));
    // 0x1c634c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c6350: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c6354: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c635c: 0xae002200
    WRITE32(ADD32(GPR_U32(ctx, 16), 8704), GPR_U32(ctx, 0));
    // 0x1c6360: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x1c6364: 0xae002204
    WRITE32(ADD32(GPR_U32(ctx, 16), 8708), GPR_U32(ctx, 0));
    // 0x1c6368: 0x100000ae
    WRITE32(ADD32(GPR_U32(ctx, 16), 8712), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
    // 0x1c6370: 0x100000ab
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6620; return;
    }
    // 0x1c6378: 0x100000a9
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6620; return;
    }
    // 0x1c6380: 0xae0004b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    // 0x1c6384: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x1c6388: 0x100000a6
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 4120)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
    // 0x1c6390: 0xae0004b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    // 0x1c6394: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x1c6398: 0x100000a2
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 4124)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
    // 0x1c63a0: 0x8e0321c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8644)));
    // 0x1c63a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c63a8: 0x24441858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1c63ac: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c63b0: 0x8c7203e4
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 3), 996)));
    // 0x1c63b4: 0x2413000d
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1c63b8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1c63bc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1c63c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c63c4: 0x8e4200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 192)));
    // 0x1c63c8: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1c63cc: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1c63d0: 0xc4760008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[22] = *(float*)&val; }
    // 0x1c63d4: 0xae0004b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    // 0x1c63d8: 0xae002210
    WRITE32(ADD32(GPR_U32(ctx, 16), 8720), GPR_U32(ctx, 0));
    // 0x1c63dc: 0xae002214
    WRITE32(ADD32(GPR_U32(ctx, 16), 8724), GPR_U32(ctx, 0));
    // 0x1c63e0: 0x10000089
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6608; return;
    }
    // 0x1c63e8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c63ec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c63f0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c63f4: 0x8e0623d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9172)));
    // 0x1c63f8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c63fc: 0xae0025ec
    WRITE32(ADD32(GPR_U32(ctx, 16), 9708), GPR_U32(ctx, 0));
    // 0x1c6400: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c6404: 0xe60021c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8648), *(uint32_t*)&val); }
    // 0x1c6408: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1c6410);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c6410
// Address: 0x1c6410 - 0x1c64dc

void entry_1c6410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6410) {
        switch (ctx->pc) {
            case 0x1c6484: ctx->pc = 0; goto label_1c6484;
            case 0x1c64c4: ctx->pc = 0; goto label_1c64c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6410: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c6414: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c6418: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c641c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c6420: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c6424: 0x8e02061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x1c6428: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c642c: 0xd8410100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x1c6430: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c6434: 0x4be20888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6438: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1c643c: 0x14400011
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c6484;
    }
    // 0x1c6444: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6448: 0x8c434c10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19472)));
    // 0x1c644c: 0x14600041
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6554; return;
    }
    // 0x1c6454: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6458: 0x8c434c14
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19476)));
    // 0x1c645c: 0x14600053
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C65AC; return;
    }
    // 0x1c6464: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c6468: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c646c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6470: 0x0
    // NOP
    // 0x1c6474: 0x45010037
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 6));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C6554; return;
    }
    // 0x1c647c: 0x1000004b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C65AC; return;
    }
label_1c6484:
    // 0x1c6484: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6488: 0x8c434c10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19472)));
    // 0x1c648c: 0x1460000d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c64c4;
    }
    // 0x1c6494: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6498: 0x8c434c14
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19476)));
    // 0x1c649c: 0x1460001b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C650C; return;
    }
    // 0x1c64a4: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c64a8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c64ac: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c64b0: 0x0
    // NOP
    // 0x1c64b4: 0x45010003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c64c4;
    }
    // 0x1c64bc: 0x10000013
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C650C; return;
    }
label_1c64c4:
    // 0x1c64c4: 0xae0025ec
    WRITE32(ADD32(GPR_U32(ctx, 16), 9708), GPR_U32(ctx, 0));
    // 0x1c64c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c64cc: 0x8e062558
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9560)));
    // 0x1c64d0: 0x26052540
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 9536));
    // 0x1c64d4: 0xc071b40
    SET_GPR_U32(ctx, 31, 0x1c64dc);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1c64dc
// Address: 0x1c64dc - 0x1c6524

void entry_1c64dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c64dc) {
        switch (ctx->pc) {
            case 0x1c650c: ctx->pc = 0; goto label_1c650c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c64dc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c64e0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c64e4: 0x24831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1c64e8: 0xc4414b94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19348)); ctx->f[1] = *(float*)&val; }
    // 0x1c64ec: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c64f0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c64f4: 0xc4544b90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19344)); ctx->f[20] = *(float*)&val; }
    // 0x1c64f8: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c64fc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c6500: 0x8e122558
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9560)));
    // 0x1c6504: 0x10000047
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9252), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
label_1c650c:
    // 0x1c650c: 0xae0025ec
    WRITE32(ADD32(GPR_U32(ctx, 16), 9708), GPR_U32(ctx, 0));
    // 0x1c6510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c6514: 0x8e062574
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9588)));
    // 0x1c6518: 0x2605255c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 9564));
    // 0x1c651c: 0xc071b40
    SET_GPR_U32(ctx, 31, 0x1c6524);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1c6524
// Address: 0x1c6524 - 0x1c656c

void entry_1c6524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6524) {
        switch (ctx->pc) {
            case 0x1c6554: ctx->pc = 0; goto label_1c6554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6524: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c6528: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c652c: 0x24831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1c6530: 0xc4414b98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19352)); ctx->f[1] = *(float*)&val; }
    // 0x1c6534: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c6538: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c653c: 0xc4544b90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19344)); ctx->f[20] = *(float*)&val; }
    // 0x1c6540: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c6544: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c6548: 0x8e122574
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9588)));
    // 0x1c654c: 0x10000035
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9252), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6624; return;
    }
label_1c6554:
    // 0x1c6554: 0xae0025ec
    WRITE32(ADD32(GPR_U32(ctx, 16), 9708), GPR_U32(ctx, 0));
    // 0x1c6558: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c655c: 0x8e062590
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9616)));
    // 0x1c6560: 0x26052578
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 9592));
    // 0x1c6564: 0xc071b40
    SET_GPR_U32(ctx, 31, 0x1c656c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1c656c
// Address: 0x1c656c - 0x1c6584

void entry_1c656c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c656c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6570: 0x8e041188
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4488)));
    // 0x1c6574: 0xc4544b90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19344)); ctx->f[20] = *(float*)&val; }
    // 0x1c6578: 0x2405014f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 335));
    // 0x1c657c: 0xc06d8f0
    SET_GPR_U32(ctx, 31, 0x1c6584);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9616)));
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c6584
// Address: 0x1c6584 - 0x1c6598

void entry_1c6584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6584: 0x4400005
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1C659C; return;
    }
    // 0x1c658c: 0x8e042234
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8756)));
    // 0x1c6590: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1c6598);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 335));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c6598
// Address: 0x1c6598 - 0x1c65c4

void entry_1c6598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6598) {
        switch (ctx->pc) {
            case 0x1c659c: ctx->pc = 0; goto label_1c659c;
            case 0x1c65ac: ctx->pc = 0; goto label_1c65ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6598: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_1c659c:
    // 0x1c659c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c65a0: 0x24831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1c65a4: 0x10000016
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19348)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6600; return;
    }
label_1c65ac:
    // 0x1c65ac: 0xae0025ec
    WRITE32(ADD32(GPR_U32(ctx, 16), 9708), GPR_U32(ctx, 0));
    // 0x1c65b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c65b4: 0x8e0625ac
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9644)));
    // 0x1c65b8: 0x26052594
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 9620));
    // 0x1c65bc: 0xc071b40
    SET_GPR_U32(ctx, 31, 0x1c65c4);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1c65c4
// Address: 0x1c65c4 - 0x1c65dc

void entry_1c65c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c65c4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c65c8: 0x8e041188
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4488)));
    // 0x1c65cc: 0xc4544b90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19344)); ctx->f[20] = *(float*)&val; }
    // 0x1c65d0: 0x2405014f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 335));
    // 0x1c65d4: 0xc06d8f0
    SET_GPR_U32(ctx, 31, 0x1c65dc);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9644)));
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c65dc
// Address: 0x1c65dc - 0x1c65f0

void entry_1c65dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c65dc: 0x4400005
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x1C65F4; return;
    }
    // 0x1c65e4: 0x8e042234
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8756)));
    // 0x1c65e8: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1c65f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 335));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c65f0
// Address: 0x1c65f0 - 0x1c6708

void entry_1c65f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c65f0) {
        switch (ctx->pc) {
            case 0x1c65f4: ctx->pc = 0; goto label_1c65f4;
            case 0x1c6600: ctx->pc = 0; goto label_1c6600;
            case 0x1c6608: ctx->pc = 0; goto label_1c6608;
            case 0x1c6620: ctx->pc = 0; goto label_1c6620;
            case 0x1c6624: ctx->pc = 0; goto label_1c6624;
            case 0x1c666c: ctx->pc = 0; goto label_1c666c;
            case 0x1c6690: ctx->pc = 0; goto label_1c6690;
            case 0x1c6698: ctx->pc = 0; goto label_1c6698;
            case 0x1c669c: ctx->pc = 0; goto label_1c669c;
            case 0x1c66a0: ctx->pc = 0; goto label_1c66a0;
            case 0x1c66bc: ctx->pc = 0; goto label_1c66bc;
            case 0x1c66c4: ctx->pc = 0; goto label_1c66c4;
            case 0x1c66d8: ctx->pc = 0; goto label_1c66d8;
            case 0x1c66dc: ctx->pc = 0; goto label_1c66dc;
            case 0x1c66f4: ctx->pc = 0; goto label_1c66f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c65f0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_1c65f4:
    // 0x1c65f4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c65f8: 0x24831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1c65fc: 0xc4414b98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19352)); ctx->f[1] = *(float*)&val; }
label_1c6600:
    // 0x1c6600: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c6604: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1c6608:
    // 0x1c6608: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c660c: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9252), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c6624;
    }
    // 0x1c6614: 0x10000002
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9648)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c6620;
    }
    // 0x1c661c: 0x8e1225b4
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 9652)));
label_1c6620:
    // 0x1c6620: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
label_1c6624:
    // 0x1c6624: 0x5280001e
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 8776), GPR_U32(ctx, 0));
        goto label_1c66a0;
    }
    // 0x1c662c: 0x8e022244
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8772)));
    // 0x1c6630: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c6634: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1c6638: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c663c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6640: 0x0
    // NOP
    // 0x1c6644: 0x45000012
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[22] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c6690;
    }
    // 0x1c664c: 0x4601b032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[22], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6650: 0x0
    // NOP
    // 0x1c6654: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
        goto label_1c666c;
    }
    // 0x1c665c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c6660: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1c6664: 0x1000000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 28)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c6698;
    }
label_1c666c:
    // 0x1c666c: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1c6670: 0x4600b032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6674: 0x0
    // NOP
    // 0x1c6678: 0x45000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 28)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c6698;
    }
    // 0x1c6680: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6684: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1c6688: 0x10000004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c669c;
    }
label_1c6690:
    // 0x1c6690: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1c6694: 0xc460001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 28)); ctx->f[0] = *(float*)&val; }
label_1c6698:
    // 0x1c6698: 0x2413ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1c669c:
    // 0x1c669c: 0x4600ad43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[21] = ctx->f[21] / ctx->f[0];
label_1c66a0:
    // 0x1c66a0: 0x8e03223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x1c66a4: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1c66a8: 0x10620004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c66bc;
    }
    // 0x1c66b0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c66b4: 0x14620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c66c4;
    }
label_1c66bc:
    // 0x1c66bc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c66c0: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
label_1c66c4:
    // 0x1c66c4: 0x12220004
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_1c66d8;
    }
    // 0x1c66cc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c66d0: 0x16220002
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_1c66dc;
    }
label_1c66d8:
    // 0x1c66d8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_1c66dc:
    // 0x1c66dc: 0x10830024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        entry_1c6770(rdram, ctx, runtime); return;
    }
    // 0x1c66e4: 0x12220003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_1c66f4;
    }
    // 0x1c66ec: 0x56220012
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9168)));
        ctx->pc = 0x1C6738; return;
    }
label_1c66f4:
    // 0x1c66f4: 0x8e0423d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9176)));
    // 0x1c66f8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c66fc: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1c6700: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c6708);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c6708
// Address: 0x1c6708 - 0x1c671c

void entry_1c6708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6708: 0x8e0423d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9176)));
    // 0x1c670c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c6710: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x1c6714: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c671c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9168)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c671c
// Address: 0x1c671c - 0x1c6730

void entry_1c671c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c671c: 0x8e0423d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9168)));
    // 0x1c6720: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c6724: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1c6728: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c6730);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c6730
// Address: 0x1c6730 - 0x1c6748

void entry_1c6730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6730) {
        switch (ctx->pc) {
            case 0x1c6738: ctx->pc = 0; goto label_1c6738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6730: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 8764), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6774; return;
    }
label_1c6738:
    // 0x1c6738: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c673c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1c6740: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c6748);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c6748
// Address: 0x1c6748 - 0x1c675c

void entry_1c6748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6748: 0x8e0423d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9168)));
    // 0x1c674c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c6750: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x1c6754: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c675c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9176)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c675c
// Address: 0x1c675c - 0x1c6770

void entry_1c675c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c675c: 0x8e0423d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9176)));
    // 0x1c6760: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c6764: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1c6768: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c6770);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c6770
// Address: 0x1c6770 - 0x1c67a0

void entry_1c6770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6770) {
        switch (ctx->pc) {
            case 0x1c6774: ctx->pc = 0; goto label_1c6774;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6770: 0xae11223c
    WRITE32(ADD32(GPR_U32(ctx, 16), 8764), GPR_U32(ctx, 17));
label_1c6774:
    // 0x1c6774: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c6778: 0x26b11858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1c677c: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1c6780: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c6784: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1c6788: 0xae0021cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 8652), GPR_U32(ctx, 0));
    // 0x1c678c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c6790: 0xe6002240
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8768), *(uint32_t*)&val); }
    // 0x1c6794: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c6798: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x1c67a0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 8772));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c67a0
// Address: 0x1c67a0 - 0x1c6860

void entry_1c67a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c67a0) {
        switch (ctx->pc) {
            case 0x1c67d8: ctx->pc = 0; goto label_1c67d8;
            case 0x1c67f4: ctx->pc = 0; goto label_1c67f4;
            case 0x1c6810: ctx->pc = 0; goto label_1c6810;
            case 0x1c681c: ctx->pc = 0; goto label_1c681c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c67a0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c67a4: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c67a8: 0x0
    // NOP
    // 0x1c67ac: 0x4501001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c681c;
    }
    // 0x1c67b4: 0x8e022244
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8772)));
    // 0x1c67b8: 0x8c430044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    // 0x1c67bc: 0x10600017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c681c;
    }
    // 0x1c67c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c67c8: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c67cc: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1c67d0: 0x80620010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1c67d4: 0x0
    // NOP
label_1c67d8:
    // 0x1c67d8: 0x54460006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 17)));
        goto label_1c67f4;
    }
    // 0x1c67e0: 0xa0650010
    WRITE8(ADD32(GPR_U32(ctx, 3), 16), (uint8_t)GPR_U32(ctx, 5));
    // 0x1c67e4: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c67e8: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1c67ec: 0xe4600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 24), *(uint32_t*)&val); }
    // 0x1c67f0: 0x80620011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 17)));
label_1c67f4:
    // 0x1c67f4: 0x54460006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 32)));
        goto label_1c6810;
    }
    // 0x1c67fc: 0xa0650011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 5));
    // 0x1c6800: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c6804: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1c6808: 0xe4600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 24), *(uint32_t*)&val); }
    // 0x1c680c: 0x8c630020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 32)));
label_1c6810:
    // 0x1c6810: 0x5460fff1
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 16)));
        goto label_1c67d8;
    }
    // 0x1c6818: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1c681c:
    // 0x1c681c: 0x12620010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        entry_1c6860(rdram, ctx, runtime); return;
    }
    // 0x1c6824: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1c6828: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1c682c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1c6830: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c6834: 0x26070140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1c6838: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1c683c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c6840: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6844: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6848: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1c684c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6850: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1c6854: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6858: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1c6860);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1c6860
// Address: 0x1c6860 - 0x1c6890

void entry_1c6860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6860: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c6864: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c6868: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c686c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c6870: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c6874: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6878: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c687c: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1c6880: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1c6884: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1c6888: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtCane__FP2JT
// Address: 0x1c6890 - 0x1c68b4

void entry_1c68b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c68b4: 0x14400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C68D8; return;
    }
    // 0x1c68bc: 0xae002200
    WRITE32(ADD32(GPR_U32(ctx, 16), 8704), GPR_U32(ctx, 0));
    // 0x1c68c0: 0x14400014
    WRITE32(ADD32(GPR_U32(ctx, 16), 8708), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c6914(rdram, ctx, runtime); return;
    }
    // 0x1c68c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c68cc: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1c68d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1c68d4
// Address: 0x1c68d4 - 0x1c68f4

void entry_1c68d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c68d4) {
        switch (ctx->pc) {
            case 0x1c68d8: ctx->pc = 0; goto label_1c68d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c68d4: 0x8e02223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
label_1c68d8:
    // 0x1c68d8: 0x1440000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6918; return;
    }
    // 0x1c68e0: 0x8e062200
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8704)));
    // 0x1c68e4: 0x10c00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C68FC; return;
    }
    // 0x1c68ec: 0xc0674aa
    SET_GPR_U32(ctx, 31, 0x1c68f4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8644)));
    TrackJtTarget__FP2JTP4RCHMP6TARGET(rdram, ctx, runtime); return;
}


// Function: entry_1c68f4
// Address: 0x1c68f4 - 0x1c6914

void entry_1c68f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c68f4) {
        switch (ctx->pc) {
            case 0x1c68fc: ctx->pc = 0; goto label_1c68fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c68f4: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6918; return;
    }
label_1c68fc:
    // 0x1c68fc: 0x8e062208
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x1c6900: 0x10c00005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6918; return;
    }
    // 0x1c6908: 0x8c8521c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8644)));
    // 0x1c690c: 0xc0674ce
    SET_GPR_U32(ctx, 31, 0x1c6914);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 8716));
    TrackJtPipe__FP2JTP4RCHMP4PIPEPf(rdram, ctx, runtime); return;
}


// Function: entry_1c6914
// Address: 0x1c6914 - 0x1c6928

void entry_1c6914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6914) {
        switch (ctx->pc) {
            case 0x1c6918: ctx->pc = 0; goto label_1c6918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6914: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c6918:
    // 0x1c6918: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c691c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c6924: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c6928; return;
}


// Function: UpdateJtActiveCane__FP2JTP3JOY
// Address: 0x1c6928 - 0x1c698c

void entry_1c698c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c698c) {
        switch (ctx->pc) {
            case 0x1c69ac: ctx->pc = 0; goto label_1c69ac;
            case 0x1c69e8: ctx->pc = 0; goto label_1c69e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c698c: 0x1000001d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
    // 0x1c6994: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x1c6998: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x1c699c: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c69ac;
    }
    // 0x1c69a4: 0x10400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
label_1c69ac:
    // 0x1c69ac: 0x10000015
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
    // 0x1c69b4: 0x8e022590
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9616)));
    // 0x1c69b8: 0x10400012
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
    // 0x1c69c0: 0x8e0225ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9644)));
    // 0x1c69c4: 0x1040000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
    // 0x1c69cc: 0x8e03223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x1c69d0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c69e8;
    }
    // 0x1c69d8: 0x10620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C69FC; return;
    }
    // 0x1c69e0: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
label_1c69e8:
    // 0x1c69e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c69ec: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1c69f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1c69f4
// Address: 0x1c69f4 - 0x1c6a04

void entry_1c69f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c69f4) {
        switch (ctx->pc) {
            case 0x1c69fc: ctx->pc = 0; goto label_1c69fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c69f4: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c6a04(rdram, ctx, runtime); return;
    }
label_1c69fc:
    // 0x1c69fc: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1c6a04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1c6a04
// Address: 0x1c6a04 - 0x1c6a90

void entry_1c6a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6a04) {
        switch (ctx->pc) {
            case 0x1c6a14: ctx->pc = 0; goto label_1c6a14;
            case 0x1c6a34: ctx->pc = 0; goto label_1c6a34;
            case 0x1c6a64: ctx->pc = 0; goto label_1c6a64;
            case 0x1c6a88: ctx->pc = 0; goto label_1c6a88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6a04: 0x12400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1c6a14;
    }
    // 0x1c6a0c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c6a10: 0xe60021c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8648), *(uint32_t*)&val); }
label_1c6a14:
    // 0x1c6a14: 0x8e05223c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x1c6a18: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c6a1c: 0x14a20005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1c6a34;
    }
    // 0x1c6a24: 0x12200018
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a2c: 0x1000000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8648)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c6a64;
    }
label_1c6a34:
    // 0x1c6a34: 0x14400014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a3c: 0x10400012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a44: 0x14400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a4c: 0x1220000e
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a54: 0x8e022248
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8776)));
    // 0x1c6a58: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c6a88;
    }
    // 0x1c6a60: 0xc60221c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8648)); ctx->f[2] = *(float*)&val; }
label_1c6a64:
    // 0x1c6a64: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c6a68: 0x3c013eb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16051 << 16));
    // 0x1c6a6c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1c6a70: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c6a74: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1c6a78: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6a7c: 0x0
    // NOP
    // 0x1c6a80: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
        goto label_1c6a88;
    }
label_1c6a88:
    // 0x1c6a88: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1c6a90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1c6a90
// Address: 0x1c6a90 - 0x1c6aa8

void entry_1c6a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6a90: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6a94: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c6a98: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6a9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c6aa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChooseJtAttackTarget__FP2JTiP6VECTORffPP6TARGETT2
// Address: 0x1c6aa8 - 0x1c6b1c

void entry_1c6b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6b1c: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1c6b20: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c6b24: 0xda420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1c6b28: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c6b2c: 0xda410100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x1c6b30: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c6b34: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c6b38: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6b3c: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c6b40: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c6b44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6b48: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1c6b50);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c6b50
// Address: 0x1c6b50 - 0x1c6bc0

void entry_1c6b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6b50) {
        switch (ctx->pc) {
            case 0x1c6b98: ctx->pc = 0; goto label_1c6b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6b50: 0xda030000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c6b54: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6b58: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6b5c: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c6b60: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1c6b64: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c6b68: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6b6c: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c6b70: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c6b74: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c6b78: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c6b7c: 0x8e3058d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 22736)));
    // 0x1c6b80: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c6b84: 0x1200004c
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6CB8; return;
    }
    // 0x1c6b8c: 0x27b100c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1c6b90: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1c6b94: 0x8e020088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 136)));
label_1c6b98:
    // 0x1c6b98: 0x541024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1c6b9c: 0x10400043
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 176));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6CAC; return;
    }
    // 0x1c6ba4: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1c6ba8: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1c6bac: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c6bb0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6bb4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c6bb8: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1c6bc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1c6bc0
// Address: 0x1c6bc0 - 0x1c6bcc

void entry_1c6bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6bc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c6bc4: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1c6bcc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c6bcc
// Address: 0x1c6bcc - 0x1c6c1c

void entry_1c6bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6bcc: 0xdba100c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1c6bd0: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1c6bd4: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c6bd8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c6bdc: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c6be0: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c6be4: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c6be8: 0x27a600d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1c6bec: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c6bf0: 0x27a70100
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1c6bf4: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c6bf8: 0x27a80104
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 260));
    // 0x1c6bfc: 0xda030040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1c6c00: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1c6c04: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c6c08: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c6c0c: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c6c10: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c6c14: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x1c6c1c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_1c6c1c
// Address: 0x1c6c1c - 0x1c6c74

void entry_1c6c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6c1c) {
        switch (ctx->pc) {
            case 0x1c6c4c: ctx->pc = 0; goto label_1c6c4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6c1c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1c6c20: 0x1040000a
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c6c4c;
    }
    // 0x1c6c28: 0x8c420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1c6c2c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c6c30: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1c6c34: 0x30630008
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 8));
    // 0x1c6c38: 0x10600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 19412)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c6c4c;
    }
    // 0x1c6c40: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c6c44: 0xe7a00104
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 260), *(uint32_t*)&val); }
    // 0x1c6c48: 0xc7a00104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[0] = *(float*)&val; }
label_1c6c4c:
    // 0x1c6c4c: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6c50: 0x0
    // NOP
    // 0x1c6c54: 0x45000015
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C6CAC; return;
    }
    // 0x1c6c5c: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1c6c60: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c6c64: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c6c68: 0xc7ac00f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 244)); ctx->f[12] = *(float*)&val; }
    // 0x1c6c6c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c6c74);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c6c74
// Address: 0x1c6c74 - 0x1c6c80

void entry_1c6c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6c74: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1c6c78: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c6c80);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c6c80
// Address: 0x1c6c80 - 0x1c6d00

void entry_1c6c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6c80) {
        switch (ctx->pc) {
            case 0x1c6cac: ctx->pc = 0; goto label_1c6cac;
            case 0x1c6cb0: ctx->pc = 0; goto label_1c6cb0;
            case 0x1c6cb8: ctx->pc = 0; goto label_1c6cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6c80: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1c6c84: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6c88: 0x0
    // NOP
    // 0x1c6c8c: 0x45030008
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        goto label_1c6cb0;
    }
    // 0x1c6c94: 0xdba200d0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c6c98: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c6c9c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c6ca0: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c6ca4: 0xc7b50104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[21] = *(float*)&val; }
    // 0x1c6ca8: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
label_1c6cac:
    // 0x1c6cac: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
label_1c6cb0:
    // 0x1c6cb0: 0x5600ffb9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 136)));
        ctx->pc = 0x1C6B98; return;
    }
label_1c6cb8:
    // 0x1c6cb8: 0x7ba200e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c6cbc: 0xaed30000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 19));
    // 0x1c6cc0: 0x7ee20000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), GPR_VEC(ctx, 2));
    // 0x1c6cc4: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1c6cc8: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1c6ccc: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1c6cd0: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1c6cd4: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1c6cd8: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1c6cdc: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1c6ce0: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1c6ce4: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1c6ce8: 0xc7b601b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[22] = *(float*)&val; }
    // 0x1c6cec: 0xc7b501a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 424)); ctx->f[21] = *(float*)&val; }
    // 0x1c6cf0: 0xc7b401a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[20] = *(float*)&val; }
    // 0x1c6cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c6cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c6d00; return;
}


// Function: ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL
// Address: 0x1c6d00 - 0x1c6d68

void entry_1c6d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6d68) {
        switch (ctx->pc) {
            case 0x1c6dbc: ctx->pc = 0; goto label_1c6dbc;
            case 0x1c6dc4: ctx->pc = 0; goto label_1c6dc4;
            case 0x1c6de0: ctx->pc = 0; goto label_1c6de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6d68: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6d6c: 0x10400013
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c6dbc;
    }
    // 0x1c6d74: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x1c6d78: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c6d7c: 0x3c013c14
    SET_GPR_U32(ctx, 1, ((uint32_t)15380 << 16));
    // 0x1c6d80: 0x3421f209
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61961));
    // 0x1c6d84: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c6d88: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1c6d8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6d90: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c6d94: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c6d98: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1c6d9c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6da0: 0x0
    // NOP
    // 0x1c6da4: 0x45010007
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c6dc4;
    }
    // 0x1c6dac: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6db0: 0x0
    // NOP
    // 0x1c6db4: 0x45000003
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c6dc4;
    }
label_1c6dbc:
    // 0x1c6dbc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6dc0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_1c6dc4:
    // 0x1c6dc4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c6dc8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c6dcc: 0xc4414bd8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19416)); ctx->f[1] = *(float*)&val; }
    // 0x1c6dd0: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c6dd4: 0x0
    // NOP
    // 0x1c6dd8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[1]);
        goto label_1c6de0;
    }
label_1c6de0:
    // 0x1c6de0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c6de4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c6de8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c6dec: 0xe622000c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    // 0x1c6df0: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c6df4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1c6df8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1c6dfc: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c6e00: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1c6e08);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1c6e08
// Address: 0x1c6e08 - 0x1c6e34

void entry_1c6e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6e08: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6e0c: 0xae002204
    WRITE32(ADD32(GPR_U32(ctx, 16), 8708), GPR_U32(ctx, 0));
    // 0x1c6e10: 0xae022200
    WRITE32(ADD32(GPR_U32(ctx, 16), 8704), GPR_U32(ctx, 2));
    // 0x1c6e14: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 8712), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6e40(rdram, ctx, runtime); return;
    }
    // 0x1c6e1c: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1c6e20: 0x14400008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C6E44; return;
    }
    // 0x1c6e28: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c6e2c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c6e34);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c6e34
// Address: 0x1c6e34 - 0x1c6e40

void entry_1c6e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6e34: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1c6e38: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1c6e40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c6e40
// Address: 0x1c6e40 - 0x1c6e58

void entry_1c6e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6e40) {
        switch (ctx->pc) {
            case 0x1c6e44: ctx->pc = 0; goto label_1c6e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6e40: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1c6e44:
    // 0x1c6e44: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c6e48: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6e4c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c6e50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChooseJtRushTarget__FP2JT
// Address: 0x1c6e58 - 0x1c6e90

void entry_1c6e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6e90: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6e94: 0xae002204
    WRITE32(ADD32(GPR_U32(ctx, 16), 8708), GPR_U32(ctx, 0));
    // 0x1c6e98: 0xae022200
    WRITE32(ADD32(GPR_U32(ctx, 16), 8704), GPR_U32(ctx, 2));
    // 0x1c6e9c: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 8712), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6ebc(rdram, ctx, runtime); return;
    }
    // 0x1c6ea4: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c6ea8: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c6eb0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c6eb0
// Address: 0x1c6eb0 - 0x1c6ebc

void entry_1c6eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6eb0: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1c6eb4: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1c6ebc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c6ebc
// Address: 0x1c6ebc - 0x1c6ed0

void entry_1c6ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6ebc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6ec0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c6ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c6ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c6ed0; return;
}


// Function: ChooseJtSmashTarget__FP2JT
// Address: 0x1c6ed0 - 0x1c6f0c

void entry_1c6f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6f0c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c6f10: 0xae002204
    WRITE32(ADD32(GPR_U32(ctx, 16), 8708), GPR_U32(ctx, 0));
    // 0x1c6f14: 0xae022200
    WRITE32(ADD32(GPR_U32(ctx, 16), 8704), GPR_U32(ctx, 2));
    // 0x1c6f18: 0x10400007
    WRITE32(ADD32(GPR_U32(ctx, 16), 8712), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c6f38(rdram, ctx, runtime); return;
    }
    // 0x1c6f20: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c6f24: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c6f2c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c6f2c
// Address: 0x1c6f2c - 0x1c6f38

void entry_1c6f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6f2c: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1c6f30: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1c6f38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c6f38
// Address: 0x1c6f38 - 0x1c6f48

void entry_1c6f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c6f38: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c6f3c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c6f40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitStepguard__FP9STEPGUARD
// Address: 0x1c6f48 - 0x1c6f70

void entry_1c6f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c6f70) {
        switch (ctx->pc) {
            case 0x1c6ff0: ctx->pc = 0; goto label_1c6ff0;
            case 0x1c7020: ctx->pc = 0; goto label_1c7020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c6f70: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1c6f74: 0x2403ff0f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967055));
    // 0x1c6f78: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1c6f7c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1c6f80: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1c6f84: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1c6f88: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1c6f8c: 0x425b8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 22);
    // 0x1c6f90: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1c6f94: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c6f98: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c6f9c: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1c6fa0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1c6fa4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c6fa8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c6fac: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c6fb0: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1c6fb4: 0x3c013e32
    SET_GPR_U32(ctx, 1, ((uint32_t)15922 << 16));
    // 0x1c6fb8: 0x3421b8c3
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47299));
    // 0x1c6fbc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c6fc0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c6fc4: 0xfe420538
    WRITE64(ADD32(GPR_U32(ctx, 18), 1336), GPR_U64(ctx, 2));
    // 0x1c6fc8: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c6fcc: 0xae430924
    WRITE32(ADD32(GPR_U32(ctx, 18), 2340), GPR_U32(ctx, 3));
    // 0x1c6fd0: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1c6fd4: 0xe643073c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 1852), *(uint32_t*)&val); }
    // 0x1c6fd8: 0x264207d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 2008));
    // 0x1c6fdc: 0xe6410740
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 1856), *(uint32_t*)&val); }
    // 0x1c6fe0: 0xe6420744
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 1860), *(uint32_t*)&val); }
    // 0x1c6fe4: 0xe640074c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1868), *(uint32_t*)&val); }
    // 0x1c6fe8: 0xae430724
    WRITE32(ADD32(GPR_U32(ctx, 18), 1828), GPR_U32(ctx, 3));
    // 0x1c6fec: 0xae400738
    WRITE32(ADD32(GPR_U32(ctx, 18), 1848), GPR_U32(ctx, 0));
label_1c6ff0:
    // 0x1c6ff0: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x1c6ff4: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1c6ff8: 0x0
    // NOP
    // 0x1c6ffc: 0x0
    // NOP
    // 0x1c7000: 0x0
    // NOP
    // 0x1c7004: 0x481fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967288));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1c6ff0;
    }
    // 0x1c700c: 0x26530b9c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 2972));
    // 0x1c7010: 0x26540be0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 18), 3040));
    // 0x1c7014: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c7018: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1c701c: 0x264208f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 2288));
label_1c7020:
    // 0x1c7020: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x1c7024: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1c7028: 0x0
    // NOP
    // 0x1c702c: 0x0
    // NOP
    // 0x1c7030: 0x0
    // NOP
    // 0x1c7034: 0x481fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967288));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1c7020;
    }
    // 0x1c703c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c7040: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c7044: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1c7048: 0x24841420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    // 0x1c704c: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x1c7054);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_1c7054
// Address: 0x1c7054 - 0x1c70a4

void entry_1c7054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7054: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c7058: 0xde430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x1c705c: 0x2404ff0f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967055));
    // 0x1c7060: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1c7064: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1c7068: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1c706c: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1c7070: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1c7074: 0x52db8
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 22);
    // 0x1c7078: 0xae510b14
    WRITE32(ADD32(GPR_U32(ctx, 18), 2836), GPR_U32(ctx, 17));
    // 0x1c707c: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1c7080: 0xae500b4c
    WRITE32(ADD32(GPR_U32(ctx, 18), 2892), GPR_U32(ctx, 16));
    // 0x1c7084: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1c7088: 0xe6540b30
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 2864), *(uint32_t*)&val); }
    // 0x1c708c: 0xae500b58
    WRITE32(ADD32(GPR_U32(ctx, 18), 2904), GPR_U32(ctx, 16));
    // 0x1c7090: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c7094: 0xae420b10
    WRITE32(ADD32(GPR_U32(ctx, 18), 2832), GPR_U32(ctx, 2));
    // 0x1c7098: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c709c: 0xc064a64
    SET_GPR_U32(ctx, 31, 0x1c70a4);
    WRITE64(ADD32(GPR_U32(ctx, 18), 1336), GPR_U64(ctx, 3));
    SetPoPlayable__FP2POi(rdram, ctx, runtime); return;
}


// Function: entry_1c70a4
// Address: 0x1c70a4 - 0x1c7140

void entry_1c70a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c70a4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c70a8: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1c70ac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c70b0: 0xc442d650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956624)); ctx->f[2] = *(float*)&val; }
    // 0x1c70b4: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1c70b8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c70bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c70c0: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x1c70c4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1c70c8: 0xe6400700
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1792), *(uint32_t*)&val); }
    // 0x1c70cc: 0xe6410b18
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 2840), *(uint32_t*)&val); }
    // 0x1c70d0: 0xe6540b9c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 2972), *(uint32_t*)&val); }
    // 0x1c70d4: 0xe6420c00
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 3072), *(uint32_t*)&val); }
    // 0x1c70d8: 0xa24302b3
    WRITE8(ADD32(GPR_U32(ctx, 18), 691), (uint8_t)GPR_U32(ctx, 3));
    // 0x1c70dc: 0xae520b74
    WRITE32(ADD32(GPR_U32(ctx, 18), 2932), GPR_U32(ctx, 18));
    // 0x1c70e0: 0xe6420bfc
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 3068), *(uint32_t*)&val); }
    // 0x1c70e4: 0xe6630004
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 19), 4), *(uint32_t*)&val); }
    // 0x1c70e8: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1c70ec: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1c70f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c70f4: 0xae400be0
    WRITE32(ADD32(GPR_U32(ctx, 18), 3040), GPR_U32(ctx, 0));
    // 0x1c70f8: 0x3c013fa0
    SET_GPR_U32(ctx, 1, ((uint32_t)16288 << 16));
    // 0x1c70fc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c7100: 0xe6800004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 4), *(uint32_t*)&val); }
    // 0x1c7104: 0xae510bdc
    WRITE32(ADD32(GPR_U32(ctx, 18), 3036), GPR_U32(ctx, 17));
    // 0x1c7108: 0xae500bec
    WRITE32(ADD32(GPR_U32(ctx, 18), 3052), GPR_U32(ctx, 16));
    // 0x1c710c: 0xe6540bd0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 3024), *(uint32_t*)&val); }
    // 0x1c7110: 0xae510bd4
    WRITE32(ADD32(GPR_U32(ctx, 18), 3028), GPR_U32(ctx, 17));
    // 0x1c7114: 0xe6410be8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 3048), *(uint32_t*)&val); }
    // 0x1c7118: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c711c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c7120: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c7124: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c7128: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c712c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7130: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1c7134: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c713c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c7140; return;
}


// Function: LoadStepguardFromBrx__FP9STEPGUARDP18CBinaryInputStream
// Address: 0x1c7140 - 0x1c7154

void entry_1c7154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7154: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c7158: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c715c: 0x24c64c20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19488));
    // 0x1c7160: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1c7168);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1c7168
// Address: 0x1c7168 - 0x1c7170

void entry_1c7168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7168: 0xc0729f0
    SET_GPR_U32(ctx, 31, 0x1c7170);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadStepguardAnimations__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7170
// Address: 0x1c7170 - 0x1c7178

void entry_1c7170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7170: 0xc072a3a
    SET_GPR_U32(ctx, 31, 0x1c7178);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadStepguardPhys__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7178
// Address: 0x1c7178 - 0x1c7188

void entry_1c7178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7178: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c717c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7180: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneStepguard__FP9STEPGUARDT0
// Address: 0x1c7188 - 0x1c71b4

void entry_1c71b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c71b4: 0xae110b74
    WRITE32(ADD32(GPR_U32(ctx, 16), 2932), GPR_U32(ctx, 17));
    // 0x1c71b8: 0xae130b10
    WRITE32(ADD32(GPR_U32(ctx, 16), 2832), GPR_U32(ctx, 19));
    // 0x1c71bc: 0xae120720
    WRITE32(ADD32(GPR_U32(ctx, 16), 1824), GPR_U32(ctx, 18));
    // 0x1c71c0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c71c4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c71c8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c71cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c71d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c71d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c71dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c71e0; return;
}


// Function: BindStepguard__FP9STEPGUARD
// Address: 0x1c71e0 - 0x1c71f8

void entry_1c71f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c71f8: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c71fc: 0x8e050924
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2340)));
    // 0x1c7200: 0x50b10006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2892)));
        ctx->pc = 0x1C721C; return;
    }
    // 0x1c7208: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c720c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1c7214);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c7214
// Address: 0x1c7214 - 0x1c722c

void entry_1c7214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7214) {
        switch (ctx->pc) {
            case 0x1c721c: ctx->pc = 0; goto label_1c721c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7214: 0xae020928
    WRITE32(ADD32(GPR_U32(ctx, 16), 2344), GPR_U32(ctx, 2));
    // 0x1c7218: 0x8e020b4c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2892)));
label_1c721c:
    // 0x1c721c: 0x50510004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2808)));
        ctx->pc = 0x1C7230; return;
    }
    // 0x1c7224: 0xc072ac4
    SET_GPR_U32(ctx, 31, 0x1c722c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebindStepguardEnemy__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c722c
// Address: 0x1c722c - 0x1c7250

void entry_1c722c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c722c) {
        switch (ctx->pc) {
            case 0x1c7230: ctx->pc = 0; goto label_1c7230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c722c: 0x8e020af8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2808)));
label_1c7230:
    // 0x1c7230: 0x10400009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7258; return;
    }
    // 0x1c7238: 0x8e060afc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 2812)));
    // 0x1c723c: 0x10d10008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 17)) {
        entry_1c7260(rdram, ctx, runtime); return;
    }
    // 0x1c7244: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c7248: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1c7250);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c7250
// Address: 0x1c7250 - 0x1c7260

void entry_1c7250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7250) {
        switch (ctx->pc) {
            case 0x1c7258: ctx->pc = 0; goto label_1c7258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7250: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 2816), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c7260(rdram, ctx, runtime); return;
    }
label_1c7258:
    // 0x1c7258: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x1c7260);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 2816));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c7260
// Address: 0x1c7260 - 0x1c7278

void entry_1c7260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7260: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c7264: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c7268: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c726c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c7274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c7278; return;
}


// Function: PostStepguardLoadCallback__FP9STEPGUARD5MSGIDPv
// Address: 0x1c7278 - 0x1c7290

void entry_1c7290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7290: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7294: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c729c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c72a0; return;
}


// Function: PostStepguardLoad__FP9STEPGUARD
// Address: 0x1c72a0 - 0x1c72c4

void entry_1c72c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c72c4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1c72c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c72cc: 0x24c64c30
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19504));
    // 0x1c72d0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1c72d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1c72d8
// Address: 0x1c72d8 - 0x1c72ec

void entry_1c72d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c72d8: 0x8e020720
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
    // 0x1c72dc: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1c72fc(rdram, ctx, runtime); return;
    }
    // 0x1c72e4: 0xc072d6e
    SET_GPR_U32(ctx, 31, 0x1c72ec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PsggNew__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1c72ec
// Address: 0x1c72ec - 0x1c72fc

void entry_1c72ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c72ec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c72f0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c72f4: 0xc072d92
    SET_GPR_U32(ctx, 31, 0x1c72fc);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1824), GPR_U32(ctx, 2));
    AddSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c72fc
// Address: 0x1c72fc - 0x1c7304

void entry_1c72fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c72fc: 0xc0729f0
    SET_GPR_U32(ctx, 31, 0x1c7304);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadStepguardAnimations__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7304
// Address: 0x1c7304 - 0x1c734c

void entry_1c7304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7304) {
        switch (ctx->pc) {
            case 0x1c7310: ctx->pc = 0; goto label_1c7310;
            case 0x1c7314: ctx->pc = 0; goto label_1c7314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7304: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7308: 0x10000002
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7314;
    }
label_1c7310:
    // 0x1c7310: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
label_1c7314:
    // 0x1c7314: 0x28620011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 17));
    // 0x1c7318: 0x1040000c
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c734c(rdram, ctx, runtime); return;
    }
    // 0x1c7320: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1c7324: 0x8c420874
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 2164)));
    // 0x1c7328: 0x1040fff9
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c7310;
    }
    // 0x1c7330: 0xae0206dc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1756), GPR_U32(ctx, 2));
    // 0x1c7334: 0xae0208f8
    WRITE32(ADD32(GPR_U32(ctx, 16), 2296), GPR_U32(ctx, 2));
    // 0x1c7338: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c733c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c7340: 0x8c6200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 224)));
    // 0x1c7344: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c734c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c734c
// Address: 0x1c734c - 0x1c737c

void entry_1c734c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c734c) {
        switch (ctx->pc) {
            case 0x1c7368: ctx->pc = 0; goto label_1c7368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c734c: 0x8e020a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2680)));
    // 0x1c7350: 0x1840001a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1C73BC; return;
    }
    // 0x1c7358: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1c735c: 0x139f38
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 28);
    // 0x1c7360: 0x26110a7c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 2684));
    // 0x1c7364: 0x0
    // NOP
label_1c7368:
    // 0x1c7368: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c736c: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1c7370: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7374: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1c737c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c737c
// Address: 0x1c737c - 0x1c73a8

void entry_1c737c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c737c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c7380: 0x10600009
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1c73a8(rdram, ctx, runtime); return;
    }
    // 0x1c7388: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1c738c: 0x531025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1c7390: 0xfc620538
    WRITE64(ADD32(GPR_U32(ctx, 3), 1336), GPR_U64(ctx, 2));
    // 0x1c7394: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1c7398: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c739c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1c73a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c73a8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c73a8
// Address: 0x1c73a8 - 0x1c73e0

void entry_1c73a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c73a8) {
        switch (ctx->pc) {
            case 0x1c73bc: ctx->pc = 0; goto label_1c73bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c73a8: 0x8e020a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2680)));
    // 0x1c73ac: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1c73b0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c73b4: 0x1440ffec
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7368; return;
    }
label_1c73bc:
    // 0x1c73bc: 0x8e020b04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2820)));
    // 0x1c73c0: 0x10400009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C73E8; return;
    }
    // 0x1c73c8: 0x8e060b08
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 2824)));
    // 0x1c73cc: 0x10c2000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C7400; return;
    }
    // 0x1c73d4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c73d8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1c73e0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c73e0
// Address: 0x1c73e0 - 0x1c73fc

void entry_1c73e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c73e0) {
        switch (ctx->pc) {
            case 0x1c73e8: ctx->pc = 0; goto label_1c73e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c73e0: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 2828), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7400; return;
    }
label_1c73e8:
    // 0x1c73e8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c73ec: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1c73f0: 0x2406008c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 140));
    // 0x1c73f4: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1c73fc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c73fc
// Address: 0x1c73fc - 0x1c740c

void entry_1c73fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c73fc) {
        switch (ctx->pc) {
            case 0x1c7400: ctx->pc = 0; goto label_1c7400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c73fc: 0xae020b0c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2828), GPR_U32(ctx, 2));
label_1c7400:
    // 0x1c7400: 0xc60c0700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1792)); ctx->f[12] = *(float*)&val; }
    // 0x1c7404: 0xc0717aa
    SET_GPR_U32(ctx, 31, 0x1c740c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetStepGravityRatio__FP4STEPf(rdram, ctx, runtime); return;
}


// Function: entry_1c740c
// Address: 0x1c740c - 0x1c741c

void entry_1c740c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c740c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c7410: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7414: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1c741c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1c741c
// Address: 0x1c741c - 0x1c7428

void entry_1c741c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c741c: 0x8e050b10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2832)));
    // 0x1c7420: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1c7428);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1c7428
// Address: 0x1c7428 - 0x1c7448

void entry_1c7428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7428: 0x10400007
    SET_GPR_U32(ctx, 5, ((uint32_t)28 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c7448(rdram, ctx, runtime); return;
    }
    // 0x1c7430: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c7434: 0x24a57278
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 29304));
    // 0x1c7438: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c743c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7440: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1c7448);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1c7448
// Address: 0x1c7448 - 0x1c7468

void entry_1c7448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7448: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c744c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c7450: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c7454: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c7458: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c745c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7460: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreStepguardIntersection__FP9STEPGUARDP2SO
// Address: 0x1c7468 - 0x1c7484

void entry_1c7484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7484: 0x14400013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C74D4; return;
    }
    // 0x1c748c: 0x8e040b0c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2828)));
    // 0x1c7490: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
        ctx->pc = 0x1C74AC; return;
    }
    // 0x1c7498: 0xc06a208
    SET_GPR_U32(ctx, 31, 0x1c74a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1c74a0
// Address: 0x1c74a0 - 0x1c74e8

void entry_1c74a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c74a0) {
        switch (ctx->pc) {
            case 0x1c74ac: ctx->pc = 0; goto label_1c74ac;
            case 0x1c74d4: ctx->pc = 0; goto label_1c74d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c74a0: 0x1440000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c74d4;
    }
    // 0x1c74a8: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
label_1c74ac:
    // 0x1c74ac: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1c74b0: 0x14620008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c74d4;
    }
    // 0x1c74b8: 0xde230538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1c74bc: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1c74c0: 0x4223c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 8));
    // 0x1c74c4: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1c74c8: 0x10600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c74d4;
    }
    // 0x1c74d0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1c74d4:
    // 0x1c74d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c74d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c74dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c74e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnStepguardAdd__FP9STEPGUARD
// Address: 0x1c74e8 - 0x1c74fc

void entry_1c74fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c74fc: 0x8e040720
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
    // 0x1c7500: 0x10800004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7514; return;
    }
    // 0x1c7508: 0xc072d92
    SET_GPR_U32(ctx, 31, 0x1c7510);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7510
// Address: 0x1c7510 - 0x1c7520

void entry_1c7510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7510) {
        switch (ctx->pc) {
            case 0x1c7514: ctx->pc = 0; goto label_1c7514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7510: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c7514:
    // 0x1c7514: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnStepguardRemove__FP9STEPGUARD
// Address: 0x1c7520 - 0x1c7534

void entry_1c7534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7534: 0x8e0407e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c7538: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
        ctx->pc = 0x1C7550; return;
    }
    // 0x1c7540: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c7548);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c7548
// Address: 0x1c7548 - 0x1c7560

void entry_1c7548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7548) {
        switch (ctx->pc) {
            case 0x1c7550: ctx->pc = 0; goto label_1c7550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7548: 0xae0007e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 2016), GPR_U32(ctx, 0));
    // 0x1c754c: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
label_1c7550:
    // 0x1c7550: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
        ctx->pc = 0x1C7568; return;
    }
    // 0x1c7558: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c7560);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c7560
// Address: 0x1c7560 - 0x1c7578

void entry_1c7560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7560) {
        switch (ctx->pc) {
            case 0x1c7568: ctx->pc = 0; goto label_1c7568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7560: 0xae000754
    WRITE32(ADD32(GPR_U32(ctx, 16), 1876), GPR_U32(ctx, 0));
    // 0x1c7564: 0x8e040720
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
label_1c7568:
    // 0x1c7568: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C757C; return;
    }
    // 0x1c7570: 0xc072dbe
    SET_GPR_U32(ctx, 31, 0x1c7578);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7578
// Address: 0x1c7578 - 0x1c75b0

void entry_1c7578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7578) {
        switch (ctx->pc) {
            case 0x1c757c: ctx->pc = 0; goto label_1c757c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7578: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1c757c:
    // 0x1c757c: 0xae00072c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1836), GPR_U32(ctx, 0));
    // 0x1c7580: 0xc440d654
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956628)); ctx->f[0] = *(float*)&val; }
    // 0x1c7584: 0xae000a60
    WRITE32(ADD32(GPR_U32(ctx, 16), 2656), GPR_U32(ctx, 0));
    // 0x1c7588: 0xe6000c00
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3072), *(uint32_t*)&val); }
    // 0x1c758c: 0xae000748
    WRITE32(ADD32(GPR_U32(ctx, 16), 1864), GPR_U32(ctx, 0));
    // 0x1c7590: 0xae000ba4
    WRITE32(ADD32(GPR_U32(ctx, 16), 2980), GPR_U32(ctx, 0));
    // 0x1c7594: 0xe6000bf4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3060), *(uint32_t*)&val); }
    // 0x1c7598: 0xe6000bf8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3064), *(uint32_t*)&val); }
    // 0x1c759c: 0xe6000bfc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3068), *(uint32_t*)&val); }
    // 0x1c75a0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c75a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c75a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetStepguardAccel__FP9STEPGUARDf
// Address: 0x1c75b0 - 0x1c7614

void entry_1c7614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7614: 0xda420640
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1600)));
    // 0x1c7618: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c761c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x1c7620: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c7624: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7628: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c762c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7630: 0xda450660
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1632)));
    // 0x1c7634: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1c7638: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c763c: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c7640: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c7644: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7648: 0xda030010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1c764c: 0xda020020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1c7650: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c7654: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7658: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c765c: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c7664);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c7664
// Address: 0x1c7664 - 0x1c76ac

void entry_1c7664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7664) {
        switch (ctx->pc) {
            case 0x1c7678: ctx->pc = 0; goto label_1c7678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7664: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c7668: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c766c: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1c7670: 0x10000099
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C78D8; return;
    }
label_1c7678:
    // 0x1c7678: 0x8e420b1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2844)));
    // 0x1c767c: 0x1040006e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7838; return;
    }
    // 0x1c7684: 0xda4100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1c7688: 0xda420660
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1632)));
    // 0x1c768c: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7690: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c7694: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7698: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c769c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c76a0: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1c76a4: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x1c76ac);
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_1c76ac
// Address: 0x1c76ac - 0x1c77ec

void entry_1c76ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c76ac) {
        switch (ctx->pc) {
            case 0x1c76fc: ctx->pc = 0; goto label_1c76fc;
            case 0x1c7710: ctx->pc = 0; goto label_1c7710;
            case 0x1c7790: ctx->pc = 0; goto label_1c7790;
            case 0x1c77a4: ctx->pc = 0; goto label_1c77a4;
            case 0x1c77a8: ctx->pc = 0; goto label_1c77a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c76ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c76b0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1c76b4: 0x24434c50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19536));
    // 0x1c76b8: 0xc4434c50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19536)); ctx->f[3] = *(float*)&val; }
    // 0x1c76bc: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1c76c0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c76c4: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c76c8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c76cc: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1c76d0: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c76d4: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1c76d8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1c76dc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c76e0: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1c76e4: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c76e8: 0x0
    // NOP
    // 0x1c76ec: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c76fc;
    }
    // 0x1c76f4: 0x10000006
    ctx->f[6] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7710;
    }
label_1c76fc:
    // 0x1c76fc: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7700: 0x0
    // NOP
    // 0x1c7704: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7710;
    }
    // 0x1c770c: 0x46002986
    ctx->f[6] = FPU_MOV_S(ctx->f[5]);
label_1c7710:
    // 0x1c7710: 0x8e430724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1828)));
    // 0x1c7714: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1c7718: 0x14620023
    ctx->f[0] = FPU_MOV_S(ctx->f[6]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c77a8;
    }
    // 0x1c7720: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1c7724: 0x26420b30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 2864));
    // 0x1c7728: 0xda410a50
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 2640)));
    // 0x1c772c: 0x24835c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1c7730: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7734: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1c7738: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c773c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c7740: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7744: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7748: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c774c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7750: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c7754: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c7758: 0xc6430b30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2864)); ctx->f[3] = *(float*)&val; }
    // 0x1c775c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7760: 0xc4845c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c7764: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c7768: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1c776c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1c7770: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c7774: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1c7778: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c777c: 0x0
    // NOP
    // 0x1c7780: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7790;
    }
    // 0x1c7788: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c77a4;
    }
label_1c7790:
    // 0x1c7790: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7794: 0x0
    // NOP
    // 0x1c7798: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c77a4;
    }
    // 0x1c77a0: 0x46002806
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
label_1c77a4:
    // 0x1c77a4: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
label_1c77a8:
    // 0x1c77a8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1c77ac: 0xda410110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 272)));
    // 0x1c77b0: 0xda420120
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 288)));
    // 0x1c77b4: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c77b8: 0xda430130
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 304)));
    // 0x1c77bc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1c77c0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c77c4: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1c77c8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c77cc: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c77d0: 0x4be418d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c77d4: 0x4be41098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c77d8: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c77dc: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c77e0: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c77e4: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1c77ec);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1c77ec
// Address: 0x1c77ec - 0x1c7828

void entry_1c77ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c77ec: 0xda420640
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1600)));
    // 0x1c77f0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1c77f4: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c77f8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c77fc: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c7800: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7804: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c7808: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c780c: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c7810: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c7814: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7818: 0x8e480210
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x1c781c: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c7820: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1c7828);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1c7828
// Address: 0x1c7828 - 0x1c787c

void entry_1c7828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7828) {
        switch (ctx->pc) {
            case 0x1c7838: ctx->pc = 0; goto label_1c7838;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7828: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c782c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c7830: 0x10000028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C78D4; return;
    }
label_1c7838:
    // 0x1c7838: 0xc6400ba4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2980)); ctx->f[0] = *(float*)&val; }
    // 0x1c783c: 0xc44c185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[12] = *(float*)&val; }
    // 0x1c7840: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7844: 0x0
    // NOP
    // 0x1c7848: 0x45000027
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 2992));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C78E8; return;
    }
    // 0x1c7850: 0x460c0301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x1c7854: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c7858: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1c785c: 0x26470bc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 3008));
    // 0x1c7860: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c7864: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c7868: 0x46156369
    ctx->f[13] = std::min(ctx->f[12], ctx->f[21]);
    // 0x1c786c: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7870: 0x26440100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 256));
    // 0x1c7874: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1c787c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 336));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1c787c
// Address: 0x1c787c - 0x1c78c0

void entry_1c787c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c787c: 0xda420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1c7880: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c7884: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c7888: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c788c: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x1c7890: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7894: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c7898: 0x3c01469c
    SET_GPR_U32(ctx, 1, ((uint32_t)18076 << 16));
    // 0x1c789c: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1c78a0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c78a4: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1c78a8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c78ac: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c78b0: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c78b4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c78b8: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x1c78c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_1c78c0
// Address: 0x1c78c0 - 0x1c78cc

void entry_1c78c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c78c0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c78c4: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c78cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c78cc
// Address: 0x1c78cc - 0x1c78e0

void entry_1c78cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c78cc) {
        switch (ctx->pc) {
            case 0x1c78d4: ctx->pc = 0; goto label_1c78d4;
            case 0x1c78d8: ctx->pc = 0; goto label_1c78d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c78cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c78d0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
label_1c78d4:
    // 0x1c78d4: 0x24850660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1632));
label_1c78d8:
    // 0x1c78d8: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1c78e0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1760));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1c78e0
// Address: 0x1c78e0 - 0x1c799c

void entry_1c78e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c78e0) {
        switch (ctx->pc) {
            case 0x1c78e8: ctx->pc = 0; goto label_1c78e8;
            case 0x1c7924: ctx->pc = 0; goto label_1c7924;
            case 0x1c792c: ctx->pc = 0; goto label_1c792c;
            case 0x1c7974: ctx->pc = 0; goto label_1c7974;
            case 0x1c7988: ctx->pc = 0; goto label_1c7988;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c78e0: 0x10000057
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7A40; return;
    }
label_1c78e8:
    // 0x1c78e8: 0x8e430724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1828)));
    // 0x1c78ec: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1c78f0: 0x14620050
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C7A34; return;
    }
    // 0x1c78f8: 0x8e420a6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2668)));
    // 0x1c78fc: 0x1040004d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7A34; return;
    }
    // 0x1c7904: 0x8e4307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2016)));
    // 0x1c7908: 0x10600006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c7924;
    }
    // 0x1c7910: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1c7914: 0xc4610014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1c7918: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1c791c: 0x10000003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[3] = ctx->f[1] / ctx->f[0];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c792c;
    }
label_1c7924:
    // 0x1c7924: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c7928: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
label_1c792c:
    // 0x1c792c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c7930: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c7934: 0x24434c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19552));
    // 0x1c7938: 0xc4424c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19552)); ctx->f[2] = *(float*)&val; }
    // 0x1c793c: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c7940: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1c7944: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c7948: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1c794c: 0xc4845c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1c7950: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c7954: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1c7958: 0x46001300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c795c: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7960: 0x0
    // NOP
    // 0x1c7964: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7974;
    }
    // 0x1c796c: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7988;
    }
label_1c7974:
    // 0x1c7974: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7978: 0x0
    // NOP
    // 0x1c797c: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7988;
    }
    // 0x1c7984: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_1c7988:
    // 0x1c7988: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1c798c: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1c7990: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c7994: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1c799c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 19568));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1c799c
// Address: 0x1c799c - 0x1c79ac

void entry_1c799c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c799c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c79a0: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1c79a4: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1c79ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c79ac
// Address: 0x1c79ac - 0x1c79b8

void entry_1c79ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79ac: 0x7ba500a0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1c79b0: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1c79b8);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c79b8
// Address: 0x1c79b8 - 0x1c79c4

void entry_1c79b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79b8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c79bc: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1c79c4);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c79c4
// Address: 0x1c79c4 - 0x1c79d8

void entry_1c79c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79c4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1c79c8: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1c79cc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c79d0: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1c79d8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 19584));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1c79d8
// Address: 0x1c79d8 - 0x1c79e8

void entry_1c79d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79d8: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1c79dc: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1c79e0: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1c79e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c79e8
// Address: 0x1c79e8 - 0x1c79f4

void entry_1c79e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79e8: 0x7ba500c0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1c79ec: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1c79f4);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c79f4
// Address: 0x1c79f4 - 0x1c7a00

void entry_1c79f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c79f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c79f8: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1c7a00);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c7a00
// Address: 0x1c7a00 - 0x1c7a20

void entry_1c7a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7a00: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1c7a04: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c7a08: 0x26450660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1632));
    // 0x1c7a0c: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1c7a10: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1c7a14: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c7a18: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1c7a20);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1c7a20
// Address: 0x1c7a20 - 0x1c7a2c

void entry_1c7a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7a20: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c7a24: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1c7a2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 848));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c7a2c
// Address: 0x1c7a2c - 0x1c7a3c

void entry_1c7a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7a2c) {
        switch (ctx->pc) {
            case 0x1c7a34: ctx->pc = 0; goto label_1c7a34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7a2c: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7A40; return;
    }
label_1c7a34:
    // 0x1c7a34: 0xc071446
    SET_GPR_U32(ctx, 31, 0x1c7a3c);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    PresetStepAccel__FP4STEPf(rdram, ctx, runtime); return;
}


// Function: entry_1c7a3c
// Address: 0x1c7a3c - 0x1c7a60

void entry_1c7a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7a3c) {
        switch (ctx->pc) {
            case 0x1c7a40: ctx->pc = 0; goto label_1c7a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7a3c: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_1c7a40:
    // 0x1c7a40: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c7a44: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c7a48: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c7a4c: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x1c7a50: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x1c7a54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c7a5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c7a60; return;
}


// Function: DradEnemyStepguard__FP9STEPGUARD
// Address: 0x1c7a60 - 0x1c7a84

void entry_1c7a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7a84: 0x10400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7AC8; return;
    }
    // 0x1c7a8c: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1c7a90: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c7a94: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7a98: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7a9c: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c7aa0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c7aa8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c7aa8
// Address: 0x1c7aa8 - 0x1c7ab8

void entry_1c7aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7aa8: 0xc60c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 276)); ctx->f[12] = *(float*)&val; }
    // 0x1c7aac: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1c7ab0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c7ab8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c7ab8
// Address: 0x1c7ab8 - 0x1c7ac0

void entry_1c7ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ab8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c7ac0);
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c7ac0
// Address: 0x1c7ac0 - 0x1c7ae0

void entry_1c7ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7ac0) {
        switch (ctx->pc) {
            case 0x1c7ac8: ctx->pc = 0; goto label_1c7ac8;
            case 0x1c7acc: ctx->pc = 0; goto label_1c7acc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7ac0: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7acc;
    }
label_1c7ac8:
    // 0x1c7ac8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
label_1c7acc:
    // 0x1c7acc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c7ad0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1c7ad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c7adc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c7ae0; return;
}


// Function: SetStepguardTargetHeading__FP9STEPGUARDff
// Address: 0x1c7ae0 - 0x1c7b04

void entry_1c7b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7b04: 0x14400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7B4C; return;
    }
    // 0x1c7b0c: 0x8e020b1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2844)));
    // 0x1c7b10: 0xe6140638
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1c7b14: 0x10400007
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 2852), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7B34; return;
    }
    // 0x1c7b1c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c7b20: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1c7b24: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1c7b2c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1632));
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c7b2c
// Address: 0x1c7b2c - 0x1c7b48

void entry_1c7b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7b2c) {
        switch (ctx->pc) {
            case 0x1c7b34: ctx->pc = 0; goto label_1c7b34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7b2c: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7B4C; return;
    }
label_1c7b34:
    // 0x1c7b34: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1c7b38: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1c7b3c: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1c7b40: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1c7b48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1632));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c7b48
// Address: 0x1c7b48 - 0x1c7b60

void entry_1c7b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7b48) {
        switch (ctx->pc) {
            case 0x1c7b4c: ctx->pc = 0; goto label_1c7b4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7b48: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c7b4c:
    // 0x1c7b4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c7b50: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x1c7b54: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1c7b58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c7b60
// Address: 0x1c7b60 - 0x1c7bb8

void FUN_001c7b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7b60) {
        switch (ctx->pc) {
            case 0x1c7bb0: ctx->pc = 0; goto label_1c7bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7b60: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1c7b64: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1c7b68: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1c7b6c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c7b70: 0x8e020b84
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2948)));
    // 0x1c7b74: 0x14400019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7BDC; return;
    }
    // 0x1c7b7c: 0x8e020b88
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2952)));
    // 0x1c7b80: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x1C7BE0; return;
    }
    // 0x1c7b88: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c7b8c: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1c7b90: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1C7BBC; return;
    }
    // 0x1c7b98: 0x8c42275c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 10076)));
    // 0x1c7b9c: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x1C7BE0; return;
    }
    // 0x1c7ba4: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7BBC; return;
    }
    // 0x1c7bac: 0x0
    // NOP
label_1c7bb0:
    // 0x1c7bb0: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1c7bb8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1c7bb8
// Address: 0x1c7bb8 - 0x1c7bc8

void entry_1c7bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7bb8) {
        switch (ctx->pc) {
            case 0x1c7bbc: ctx->pc = 0; goto label_1c7bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7bb8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1c7bbc:
    // 0x1c7bbc: 0x8c620174
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 372)));
    // 0x1c7bc0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7bc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7bc8
// Address: 0x1c7bc8 - 0x1c7be8

void entry_1c7bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7bc8) {
        switch (ctx->pc) {
            case 0x1c7bdc: ctx->pc = 0; goto label_1c7bdc;
            case 0x1c7be0: ctx->pc = 0; goto label_1c7be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7bc8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c7bcc: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c7bd0: 0x54a2fff7
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1C7BB0; return;
    }
    // 0x1c7bd8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c7bdc:
    // 0x1c7bdc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1c7be0:
    // 0x1c7be0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStepguardDrive__FP9STEPGUARD
// Address: 0x1c7be8 - 0x1c7c2c

void entry_1c7c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7c2c) {
        switch (ctx->pc) {
            case 0x1c7c98: ctx->pc = 0; goto label_1c7c98;
            case 0x1c7c9c: ctx->pc = 0; goto label_1c7c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7c2c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1c7c30: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c7c34: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c7c38: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c7c3c: 0xda010640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1c7c40: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7c44: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c7c48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7c4c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7c50: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7c54: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7c58: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c7c5c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c7c60: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7c64: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1c7c68: 0x4500000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7c98;
    }
    // 0x1c7c70: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c7c74: 0x0
    // NOP
    // 0x1c7c78: 0x45000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c7c9c;
    }
    // 0x1c7c80: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1c7c84: 0x8e020754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c7c88: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1c7c8c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c7c90: 0xe4400018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 24), *(uint32_t*)&val); }
    // 0x1c7c94: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
label_1c7c98:
    // 0x1c7c98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1c7c9c:
    // 0x1c7c9c: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c7ca4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c7ca4
// Address: 0x1c7ca4 - 0x1c7cb8

void entry_1c7ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ca4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c7ca8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c7cac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c7cb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c7cb8; return;
}


// Function: UpdateStepguard__FP9STEPGUARDf
// Address: 0x1c7cb8 - 0x1c7cd8

void entry_1c7cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7cd8: 0x8e220b44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2884)));
    // 0x1c7cdc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 2896)));
        ctx->pc = 0x1C7CF0; return;
    }
    // 0x1c7ce4: 0xc072ac4
    SET_GPR_U32(ctx, 31, 0x1c7cec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RebindStepguardEnemy__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7cec
// Address: 0x1c7cec - 0x1c7d18

void entry_1c7cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7cec) {
        switch (ctx->pc) {
            case 0x1c7cf0: ctx->pc = 0; goto label_1c7cf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7cec: 0x8e320b50
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 2896)));
label_1c7cf0:
    // 0x1c7cf0: 0x16400038
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7DD4; return;
    }
    // 0x1c7cf8: 0x8e220720
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c7cfc: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1c7d00: 0x50640040
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
        ctx->pc = 0x1C7E04; return;
    }
    // 0x1c7d08: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7d0c: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1c7d10: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7d18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7d18
// Address: 0x1c7d18 - 0x1c7d44

void entry_1c7d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7d18: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c7d1c: 0x10800038
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1c7e00(rdram, ctx, runtime); return;
    }
    // 0x1c7d24: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1c7d28: 0x14820035
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        entry_1c7e00(rdram, ctx, runtime); return;
    }
    // 0x1c7d30: 0x8c842750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 10064)));
    // 0x1c7d34: 0x50800033
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
        ctx->pc = 0x1C7E04; return;
    }
    // 0x1c7d3c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1c7d44);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c7d44
// Address: 0x1c7d44 - 0x1c7d58

void entry_1c7d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7d44: 0x1040002e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c7e00(rdram, ctx, runtime); return;
    }
    // 0x1c7d4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c7d50: 0xc072b0a
    SET_GPR_U32(ctx, 31, 0x1c7d58);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 10064)));
    FUN_001cac28__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7d58
// Address: 0x1c7d58 - 0x1c7d68

void entry_1c7d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7d58: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7d5c: 0x8c62016c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 364)));
    // 0x1c7d60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7d68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7d68
// Address: 0x1c7d68 - 0x1c7d7c

void entry_1c7d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7d68: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
        ctx->pc = 0x1C7D84; return;
    }
    // 0x1c7d70: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c7d74: 0xc072b0a
    SET_GPR_U32(ctx, 31, 0x1c7d7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001cac28__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7d7c
// Address: 0x1c7d7c - 0x1c7db4

void entry_1c7d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7d7c) {
        switch (ctx->pc) {
            case 0x1c7d84: ctx->pc = 0; goto label_1c7d84;
            case 0x1c7d98: ctx->pc = 0; goto label_1c7d98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7d7c: 0x10000021
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7E04; return;
    }
label_1c7d84:
    // 0x1c7d84: 0x8c620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    // 0x1c7d88: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c7d8c: 0x1040001c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c7e00(rdram, ctx, runtime); return;
    }
    // 0x1c7d94: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
label_1c7d98:
    // 0x1c7d98: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c7d9c: 0x8c43005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 92)));
    // 0x1c7da0: 0x10710004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 17)) {
        entry_1c7db4(rdram, ctx, runtime); return;
    }
    // 0x1c7da8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c7dac: 0xc072b0a
    SET_GPR_U32(ctx, 31, 0x1c7db4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 10064)));
    FUN_001cac28__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7db4
// Address: 0x1c7db4 - 0x1c7ddc

void entry_1c7db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7db4) {
        switch (ctx->pc) {
            case 0x1c7dd4: ctx->pc = 0; goto label_1c7dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7db4: 0x8e230720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c7db8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1c7dbc: 0x8c620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    // 0x1c7dc0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1c7dc4: 0x1440fff4
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7D98; return;
    }
    // 0x1c7dcc: 0x1000000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7E04; return;
    }
label_1c7dd4:
    // 0x1c7dd4: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1c7ddc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c7ddc
// Address: 0x1c7ddc - 0x1c7e00

void entry_1c7ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7ddc) {
        switch (ctx->pc) {
            case 0x1c7df4: ctx->pc = 0; goto label_1c7df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7ddc: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c7df4;
    }
    // 0x1c7de4: 0x8e220720
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c7de8: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1c7dec: 0x50640005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
        ctx->pc = 0x1C7E04; return;
    }
label_1c7df4:
    // 0x1c7df4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c7df8: 0xc072b0a
    SET_GPR_U32(ctx, 31, 0x1c7e00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001cac28__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7e00
// Address: 0x1c7e00 - 0x1c7e18

void entry_1c7e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7e00) {
        switch (ctx->pc) {
            case 0x1c7e04: ctx->pc = 0; goto label_1c7e04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7e00: 0x8e220b8c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
label_1c7e04:
    // 0x1c7e04: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c7e30(rdram, ctx, runtime); return;
    }
    // 0x1c7e0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7e10: 0xc06eca4
    SET_GPR_U32(ctx, 31, 0x1c7e18);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime); return;
}


// Function: entry_1c7e18
// Address: 0x1c7e18 - 0x1c7e30

void entry_1c7e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7e18: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c7e30(rdram, ctx, runtime); return;
    }
    // 0x1c7e20: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7e24: 0x8c620190
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 400)));
    // 0x1c7e28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7e30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7e30
// Address: 0x1c7e30 - 0x1c7e38

void entry_1c7e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7e30: 0xc072696
    SET_GPR_U32(ctx, 31, 0x1c7e38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    HandleStepguardGrfsgsc__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7e38
// Address: 0x1c7e38 - 0x1c7e40

void entry_1c7e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7e38: 0xc071ed8
    SET_GPR_U32(ctx, 31, 0x1c7e40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001c7b60(rdram, ctx, runtime); return;
}


// Function: entry_1c7e40
// Address: 0x1c7e40 - 0x1c7e88

void entry_1c7e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7e40: 0x8e2707e0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x1c7e44: 0x10e0001a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7EB0; return;
    }
    // 0x1c7e4c: 0x8ce20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x1c7e50: 0x8c42009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 156)));
    // 0x1c7e54: 0x50400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
        ctx->pc = 0x1C7EB0; return;
    }
    // 0x1c7e5c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1c7e60: 0x10800012
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7EAC; return;
    }
    // 0x1c7e68: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c7e6c: 0xc4ed0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[13] = *(float*)&val; }
    // 0x1c7e70: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7e74: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c7e78: 0x26280640
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 1600));
    // 0x1c7e7c: 0xc4ec0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1c7e80: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1c7e88);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1c7e88
// Address: 0x1c7e88 - 0x1c7ed0

void entry_1c7e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7e88) {
        switch (ctx->pc) {
            case 0x1c7eac: ctx->pc = 0; goto label_1c7eac;
            case 0x1c7eb0: ctx->pc = 0; goto label_1c7eb0;
            case 0x1c7ebc: ctx->pc = 0; goto label_1c7ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7e88: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c7e8c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c7e90: 0xda210640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x1c7e94: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c7e98: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c7e9c: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c7ea0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c7ea4: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7ebc;
    }
label_1c7eac:
    // 0x1c7eac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1c7eb0:
    // 0x1c7eb0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1c7eb4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c7eb8: 0x7e230640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), GPR_VEC(ctx, 3));
label_1c7ebc:
    // 0x1c7ebc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7ec0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c7ec4: 0x8c620188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 392)));
    // 0x1c7ec8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7ed0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7ed0
// Address: 0x1c7ed0 - 0x1c7ee0

void entry_1c7ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ed0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c7ed4: 0x8c620178
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 376)));
    // 0x1c7ed8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c7ee0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c7ee0
// Address: 0x1c7ee0 - 0x1c7ef4

void entry_1c7ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ee0: 0x8e240720
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c7ee4: 0x10800003
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1c7ef4(rdram, ctx, runtime); return;
    }
    // 0x1c7eec: 0xc072ea8
    SET_GPR_U32(ctx, 31, 0x1c7ef4);
    EnsureSggCallback__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1c7ef4
// Address: 0x1c7ef4 - 0x1c7efc

void entry_1c7ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ef4: 0xc072bce
    SET_GPR_U32(ctx, 31, 0x1c7efc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateStepguardEffect__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c7efc
// Address: 0x1c7efc - 0x1c7f14

void entry_1c7efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7efc: 0x8e220c08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3080)));
    // 0x1c7f00: 0x10400039
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C7FE8; return;
    }
    // 0x1c7f08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c7f0c: 0xc06eca4
    SET_GPR_U32(ctx, 31, 0x1c7f14);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 224));
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime); return;
}


// Function: entry_1c7f14
// Address: 0x1c7f14 - 0x1c7f78

void entry_1c7f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7f14) {
        switch (ctx->pc) {
            case 0x1c7f50: ctx->pc = 0; goto label_1c7f50;
            case 0x1c7f64: ctx->pc = 0; goto label_1c7f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7f14: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c7f18: 0x1080000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1c7f50;
    }
    // 0x1c7f20: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1c7f24: 0x24634ad0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 19152));
    // 0x1c7f28: 0xd8820080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    // 0x1c7f2c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1c7f30: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1c7f34: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c7f38: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c7f3c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c7f40: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c7f44: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7f48: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c7f64;
    }
label_1c7f50:
    // 0x1c7f50: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c7f54: 0x24448d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1c7f58: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c7f5c: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c7f60: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
label_1c7f64:
    // 0x1c7f64: 0x26108d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937888));
    // 0x1c7f68: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1c7f6c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c7f70: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1c7f78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c7f78
// Address: 0x1c7f78 - 0x1c7f88

void entry_1c7f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7f78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c7f7c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c7f80: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1c7f88);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1c7f88
// Address: 0x1c7f88 - 0x1c7ff0

void entry_1c7f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c7f88) {
        switch (ctx->pc) {
            case 0x1c7fe8: ctx->pc = 0; goto label_1c7fe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c7f88: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c7f8c: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c7f90: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c7f94: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c7f98: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c7f9c: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1c7fa0: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c7fa4: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7fa8: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c7fac: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1c7fb0: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1c7fb4: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7fb8: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1c7fbc: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1c7fc0: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c7fc4: 0xfa230660
    WRITE128(ADD32(GPR_U32(ctx, 17), 1632), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c7fc8: 0xfa250670
    WRITE128(ADD32(GPR_U32(ctx, 17), 1648), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c7fcc: 0xfa210680
    WRITE128(ADD32(GPR_U32(ctx, 17), 1664), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7fd0: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c7fd4: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c7fd8: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c7fdc: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1c7fe0: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c7fe4: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c7fe8:
    // 0x1c7fe8: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1c7ff0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c7ff0
// Address: 0x1c7ff0 - 0x1c8010

void entry_1c7ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c7ff0: 0xae200b14
    WRITE32(ADD32(GPR_U32(ctx, 17), 2836), GPR_U32(ctx, 0));
    // 0x1c7ff4: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1c7ff8: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1c7ffc: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1c8000: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1c8004: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c8008: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SgsNextStepguardAI__FP9STEPGUARD
// Address: 0x1c8010 - 0x1c8030

void entry_1c8030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8030) {
        switch (ctx->pc) {
            case 0x1c8080: ctx->pc = 0; goto label_1c8080;
            case 0x1c8084: ctx->pc = 0; goto label_1c8084;
            case 0x1c8088: ctx->pc = 0; goto label_1c8088;
            case 0x1c80cc: ctx->pc = 0; goto label_1c80cc;
            case 0x1c80dc: ctx->pc = 0; goto label_1c80dc;
            case 0x1c812c: ctx->pc = 0; goto label_1c812c;
            case 0x1c81c0: ctx->pc = 0; goto label_1c81c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8030: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c8034: 0xc6000bfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3068)); ctx->f[0] = *(float*)&val; }
    // 0x1c8038: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c803c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c8040: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1c8044: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1c8048: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c804c: 0x0
    // NOP
    // 0x1c8050: 0x4500000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8080;
    }
    // 0x1c8058: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c805c: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c8084;
    }
    // 0x1c8064: 0x10620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c8088;
    }
    // 0x1c806c: 0x8e0207ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1964)));
    // 0x1c8070: 0x10400005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c8088;
    }
    // 0x1c8078: 0x100000e0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
label_1c8080:
    // 0x1c8080: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
label_1c8084:
    // 0x1c8084: 0x2c620011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
label_1c8088:
    // 0x1c8088: 0x104000dc
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8090: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c8094: 0x2442d660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956640));
    // 0x1c8098: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c809c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c80a0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c80a8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c80ac: 0x10a2006e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C8268; return;
    }
    // 0x1c80b4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c80cc;
    }
    // 0x1c80bc: 0x10a00007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1c80dc;
    }
    // 0x1c80c4: 0x100000cf
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8404; return;
    }
label_1c80cc:
    // 0x1c80cc: 0x10a2007f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C82CC; return;
    }
    // 0x1c80d4: 0x100000cb
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8404; return;
    }
label_1c80dc:
    // 0x1c80dc: 0x100000c7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c80e4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c80e8: 0x10a20058
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C824C; return;
    }
    // 0x1c80f0: 0x10400068
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8294; return;
    }
    // 0x1c80f8: 0x14a000c1
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c8100: 0x8e020754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c8104: 0x10400009
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c812c;
    }
    // 0x1c810c: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1c8110: 0x3403c000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 49152));
    // 0x1c8114: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1c8118: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c811c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c8120: 0x441026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1c8124: 0x100000b5
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
label_1c812c:
    // 0x1c812c: 0x100000b3
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8134: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8138: 0x10a40044
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1C824C; return;
    }
    // 0x1c8140: 0x10400054
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8294; return;
    }
    // 0x1c8148: 0x14a000ad
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c8150: 0x8e020754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c8154: 0x104000aa
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c815c: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1c8160: 0x3403c000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 49152));
    // 0x1c8164: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1c8168: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c816c: 0x100000a3
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8174: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8178: 0x10a20034
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C824C; return;
    }
    // 0x1c8180: 0x1440009f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c8188: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c818c: 0x14a2009c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c8194: 0x10000047
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C82B4; return;
    }
    // 0x1c819c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c81a0: 0x10a20007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1c81c0;
    }
    // 0x1c81a8: 0x1040ffc8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c80cc;
    }
    // 0x1c81b0: 0x10a00016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C820C; return;
    }
    // 0x1c81b8: 0x10000092
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8404; return;
    }
label_1c81c0:
    // 0x1c81c0: 0xc072130
    SET_GPR_U32(ctx, 31, 0x1c81c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FReachedStepguardGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c81c8
// Address: 0x1c81c8 - 0x1c8244

void entry_1c81c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c81c8) {
        switch (ctx->pc) {
            case 0x1c820c: ctx->pc = 0; goto label_1c820c;
            case 0x1c8214: ctx->pc = 0; goto label_1c8214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c81c8: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1c81cc: 0x1000008b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c81d4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c81d8: 0x10a2000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1c8214;
    }
    // 0x1c81e0: 0x1040ffba
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C80CC; return;
    }
    // 0x1c81e8: 0x14a00085
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c81f0: 0x24c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    // 0x1c81f4: 0xc6010bf4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3060)); ctx->f[1] = *(float*)&val; }
    // 0x1c81f8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c81fc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8200: 0x0
    // NOP
    // 0x1c8204: 0x4500007e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C8400; return;
    }
label_1c820c:
    // 0x1c820c: 0x1000007b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
label_1c8214:
    // 0x1c8214: 0x8e030a60
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2656)));
    // 0x1c8218: 0x10000077
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83F8; return;
    }
    // 0x1c8220: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8224: 0x10b20009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x1C824C; return;
    }
    // 0x1c822c: 0x10400019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8294; return;
    }
    // 0x1c8234: 0x14a00072
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c823c: 0xc072130
    SET_GPR_U32(ctx, 31, 0x1c8244);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FReachedStepguardGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c8244
// Address: 0x1c8244 - 0x1c8328

void entry_1c8244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8244) {
        switch (ctx->pc) {
            case 0x1c824c: ctx->pc = 0; goto label_1c824c;
            case 0x1c8268: ctx->pc = 0; goto label_1c8268;
            case 0x1c8294: ctx->pc = 0; goto label_1c8294;
            case 0x1c82a4: ctx->pc = 0; goto label_1c82a4;
            case 0x1c82b0: ctx->pc = 0; goto label_1c82b0;
            case 0x1c82b4: ctx->pc = 0; goto label_1c82b4;
            case 0x1c82cc: ctx->pc = 0; goto label_1c82cc;
            case 0x1c8310: ctx->pc = 0; goto label_1c8310;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8244: 0x1000006d
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
label_1c824c:
    // 0x1c824c: 0x24c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    // 0x1c8250: 0xc6010bf8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3064)); ctx->f[1] = *(float*)&val; }
    // 0x1c8254: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c8258: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c825c: 0x0
    // NOP
    // 0x1c8260: 0x45000067
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C8400; return;
    }
label_1c8268:
    // 0x1c8268: 0x10000064
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8270: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8274: 0x10a2fffc
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1c8268;
    }
    // 0x1c827c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c8294;
    }
    // 0x1c8284: 0x10a00007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1c82a4;
    }
    // 0x1c828c: 0x1000005d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8404; return;
    }
label_1c8294:
    // 0x1c8294: 0x10a20006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1c82b0;
    }
    // 0x1c829c: 0x10000059
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8404; return;
    }
label_1c82a4:
    // 0x1c82a4: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c82a8: 0x10000053
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83F8; return;
    }
label_1c82b0:
    // 0x1c82b0: 0x24c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
label_1c82b4:
    // 0x1c82b4: 0xc6010bf8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3064)); ctx->f[1] = *(float*)&val; }
    // 0x1c82b8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c82bc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c82c0: 0x0
    // NOP
    // 0x1c82c4: 0x4500004e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C8400; return;
    }
label_1c82cc:
    // 0x1c82cc: 0x1000004b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c82d4: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c82d8: 0x10000048
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c82e0: 0x4a00046
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_S32(ctx, 5) < 0) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c82e8: 0x14400039
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83D0; return;
    }
    // 0x1c82f0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c82f4: 0x14a20042
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c82fc: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c8300: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1996)));
        goto label_1c8310;
    }
    // 0x1c8308: 0x1000003c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
label_1c8310:
    // 0x1c8310: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8330; return;
    }
    // 0x1c8318: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c831c: 0x8c620184
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 388)));
    // 0x1c8320: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c8328);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c8328
// Address: 0x1c8328 - 0x1c8338

void entry_1c8328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8328) {
        switch (ctx->pc) {
            case 0x1c8330: ctx->pc = 0; goto label_1c8330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8328: 0x54400034
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 14));
        ctx->pc = 0x1C83FC; return;
    }
label_1c8330:
    // 0x1c8330: 0xc072130
    SET_GPR_U32(ctx, 31, 0x1c8338);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FReachedStepguardGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c8338
// Address: 0x1c8338 - 0x1c8384

void entry_1c8338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8338: 0x10400030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8340: 0x8e0307c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1988)));
    // 0x1c8344: 0x1000002d
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c834c: 0x4a0002b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_S32(ctx, 5) < 0) {
        ctx->pc = 0x1C83FC; return;
    }
    // 0x1c8354: 0x1440001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C83D0; return;
    }
    // 0x1c835c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c8360: 0x14a20027
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C8400; return;
    }
    // 0x1c8368: 0x8e0207cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1996)));
    // 0x1c836c: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2656)));
        ctx->pc = 0x1C8394; return;
    }
    // 0x1c8374: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c8378: 0x8c620184
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 388)));
    // 0x1c837c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c8384);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c8384
// Address: 0x1c8384 - 0x1c8418

void entry_1c8384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8384) {
        switch (ctx->pc) {
            case 0x1c8394: ctx->pc = 0; goto label_1c8394;
            case 0x1c83d0: ctx->pc = 0; goto label_1c83d0;
            case 0x1c83f0: ctx->pc = 0; goto label_1c83f0;
            case 0x1c83f8: ctx->pc = 0; goto label_1c83f8;
            case 0x1c83fc: ctx->pc = 0; goto label_1c83fc;
            case 0x1c8400: ctx->pc = 0; goto label_1c8400;
            case 0x1c8404: ctx->pc = 0; goto label_1c8404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8384: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2656)));
        goto label_1c8394;
    }
    // 0x1c838c: 0x1000001b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c83fc;
    }
label_1c8394:
    // 0x1c8394: 0x1440001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c8400;
    }
    // 0x1c839c: 0x8e0307bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1980)));
    // 0x1c83a0: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1c83a4: 0x10000015
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c83fc;
    }
    // 0x1c83ac: 0x4a00013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 2));
    if (GPR_S32(ctx, 5) < 0) {
        goto label_1c83fc;
    }
    // 0x1c83b4: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6232));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c83d0;
    }
    // 0x1c83bc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c83c0: 0x10a2000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1c83f0;
    }
    // 0x1c83c8: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8404;
    }
label_1c83d0:
    // 0x1c83d0: 0xc6010c00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3072)); ctx->f[1] = *(float*)&val; }
    // 0x1c83d4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c83d8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c83dc: 0x0
    // NOP
    // 0x1c83e0: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 8));
        goto label_1c83fc;
    }
    // 0x1c83e8: 0x10000005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8400;
    }
label_1c83f0:
    // 0x1c83f0: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c83f4: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
label_1c83f8:
    // 0x1c83f8: 0x43880a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
label_1c83fc:
    // 0x1c83fc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1c8400:
    // 0x1c8400: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1c8404:
    // 0x1c8404: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8408: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c840c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c8410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepguardGoal__FP9STEPGUARDP6VECTOR
// Address: 0x1c8418 - 0x1c8448

void entry_1c8448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8448) {
        switch (ctx->pc) {
            case 0x1c8494: ctx->pc = 0; goto label_1c8494;
            case 0x1c849c: ctx->pc = 0; goto label_1c849c;
            case 0x1c84a8: ctx->pc = 0; goto label_1c84a8;
            case 0x1c84b4: ctx->pc = 0; goto label_1c84b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8448: 0x8e020a60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2656)));
    // 0x1c844c: 0x10400016
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c84a8;
    }
    // 0x1c8454: 0xda010a50
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 2640)));
    // 0x1c8458: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c845c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8460: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8464: 0xc4414c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19600)); ctx->f[1] = *(float*)&val; }
    // 0x1c8468: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c846c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8470: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8474: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c8478: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c847c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8480: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c8484: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8488: 0x0
    // NOP
    // 0x1c848c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1c8494;
    }
label_1c8494:
    // 0x1c8494: 0x54600001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2656), GPR_U32(ctx, 0));
        goto label_1c849c;
    }
label_1c849c:
    // 0x1c849c: 0x8e020a60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2656)));
    // 0x1c84a0: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c84b4;
    }
label_1c84a8:
    // 0x1c84a8: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c84ac: 0x7e020a50
    WRITE128(ADD32(GPR_U32(ctx, 16), 2640), GPR_VEC(ctx, 2));
    // 0x1c84b0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c84b4:
    // 0x1c84b4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c84b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FReachedStepguardGoal__FP9STEPGUARD
// Address: 0x1c84c0 - 0x1c84e8

void entry_1c8548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8548: 0x1440000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C857C; return;
    }
    // 0x1c8550: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1c8554: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1c855c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1c855c
// Address: 0x1c855c - 0x1c8570

void entry_1c855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c855c: 0x14400007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C857C; return;
    }
    // 0x1c8564: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1c8568: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1c8570);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1c8570
// Address: 0x1c8570 - 0x1c8590

void entry_1c8570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8570) {
        switch (ctx->pc) {
            case 0x1c857c: ctx->pc = 0; goto label_1c857c;
            case 0x1c8580: ctx->pc = 0; goto label_1c8580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8570: 0x14400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c857c;
    }
    // 0x1c8578: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c857c:
    // 0x1c857c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1c8580:
    // 0x1c8580: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c8584: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c858c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8590; return;
}


// Function: MoveStepguardToGoal__FP9STEPGUARD
// Address: 0x1c8590 - 0x1c86a0

void entry_1c86a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c86a0) {
        switch (ctx->pc) {
            case 0x1c86a8: ctx->pc = 0; goto label_1c86a8;
            case 0x1c86b0: ctx->pc = 0; goto label_1c86b0;
            case 0x1c86e8: ctx->pc = 0; goto label_1c86e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c86a0: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c86b0;
    }
label_1c86a8:
    // 0x1c86a8: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c86ac: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
label_1c86b0:
    // 0x1c86b0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1c86b4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c86b8: 0x4614a829
    ctx->f[0] = std::min(ctx->f[21], ctx->f[20]);
    // 0x1c86bc: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c86c0: 0x46010582
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c86c4: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1c86c8: 0x3c160025
    SET_GPR_U32(ctx, 22, ((uint32_t)37 << 16));
    // 0x1c86cc: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1c86d0: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1c86d4: 0x3c17001d
    SET_GPR_U32(ctx, 23, ((uint32_t)29 << 16));
    // 0x1c86d8: 0x27b300d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1c86dc: 0x27b400d4
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 212));
    // 0x1c86e0: 0x10000016
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c873c(rdram, ctx, runtime); return;
    }
label_1c86e8:
    // 0x1c86e8: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1c86ec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c86f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c86f4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1c86f8: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1c86fc: 0x4601a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[1]);
    // 0x1c8700: 0xda030a50
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 2640)));
    // 0x1c8704: 0x8e040928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x1c8708: 0x46140d69
    ctx->f[21] = std::min(ctx->f[1], ctx->f[20]);
    // 0x1c870c: 0x4614a803
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[20];
    // 0x1c8710: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1c8714: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1c8718: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c871c: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1c8720: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c8724: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c8728: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c872c: 0x4be12088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c8730: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8734: 0xc0646a2
    SET_GPR_U32(ctx, 31, 0x1c873c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    FindPathzoneClosestPoint__FP8PATHZONEP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1c873c
// Address: 0x1c873c - 0x1c8788

void entry_1c873c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c873c) {
        switch (ctx->pc) {
            case 0x1c8778: ctx->pc = 0; goto label_1c8778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c873c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8740: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8744: 0xda040140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c8748: 0x4be4086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c874c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8750: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8754: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8758: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c875c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c8760: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8764: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c8768: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c876c: 0x0
    // NOP
    // 0x1c8770: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1c8778;
    }
label_1c8778:
    // 0x1c8778: 0x1440ffdb
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C86E8; return;
    }
    // 0x1c8780: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1c8788);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4294937888));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c8788
// Address: 0x1c8788 - 0x1c87f4

void entry_1c8788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8788: 0x3c01c3fa
    SET_GPR_U32(ctx, 1, ((uint32_t)50170 << 16));
    // 0x1c878c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c8790: 0x26e884e8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 23), 4294935784));
    // 0x1c8794: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1c8798: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c879c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c87a0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c87a4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c87a8: 0xdac20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1c87ac: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c87b0: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c87b4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c87b8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1c87bc: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c87c0: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c87c4: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c87c8: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c87cc: 0x4be51108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c87d0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1c87d4: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c87d8: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c87dc: 0x260502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1c87e0: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1c87e4: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c87e8: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1c87ec: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1c87f4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1c87f4
// Address: 0x1c87f4 - 0x1c8810

void entry_1c87f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c87f4: 0x8fa700d0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1c87f8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c87fc: 0x8fa800d4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 212)));
    // 0x1c8800: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c8804: 0x2a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1c8808: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1c8810);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1c8810
// Address: 0x1c8810 - 0x1c8874

void entry_1c8810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8810) {
        switch (ctx->pc) {
            case 0x1c884c: ctx->pc = 0; goto label_1c884c;
            case 0x1c886c: ctx->pc = 0; goto label_1c886c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8810: 0x10400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c886c;
    }
    // 0x1c8818: 0x8e0206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1744)));
    // 0x1c881c: 0x8e030388
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 904)));
    // 0x1c8820: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1c8824: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c8828: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c882c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c8830: 0x8e040c04
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3076)));
    // 0x1c8834: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1c8838: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1c883c: 0x10800003
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1c884c;
    }
    // 0x1c8844: 0xc60006cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1740)); ctx->f[0] = *(float*)&val; }
    // 0x1c8848: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_1c884c:
    // 0x1c884c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c8850: 0xdac20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1c8854: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c8858: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c885c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c8860: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c8864: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c8868: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c886c:
    // 0x1c886c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1c8874);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c8874
// Address: 0x1c8874 - 0x1c88a0

void entry_1c8874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8874) {
        switch (ctx->pc) {
            case 0x1c8880: ctx->pc = 0; goto label_1c8880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8874: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8878: 0x10000013
    WRITE128(ADD32(GPR_U32(ctx, 16), 2384), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C88C8; return;
    }
label_1c8880:
    // 0x1c8880: 0x8e040928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x1c8884: 0x10800007
    WRITE32(ADD32(GPR_U32(ctx, 16), 2348), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C88A4; return;
    }
    // 0x1c888c: 0x26050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1c8890: 0x26060a50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 2640));
    // 0x1c8894: 0x24070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1c8898: 0xc06469a
    SET_GPR_U32(ctx, 31, 0x1c88a0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 2368));
    CposFindPathzonePath__FP8PATHZONEP6VECTORT1iT1(rdram, ctx, runtime); return;
}


// Function: entry_1c88a0
// Address: 0x1c88a0 - 0x1c8920

void entry_1c88a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c88a0) {
        switch (ctx->pc) {
            case 0x1c88a4: ctx->pc = 0; goto label_1c88a4;
            case 0x1c88c8: ctx->pc = 0; goto label_1c88c8;
            case 0x1c88cc: ctx->pc = 0; goto label_1c88cc;
            case 0x1c88e4: ctx->pc = 0; goto label_1c88e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c88a0: 0xae02092c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2348), GPR_U32(ctx, 2));
label_1c88a4:
    // 0x1c88a4: 0x8e02092c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2348)));
    // 0x1c88a8: 0x14400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c88cc;
    }
    // 0x1c88b0: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c88b4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c88b8: 0x7a030a50
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 2640)));
    // 0x1c88bc: 0xae04092c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2348), GPR_U32(ctx, 4));
    // 0x1c88c0: 0x7e020940
    WRITE128(ADD32(GPR_U32(ctx, 16), 2368), GPR_VEC(ctx, 2));
    // 0x1c88c4: 0x7e030950
    WRITE128(ADD32(GPR_U32(ctx, 16), 2384), GPR_VEC(ctx, 3));
label_1c88c8:
    // 0x1c88c8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c88cc:
    // 0x1c88cc: 0xae000930
    WRITE32(ADD32(GPR_U32(ctx, 16), 2352), GPR_U32(ctx, 0));
    // 0x1c88d0: 0xae020a60
    WRITE32(ADD32(GPR_U32(ctx, 16), 2656), GPR_U32(ctx, 2));
    // 0x1c88d4: 0x27c31858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1c88d8: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c88dc: 0xe6000a64
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2660), *(uint32_t*)&val); }
    // 0x1c88e0: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
label_1c88e4:
    // 0x1c88e4: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1c88e8: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1c88ec: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1c88f0: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1c88f4: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1c88f8: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1c88fc: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1c8900: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1c8904: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1c8908: 0xc7b60190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[22] = *(float*)&val; }
    // 0x1c890c: 0xc7b50188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[21] = *(float*)&val; }
    // 0x1c8910: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x1c8914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c891c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8920; return;
}


// Function: FUN_001c8920
// Address: 0x1c8920 - 0x1c8940

void FUN_001c8920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8920: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1c8924: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1c8928: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1c892c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c8930: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c8934: 0x8c62018c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 396)));
    // 0x1c8938: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c8940);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c8940
// Address: 0x1c8940 - 0x1c8a3c

void entry_1c8940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8940) {
        switch (ctx->pc) {
            case 0x1c8960: ctx->pc = 0; goto label_1c8960;
            case 0x1c89a4: ctx->pc = 0; goto label_1c89a4;
            case 0x1c89b8: ctx->pc = 0; goto label_1c89b8;
            case 0x1c89dc: ctx->pc = 0; goto label_1c89dc;
            case 0x1c89f4: ctx->pc = 0; goto label_1c89f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8940: 0x8e03092c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2348)));
    // 0x1c8944: 0x8e020930
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2352)));
    // 0x1c8948: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1c894c: 0x10400023
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c89dc;
    }
    // 0x1c8954: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c8958: 0xc4414c94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19604)); ctx->f[1] = *(float*)&val; }
    // 0x1c895c: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1c8960:
    // 0x1c8960: 0x8e030930
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2352)));
    // 0x1c8964: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c8968: 0x31100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1c896c: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1c8970: 0xd8410940
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 2368)));
    // 0x1c8974: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c8978: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c897c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8980: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8984: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c8988: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c898c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8990: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c8994: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8998: 0x0
    // NOP
    // 0x1c899c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1c89a4;
    }
label_1c89a4:
    // 0x1c89a4: 0x14800004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1c89b8;
    }
    // 0x1c89ac: 0x45182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x1c89b0: 0x1460ffeb
    WRITE32(ADD32(GPR_U32(ctx, 16), 2352), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c8960;
    }
label_1c89b8:
    // 0x1c89b8: 0x8e030930
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2352)));
    // 0x1c89bc: 0x8e02092c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2348)));
    // 0x1c89c0: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1c89c4: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c89dc;
    }
    // 0x1c89cc: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c89d0: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1c89d4: 0x10000007
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 2368)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c89f4;
    }
label_1c89dc:
    // 0x1c89dc: 0x8e02092c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2348)));
    // 0x1c89e0: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1c89e4: 0x501821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1c89e8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1c89ec: 0xd8620920
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 2336)));
    // 0x1c89f0: 0xd8410930
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 2352)));
label_1c89f4:
    // 0x1c89f4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c89f8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c89fc: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c8a00: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a04: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a08: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c8a0c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c8a10: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a14: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c8a18: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c8a1c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8a20: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1c8a24: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8a28: 0x0
    // NOP
    // 0x1c8a2c: 0x45000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C8A44; return;
    }
    // 0x1c8a34: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c8a3c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c8a3c
// Address: 0x1c8a3c - 0x1c8bac

void entry_1c8a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8a3c) {
        switch (ctx->pc) {
            case 0x1c8a44: ctx->pc = 0; goto label_1c8a44;
            case 0x1c8a48: ctx->pc = 0; goto label_1c8a48;
            case 0x1c8a60: ctx->pc = 0; goto label_1c8a60;
            case 0x1c8ac4: ctx->pc = 0; goto label_1c8ac4;
            case 0x1c8b0c: ctx->pc = 0; goto label_1c8b0c;
            case 0x1c8b20: ctx->pc = 0; goto label_1c8b20;
            case 0x1c8b6c: ctx->pc = 0; goto label_1c8b6c;
            case 0x1c8b80: ctx->pc = 0; goto label_1c8b80;
            case 0x1c8ba4: ctx->pc = 0; goto label_1c8ba4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8a3c: 0x10000002
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8a48;
    }
label_1c8a44:
    // 0x1c8a44: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
label_1c8a48:
    // 0x1c8a48: 0x8e020b1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2844)));
    // 0x1c8a4c: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 2640)));
        goto label_1c8a60;
    }
    // 0x1c8a54: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1c8a58: 0x10000052
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8ba4;
    }
label_1c8a60:
    // 0x1c8a60: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c8a64: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a68: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c8a6c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a70: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a74: 0xc6010a58
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2648)); ctx->f[1] = *(float*)&val; }
    // 0x1c8a78: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c8a7c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c8a80: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c8a84: 0xc6000148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[0] = *(float*)&val; }
    // 0x1c8a88: 0x2443fffb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967291));
    // 0x1c8a8c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c8a90: 0x2c62000b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 11));
    // 0x1c8a94: 0x44842800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 4);
    // 0x1c8a98: 0x1040000a
    ctx->f[7] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c8ac4;
    }
    // 0x1c8aa0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c8aa4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c8aa8: 0x2442d6b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956720));
    // 0x1c8aac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c8ab0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c8ab4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c8abc: 0xc6000b20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2848)); ctx->f[0] = *(float*)&val; }
    // 0x1c8ac0: 0x460039c0
    ctx->f[7] = FPU_ADD_S(ctx->f[7], ctx->f[0]);
label_1c8ac4:
    // 0x1c8ac4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c8ac8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1c8acc: 0x24434ca0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19616));
    // 0x1c8ad0: 0xc4424ca0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19616)); ctx->f[2] = *(float*)&val; }
    // 0x1c8ad4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c8ad8: 0x24824cb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 19632));
    // 0x1c8adc: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c8ae0: 0x46012842
    ctx->f[1] = FPU_MUL_S(ctx->f[5], ctx->f[1]);
    // 0x1c8ae4: 0xc4834cb0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 19632)); ctx->f[3] = *(float*)&val; }
    // 0x1c8ae8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c8aec: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1c8af0: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1c8af4: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8af8: 0x0
    // NOP
    // 0x1c8afc: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8b0c;
    }
    // 0x1c8b04: 0x10000006
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8b20;
    }
label_1c8b0c:
    // 0x1c8b0c: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8b10: 0x0
    // NOP
    // 0x1c8b14: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8b20;
    }
    // 0x1c8b1c: 0x46002186
    ctx->f[6] = FPU_MOV_S(ctx->f[4]);
label_1c8b20:
    // 0x1c8b20: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c8b24: 0x46003885
    ctx->f[2] = FPU_ABS_S(ctx->f[7]);
    // 0x1c8b28: 0x24434cc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19648));
    // 0x1c8b2c: 0xc4434cc0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19648)); ctx->f[3] = *(float*)&val; }
    // 0x1c8b30: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1c8b34: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c8b38: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1c8b3c: 0x24444cd0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 19664));
    // 0x1c8b40: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1c8b44: 0xc4444cd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19664)); ctx->f[4] = *(float*)&val; }
    // 0x1c8b48: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1c8b4c: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1c8b50: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1c8b54: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8b58: 0x0
    // NOP
    // 0x1c8b5c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8b6c;
    }
    // 0x1c8b64: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8b80;
    }
label_1c8b6c:
    // 0x1c8b6c: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8b70: 0x0
    // NOP
    // 0x1c8b74: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8b80;
    }
    // 0x1c8b7c: 0x46002806
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
label_1c8b80:
    // 0x1c8b80: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1c8b84: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c8b88: 0x46003042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x1c8b8c: 0xc4404cd8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19672)); ctx->f[0] = *(float*)&val; }
    // 0x1c8b90: 0x46023834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[7], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c8b94: 0x0
    // NOP
    // 0x1c8b98: 0x45000002
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c8ba4;
    }
    // 0x1c8ba0: 0x46006b47
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
label_1c8ba4:
    // 0x1c8ba4: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c8bac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c8bac
// Address: 0x1c8bac - 0x1c8bc0

void entry_1c8bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8bac: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8bb0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8bb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c8bbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8bc0; return;
}


// Function: LookStepguardAtGoal__FP9STEPGUARD
// Address: 0x1c8bc0 - 0x1c8be8

void entry_1c8be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8be8: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1c8bec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8bf0: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c8bf8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c8bf8
// Address: 0x1c8bf8 - 0x1c8c08

void entry_1c8bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8bf8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8bfc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8c00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateStepguardGoal__FP9STEPGUARDi
// Address: 0x1c8c08 - 0x1c8c54

void entry_1c8c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8c54: 0x10400036
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c8d30(rdram, ctx, runtime); return;
    }
    // 0x1c8c5c: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1c8c64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c8c64
// Address: 0x1c8c64 - 0x1c8cb8

void entry_1c8c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8c64) {
        switch (ctx->pc) {
            case 0x1c8c9c: ctx->pc = 0; goto label_1c8c9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8c64: 0x10000033
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8D34; return;
    }
    // 0x1c8c6c: 0x10a00031
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8D34; return;
    }
    // 0x1c8c74: 0x8e040750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
    // 0x1c8c78: 0x50800023
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 400)));
        ctx->pc = 0x1C8D08; return;
    }
    // 0x1c8c80: 0x8e030920
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2336)));
    // 0x1c8c84: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c8c9c;
    }
    // 0x1c8c8c: 0x5062000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2328)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1C8CC0; return;
    }
    // 0x1c8c94: 0x10000018
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c8cf8(rdram, ctx, runtime); return;
    }
label_1c8c9c:
    // 0x1c8c9c: 0xc60c0918
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2328)); ctx->f[12] = *(float*)&val; }
    // 0x1c8ca0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8ca4: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1c8ca8: 0x26070914
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 2324));
    // 0x1c8cac: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c8cb0: 0xc04b27a
    SET_GPR_U32(ctx, 31, 0x1c8cb8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FindAsegClosestPoint__FP4ASEGP3ALOP6VECTORfPfT2T2(rdram, ctx, runtime); return;
}


// Function: entry_1c8cb8
// Address: 0x1c8cb8 - 0x1c8ccc

void entry_1c8cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8cb8) {
        switch (ctx->pc) {
            case 0x1c8cc0: ctx->pc = 0; goto label_1c8cc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8cb8: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1c8cf8(rdram, ctx, runtime); return;
    }
label_1c8cc0:
    // 0x1c8cc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8cc4: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x1c8ccc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2324), *(uint32_t*)&val); }
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c8ccc
// Address: 0x1c8ccc - 0x1c8cf8

void entry_1c8ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8ccc: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1c8cd0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8cd4: 0xc60c0914
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2324)); ctx->f[12] = *(float*)&val; }
    // 0x1c8cd8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c8cdc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c8ce0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c8ce4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c8ce8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c8cec: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c8cf0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c8cf8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c8cf8
// Address: 0x1c8cf8 - 0x1c8d18

void entry_1c8cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8cf8) {
        switch (ctx->pc) {
            case 0x1c8d08: ctx->pc = 0; goto label_1c8d08;
            case 0x1c8d0c: ctx->pc = 0; goto label_1c8d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8cf8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c8cfc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c8d00: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2332), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c8d0c;
    }
label_1c8d08:
    // 0x1c8d08: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_1c8d0c:
    // 0x1c8d0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8d10: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1c8d18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c8d18
// Address: 0x1c8d18 - 0x1c8d30

void entry_1c8d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8d18: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8D34; return;
    }
    // 0x1c8d20: 0x10a00003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1c8d30(rdram, ctx, runtime); return;
    }
    // 0x1c8d28: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1c8d30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 2304));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1c8d30
// Address: 0x1c8d30 - 0x1c8d40

void entry_1c8d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8d30) {
        switch (ctx->pc) {
            case 0x1c8d34: ctx->pc = 0; goto label_1c8d34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8d30: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c8d34:
    // 0x1c8d34: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8d38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001c8d40
// Address: 0x1c8d40 - 0x1c8d78

void FUN_001c8d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8d40) {
        switch (ctx->pc) {
            case 0x1c8d6c: ctx->pc = 0; goto label_1c8d6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8d40: 0x8c820a60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 2656)));
    // 0x1c8d44: 0x10400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c8d6c;
    }
    // 0x1c8d4c: 0x8c82092c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 2348)));
    // 0x1c8d50: 0x8c830930
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 2352)));
    // 0x1c8d54: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x1c8d58: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1c8d5c: 0x14600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1c8d6c;
    }
    // 0x1c8d64: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1c8d6c:
    // 0x1c8d6c: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c8d74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8d78; return;
}


// Function: OnStepguardWaypointActive__FP9STEPGUARD
// Address: 0x1c8d78 - 0x1c8dc8

void entry_1c8dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8dc8: 0x8e050a74
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
    // 0x1c8dcc: 0xc04be04
    SET_GPR_U32(ctx, 31, 0x1c8dd4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    SubscribeAsegaObject__FP5ASEGAP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c8dd4
// Address: 0x1c8dd4 - 0x1c8ddc

void entry_1c8dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8dd4: 0xc060d16
    SET_GPR_U32(ctx, 31, 0x1c8ddc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OidProxyLoPreferred__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c8ddc
// Address: 0x1c8ddc - 0x1c8de8

void entry_1c8ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8ddc: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c8de0: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x1c8de8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c8de8
// Address: 0x1c8de8 - 0x1c8e28

void entry_1c8de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8de8) {
        switch (ctx->pc) {
            case 0x1c8e04: ctx->pc = 0; goto label_1c8e04;
            case 0x1c8e14: ctx->pc = 0; goto label_1c8e14;
            case 0x1c8e18: ctx->pc = 0; goto label_1c8e18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8de8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c8dec: 0x8e0201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 492)));
    // 0x1c8df0: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
        goto label_1c8e04;
    }
    // 0x1c8df8: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1c8dfc: 0xa0620010
    WRITE8(ADD32(GPR_U32(ctx, 3), 16), (uint8_t)GPR_U32(ctx, 2));
    // 0x1c8e00: 0x8e0201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
label_1c8e04:
    // 0x1c8e04: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1c8e18;
    }
    // 0x1c8e0c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1c8e10: 0xa0620011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 2));
label_1c8e14:
    // 0x1c8e14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c8e18:
    // 0x1c8e18: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8e1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c8e24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8e28; return;
}


// Function: UpdateStepguardSgs__FP9STEPGUARD
// Address: 0x1c8e28 - 0x1c8e48

void entry_1c8e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8e48: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c8e4c: 0x2c620011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
    // 0x1c8e50: 0x1040002e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c8f0c(rdram, ctx, runtime); return;
    }
    // 0x1c8e58: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c8e5c: 0x2442d710
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956816));
    // 0x1c8e60: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c8e64: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c8e68: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c8e70: 0xc04a08c
    SET_GPR_U32(ctx, 31, 0x1c8e78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FDrivenAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c8e78
// Address: 0x1c8e78 - 0x1c8e88

void entry_1c8e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8e78: 0x10400025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8F10; return;
    }
    // 0x1c8e80: 0xc071efa
    SET_GPR_U32(ctx, 31, 0x1c8e88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardDrive__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c8e88
// Address: 0x1c8e88 - 0x1c8ed0

void entry_1c8e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8e88: 0x10000021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8F10; return;
    }
    // 0x1c8e90: 0x8e020754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c8e94: 0x10400012
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c8ee0(rdram, ctx, runtime); return;
    }
    // 0x1c8e9c: 0x8e020b1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2844)));
    // 0x1c8ea0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c8ea4: 0x27a80004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 4));
    // 0x1c8ea8: 0xc60d0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[13] = *(float*)&val; }
    // 0x1c8eac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8eb0: 0xc46c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1c8eb4: 0x2400a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 0));
    // 0x1c8eb8: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1c8ebc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c8ec0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c8ec4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c8ec8: 0xc04a166
    SET_GPR_U32(ctx, 31, 0x1c8ed0);
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 29), 8));
    CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25(rdram, ctx, runtime); return;
}


// Function: entry_1c8ed0
// Address: 0x1c8ed0 - 0x1c8ee0

void entry_1c8ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8ed0: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1c8ed4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8ed8: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c8ee0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c8ee0
// Address: 0x1c8ee0 - 0x1c8eec

void entry_1c8ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8ee0: 0x8e020a74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
    // 0x1c8ee4: 0xc07bf26
    SET_GPR_U32(ctx, 31, 0x1c8eec);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 808)));
    EnsureWpsgCallback__FP4WPSG(rdram, ctx, runtime); return;
}


// Function: entry_1c8eec
// Address: 0x1c8eec - 0x1c8efc

void entry_1c8eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8eec: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8F10; return;
    }
    // 0x1c8ef4: 0xc072248
    SET_GPR_U32(ctx, 31, 0x1c8efc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001c8920(rdram, ctx, runtime); return;
}


// Function: entry_1c8efc
// Address: 0x1c8efc - 0x1c8f0c

void entry_1c8efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8efc: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C8F10; return;
    }
    // 0x1c8f04: 0xc0722f0
    SET_GPR_U32(ctx, 31, 0x1c8f0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LookStepguardAtGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c8f0c
// Address: 0x1c8f0c - 0x1c8f20

void entry_1c8f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c8f0c) {
        switch (ctx->pc) {
            case 0x1c8f10: ctx->pc = 0; goto label_1c8f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c8f0c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1c8f10:
    // 0x1c8f10: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8f14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c8f1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c8f20; return;
}


// Function: SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG
// Address: 0x1c8f20 - 0x1c8f6c

void entry_1c8f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8f6c: 0xae110724
    WRITE32(ADD32(GPR_U32(ctx, 16), 1828), GPR_U32(ctx, 17));
    // 0x1c8f70: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c8f74: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c8f78: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c8f7c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1c8f80: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c8f84: 0xe6000728
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1832), *(uint32_t*)&val); }
    // 0x1c8f88: 0x8c620180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 384)));
    // 0x1c8f8c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c8f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c8f94
// Address: 0x1c8f94 - 0x1c8fb8

void entry_1c8f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8f94: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c8f98: 0x26020724
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1828));
    // 0x1c8f9c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1c8fa0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c8fa4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c8fa8: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x1c8fac: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c8fb0: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1c8fb8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1c8fb8
// Address: 0x1c8fb8 - 0x1c8fd0

void entry_1c8fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8fb8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c8fbc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c8fc0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c8fc4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c8fc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepguardSgsExternal__FP9STEPGUARD3SGSP4ASEG
// Address: 0x1c8fd0 - 0x1c8ffc

void entry_1c8ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c8ffc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c9000: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnStepguardExitingSgs__FP9STEPGUARD3SGS
// Address: 0x1c9008 - 0x1c907c

void entry_1c907c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c907c) {
        switch (ctx->pc) {
            case 0x1c908c: ctx->pc = 0; goto label_1c908c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c907c: 0x8e020a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2680)));
    // 0x1c9080: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1c9084: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1C9068; return;
    }
label_1c908c:
    // 0x1c908c: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c9090: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c9094: 0x2c830010
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 16));
    // 0x1c9098: 0x10600039
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c90a0: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c90a4: 0x2442d760
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956896));
    // 0x1c90a8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c90ac: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c90b0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c90b8: 0x8e030754
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c90bc: 0x10600030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c90c4: 0x1262002e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c90cc: 0xc4610014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1c90d0: 0xe6010918
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 2328), *(uint32_t*)&val); }
    // 0x1c90d4: 0xc4600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1c90d8: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c90e0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2332), *(uint32_t*)&val); }
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c90e0
// Address: 0x1c90e0 - 0x1c90fc

void entry_1c90e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c90e0: 0x10000027
    WRITE32(ADD32(GPR_U32(ctx, 16), 1876), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c90e8: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c90ec: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
        ctx->pc = 0x1C9104; return;
    }
    // 0x1c90f4: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c90fc);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c90fc
// Address: 0x1c90fc - 0x1c9114

void entry_1c90fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c90fc) {
        switch (ctx->pc) {
            case 0x1c9104: ctx->pc = 0; goto label_1c9104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c90fc: 0xae000754
    WRITE32(ADD32(GPR_U32(ctx, 16), 1876), GPR_U32(ctx, 0));
    // 0x1c9100: 0x8e040a74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
label_1c9104:
    // 0x1c9104: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c9108: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1c910c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9114);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9114
// Address: 0x1c9114 - 0x1c9120

void entry_1c9114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9114: 0x8e040a74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
    // 0x1c9118: 0xc07be40
    SET_GPR_U32(ctx, 31, 0x1c9120);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWaypointWps__FP8WAYPOINT3WPS(rdram, ctx, runtime); return;
}


// Function: entry_1c9120
// Address: 0x1c9120 - 0x1c9144

void entry_1c9120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9120: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c9124: 0x16620016
    WRITE32(ADD32(GPR_U32(ctx, 16), 2676), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c912c: 0xc6000918
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2328)); ctx->f[0] = *(float*)&val; }
    // 0x1c9130: 0x10000013
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2324), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c9138: 0xc60c0740
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1856)); ctx->f[12] = *(float*)&val; }
    // 0x1c913c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1c9144);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1860)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c9144
// Address: 0x1c9144 - 0x1c916c

void entry_1c9144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9144: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1c9148: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1c914c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1c9150: 0x1000000b
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1864), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9180; return;
    }
    // 0x1c9158: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c915c: 0xae130724
    WRITE32(ADD32(GPR_U32(ctx, 16), 1828), GPR_U32(ctx, 19));
    // 0x1c9160: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1c9164: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1c916c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1c916c
// Address: 0x1c916c - 0x1c9194

void entry_1c916c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c916c) {
        switch (ctx->pc) {
            case 0x1c9180: ctx->pc = 0; goto label_1c9180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c916c: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9180;
    }
    // 0x1c9174: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9178: 0xc440d754
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956884)); ctx->f[0] = *(float*)&val; }
    // 0x1c917c: 0xe6000c00
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3072), *(uint32_t*)&val); }
label_1c9180:
    // 0x1c9180: 0x8e0407e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c9184: 0x10800009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C91AC; return;
    }
    // 0x1c918c: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x1c9194);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c9194
// Address: 0x1c9194 - 0x1c91c8

void entry_1c9194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9194) {
        switch (ctx->pc) {
            case 0x1c91ac: ctx->pc = 0; goto label_1c91ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9194: 0x8e02072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1836)));
    // 0x1c9198: 0x2403fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1c919c: 0xae0007e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 2016), GPR_U32(ctx, 0));
    // 0x1c91a0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c91a4: 0xae02072c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1836), GPR_U32(ctx, 2));
    // 0x1c91a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1c91ac:
    // 0x1c91ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c91b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c91b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c91b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c91bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c91c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c91c8; return;
}


// Function: OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG
// Address: 0x1c91c8 - 0x1c9230

void entry_1c9230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9230: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c9234: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9238: 0x8c620188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 392)));
    // 0x1c923c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9244);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9244
// Address: 0x1c9244 - 0x1c928c

void entry_1c9244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9244: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c9248: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1c924c: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x1c9250: 0x1040008e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c9258: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c925c: 0x2442d7b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956976));
    // 0x1c9260: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c9264: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9268: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c9270: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c9274: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 472)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1C9294; return;
    }
    // 0x1c927c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c9280: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1c9284: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x1c928c);
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_1c928c
// Address: 0x1c928c - 0x1c92a0

void entry_1c928c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c928c) {
        switch (ctx->pc) {
            case 0x1c9294: ctx->pc = 0; goto label_1c9294;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c928c: 0x1000007f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
label_1c9294:
    // 0x1c9294: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1c9298: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c92a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c92a0
// Address: 0x1c92a0 - 0x1c92c4

void entry_1c92a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c92a0: 0x1000007a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c92a8: 0x8e020a74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2676)));
    // 0x1c92ac: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c92b0: 0x8c4302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    // 0x1c92b4: 0x14640075
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c92bc: 0xc07235e
    SET_GPR_U32(ctx, 31, 0x1c92c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnStepguardWaypointActive__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c92c4
// Address: 0x1c92c4 - 0x1c92f4

void entry_1c92c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c92c4: 0x10000071
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c92cc: 0x8e040750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
    // 0x1c92d0: 0x1080006e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c92d8: 0x1262006c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c92e0: 0xc60c0914
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2324)); ctx->f[12] = *(float*)&val; }
    // 0x1c92e4: 0xc60d091c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2332)); ctx->f[13] = *(float*)&val; }
    // 0x1c92e8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c92ec: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1c92f4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1876));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c92f4
// Address: 0x1c92f4 - 0x1c92fc

void entry_1c92f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c92f4: 0xc060d16
    SET_GPR_U32(ctx, 31, 0x1c92fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OidProxyLoPreferred__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1c92fc
// Address: 0x1c92fc - 0x1c9308

void entry_1c92fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c92fc: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1c9300: 0xc04b55c
    SET_GPR_U32(ctx, 31, 0x1c9308);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PactsegFindAsega__FP5ASEGA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1c9308
// Address: 0x1c9308 - 0x1c9348

void entry_1c9308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9308) {
        switch (ctx->pc) {
            case 0x1c9324: ctx->pc = 0; goto label_1c9324;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9308: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c930c: 0x8e0201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 492)));
    // 0x1c9310: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
        goto label_1c9324;
    }
    // 0x1c9318: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1c931c: 0xa0620010
    WRITE8(ADD32(GPR_U32(ctx, 3), 16), (uint8_t)GPR_U32(ctx, 2));
    // 0x1c9320: 0x8e0201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 496)));
label_1c9324:
    // 0x1c9324: 0x14620059
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c932c: 0x10000057
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c9334: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c9338: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c933c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9340: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1c9348);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 2912));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1c9348
// Address: 0x1c9348 - 0x1c9364

void entry_1c9348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9348: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1c934c: 0x8e060b58
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 2904)));
    // 0x1c9350: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1c9354: 0x8e070b70
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 2928)));
    // 0x1c9358: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c935c: 0xc054804
    SET_GPR_U32(ctx, 31, 0x1c9364);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyBreak(rdram, ctx, runtime); return;
}


// Function: entry_1c9364
// Address: 0x1c9364 - 0x1c9374

void entry_1c9364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9364: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1c9368: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c936c: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1c9374);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1c9374
// Address: 0x1c9374 - 0x1c9388

void entry_1c9374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9374: 0x8e020750
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
    // 0x1c9378: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2832)));
        ctx->pc = 0x1C93DC; return;
    }
    // 0x1c9380: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1c9388);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c9388
// Address: 0x1c9388 - 0x1c939c

void entry_1c9388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9388: 0x8e040750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
    // 0x1c938c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9390: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1c9394: 0xc04b46c
    SET_GPR_U32(ctx, 31, 0x1c939c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 20));
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_1c939c
// Address: 0x1c939c - 0x1c93c0

void entry_1c939c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c939c) {
        switch (ctx->pc) {
            case 0x1c93a8: ctx->pc = 0; goto label_1c93a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c939c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c93a0: 0x1840000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1C93D0; return;
    }
label_1c93a8:
    // 0x1c93a8: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1c93ac: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1c93b0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c93b4: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c93b8: 0xc07bea2
    SET_GPR_U32(ctx, 31, 0x1c93c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 808)));
    RemoveWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_1c93c0
// Address: 0x1c93c0 - 0x1c93d8

void entry_1c93c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c93c0) {
        switch (ctx->pc) {
            case 0x1c93d0: ctx->pc = 0; goto label_1c93d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c93c0: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c93c4: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1c93c8: 0x1440fff7
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C93A8; return;
    }
label_1c93d0:
    // 0x1c93d0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1c93d8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1c93d8
// Address: 0x1c93d8 - 0x1c93e4

void entry_1c93d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c93d8) {
        switch (ctx->pc) {
            case 0x1c93dc: ctx->pc = 0; goto label_1c93dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c93d8: 0x8e050b10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2832)));
label_1c93dc:
    // 0x1c93dc: 0xc050410
    SET_GPR_U32(ctx, 31, 0x1c93e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 5152));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1c93e4
// Address: 0x1c93e4 - 0x1c9400

void entry_1c93e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c93e4: 0x8e040b54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2900)));
    // 0x1c93e8: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3028)));
        ctx->pc = 0x1C9408; return;
    }
    // 0x1c93f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c93f4: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1c93f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9400);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9400
// Address: 0x1c9400 - 0x1c9428

void entry_1c9400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9400) {
        switch (ctx->pc) {
            case 0x1c9408: ctx->pc = 0; goto label_1c9408;
            case 0x1c9420: ctx->pc = 0; goto label_1c9420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9400: 0xae000b54
    WRITE32(ADD32(GPR_U32(ctx, 16), 2900), GPR_U32(ctx, 0));
    // 0x1c9404: 0x8e020bd4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3028)));
label_1c9408:
    // 0x1c9408: 0x10400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C942C; return;
    }
    // 0x1c9410: 0x12400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2672)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1c9420;
    }
    // 0x1c9418: 0xc6400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1c941c: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
label_1c9420:
    // 0x1c9420: 0xc049b58
    SET_GPR_U32(ctx, 31, 0x1c9428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FadeAloOut__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1c9428
// Address: 0x1c9428 - 0x1c9468

void entry_1c9428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9428) {
        switch (ctx->pc) {
            case 0x1c942c: ctx->pc = 0; goto label_1c942c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9428: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1c942c:
    // 0x1c942c: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c9434: 0x8e020a68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2664)));
    // 0x1c9438: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c943c: 0xae030c04
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 3));
    // 0x1c9440: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c9444: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 16), 2664), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C948C; return;
    }
    // 0x1c944c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9450: 0xc60c0910
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2320)); ctx->f[12] = *(float*)&val; }
    // 0x1c9454: 0xc440d7a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956960)); ctx->f[0] = *(float*)&val; }
    // 0x1c9458: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c945c: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1c9460: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c9468);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3060), *(uint32_t*)&val); }
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c9468
// Address: 0x1c9468 - 0x1c94d4

void entry_1c9468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9468) {
        switch (ctx->pc) {
            case 0x1c948c: ctx->pc = 0; goto label_1c948c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9468: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c948c;
    }
    // 0x1c9470: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9474: 0xc440d7a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956960)); ctx->f[0] = *(float*)&val; }
    // 0x1c9478: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3064), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c948c;
    }
    // 0x1c9480: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9484: 0xc440d7a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294956960)); ctx->f[0] = *(float*)&val; }
    // 0x1c9488: 0xe6000bfc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3068), *(uint32_t*)&val); }
label_1c948c:
    // 0x1c948c: 0x12400070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9650; return;
    }
    // 0x1c9494: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c9498: 0x54620012
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 16), 2152)));
        ctx->pc = 0x1C94E4; return;
    }
    // 0x1c94a0: 0x8e020b14
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2836)));
    // 0x1c94a4: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 16), 2152)));
        ctx->pc = 0x1C94E4; return;
    }
    // 0x1c94ac: 0xc6000b18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2840)); ctx->f[0] = *(float*)&val; }
    // 0x1c94b0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1c94b4: 0x46006036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c94b8: 0x0
    // NOP
    // 0x1c94bc: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C94D8; return;
    }
    // 0x1c94c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c94c8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c94cc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1c94d4);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1c94d4
// Address: 0x1c94d4 - 0x1c9618

void entry_1c94d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c94d4) {
        switch (ctx->pc) {
            case 0x1c94d8: ctx->pc = 0; goto label_1c94d8;
            case 0x1c94e4: ctx->pc = 0; goto label_1c94e4;
            case 0x1c94f8: ctx->pc = 0; goto label_1c94f8;
            case 0x1c9510: ctx->pc = 0; goto label_1c9510;
            case 0x1c9530: ctx->pc = 0; goto label_1c9530;
            case 0x1c9548: ctx->pc = 0; goto label_1c9548;
            case 0x1c9564: ctx->pc = 0; goto label_1c9564;
            case 0x1c9590: ctx->pc = 0; goto label_1c9590;
            case 0x1c95a8: ctx->pc = 0; goto label_1c95a8;
            case 0x1c95b4: ctx->pc = 0; goto label_1c95b4;
            case 0x1c95b8: ctx->pc = 0; goto label_1c95b8;
            case 0x1c95c4: ctx->pc = 0; goto label_1c95c4;
            case 0x1c95dc: ctx->pc = 0; goto label_1c95dc;
            case 0x1c95fc: ctx->pc = 0; goto label_1c95fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c94d4: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
label_1c94d8:
    // 0x1c94d8: 0x3a65000b
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 19), 11));
    // 0x1c94dc: 0x10000039
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 2016));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c95c4;
    }
label_1c94e4:
    // 0x1c94e4: 0x15800004
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 19), 11));
    if (GPR_U32(ctx, 12) != GPR_U32(ctx, 0)) {
        goto label_1c94f8;
    }
    // 0x1c94ec: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c94f0: 0x10000034
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 2016));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c95c4;
    }
label_1c94f8:
    // 0x1c94f8: 0x564c0005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 12)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2020)));
        goto label_1c9510;
    }
    // 0x1c9500: 0x3a65000b
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 19), 11));
    // 0x1c9504: 0xc601086c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2156)); ctx->f[1] = *(float*)&val; }
    // 0x1c9508: 0x1000002e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 2016));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c95c4;
    }
label_1c9510:
    // 0x1c9510: 0x3a65000b
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 19), 11));
    // 0x1c9514: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1c9518: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c951c: 0x18400029
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 2016));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1c95c4;
    }
    // 0x1c9524: 0x8d8d0008
    SET_GPR_U32(ctx, 13, READ32(ADD32(GPR_U32(ctx, 12), 8)));
    // 0x1c9528: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c952c: 0x260807e8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 2024));
label_1c9530:
    // 0x1c9530: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1c9534: 0x11a2000b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 13) == GPR_U32(ctx, 2)) {
        goto label_1c9564;
    }
    // 0x1c953c: 0x180502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    // 0x1c9540: 0x100202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1c9544: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_1c9548:
    // 0x1c9548: 0x2cc20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4));
    // 0x1c954c: 0x10400019
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c95b4;
    }
    // 0x1c9554: 0x8d430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 8)));
    // 0x1c9558: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c955c: 0x5462fffa
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
        goto label_1c9548;
    }
label_1c9564:
    // 0x1c9564: 0x2cc20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4));
    // 0x1c9568: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 1));
        goto label_1c95b8;
    }
    // 0x1c9570: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c9574: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1c9578: 0x1062000b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1c95a8;
    }
    // 0x1c9580: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1c9584: 0x100182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1c9588: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1c958c: 0x0
    // NOP
label_1c9590:
    // 0x1c9590: 0x2cc20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4));
    // 0x1c9594: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c95b4;
    }
    // 0x1c959c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c95a0: 0x5482fffb
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
        goto label_1c9590;
    }
label_1c95a8:
    // 0x1c95a8: 0x2cc20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4));
    // 0x1c95ac: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2156)); ctx->f[1] = *(float*)&val; }
        goto label_1c95c4;
    }
label_1c95b4:
    // 0x1c95b4: 0x256b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 1));
label_1c95b8:
    // 0x1c95b8: 0x169102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 11), GPR_S32(ctx, 9)));
    // 0x1c95bc: 0x1440ffdc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c9530;
    }
label_1c95c4:
    // 0x1c95c4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1c95c8: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c95cc: 0x0
    // NOP
    // 0x1c95d0: 0x45010002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1c95dc;
    }
    // 0x1c95d8: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
label_1c95dc:
    // 0x1c95dc: 0x34c20004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), 4));
    // 0x1c95e0: 0x8e040bec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3052)));
    // 0x1c95e4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c95e8: 0x10830004
    if (GPR_U32(ctx, 5) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1c95fc;
    }
    // 0x1c95f0: 0x8e020bf0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3056)));
    // 0x1c95f4: 0x5440000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1C9620; return;
    }
label_1c95fc:
    // 0x1c95fc: 0xc64c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1c9600: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c9604: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c9608: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c960c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9610: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x1c9618);
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c9618
// Address: 0x1c9618 - 0x1c9648

void entry_1c9618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9618) {
        switch (ctx->pc) {
            case 0x1c9620: ctx->pc = 0; goto label_1c9620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9618: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2152), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C964C; return;
    }
label_1c9620:
    // 0x1c9620: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1c9624: 0xe0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1c9628: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c962c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c9630: 0x460c0b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    // 0x1c9634: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c9638: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c963c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c9640: 0xc04b0a2
    SET_GPR_U32(ctx, 31, 0x1c9648);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 3052));
    ApplyAsegOvr__FP4ASEGP3ALOiP3OVRffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1c9648
// Address: 0x1c9648 - 0x1c9684

void entry_1c9648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9648) {
        switch (ctx->pc) {
            case 0x1c964c: ctx->pc = 0; goto label_1c964c;
            case 0x1c9650: ctx->pc = 0; goto label_1c9650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9648: 0xae120868
    WRITE32(ADD32(GPR_U32(ctx, 16), 2152), GPR_U32(ctx, 18));
label_1c964c:
    // 0x1c964c: 0xae00086c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2156), GPR_U32(ctx, 0));
label_1c9650:
    // 0x1c9650: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1c9654: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1c9658: 0x2c83000e
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 14));
    // 0x1c965c: 0x1060000d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1c9694(rdram, ctx, runtime); return;
    }
    // 0x1c9664: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c9668: 0x2442d7f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957040));
    // 0x1c966c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c9670: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9674: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c967c: 0xc072248
    SET_GPR_U32(ctx, 31, 0x1c9684);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001c8920(rdram, ctx, runtime); return;
}


// Function: entry_1c9684
// Address: 0x1c9684 - 0x1c9694

void entry_1c9684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9684: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9698; return;
    }
    // 0x1c968c: 0xc0722f0
    SET_GPR_U32(ctx, 31, 0x1c9694);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LookStepguardAtGoal__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c9694
// Address: 0x1c9694 - 0x1c96b8

void entry_1c9694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9694) {
        switch (ctx->pc) {
            case 0x1c9698: ctx->pc = 0; goto label_1c9698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9694: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1c9698:
    // 0x1c9698: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c969c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c96a0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c96a4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1c96a8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c96ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c96b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c96b8; return;
}


// Function: SggsGetStepguard__FP9STEPGUARD
// Address: 0x1c96b8 - 0x1c96d8

void entry_1c972c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c972c) {
        switch (ctx->pc) {
            case 0x1c9734: ctx->pc = 0; goto label_1c9734;
            case 0x1c973c: ctx->pc = 0; goto label_1c973c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c972c: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c973c;
    }
label_1c9734:
    // 0x1c9734: 0x1000008e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9970; return;
    }
label_1c973c:
    // 0x1c973c: 0xc06f0c8
    SET_GPR_U32(ctx, 31, 0x1c9744);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbsorbSoWkr__FP2SOP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_1c9744
// Address: 0x1c9744 - 0x1c9804

void entry_1c9744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9744) {
        switch (ctx->pc) {
            case 0x1c9780: ctx->pc = 0; goto label_1c9780;
            case 0x1c97a0: ctx->pc = 0; goto label_1c97a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9744: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1c9748: 0x12600089
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9970; return;
    }
    // 0x1c9750: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1c9754: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1c9758: 0x10400084
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c996c(rdram, ctx, runtime); return;
    }
    // 0x1c9760: 0x8e050ac4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2756)));
    // 0x1c9764: 0x8e060bdc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 3036)));
    // 0x1c9768: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c976c: 0xa21018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1c9770: 0x24420ac8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2760));
    // 0x1c9774: 0x502021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1c9778: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1c977c: 0x0
    // NOP
label_1c9780:
    // 0x1c9780: 0x4a00007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967284));
    if (GPR_S32(ctx, 5) < 0) {
        goto label_1c97a0;
    }
    // 0x1c9788: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c978c: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1c9790: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c9794: 0x5040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
        goto label_1c9780;
    }
    // 0x1c979c: 0x8c920008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 4), 8)));
label_1c97a0:
    // 0x1c97a0: 0x50c00027
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2664)));
        ctx->pc = 0x1C9840; return;
    }
    // 0x1c97a8: 0xda210030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1c97ac: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c97b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c97b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c97b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c97bc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c97c0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c97c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c97c8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c97cc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c97d0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c97d4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c97d8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c97dc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c97e0: 0x0
    // NOP
    // 0x1c97e4: 0x45020016
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2664)));
        ctx->pc = 0x1C9840; return;
    }
    // 0x1c97ec: 0xae000b7c
    WRITE32(ADD32(GPR_U32(ctx, 16), 2940), GPR_U32(ctx, 0));
    // 0x1c97f0: 0xc62c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1c97f4: 0xc62d0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[13] = *(float*)&val; }
    // 0x1c97f8: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x1c97fc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c9804);
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c9804
// Address: 0x1c9804 - 0x1c9810

void entry_1c9804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9804: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1c9808: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c9810);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c9810
// Address: 0x1c9810 - 0x1c9824

void entry_1c9810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9810: 0xc6010bd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3024)); ctx->f[1] = *(float*)&val; }
    // 0x1c9814: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1c9818: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1c981c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1c9824);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1c9824
// Address: 0x1c9824 - 0x1c9834

void entry_1c9824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9824: 0xc60d0b24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2852)); ctx->f[13] = *(float*)&val; }
    // 0x1c9828: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c982c: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c9834);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c9834
// Address: 0x1c9834 - 0x1c983c

void entry_1c9834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9834: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1c983c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1c983c
// Address: 0x1c983c - 0x1c985c

void entry_1c983c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c983c) {
        switch (ctx->pc) {
            case 0x1c9840: ctx->pc = 0; goto label_1c9840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c983c: 0x8e020a68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2664)));
label_1c9840:
    // 0x1c9840: 0x2403000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1c9844: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1c9848: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1c984c: 0x28420001
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 1));
    // 0x1c9850: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9854: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1c985c);
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1c985c
// Address: 0x1c985c - 0x1c9948

void entry_1c985c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c985c) {
        switch (ctx->pc) {
            case 0x1c98d0: ctx->pc = 0; goto label_1c98d0;
            case 0x1c98d4: ctx->pc = 0; goto label_1c98d4;
            case 0x1c9924: ctx->pc = 0; goto label_1c9924;
            case 0x1c9930: ctx->pc = 0; goto label_1c9930;
            case 0x1c9934: ctx->pc = 0; goto label_1c9934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c985c: 0x8e020b00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2816)));
    // 0x1c9860: 0x10400039
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c9948(rdram, ctx, runtime); return;
    }
    // 0x1c9868: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1c986c: 0xc6200028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1c9870: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c9874: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c9878: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1c987c: 0x10800014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1c98d0;
    }
    // 0x1c9884: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c9888: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1c988c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1c9890: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
        goto label_1c98d4;
    }
    // 0x1c9898: 0xd8810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x1c989c: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c98a0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c98a4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c98a8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c98ac: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c98b0: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c98b4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c98b8: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c98bc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c98c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c98c4: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1c98c8: 0x1000001a
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9934;
    }
label_1c98d0:
    // 0x1c98d0: 0xda230030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
label_1c98d4:
    // 0x1c98d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c98d8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c98dc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1c98e0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c98e4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c98e8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1c98ec: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1c98f0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c98f4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c98f8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c98fc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c9900: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1c9904: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c9908: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c990c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1c9910: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c9914: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c9924;
    }
    // 0x1c991c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9930;
    }
label_1c9924:
    // 0x1c9924: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c9928: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c992c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1c9930:
    // 0x1c9930: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1c9934:
    // 0x1c9934: 0x8e040b00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2816)));
    // 0x1c9938: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c993c: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1c9940: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9948);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9948
// Address: 0x1c9948 - 0x1c996c

void entry_1c9948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9948: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1c994c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9950: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1c9954: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1c9958: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1c995c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c9960: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1c9964: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1c996c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1c996c
// Address: 0x1c996c - 0x1c9990

void entry_1c996c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c996c) {
        switch (ctx->pc) {
            case 0x1c9970: ctx->pc = 0; goto label_1c9970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c996c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1c9970:
    // 0x1c9970: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1c9974: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1c9978: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1c997c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c9980: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c9984: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c998c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c9990; return;
}


// Function: FTakeStepguardDamage__FP9STEPGUARDP3ZPR
// Address: 0x1c9990 - 0x1c99b8

void entry_1c99b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c99b8: 0x1440001d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9A30; return;
    }
    // 0x1c99c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c99c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c99c8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1c99d0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1c99d0
// Address: 0x1c99d0 - 0x1c9a2c

void entry_1c99d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c99d0) {
        switch (ctx->pc) {
            case 0x1c99f0: ctx->pc = 0; goto label_1c99f0;
            case 0x1c9a10: ctx->pc = 0; goto label_1c9a10;
            case 0x1c9a14: ctx->pc = 0; goto label_1c9a14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c99d0: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1c99d4: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1c99d8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c99dc: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x1c99e0: 0x14820003
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1c99f0;
    }
    // 0x1c99e8: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9a14;
    }
label_1c99f0:
    // 0x1c99f0: 0x10600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c9a10;
    }
    // 0x1c99f8: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c99fc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1c9a00: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1c9a04: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1c9a10;
    }
    // 0x1c9a0c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1c9a10:
    // 0x1c9a10: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_1c9a14:
    // 0x1c9a14: 0x7a220140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1c9a18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1c9a1c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9a20: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9a24: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1c9a2c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1c9a2c
// Address: 0x1c9a2c - 0x1c9a48

void entry_1c9a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9a2c) {
        switch (ctx->pc) {
            case 0x1c9a30: ctx->pc = 0; goto label_1c9a30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9a2c: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1c9a30:
    // 0x1c9a30: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1c9a34: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c9a38: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c9a3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c9a44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c9a48; return;
}


// Function: FUN_001c9a48
// Address: 0x1c9a48 - 0x1c9a58

void FUN_001c9a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9a48: 0x8c820bd8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 3032)));
    // 0x1c9a4c: 0x3e00008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c9a54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c9a58; return;
}


// Function: HandleStepguardGrfsgsc__FP9STEPGUARD
// Address: 0x1c9a58 - 0x1c9a9c

void entry_1c9a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9a9c) {
        switch (ctx->pc) {
            case 0x1c9aa4: ctx->pc = 0; goto label_1c9aa4;
            case 0x1c9abc: ctx->pc = 0; goto label_1c9abc;
            case 0x1c9ad0: ctx->pc = 0; goto label_1c9ad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9a9c: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 2016), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9abc;
    }
label_1c9aa4:
    // 0x1c9aa4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9aa8: 0xc441d828
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294957096)); ctx->f[1] = *(float*)&val; }
    // 0x1c9aac: 0xc4600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1c9ab0: 0xe4800014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 20), *(uint32_t*)&val); }
    // 0x1c9ab4: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c9ab8: 0xe4410010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 16), *(uint32_t*)&val); }
label_1c9abc:
    // 0x1c9abc: 0x8e02072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1836)));
    // 0x1c9ac0: 0x2403fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1c9ac4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c9ac8: 0xae02072c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1836), GPR_U32(ctx, 2));
    // 0x1c9acc: 0x8e02072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1836)));
label_1c9ad0:
    // 0x1c9ad0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1c9ad4: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1c9ae8(rdram, ctx, runtime); return;
    }
    // 0x1c9adc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9ae0: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1c9ae8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1840)));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1c9ae8
// Address: 0x1c9ae8 - 0x1c9af8

void entry_1c9ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9ae8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c9aec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c9af0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DoStepguardFreefallJump__FP9STEPGUARD
// Address: 0x1c9af8 - 0x1c9b78

void entry_1c9b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9b78: 0xc6020b98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2968)); ctx->f[2] = *(float*)&val; }
    // 0x1c9b7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1c9b80: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x1c9b84: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1c9b88: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1c9b8c: 0x46020502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1c9b90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1c9b94: 0xda040350
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1c9b98: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c9b9c: 0x4614a803
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[20];
    // 0x1c9ba0: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1c9ba4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1c9ba8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c9bac: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1c9bb0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1c9bb4: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1c9bb8: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c9bbc: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c9bc0: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c9bc4: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1c9bc8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1c9bcc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9bd4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9bd4
// Address: 0x1c9bd4 - 0x1c9c40

void entry_1c9bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9bd4: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c9bd8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1c9bdc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c9be0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c9be4: 0xc461185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1c9be8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c9bec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1c9bf0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1c9bf4: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1c9bf8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1c9bfc: 0x46140840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[20]);
    // 0x1c9c00: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1c9c04: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c9c08: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c9c0c: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c9c10: 0xda010350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1c9c14: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c9c18: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1c9c1c: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c9c20: 0xe6010ba4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 2980), *(uint32_t*)&val); }
    // 0x1c9c24: 0x7e020bb0
    WRITE128(ADD32(GPR_U32(ctx, 16), 2992), GPR_VEC(ctx, 2));
    // 0x1c9c28: 0xfa020bc0
    WRITE128(ADD32(GPR_U32(ctx, 16), 3008), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1c9c2c: 0x45000027
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1C9CCC; return;
    }
    // 0x1c9c34: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1c9c38: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1c9c40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1c9c40
// Address: 0x1c9c40 - 0x1c9c70

void entry_1c9c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9c40) {
        switch (ctx->pc) {
            case 0x1c9c68: ctx->pc = 0; goto label_1c9c68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9c40: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c9c44: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1c9c48: 0xc6000b94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2964)); ctx->f[0] = *(float*)&val; }
    // 0x1c9c4c: 0x460d0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1c9c50: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1c9c68;
    }
    // 0x1c9c58: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1c9c5c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1c9c60: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c9c64: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
label_1c9c68:
    // 0x1c9c68: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1c9c70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1c9c70
// Address: 0x1c9c70 - 0x1c9cf8

void entry_1c9c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9c70) {
        switch (ctx->pc) {
            case 0x1c9ccc: ctx->pc = 0; goto label_1c9ccc;
            case 0x1c9cdc: ctx->pc = 0; goto label_1c9cdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9c70: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c9c74: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c9c78: 0x26020660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1c9c7c: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1c9c80: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1c9c84: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1c9c88: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1c9c8c: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1c9c90: 0x4be618d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1c9c94: 0xda010660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1632)));
    // 0x1c9c98: 0x4be30a6a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1c9c9c: 0x4be00293
    // Unhandled VU0 Special1 function: 0x13
    // 0x1c9ca0: 0x4be3122a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1c9ca4: 0x4be321ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1c9ca8: 0x4b09483d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x1c9cac: 0x4b09514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c9cb0: 0x4a88403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1c9cb4: 0x4a88514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c9cb8: 0x4a47383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1c9cbc: 0x4a475149
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1c9cc0: 0xfba60030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1c9cc4: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9cdc;
    }
label_1c9ccc:
    // 0x1c9ccc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1c9cd0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1c9cd4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c9cd8: 0x7e030640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), GPR_VEC(ctx, 3));
label_1c9cdc:
    // 0x1c9cdc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1c9ce0: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1c9ce4: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x1c9ce8: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1c9cec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c9cf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c9cf8; return;
}


// Function: DoStepguardFreefallLanding__FP9STEPGUARD
// Address: 0x1c9cf8 - 0x1c9d20

void entry_1c9d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9d20: 0x8e0407e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1c9d24: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1c9d28: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1c9d2c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1c9d30: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x1c9d38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_1c9d38
// Address: 0x1c9d38 - 0x1c9d50

void entry_1c9d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9d38: 0xae000ba4
    WRITE32(ADD32(GPR_U32(ctx, 16), 2980), GPR_U32(ctx, 0));
    // 0x1c9d3c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1c9d40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c9d44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1c9d4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1c9d50; return;
}


// Function: FUN_001c9d50
// Address: 0x1c9d50 - 0x1c9dc0

void FUN_001c9d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9d50) {
        switch (ctx->pc) {
            case 0x1c9d94: ctx->pc = 0; goto label_1c9d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9d50: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1c9d54: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1c9d58: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1c9d5c: 0x8ce20b54
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 2900)));
    // 0x1c9d60: 0x14a2001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C9DD4; return;
    }
    // 0x1c9d68: 0x8ce20724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 1828)));
    // 0x1c9d6c: 0x2444fff6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967286));
    // 0x1c9d70: 0x2c830007
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 7));
    // 0x1c9d74: 0x10600007
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1c9d94;
    }
    // 0x1c9d7c: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c9d80: 0x2442d830
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957104));
    // 0x1c9d84: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c9d88: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9d8c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
label_1c9d94:
    // 0x1c9d94: 0x10c0000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9DD4; return;
    }
    // 0x1c9d9c: 0x8cc30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 80)));
    // 0x1c9da0: 0x8ce20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 80)));
    // 0x1c9da4: 0x1062000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1C9DD4; return;
    }
    // 0x1c9dac: 0x8ce40b0c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 2828)));
    // 0x1c9db0: 0x10800008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9DD4; return;
    }
    // 0x1c9db8: 0xc06a208
    SET_GPR_U32(ctx, 31, 0x1c9dc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1c9dc0
// Address: 0x1c9dc0 - 0x1c9de0

void entry_1c9dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9dc0) {
        switch (ctx->pc) {
            case 0x1c9dd4: ctx->pc = 0; goto label_1c9dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9dc0: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1c9dd4;
    }
    // 0x1c9dc8: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9dd4;
    }
    // 0x1c9dd0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1c9dd4:
    // 0x1c9dd4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1c9dd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleStepguardMessage__FP9STEPGUARD5MSGIDPv
// Address: 0x1c9de0 - 0x1c9e20

void entry_1c9e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9e20) {
        switch (ctx->pc) {
            case 0x1c9e64: ctx->pc = 0; goto label_1c9e64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9e20: 0x2603fffb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967291));
    // 0x1c9e24: 0x2c620013
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 19));
    // 0x1c9e28: 0x1040017f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1c9e30: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1c9e34: 0x2442d850
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957136));
    // 0x1c9e38: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c9e3c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9e40: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c9e48: 0x8e2207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x1c9e4c: 0x56420005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1876)));
        goto label_1c9e64;
    }
    // 0x1c9e54: 0x8e22072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1836)));
    // 0x1c9e58: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x1c9e5c: 0x10000172
    WRITE32(ADD32(GPR_U32(ctx, 17), 1836), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
label_1c9e64:
    // 0x1c9e64: 0x16420171
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1c9e6c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c9e70: 0xc072cca
    SET_GPR_U32(ctx, 31, 0x1c9e78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardPatrolAnimation__FP9STEPGUARDP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1c9e78
// Address: 0x1c9e78 - 0x1c9eac

void entry_1c9e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9e78: 0x1000016c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1c9e80: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c9e84: 0x8e220754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1876)));
    // 0x1c9e88: 0x14620168
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1c9e90: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1c9e94: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c9e98: 0xae220a74
    WRITE32(ADD32(GPR_U32(ctx, 17), 2676), GPR_U32(ctx, 2));
    // 0x1c9e9c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1c9ea0: 0x8c66006c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1c9ea4: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1c9eac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1c9eac
// Address: 0x1c9eac - 0x1c9f1c

void entry_1c9eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9eac) {
        switch (ctx->pc) {
            case 0x1c9eec: ctx->pc = 0; goto label_1c9eec;
            case 0x1c9f10: ctx->pc = 0; goto label_1c9f10;
            case 0x1c9f14: ctx->pc = 0; goto label_1c9f14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9eac: 0x8e22072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1836)));
    // 0x1c9eb0: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c9eb4: 0x8e240a74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2676)));
    // 0x1c9eb8: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1c9ebc: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x1c9ec0: 0xae230730
    WRITE32(ADD32(GPR_U32(ctx, 17), 1840), GPR_U32(ctx, 3));
    // 0x1c9ec4: 0xae22072c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1836), GPR_U32(ctx, 2));
    // 0x1c9ec8: 0x8c8402e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 736)));
    // 0x1c9ecc: 0x10850010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 5)) {
        goto label_1c9f10;
    }
    // 0x1c9ed4: 0x8e230720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c9ed8: 0x5060000e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2676)));
        goto label_1c9f14;
    }
    // 0x1c9ee0: 0x8c620180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 384)));
    // 0x1c9ee4: 0x50450001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 384), GPR_U32(ctx, 4));
        goto label_1c9eec;
    }
label_1c9eec:
    // 0x1c9eec: 0x8e250720
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1824)));
    // 0x1c9ef0: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1c9ef4: 0x8e240a74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2676)));
    // 0x1c9ef8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c9efc: 0x8ca20180
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 384)));
    // 0x1c9f00: 0x8c8302e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 736)));
    // 0x1c9f04: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1c9f08: 0x10000002
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1c9f14;
    }
label_1c9f10:
    // 0x1c9f10: 0x8e240a74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2676)));
label_1c9f14:
    // 0x1c9f14: 0xc07be40
    SET_GPR_U32(ctx, 31, 0x1c9f1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    SetWaypointWps__FP8WAYPOINT3WPS(rdram, ctx, runtime); return;
}


// Function: entry_1c9f1c
// Address: 0x1c9f1c - 0x1c9f60

void entry_1c9f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9f1c: 0x10000143
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1c9f24: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c9f28: 0x8e220a74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2676)));
    // 0x1c9f2c: 0x1462013f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1c9f34: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c9f38: 0x1060000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9F68; return;
    }
    // 0x1c9f40: 0x1462013b
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA430; return;
    }
    // 0x1c9f48: 0x8e230724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1828)));
    // 0x1c9f4c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1c9f50: 0x14620138
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA434; return;
    }
    // 0x1c9f58: 0xc07235e
    SET_GPR_U32(ctx, 31, 0x1c9f60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    OnStepguardWaypointActive__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1c9f60
// Address: 0x1c9f60 - 0x1c9ff4

void entry_1c9f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1c9f60) {
        switch (ctx->pc) {
            case 0x1c9f68: ctx->pc = 0; goto label_1c9f68;
            case 0x1c9fc8: ctx->pc = 0; goto label_1c9fc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1c9f60: 0x10000132
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
label_1c9f68:
    // 0x1c9f68: 0x8e22072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1836)));
    // 0x1c9f6c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1c9f70: 0xae230730
    WRITE32(ADD32(GPR_U32(ctx, 17), 1840), GPR_U32(ctx, 3));
    // 0x1c9f74: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x1c9f78: 0x1000012b
    WRITE32(ADD32(GPR_U32(ctx, 17), 1836), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1c9f80: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1c9f84: 0x8e2207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    // 0x1c9f88: 0x16020127
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1c9f90: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1c9f94: 0x2444fec8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966984));
    // 0x1c9f98: 0x2c83007c
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 124));
    // 0x1c9f9c: 0x10600122
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1c9fa4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1c9fa8: 0x2442d8a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957216));
    // 0x1c9fac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1c9fb0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9fb4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1c9fbc: 0x8e62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 156)));
    // 0x1c9fc0: 0x1040011a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
label_1c9fc8:
    // 0x1c9fc8: 0x8e62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 156)));
    // 0x1c9fcc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1c9fd0: 0xc64c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1c9fd4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9fd8: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1c9fdc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1c9fe0: 0xc60d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[13] = *(float*)&val; }
    // 0x1c9fe4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1c9fe8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1c9fec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1c9ff4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1c9ff4
// Address: 0x1c9ff4 - 0x1ca04c

void entry_1c9ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1c9ff4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1c9ff8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1c9ffc: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x1ca000: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca004: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ca008: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1ca00c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ca010: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1ca014: 0xda240660
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x1ca018: 0x4be51858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ca01c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ca020: 0xfa210640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ca024: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1ca028: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1ca02c: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1ca030: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ca034: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ca038: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1ca03c: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ca040: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1ca044: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca04c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca04c
// Address: 0x1ca04c - 0x1ca060

void entry_1ca04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca04c: 0x100000f7
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca054: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ca058: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca060);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 423));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca060
// Address: 0x1ca060 - 0x1ca0a8

void entry_1ca060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca060: 0x104000f2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca068: 0x8e62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 156)));
    // 0x1ca06c: 0x104000f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA430; return;
    }
    // 0x1ca074: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ca078: 0x104000ed
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA430; return;
    }
    // 0x1ca080: 0x1000ffd1
    WRITE32(ADD32(GPR_U32(ctx, 17), 2936), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1C9FC8; return;
    }
    // 0x1ca088: 0x100000e7
    WRITE32(ADD32(GPR_U32(ctx, 17), 2936), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca090: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ca094: 0xae200a60
    WRITE32(ADD32(GPR_U32(ctx, 17), 2656), GPR_U32(ctx, 0));
    // 0x1ca098: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ca09c: 0x240501ae
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 430));
    // 0x1ca0a0: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca0a8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 2960), GPR_U32(ctx, 2));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca0a8
// Address: 0x1ca0a8 - 0x1ca0b8

void entry_1ca0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca0a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ca0ac: 0x240501af
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 431));
    // 0x1ca0b0: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca0b8);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca0b8
// Address: 0x1ca0b8 - 0x1ca0c8

void entry_1ca0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca0b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ca0bc: 0x240501b1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 433));
    // 0x1ca0c0: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca0c8);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca0c8
// Address: 0x1ca0c8 - 0x1ca0d8

void entry_1ca0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca0c8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ca0cc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ca0d0: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca0d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 432));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca0d8
// Address: 0x1ca0d8 - 0x1ca120

void entry_1ca0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca0d8: 0x124000d3
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca0e0: 0x120000d2
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca0e8: 0x128000d0
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca0f0: 0x8e62009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 156)));
    // 0x1ca0f4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1ca0f8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ca0fc: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ca100: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ca104: 0xc64c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1ca108: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1ca10c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ca110: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca114: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ca118: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca120);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca120
// Address: 0x1ca120 - 0x1ca14c

void entry_1ca120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca120: 0x8e63009c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 156)));
    // 0x1ca124: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1ca128: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1ca12c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ca130: 0x8c640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1ca134: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca138: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ca13c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ca140: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ca144: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca14c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca14c
// Address: 0x1ca14c - 0x1ca190

void entry_1ca14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca14c: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1ca150: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1ca154: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ca158: 0xe6200b94
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 2964), *(uint32_t*)&val); }
    // 0x1ca15c: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1ca160: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ca164: 0xc662007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 124)); ctx->f[2] = *(float*)&val; }
    // 0x1ca168: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1ca16c: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1ca170: 0x100000ad
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 2968), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca178: 0x100000ab
    WRITE32(ADD32(GPR_U32(ctx, 17), 2960), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca180: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ca184: 0x8c620194
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 404)));
    // 0x1ca188: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca190
// Address: 0x1ca190 - 0x1ca1b8

void entry_1ca190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca190: 0x100000a6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca198: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ca19c: 0x100000a2
    WRITE32(ADD32(GPR_U32(ctx, 17), 2956), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca1a4: 0x8e220b8c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
    // 0x1ca1a8: 0x1040009f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca1b0: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x1ca1b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 432));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca1b8
// Address: 0x1ca1b8 - 0x1ca1e0

void entry_1ca1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca1b8) {
        switch (ctx->pc) {
            case 0x1ca1c4: ctx->pc = 0; goto label_1ca1c4;
            case 0x1ca1d8: ctx->pc = 0; goto label_1ca1d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca1b8: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[12] = *(float*)&val; }
        goto label_1ca1c4;
    }
    // 0x1ca1c0: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
label_1ca1c4:
    // 0x1ca1c4: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1ca1c8: 0x10400003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2016)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ca1d8;
    }
    // 0x1ca1d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ca1d4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_1ca1d8:
    // 0x1ca1d8: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x1ca1e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_1ca1e0
// Address: 0x1ca1e0 - 0x1ca24c

void entry_1ca1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca1e0: 0x10000092
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca1e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ca1ec: 0x1000008e
    WRITE32(ADD32(GPR_U32(ctx, 17), 2948), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca1f4: 0x1000008c
    WRITE32(ADD32(GPR_U32(ctx, 17), 2948), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca1fc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ca200: 0x10000089
    WRITE32(ADD32(GPR_U32(ctx, 17), 2940), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca208: 0x10000087
    WRITE32(ADD32(GPR_U32(ctx, 17), 2940), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca210: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ca214: 0x10000084
    WRITE32(ADD32(GPR_U32(ctx, 17), 3032), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca21c: 0x10000082
    WRITE32(ADD32(GPR_U32(ctx, 17), 3032), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca224: 0x8e300b0c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 2828)));
    // 0x1ca228: 0x1200007f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca230: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1ca234: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2828)));
        ctx->pc = 0x1CA254; return;
    }
    // 0x1ca23c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ca240: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1ca244: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca24c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca24c
// Address: 0x1ca24c - 0x1ca25c

void entry_1ca24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca24c) {
        switch (ctx->pc) {
            case 0x1ca254: ctx->pc = 0; goto label_1ca254;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca24c: 0xae0200e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 224), GPR_U32(ctx, 2));
    // 0x1ca250: 0x8e240b0c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2828)));
label_1ca254:
    // 0x1ca254: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x1ca25c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_1ca25c
// Address: 0x1ca25c - 0x1ca28c

void entry_1ca25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca25c: 0x10000073
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca264: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ca268: 0x14510070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca270: 0x8e220b8c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2956)));
    // 0x1ca274: 0x1040006e
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA430; return;
    }
    // 0x1ca27c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ca280: 0x8c620190
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 400)));
    // 0x1ca284: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca28c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca28c
// Address: 0x1ca28c - 0x1ca2d4

void entry_1ca28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca28c: 0x10000067
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA42C; return;
    }
    // 0x1ca294: 0x8e470004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1ca298: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca29c: 0x8e480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ca2a0: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca2a4: 0x8ce50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1ca2a8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ca2ac: 0x8d060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1ca2b0: 0x8ca20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x1ca2b4: 0x8cc30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1ca2b8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1ca2bc: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x1ca2c0: 0xe2b80b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 23, GPR_U32(ctx, 7));
    // 0x1ca2c4: 0x103a00b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 8));
    // 0x1ca2c8: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1ca2cc: 0xc072754
    SET_GPR_U32(ctx, 31, 0x1ca2d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_001c9d50(rdram, ctx, runtime); return;
}


// Function: entry_1ca2d4
// Address: 0x1ca2d4 - 0x1ca32c

void entry_1ca2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca2d4: 0x10400054
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
    // 0x1ca2dc: 0xda820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x1ca2e0: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ca2e4: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ca2e8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca2ec: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1ca2f0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca2f4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ca2f8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca2fc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ca300: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1ca304: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca308: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ca30c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ca310: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca314: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ca318: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1ca31c: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1ca320: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ca324: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1ca32c);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ca32c
// Address: 0x1ca32c - 0x1ca358

void entry_1ca32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca32c) {
        switch (ctx->pc) {
            case 0x1ca340: ctx->pc = 0; goto label_1ca340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca32c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ca330: 0x18400020
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CA3B4; return;
    }
    // 0x1ca338: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ca33c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1ca340:
    // 0x1ca340: 0x8eb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1ca344: 0x12110018
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1CA3A8; return;
    }
    // 0x1ca34c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ca350: 0xc072754
    SET_GPR_U32(ctx, 31, 0x1ca358);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    FUN_001c9d50(rdram, ctx, runtime); return;
}


// Function: entry_1ca358
// Address: 0x1ca358 - 0x1ca3f8

void entry_1ca358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca358) {
        switch (ctx->pc) {
            case 0x1ca3a4: ctx->pc = 0; goto label_1ca3a4;
            case 0x1ca3a8: ctx->pc = 0; goto label_1ca3a8;
            case 0x1ca3b4: ctx->pc = 0; goto label_1ca3b4;
            case 0x1ca3d4: ctx->pc = 0; goto label_1ca3d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca358: 0x10400013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ca3a8;
    }
    // 0x1ca360: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1ca364: 0x26d60001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    // 0x1ca368: 0xda820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x1ca36c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca370: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca374: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ca378: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca37c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ca380: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ca384: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ca388: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ca38c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ca390: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1ca394: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ca398: 0x0
    // NOP
    // 0x1ca39c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1ca3a4;
    }
label_1ca3a4:
    // 0x1ca3a4: 0x2429021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
label_1ca3a8:
    // 0x1ca3a8: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x1ca3ac: 0x1660ffe4
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA340; return;
    }
label_1ca3b4:
    // 0x1ca3b4: 0x16400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1ca3d4;
    }
    // 0x1ca3bc: 0x27c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1ca3c0: 0xc6210be0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3040)); ctx->f[1] = *(float*)&val; }
    // 0x1ca3c4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ca3c8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ca3cc: 0x10000016
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3068), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA428; return;
    }
label_1ca3d4:
    // 0x1ca3d4: 0x44960000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 22);
    // 0x1ca3d8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ca3dc: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1ca3e0: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x1ca3e4: 0x44926800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 18);
    // 0x1ca3e8: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1ca3ec: 0x46006303
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    // 0x1ca3f0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1ca3f8);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[0];
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1ca3f8
// Address: 0x1ca3f8 - 0x1ca460

void entry_1ca3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca3f8) {
        switch (ctx->pc) {
            case 0x1ca428: ctx->pc = 0; goto label_1ca428;
            case 0x1ca42c: ctx->pc = 0; goto label_1ca42c;
            case 0x1ca430: ctx->pc = 0; goto label_1ca430;
            case 0x1ca434: ctx->pc = 0; goto label_1ca434;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca3f8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ca3fc: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ca400: 0x27c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1ca404: 0xc6240be0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3040)); ctx->f[4] = *(float*)&val; }
    // 0x1ca408: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1ca40c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1ca410: 0xc6230be4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3044)); ctx->f[3] = *(float*)&val; }
    // 0x1ca414: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1ca418: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ca41c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1ca420: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1ca424: 0xe6210bfc
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 3068), *(uint32_t*)&val); }
label_1ca428:
    // 0x1ca428: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_1ca42c:
    // 0x1ca42c: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_1ca430:
    // 0x1ca430: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_1ca434:
    // 0x1ca434: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ca438: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ca43c: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ca440: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ca444: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ca448: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ca44c: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ca450: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x1ca454: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca45c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca460; return;
}


// Function: SgasGetStepguard__FP9STEPGUARD
// Address: 0x1ca460 - 0x1ca468

void entry_1ca490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca490: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ca494: 0x1200004b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca49c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ca4a0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ca4a4: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1ca4a8: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
        ctx->pc = 0x1CA4C8; return;
    }
    // 0x1ca4b0: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1ca4b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ca4bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ca4bc
// Address: 0x1ca4bc - 0x1ca500

void entry_1ca4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca4bc) {
        switch (ctx->pc) {
            case 0x1ca4c8: ctx->pc = 0; goto label_1ca4c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca4bc: 0x14400041
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca4c4: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
label_1ca4c8:
    // 0x1ca4c8: 0x26240738
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1848));
    // 0x1ca4cc: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ca4d0: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ca4d4: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ca4d8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ca4dc: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ca4e0: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ca4e4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ca4e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ca4ec: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ca4f0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ca4f4: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1ca4f8: 0xc07ac14
    SET_GPR_U32(ctx, 31, 0x1ca500);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FCheckLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1ca500
// Address: 0x1ca500 - 0x1ca510

void entry_1ca500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca500: 0x10400030
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca508: 0xc071e98
    SET_GPR_U32(ctx, 31, 0x1ca510);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DradEnemyStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1ca510
// Address: 0x1ca510 - 0x1ca5b4

void entry_1ca510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca510) {
        switch (ctx->pc) {
            case 0x1ca55c: ctx->pc = 0; goto label_1ca55c;
            case 0x1ca56c: ctx->pc = 0; goto label_1ca56c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca510: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ca514: 0x46000305
    ctx->f[12] = FPU_ABS_S(ctx->f[0]);
    // 0x1ca518: 0x24434ce0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19680));
    // 0x1ca51c: 0xc4424ce0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19680)); ctx->f[2] = *(float*)&val; }
    // 0x1ca520: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1ca524: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ca528: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ca52c: 0x24445c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1ca530: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1ca534: 0xc4435c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x1ca538: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ca53c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ca540: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1ca544: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ca548: 0x0
    // NOP
    // 0x1ca54c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ca55c;
    }
    // 0x1ca554: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ca56c;
    }
label_1ca55c:
    // 0x1ca55c: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ca560: 0x0
    // NOP
    // 0x1ca564: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_1ca56c;
    }
label_1ca56c:
    // 0x1ca56c: 0x460c0042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x1ca570: 0xc620074c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1868)); ctx->f[0] = *(float*)&val; }
    // 0x1ca574: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ca578: 0x0
    // NOP
    // 0x1ca57c: 0x45010011
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca584: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ca588: 0xc6210748
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1864)); ctx->f[1] = *(float*)&val; }
    // 0x1ca58c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1ca590: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ca594: 0x0
    // NOP
    // 0x1ca598: 0x4501000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca5a0: 0x8e240b0c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2828)));
    // 0x1ca5a4: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x1CA5C4; return;
    }
    // 0x1ca5ac: 0xc06a314
    SET_GPR_U32(ctx, 31, 0x1ca5b4);
    FEnsureRwmLoaded__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_1ca5b4
// Address: 0x1ca5b4 - 0x1ca5e0

void entry_1ca5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca5b4) {
        switch (ctx->pc) {
            case 0x1ca5c4: ctx->pc = 0; goto label_1ca5c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca5b4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ca5b8: 0x10600002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ca5c4;
    }
    // 0x1ca5c0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1ca5c4:
    // 0x1ca5c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca5c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca5cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca5d0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ca5d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca5dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca5e0; return;
}


// Function: RenderStepguardSelf__FP9STEPGUARDP2CMP2RO
// Address: 0x1ca5e0 - 0x1ca5f0

void entry_1ca5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca5f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca5f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca5fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca600; return;
}


// Function: FValidSgs__F3SGS
// Address: 0x1ca600 - 0x1ca608

void entry_1ca630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca630) {
        switch (ctx->pc) {
            case 0x1ca640: ctx->pc = 0; goto label_1ca640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca630: 0x10400003
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ca640;
    }
    // 0x1ca638: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1ca63c: 0xac510758
    WRITE32(ADD32(GPR_U32(ctx, 2), 1880), GPR_U32(ctx, 17));
label_1ca640:
    // 0x1ca640: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ca644: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca648: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca64c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca650: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UseStepguardAnimationImmediate__FP9STEPGUARD3SGS3OID
// Address: 0x1ca658 - 0x1ca680

void entry_1ca680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca680) {
        switch (ctx->pc) {
            case 0x1ca6a4: ctx->pc = 0; goto label_1ca6a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca680: 0x1040000c
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA6B4; return;
    }
    // 0x1ca688: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ca68c: 0x24420758
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1880));
    // 0x1ca690: 0x2428021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1ca694: 0x16230003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        goto label_1ca6a4;
    }
    // 0x1ca69c: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA6B4; return;
    }
label_1ca6a4:
    // 0x1ca6a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ca6a8: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x1ca6b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca6b0
// Address: 0x1ca6b0 - 0x1ca6d0

void entry_1ca6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca6b0) {
        switch (ctx->pc) {
            case 0x1ca6b4: ctx->pc = 0; goto label_1ca6b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca6b0: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_1ca6b4:
    // 0x1ca6b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ca6b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca6bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca6c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca6c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca6cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca6d0; return;
}


// Function: FUN_001ca6d0
// Address: 0x1ca6d0 - 0x1ca6f0

void FUN_001ca6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca6d0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ca6d4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ca6d8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ca6dc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ca6e0: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ca6e4: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ca6e8: 0xc072980
    SET_GPR_U32(ctx, 31, 0x1ca6f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FValidSgs__F3SGS(rdram, ctx, runtime); return;
}


// Function: entry_1ca6f0
// Address: 0x1ca6f0 - 0x1ca720

void entry_1ca6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca6f0) {
        switch (ctx->pc) {
            case 0x1ca704: ctx->pc = 0; goto label_1ca704;
            case 0x1ca708: ctx->pc = 0; goto label_1ca708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca6f0: 0x10400004
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ca704;
    }
    // 0x1ca6f8: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1ca6fc: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1884)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ca708;
    }
label_1ca704:
    // 0x1ca704: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ca708:
    // 0x1ca708: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca70c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca710: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca71c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca720; return;
}


// Function: UseStepguardDeathAnimation__FP9STEPGUARDi3OID
// Address: 0x1ca720 - 0x1ca758

void entry_1ca780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca780: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ca784: 0x12000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA7A8; return;
    }
    // 0x1ca78c: 0xae000048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 0));
    // 0x1ca790: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ca794: 0xc04b4e6
    SET_GPR_U32(ctx, 31, 0x1ca79c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    StripAsegAlo__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ca79c
// Address: 0x1ca79c - 0x1ca7a4

void entry_1ca79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca79c: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1ca7a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ca7a4
// Address: 0x1ca7a4 - 0x1ca7c0

void entry_1ca7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca7a4) {
        switch (ctx->pc) {
            case 0x1ca7a8: ctx->pc = 0; goto label_1ca7a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca7a4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ca7a8:
    // 0x1ca7a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca7ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca7b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca7b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca7bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca7c0; return;
}


// Function: LoadStepguardAnimations__FP9STEPGUARD
// Address: 0x1ca7c0 - 0x1ca7fc

void entry_1ca7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca7fc) {
        switch (ctx->pc) {
            case 0x1ca808: ctx->pc = 0; goto label_1ca808;
            case 0x1ca828: ctx->pc = 0; goto label_1ca828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca7fc: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1ca800: 0xae130000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 19));
    // 0x1ca804: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
label_1ca808:
    // 0x1ca808: 0x641fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1CA7E8; return;
    }
    // 0x1ca810: 0x8e220ac4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2756)));
    // 0x1ca814: 0x18400010
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CA858; return;
    }
    // 0x1ca81c: 0x2413ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ca820: 0x26300ac8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 2760));
    // 0x1ca824: 0x0
    // NOP
label_1ca828:
    // 0x1ca828: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ca82c: 0x50b30006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2756)));
        ctx->pc = 0x1CA848; return;
    }
    // 0x1ca834: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x1ca83c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ca83c
// Address: 0x1ca83c - 0x1ca878

void entry_1ca83c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca83c) {
        switch (ctx->pc) {
            case 0x1ca848: ctx->pc = 0; goto label_1ca848;
            case 0x1ca858: ctx->pc = 0; goto label_1ca858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca83c: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1ca840: 0xae130004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 19));
    // 0x1ca844: 0x8e220ac4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2756)));
label_1ca848:
    // 0x1ca848: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1ca84c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1ca850: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CA828; return;
    }
label_1ca858:
    // 0x1ca858: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ca85c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ca860: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca864: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca868: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca86c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ca874: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ca878; return;
}


// Function: UseStepguardExpl__FP9STEPGUARD3OID
// Address: 0x1ca878 - 0x1ca888

void entry_1ca8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca8c0) {
        switch (ctx->pc) {
            case 0x1ca8d0: ctx->pc = 0; goto label_1ca8d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca8c0: 0x10400003
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ca8d0;
    }
    // 0x1ca8c8: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1ca8cc: 0xac510870
    WRITE32(ADD32(GPR_U32(ctx, 2), 2160), GPR_U32(ctx, 17));
label_1ca8d0:
    // 0x1ca8d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ca8d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca8d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca8dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca8e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadStepguardPhys__FP9STEPGUARD
// Address: 0x1ca8e8 - 0x1ca928

void entry_1ca928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca928: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ca938(rdram, ctx, runtime); return;
    }
    // 0x1ca930: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x1ca938);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ca938
// Address: 0x1ca938 - 0x1ca960

void entry_1ca938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ca938: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x1ca93c: 0x641fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1CA910; return;
    }
    // 0x1ca944: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ca948: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ca94c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ca950: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca954: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca958: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddStepguardEffect__FP9STEPGUARD3OID3ZPK
// Address: 0x1ca960 - 0x1ca998

void entry_1ca9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ca9d0) {
        switch (ctx->pc) {
            case 0x1ca9dc: ctx->pc = 0; goto label_1ca9dc;
            case 0x1ca9e8: ctx->pc = 0; goto label_1ca9e8;
            case 0x1ca9f4: ctx->pc = 0; goto label_1ca9f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ca9d0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ca9d4: 0x10600007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ca9f4;
    }
label_1ca9dc:
    // 0x1ca9dc: 0x8e020928
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x1ca9e0: 0x54620001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2656), GPR_U32(ctx, 0));
        goto label_1ca9e8;
    }
label_1ca9e8:
    // 0x1ca9e8: 0xae030928
    WRITE32(ADD32(GPR_U32(ctx, 16), 2344), GPR_U32(ctx, 3));
    // 0x1ca9ec: 0xae110924
    WRITE32(ADD32(GPR_U32(ctx, 16), 2340), GPR_U32(ctx, 17));
    // 0x1ca9f0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ca9f4:
    // 0x1ca9f4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ca9f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ca9fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1caa04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1caa08; return;
}


// Function: PsoEnemyStepguard__FP9STEPGUARD
// Address: 0x1caa08 - 0x1caa44

void entry_1caa44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1caa44) {
        switch (ctx->pc) {
            case 0x1caa48: ctx->pc = 0; goto label_1caa48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1caa44: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1caa48:
    // 0x1caa48: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1caa50);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1caa50
// Address: 0x1caa50 - 0x1caa70

void entry_1caa50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caa50: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2900)));
        ctx->pc = 0x1CAA7C; return;
    }
    // 0x1caa58: 0x54500008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2900)));
        ctx->pc = 0x1CAA7C; return;
    }
    // 0x1caa60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1caa64: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1caa68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1caa70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1caa70
// Address: 0x1caa70 - 0x1caa9c

void entry_1caa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1caa70) {
        switch (ctx->pc) {
            case 0x1caa7c: ctx->pc = 0; goto label_1caa7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1caa70: 0x38420002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 2));
    // 0x1caa74: 0x2800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x1caa78: 0x8e240b54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2900)));
label_1caa7c:
    // 0x1caa7c: 0x1204000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1CAABC; return;
    }
    // 0x1caa84: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1caa9c(rdram, ctx, runtime); return;
    }
    // 0x1caa8c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1caa90: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1caa94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1caa9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1caa9c
// Address: 0x1caa9c - 0x1caab4

void entry_1caa9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caa9c: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1caab4(rdram, ctx, runtime); return;
    }
    // 0x1caaa4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1caaa8: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1caaac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1caab4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1caab4
// Address: 0x1caab4 - 0x1caad0

void entry_1caab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1caab4) {
        switch (ctx->pc) {
            case 0x1caabc: ctx->pc = 0; goto label_1caabc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1caab4: 0xae300b54
    WRITE32(ADD32(GPR_U32(ctx, 17), 2900), GPR_U32(ctx, 16));
    // 0x1caab8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1caabc:
    // 0x1caabc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1caac0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1caac4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1caac8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001caad0
// Address: 0x1caad0 - 0x1caaec

void FUN_001caad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caad0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1caad4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1caad8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1caadc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1caae0: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1caae4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1caaec);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1caaec
// Address: 0x1caaec - 0x1cab00

void entry_1caaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caaec: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1caaf0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1caaf4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1caaf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepguardEnemyObject__FP9STEPGUARDP2SO
// Address: 0x1cab00 - 0x1cab10

void entry_1cab3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cab3c) {
        switch (ctx->pc) {
            case 0x1caba0: ctx->pc = 0; goto label_1caba0;
            case 0x1cabec: ctx->pc = 0; goto label_1cabec;
            case 0x1cac04: ctx->pc = 0; goto label_1cac04;
            case 0x1cac0c: ctx->pc = 0; goto label_1cac0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cab3c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cab40: 0xda020100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1cab44: 0x7a020150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1cab48: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cab4c: 0x8c634cf0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 19696)));
    // 0x1cab50: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cab54: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x1cab58: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1cab5c: 0xafa00088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 0));
    // 0x1cab60: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cab64: 0xc441da90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294957712)); ctx->f[1] = *(float*)&val; }
    // 0x1cab68: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cab6c: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cab70: 0x4be30848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cab74: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cab78: 0x18800024
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_1cac0c;
    }
    // 0x1cab80: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cab84: 0x8e070b48
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 2888)));
    // 0x1cab88: 0x4be41b3c
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cab8c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cab90: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cab94: 0x4be50b3c
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cab98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cab9c: 0x0
    // NOP
label_1caba0:
    // 0x1caba0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1caba4: 0x78620150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1caba8: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x1cabac: 0xafa00088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 0));
    // 0x1cabb0: 0xd8620100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x1cabb4: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cabb8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cabbc: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cabc0: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cabc4: 0x4be2286c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cabc8: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cabcc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cabd0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cabd4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cabd8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cabdc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cabe0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cabe4: 0x50670001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 7)) {
        ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
        goto label_1cabec;
    }
label_1cabec:
    // 0x1cabec: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cabf0: 0x0
    // NOP
    // 0x1cabf4: 0x45000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cac04;
    }
    // 0x1cabfc: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1cac00: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1cac04:
    // 0x1cac04: 0x14a0ffe6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1caba0;
    }
label_1cac0c:
    // 0x1cac0c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cac10: 0xae060b48
    WRITE32(ADD32(GPR_U32(ctx, 16), 2888), GPR_U32(ctx, 6));
    // 0x1cac14: 0xae020b40
    WRITE32(ADD32(GPR_U32(ctx, 16), 2880), GPR_U32(ctx, 2));
    // 0x1cac18: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cac1c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cac20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cac28__FP9STEPGUARD
// Address: 0x1cac28 - 0x1cac30

void FUN_001cac28__FP9STEPGUARD(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cac28: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 2896), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cac30
// Address: 0x1cac30 - 0x1cac80

void FUN_001cac30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cac30) {
        switch (ctx->pc) {
            case 0x1cac6c: ctx->pc = 0; goto label_1cac6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cac30: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1cac34: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1cac38: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1cac3c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cac40: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1cac44: 0x8e220c04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3076)));
    // 0x1cac48: 0x10400008
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cac6c;
    }
    // 0x1cac50: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cac54: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cac58: 0xc4404cf4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19700)); ctx->f[0] = *(float*)&val; }
    // 0x1cac5c: 0xc4614cf8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19704)); ctx->f[1] = *(float*)&val; }
    // 0x1cac60: 0xe6000094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    // 0x1cac64: 0x1000000d
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 152), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAC9C; return;
    }
label_1cac6c:
    // 0x1cac6c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cac70: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cac74: 0x8c620168
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 360)));
    // 0x1cac78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cac80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cac80
// Address: 0x1cac80 - 0x1cacb0

void entry_1cac80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cac80) {
        switch (ctx->pc) {
            case 0x1cac98: ctx->pc = 0; goto label_1cac98;
            case 0x1cac9c: ctx->pc = 0; goto label_1cac9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cac80: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
        goto label_1cac98;
    }
    // 0x1cac88: 0xc6200be8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3048)); ctx->f[0] = *(float*)&val; }
    // 0x1cac8c: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
    // 0x1cac90: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cac9c;
    }
label_1cac98:
    // 0x1cac98: 0xae000094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 0));
label_1cac9c:
    // 0x1cac9c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1caca0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1caca4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1caca8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustStepguardDz__FP9STEPGUARDiP2DZif
// Address: 0x1cacb0 - 0x1cacd4

void entry_1cacd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cacd4) {
        switch (ctx->pc) {
            case 0x1cad10: ctx->pc = 0; goto label_1cad10;
            case 0x1cad14: ctx->pc = 0; goto label_1cad14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cacd4: 0x8e020c04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3076)));
    // 0x1cacd8: 0x1040000d
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 18));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cad10;
    }
    // 0x1cace0: 0x24020012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    // 0x1cace4: 0x1462000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1cad14;
    }
    // 0x1cacec: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cacf0: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1cacf4: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1cacf8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cacfc: 0xc4400088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 136)); ctx->f[0] = *(float*)&val; }
    // 0x1cad00: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cad04: 0x0
    // NOP
    // 0x1cad08: 0x45030002
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 48), GPR_U32(ctx, 0));
        goto label_1cad14;
    }
label_1cad10:
    // 0x1cad10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1cad14:
    // 0x1cad14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cad18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cad1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cad20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepguardAttackAngleMax__FP9STEPGUARDf
// Address: 0x1cad28 - 0x1cad40

void entry_1cad50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cad50: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cad54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cad5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cad60; return;
}


// Function: MatchStepguardAnimationPhase__FP9STEPGUARD3OIDN31
// Address: 0x1cad60 - 0x1cad98

void entry_1cade8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cade8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cadec: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1cadf0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cadf8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cadf8
// Address: 0x1cadf8 - 0x1cae18

void entry_1cadf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cadf8: 0x5222000a
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2680)));
        ctx->pc = 0x1CAE24; return;
    }
    // 0x1cae00: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1cae04: 0x1440002c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAEB8; return;
    }
    // 0x1cae0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cae10: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1cae18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 76));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1cae18
// Address: 0x1cae18 - 0x1cae40

void entry_1cae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cae18) {
        switch (ctx->pc) {
            case 0x1cae24: ctx->pc = 0; goto label_1cae24;
            case 0x1cae38: ctx->pc = 0; goto label_1cae38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cae18: 0x10400027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAEB8; return;
    }
    // 0x1cae20: 0x8e420a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2680)));
label_1cae24:
    // 0x1cae24: 0x18400023
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CAEB4; return;
    }
    // 0x1cae2c: 0x34178000
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1cae30: 0x17be78
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 23) << 25);
    // 0x1cae34: 0x26500a7c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 2684));
label_1cae38:
    // 0x1cae38: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1cae40);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1cae40
// Address: 0x1cae40 - 0x1cae78

void entry_1cae40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cae40: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2680)));
        ctx->pc = 0x1CAEA4; return;
    }
    // 0x1cae48: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1cae4c: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1cae50: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAE80; return;
    }
    // 0x1cae58: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cae5c: 0xc62c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1cae60: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1cae64: 0x8cc703f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 1008)));
    // 0x1cae68: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cae6c: 0x8cc803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 1016)));
    // 0x1cae70: 0xc061e70
    SET_GPR_U32(ctx, 31, 0x1cae78);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 18), 2732));
    MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1cae78
// Address: 0x1cae78 - 0x1caea0

void entry_1cae78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cae78) {
        switch (ctx->pc) {
            case 0x1cae80: ctx->pc = 0; goto label_1cae80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cae78: 0x1000000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2680)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAEA4; return;
    }
label_1cae80:
    // 0x1cae80: 0x12800007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        entry_1caea0(rdram, ctx, runtime); return;
    }
    // 0x1cae88: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cae8c: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cae90: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cae94: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1cae98: 0xc061aea
    SET_GPR_U32(ctx, 31, 0x1caea0);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 2732));
    MarkSoContactsBspBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1caea0
// Address: 0x1caea0 - 0x1caee0

void entry_1caea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1caea0) {
        switch (ctx->pc) {
            case 0x1caea4: ctx->pc = 0; goto label_1caea4;
            case 0x1caeb4: ctx->pc = 0; goto label_1caeb4;
            case 0x1caeb8: ctx->pc = 0; goto label_1caeb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1caea0: 0x8e420a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2680)));
label_1caea4:
    // 0x1caea4: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1caea8: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1caeac: 0x1440ffe2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CAE38; return;
    }
label_1caeb4:
    // 0x1caeb4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1caeb8:
    // 0x1caeb8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1caebc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1caec0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1caec4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1caec8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1caecc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1caed0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1caed4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1caed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001caee0
// Address: 0x1caee0 - 0x1caf04

void FUN_001caee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caee0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1caee4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1caee8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1caeec: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1caef0: 0x24850ab0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 2736));
    // 0x1caef4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1caef8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1caefc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1caf04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1caf04
// Address: 0x1caf04 - 0x1caf10

void entry_1caf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caf04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1caf08: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1caf10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1caf10
// Address: 0x1caf10 - 0x1caf24

void entry_1caf10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caf10: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1caf24(rdram, ctx, runtime); return;
    }
    // 0x1caf18: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1caf1c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1caf24);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1caf24
// Address: 0x1caf24 - 0x1caf38

void entry_1caf24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1caf24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1caf28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1caf2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1caf34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1caf38; return;
}


// Function: UpdateStepguardEffect__FP9STEPGUARD
// Address: 0x1caf38 - 0x1caf78

void entry_1caf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1caf78) {
        switch (ctx->pc) {
            case 0x1cafb4: ctx->pc = 0; goto label_1cafb4;
            case 0x1cb024: ctx->pc = 0; goto label_1cb024;
            case 0x1cb028: ctx->pc = 0; goto label_1cb028;
            case 0x1cb064: ctx->pc = 0; goto label_1cb064;
            case 0x1cb0a0: ctx->pc = 0; goto label_1cb0a0;
            case 0x1cb0a4: ctx->pc = 0; goto label_1cb0a4;
            case 0x1cb0b0: ctx->pc = 0; goto label_1cb0b0;
            case 0x1cb0d0: ctx->pc = 0; goto label_1cb0d0;
            case 0x1cb0d4: ctx->pc = 0; goto label_1cb0d4;
            case 0x1cb0dc: ctx->pc = 0; goto label_1cb0dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1caf78: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1caf7c: 0x106000df
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB2FC; return;
    }
    // 0x1caf84: 0x8e620c04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3076)));
    // 0x1caf88: 0x544000d8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x1CB2EC; return;
    }
    // 0x1caf90: 0x8e660aac
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 2732)));
    // 0x1caf94: 0x10c000d4
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB2E8; return;
    }
    // 0x1caf9c: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1cafa0: 0x10640004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_1cafb4;
    }
    // 0x1cafa8: 0x8e620b50
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2896)));
    // 0x1cafac: 0x1462003d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1cb0a4;
    }
label_1cafb4:
    // 0x1cafb4: 0x8e620ac0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2752)));
    // 0x1cafb8: 0x1440003a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb0a4;
    }
    // 0x1cafc0: 0x8c822200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8704)));
    // 0x1cafc4: 0x10400037
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb0a4;
    }
    // 0x1cafcc: 0x8c420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cafd0: 0x10400034
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb0a4;
    }
    // 0x1cafd8: 0x8c420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1cafdc: 0x14530031
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        goto label_1cb0a4;
    }
    // 0x1cafe4: 0x8c83223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8764)));
    // 0x1cafe8: 0x28620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    // 0x1cafec: 0x1040000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb024;
    }
    // 0x1caff4: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 11792)));
        goto label_1cb028;
    }
    // 0x1caffc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cb000: 0xc4822240
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8768)); ctx->f[2] = *(float*)&val; }
    // 0x1cb004: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cb008: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cb00c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cb010: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cb014: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cb018: 0x0
    // NOP
    // 0x1cb01c: 0x450300b3
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x1CB2EC; return;
    }
label_1cb024:
    // 0x1cb024: 0x8ca42e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 11792)));
label_1cb028:
    // 0x1cb028: 0x2403000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1cb02c: 0x8c822220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1cb030: 0x5443000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
        goto label_1cb064;
    }
    // 0x1cb038: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cb03c: 0xc4822224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x1cb040: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cb044: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cb048: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cb04c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cb050: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cb054: 0x0
    // NOP
    // 0x1cb058: 0x450300a4
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x1CB2EC; return;
    }
    // 0x1cb060: 0x8c832228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
label_1cb064:
    // 0x1cb064: 0x28620009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    // 0x1cb068: 0x1040000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb0a0;
    }
    // 0x1cb070: 0x1440000c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb0a4;
    }
    // 0x1cb078: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cb07c: 0xc482222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1cb080: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cb084: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cb088: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cb08c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cb090: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cb094: 0x0
    // NOP
    // 0x1cb098: 0x45030094
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x1CB2EC; return;
    }
label_1cb0a0:
    // 0x1cb0a0: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_1cb0a4:
    // 0x1cb0a4: 0x12400090
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB2E8; return;
    }
    // 0x1cb0ac: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1cb0b0:
    // 0x1cb0b0: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb0b4: 0x26700a80
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 2688));
    // 0x1cb0b8: 0x26740a7c
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 19), 2684));
    // 0x1cb0bc: 0x731826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x1cb0c0: 0x3a82b
    SET_GPR_U32(ctx, 21, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1cb0c4: 0x151180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 6));
    // 0x1cb0c8: 0x10000004
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cb0dc;
    }
label_1cb0d0:
    // 0x1cb0d0: 0x2610000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
label_1cb0d4:
    // 0x1cb0d4: 0x2694000c
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 12));
    // 0x1cb0d8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_1cb0dc:
    // 0x1cb0dc: 0x8e620a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2680)));
    // 0x1cb0e0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cb0e4: 0x5040007e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x1CB2E0; return;
    }
    // 0x1cb0ec: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cb0f0: 0x8ec20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x1cb0f4: 0x1482fff6
    SET_GPR_U32(ctx, 23, SLL32(GPR_U32(ctx, 21), 6));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1cb0d0;
    }
    // 0x1cb0fc: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1cb104);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1cb104
// Address: 0x1cb104 - 0x1cb138

void entry_1cb104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb104: 0x5040fff3
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
        ctx->pc = 0x1CB0D4; return;
    }
    // 0x1cb10c: 0x8e620a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2680)));
    // 0x1cb110: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cb114: 0x10400071
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB2DC; return;
    }
    // 0x1cb11c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1cb120: 0x751023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1cb124: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1cb128: 0x2428021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1cb12c: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cb130: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1cb138);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1cb138
// Address: 0x1cb138 - 0x1cb14c

void entry_1cb138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb138: 0x10400040
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB23C; return;
    }
    // 0x1cb140: 0x8e850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1cb144: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1cb14c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1cb14c
// Address: 0x1cb14c - 0x1cb1b8

void entry_1cb14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb14c) {
        switch (ctx->pc) {
            case 0x1cb184: ctx->pc = 0; goto label_1cb184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb14c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb150: 0x1060000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1cb184;
    }
    // 0x1cb158: 0x54620032
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1CB224; return;
    }
    // 0x1cb160: 0x8e620b1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2844)));
    // 0x1cb164: 0x10400007
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb184;
    }
    // 0x1cb16c: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1cb170: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cb174: 0x3c03001d
    SET_GPR_U32(ctx, 3, ((uint32_t)29 << 16));
    // 0x1cb178: 0x2463aee0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294946528));
    // 0x1cb17c: 0x10000027
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB21C; return;
    }
label_1cb184:
    // 0x1cb184: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cb188: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb18c: 0x553023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1cb190: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1cb194: 0x2571021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 23)));
    // 0x1cb198: 0x63180
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 6));
    // 0x1cb19c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1cb1a0: 0x2463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 6)));
    // 0x1cb1a4: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1cb1a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb1ac: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb1b0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1cb1b8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1cb1b8
// Address: 0x1cb1b8 - 0x1cb1f8

void entry_1cb1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb1b8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cb1bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cb1c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cb1c4: 0xc4404cfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19708)); ctx->f[0] = *(float*)&val; }
    // 0x1cb1c8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cb1cc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb1d0: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1cb1d4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1cb1d8: 0xc46c4d04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19716)); ctx->f[12] = *(float*)&val; }
    // 0x1cb1dc: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cb1e0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1cb1e4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1cb1e8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cb1ec: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cb1f0: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x1cb1f8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_1cb1f8
// Address: 0x1cb1f8 - 0x1cb234

void entry_1cb1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb1f8) {
        switch (ctx->pc) {
            case 0x1cb21c: ctx->pc = 0; goto label_1cb21c;
            case 0x1cb224: ctx->pc = 0; goto label_1cb224;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb1f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cb1fc: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1cb200: 0xc4404d00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19712)); ctx->f[0] = *(float*)&val; }
    // 0x1cb204: 0x3c03001d
    SET_GPR_U32(ctx, 3, ((uint32_t)29 << 16));
    // 0x1cb208: 0x2463aee0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294946528));
    // 0x1cb20c: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1cb210: 0xafa3000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 3));
    // 0x1cb214: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1cb218: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1cb21c:
    // 0x1cb21c: 0x7e620ab0
    WRITE128(ADD32(GPR_U32(ctx, 19), 2736), GPR_VEC(ctx, 2));
    // 0x1cb220: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1cb224:
    // 0x1cb224: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cb228: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1cb22c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cb234);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cb234
// Address: 0x1cb234 - 0x1cb24c

void entry_1cb234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb234) {
        switch (ctx->pc) {
            case 0x1cb23c: ctx->pc = 0; goto label_1cb23c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb234: 0x10000019
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2680)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB29C; return;
    }
label_1cb23c:
    // 0x1cb23c: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cb240: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb244: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1cb24c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1cb24c
// Address: 0x1cb24c - 0x1cb280

void entry_1cb24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb24c: 0x7a630140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1cb250: 0x2571021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 23)));
    // 0x1cb254: 0xafb10034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 17));
    // 0x1cb258: 0x26060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1cb25c: 0x7fa30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 3));
    // 0x1cb260: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb264: 0xafb30030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 19));
    // 0x1cb268: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cb26c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb270: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb274: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1cb278: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1cb280);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1cb280
// Address: 0x1cb280 - 0x1cb298

void entry_1cb280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb280: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1cb284: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cb288: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x1cb28c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb290: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1cb298);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1cb298
// Address: 0x1cb298 - 0x1cb2c4

void entry_1cb298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb298) {
        switch (ctx->pc) {
            case 0x1cb29c: ctx->pc = 0; goto label_1cb29c;
            case 0x1cb2b0: ctx->pc = 0; goto label_1cb2b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb298: 0x8e620a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2680)));
label_1cb29c:
    // 0x1cb29c: 0x18400012
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CB2E8; return;
    }
    // 0x1cb2a4: 0x26700a80
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 2688));
    // 0x1cb2a8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cb2ac: 0x0
    // NOP
label_1cb2b0:
    // 0x1cb2b0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1cb2b4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cb2b8: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1cb2bc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1cb2c4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1cb2c4
// Address: 0x1cb2c4 - 0x1cb2f4

void entry_1cb2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb2c4) {
        switch (ctx->pc) {
            case 0x1cb2dc: ctx->pc = 0; goto label_1cb2dc;
            case 0x1cb2e0: ctx->pc = 0; goto label_1cb2e0;
            case 0x1cb2e8: ctx->pc = 0; goto label_1cb2e8;
            case 0x1cb2ec: ctx->pc = 0; goto label_1cb2ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb2c4: 0x8e620a78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2680)));
    // 0x1cb2c8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cb2cc: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1CB2B0; return;
    }
    // 0x1cb2d4: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cb2ec;
    }
label_1cb2dc:
    // 0x1cb2dc: 0x8e5200d0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
label_1cb2e0:
    // 0x1cb2e0: 0x5640ff73
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1CB0B0; return;
    }
label_1cb2e8:
    // 0x1cb2e8: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
label_1cb2ec:
    // 0x1cb2ec: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1cb2f4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 2732)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1cb2f4
// Address: 0x1cb2f4 - 0x1cb328

void entry_1cb2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb2f4) {
        switch (ctx->pc) {
            case 0x1cb2fc: ctx->pc = 0; goto label_1cb2fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb2f4: 0xae600aac
    WRITE32(ADD32(GPR_U32(ctx, 19), 2732), GPR_U32(ctx, 0));
    // 0x1cb2f8: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_1cb2fc:
    // 0x1cb2fc: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cb300: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1cb304: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cb308: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cb30c: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cb310: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1cb314: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cb318: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cb31c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cb320: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetStepguardPatrolAnimation__FP9STEPGUARDP4ASEG
// Address: 0x1cb328 - 0x1cb360

void entry_1cb360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb360) {
        switch (ctx->pc) {
            case 0x1cb368: ctx->pc = 0; goto label_1cb368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb360: 0xae000754
    WRITE32(ADD32(GPR_U32(ctx, 16), 1876), GPR_U32(ctx, 0));
    // 0x1cb364: 0xae110750
    WRITE32(ADD32(GPR_U32(ctx, 16), 1872), GPR_U32(ctx, 17));
label_1cb368:
    // 0x1cb368: 0xc0725ae
    SET_GPR_U32(ctx, 31, 0x1cb370);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SggsGetStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1cb370
// Address: 0x1cb370 - 0x1cb3ac

void entry_1cb370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb370) {
        switch (ctx->pc) {
            case 0x1cb38c: ctx->pc = 0; goto label_1cb38c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb370: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
        goto label_1cb38c;
    }
    // 0x1cb378: 0x8e02072c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1836)));
    // 0x1cb37c: 0xae000730
    WRITE32(ADD32(GPR_U32(ctx, 16), 1840), GPR_U32(ctx, 0));
    // 0x1cb380: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x1cb384: 0xae02072c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1836), GPR_U32(ctx, 2));
    // 0x1cb388: 0x8e040750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
label_1cb38c:
    // 0x1cb38c: 0x10800007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1cb3ac(rdram, ctx, runtime); return;
    }
    // 0x1cb394: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1cb398: 0x24a60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 5), 320));
    // 0x1cb39c: 0x24a70918
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 2328));
    // 0x1cb3a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb3a4: 0xc04b27a
    SET_GPR_U32(ctx, 31, 0x1cb3ac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FindAsegClosestPoint__FP4ASEGP3ALOP6VECTORfPfT2T2(rdram, ctx, runtime); return;
}


// Function: entry_1cb3ac
// Address: 0x1cb3ac - 0x1cb3c0

void entry_1cb3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb3ac) {
        switch (ctx->pc) {
            case 0x1cb3b0: ctx->pc = 0; goto label_1cb3b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb3ac: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1cb3b0:
    // 0x1cb3b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb3b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb3b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FInflictStepguardZap__FP9STEPGUARDP2XPP3ZPR
// Address: 0x1cb3c0 - 0x1cb3c8

void entry_1cb3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb3f4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cb3f8: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1cb3fc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1cb404);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1cb404
// Address: 0x1cb404 - 0x1cb46c

void entry_1cb404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb404) {
        switch (ctx->pc) {
            case 0x1cb454: ctx->pc = 0; goto label_1cb454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb404: 0x10400055
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB55C; return;
    }
    // 0x1cb40c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1cb410: 0x14620053
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CB560; return;
    }
    // 0x1cb418: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1cb41c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cb420: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1cb424: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cb428: 0x4be3133c
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1cb42c: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cb430: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x1cb434: 0x1062002b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CB4E4; return;
    }
    // 0x1cb43c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb454;
    }
    // 0x1cb444: 0x10600010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB488; return;
    }
    // 0x1cb44c: 0x10000045
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB564; return;
    }
label_1cb454:
    // 0x1cb454: 0x1062003d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CB54C; return;
    }
    // 0x1cb45c: 0x14620040
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CB560; return;
    }
    // 0x1cb464: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1cb46c);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cb46c
// Address: 0x1cb46c - 0x1cb578

void entry_1cb46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb46c) {
        switch (ctx->pc) {
            case 0x1cb488: ctx->pc = 0; goto label_1cb488;
            case 0x1cb4a4: ctx->pc = 0; goto label_1cb4a4;
            case 0x1cb4bc: ctx->pc = 0; goto label_1cb4bc;
            case 0x1cb4e4: ctx->pc = 0; goto label_1cb4e4;
            case 0x1cb500: ctx->pc = 0; goto label_1cb500;
            case 0x1cb518: ctx->pc = 0; goto label_1cb518;
            case 0x1cb53c: ctx->pc = 0; goto label_1cb53c;
            case 0x1cb54c: ctx->pc = 0; goto label_1cb54c;
            case 0x1cb55c: ctx->pc = 0; goto label_1cb55c;
            case 0x1cb560: ctx->pc = 0; goto label_1cb560;
            case 0x1cb564: ctx->pc = 0; goto label_1cb564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb46c: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x1cb470: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1cb474: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1cb478: 0x10400038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb55c;
    }
    // 0x1cb480: 0x10000038
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cb564;
    }
label_1cb488:
    // 0x1cb488: 0x8e0223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
    // 0x1cb48c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9128)));
        goto label_1cb4a4;
    }
    // 0x1cb494: 0x8c420054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x1cb498: 0x14400031
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb560;
    }
    // 0x1cb4a0: 0x8e0223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9128)));
label_1cb4a4:
    // 0x1cb4a4: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
        goto label_1cb4bc;
    }
    // 0x1cb4ac: 0x8c42006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 108)));
    // 0x1cb4b0: 0x1440002b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb560;
    }
    // 0x1cb4b8: 0xda010110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
label_1cb4bc:
    // 0x1cb4bc: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cb4c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cb4c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cb4c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cb4cc: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1cb4d0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cb4d4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cb4d8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cb4dc: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cb53c;
    }
label_1cb4e4:
    // 0x1cb4e4: 0x8e0223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
    // 0x1cb4e8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9128)));
        goto label_1cb500;
    }
    // 0x1cb4f0: 0x8c420054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x1cb4f4: 0x1440001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb560;
    }
    // 0x1cb4fc: 0x8e0223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9128)));
label_1cb500:
    // 0x1cb500: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
        goto label_1cb518;
    }
    // 0x1cb508: 0x8c42006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 108)));
    // 0x1cb50c: 0x14400014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb560;
    }
    // 0x1cb514: 0xda010110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
label_1cb518:
    // 0x1cb518: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cb51c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cb520: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cb524: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cb528: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1cb52c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cb530: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cb534: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cb538: 0x0
    // NOP
label_1cb53c:
    // 0x1cb53c: 0x45000007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cb55c;
    }
    // 0x1cb544: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cb564;
    }
label_1cb54c:
    // 0x1cb54c: 0x8e042228
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x1cb550: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1cb554: 0x10830002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1cb560;
    }
label_1cb55c:
    // 0x1cb55c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1cb560:
    // 0x1cb560: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1cb564:
    // 0x1cb564: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cb568: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb56c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cb574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cb578; return;
}


// Function: FUN_001cb578
// Address: 0x1cb578 - 0x1cb5b8

void FUN_001cb578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb578) {
        switch (ctx->pc) {
            case 0x1cb5ac: ctx->pc = 0; goto label_1cb5ac;
            case 0x1cb5b0: ctx->pc = 0; goto label_1cb5b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb578: 0x8c820b7c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 2940)));
    // 0x1cb57c: 0x1440000b
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cb5ac;
    }
    // 0x1cb584: 0x8c820b80
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 2944)));
    // 0x1cb588: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1cb5b0;
    }
    // 0x1cb590: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cb594: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1cb598: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb5b0;
    }
    // 0x1cb5a0: 0x8c42275c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 10076)));
    // 0x1cb5a4: 0x10400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb5b0;
    }
label_1cb5ac:
    // 0x1cb5ac: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_1cb5b0:
    // 0x1cb5b0: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsggNew__FP2SW
// Address: 0x1cb5b8 - 0x1cb5dc

void entry_1cb5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb5dc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cb5e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cb5e4: 0x8c645710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1cb5e8: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1cb5ec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cb5f0: 0x24a5b8b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294949048));
    // 0x1cb5f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cb5f8: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1cb600);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1cb600
// Address: 0x1cb600 - 0x1cb618

void entry_1cb600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb600: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cb604: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb608: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb60c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cb614: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cb618; return;
}


// Function: InitSgg__FP3SGG
// Address: 0x1cb618 - 0x1cb62c

void entry_1cb62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb62c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1cb630: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb634: 0xae020180
    WRITE32(ADD32(GPR_U32(ctx, 16), 384), GPR_U32(ctx, 2));
    // 0x1cb638: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb63c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cb644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cb648; return;
}


// Function: AddSggGuard__FP3SGGP9STEPGUARD
// Address: 0x1cb648 - 0x1cb670

void entry_1cb670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb670) {
        switch (ctx->pc) {
            case 0x1cb690: ctx->pc = 0; goto label_1cb690;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb670: 0x8e030058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x1cb674: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x1cb678: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb690;
    }
    // 0x1cb680: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1cb684: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1cb688: 0xac51005c
    WRITE32(ADD32(GPR_U32(ctx, 2), 92), GPR_U32(ctx, 17));
    // 0x1cb68c: 0xae030058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 3));
label_1cb690:
    // 0x1cb690: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cb694: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb698: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb69c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cb6a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cb6a8; return;
}


// Function: AddSggGuardName__FP3SGG3OID
// Address: 0x1cb6a8 - 0x1cb6d0

void entry_1cb774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb774: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x1cb778: 0x1c400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1CB790; return;
    }
    // 0x1cb780: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cb784: 0xc072fba
    SET_GPR_U32(ctx, 31, 0x1cb78c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetSggSggs__FP3SGG4SGGS(rdram, ctx, runtime); return;
}


// Function: entry_1cb78c
// Address: 0x1cb78c - 0x1cb7a0

void entry_1cb78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb78c) {
        switch (ctx->pc) {
            case 0x1cb790: ctx->pc = 0; goto label_1cb790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb78c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1cb790:
    // 0x1cb790: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb794: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cb79c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cb7a0; return;
}


// Function: BindSgg__FP3SGG
// Address: 0x1cb7a0 - 0x1cb7e8

void entry_1cb7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb7e8) {
        switch (ctx->pc) {
            case 0x1cb818: ctx->pc = 0; goto label_1cb818;
            case 0x1cb81c: ctx->pc = 0; goto label_1cb81c;
            case 0x1cb82c: ctx->pc = 0; goto label_1cb82c;
            case 0x1cb848: ctx->pc = 0; goto label_1cb848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb7e8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cb7ec: 0x5080000b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
        goto label_1cb81c;
    }
    // 0x1cb7f4: 0x8e030058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x1cb7f8: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x1cb7fc: 0x10400006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb818;
    }
    // 0x1cb804: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1cb808: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1cb80c: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1cb810: 0xae030058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 3));
    // 0x1cb814: 0xac900720
    WRITE32(ADD32(GPR_U32(ctx, 4), 1824), GPR_U32(ctx, 16));
label_1cb818:
    // 0x1cb818: 0x8e02009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
label_1cb81c:
    // 0x1cb81c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1cb820: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1cb824: 0x1440ffec
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB7D8; return;
    }
label_1cb82c:
    // 0x1cb82c: 0x8e020124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 292)));
    // 0x1cb830: 0x18400019
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CB898; return;
    }
    // 0x1cb838: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1cb83c: 0x261300e4
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 228));
    // 0x1cb840: 0x26110128
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 296));
    // 0x1cb844: 0x0
    // NOP
label_1cb848:
    // 0x1cb848: 0x8e845710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 22288)));
    // 0x1cb84c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cb850: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1cb858);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1cb858
// Address: 0x1cb858 - 0x1cb8b8

void entry_1cb858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb858) {
        switch (ctx->pc) {
            case 0x1cb884: ctx->pc = 0; goto label_1cb884;
            case 0x1cb888: ctx->pc = 0; goto label_1cb888;
            case 0x1cb898: ctx->pc = 0; goto label_1cb898;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb858: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cb85c: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 292)));
        goto label_1cb888;
    }
    // 0x1cb864: 0x8e0300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 224)));
    // 0x1cb868: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x1cb86c: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cb884;
    }
    // 0x1cb874: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1cb878: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1cb87c: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1cb880: 0xae0300e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 224), GPR_U32(ctx, 3));
label_1cb884:
    // 0x1cb884: 0x8e020124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 292)));
label_1cb888:
    // 0x1cb888: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1cb88c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1cb890: 0x1440ffed
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB848; return;
    }
label_1cb898:
    // 0x1cb898: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cb89c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cb8a0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cb8a4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cb8a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cb8ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cb8b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSggLoadCallback__FP3SGG5MSGIDPv
// Address: 0x1cb8b8 - 0x1cb8f0

void entry_1cb8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb8f0: 0x8e840058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cb8f4: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x1cb8fc);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1cb8fc
// Address: 0x1cb8fc - 0x1cb930

void entry_1cb8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb8fc) {
        switch (ctx->pc) {
            case 0x1cb918: ctx->pc = 0; goto label_1cb918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb8fc: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cb900: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cb904: 0x58400058
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x1CBA68; return;
    }
    // 0x1cb90c: 0x26f30004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 23), 4));
    // 0x1cb910: 0x2e0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cb914: 0x2691005c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 92));
label_1cb918:
    // 0x1cb918: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cb91c: 0x8ca40750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 1872)));
    // 0x1cb920: 0x10800003
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1cb930(rdram, ctx, runtime); return;
    }
    // 0x1cb928: 0xc04b46c
    SET_GPR_U32(ctx, 31, 0x1cb930);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_1cb930
// Address: 0x1cb930 - 0x1cb998

void entry_1cb930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb930) {
        switch (ctx->pc) {
            case 0x1cb960: ctx->pc = 0; goto label_1cb960;
            case 0x1cb978: ctx->pc = 0; goto label_1cb978;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb930: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cb934: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1cb938: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1cb93c: 0x26520008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    // 0x1cb940: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1cb944: 0x1440fff4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB918; return;
    }
    // 0x1cb94c: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cb950: 0x18400045
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CBA68; return;
    }
    // 0x1cb958: 0x1010c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    // 0x1cb95c: 0x0
    // NOP
label_1cb960:
    // 0x1cb960: 0x26160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1cb964: 0x2e2a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1cb968: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1cb96c: 0x18400039
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CBA54; return;
    }
    // 0x1cb974: 0x8ea20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4)));
label_1cb978:
    // 0x1cb978: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1cb97c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1cb980: 0x8c710000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cb984: 0x8e220328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 808)));
    // 0x1cb988: 0x1440002d
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBA40; return;
    }
    // 0x1cb990: 0xc07be8c
    SET_GPR_U32(ctx, 31, 0x1cb998);
    PwpsgNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cb998
// Address: 0x1cb998 - 0x1cb9ac

void entry_1cb998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cb998: 0xae220328
    WRITE32(ADD32(GPR_U32(ctx, 17), 808), GPR_U32(ctx, 2));
    // 0x1cb99c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cb9a0: 0xac54002c
    WRITE32(ADD32(GPR_U32(ctx, 2), 44), GPR_U32(ctx, 20));
    // 0x1cb9a4: 0xc07be98
    SET_GPR_U32(ctx, 31, 0x1cb9ac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 808)));
    AddWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_1cb9ac
// Address: 0x1cb9ac - 0x1cba18

void entry_1cb9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cb9ac) {
        switch (ctx->pc) {
            case 0x1cb9d0: ctx->pc = 0; goto label_1cb9d0;
            case 0x1cb9e8: ctx->pc = 0; goto label_1cb9e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cb9ac: 0x8e2202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 736)));
    // 0x1cb9b0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1cb9b4: 0x50430023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
        ctx->pc = 0x1CBA44; return;
    }
    // 0x1cb9bc: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cb9c0: 0x2c2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 2)));
    // 0x1cb9c4: 0x1040001e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBA40; return;
    }
    // 0x1cb9cc: 0x310c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
label_1cb9d0:
    // 0x1cb9d0: 0x24730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1cb9d4: 0x2e29021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1cb9d8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cb9dc: 0x18400013
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CBA2C; return;
    }
    // 0x1cb9e4: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1cb9e8:
    // 0x1cb9e8: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1cb9ec: 0x8e2402e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 736)));
    // 0x1cb9f0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1cb9f4: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cb9f8: 0x8c6202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 736)));
    // 0x1cb9fc: 0x54440007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1CBA1C; return;
    }
    // 0x1cba04: 0x8e220328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 808)));
    // 0x1cba08: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1cba0c: 0xac620328
    WRITE32(ADD32(GPR_U32(ctx, 3), 808), GPR_U32(ctx, 2));
    // 0x1cba10: 0xc07be98
    SET_GPR_U32(ctx, 31, 0x1cba18);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 808)));
    AddWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_1cba18
// Address: 0x1cba18 - 0x1cba70

void entry_1cba18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cba18) {
        switch (ctx->pc) {
            case 0x1cba1c: ctx->pc = 0; goto label_1cba1c;
            case 0x1cba2c: ctx->pc = 0; goto label_1cba2c;
            case 0x1cba40: ctx->pc = 0; goto label_1cba40;
            case 0x1cba44: ctx->pc = 0; goto label_1cba44;
            case 0x1cba54: ctx->pc = 0; goto label_1cba54;
            case 0x1cba68: ctx->pc = 0; goto label_1cba68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cba18: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1cba1c:
    // 0x1cba1c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1cba20: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1cba24: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x1CB9E8; return;
    }
label_1cba2c:
    // 0x1cba2c: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cba30: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cba34: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1cba38: 0x1440ffe5
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB9D0; return;
    }
label_1cba40:
    // 0x1cba40: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
label_1cba44:
    // 0x1cba44: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1cba48: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1cba4c: 0x5440ffca
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4)));
        ctx->pc = 0x1CB978; return;
    }
label_1cba54:
    // 0x1cba54: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1cba58: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cba5c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1cba60: 0x1440ffbf
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CB960; return;
    }
label_1cba68:
    // 0x1cba68: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1cba70);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cba70
// Address: 0x1cba70 - 0x1cbaa0

void entry_1cba70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cba70: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cba74: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cba78: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cba7c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cba80: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cba84: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cba88: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cba8c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cba90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cba94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cba98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureSggCallback__FP3SGG
// Address: 0x1cbaa0 - 0x1cbae8

void entry_1cbae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbae8) {
        switch (ctx->pc) {
            case 0x1cbaec: ctx->pc = 0; goto label_1cbaec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbae8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1cbaec:
    // 0x1cbaec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cbaf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cbaf8; return;
}


// Function: PsoEnemySgg__FP3SGG
// Address: 0x1cbaf8 - 0x1cbb14

void entry_1cbb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cbb14: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbb18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSggCallback__FP3SGG5MSGIDPv
// Address: 0x1cbb20 - 0x1cbb4c

void entry_1cbb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbb4c) {
        switch (ctx->pc) {
            case 0x1cbb58: ctx->pc = 0; goto label_1cbb58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbb4c: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 392), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1cbb60(rdram, ctx, runtime); return;
    }
    // 0x1cbb54: 0x0
    // NOP
label_1cbb58:
    // 0x1cbb58: 0xc072fba
    SET_GPR_U32(ctx, 31, 0x1cbb60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSggSggs__FP3SGG4SGGS(rdram, ctx, runtime); return;
}


// Function: entry_1cbb60
// Address: 0x1cbb60 - 0x1cbb68

void entry_1cbb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cbb60: 0xc072ee2
    SET_GPR_U32(ctx, 31, 0x1cbb68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SggsNextSgg__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1cbb68
// Address: 0x1cbb68 - 0x1cbb88

void entry_1cbb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbb68) {
        switch (ctx->pc) {
            case 0x1cbb78: ctx->pc = 0; goto label_1cbb78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbb68: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cbb6c: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1cbb70: 0x14a2fff9
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CBB58; return;
    }
label_1cbb78:
    // 0x1cbb78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbb7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cbb84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cbb88; return;
}


// Function: SggsNextSgg__FP3SGG
// Address: 0x1cbb88 - 0x1cbc10

void entry_1cbc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbc10) {
        switch (ctx->pc) {
            case 0x1cbc28: ctx->pc = 0; goto label_1cbc28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbc10: 0x1440fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBBF0; return;
    }
    // 0x1cbc18: 0x8e220058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    // 0x1cbc1c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1cbc20: 0x1440001e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBC9C; return;
    }
label_1cbc28:
    // 0x1cbc28: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1cbc2c: 0x2404003f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1cbc30: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1cbc34: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1cbc38: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cbc3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cbc40: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1cbc44: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1cbc48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cbc4c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cbc50: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1cbc54: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cbc58: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1cbc5c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cbc60: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1cbc68);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1cbc68
// Address: 0x1cbc68 - 0x1cbc8c

void entry_1cbc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbc68) {
        switch (ctx->pc) {
            case 0x1cbc70: ctx->pc = 0; goto label_1cbc70;
            case 0x1cbc84: ctx->pc = 0; goto label_1cbc84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbc68: 0x1000000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBC9C; return;
    }
label_1cbc70:
    // 0x1cbc70: 0x8e220188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 392)));
    // 0x1cbc74: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cbc84;
    }
    // 0x1cbc7c: 0x10000007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBC9C; return;
    }
label_1cbc84:
    // 0x1cbc84: 0xc072f56
    SET_GPR_U32(ctx, 31, 0x1cbc8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbandonSggSearch__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1cbc8c
// Address: 0x1cbc8c - 0x1cbcb8

void entry_1cbc8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbc8c) {
        switch (ctx->pc) {
            case 0x1cbc94: ctx->pc = 0; goto label_1cbc94;
            case 0x1cbc9c: ctx->pc = 0; goto label_1cbc9c;
            case 0x1cbca4: ctx->pc = 0; goto label_1cbca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbc8c: 0x10000003
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cbc9c;
    }
label_1cbc94:
    // 0x1cbc94: 0x8e220188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 392)));
    // 0x1cbc98: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
label_1cbc9c:
    // 0x1cbc9c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cbca0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1cbca4:
    // 0x1cbca4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cbca8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cbcac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbcb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FDetectSgg__FP3SGG
// Address: 0x1cbcb8 - 0x1cbd08

void entry_1cbd08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cbd08: 0x5040fff5
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x1CBCE0; return;
    }
    // 0x1cbd10: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cbd14: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cbd18: 0x10400008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBD3C; return;
    }
    // 0x1cbd20: 0xc072ebe
    SET_GPR_U32(ctx, 31, 0x1cbd28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PsoEnemySgg__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1cbd28
// Address: 0x1cbd28 - 0x1cbd58

void entry_1cbd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbd28) {
        switch (ctx->pc) {
            case 0x1cbd3c: ctx->pc = 0; goto label_1cbd3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbd28: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1cbd3c;
    }
    // 0x1cbd30: 0x78420140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1cbd34: 0x7e420040
    WRITE128(ADD32(GPR_U32(ctx, 18), 64), GPR_VEC(ctx, 2));
    // 0x1cbd38: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1cbd3c:
    // 0x1cbd3c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cbd40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cbd44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cbd48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbd4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cbd54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cbd58; return;
}


// Function: FAbandonSggSearch__FP3SGG
// Address: 0x1cbd58 - 0x1cbdac

void entry_1cbdac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbdac) {
        switch (ctx->pc) {
            case 0x1cbdd0: ctx->pc = 0; goto label_1cbdd0;
            case 0x1cbde0: ctx->pc = 0; goto label_1cbde0;
            case 0x1cbde4: ctx->pc = 0; goto label_1cbde4;
            case 0x1cbdf4: ctx->pc = 0; goto label_1cbdf4;
            case 0x1cbdf8: ctx->pc = 0; goto label_1cbdf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbdac: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cbdb0: 0x1075000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 21)) {
        goto label_1cbde0;
    }
    // 0x1cbdb8: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cbdd0;
    }
    // 0x1cbdc0: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1cbde0;
    }
    // 0x1cbdc8: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cbde4;
    }
label_1cbdd0:
    // 0x1cbdd0: 0x10740009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 20)) {
        goto label_1cbdf8;
    }
    // 0x1cbdd8: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cbde4;
    }
label_1cbde0:
    // 0x1cbde0: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
label_1cbde4:
    // 0x1cbde4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1cbde8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cbdec: 0x1440ffea
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBD98; return;
    }
label_1cbdf4:
    // 0x1cbdf4: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1cbdf8:
    // 0x1cbdf8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cbdfc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cbe00: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cbe04: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cbe08: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cbe0c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cbe10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbe14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cbe1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cbe20; return;
}


// Function: EnsureSggAlarm__FP3SGGP5ALARM
// Address: 0x1cbe20 - 0x1cbe70

void entry_1cbeb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbeb8) {
        switch (ctx->pc) {
            case 0x1cbec8: ctx->pc = 0; goto label_1cbec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbeb8: 0x8e420168
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 360)));
    // 0x1cbebc: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cbec0: 0x5440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1CBEA8; return;
    }
label_1cbec8:
    // 0x1cbec8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cbecc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cbed0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cbed4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cbed8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cbedc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cbee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cbee8; return;
}


// Function: SetSggSggs__FP3SGG4SGGS
// Address: 0x1cbee8 - 0x1cbf44

void entry_1cbf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbf44) {
        switch (ctx->pc) {
            case 0x1cbf60: ctx->pc = 0; goto label_1cbf60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbf44: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cbf48: 0x18400027
    WRITE32(ADD32(GPR_U32(ctx, 18), 388), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CBFE8; return;
    }
    // 0x1cbf50: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1cbf54: 0x27d71858
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1cbf58: 0x26964d18
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 20), 19736));
    // 0x1cbf5c: 0x2651005c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 92));
label_1cbf60:
    // 0x1cbf60: 0xc68c4d18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 19736)); ctx->f[12] = *(float*)&val; }
    // 0x1cbf64: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1cbf68: 0xc6cd0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1cbf6c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cbf74);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cbf74
// Address: 0x1cbf74 - 0x1cbfc8

void entry_1cbf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbf74) {
        switch (ctx->pc) {
            case 0x1cbf98: ctx->pc = 0; goto label_1cbf98;
            case 0x1cbfb8: ctx->pc = 0; goto label_1cbfb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbf74: 0xc6e10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1cbf78: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cbf7c: 0xe6010c00
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3072), *(uint32_t*)&val); }
    // 0x1cbf80: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cbf84: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1cbf88: 0x1440fff5
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBF60; return;
    }
    // 0x1cbf90: 0x10000016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBFEC; return;
    }
label_1cbf98:
    // 0x1cbf98: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cbf9c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cbfa0: 0x18400011
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CBFE8; return;
    }
    // 0x1cbfa8: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x1cbfac: 0x27d61858
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1cbfb0: 0x26744d08
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 19), 19720));
    // 0x1cbfb4: 0x2650005c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 92));
label_1cbfb8:
    // 0x1cbfb8: 0xc66c4d08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 19720)); ctx->f[12] = *(float*)&val; }
    // 0x1cbfbc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1cbfc0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cbfc8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cbfc8
// Address: 0x1cbfc8 - 0x1cc030

void entry_1cbfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cbfc8) {
        switch (ctx->pc) {
            case 0x1cbfe8: ctx->pc = 0; goto label_1cbfe8;
            case 0x1cbfec: ctx->pc = 0; goto label_1cbfec;
            case 0x1cc00c: ctx->pc = 0; goto label_1cc00c;
            case 0x1cc024: ctx->pc = 0; goto label_1cc024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cbfc8: 0xc6c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1cbfcc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cbfd0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cbfd4: 0xe4610bf4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 3060), *(uint32_t*)&val); }
    // 0x1cbfd8: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cbfdc: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cbfe0: 0x1440fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CBFB8; return;
    }
label_1cbfe8:
    // 0x1cbfe8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1cbfec:
    // 0x1cbfec: 0x12a20032
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), 2));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CC0B8; return;
    }
    // 0x1cbff4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cc00c;
    }
    // 0x1cbffc: 0x12a00032
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0C8; return;
    }
    // 0x1cc004: 0x10000037
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0E4; return;
    }
label_1cc00c:
    // 0x1cc00c: 0x12a20005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        goto label_1cc024;
    }
    // 0x1cc014: 0x12a20030
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CC0D8; return;
    }
    // 0x1cc01c: 0x10000031
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0E4; return;
    }
label_1cc024:
    // 0x1cc024: 0x2404006b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 107));
    // 0x1cc028: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x1cc030);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1cc030
// Address: 0x1cc030 - 0x1cc040

void entry_1cc030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc030: 0xae420184
    WRITE32(ADD32(GPR_U32(ctx, 18), 388), GPR_U32(ctx, 2));
    // 0x1cc034: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cc038: 0xc072f9c
    SET_GPR_U32(ctx, 31, 0x1cc040);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerSggAlarms__FP3SGG4ALTK(rdram, ctx, runtime); return;
}


// Function: entry_1cc040
// Address: 0x1cc040 - 0x1cc074

void entry_1cc040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc040) {
        switch (ctx->pc) {
            case 0x1cc060: ctx->pc = 0; goto label_1cc060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc040: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cc044: 0x18400026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1cc0e0(rdram, ctx, runtime); return;
    }
    // 0x1cc04c: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x1cc050: 0x24541858
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1cc054: 0x26d74d10
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 22), 19728));
    // 0x1cc058: 0x2651005c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 92));
    // 0x1cc05c: 0x0
    // NOP
label_1cc060:
    // 0x1cc060: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cc064: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cc068: 0x8c62016c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 364)));
    // 0x1cc06c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cc074);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cc074
// Address: 0x1cc074 - 0x1cc090

void entry_1cc074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc074) {
        switch (ctx->pc) {
            case 0x1cc088: ctx->pc = 0; goto label_1cc088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc074: 0x10400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 19728)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cc088;
    }
    // 0x1cc07c: 0xc6800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1cc080: 0x10000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3064), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC09C; return;
    }
label_1cc088:
    // 0x1cc088: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cc090);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cc090
// Address: 0x1cc090 - 0x1cc0c0

void entry_1cc090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc090) {
        switch (ctx->pc) {
            case 0x1cc09c: ctx->pc = 0; goto label_1cc09c;
            case 0x1cc0b8: ctx->pc = 0; goto label_1cc0b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc090: 0xc6810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1cc094: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cc098: 0xe6010bf8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3064), *(uint32_t*)&val); }
label_1cc09c:
    // 0x1cc09c: 0x8e420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 88)));
    // 0x1cc0a0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1cc0a4: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1cc0a8: 0x1440ffed
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC060; return;
    }
    // 0x1cc0b0: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0E4; return;
    }
label_1cc0b8:
    // 0x1cc0b8: 0xc073048
    SET_GPR_U32(ctx, 31, 0x1cc0c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AssignSggSearchPoints__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1cc0c0
// Address: 0x1cc0c0 - 0x1cc0d0

void entry_1cc0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc0c0) {
        switch (ctx->pc) {
            case 0x1cc0c8: ctx->pc = 0; goto label_1cc0c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc0c0: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0E4; return;
    }
label_1cc0c8:
    // 0x1cc0c8: 0xc072f9c
    SET_GPR_U32(ctx, 31, 0x1cc0d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    TriggerSggAlarms__FP3SGG4ALTK(rdram, ctx, runtime); return;
}


// Function: entry_1cc0d0
// Address: 0x1cc0d0 - 0x1cc0e0

void entry_1cc0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc0d0) {
        switch (ctx->pc) {
            case 0x1cc0d8: ctx->pc = 0; goto label_1cc0d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc0d0: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC0E4; return;
    }
label_1cc0d8:
    // 0x1cc0d8: 0xc072f9c
    SET_GPR_U32(ctx, 31, 0x1cc0e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    TriggerSggAlarms__FP3SGG4ALTK(rdram, ctx, runtime); return;
}


// Function: entry_1cc0e0
// Address: 0x1cc0e0 - 0x1cc120

void entry_1cc0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc0e0) {
        switch (ctx->pc) {
            case 0x1cc0e4: ctx->pc = 0; goto label_1cc0e4;
            case 0x1cc0f0: ctx->pc = 0; goto label_1cc0f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc0e0: 0xae550050
    WRITE32(ADD32(GPR_U32(ctx, 18), 80), GPR_U32(ctx, 21));
label_1cc0e4:
    // 0x1cc0e4: 0x27c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 6232));
    // 0x1cc0e8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1cc0ec: 0xe6400054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 84), *(uint32_t*)&val); }
label_1cc0f0:
    // 0x1cc0f0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cc0f4: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cc0f8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cc0fc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cc100: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cc104: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cc108: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cc10c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cc110: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cc114: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cc118: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AssignSggSearchPoints__FP3SGG
// Address: 0x1cc120 - 0x1cc168

void entry_1cc168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc168: 0x8e6400e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 224)));
    // 0x1cc16c: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x1cc174);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1cc174
// Address: 0x1cc174 - 0x1cc1f0

void entry_1cc174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc174) {
        switch (ctx->pc) {
            case 0x1cc1a8: ctx->pc = 0; goto label_1cc1a8;
            case 0x1cc1d8: ctx->pc = 0; goto label_1cc1d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc174: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cc178: 0x8e640058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 88)));
    // 0x1cc17c: 0x8e6200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 224)));
    // 0x1cc180: 0x82282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1cc184: 0x85100b
    if (GPR_U32(ctx, 5) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x1cc188: 0x18400048
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1CC2AC; return;
    }
    // 0x1cc190: 0x2664005c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 92));
    // 0x1cc194: 0xafa20054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    // 0x1cc198: 0x267700e4
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 19), 228));
    // 0x1cc19c: 0xafa40050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 4));
    // 0x1cc1a0: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cc1a4: 0x0
    // NOP
label_1cc1a8:
    // 0x1cc1a8: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1cc1ac: 0x8e6300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 224)));
    // 0x1cc1b0: 0x26360001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1cc1b4: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1cc1b8: 0x2415ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1cc1bc: 0x8c540000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cc1c0: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc1c4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cc1c8: 0x18600020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294957716)); ctx->f[20] = *(float*)&val; }
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1CC24C; return;
    }
    // 0x1cc1d0: 0x2e0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cc1d4: 0x3c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_1cc1d8:
    // 0x1cc1d8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cc1dc: 0x54400016
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 224)));
        ctx->pc = 0x1CC238; return;
    }
    // 0x1cc1e4: 0x8e440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cc1e8: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1cc1f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cc1f0
// Address: 0x1cc1f0 - 0x1cc274

void entry_1cc1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc1f0) {
        switch (ctx->pc) {
            case 0x1cc238: ctx->pc = 0; goto label_1cc238;
            case 0x1cc24c: ctx->pc = 0; goto label_1cc24c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc1f0: 0xda610040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1cc1f4: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cc1f8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc1fc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc200: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc204: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc208: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc20c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc210: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc214: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cc218: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc21c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cc220: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cc224: 0x0
    // NOP
    // 0x1cc228: 0x45000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 224)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cc238;
    }
    // 0x1cc230: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1cc234: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1cc238:
    // 0x1cc238: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1cc23c: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x1cc240: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1cc244: 0x1440ffe4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC1D8; return;
    }
label_1cc24c:
    // 0x1cc24c: 0x151080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 2));
    // 0x1cc250: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cc254: 0x5e1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x1cc258: 0x26850900
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 2304));
    // 0x1cc25c: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x1cc260: 0x2e21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x1cc264: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cc268: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cc26c: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1cc274);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cc274
// Address: 0x1cc274 - 0x1cc280

void entry_1cc274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc274: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1cc278: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1cc280);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cc280
// Address: 0x1cc280 - 0x1cc28c

void entry_1cc280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc280: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1cc284: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1cc28c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1cc28c
// Address: 0x1cc28c - 0x1cc2b4

void entry_1cc28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc28c) {
        switch (ctx->pc) {
            case 0x1cc2ac: ctx->pc = 0; goto label_1cc2ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc28c: 0xe6800910
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 2320), *(uint32_t*)&val); }
    // 0x1cc290: 0x8e640058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 88)));
    // 0x1cc294: 0x8e6300e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 224)));
    // 0x1cc298: 0x83282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1cc29c: 0x65200a
    if (GPR_U32(ctx, 5) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 3));
    // 0x1cc2a0: 0x224102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 4)));
    // 0x1cc2a4: 0x1440ffc0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC1A8; return;
    }
label_1cc2ac:
    // 0x1cc2ac: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1cc2b4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cc2b4
// Address: 0x1cc2b4 - 0x1cc2f8

void entry_1cc2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc2b4: 0x8e620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 88)));
    // 0x1cc2b8: 0x1222003e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CC3B4; return;
    }
    // 0x1cc2c0: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1cc2c4: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1cc2c8: 0x3c013e22
    SET_GPR_U32(ctx, 1, ((uint32_t)15906 << 16));
    // 0x1cc2cc: 0x3421f983
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63875));
    // 0x1cc2d0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cc2d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cc2d8: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1cc2dc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1cc2e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cc2e4: 0xc4414d20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19744)); ctx->f[1] = *(float*)&val; }
    // 0x1cc2e8: 0x46030583
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[22] = ctx->f[0] / ctx->f[3];
    // 0x1cc2ec: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1cc2f0: 0xc072ebe
    SET_GPR_U32(ctx, 31, 0x1cc2f8);
    ctx->f[23] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    PsoEnemySgg__FP3SGG(rdram, ctx, runtime); return;
}


// Function: entry_1cc2f8
// Address: 0x1cc2f8 - 0x1cc30c

void entry_1cc2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc2f8: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC314; return;
    }
    // 0x1cc300: 0xc44d0150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 336)); ctx->f[13] = *(float*)&val; }
    // 0x1cc304: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1cc30c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 340)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1cc30c
// Address: 0x1cc30c - 0x1cc354

void entry_1cc30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc30c) {
        switch (ctx->pc) {
            case 0x1cc314: ctx->pc = 0; goto label_1cc314;
            case 0x1cc318: ctx->pc = 0; goto label_1cc318;
            case 0x1cc340: ctx->pc = 0; goto label_1cc340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc30c: 0x10000002
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cc318;
    }
label_1cc314:
    // 0x1cc314: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
label_1cc318:
    // 0x1cc318: 0x8e620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 88)));
    // 0x1cc31c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cc320: 0x10400024
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC3B4; return;
    }
    // 0x1cc328: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1cc32c: 0x2442005c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 92));
    // 0x1cc330: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1cc334: 0x26b74d28
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 21), 19752));
    // 0x1cc338: 0x26964d30
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 20), 19760));
    // 0x1cc33c: 0x539021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
label_1cc340:
    // 0x1cc340: 0xc6ed0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1cc344: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1cc348: 0xc6ac4d28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 19752)); ctx->f[12] = *(float*)&val; }
    // 0x1cc34c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cc354);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cc354
// Address: 0x1cc354 - 0x1cc364

void entry_1cc354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc354: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x1cc358: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1cc35c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1cc364);
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1cc364
// Address: 0x1cc364 - 0x1cc374

void entry_1cc364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc364: 0xc68c4d30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 19760)); ctx->f[12] = *(float*)&val; }
    // 0x1cc368: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1cc36c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cc374);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cc374
// Address: 0x1cc374 - 0x1cc388

void entry_1cc374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc374: 0x46170342
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1cc378: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cc37c: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1cc380: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1cc388);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1cc388
// Address: 0x1cc388 - 0x1cc3a4

void entry_1cc388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc388: 0xda620040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1cc38c: 0x4616ab00
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[22]);
    // 0x1cc390: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cc394: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cc398: 0xe6140910
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 2320), *(uint32_t*)&val); }
    // 0x1cc39c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1cc3a4);
    WRITE128(ADD32(GPR_U32(ctx, 16), 2304), _mm_castps_si128(ctx->vu0_vf[2]));
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1cc3a4
// Address: 0x1cc3a4 - 0x1cc410

void entry_1cc3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc3a4) {
        switch (ctx->pc) {
            case 0x1cc3b4: ctx->pc = 0; goto label_1cc3b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc3a4: 0x8e620058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 88)));
    // 0x1cc3a8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1cc3ac: 0x1440ffe4
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC340; return;
    }
label_1cc3b4:
    // 0x1cc3b4: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cc3b8: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1cc3bc: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cc3c0: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cc3c4: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cc3c8: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1cc3cc: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cc3d0: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cc3d4: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cc3d8: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cc3dc: 0xc7b70118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[23] = *(float*)&val; }
    // 0x1cc3e0: 0xc7b60110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[22] = *(float*)&val; }
    // 0x1cc3e4: 0xc7b50108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[21] = *(float*)&val; }
    // 0x1cc3e8: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x1cc3ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cc3f4: 0x0
    // NOP
    // 0x1cc3f8: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cc3fc: 0x0
    // NOP
    // 0x1cc400: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x1cc404: 0x0
    // NOP
    // 0x1cc408: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc40c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cc410; return;
}


// Function: PostJtLoadSwing__FP2JTP2BLPP6ASEGBL
// Address: 0x1cc410 - 0x1cc45c

void entry_1cc45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc45c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cc460: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cc464: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1cc468: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1cc470);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1cc470
// Address: 0x1cc470 - 0x1cc490

void entry_1cc470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc470) {
        switch (ctx->pc) {
            case 0x1cc47c: ctx->pc = 0; goto label_1cc47c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc470: 0x12200002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cc47c;
    }
    // 0x1cc478: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_1cc47c:
    // 0x1cc47c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cc480: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cc484: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cc488: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX
// Address: 0x1cc490 - 0x1cc5f4

void entry_1cc5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc5f4: 0x8fa5021c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 540)));
    // 0x1cc5f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cc5fc: 0xc06e3fa
    SET_GPR_U32(ctx, 31, 0x1cc604);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    CalculateSoAngularEffectWorld__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1cc604
// Address: 0x1cc604 - 0x1cc61c

void entry_1cc604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc604: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cc608: 0x26250460
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1120));
    // 0x1cc60c: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1cc610: 0x26070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1cc614: 0xc06e8ba
    SET_GPR_U32(ctx, 31, 0x1cc61c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintWorld__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1cc61c
// Address: 0x1cc61c - 0x1cc630

void entry_1cc61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc61c: 0x8fa50210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1cc620: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cc624: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cc628: 0xc06f1fe
    SET_GPR_U32(ctx, 31, 0x1cc630);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateSoEffect__FP2SOP6VECTORP2FXT1(rdram, ctx, runtime); return;
}


// Function: entry_1cc630
// Address: 0x1cc630 - 0x1cc70c

void entry_1cc630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc630) {
        switch (ctx->pc) {
            case 0x1cc680: ctx->pc = 0; goto label_1cc680;
            case 0x1cc6a8: ctx->pc = 0; goto label_1cc6a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc630: 0x2aa20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), 2));
    // 0x1cc634: 0x1440ffc6
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC550; return;
    }
    // 0x1cc63c: 0x8fab0240
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1cc640: 0x26d60001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    // 0x1cc644: 0xdba10130
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cc648: 0x2ac20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 3));
    // 0x1cc64c: 0xdba20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1cc650: 0x256b0010
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 16));
    // 0x1cc654: 0xafab0240
    WRITE32(ADD32(GPR_U32(ctx, 29), 576), GPR_U32(ctx, 11));
    // 0x1cc658: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc65c: 0xfae10000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc660: 0x1440ffb5
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CC538; return;
    }
    // 0x1cc668: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cc66c: 0x8fac0220
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1cc670: 0x8fa80238
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 568)));
    // 0x1cc674: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc678: 0x244a83d0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x1cc67c: 0x2409000c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 12));
label_1cc680:
    // 0x1cc680: 0x2c91018
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1cc684: 0x26c70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 22), 1));
    // 0x1cc688: 0x163080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 22), 2));
    // 0x1cc68c: 0x140182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1cc690: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1cc694: 0x4c2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 12)));
    // 0x1cc698: 0x161100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 4));
    // 0x1cc69c: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1cc6a0: 0x24420150
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 336));
    // 0x1cc6a4: 0x0
    // NOP
label_1cc6a8:
    // 0x1cc6a8: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cc6ac: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1cc6b0: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cc6b4: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1cc6b8: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc6bc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc6c0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc6c4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc6c8: 0x482b0800
    SET_GPR_VEC(ctx, 11, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc6cc: 0xac8b0000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 11));
    // 0x1cc6d0: 0x4a1fff5
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_1cc6a8;
    }
    // 0x1cc6d8: 0x8fa30214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 532)));
    // 0x1cc6dc: 0xe0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1cc6e0: 0x661021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1cc6e4: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1cc6e8: 0x1061821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 6)));
    // 0x1cc6ec: 0x2ac20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 3));
    // 0x1cc6f0: 0x1440ffe3
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cc680;
    }
    // 0x1cc6f8: 0x8fa50220
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1cc6fc: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1cc700: 0x8fa6022c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 556)));
    // 0x1cc704: 0xc052c30
    SET_GPR_U32(ctx, 31, 0x1cc70c);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    CroutDecomp__FiPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1cc70c
// Address: 0x1cc70c - 0x1cc724

void entry_1cc70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc70c: 0x8fa5022c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 556)));
    // 0x1cc710: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1cc714: 0x8fa60238
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 568)));
    // 0x1cc718: 0x8fa7023c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 572)));
    // 0x1cc71c: 0xc052cf8
    SET_GPR_U32(ctx, 31, 0x1cc724);
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 29), 536)));
    CroutSolve__FiPfN21(rdram, ctx, runtime); return;
}


// Function: entry_1cc724
// Address: 0x1cc724 - 0x1cc7c0

void entry_1cc724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc724) {
        switch (ctx->pc) {
            case 0x1cc738: ctx->pc = 0; goto label_1cc738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc724: 0x26710010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 16));
    // 0x1cc728: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cc72c: 0x27b000c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cc730: 0x8fa601f0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1cc734: 0x0
    // NOP
label_1cc738:
    // 0x1cc738: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cc73c: 0x48a62000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x1cc740: 0x8fa201f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 504)));
    // 0x1cc744: 0xfba40200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cc748: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1cc74c: 0x8fab01f4
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 500)));
    // 0x1cc750: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cc754: 0x48ab3000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 11));
    // 0x1cc758: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc75c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cc760: 0x26730020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 32));
    // 0x1cc764: 0xda02ffb0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294967216)));
    // 0x1cc768: 0x26b5ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1cc76c: 0xfba60200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cc770: 0xda03ffd0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294967248)));
    // 0x1cc774: 0xfba50200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cc778: 0xda01fff0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294967280)));
    // 0x1cc77c: 0xfba40200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cc780: 0x4be411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cc784: 0x4be618bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cc788: 0x4be50888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc78c: 0xfa22fff0
    WRITE128(ADD32(GPR_U32(ctx, 17), 4294967280), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cc790: 0xda03ffc0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294967232)));
    // 0x1cc794: 0xfba60200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cc798: 0xda02ffe0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 4294967264)));
    // 0x1cc79c: 0xfba50200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cc7a0: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cc7a4: 0x4be419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cc7a8: 0x4be610bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cc7ac: 0x4be50908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc7b0: 0x26100060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 96));
    // 0x1cc7b4: 0xfa240000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cc7b8: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1cc7c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cc7c0
// Address: 0x1cc7c0 - 0x1cc7e0

void entry_1cc7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc7c0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cc7c4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cc7c8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cc7cc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc7d0: 0x8c450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cc7d4: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x1cc7d8: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1cc7e0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 32));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cc7e0
// Address: 0x1cc7e0 - 0x1cc818

void entry_1cc7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc7e0: 0x6a1ffd5
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 496)));
    if (GPR_S32(ctx, 21) >= 0) {
        ctx->pc = 0x1CC738; return;
    }
    // 0x1cc7e8: 0x7bbf02e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 736)));
    // 0x1cc7ec: 0x7bbe02d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 720)));
    // 0x1cc7f0: 0x7bb702c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 704)));
    // 0x1cc7f4: 0x7bb602b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 688)));
    // 0x1cc7f8: 0x7bb502a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 672)));
    // 0x1cc7fc: 0x7bb40290
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x1cc800: 0x7bb30280
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x1cc804: 0x7bb20270
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x1cc808: 0x7bb10260
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x1cc80c: 0x7bb00250
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x1cc810: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 752));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateJtHangAccel__FP2JT
// Address: 0x1cc818 - 0x1cc858

void entry_1cc858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc858: 0x8e842204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 8708)));
    // 0x1cc85c: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1cc864);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cc864
// Address: 0x1cc864 - 0x1cc888

void entry_1cc864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cc864: 0x8e822204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8708)));
    // 0x1cc868: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc86c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cc870: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cc874: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cc878: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc87c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cc880: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1cc888);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1cc888
// Address: 0x1cc888 - 0x1cc928

void entry_1cc888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc888) {
        switch (ctx->pc) {
            case 0x1cc8ec: ctx->pc = 0; goto label_1cc8ec;
            case 0x1cc8fc: ctx->pc = 0; goto label_1cc8fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc888: 0xda820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x1cc88c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cc890: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cc894: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1cc898: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cc89c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cc8a0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cc8a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cc8a8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cc8ac: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc8b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc8b4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc8b8: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cc8bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc8c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc8c4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cc8c8: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cc8cc: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cc8d0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1cc8d4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cc8d8: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cc8ec;
    }
    // 0x1cc8e0: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cc8e4: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cc8fc;
    }
label_1cc8ec:
    // 0x1cc8ec: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cc8f0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc8f4: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1cc8f8: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_1cc8fc:
    // 0x1cc8fc: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cc900: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cc904: 0xda810150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 336)));
    // 0x1cc908: 0x4484a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 4);
    // 0x1cc90c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cc910: 0x27a40070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1cc914: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc918: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1cc91c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc920: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1cc928);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1cc928
// Address: 0x1cc928 - 0x1ccb10

void entry_1cc928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cc928) {
        switch (ctx->pc) {
            case 0x1cc998: ctx->pc = 0; goto label_1cc998;
            case 0x1cca58: ctx->pc = 0; goto label_1cca58;
            case 0x1cca64: ctx->pc = 0; goto label_1cca64;
            case 0x1ccac0: ctx->pc = 0; goto label_1ccac0;
            case 0x1ccacc: ctx->pc = 0; goto label_1ccacc;
            case 0x1ccad0: ctx->pc = 0; goto label_1ccad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cc928: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cc92c: 0x46000586
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    // 0x1cc930: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cc934: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cc938: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1cc93c: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc940: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cc944: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cc948: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cc94c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cc950: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cc954: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc958: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc95c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc960: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1cc964: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc968: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc96c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cc970: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cc974: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc978: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1cc97c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cc980: 0x0
    // NOP
    // 0x1cc984: 0x45010004
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1cc998;
    }
    // 0x1cc98c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1cc990: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc994: 0x4be0199c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1cc998:
    // 0x1cc998: 0xda840350
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 848)));
    // 0x1cc99c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cc9a0: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cc9a4: 0x24428d10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x1cc9a8: 0x4bc320aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9ac: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9b0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9b4: 0x4b02288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc9b8: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cc9bc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9c0: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9c8: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc9cc: 0x4be21898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9d0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9d4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cc9d8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cc9dc: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9e0: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cc9e4: 0x4bc41afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x1cc9e8: 0x4bc3216e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cc9ec: 0x4a25296c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9f0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cc9f4: 0x4bc528aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9f8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cc9fc: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cca00: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cca04: 0x46150003
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[21];
    // 0x1cca08: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cca0c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cca10: 0x4b0000e0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cca14: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cca18: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cca1c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cca20: 0x48231800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cca24: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1cca28: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cca2c: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cca30: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cca34: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1cca38: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1cca3c: 0x4be13098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1cca40: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cca44: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cca48: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cca58;
    }
    // 0x1cca50: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cca64;
    }
label_1cca58:
    // 0x1cca58: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1cca5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cca60: 0x4be028dc
    ctx->vu0_vf[5] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1cca64:
    // 0x1cca64: 0xdba100c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cca68: 0x24020032
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    // 0x1cca6c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cca70: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cca74: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cca78: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cca7c: 0x8e832228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8744)));
    // 0x1cca80: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cca84: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cca88: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cca8c: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cca90: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cca94: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cca98: 0x46150003
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[21];
    // 0x1cca9c: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1ccaa0: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1ccaa4: 0x4be11898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ccaa8: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ccaac: 0x10620004
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ccac0;
    }
    // 0x1ccab4: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1ccab8: 0x14620004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1ccacc;
    }
label_1ccac0:
    // 0x1ccac0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ccac4: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19780)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ccad0;
    }
label_1ccacc:
    // 0x1ccacc: 0xc4544d48
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19784)); ctx->f[20] = *(float*)&val; }
label_1ccad0:
    // 0x1ccad0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ccad4: 0xdba100e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ccad8: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1ccadc: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ccae0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1ccae4: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1ccae8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ccaec: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ccaf0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ccaf4: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccaf8: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ccafc: 0xfba200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ccb00: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ccb04: 0x27a60100
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1ccb08: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1ccb10);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 272));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1ccb10
// Address: 0x1ccb10 - 0x1cccb8

void entry_1ccb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ccb10) {
        switch (ctx->pc) {
            case 0x1ccb78: ctx->pc = 0; goto label_1ccb78;
            case 0x1ccbac: ctx->pc = 0; goto label_1ccbac;
            case 0x1ccbb8: ctx->pc = 0; goto label_1ccbb8;
            case 0x1ccc50: ctx->pc = 0; goto label_1ccc50;
            case 0x1ccc60: ctx->pc = 0; goto label_1ccc60;
            case 0x1ccc84: ctx->pc = 0; goto label_1ccc84;
            case 0x1ccc88: ctx->pc = 0; goto label_1ccc88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ccb10: 0xc6030008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1ccb14: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ccb18: 0xc4404d40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19776)); ctx->f[0] = *(float*)&val; }
    // 0x1ccb1c: 0x24040032
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 50));
    // 0x1ccb20: 0x4603a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x1ccb24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ccb28: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ccb2c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ccb30: 0x8e832228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8744)));
    // 0x1ccb34: 0xdba20100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ccb38: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1ccb3c: 0xdba30110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ccb40: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1ccb44: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ccb48: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ccb4c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ccb50: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ccb54: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1ccb58: 0x4be41888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccb5c: 0xfba10120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ccb60: 0xfba200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ccb64: 0x10640004
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_1ccb78;
    }
    // 0x1ccb6c: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1ccb70: 0x54620045
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8708)));
        goto label_1ccc88;
    }
label_1ccb78:
    // 0x1ccb78: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ccb7c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ccb80: 0xc681222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8748)); ctx->f[1] = *(float*)&val; }
    // 0x1ccb84: 0xc4424d4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19788)); ctx->f[2] = *(float*)&val; }
    // 0x1ccb88: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ccb8c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ccb90: 0x0
    // NOP
    // 0x1ccb94: 0x4500003b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ccc84;
    }
    // 0x1ccb9c: 0xc4404d50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19792)); ctx->f[0] = *(float*)&val; }
    // 0x1ccba0: 0x14640002
    ctx->f[7] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1ccbac;
    }
    // 0x1ccba8: 0x460039c7
    ctx->f[7] = FPU_NEG_S(ctx->f[7]);
label_1ccbac:
    // 0x1ccbac: 0x8e8222a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8872)));
    // 0x1ccbb0: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[7] = FPU_NEG_S(ctx->f[7]);
        goto label_1ccbb8;
    }
label_1ccbb8:
    // 0x1ccbb8: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ccbbc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ccbc0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ccbc4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ccbc8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ccbcc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccbd0: 0xc6850358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 856)); ctx->f[5] = *(float*)&val; }
    // 0x1ccbd4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ccbd8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ccbdc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ccbe0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ccbe4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ccbe8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ccbec: 0x46002947
    ctx->f[5] = FPU_NEG_S(ctx->f[5]);
    // 0x1ccbf0: 0x44832000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 3);
    // 0x1ccbf4: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1ccbf8: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1ccbfc: 0x24434d60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 19808));
    // 0x1ccc00: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x1ccc04: 0xc4630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1ccc08: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1ccc0c: 0x46012102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1ccc10: 0xc4464d60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19808)); ctx->f[6] = *(float*)&val; }
    // 0x1ccc14: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ccc18: 0xc4415c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[1] = *(float*)&val; }
    // 0x1ccc1c: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1ccc20: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1ccc24: 0x46050003
    if (ctx->f[5] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[5];
    // 0x1ccc28: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ccc2c: 0x46031080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x1ccc30: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1ccc34: 0x46003180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[0]);
    // 0x1ccc38: 0x46013034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ccc3c: 0x0
    // NOP
    // 0x1ccc40: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ccc50;
    }
    // 0x1ccc48: 0x10000005
    ctx->f[6] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ccc60;
    }
label_1ccc50:
    // 0x1ccc50: 0x46062034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ccc54: 0x0
    // NOP
    // 0x1ccc58: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[6] = FPU_MOV_S(ctx->f[4]);
        goto label_1ccc60;
    }
label_1ccc60:
    // 0x1ccc60: 0x460639c2
    ctx->f[7] = FPU_MUL_S(ctx->f[7], ctx->f[6]);
    // 0x1ccc64: 0xdba100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ccc68: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ccc6c: 0x44043800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[7]);
    // 0x1ccc70: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1ccc74: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1ccc78: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccc7c: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ccc80: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
label_1ccc84:
    // 0x1ccc84: 0x8e822204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8708)));
label_1ccc88:
    // 0x1ccc88: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1ccc8c: 0xc6004d84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 19844)); ctx->f[0] = *(float*)&val; }
    // 0x1ccc90: 0x26d51858
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 22), 6232));
    // 0x1ccc94: 0xc44e00b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 176)); ctx->f[14] = *(float*)&val; }
    // 0x1ccc98: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ccc9c: 0xc6af0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 8)); ctx->f[15] = *(float*)&val; }
    // 0x1ccca0: 0x24844d70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19824));
    // 0x1ccca4: 0x460e0381
    ctx->f[14] = FPU_SUB_S(ctx->f[0], ctx->f[14]);
    // 0x1ccca8: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x1cccac: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1cccb0: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x1cccb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 432));
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_1cccb8
// Address: 0x1cccb8 - 0x1ccd30

void entry_1cccb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cccb8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1cccbc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cccc0: 0xc4404d80
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19840)); ctx->f[0] = *(float*)&val; }
    // 0x1cccc4: 0xc6014d84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 19844)); ctx->f[1] = *(float*)&val; }
    // 0x1cccc8: 0x46140028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[20]);
    // 0x1ccccc: 0xdba200f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cccd0: 0x46150869
    ctx->f[1] = std::min(ctx->f[1], ctx->f[21]);
    // 0x1cccd4: 0x8e8422ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 8876)));
    // 0x1cccd8: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1cccdc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ccce0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ccce4: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ccce8: 0xfba10120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cccec: 0x10800058
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CCE50; return;
    }
    // 0x1cccf4: 0x8c930004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1cccf8: 0x8e6401ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 492)));
    // 0x1cccfc: 0x1080001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CCD6C; return;
    }
    // 0x1ccd04: 0x80830010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1ccd08: 0x14620019
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CCD70; return;
    }
    // 0x1ccd10: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ccd14: 0x27b10150
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 336));
    // 0x1ccd18: 0x27b20160
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 352));
    // 0x1ccd1c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ccd20: 0x8c430010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1ccd24: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ccd28: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ccd30);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ccd30
// Address: 0x1ccd30 - 0x1ccd4c

void entry_1ccd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccd30: 0x27b00130
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 304));
    // 0x1ccd34: 0xc6ac0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ccd38: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ccd3c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ccd40: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ccd44: 0xc0485d8
    SET_GPR_U32(ctx, 31, 0x1ccd4c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateAloPositionSpring__FP3ALOfP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_1ccd4c
// Address: 0x1ccd4c - 0x1ccd64

void entry_1ccd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccd4c: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ccd50: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1ccd54: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ccd58: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ccd5c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1ccd64);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ccd64
// Address: 0x1ccd64 - 0x1ccdb8

void entry_1ccd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ccd64) {
        switch (ctx->pc) {
            case 0x1ccd6c: ctx->pc = 0; goto label_1ccd6c;
            case 0x1ccd70: ctx->pc = 0; goto label_1ccd70;
            case 0x1ccd84: ctx->pc = 0; goto label_1ccd84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ccd64: 0x10000007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ccd84;
    }
label_1ccd6c:
    // 0x1ccd6c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
label_1ccd70:
    // 0x1ccd70: 0x27b50130
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 304));
    // 0x1ccd74: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1ccd78: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ccd7c: 0x7fa20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 2));
    // 0x1ccd80: 0x8e6401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 496)));
label_1ccd84:
    // 0x1ccd84: 0x1080001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CCDF4; return;
    }
    // 0x1ccd8c: 0x80830011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 17)));
    // 0x1ccd90: 0x14620019
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CCDF8; return;
    }
    // 0x1ccd98: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ccd9c: 0x27b10170
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1ccda0: 0x27b20150
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 336));
    // 0x1ccda4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ccda8: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1ccdac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ccdb0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ccdb8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ccdb8
// Address: 0x1ccdb8 - 0x1ccdd8

void entry_1ccdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccdb8: 0x26c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 6232));
    // 0x1ccdbc: 0x27b00140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 320));
    // 0x1ccdc0: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ccdc4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ccdc8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ccdcc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ccdd0: 0xc048712
    SET_GPR_U32(ctx, 31, 0x1ccdd8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateAloRotationSpring__FP3ALOfP7MATRIX3P6VECTORT3(rdram, ctx, runtime); return;
}


// Function: entry_1ccdd8
// Address: 0x1ccdd8 - 0x1ccdec

void entry_1ccdd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccdd8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ccddc: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1ccde0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ccde4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1ccdec);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ccdec
// Address: 0x1ccdec - 0x1cce9c

void entry_1ccdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ccdec) {
        switch (ctx->pc) {
            case 0x1ccdf4: ctx->pc = 0; goto label_1ccdf4;
            case 0x1ccdf8: ctx->pc = 0; goto label_1ccdf8;
            case 0x1cce08: ctx->pc = 0; goto label_1cce08;
            case 0x1cce50: ctx->pc = 0; goto label_1cce50;
            case 0x1cce60: ctx->pc = 0; goto label_1cce60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ccdec: 0x10000006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cce08;
    }
label_1ccdf4:
    // 0x1ccdf4: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
label_1ccdf8:
    // 0x1ccdf8: 0x27a50170
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1ccdfc: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1cce00: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cce04: 0x7fa20140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 2));
label_1cce08:
    // 0x1cce08: 0x26c21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 6232));
    // 0x1cce0c: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cce10: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1cce14: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1cce18: 0xdba30140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1cce1c: 0xfba50150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cce20: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cce24: 0xdba60130
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cce28: 0xda610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1cce2c: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cce30: 0x4bc41afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x1cce34: 0x4bc320ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cce38: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cce3c: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cce40: 0x4be530bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cce44: 0x4be51888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cce48: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cce60;
    }
label_1cce50:
    // 0x1cce50: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cce54: 0x27b50130
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 304));
    // 0x1cce58: 0x27a50170
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1cce5c: 0x7fa20120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 2));
label_1cce60:
    // 0x1cce60: 0x26d01858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 22), 6232));
    // 0x1cce64: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cce68: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cce6c: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1cce70: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1cce74: 0xdba100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cce78: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1cce7c: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cce80: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cce84: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1cce88: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1cce8c: 0x4be31098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cce90: 0xfba301a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cce94: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x1cce9c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cce9c
// Address: 0x1cce9c - 0x1ccf54

void entry_1cce9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cce9c: 0xdba40170
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1ccea0: 0xdba30180
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1ccea4: 0xdba10190
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1ccea8: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x1cceac: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cceb0: 0x48a43000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1cceb4: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cceb8: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1ccebc: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccec0: 0x8fa301b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1ccec4: 0x4be629d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1ccec8: 0xdba200f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ccecc: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1cced0: 0x48a34000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1cced4: 0xda830150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 336)));
    // 0x1cced8: 0x4bc712fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[7] = READ32(addr); }
    // 0x1ccedc: 0x4bc238ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ccee0: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ccee4: 0x8e8222ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8876)));
    // 0x1ccee8: 0x4be82858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cceec: 0xdba40120
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1ccef0: 0x48b04800
    ctx->vu0_vf[9] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x1ccef4: 0xfba601a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1ccef8: 0x4be22128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ccefc: 0x4be12128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ccf00: 0x4be320ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ccf04: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ccf08: 0xda820350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 848)));
    // 0x1ccf0c: 0x4a6903bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x1ccf10: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ccf14: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1ccf18: 0x4be70868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ccf1c: 0x4be218ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ccf20: 0xfba801a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1ccf24: 0xfba10150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ccf28: 0xfba50140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1ccf2c: 0xfba40160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1ccf30: 0xfba901a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x1ccf34: 0x10400009
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CCF5C; return;
    }
    // 0x1ccf3c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ccf40: 0x8c450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1ccf44: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ccf48: 0x27a700c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1ccf4c: 0xc073124
    SET_GPR_U32(ctx, 31, 0x1ccf54);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 4), 8880));
    AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX(rdram, ctx, runtime); return;
}


// Function: entry_1ccf54
// Address: 0x1ccf54 - 0x1ccf98

void entry_1ccf54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ccf54) {
        switch (ctx->pc) {
            case 0x1ccf5c: ctx->pc = 0; goto label_1ccf5c;
            case 0x1ccf64: ctx->pc = 0; goto label_1ccf64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ccf54: 0x10000003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ccf64;
    }
label_1ccf5c:
    // 0x1ccf5c: 0xfa8222b0
    WRITE128(ADD32(GPR_U32(ctx, 20), 8880), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ccf60: 0x7bbf0230
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 560)));
label_1ccf64:
    // 0x1ccf64: 0x7bb60220
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1ccf68: 0x7bb50210
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1ccf6c: 0x7bb40200
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1ccf70: 0x7bb301f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1ccf74: 0x7bb201e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x1ccf78: 0x7bb101d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1ccf7c: 0x7bb001c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1ccf80: 0xc7b60250
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 592)); ctx->f[22] = *(float*)&val; }
    // 0x1ccf84: 0xc7b50248
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 584)); ctx->f[21] = *(float*)&val; }
    // 0x1ccf88: 0xc7b40240
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 576)); ctx->f[20] = *(float*)&val; }
    // 0x1ccf8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 608));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ccf94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ccf98; return;
}


// Function: PresetJtAccelHang__FP2JT
// Address: 0x1ccf98 - 0x1ccfb4

void entry_1ccfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccfb4: 0x8e242204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8708)));
    // 0x1ccfb8: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1ccfc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ccfc0
// Address: 0x1ccfc0 - 0x1ccfe8

void entry_1ccfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccfc0: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ccfc4: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1ccfc8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ccfcc: 0x26108d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937888));
    // 0x1ccfd0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ccfd4: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ccfd8: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ccfdc: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ccfe0: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1ccfe8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1ccfe8
// Address: 0x1ccfe8 - 0x1ccff8

void entry_1ccfe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccfe8: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1ccfec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ccff0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1ccff8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1ccff8
// Address: 0x1ccff8 - 0x1cd074

void entry_1ccff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ccff8: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ccffc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cd000: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cd004: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1cd008: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cd00c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cd010: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cd014: 0x24c64d88
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19848));
    // 0x1cd018: 0xdba50060
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cd01c: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cd020: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cd024: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd028: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cd02c: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cd030: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd034: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cd038: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1cd03c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cd040: 0x4bc3104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd044: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1cd048: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cd04c: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1cd050: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cd054: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd058: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cd05c: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cd060: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cd064: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cd068: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd06c: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1cd074);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1cd074
// Address: 0x1cd074 - 0x1cd088

void entry_1cd074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd074: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cd078: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1cd07c: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1cd080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddJtExternalAccelerations__FP2JTP2XAf
// Address: 0x1cd088 - 0x1cd0a8

void entry_1cd0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd0a8: 0x8e0222ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8876)));
    // 0x1cd0ac: 0x260522e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8928));
    // 0x1cd0b0: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1cd0b8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cd0b8
// Address: 0x1cd0b8 - 0x1cd0c8

void entry_1cd0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd0b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cd0bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cd0c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtActiveHang__FP2JTP3JOY
// Address: 0x1cd0c8 - 0x1cd104

void entry_1cd104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd104: 0x8e4222a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8872)));
    // 0x1cd108: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CD130; return;
    }
    // 0x1cd110: 0xc6400638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[0] = *(float*)&val; }
    // 0x1cd114: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1cd118: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1cd11c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cd120: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1cd128);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1cd128
// Address: 0x1cd128 - 0x1cd144

void entry_1cd128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd128) {
        switch (ctx->pc) {
            case 0x1cd130: ctx->pc = 0; goto label_1cd130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd128: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x1cd12c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1cd130:
    // 0x1cd130: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cd134: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1cd138: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cd13c: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1cd144);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1cd144
// Address: 0x1cd144 - 0x1cd154

void entry_1cd144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd144: 0xc7a00060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[0] = *(float*)&val; }
    // 0x1cd148: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1cd14c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1cd154);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1cd154
// Address: 0x1cd154 - 0x1cd1dc

void entry_1cd154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd154) {
        switch (ctx->pc) {
            case 0x1cd1a0: ctx->pc = 0; goto label_1cd1a0;
            case 0x1cd1c0: ctx->pc = 0; goto label_1cd1c0;
            case 0x1cd1cc: ctx->pc = 0; goto label_1cd1cc;
            case 0x1cd1d0: ctx->pc = 0; goto label_1cd1d0;
            case 0x1cd1d4: ctx->pc = 0; goto label_1cd1d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd154: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x1cd158: 0xc6410634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x1cd15c: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1cd160: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1cd164: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd168: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd16c: 0x0
    // NOP
    // 0x1cd170: 0x45000016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd1cc;
    }
    // 0x1cd178: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x1cd17c: 0x3c013f86
    SET_GPR_U32(ctx, 1, ((uint32_t)16262 << 16));
    // 0x1cd180: 0x34210a92
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2706));
    // 0x1cd184: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd188: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd18c: 0x0
    // NOP
    // 0x1cd190: 0x45000003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd1a0;
    }
    // 0x1cd198: 0x10000009
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd1c0;
    }
label_1cd1a0:
    // 0x1cd1a0: 0x3c014006
    SET_GPR_U32(ctx, 1, ((uint32_t)16390 << 16));
    // 0x1cd1a4: 0x34210a92
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2706));
    // 0x1cd1a8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd1ac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd1b0: 0x0
    // NOP
    // 0x1cd1b4: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
        goto label_1cd1d4;
    }
    // 0x1cd1bc: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
label_1cd1c0:
    // 0x1cd1c0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cd1c4: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8864), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd1d0;
    }
label_1cd1cc:
    // 0x1cd1cc: 0xae4222a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 8868), GPR_U32(ctx, 2));
label_1cd1d0:
    // 0x1cd1d0: 0x8e442204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
label_1cd1d4:
    // 0x1cd1d4: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1cd1dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cd1dc
// Address: 0x1cd1dc - 0x1cd25c

void entry_1cd1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd1dc) {
        switch (ctx->pc) {
            case 0x1cd23c: ctx->pc = 0; goto label_1cd23c;
            case 0x1cd248: ctx->pc = 0; goto label_1cd248;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd1dc: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cd1e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cd1e4: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1cd1e8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cd1ec: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cd1f0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cd1f4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cd1f8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cd1fc: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cd200: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cd204: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd208: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd20c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1cd210: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd214: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cd218: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cd21c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cd220: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd224: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1cd228: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd22c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd23c;
    }
    // 0x1cd234: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd248;
    }
label_1cd23c:
    // 0x1cd23c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1cd240: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cd244: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1cd248:
    // 0x1cd248: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1cd24c: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1cd250: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd254: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1cd25c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cd25c
// Address: 0x1cd25c - 0x1cd2a4

void entry_1cd25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd25c: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cd260: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cd264: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cd268: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cd26c: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cd270: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1cd274: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cd278: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd27c: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1cd280: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd284: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1cd288: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd28c: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cd290: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd294: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cd298: 0xc7ac0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[12] = *(float*)&val; }
    // 0x1cd29c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1cd2a4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1cd2a4
// Address: 0x1cd2a4 - 0x1cd2b8

void entry_1cd2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd2a4: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1cd2a8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1cd2ac: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cd2b0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1cd2b8);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1cd2b8
// Address: 0x1cd2b8 - 0x1cd4e0

void entry_1cd2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd2b8) {
        switch (ctx->pc) {
            case 0x1cd2e4: ctx->pc = 0; goto label_1cd2e4;
            case 0x1cd300: ctx->pc = 0; goto label_1cd300;
            case 0x1cd310: ctx->pc = 0; goto label_1cd310;
            case 0x1cd32c: ctx->pc = 0; goto label_1cd32c;
            case 0x1cd33c: ctx->pc = 0; goto label_1cd33c;
            case 0x1cd354: ctx->pc = 0; goto label_1cd354;
            case 0x1cd374: ctx->pc = 0; goto label_1cd374;
            case 0x1cd3a4: ctx->pc = 0; goto label_1cd3a4;
            case 0x1cd3b8: ctx->pc = 0; goto label_1cd3b8;
            case 0x1cd3cc: ctx->pc = 0; goto label_1cd3cc;
            case 0x1cd428: ctx->pc = 0; goto label_1cd428;
            case 0x1cd430: ctx->pc = 0; goto label_1cd430;
            case 0x1cd444: ctx->pc = 0; goto label_1cd444;
            case 0x1cd450: ctx->pc = 0; goto label_1cd450;
            case 0x1cd464: ctx->pc = 0; goto label_1cd464;
            case 0x1cd470: ctx->pc = 0; goto label_1cd470;
            case 0x1cd4cc: ctx->pc = 0; goto label_1cd4cc;
            case 0x1cd4d0: ctx->pc = 0; goto label_1cd4d0;
            case 0x1cd4d4: ctx->pc = 0; goto label_1cd4d4;
            case 0x1cd4d8: ctx->pc = 0; goto label_1cd4d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd2b8: 0x8e462228
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x1cd2bc: 0x24020033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 51));
    // 0x1cd2c0: 0x10c20038
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1cd3a4;
    }
    // 0x1cd2c8: 0x28c20034
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 52));
    // 0x1cd2cc: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cd2e4;
    }
    // 0x1cd2d4: 0x10c2000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1cd300;
    }
    // 0x1cd2dc: 0x1000007e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d8;
    }
label_1cd2e4:
    // 0x1cd2e4: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1cd2e8: 0x10c20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 53));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1cd32c;
    }
    // 0x1cd2f0: 0x10c2004f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1cd430;
    }
    // 0x1cd2f8: 0x10000077
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d8;
    }
label_1cd300:
    // 0x1cd300: 0x12600003
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cd310;
    }
    // 0x1cd308: 0x10000072
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d4;
    }
label_1cd310:
    // 0x1cd310: 0x12200018
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cd374;
    }
    // 0x1cd318: 0xc642222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1cd31c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cd320: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd324: 0x1000000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19860)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd354;
    }
label_1cd32c:
    // 0x1cd32c: 0x12200003
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cd33c;
    }
    // 0x1cd334: 0x10000067
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d4;
    }
label_1cd33c:
    // 0x1cd33c: 0x1260000d
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cd374;
    }
    // 0x1cd344: 0xc642222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1cd348: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cd34c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd350: 0xc4414d98
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19864)); ctx->f[1] = *(float*)&val; }
label_1cd354:
    // 0x1cd354: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cd358: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd35c: 0x0
    // NOP
    // 0x1cd360: 0x4502005d
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        goto label_1cd4d8;
    }
    // 0x1cd368: 0xae4622a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 8868), GPR_U32(ctx, 6));
    // 0x1cd36c: 0x10000059
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 51));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d4;
    }
label_1cd374:
    // 0x1cd374: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1cd378: 0xc64222a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8864)); ctx->f[2] = *(float*)&val; }
    // 0x1cd37c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1cd380: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd384: 0xc4414d9c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19868)); ctx->f[1] = *(float*)&val; }
    // 0x1cd388: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cd38c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd390: 0x0
    // NOP
    // 0x1cd394: 0x4503004f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 51));
        goto label_1cd4d4;
    }
    // 0x1cd39c: 0x1000004e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d8;
    }
label_1cd3a4:
    // 0x1cd3a4: 0x12200004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cd3b8;
    }
    // 0x1cd3ac: 0x8e4322a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8868)));
    // 0x1cd3b0: 0x14620024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1cd444;
    }
label_1cd3b8:
    // 0x1cd3b8: 0x12600004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cd3cc;
    }
    // 0x1cd3c0: 0x8e4322a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8868)));
    // 0x1cd3c4: 0x14620027
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1cd464;
    }
label_1cd3cc:
    // 0x1cd3cc: 0x4600a805
    ctx->f[0] = FPU_ABS_S(ctx->f[21]);
    // 0x1cd3d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd3d4: 0xc4414da0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19872)); ctx->f[1] = *(float*)&val; }
    // 0x1cd3d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd3dc: 0x0
    // NOP
    // 0x1cd3e0: 0x4500003c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd4d4;
    }
    // 0x1cd3e8: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1cd3ec: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd3f0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cd3f4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd3f8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd3fc: 0xc4414da8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19880)); ctx->f[1] = *(float*)&val; }
    // 0x1cd400: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd404: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cd408: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cd40c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cd410: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd414: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cd418: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd41c: 0x0
    // NOP
    // 0x1cd420: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1cd428;
    }
label_1cd428:
    // 0x1cd428: 0x10000029
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 53));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d0;
    }
label_1cd430:
    // 0x1cd430: 0x12200007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cd450;
    }
    // 0x1cd438: 0x8e4322a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8868)));
    // 0x1cd43c: 0x10620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1cd450;
    }
label_1cd444:
    // 0x1cd444: 0x24060032
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 50));
    // 0x1cd448: 0x10000022
    WRITE32(ADD32(GPR_U32(ctx, 18), 8868), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d4;
    }
label_1cd450:
    // 0x1cd450: 0x12600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cd470;
    }
    // 0x1cd458: 0x8e4322a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8868)));
    // 0x1cd45c: 0x10620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1cd470;
    }
label_1cd464:
    // 0x1cd464: 0x24060034
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1cd468: 0x1000001a
    WRITE32(ADD32(GPR_U32(ctx, 18), 8868), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd4d4;
    }
label_1cd470:
    // 0x1cd470: 0x4600a805
    ctx->f[0] = FPU_ABS_S(ctx->f[21]);
    // 0x1cd474: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd478: 0xc4414da4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19876)); ctx->f[1] = *(float*)&val; }
    // 0x1cd47c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd480: 0x0
    // NOP
    // 0x1cd484: 0x45000013
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd4d4;
    }
    // 0x1cd48c: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1cd490: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd494: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cd498: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd49c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd4a0: 0xc4414dac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19884)); ctx->f[1] = *(float*)&val; }
    // 0x1cd4a4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd4a8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cd4ac: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cd4b0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cd4b4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd4b8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cd4bc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd4c0: 0x0
    // NOP
    // 0x1cd4c4: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1cd4cc;
    }
label_1cd4cc:
    // 0x1cd4cc: 0x24020033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 51));
label_1cd4d0:
    // 0x1cd4d0: 0x43300b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
label_1cd4d4:
    // 0x1cd4d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1cd4d8:
    // 0x1cd4d8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1cd4e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1cd4e0
// Address: 0x1cd4e0 - 0x1cd4e8

void entry_1cd4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd4e0: 0xc073206
    SET_GPR_U32(ctx, 31, 0x1cd4e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CalculateJtHangAccel__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1cd4e8
// Address: 0x1cd4e8 - 0x1cd4fc

void entry_1cd4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd4e8: 0x8e4222ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8876)));
    // 0x1cd4ec: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x1CD500; return;
    }
    // 0x1cd4f4: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1cd4fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1cd4fc
// Address: 0x1cd4fc - 0x1cd5b0

void entry_1cd4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd4fc) {
        switch (ctx->pc) {
            case 0x1cd500: ctx->pc = 0; goto label_1cd500;
            case 0x1cd52c: ctx->pc = 0; goto label_1cd52c;
            case 0x1cd540: ctx->pc = 0; goto label_1cd540;
            case 0x1cd550: ctx->pc = 0; goto label_1cd550;
            case 0x1cd564: ctx->pc = 0; goto label_1cd564;
            case 0x1cd58c: ctx->pc = 0; goto label_1cd58c;
            case 0x1cd594: ctx->pc = 0; goto label_1cd594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd4fc: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
label_1cd500:
    // 0x1cd500: 0x24020035
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 53));
    // 0x1cd504: 0x10620063
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 51));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CD694; return;
    }
    // 0x1cd50c: 0x10620015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 52));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1cd564;
    }
    // 0x1cd514: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 50));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cd52c;
    }
    // 0x1cd51c: 0x10620008
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1cd540;
    }
    // 0x1cd524: 0x1000001b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9100)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd594;
    }
label_1cd52c:
    // 0x1cd52c: 0x24020034
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 52));
    // 0x1cd530: 0x10620007
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1cd550;
    }
    // 0x1cd538: 0x10000016
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9100)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd594;
    }
label_1cd540:
    // 0x1cd540: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cd544: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1cd548: 0x10000010
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd58c;
    }
label_1cd550:
    // 0x1cd550: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cd554: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1cd558: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x1cd55c: 0x1000000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9100)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd594;
    }
label_1cd564:
    // 0x1cd564: 0xc6412388
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9096)); ctx->f[1] = *(float*)&val; }
    // 0x1cd568: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cd56c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd570: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1cd574: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd578: 0x0
    // NOP
    // 0x1cd57c: 0x45000003
    ctx->f[22] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd58c;
    }
    // 0x1cd584: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cd588: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
label_1cd58c:
    // 0x1cd58c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x1cd590: 0xc64c238c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9100)); ctx->f[12] = *(float*)&val; }
label_1cd594:
    // 0x1cd594: 0x26301858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1cd598: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1cd59c: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1cd5a0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1cd5a4: 0x24844db0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19888));
    // 0x1cd5a8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1cd5b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1cd5b0
// Address: 0x1cd5b0 - 0x1cd5d8

void entry_1cd5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd5b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cd5b4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1cd5b8: 0xe640238c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9100), *(uint32_t*)&val); }
    // 0x1cd5bc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1cd5c0: 0xc64c2388
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9096)); ctx->f[12] = *(float*)&val; }
    // 0x1cd5c4: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x1cd5c8: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1cd5cc: 0x24844dc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19904));
    // 0x1cd5d0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1cd5d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1cd5d8
// Address: 0x1cd5d8 - 0x1cd610

void entry_1cd5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd5d8: 0xc641238c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9100)); ctx->f[1] = *(float*)&val; }
    // 0x1cd5dc: 0x4600a081
    ctx->f[2] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1cd5e0: 0xe6402388
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9096), *(uint32_t*)&val); }
    // 0x1cd5e4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1cd5e8: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1cd5ec: 0x8e442384
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9092)));
    // 0x1cd5f0: 0x4601a0c1
    ctx->f[3] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x1cd5f4: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1cd5f8: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1cd5fc: 0x26472360
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 9056));
    // 0x1cd600: 0xe6402360
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9056), *(uint32_t*)&val); }
    // 0x1cd604: 0xe6432378
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 9080), *(uint32_t*)&val); }
    // 0x1cd608: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1cd610);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 9068), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1cd610
// Address: 0x1cd610 - 0x1cd68c

void entry_1cd610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd610) {
        switch (ctx->pc) {
            case 0x1cd644: ctx->pc = 0; goto label_1cd644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd610: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cd614: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1cd618: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cd61c: 0xc4404dcc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19916)); ctx->f[0] = *(float*)&val; }
    // 0x1cd620: 0x4600a803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[0];
    // 0x1cd624: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd628: 0x45010006
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1cd644;
    }
    // 0x1cd630: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd634: 0x0
    // NOP
    // 0x1cd638: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cd644;
    }
    // 0x1cd640: 0x4600a046
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
label_1cd644:
    // 0x1cd644: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cd648: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd64c: 0x26241858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1cd650: 0x8e432384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9092)));
    // 0x1cd654: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1cd658: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cd65c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cd660: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cd664: 0xc46c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1cd668: 0x8e422230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1cd66c: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1cd670: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1cd674: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1cd678: 0xc4ad4dd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 19920)); ctx->f[13] = *(float*)&val; }
    // 0x1cd67c: 0x46026302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x1cd680: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x1cd684: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1cd68c);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cd68c
// Address: 0x1cd68c - 0x1cd6c0

void entry_1cd68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd68c) {
        switch (ctx->pc) {
            case 0x1cd694: ctx->pc = 0; goto label_1cd694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd68c: 0x8e422230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1cd690: 0xe4400018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 24), *(uint32_t*)&val); }
label_1cd694:
    // 0x1cd694: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cd698: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1cd69c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cd6a0: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cd6a4: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cd6a8: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x1cd6ac: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1cd6b0: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1cd6b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cd6bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cd6c0; return;
}


// Function: CheckJtUnhook__FP2JT
// Address: 0x1cd6c0 - 0x1cd6ec

void entry_1cd6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd6ec) {
        switch (ctx->pc) {
            case 0x1cd744: ctx->pc = 0; goto label_1cd744;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd6ec: 0x8e0223d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9172)));
    // 0x1cd6f0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cd6f4: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1cd6f8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd6fc: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1cd700: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cd704: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd708: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cd70c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd710: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd714: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd718: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cd71c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cd720: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd724: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cd728: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd72c: 0x0
    // NOP
    // 0x1cd730: 0x45000028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CD7D4; return;
    }
    // 0x1cd738: 0xae0004b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1208), GPR_U32(ctx, 0));
    // 0x1cd73c: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 16), 8720), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CD7D4; return;
    }
label_1cd744:
    // 0x1cd744: 0x8e022214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8724)));
    // 0x1cd748: 0x10400021
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CD7D0; return;
    }
    // 0x1cd750: 0x8e0623d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9172)));
    // 0x1cd754: 0x8c450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cd758: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cd75c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cd764);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cd764
// Address: 0x1cd764 - 0x1cd798

void entry_1cd764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd764: 0x8e022214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8724)));
    // 0x1cd768: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1cd76c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cd770: 0x8c620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x1cd774: 0x10400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cd798(rdram, ctx, runtime); return;
    }
    // 0x1cd77c: 0xc60c2218
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8728)); ctx->f[12] = *(float*)&val; }
    // 0x1cd780: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cd784: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cd788: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cd78c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cd790: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cd798);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 16), 8728));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cd798
// Address: 0x1cd798 - 0x1cd7e0

void entry_1cd798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd798) {
        switch (ctx->pc) {
            case 0x1cd7d0: ctx->pc = 0; goto label_1cd7d0;
            case 0x1cd7d4: ctx->pc = 0; goto label_1cd7d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd798: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cd79c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd7a0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cd7a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd7a8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd7ac: 0x3c01451c
    SET_GPR_U32(ctx, 1, ((uint32_t)17692 << 16));
    // 0x1cd7b0: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1cd7b4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cd7b8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cd7bc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cd7c0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd7c4: 0x0
    // NOP
    // 0x1cd7c8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 8724), GPR_U32(ctx, 0));
        goto label_1cd7d0;
    }
label_1cd7d0:
    // 0x1cd7d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1cd7d4:
    // 0x1cd7d4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cd7d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtHookOx__FP2JTP2LOi
// Address: 0x1cd7e0 - 0x1cd82c

void entry_1cd82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd82c: 0x10400009
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cd854(rdram, ctx, runtime); return;
    }
    // 0x1cd834: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1cd838: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1cd83c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1cd840: 0xf2400a
    if (GPR_U32(ctx, 18) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 7));
    // 0x1cd844: 0x8c460480
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 1152)));
    // 0x1cd848: 0x8e250480
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x1cd84c: 0xc04e168
    SET_GPR_U32(ctx, 31, 0x1cd854);
    if (GPR_U32(ctx, 18) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 0));
    UpdateSwPox__FP2SWP3OXAT1UcUc(rdram, ctx, runtime); return;
}


// Function: entry_1cd854
// Address: 0x1cd854 - 0x1cd870

void entry_1cd854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd854) {
        switch (ctx->pc) {
            case 0x1cd858: ctx->pc = 0; goto label_1cd858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd854: 0xae2004b8
    WRITE32(ADD32(GPR_U32(ctx, 17), 1208), GPR_U32(ctx, 0));
label_1cd858:
    // 0x1cd858: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cd85c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cd860: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cd864: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cd868: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddJtHookXps__FP2JTiP2LOP6VECTORN23
// Address: 0x1cd870 - 0x1cd8bc

void entry_1cd8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cd8bc: 0x14400007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CD8DC; return;
    }
    // 0x1cd8c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cd8c8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1cd8cc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1cd8d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1cd8d4
// Address: 0x1cd8d4 - 0x1cd954

void entry_1cd8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd8d4) {
        switch (ctx->pc) {
            case 0x1cd8dc: ctx->pc = 0; goto label_1cd8dc;
            case 0x1cd8e8: ctx->pc = 0; goto label_1cd8e8;
            case 0x1cd918: ctx->pc = 0; goto label_1cd918;
            case 0x1cd930: ctx->pc = 0; goto label_1cd930;
            case 0x1cd938: ctx->pc = 0; goto label_1cd938;
            case 0x1cd93c: ctx->pc = 0; goto label_1cd93c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd8d4: 0x10000089
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CDAFC; return;
    }
label_1cd8dc:
    // 0x1cd8dc: 0x327e0001
    SET_GPR_U32(ctx, 30, AND32(GPR_U32(ctx, 19), 1));
    // 0x1cd8e0: 0xafa20044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    // 0x1cd8e4: 0x32770004
    SET_GPR_U32(ctx, 23, AND32(GPR_U32(ctx, 19), 4));
label_1cd8e8:
    // 0x1cd8e8: 0x12000013
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1204));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1cd938;
    }
    // 0x1cd8f0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cd8f4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1cd8f8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1cd8fc: 0x5040fffa
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_1cd8e8;
    }
    // 0x1cd904: 0x1200000d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1cd93c;
    }
    // 0x1cd90c: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x1cd910: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1cd914: 0x8c4b0000
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1cd918:
    // 0x1cd918: 0x11600005
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 11) == GPR_U32(ctx, 0)) {
        goto label_1cd930;
    }
    // 0x1cd920: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x1cd924: 0x5443fffc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 11), 4)));
        goto label_1cd918;
    }
    // 0x1cd92c: 0x160902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
label_1cd930:
    // 0x1cd930: 0x10000002
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd93c;
    }
label_1cd938:
    // 0x1cd938: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_1cd93c:
    // 0x1cd93c: 0x12c00007
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CD95C; return;
    }
    // 0x1cd944: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cd948: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1cd94c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1cd954);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cd954
// Address: 0x1cd954 - 0x1cda2c

void entry_1cd954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cd954) {
        switch (ctx->pc) {
            case 0x1cd95c: ctx->pc = 0; goto label_1cd95c;
            case 0x1cd980: ctx->pc = 0; goto label_1cd980;
            case 0x1cd9fc: ctx->pc = 0; goto label_1cd9fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cd954: 0x1000000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cd980;
    }
label_1cd95c:
    // 0x1cd95c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cd960: 0x244283d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x1cd964: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1cd968: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cd96c: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1cd970: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x1cd974: 0x7fa40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 4));
    // 0x1cd978: 0x7fa50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 5));
    // 0x1cd97c: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
label_1cd980:
    // 0x1cd980: 0xda212400
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 9216)));
    // 0x1cd984: 0xda840000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1cd988: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cd98c: 0x4be12128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cd990: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cd994: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cd998: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cd99c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cd9a0: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cd9a4: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1cd9a8: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cd9ac: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cd9b0: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1cd9b4: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd9b8: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1cd9bc: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd9c0: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cd9c4: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cd9c8: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cd9cc: 0x17c0000b
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        goto label_1cd9fc;
    }
    // 0x1cd9d4: 0x32620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 8));
    // 0x1cd9d8: 0x10400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cda2c(rdram, ctx, runtime); return;
    }
    // 0x1cd9e0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cd9e4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cd9e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cd9ec: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cd9f0: 0x0
    // NOP
    // 0x1cd9f4: 0x4500000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CDA30; return;
    }
label_1cd9fc:
    // 0x1cd9fc: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1cda00: 0x2408000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1cda04: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1cda08: 0x5e400a
    if (GPR_U32(ctx, 30) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 2));
    // 0x1cda0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cda10: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cda14: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cda18: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cda1c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cda20: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cda24: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1cda2c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1cda2c
// Address: 0x1cda2c - 0x1cda8c

void entry_1cda2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cda2c) {
        switch (ctx->pc) {
            case 0x1cda30: ctx->pc = 0; goto label_1cda30;
            case 0x1cda5c: ctx->pc = 0; goto label_1cda5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cda2c: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
label_1cda30:
    // 0x1cda30: 0x1440000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1cda5c;
    }
    // 0x1cda38: 0x32620010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 16));
    // 0x1cda3c: 0x10400013
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cda8c(rdram, ctx, runtime); return;
    }
    // 0x1cda44: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cda48: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cda4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cda50: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cda54: 0x4500000d
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1cda8c(rdram, ctx, runtime); return;
    }
label_1cda5c:
    // 0x1cda5c: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1cda60: 0x2408000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1cda64: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1cda68: 0x43400a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 2));
    // 0x1cda6c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cda70: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cda74: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cda78: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cda7c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cda80: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cda84: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1cda8c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1cda8c
// Address: 0x1cda8c - 0x1cdaf0

void entry_1cda8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cda8c) {
        switch (ctx->pc) {
            case 0x1cdabc: ctx->pc = 0; goto label_1cdabc;
            case 0x1cdad4: ctx->pc = 0; goto label_1cdad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cda8c: 0x16e0000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_1cdabc;
    }
    // 0x1cda94: 0x32620020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 19), 32));
    // 0x1cda98: 0x10400015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cdaf0(rdram, ctx, runtime); return;
    }
    // 0x1cdaa0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cdaa4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cdaa8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cdaac: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cdab0: 0x0
    // NOP
    // 0x1cdab4: 0x4502000f
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1CDAF4; return;
    }
label_1cdabc:
    // 0x1cdabc: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1cdac0: 0x57400b
    if (GPR_U32(ctx, 23) != 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 2));
    // 0x1cdac4: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cdac8: 0x16e00002
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_1cdad4;
    }
    // 0x1cdad0: 0x8e2906d4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
label_1cdad4:
    // 0x1cdad4: 0xc7ac0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1cdad8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cdadc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cdae0: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cdae4: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cdae8: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1cdaf0);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1cdaf0
// Address: 0x1cdaf0 - 0x1cdb28

void entry_1cdaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cdaf0) {
        switch (ctx->pc) {
            case 0x1cdaf4: ctx->pc = 0; goto label_1cdaf4;
            case 0x1cdafc: ctx->pc = 0; goto label_1cdafc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cdaf0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1cdaf4:
    // 0x1cdaf4: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1cdaf8: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1cdafc:
    // 0x1cdafc: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cdb00: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cdb04: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cdb08: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1cdb0c: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cdb10: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cdb14: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cdb18: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cdb1c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cdb20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJtHangHeading__FP2JTPf
// Address: 0x1cdb28 - 0x1cdb50

void entry_1cdb50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdb50: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1cdb54: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1cdb5c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1cdb5c
// Address: 0x1cdb5c - 0x1cdb70

void entry_1cdb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdb5c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1cdb60: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cdb64: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cdb68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtIkHang__FP2JT
// Address: 0x1cdb70 - 0x1cdbc8

void entry_1cdbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdbc8: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1cdbcc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cdbd0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cdbd4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cdbdc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cdbdc
// Address: 0x1cdbdc - 0x1cdbfc

void entry_1cdbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdbdc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cdbe0: 0x26248d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294937856));
    // 0x1cdbe4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cdbe8: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cdbec: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cdbf0: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cdbf4: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1cdbfc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cdbfc
// Address: 0x1cdbfc - 0x1cdc94

void entry_1cdbfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cdbfc) {
        switch (ctx->pc) {
            case 0x1cdc64: ctx->pc = 0; goto label_1cdc64;
            case 0x1cdc70: ctx->pc = 0; goto label_1cdc70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cdbfc: 0x8e422204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x1cdc00: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cdc04: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cdc08: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cdc0c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cdc10: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cdc14: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdc18: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x1cdc1c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cdc20: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cdc24: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cdc28: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1cdc2c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cdc30: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cdc34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cdc38: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cdc3c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cdc40: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cdc44: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cdc48: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cdc4c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1cdc50: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cdc54: 0x45000003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cdc64;
    }
    // 0x1cdc5c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cdc70;
    }
label_1cdc64:
    // 0x1cdc64: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1cdc68: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cdc6c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1cdc70:
    // 0x1cdc70: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cdc74: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cdc78: 0x4be20848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdc7c: 0x26308d00
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294937856));
    // 0x1cdc80: 0xc44c4dd4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19924)); ctx->f[12] = *(float*)&val; }
    // 0x1cdc84: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cdc88: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cdc8c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1cdc94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cdc94
// Address: 0x1cdc94 - 0x1cdd08

void entry_1cdc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdc94: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cdc98: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cdc9c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cdca0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cdca4: 0xdba60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cdca8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cdcac: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cdcb0: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cdcb4: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1cdcb8: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cdcbc: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdcc0: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cdcc4: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cdcc8: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdccc: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cdcd0: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cdcd4: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cdcd8: 0x4bc5104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdcdc: 0xc44c4dd8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19928)); ctx->f[12] = *(float*)&val; }
    // 0x1cdce0: 0xfa630000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdce4: 0xfa640010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cdce8: 0xfa610020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cdcec: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdcf0: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdcf4: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cdcf8: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cdcfc: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cdd00: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1cdd08);
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1cdd08
// Address: 0x1cdd08 - 0x1cdd98

void entry_1cdd08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdd08: 0x8e4223d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9172)));
    // 0x1cdd0c: 0x8e4323d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9168)));
    // 0x1cdd10: 0xda850020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1cdd14: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1cdd18: 0xda810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1cdd1c: 0xd8420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x1cdd20: 0x8e42061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1564)));
    // 0x1cdd24: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cdd28: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd2c: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdd30: 0xd8640100
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x1cdd34: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1cdd38: 0x4be22128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd3c: 0xda610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1cdd40: 0xda650020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1cdd44: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cdd48: 0x4bc408bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd4c: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdd50: 0xd8420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x1cdd54: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd58: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cdd5c: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cdd60: 0x4be218ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd64: 0x7bbf0160
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1cdd68: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1cdd6c: 0xd8410100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x1cdd70: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cdd74: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cdd78: 0xfaa10000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cdd7c: 0x7bb50150
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1cdd80: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1cdd84: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1cdd88: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1cdd8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cdd94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cdd98; return;
}


// Function: FUN_001cdd98
// Address: 0x1cdd98 - 0x1cddd4

void FUN_001cdd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdd98: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x1cdd9c: 0x7fb30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 19));
    // 0x1cdda0: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cdda4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cdda8: 0x7fbf0130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 31));
    // 0x1cddac: 0x7fb50120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 21));
    // 0x1cddb0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cddb4: 0x7fb40110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 20));
    // 0x1cddb8: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1cddbc: 0x7fb200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 18));
    // 0x1cddc0: 0x7fb100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 17));
    // 0x1cddc4: 0x26742300
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 19), 8960));
    // 0x1cddc8: 0x7fb000d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 16));
    // 0x1cddcc: 0xc0736dc
    SET_GPR_U32(ctx, 31, 0x1cddd4);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 19), 9008));
    UpdateJtIkHang__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1cddd4
// Address: 0x1cddd4 - 0x1cde00

void entry_1cddd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cddd4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cddd8: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x1cdddc: 0x26521858
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x1cdde0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1cdde4: 0x7a6422f0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 19), 8944)));
    // 0x1cdde8: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1cddec: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1cddf0: 0x24c64de0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19936));
    // 0x1cddf4: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cddf8: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1cde00);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1cde00
// Address: 0x1cde00 - 0x1cde30

void entry_1cde00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cde00: 0x7e6222f0
    WRITE128(ADD32(GPR_U32(ctx, 19), 8944), GPR_VEC(ctx, 2));
    // 0x1cde04: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1cde08: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1cde0c: 0x261083d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294935504));
    // 0x1cde10: 0x26314df0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 19952));
    // 0x1cde14: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1cde18: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cde1c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cde20: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cde24: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cde28: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x1cde30);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_1cde30
// Address: 0x1cde30 - 0x1cde4c

void entry_1cde30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cde30: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1cde34: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cde38: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1cde3c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1cde40: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cde44: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x1cde4c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_1cde4c
// Address: 0x1cde4c - 0x1cdf44

void entry_1cde4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cde4c: 0xda6222f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 8944)));
    // 0x1cde50: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cde54: 0x8e62251c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 9500)));
    // 0x1cde58: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cde5c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cde60: 0xf8410020
    WRITE128(ADD32(GPR_U32(ctx, 2), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cde64: 0xda820020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x1cde68: 0xda810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1cde6c: 0xda632300
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 8960)));
    // 0x1cde70: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cde74: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cde78: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cde7c: 0x4bc608bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1cde80: 0x4bc6118a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cde84: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cde88: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1cde8c: 0x4bc408bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1cde90: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cde94: 0x8e64251c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9500)));
    // 0x1cde98: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cde9c: 0x4bc508bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1cdea0: 0x4bc510ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdea4: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cdea8: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdeac: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdeb0: 0xfba60070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdeb4: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1cdeb8: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdebc: 0xf8860040
    WRITE128(ADD32(GPR_U32(ctx, 4), 64), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdec0: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cdec4: 0x7c820050
    WRITE128(ADD32(GPR_U32(ctx, 4), 80), GPR_VEC(ctx, 2));
    // 0x1cdec8: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cdecc: 0x7c830060
    WRITE128(ADD32(GPR_U32(ctx, 4), 96), GPR_VEC(ctx, 3));
    // 0x1cded0: 0xdaa40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1cded4: 0xdaa20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1cded8: 0xda652330
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 9008)));
    // 0x1cdedc: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cdee0: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1cdee4: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1cdee8: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdeec: 0xdba60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cdef0: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdef4: 0x4bc629bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1cdef8: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1cdefc: 0x4bc6218a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdf00: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cdf04: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1cdf08: 0x4bc110bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cdf0c: 0x4bc1214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cdf10: 0x8e642520
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9504)));
    // 0x1cdf14: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdf18: 0xfba60070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdf1c: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cdf20: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cdf24: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cdf28: 0xf8860040
    WRITE128(ADD32(GPR_U32(ctx, 4), 64), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1cdf2c: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cdf30: 0x7c820050
    WRITE128(ADD32(GPR_U32(ctx, 4), 80), GPR_VEC(ctx, 2));
    // 0x1cdf34: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cdf38: 0x7c830060
    WRITE128(ADD32(GPR_U32(ctx, 4), 96), GPR_VEC(ctx, 3));
    // 0x1cdf3c: 0xc048592
    SET_GPR_U32(ctx, 31, 0x1cdf44);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9500)));
    SnapAct__FP3ACTi(rdram, ctx, runtime); return;
}


// Function: entry_1cdf44
// Address: 0x1cdf44 - 0x1cdf50

void entry_1cdf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdf44: 0x8e642520
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9504)));
    // 0x1cdf48: 0xc048592
    SET_GPR_U32(ctx, 31, 0x1cdf50);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnapAct__FP3ACTi(rdram, ctx, runtime); return;
}


// Function: entry_1cdf50
// Address: 0x1cdf50 - 0x1cdf78

void entry_1cdf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdf50: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cdf54: 0x7bb50120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1cdf58: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1cdf5c: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1cdf60: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cdf64: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1cdf68: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cdf6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cdf74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cdf78; return;
}


// Function: FUN_001cdf78
// Address: 0x1cdf78 - 0x1cdf98

void FUN_001cdf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cdf78: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1cdf7c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1cdf80: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1cdf84: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1cdf88: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1CDFA0; return;
    }
    // 0x1cdf90: 0xc048974
    SET_GPR_U32(ctx, 31, 0x1cdf98);
    PredictAloRotation__FP3ALOfP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cdf98
// Address: 0x1cdf98 - 0x1cdfa8

void entry_1cdf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cdf98) {
        switch (ctx->pc) {
            case 0x1cdfa0: ctx->pc = 0; goto label_1cdfa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cdf98: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CDFAC; return;
    }
label_1cdfa0:
    // 0x1cdfa0: 0xc07176e
    SET_GPR_U32(ctx, 31, 0x1cdfa8);
    PredictStepRotation__FP4STEPfP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cdfa8
// Address: 0x1cdfa8 - 0x1cdfb8

void entry_1cdfa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cdfa8) {
        switch (ctx->pc) {
            case 0x1cdfac: ctx->pc = 0; goto label_1cdfac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cdfa8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1cdfac:
    // 0x1cdfac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cdfb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cdfb8; return;
}


// Function: JtbsChooseJtHide__FP2JTP2LOP4JTHK
// Address: 0x1cdfb8 - 0x1ce040

void entry_1ce040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce040: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1ce044: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ce048: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1ce04c: 0x10400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ce06c(rdram, ctx, runtime); return;
    }
    // 0x1ce054: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce058: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ce05c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce060: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce064: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ce06c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ce06c
// Address: 0x1ce06c - 0x1ce0f0

void entry_1ce06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce06c) {
        switch (ctx->pc) {
            case 0x1ce0b8: ctx->pc = 0; goto label_1ce0b8;
            case 0x1ce0c8: ctx->pc = 0; goto label_1ce0c8;
            case 0x1ce0d4: ctx->pc = 0; goto label_1ce0d4;
            case 0x1ce0e8: ctx->pc = 0; goto label_1ce0e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce06c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ce070: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ce074: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce078: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce07c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce080: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce084: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce088: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce08c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce090: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce094: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce098: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ce09c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce0a0: 0x0
    // NOP
    // 0x1ce0a4: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[23] = *(float*)&val; }
        goto label_1ce0b8;
    }
    // 0x1ce0ac: 0x56130006
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        goto label_1ce0c8;
    }
    // 0x1ce0b4: 0xc7b70020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[23] = *(float*)&val; }
label_1ce0b8:
    // 0x1ce0b8: 0x4600a529
    ctx->f[20] = std::min(ctx->f[20], ctx->f[0]);
    // 0x1ce0bc: 0x200b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce0c0: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce0c4: 0x8e100038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
label_1ce0c8:
    // 0x1ce0c8: 0x5600ffd9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x1CE030; return;
    }
    // 0x1ce0d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1ce0d4:
    // 0x1ce0d4: 0x8c5026f8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 9976)));
    // 0x1ce0d8: 0x12000021
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE160; return;
    }
    // 0x1ce0e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce0e4: 0x0
    // NOP
label_1ce0e8:
    // 0x1ce0e8: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1ce0f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ce0f0
// Address: 0x1ce0f0 - 0x1ce22c

void entry_1ce0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce0f0) {
        switch (ctx->pc) {
            case 0x1ce148: ctx->pc = 0; goto label_1ce148;
            case 0x1ce154: ctx->pc = 0; goto label_1ce154;
            case 0x1ce160: ctx->pc = 0; goto label_1ce160;
            case 0x1ce178: ctx->pc = 0; goto label_1ce178;
            case 0x1ce1c8: ctx->pc = 0; goto label_1ce1c8;
            case 0x1ce1d4: ctx->pc = 0; goto label_1ce1d4;
            case 0x1ce1e0: ctx->pc = 0; goto label_1ce1e0;
            case 0x1ce1f8: ctx->pc = 0; goto label_1ce1f8;
            case 0x1ce224: ctx->pc = 0; goto label_1ce224;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce0f0: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1ce0f4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ce0f8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce0fc: 0xc600005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[0] = *(float*)&val; }
    // 0x1ce100: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce104: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce108: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce10c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce110: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce114: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce118: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce11c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce120: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1ce124: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1ce128: 0x46000045
    ctx->f[1] = FPU_ABS_S(ctx->f[0]);
    // 0x1ce12c: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce130: 0x0
    // NOP
    // 0x1ce134: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = std::min(ctx->f[20], ctx->f[1]);
        goto label_1ce148;
    }
    // 0x1ce13c: 0x56130005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_1ce154;
    }
    // 0x1ce144: 0x4601a529
    ctx->f[20] = std::min(ctx->f[20], ctx->f[1]);
label_1ce148:
    // 0x1ce148: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce14c: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ce150: 0x8e100050
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_1ce154:
    // 0x1ce154: 0x1600ffe4
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE0E8; return;
    }
    // 0x1ce15c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1ce160:
    // 0x1ce160: 0x8c422708
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 9992)));
    // 0x1ce164: 0x5040001e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1ce1e0;
    }
    // 0x1ce16c: 0xda430140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1ce170: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1ce174: 0x0
    // NOP
label_1ce178:
    // 0x1ce178: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce17c: 0xc4400560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 1376)); ctx->f[0] = *(float*)&val; }
    // 0x1ce180: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce184: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce188: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce18c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce190: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce194: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce198: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce19c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce1a0: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1ce1a4: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1ce1a8: 0x46000045
    ctx->f[1] = FPU_ABS_S(ctx->f[0]);
    // 0x1ce1ac: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce1b0: 0x0
    // NOP
    // 0x1ce1b4: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
        goto label_1ce1c8;
    }
    // 0x1ce1bc: 0x54530005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1368)));
        goto label_1ce1d4;
    }
    // 0x1ce1c4: 0xafa20028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
label_1ce1c8:
    // 0x1ce1c8: 0x4601a529
    ctx->f[20] = std::min(ctx->f[20], ctx->f[1]);
    // 0x1ce1cc: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ce1d0: 0x8c420558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1368)));
label_1ce1d4:
    // 0x1ce1d4: 0x5440ffe8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
        goto label_1ce178;
    }
    // 0x1ce1dc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1ce1e0:
    // 0x1ce1e0: 0x8c5058d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 22736)));
    // 0x1ce1e4: 0x12000030
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE2A8; return;
    }
    // 0x1ce1ec: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1ce1f0: 0x8e422210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8720)));
    // 0x1ce1f4: 0x0
    // NOP
label_1ce1f8:
    // 0x1ce1f8: 0x52020029
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CE2A0; return;
    }
    // 0x1ce200: 0x8e020088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 136)));
    // 0x1ce204: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1ce208: 0x50400025
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CE2A0; return;
    }
    // 0x1ce210: 0x12600004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1ce224;
    }
    // 0x1ce218: 0x56130021
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CE2A0; return;
    }
    // 0x1ce220: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ce224:
    // 0x1ce224: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1ce22c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1ce22c
// Address: 0x1ce22c - 0x1ce23c

void entry_1ce22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce22c: 0x1040001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE29C; return;
    }
    // 0x1ce234: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1ce23c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ce23c
// Address: 0x1ce23c - 0x1ce2d0

void entry_1ce23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce23c) {
        switch (ctx->pc) {
            case 0x1ce294: ctx->pc = 0; goto label_1ce294;
            case 0x1ce29c: ctx->pc = 0; goto label_1ce29c;
            case 0x1ce2a0: ctx->pc = 0; goto label_1ce2a0;
            case 0x1ce2a8: ctx->pc = 0; goto label_1ce2a8;
            case 0x1ce2c0: ctx->pc = 0; goto label_1ce2c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce23c: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1ce240: 0x4615a0a9
    ctx->f[2] = std::min(ctx->f[20], ctx->f[21]);
    // 0x1ce244: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ce248: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce24c: 0xc6214e08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 19976)); ctx->f[1] = *(float*)&val; }
    // 0x1ce250: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce254: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce258: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce25c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce260: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce264: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce268: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce26c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce270: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ce274: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ce278: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce27c: 0x0
    // NOP
    // 0x1ce280: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = std::min(ctx->f[20], ctx->f[0]);
        goto label_1ce294;
    }
    // 0x1ce288: 0x56130005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        goto label_1ce2a0;
    }
    // 0x1ce290: 0x4600a529
    ctx->f[20] = std::min(ctx->f[20], ctx->f[0]);
label_1ce294:
    // 0x1ce294: 0x200b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce298: 0x24140006
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 6));
label_1ce29c:
    // 0x1ce29c: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
label_1ce2a0:
    // 0x1ce2a0: 0x5600ffd5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8720)));
        ctx->pc = 0x1CE1F8; return;
    }
label_1ce2a8:
    // 0x1ce2a8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ce2ac: 0x8c519ba8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4294941608)));
    // 0x1ce2b0: 0x52200037
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x1CE390; return;
    }
    // 0x1ce2b8: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1ce2bc: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
label_1ce2c0:
    // 0x1ce2c0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce2c4: 0x26460140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1ce2c8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1ce2d0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ce2d0
// Address: 0x1ce2d0 - 0x1ce300

void entry_1ce2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce2d0: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1ce2d4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ce2d8: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1ce2dc: 0x10400008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ce300(rdram, ctx, runtime); return;
    }
    // 0x1ce2e4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce2e8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce2ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce2f0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce2f4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce2f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ce300);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 36));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ce300
// Address: 0x1ce300 - 0x1ce314

void entry_1ce300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce300: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce304: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1ce308: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce30c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1ce314);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ce314
// Address: 0x1ce314 - 0x1ce3bc

void entry_1ce314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce314) {
        switch (ctx->pc) {
            case 0x1ce370: ctx->pc = 0; goto label_1ce370;
            case 0x1ce384: ctx->pc = 0; goto label_1ce384;
            case 0x1ce390: ctx->pc = 0; goto label_1ce390;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce314: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1ce318: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ce31c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ce320: 0x4615a0a9
    ctx->f[2] = std::min(ctx->f[20], ctx->f[21]);
    // 0x1ce324: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce328: 0xc4614e08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19976)); ctx->f[1] = *(float*)&val; }
    // 0x1ce32c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce330: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce334: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce338: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce33c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce340: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce344: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce348: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce34c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ce350: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ce354: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce358: 0x0
    // NOP
    // 0x1ce35c: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = std::min(ctx->f[20], ctx->f[0]);
        goto label_1ce370;
    }
    // 0x1ce364: 0x56330007
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
        goto label_1ce384;
    }
    // 0x1ce36c: 0x4600a029
    ctx->f[0] = std::min(ctx->f[20], ctx->f[0]);
label_1ce370:
    // 0x1ce370: 0xc7b60024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[22] = *(float*)&val; }
    // 0x1ce374: 0xafb1002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 17));
    // 0x1ce378: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1ce37c: 0x24140007
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1ce380: 0x8e310038
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
label_1ce384:
    // 0x1ce384: 0x5620ffce
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x1CE2C0; return;
    }
    // 0x1ce38c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1ce390:
    // 0x1ce390: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ce394: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1ce398: 0x8c851ce4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 7396)));
    // 0x1ce39c: 0x10a00027
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE43C; return;
    }
    // 0x1ce3a4: 0x8c822300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8960)));
    // 0x1ce3a8: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1ce3ac: 0x14400024
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE440; return;
    }
    // 0x1ce3b4: 0xc066800
    SET_GPR_U32(ctx, 31, 0x1ce3bc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 1888)));
    FUN_0019a000(rdram, ctx, runtime); return;
}


// Function: entry_1ce3bc
// Address: 0x1ce3bc - 0x1ce3d8

void entry_1ce3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce3bc: 0x14400020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE440; return;
    }
    // 0x1ce3c4: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1ce3c8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce3cc: 0x8c621ce4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7396)));
    // 0x1ce3d0: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1ce3d8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1560)));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ce3d8
// Address: 0x1ce3d8 - 0x1ce4bc

void entry_1ce3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce3d8) {
        switch (ctx->pc) {
            case 0x1ce430: ctx->pc = 0; goto label_1ce430;
            case 0x1ce43c: ctx->pc = 0; goto label_1ce43c;
            case 0x1ce440: ctx->pc = 0; goto label_1ce440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce3d8: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1ce3dc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ce3e0: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ce3e4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce3e8: 0xc4404e18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19992)); ctx->f[0] = *(float*)&val; }
    // 0x1ce3ec: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce3f0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce3f4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce3f8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce3fc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce400: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce404: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce408: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce40c: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1ce410: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce414: 0x0
    // NOP
    // 0x1ce418: 0x45010005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ce430;
    }
    // 0x1ce420: 0x8c431ce4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7396)));
    // 0x1ce424: 0x14730006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 8));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 19)) {
        goto label_1ce440;
    }
    // 0x1ce42c: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
label_1ce430:
    // 0x1ce430: 0x24140005
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ce434: 0x8c421ce4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 7396)));
    // 0x1ce438: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
label_1ce43c:
    // 0x1ce43c: 0x2e820008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 8));
label_1ce440:
    // 0x1ce440: 0x10400036
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE51C; return;
    }
    // 0x1ce448: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1ce44c: 0x2442dab0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957744));
    // 0x1ce450: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ce454: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ce458: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1ce460: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x1ce464: 0x24030015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1ce468: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1ce46c: 0xe65723a4
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 18), 9124), *(uint32_t*)&val); }
    // 0x1ce470: 0x10000036
    WRITE32(ADD32(GPR_U32(ctx, 18), 9120), GPR_U32(ctx, 23));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE54C; return;
    }
    // 0x1ce478: 0x8fc20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 88)));
    // 0x1ce47c: 0x24030015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1ce480: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1ce484: 0x10000031
    WRITE32(ADD32(GPR_U32(ctx, 18), 9128), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE54C; return;
    }
    // 0x1ce48c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ce490: 0x24030015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1ce494: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1ce498: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1ce49c: 0x1000002b
    WRITE32(ADD32(GPR_U32(ctx, 18), 9136), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE54C; return;
    }
    // 0x1ce4a4: 0xae562200
    WRITE32(ADD32(GPR_U32(ctx, 18), 8704), GPR_U32(ctx, 22));
    // 0x1ce4a8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ce4ac: 0xae562204
    WRITE32(ADD32(GPR_U32(ctx, 18), 8708), GPR_U32(ctx, 22));
    // 0x1ce4b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce4b4: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1ce4bc);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8712), GPR_U32(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1ce4bc
// Address: 0x1ce4bc - 0x1ce4c4

void entry_1ce4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce4bc: 0xc071a24
    SET_GPR_U32(ctx, 31, 0x1ce4c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateJtCane__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1ce4c4
// Address: 0x1ce4c4 - 0x1ce4f0

void entry_1ce4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce4c4: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1ce4c8: 0x1000001f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE548; return;
    }
    // 0x1ce4d0: 0x8fa3002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1ce4d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ce4d8: 0xe656220c
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 18), 8716), *(uint32_t*)&val); }
    // 0x1ce4dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce4e0: 0xae432208
    WRITE32(ADD32(GPR_U32(ctx, 18), 8712), GPR_U32(ctx, 3));
    // 0x1ce4e4: 0xae402204
    WRITE32(ADD32(GPR_U32(ctx, 18), 8708), GPR_U32(ctx, 0));
    // 0x1ce4e8: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1ce4f0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8704), GPR_U32(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1ce4f0
// Address: 0x1ce4f0 - 0x1ce4f8

void entry_1ce4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce4f0: 0xc071a24
    SET_GPR_U32(ctx, 31, 0x1ce4f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateJtCane__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1ce4f8
// Address: 0x1ce4f8 - 0x1ce524

void entry_1ce4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce4f8) {
        switch (ctx->pc) {
            case 0x1ce51c: ctx->pc = 0; goto label_1ce51c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce4f8: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1ce4fc: 0x10000012
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE548; return;
    }
    // 0x1ce504: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1ce508: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ce50c: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
    // 0x1ce510: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ce514: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 18), 9164), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE54C; return;
    }
label_1ce51c:
    // 0x1ce51c: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1ce524);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1ce524
// Address: 0x1ce524 - 0x1ce590

void entry_1ce524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce524) {
        switch (ctx->pc) {
            case 0x1ce540: ctx->pc = 0; goto label_1ce540;
            case 0x1ce548: ctx->pc = 0; goto label_1ce548;
            case 0x1ce54c: ctx->pc = 0; goto label_1ce54c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce524: 0x3c030001
    SET_GPR_U32(ctx, 3, ((uint32_t)1 << 16));
    // 0x1ce528: 0x34632000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 8192));
    // 0x1ce52c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ce530: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ce540;
    }
    // 0x1ce538: 0x10000003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ce548;
    }
label_1ce540:
    // 0x1ce540: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ce544: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1ce548:
    // 0x1ce548: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
label_1ce54c:
    // 0x1ce54c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ce550: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1ce554: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ce558: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ce55c: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ce560: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ce564: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ce568: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ce56c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ce570: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ce574: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ce578: 0xc7b700f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[23] = *(float*)&val; }
    // 0x1ce57c: 0xc7b600f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[22] = *(float*)&val; }
    // 0x1ce580: 0xc7b500e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[21] = *(float*)&val; }
    // 0x1ce584: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x1ce588: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1
// Address: 0x1ce590 - 0x1ce5fc

void entry_1ce5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce5fc: 0x8e2506d4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1ce600: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ce604: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ce608: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce60c: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce610: 0xc05feb0
    SET_GPR_U32(ctx, 31, 0x1ce618);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 80));
    FTimeJtJumpToTarget__FP2JTP6VECTORN31Pf(rdram, ctx, runtime); return;
}


// Function: entry_1ce618
// Address: 0x1ce618 - 0x1ce720

void entry_1ce618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce618) {
        switch (ctx->pc) {
            case 0x1ce678: ctx->pc = 0; goto label_1ce678;
            case 0x1ce698: ctx->pc = 0; goto label_1ce698;
            case 0x1ce6d8: ctx->pc = 0; goto label_1ce6d8;
            case 0x1ce6e4: ctx->pc = 0; goto label_1ce6e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce618: 0x1440001f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ce698;
    }
    // 0x1ce620: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ce624: 0xc6630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1ce628: 0xc6210358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 856)); ctx->f[1] = *(float*)&val; }
    // 0x1ce62c: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x1ce630: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ce634: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1ce638: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x1ce63c: 0x8e2206d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1ce640: 0x46001807
    ctx->f[0] = FPU_NEG_S(ctx->f[3]);
    // 0x1ce644: 0xc6050008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[5] = *(float*)&val; }
    // 0x1ce648: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1ce64c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1ce650: 0x46051081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[5]);
    // 0x1ce654: 0x46060028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[6]);
    // 0x1ce658: 0x46040102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1ce65c: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1ce660: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1ce664: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ce668: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1ce66c: 0x12400002
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1ce678;
    }
    // 0x1ce674: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_1ce678:
    // 0x1ce678: 0x12800056
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE7D4; return;
    }
    // 0x1ce680: 0x3c014976
    SET_GPR_U32(ctx, 1, ((uint32_t)18806 << 16));
    // 0x1ce684: 0x34219500
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 38144));
    // 0x1ce688: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ce68c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ce690: 0x10000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE7D4; return;
    }
label_1ce698:
    // 0x1ce698: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x1ce69c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1ce6a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ce6a4: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ce6a8: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1ce6ac: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ce6b0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ce6b4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ce6b8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ce6bc: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce6c0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce6c4: 0x12a00004
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1ce6d8;
    }
    // 0x1ce6cc: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1ce6d0: 0x4be11868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ce6d4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1ce6d8:
    // 0x1ce6d8: 0x12400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1ce6e4;
    }
    // 0x1ce6e0: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_1ce6e4:
    // 0x1ce6e4: 0x12800034
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CE7B8; return;
    }
    // 0x1ce6ec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ce6f0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1ce6f4: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x1ce6f8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce6fc: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1ce700: 0x27aa0020
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ce704: 0x8e2406d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1ce708: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1ce70c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ce710: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce714: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce718: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1ce720);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1ce720
// Address: 0x1ce720 - 0x1ce76c

void entry_1ce720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce720: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ce724: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1ce728: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce72c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce730: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x1ce734: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce738: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce73c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce740: 0x8e2406d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1ce744: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce748: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ce74c: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1ce750: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce754: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1ce758: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce75c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce760: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ce764: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1ce76c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1ce76c
// Address: 0x1ce76c - 0x1ce800

void entry_1ce76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce76c) {
        switch (ctx->pc) {
            case 0x1ce7b8: ctx->pc = 0; goto label_1ce7b8;
            case 0x1ce7c4: ctx->pc = 0; goto label_1ce7c4;
            case 0x1ce7d0: ctx->pc = 0; goto label_1ce7d0;
            case 0x1ce7d4: ctx->pc = 0; goto label_1ce7d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce76c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ce770: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce774: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce778: 0xc7a00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    // 0x1ce77c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce780: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce784: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce788: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ce78c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1ce790: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce794: 0x3c014974
    SET_GPR_U32(ctx, 1, ((uint32_t)18804 << 16));
    // 0x1ce798: 0x34212400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 9216));
    // 0x1ce79c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ce7a0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1ce7a4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1ce7a8: 0x4601a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[1]);
    // 0x1ce7ac: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ce7b0: 0x4602a529
    ctx->f[20] = std::min(ctx->f[20], ctx->f[2]);
    // 0x1ce7b4: 0xe6940000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
label_1ce7b8:
    // 0x1ce7b8: 0x12c00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_1ce7c4;
    }
    // 0x1ce7c0: 0x7ec20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
label_1ce7c4:
    // 0x1ce7c4: 0x12e00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_1ce7d0;
    }
    // 0x1ce7cc: 0x7ee20000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), GPR_VEC(ctx, 2));
label_1ce7d0:
    // 0x1ce7d0: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1ce7d4:
    // 0x1ce7d4: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ce7d8: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ce7dc: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ce7e0: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ce7e4: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ce7e8: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ce7ec: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ce7f0: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ce7f4: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1ce7f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJtRailLanding__FP2JTP4RAILfP6VECTORT3
// Address: 0x1ce800 - 0x1ce85c

void entry_1ce85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce85c: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1ce860: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ce864: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ce868: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1ce870);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ce870
// Address: 0x1ce870 - 0x1ce888

void entry_1ce870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce870: 0x3c120027
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    // 0x1ce874: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1ce878: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ce87c: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ce880: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1ce888);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ce888
// Address: 0x1ce888 - 0x1ce8c8

void entry_1ce888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce888: 0xda210e90
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 3728)));
    // 0x1ce88c: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ce890: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce894: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce898: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce89c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce8a0: 0xc6200634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[0] = *(float*)&val; }
    // 0x1ce8a4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce8a8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ce8ac: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ce8b0: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1ce8b4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce8b8: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1ce8bc: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1ce8c0: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1ce8c8);
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1ce8c8
// Address: 0x1ce8c8 - 0x1ce900

void entry_1ce8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce8c8: 0x8e640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    // 0x1ce8cc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ce8d0: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ce8d4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ce8d8: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ce8dc: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ce8e0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ce8e4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ce8e8: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ce8ec: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1ce8f0: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ce8f4: 0x4483a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 3);
    // 0x1ce8f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ce900);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ce900
// Address: 0x1ce900 - 0x1ce948

void entry_1ce900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce900: 0xc6220e90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3728)); ctx->f[2] = *(float*)&val; }
    // 0x1ce904: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ce908: 0xc6210e40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3648)); ctx->f[1] = *(float*)&val; }
    // 0x1ce90c: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x1ce910: 0xc4434e1c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19996)); ctx->f[3] = *(float*)&val; }
    // 0x1ce914: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1ce918: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1ce91c: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1ce920: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ce924: 0xc64d4e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 19972)); ctx->f[13] = *(float*)&val; }
    // 0x1ce928: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1ce92c: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1ce930: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x1ce934: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ce938: 0xe7a20050
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1ce93c: 0xe7a30058
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x1ce940: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1ce948);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1ce948
// Address: 0x1ce948 - 0x1ce95c

void entry_1ce948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce948: 0x8e640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    // 0x1ce94c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ce950: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1ce954: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ce95c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ce95c
// Address: 0x1ce95c - 0x1ce978

void entry_1ce95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ce95c: 0xc64d4e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 19972)); ctx->f[13] = *(float*)&val; }
    // 0x1ce960: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ce964: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1ce968: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ce96c: 0x460d0341
    ctx->f[13] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x1ce970: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1ce978);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 116));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1ce978
// Address: 0x1ce978 - 0x1ce9e8

void entry_1ce978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ce978) {
        switch (ctx->pc) {
            case 0x1ce9a4: ctx->pc = 0; goto label_1ce9a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ce978: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x1ce97c: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ce980: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce984: 0xc7a10074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 116)); ctx->f[1] = *(float*)&val; }
    // 0x1ce988: 0x45010006
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ce9a4;
    }
    // 0x1ce990: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ce994: 0x0
    // NOP
    // 0x1ce998: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ce9a4;
    }
    // 0x1ce9a0: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
label_1ce9a4:
    // 0x1ce9a4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ce9a8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ce9ac: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ce9b0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ce9b4: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ce9b8: 0xfaa10000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ce9bc: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ce9c0: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ce9c4: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ce9c8: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ce9cc: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ce9d0: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ce9d4: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ce9d8: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x1ce9dc: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1ce9e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GMeasureJumpRail__FP3MJRf
// Address: 0x1ce9e8 - 0x1cea14

void entry_1cea14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cea14: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cea18: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1cea1c: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1cea20: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cea24: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cea28: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cea2c: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cea30: 0x27aa0030
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cea34: 0x8c460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cea38: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1cea40);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1cea40
// Address: 0x1cea40 - 0x1cea58

void entry_1cea40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cea40: 0xc7a00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1cea44: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cea48: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cea4c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cea50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cea58
// Address: 0x1cea58 - 0x1cea78

void FUN_001cea58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cea58: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1cea5c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cea60: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1cea64: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cea68: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1cea6c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cea70: 0xc05a890
    SET_GPR_U32(ctx, 31, 0x1cea78);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_1cea78
// Address: 0x1cea78 - 0x1ceaa4

void entry_1cea78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cea78: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cea7c: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1cea80: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1cea84: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cea88: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cea8c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cea90: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cea94: 0x27aa0020
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cea98: 0x8c460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1cea9c: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1ceaa4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1ceaa4
// Address: 0x1ceaa4 - 0x1ceab8

void entry_1ceaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ceaa4: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1ceaa8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ceaac: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ceab0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GMeasureJumpHshape__FP3MJHf
// Address: 0x1ceab8 - 0x1cead8

void entry_1cead8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cead8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ceadc: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1ceae0: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x1ceae4: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ceae8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceaec: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceaf0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ceaf4: 0x27aa0020
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ceaf8: 0x8c460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1ceafc: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1ceb04);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1ceb04
// Address: 0x1ceb04 - 0x1ceb18

void entry_1ceb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ceb04: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1ceb08: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ceb0c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ceb10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ceb18
// Address: 0x1ceb18 - 0x1cebb4

void FUN_001ceb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ceb18: 0x27bdff30
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967088));
    // 0x1ceb1c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ceb20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ceb24: 0xe7b400c0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 192), *(uint32_t*)&val); }
    // 0x1ceb28: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x1ceb2c: 0x7fb300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 19));
    // 0x1ceb30: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ceb34: 0x7fb20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 18));
    // 0x1ceb38: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1ceb3c: 0x100902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1ceb40: 0x7fb10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 17));
    // 0x1ceb44: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ceb48: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ceb4c: 0x7fb00070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 16));
    // 0x1ceb50: 0x7fbf00b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 31));
    // 0x1ceb54: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ceb58: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ceb5c: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ceb60: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ceb64: 0x120982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1ceb68: 0xda030350
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1ceb6c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ceb70: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1ceb74: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceb78: 0xda040150
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1ceb7c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1ceb80: 0x4be520bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1ceb84: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ceb88: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1ceb8c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ceb90: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceb94: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ceb98: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceb9c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ceba0: 0x78c20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ceba4: 0xfba50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1ceba8: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cebac: 0xc049676
    SET_GPR_U32(ctx, 31, 0x1cebb4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1cebb4
// Address: 0x1cebb4 - 0x1cedf8

void entry_1cebb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cebb4) {
        switch (ctx->pc) {
            case 0x1cec10: ctx->pc = 0; goto label_1cec10;
            case 0x1cec38: ctx->pc = 0; goto label_1cec38;
            case 0x1cec50: ctx->pc = 0; goto label_1cec50;
            case 0x1cec54: ctx->pc = 0; goto label_1cec54;
            case 0x1cec60: ctx->pc = 0; goto label_1cec60;
            case 0x1cec84: ctx->pc = 0; goto label_1cec84;
            case 0x1cecd8: ctx->pc = 0; goto label_1cecd8;
            case 0x1cece8: ctx->pc = 0; goto label_1cece8;
            case 0x1ced7c: ctx->pc = 0; goto label_1ced7c;
            case 0x1cedb0: ctx->pc = 0; goto label_1cedb0;
            case 0x1cedd4: ctx->pc = 0; goto label_1cedd4;
            case 0x1cedd8: ctx->pc = 0; goto label_1cedd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cebb4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cebb8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cebbc: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cebc0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1cebc4: 0xc4414e08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19976)); ctx->f[1] = *(float*)&val; }
    // 0x1cebc8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cebcc: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cebd0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cebd4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cebd8: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cebdc: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cebe0: 0x46010802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1cebe4: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cebe8: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1cebec: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cebf0: 0x0
    // NOP
    // 0x1cebf4: 0x45000006
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cec10;
    }
    // 0x1cebfc: 0x12200015
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cec54;
    }
    // 0x1cec04: 0x46020004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x1cec08: 0x10000011
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cec50;
    }
label_1cec10:
    // 0x1cec10: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1cec14: 0x46000085
    ctx->f[2] = FPU_ABS_S(ctx->f[0]);
    // 0x1cec18: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cec1c: 0x45010006
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1cec38;
    }
    // 0x1cec24: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1cec28: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cec2c: 0x0
    // NOP
    // 0x1cec30: 0x45020014
    if (!(ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
        goto label_1cec84;
    }
label_1cec38:
    // 0x1cec38: 0x12200006
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1cec54;
    }
    // 0x1cec40: 0x3c014976
    SET_GPR_U32(ctx, 1, ((uint32_t)18806 << 16));
    // 0x1cec44: 0x34219500
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 38144));
    // 0x1cec48: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cec4c: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
label_1cec50:
    // 0x1cec50: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1cec54:
    // 0x1cec54: 0x12400002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1cec60;
    }
    // 0x1cec5c: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
label_1cec60:
    // 0x1cec60: 0x1260005d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cedd8;
    }
    // 0x1cec68: 0xda020350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1cec6c: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1cec70: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1cec74: 0x4be51048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cec78: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cec7c: 0x10000056
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cedd8;
    }
label_1cec84:
    // 0x1cec84: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cec88: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1cec8c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1cec90: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cec94: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1cec98: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cec9c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ceca0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ceca4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ceca8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cecac: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cecb0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cecb4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cecb8: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cecbc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cecc0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cecc4: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cecd8;
    }
    // 0x1ceccc: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cecd0: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cece8;
    }
label_1cecd8:
    // 0x1cecd8: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cecdc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cece0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1cece4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1cece8:
    // 0x1cece8: 0xc4604e08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19976)); ctx->f[0] = *(float*)&val; }
    // 0x1cecec: 0x46021082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[2]);
    // 0x1cecf0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1cecf4: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x1cecf8: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1cecfc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ced00: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1ced04: 0x46011881
    ctx->f[2] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x1ced08: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ced0c: 0x4614a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x1ced10: 0xda030150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1ced14: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x1ced18: 0x46021000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[2]);
    // 0x1ced1c: 0xda040350
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1ced20: 0x48a42800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1ced24: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1ced28: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ced2c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ced30: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ced34: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ced38: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1ced3c: 0x4be520bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1ced40: 0x4be510c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ced44: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ced48: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ced4c: 0x1220000b
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ced7c;
    }
    // 0x1ced54: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ced58: 0x3c014974
    SET_GPR_U32(ctx, 1, ((uint32_t)18804 << 16));
    // 0x1ced5c: 0x34212400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 9216));
    // 0x1ced60: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ced64: 0xc4404e14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19988)); ctx->f[0] = *(float*)&val; }
    // 0x1ced68: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1ced6c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1ced70: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1ced74: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1ced78: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1ced7c:
    // 0x1ced7c: 0x1240000c
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1cedb0;
    }
    // 0x1ced84: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ced88: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ced8c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ced90: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ced94: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ced98: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1ced9c: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1ceda0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ceda4: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ceda8: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cedac: 0xfa420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_1cedb0:
    // 0x1cedb0: 0x12600008
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1cedd4;
    }
    // 0x1cedb8: 0xda010350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1cedbc: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1cedc0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1cedc4: 0x4be508bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1cedc8: 0x4be51888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cedcc: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1cedd0: 0xfa620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_1cedd4:
    // 0x1cedd4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_1cedd8:
    // 0x1cedd8: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ceddc: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1cede0: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1cede4: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cede8: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1cedec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1cedf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1cedf8; return;
}


// Function: FUN_001cedf8
// Address: 0x1cedf8 - 0x1cee20

void FUN_001cedf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cedf8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1cedfc: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cee00: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1cee04: 0x24460010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1cee08: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cee0c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cee10: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1cee14: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cee18: 0xc073ac6
    SET_GPR_U32(ctx, 31, 0x1cee20);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FUN_001ceb18(rdram, ctx, runtime); return;
}


// Function: entry_1cee20
// Address: 0x1cee20 - 0x1cee30

void entry_1cee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cee20: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1cee24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cee28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cee30
// Address: 0x1cee30 - 0x1cee64

void FUN_001cee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cee30: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x1cee34: 0x7fb00040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 16));
    // 0x1cee38: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1cee3c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cee40: 0x7fb10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 17));
    // 0x1cee44: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1cee48: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1cee4c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cee50: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1cee54: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cee64(rdram, ctx, runtime); return;
    }
    // 0x1cee5c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cee64);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cee64
// Address: 0x1cee64 - 0x1ceeb0

void entry_1cee64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cee64: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1cee68: 0x3c04001d
    SET_GPR_U32(ctx, 4, ((uint32_t)29 << 16));
    // 0x1cee6c: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cee70: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1cee74: 0x2484edf8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962680));
    // 0x1cee78: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x1cee7c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cee80: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1cee84: 0x46006b86
    ctx->f[14] = FPU_MOV_S(ctx->f[13]);
    // 0x1cee88: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1cee8c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cee90: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cee94: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cee98: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cee9c: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1ceea0: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1ceea4: 0xafa30014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    // 0x1ceea8: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1ceeb0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1ceeb0
// Address: 0x1ceeb0 - 0x1ceec8

void entry_1ceeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ceeb0: 0xc7a00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1ceeb4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ceeb8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ceebc: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ceec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ceec8
// Address: 0x1ceec8 - 0x1cef20

void FUN_001ceec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ceec8: 0x27bdfea0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966944));
    // 0x1ceecc: 0x7fb70130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 23));
    // 0x1ceed0: 0x7fb60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 22));
    // 0x1ceed4: 0x100b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1ceed8: 0x7fb50110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 21));
    // 0x1ceedc: 0x140b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1ceee0: 0x7fb40100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 20));
    // 0x1ceee4: 0xc0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ceee8: 0x7fb300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 19));
    // 0x1ceeec: 0xa0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ceef0: 0x7fb200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 18));
    // 0x1ceef4: 0x160982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x1ceef8: 0x7fb100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 17));
    // 0x1ceefc: 0xe0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1cef00: 0x7fb000c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 16));
    // 0x1cef04: 0x120882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1cef08: 0xe7b40150
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 336), *(uint32_t*)&val); }
    // 0x1cef0c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cef10: 0x7fbf0140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 31));
    // 0x1cef14: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x1cef18: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1cef20);
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 344), *(uint32_t*)&val); }
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cef20
// Address: 0x1cef20 - 0x1cef84

void entry_1cef20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cef20) {
        switch (ctx->pc) {
            case 0x1cef50: ctx->pc = 0; goto label_1cef50;
            case 0x1cef5c: ctx->pc = 0; goto label_1cef5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cef20: 0x5260000b
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_1cef50;
    }
    // 0x1cef28: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cef2c: 0xda640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1cef30: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1cef34: 0x4bc410eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cef38: 0x4bc308eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cef3c: 0x4bc410af
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1cef40: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cef44: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1cef48: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cef5c;
    }
label_1cef50:
    // 0x1cef50: 0x7a230000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cef54: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1cef58: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
label_1cef5c:
    // 0x1cef5c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1cef60: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cef64: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cef68: 0x2a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1cef6c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1cef70: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cef74: 0x27aa00b0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1cef78: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1cef7c: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1cef84);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 180));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1cef84
// Address: 0x1cef84 - 0x1cefe8

void entry_1cef84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cef84) {
        switch (ctx->pc) {
            case 0x1cef90: ctx->pc = 0; goto label_1cef90;
            case 0x1cef94: ctx->pc = 0; goto label_1cef94;
            case 0x1cefb8: ctx->pc = 0; goto label_1cefb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cef84: 0x1000000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cefb8;
    }
    // 0x1cef8c: 0x0
    // NOP
label_1cef90:
    // 0x1cef90: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1cef94:
    // 0x1cef94: 0x4614a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cef98: 0x0
    // NOP
    // 0x1cef9c: 0x45010031
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CF064; return;
    }
    // 0x1cefa4: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1cefa8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1cefac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1cefb0: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x1cefb4: 0x4600a569
    ctx->f[21] = std::min(ctx->f[20], ctx->f[0]);
label_1cefb8:
    // 0x1cefb8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cefbc: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1cefc0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1cefc4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1cefc8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cefcc: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cefd0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cefd4: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cefd8: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cefdc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cefe0: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1cefe8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1cefe8
// Address: 0x1cefe8 - 0x1cf018

void entry_1cefe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cefe8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1cefec: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ceff0: 0x0
    // NOP
    // 0x1ceff4: 0x4501ffe7
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CEF94; return;
    }
    // 0x1ceffc: 0x8fa700b0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1cf000: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf004: 0x8fa800b4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1cf008: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cf00c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cf010: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1cf018);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 64));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1cf018
// Address: 0x1cf018 - 0x1cf084

void entry_1cf018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf018) {
        switch (ctx->pc) {
            case 0x1cf064: ctx->pc = 0; goto label_1cf064;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf018: 0x1040ffdd
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CEF90; return;
    }
    // 0x1cf020: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1cf024: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf028: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1cf02c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cf030: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf034: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cf038: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf03c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cf040: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf044: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cf048: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cf04c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cf050: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cf054: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf058: 0x0
    // NOP
    // 0x1cf05c: 0x4500ffcd
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CEF94; return;
    }
label_1cf064:
    // 0x1cf064: 0x12600020
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF0E8; return;
    }
    // 0x1cf06c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf070: 0x8fa800b4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1cf074: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1cf078: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf07c: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1cf084);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 64));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1cf084
// Address: 0x1cf084 - 0x1cf0f0

void entry_1cf084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf084) {
        switch (ctx->pc) {
            case 0x1cf0e8: ctx->pc = 0; goto label_1cf0e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf084: 0x10400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1cf0e8;
    }
    // 0x1cf08c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1cf090: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cf094: 0x46020032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf098: 0x0
    // NOP
    // 0x1cf09c: 0x45010012
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1cf0e8;
    }
    // 0x1cf0a4: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1cf0a8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf0ac: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1cf0b0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cf0b4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf0b8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cf0bc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf0c0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cf0c4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf0c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cf0cc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cf0d0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cf0d4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1cf0d8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf0dc: 0x0
    // NOP
    // 0x1cf0e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[21] = FPU_SUB_S(ctx->f[20], ctx->f[2]);
        goto label_1cf0e8;
    }
label_1cf0e8:
    // 0x1cf0e8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1cf0f0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1cf0f0
// Address: 0x1cf0f0 - 0x1cf138

void entry_1cf0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf0f0) {
        switch (ctx->pc) {
            case 0x1cf104: ctx->pc = 0; goto label_1cf104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf0f0: 0x4614a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf0f4: 0x0
    // NOP
    // 0x1cf0f8: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1cf104;
    }
    // 0x1cf100: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1cf104:
    // 0x1cf104: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1cf108: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cf10c: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1cf110: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1cf114: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1cf118: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cf11c: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1cf120: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1cf124: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1cf128: 0xc7b50158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[21] = *(float*)&val; }
    // 0x1cf12c: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x1cf130: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cf138
// Address: 0x1cf138 - 0x1cf158

void FUN_001cf138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf138) {
        switch (ctx->pc) {
            case 0x1cf150: ctx->pc = 0; goto label_1cf150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf138: 0x8c822bdc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 11228)));
    // 0x1cf13c: 0x14a20004
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[13]);
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1cf150;
    }
    // 0x1cf144: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cf148: 0xc4404e3c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20028)); ctx->f[0] = *(float*)&val; }
    // 0x1cf14c: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
label_1cf150:
    // 0x1cf150: 0x3e00008
    ctx->f[0] = FPU_MOV_S(ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001cf158
// Address: 0x1cf158 - 0x1cf1e4

void FUN_001cf158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf158) {
        switch (ctx->pc) {
            case 0x1cf1c8: ctx->pc = 0; goto label_1cf1c8;
            case 0x1cf1d0: ctx->pc = 0; goto label_1cf1d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf158: 0x27bdfe00
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966784));
    // 0x1cf15c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1cf160: 0x7fb50160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), GPR_VEC(ctx, 21));
    // 0x1cf164: 0x7fb30140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 19));
    // 0x1cf168: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1cf16c: 0x7fbf01a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), GPR_VEC(ctx, 31));
    // 0x1cf170: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cf174: 0x7fbe0190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), GPR_VEC(ctx, 30));
    // 0x1cf178: 0x7fb70180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), GPR_VEC(ctx, 23));
    // 0x1cf17c: 0x7fb60170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), GPR_VEC(ctx, 22));
    // 0x1cf180: 0x7fb40150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), GPR_VEC(ctx, 20));
    // 0x1cf184: 0x7fb20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 18));
    // 0x1cf188: 0x7fb10120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 17));
    // 0x1cf18c: 0x7fb00110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 16));
    // 0x1cf190: 0xe7bc01f0
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 496), *(uint32_t*)&val); }
    // 0x1cf194: 0xe7bb01e8
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 488), *(uint32_t*)&val); }
    // 0x1cf198: 0xe7ba01e0
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 480), *(uint32_t*)&val); }
    // 0x1cf19c: 0xe7b901d8
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 472), *(uint32_t*)&val); }
    // 0x1cf1a0: 0xe7b801d0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 464), *(uint32_t*)&val); }
    // 0x1cf1a4: 0xe7b701c8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 456), *(uint32_t*)&val); }
    // 0x1cf1a8: 0xe7b601c0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 448), *(uint32_t*)&val); }
    // 0x1cf1ac: 0xe7b501b8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 440), *(uint32_t*)&val); }
    // 0x1cf1b0: 0xe7b401b0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 432), *(uint32_t*)&val); }
    // 0x1cf1b4: 0x12a00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1cf1c8;
    }
    // 0x1cf1bc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cf1c0: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294957776)); ctx->f[23] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1cf1d0;
    }
label_1cf1c8:
    // 0x1cf1c8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1cf1cc: 0xc457dad4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294957780)); ctx->f[23] = *(float*)&val; }
label_1cf1d0:
    // 0x1cf1d0: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1cf1d4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf1d8: 0x4480c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 0);
    // 0x1cf1dc: 0xc05ff12
    SET_GPR_U32(ctx, 31, 0x1cf1e4);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    GetJtJumpToTargetVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cf1e4
// Address: 0x1cf1e4 - 0x1cf210

void entry_1cf1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf1e4) {
        switch (ctx->pc) {
            case 0x1cf208: ctx->pc = 0; goto label_1cf208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf1e4: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1cf1e8: 0x8c501c84
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 7300)));
    // 0x1cf1ec: 0x5200004c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 7312)));
        ctx->pc = 0x1CF320; return;
    }
    // 0x1cf1f4: 0x27b20060
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cf1f8: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x1cf1fc: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1cf200: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cf204: 0x0
    // NOP
label_1cf208:
    // 0x1cf208: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1cf210);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cf210
// Address: 0x1cf210 - 0x1cf260

void entry_1cf210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf210) {
        switch (ctx->pc) {
            case 0x1cf234: ctx->pc = 0; goto label_1cf234;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf210: 0x12150008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        goto label_1cf234;
    }
    // 0x1cf218: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cf21c: 0xc6020058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[2] = *(float*)&val; }
    // 0x1cf220: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cf224: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf228: 0x0
    // NOP
    // 0x1cf22c: 0x45030038
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x1CF310; return;
    }
label_1cf234:
    // 0x1cf234: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cf238: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf23c: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1cf240: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cf244: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf248: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf24c: 0x8e060018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf250: 0x27a900c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cf254: 0x27aa00c4
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 196));
    // 0x1cf258: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1cf260);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1cf260
// Address: 0x1cf260 - 0x1cf2a4

void entry_1cf260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf260: 0xc6620358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 856)); ctx->f[2] = *(float*)&val; }
    // 0x1cf264: 0xc7a000c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[0] = *(float*)&val; }
    // 0x1cf268: 0xc7a10058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[1] = *(float*)&val; }
    // 0x1cf26c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1cf270: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cf274: 0x1215001b
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF2E4; return;
    }
    // 0x1cf27c: 0xc7ac00c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[12] = *(float*)&val; }
    // 0x1cf280: 0xc6c04e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cf284: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf288: 0x0
    // NOP
    // 0x1cf28c: 0x45030020
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x1CF310; return;
    }
    // 0x1cf294: 0xc68d4e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20004)); ctx->f[13] = *(float*)&val; }
    // 0x1cf298: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf29c: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cf2a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cf2a4
// Address: 0x1cf2a4 - 0x1cf2dc

void entry_1cf2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf2a4: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf2a8: 0x0
    // NOP
    // 0x1cf2ac: 0x45010017
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CF30C; return;
    }
    // 0x1cf2b4: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf2b8: 0x220502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf2bc: 0x8e6706d4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cf2c0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf2c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf2c8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf2cc: 0x2e0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cf2d0: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf2d4: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cf2dc);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cf2dc
// Address: 0x1cf2dc - 0x1cf350

void entry_1cf2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf2dc) {
        switch (ctx->pc) {
            case 0x1cf2e4: ctx->pc = 0; goto label_1cf2e4;
            case 0x1cf30c: ctx->pc = 0; goto label_1cf30c;
            case 0x1cf310: ctx->pc = 0; goto label_1cf310;
            case 0x1cf320: ctx->pc = 0; goto label_1cf320;
            case 0x1cf340: ctx->pc = 0; goto label_1cf340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf2dc: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_1cf310;
    }
label_1cf2e4:
    // 0x1cf2e4: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cf2e8: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1cf2ec: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cf2f0: 0xc7a000c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[0] = *(float*)&val; }
    // 0x1cf2f4: 0xafb000e8
    WRITE32(ADD32(GPR_U32(ctx, 29), 232), GPR_U32(ctx, 16));
    // 0x1cf2f8: 0xafa400e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 4));
    // 0x1cf2fc: 0x4600bde9
    ctx->f[23] = std::min(ctx->f[23], ctx->f[0]);
    // 0x1cf300: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cf304: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cf308: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
label_1cf30c:
    // 0x1cf30c: 0x8e100050
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_1cf310:
    // 0x1cf310: 0x1600ffbd
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF208; return;
    }
    // 0x1cf318: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1cf31c: 0x8c511c90
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 7312)));
label_1cf320:
    // 0x1cf320: 0x12200088
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 128));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF544; return;
    }
    // 0x1cf328: 0x27b60060
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cf32c: 0xafa20100
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 2));
    // 0x1cf330: 0x3c1e0027
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    // 0x1cf334: 0x27b400a0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1cf338: 0x8e250018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1cf33c: 0x0
    // NOP
label_1cf340:
    // 0x1cf340: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf344: 0x8e6606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cf348: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf350);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf350
// Address: 0x1cf350 - 0x1cf380

void entry_1cf350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf350: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1cf354: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf358: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1cf35c: 0x10400008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cf380(rdram, ctx, runtime); return;
    }
    // 0x1cf364: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf368: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cf36c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf370: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf374: 0x27a900c8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 200));
    // 0x1cf378: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf380);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf380
// Address: 0x1cf380 - 0x1cf394

void entry_1cf380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf380: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1cf384: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf388: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf38c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf394);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf394
// Address: 0x1cf394 - 0x1cf3d4

void entry_1cf394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf394) {
        switch (ctx->pc) {
            case 0x1cf3b8: ctx->pc = 0; goto label_1cf3b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf394: 0x12350008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 21)) {
        goto label_1cf3b8;
    }
    // 0x1cf39c: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cf3a0: 0xc622004c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 76)); ctx->f[2] = *(float*)&val; }
    // 0x1cf3a4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cf3a8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf3ac: 0x0
    // NOP
    // 0x1cf3b0: 0x45030062
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
        ctx->pc = 0x1CF53C; return;
    }
label_1cf3b8:
    // 0x1cf3b8: 0x7ba20050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1cf3bc: 0xafb30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 19));
    // 0x1cf3c0: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x1cf3c4: 0xafb10084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 17));
    // 0x1cf3c8: 0xc7b600c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[22] = *(float*)&val; }
    // 0x1cf3cc: 0xc053740
    SET_GPR_U32(ctx, 31, 0x1cf3d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    DuGetCrvSearchIncrement__FP3CRV(rdram, ctx, runtime); return;
}


// Function: entry_1cf3d4
// Address: 0x1cf3d4 - 0x1cf3ec

void entry_1cf3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf3d4: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1cf3d8: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1cf3dc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf3e0: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1cf3e4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf3ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 19972)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf3ec
// Address: 0x1cf3ec - 0x1cf400

void entry_1cf3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf3ec: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1cf3f0: 0x8c900000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf3f4: 0x8e020020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1cf3f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf400);
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf400
// Address: 0x1cf400 - 0x1cf414

void entry_1cf400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf400: 0xc7cc4e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 19972)); ctx->f[12] = *(float*)&val; }
    // 0x1cf404: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1cf408: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf40c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf414);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf414
// Address: 0x1cf414 - 0x1cf43c

void entry_1cf414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf414: 0x3c03001d
    SET_GPR_U32(ctx, 3, ((uint32_t)29 << 16));
    // 0x1cf418: 0x8fa50100
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1cf41c: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1cf420: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1cf424: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1cf428: 0x460003c6
    ctx->f[15] = FPU_MOV_S(ctx->f[0]);
    // 0x1cf42c: 0x2464e9e8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4294961640));
    // 0x1cf430: 0x27a600cc
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 204));
    // 0x1cf434: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cf43c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cf43c
// Address: 0x1cf43c - 0x1cf470

void entry_1cf43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf43c: 0x12350010
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF480; return;
    }
    // 0x1cf444: 0xc7ac00c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[12] = *(float*)&val; }
    // 0x1cf448: 0xc4804e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cf44c: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf450: 0x0
    // NOP
    // 0x1cf454: 0x45030039
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
        ctx->pc = 0x1CF53C; return;
    }
    // 0x1cf45c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cf460: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf464: 0xc44d4e28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20008)); ctx->f[13] = *(float*)&val; }
    // 0x1cf468: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cf470);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cf470
// Address: 0x1cf470 - 0x1cf498

void entry_1cf470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf470) {
        switch (ctx->pc) {
            case 0x1cf480: ctx->pc = 0; goto label_1cf480;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf470: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf474: 0x0
    // NOP
    // 0x1cf478: 0x4501002f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CF538; return;
    }
label_1cf480:
    // 0x1cf480: 0xc7ac00cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 204)); ctx->f[12] = *(float*)&val; }
    // 0x1cf484: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf488: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf48c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf490: 0xc073a00
    SET_GPR_U32(ctx, 31, 0x1cf498);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetJtRailLanding__FP2JTP4RAILfP6VECTORT3(rdram, ctx, runtime); return;
}


// Function: entry_1cf498
// Address: 0x1cf498 - 0x1cf4c4

void entry_1cf498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf498: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cf49c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf4a0: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1cf4a4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf4a8: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cf4ac: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cf4b0: 0x8e260018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1cf4b4: 0x27a900c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cf4b8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf4bc: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1cf4c4);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1cf4c4
// Address: 0x1cf4c4 - 0x1cf504

void entry_1cf4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf4c4: 0xc6600358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 856)); ctx->f[0] = *(float*)&val; }
    // 0x1cf4c8: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf4cc: 0xc7a10058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[1] = *(float*)&val; }
    // 0x1cf4d0: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1cf4d4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cf4d8: 0x1235000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF50C; return;
    }
    // 0x1cf4e0: 0x8e6706d4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cf4e4: 0x200502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cf4e8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf4ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf4f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf4f4: 0x2e0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cf4f8: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf4fc: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cf504);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cf504
// Address: 0x1cf504 - 0x1cf5a4

void entry_1cf504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf504) {
        switch (ctx->pc) {
            case 0x1cf50c: ctx->pc = 0; goto label_1cf50c;
            case 0x1cf538: ctx->pc = 0; goto label_1cf538;
            case 0x1cf53c: ctx->pc = 0; goto label_1cf53c;
            case 0x1cf544: ctx->pc = 0; goto label_1cf544;
            case 0x1cf570: ctx->pc = 0; goto label_1cf570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf504: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
        goto label_1cf53c;
    }
label_1cf50c:
    // 0x1cf50c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cf510: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1cf514: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cf518: 0xc7a000c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[0] = *(float*)&val; }
    // 0x1cf51c: 0xafb100ec
    WRITE32(ADD32(GPR_U32(ctx, 29), 236), GPR_U32(ctx, 17));
    // 0x1cf520: 0xafa400e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 4));
    // 0x1cf524: 0x4600bde9
    ctx->f[23] = std::min(ctx->f[23], ctx->f[0]);
    // 0x1cf528: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cf52c: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cf530: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1cf534: 0xc7b900cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 204)); ctx->f[25] = *(float*)&val; }
label_1cf538:
    // 0x1cf538: 0x8e310038
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 56)));
label_1cf53c:
    // 0x1cf53c: 0x5620ff80
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x1CF340; return;
    }
label_1cf544:
    // 0x1cf544: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cf548: 0x8c5058d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 22736)));
    // 0x1cf54c: 0x12000081
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF754; return;
    }
    // 0x1cf554: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cf558: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1cf55c: 0x3c1e0027
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    // 0x1cf560: 0x3c170027
    SET_GPR_U32(ctx, 23, ((uint32_t)39 << 16));
    // 0x1cf564: 0x27b40090
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1cf568: 0x3c16001d
    SET_GPR_U32(ctx, 22, ((uint32_t)29 << 16));
    // 0x1cf56c: 0x0
    // NOP
label_1cf570:
    // 0x1cf570: 0x1215000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF5AC; return;
    }
    // 0x1cf578: 0x56a00074
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
    // 0x1cf580: 0x8e622210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8720)));
    // 0x1cf584: 0x52020071
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
    // 0x1cf58c: 0x8e020088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 136)));
    // 0x1cf590: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1cf594: 0x5040006d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
    // 0x1cf59c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1cf5a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1cf5a4
// Address: 0x1cf5a4 - 0x1cf5b4

void entry_1cf5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf5a4) {
        switch (ctx->pc) {
            case 0x1cf5ac: ctx->pc = 0; goto label_1cf5ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf5a4: 0x10400068
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF748; return;
    }
label_1cf5ac:
    // 0x1cf5ac: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1cf5b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cf5b4
// Address: 0x1cf5b4 - 0x1cf664

void entry_1cf5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf5b4) {
        switch (ctx->pc) {
            case 0x1cf61c: ctx->pc = 0; goto label_1cf61c;
            case 0x1cf624: ctx->pc = 0; goto label_1cf624;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf5b4: 0x1215001b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        goto label_1cf624;
    }
    // 0x1cf5bc: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cf5c0: 0xc60200b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 180)); ctx->f[2] = *(float*)&val; }
    // 0x1cf5c4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cf5c8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf5cc: 0x0
    // NOP
    // 0x1cf5d0: 0x4503005e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
    // 0x1cf5d8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cf5dc: 0xda620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1cf5e0: 0xc4414e0c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19980)); ctx->f[1] = *(float*)&val; }
    // 0x1cf5e4: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cf5e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cf5ec: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf5f0: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1cf5f4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf5f8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cf5fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf600: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cf604: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cf608: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1cf60c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf610: 0x0
    // NOP
    // 0x1cf614: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1cf61c;
    }
label_1cf61c:
    // 0x1cf61c: 0x5440004b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
label_1cf624:
    // 0x1cf624: 0xafb30070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 19));
    // 0x1cf628: 0x26c4edf8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 4294962680));
    // 0x1cf62c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cf630: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cf634: 0x27a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1cf638: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf63c: 0x27a600c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cf640: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1cf644: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1cf648: 0x27a700c4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    // 0x1cf64c: 0xafa20074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 2));
    // 0x1cf650: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1cf654: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1cf658: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1cf65c: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cf664);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cf664
// Address: 0x1cf664 - 0x1cf68c

void entry_1cf664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf664: 0x27b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1cf668: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cf66c: 0x8fa50074
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x1cf670: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf674: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf678: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf67c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf680: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf684: 0xc073ac6
    SET_GPR_U32(ctx, 31, 0x1cf68c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001ceb18(rdram, ctx, runtime); return;
}


// Function: entry_1cf68c
// Address: 0x1cf68c - 0x1cf6b8

void entry_1cf68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf68c: 0x1215001f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF70C; return;
    }
    // 0x1cf694: 0xc7c04e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cf698: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf69c: 0x0
    // NOP
    // 0x1cf6a0: 0x4503002a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x1CF74C; return;
    }
    // 0x1cf6a8: 0xc6ed4e2c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 20012)); ctx->f[13] = *(float*)&val; }
    // 0x1cf6ac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf6b0: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cf6b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cf6b8
// Address: 0x1cf6b8 - 0x1cf6dc

void entry_1cf6b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf6b8: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf6bc: 0x0
    // NOP
    // 0x1cf6c0: 0x45010021
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CF748; return;
    }
    // 0x1cf6c8: 0x8fa40074
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x1cf6cc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf6d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf6d4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf6dc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf6dc
// Address: 0x1cf6dc - 0x1cf704

void entry_1cf6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf6dc: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf6e0: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf6e4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf6e8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf6ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf6f0: 0x26670140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1cf6f4: 0x26680150
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 19), 336));
    // 0x1cf6f8: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf6fc: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cf704);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cf704
// Address: 0x1cf704 - 0x1cf798

void entry_1cf704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf704) {
        switch (ctx->pc) {
            case 0x1cf70c: ctx->pc = 0; goto label_1cf70c;
            case 0x1cf748: ctx->pc = 0; goto label_1cf748;
            case 0x1cf74c: ctx->pc = 0; goto label_1cf74c;
            case 0x1cf754: ctx->pc = 0; goto label_1cf754;
            case 0x1cf788: ctx->pc = 0; goto label_1cf788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf704: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        goto label_1cf74c;
    }
label_1cf70c:
    // 0x1cf70c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cf710: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1cf714: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x1cf718: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cf71c: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cf720: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cf724: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1cf728: 0xc7a100c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[1] = *(float*)&val; }
    // 0x1cf72c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cf730: 0xafb000f8
    WRITE32(ADD32(GPR_U32(ctx, 29), 248), GPR_U32(ctx, 16));
    // 0x1cf734: 0xafa400e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 4));
    // 0x1cf738: 0x46170de9
    ctx->f[23] = std::min(ctx->f[1], ctx->f[23]);
    // 0x1cf73c: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cf740: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1cf744: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
label_1cf748:
    // 0x1cf748: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
label_1cf74c:
    // 0x1cf74c: 0x1600ff88
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF570; return;
    }
label_1cf754:
    // 0x1cf754: 0x8c509ba8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4294941608)));
    // 0x1cf758: 0x120000a8
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CF9FC; return;
    }
    // 0x1cf760: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1cf764: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1cf768: 0x27b60060
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cf76c: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1cf770: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1cf774: 0x267e0140
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1cf778: 0x27b70080
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1cf77c: 0x27b400b0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1cf780: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf784: 0x0
    // NOP
label_1cf788:
    // 0x1cf788: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf78c: 0x26660140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1cf790: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf798);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf798
// Address: 0x1cf798 - 0x1cf7c8

void entry_1cf798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf798: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1cf79c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf7a0: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1cf7a4: 0x10400008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cf7c8(rdram, ctx, runtime); return;
    }
    // 0x1cf7ac: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf7b0: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cf7b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf7b8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf7bc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf7c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf7c8);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf7c8
// Address: 0x1cf7c8 - 0x1cf7dc

void entry_1cf7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf7c8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf7cc: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf7d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf7d4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf7dc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf7dc
// Address: 0x1cf7dc - 0x1cf870

void entry_1cf7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf7dc) {
        switch (ctx->pc) {
            case 0x1cf84c: ctx->pc = 0; goto label_1cf84c;
            case 0x1cf854: ctx->pc = 0; goto label_1cf854;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf7dc: 0x1215001d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        goto label_1cf854;
    }
    // 0x1cf7e4: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cf7e8: 0xc602005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[2] = *(float*)&val; }
    // 0x1cf7ec: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cf7f0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf7f4: 0x0
    // NOP
    // 0x1cf7f8: 0x4503007d
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        ctx->pc = 0x1CF9F0; return;
    }
    // 0x1cf800: 0xda620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1cf804: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cf808: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1cf80c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cf810: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf814: 0xc4614e0c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19980)); ctx->f[1] = *(float*)&val; }
    // 0x1cf818: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf81c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1cf820: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf824: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1cf828: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cf82c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1cf830: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1cf834: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cf838: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1cf83c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf840: 0x0
    // NOP
    // 0x1cf844: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1cf84c;
    }
label_1cf84c:
    // 0x1cf84c: 0x54400068
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        ctx->pc = 0x1CF9F0; return;
    }
label_1cf854:
    // 0x1cf854: 0xafb30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 19));
    // 0x1cf858: 0xafb00084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 16));
    // 0x1cf85c: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1cf860: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf864: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1cf868: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf870);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf870
// Address: 0x1cf870 - 0x1cf89c

void entry_1cf870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf870: 0x461603c1
    ctx->f[15] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x1cf874: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1cf878: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1cf87c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1cf880: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1cf884: 0x2444ee30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294962736));
    // 0x1cf888: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cf88c: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1cf890: 0x27a600d4
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 212));
    // 0x1cf894: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cf89c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cf89c
// Address: 0x1cf89c - 0x1cf8d0

void entry_1cf89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf89c: 0x12150010
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF8E0; return;
    }
    // 0x1cf8a4: 0xc7ac00c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[12] = *(float*)&val; }
    // 0x1cf8a8: 0xc4404e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cf8ac: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf8b0: 0x0
    // NOP
    // 0x1cf8b4: 0x4503004e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        ctx->pc = 0x1CF9F0; return;
    }
    // 0x1cf8bc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cf8c0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf8c4: 0xc46d4e30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20016)); ctx->f[13] = *(float*)&val; }
    // 0x1cf8c8: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cf8d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cf8d0
// Address: 0x1cf8d0 - 0x1cf910

void entry_1cf8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf8d0) {
        switch (ctx->pc) {
            case 0x1cf8e0: ctx->pc = 0; goto label_1cf8e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf8d0: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cf8d4: 0x0
    // NOP
    // 0x1cf8d8: 0x45010044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CF9EC; return;
    }
label_1cf8e0:
    // 0x1cf8e0: 0xafb30090
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 19));
    // 0x1cf8e4: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf8e8: 0xafa20094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 2));
    // 0x1cf8ec: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1cf8f0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cf8f4: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1cf8f8: 0x10400005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cf910(rdram, ctx, runtime); return;
    }
    // 0x1cf900: 0xc7ac00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1cf904: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf908: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cf910);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cf910
// Address: 0x1cf910 - 0x1cf940

void entry_1cf910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf910: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1cf914: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cf918: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1cf91c: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1cf920: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1cf924: 0x2444edf8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294962680));
    // 0x1cf928: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1cf92c: 0x27a600c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cf930: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf934: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1cf938: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cf940);
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cf940
// Address: 0x1cf940 - 0x1cf964

void entry_1cf940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf940: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cf944: 0x8fa50094
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    // 0x1cf948: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf94c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf950: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cf954: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf958: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf95c: 0xc073ac6
    SET_GPR_U32(ctx, 31, 0x1cf964);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001ceb18(rdram, ctx, runtime); return;
}


// Function: entry_1cf964
// Address: 0x1cf964 - 0x1cf97c

void entry_1cf964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf964: 0x12150011
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CF9AC; return;
    }
    // 0x1cf96c: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cf970: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf974: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cf97c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cf97c
// Address: 0x1cf97c - 0x1cf9a4

void entry_1cf97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cf97c: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cf980: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cf984: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cf988: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf98c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cf990: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1cf994: 0x26680150
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 19), 336));
    // 0x1cf998: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cf99c: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cf9a4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cf9a4
// Address: 0x1cf9a4 - 0x1cfa28

void entry_1cf9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cf9a4) {
        switch (ctx->pc) {
            case 0x1cf9ac: ctx->pc = 0; goto label_1cf9ac;
            case 0x1cf9ec: ctx->pc = 0; goto label_1cf9ec;
            case 0x1cf9f0: ctx->pc = 0; goto label_1cf9f0;
            case 0x1cf9fc: ctx->pc = 0; goto label_1cf9fc;
            case 0x1cfa20: ctx->pc = 0; goto label_1cfa20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cf9a4: 0x54400012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        goto label_1cf9f0;
    }
label_1cf9ac:
    // 0x1cf9ac: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cf9b0: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1cf9b4: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x1cf9b8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1cf9bc: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cf9c0: 0xafa300e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 3));
    // 0x1cf9c4: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1cf9c8: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cf9cc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1cf9d0: 0xc7a100c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[1] = *(float*)&val; }
    // 0x1cf9d4: 0xafb000fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 16));
    // 0x1cf9d8: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cf9dc: 0x46170de9
    ctx->f[23] = std::min(ctx->f[1], ctx->f[23]);
    // 0x1cf9e0: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1cf9e4: 0xc7bb00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[27] = *(float*)&val; }
    // 0x1cf9e8: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
label_1cf9ec:
    // 0x1cf9ec: 0x8e100038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
label_1cf9f0:
    // 0x1cf9f0: 0x5600ff65
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x1CF788; return;
    }
    // 0x1cf9f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1cf9fc:
    // 0x1cf9fc: 0x8c5026f8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 9976)));
    // 0x1cfa00: 0x1200006f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFBC0; return;
    }
    // 0x1cfa08: 0x27b40060
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cfa0c: 0x27b60070
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1cfa10: 0x3c1e0025
    SET_GPR_U32(ctx, 30, ((uint32_t)37 << 16));
    // 0x1cfa14: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x1cfa18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cfa1c: 0x0
    // NOP
label_1cfa20:
    // 0x1cfa20: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1cfa28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1cfa28
// Address: 0x1cfa28 - 0x1cfa74

void entry_1cfa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfa28: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cfa2c: 0xc7a10068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    // 0x1cfa30: 0xc6020070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[2] = *(float*)&val; }
    // 0x1cfa34: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cfa38: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfa3c: 0x0
    // NOP
    // 0x1cfa40: 0x4503005c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x1CFBB4; return;
    }
    // 0x1cfa48: 0xda610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1cfa4c: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1cfa50: 0x7a620150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 336)));
    // 0x1cfa54: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1cfa58: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1cfa5c: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x1cfa60: 0xafb30070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 19));
    // 0x1cfa64: 0xc7ac0094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[12] = *(float*)&val; }
    // 0x1cfa68: 0xc7ad0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[13] = *(float*)&val; }
    // 0x1cfa6c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1cfa74);
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 16));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1cfa74
// Address: 0x1cfa74 - 0x1cfaa4

void entry_1cfa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfa74: 0xc60c005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[12] = *(float*)&val; }
    // 0x1cfa78: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cfa7c: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1cfa80: 0xc46d4e40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20032)); ctx->f[13] = *(float*)&val; }
    // 0x1cfa84: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x1cfa88: 0xc7cedad0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4294957776)); ctx->f[14] = *(float*)&val; }
    // 0x1cfa8c: 0xc6efdad4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4294957780)); ctx->f[15] = *(float*)&val; }
    // 0x1cfa90: 0x2444ea58
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294961752));
    // 0x1cfa94: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cfa98: 0x27a600d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 216));
    // 0x1cfa9c: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cfaa4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cfaa4
// Address: 0x1cfaa4 - 0x1cfae8

void entry_1cfaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfaa4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1cfaa8: 0xc7a100c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[1] = *(float*)&val; }
    // 0x1cfaac: 0xc4804e10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 19984)); ctx->f[0] = *(float*)&val; }
    // 0x1cfab0: 0x46000b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1cfab4: 0x12150010
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CFAF8; return;
    }
    // 0x1cfabc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cfac0: 0xc4404e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cfac4: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfac8: 0x0
    // NOP
    // 0x1cfacc: 0x45030039
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x1CFBB4; return;
    }
    // 0x1cfad4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cfad8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfadc: 0xc46d4e38
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20024)); ctx->f[13] = *(float*)&val; }
    // 0x1cfae0: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cfae8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cfae8
// Address: 0x1cfae8 - 0x1cfb0c

void entry_1cfae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfae8) {
        switch (ctx->pc) {
            case 0x1cfaf8: ctx->pc = 0; goto label_1cfaf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfae8: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfaec: 0x0
    // NOP
    // 0x1cfaf0: 0x4501002f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CFBB0; return;
    }
label_1cfaf8:
    // 0x1cfaf8: 0xc7ac00d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[12] = *(float*)&val; }
    // 0x1cfafc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cfb00: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cfb04: 0xc05a890
    SET_GPR_U32(ctx, 31, 0x1cfb0c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_1cfb0c
// Address: 0x1cfb0c - 0x1cfb3c

void entry_1cfb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfb0c: 0x26710150
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 336));
    // 0x1cfb10: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cfb14: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfb18: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x1cfb1c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cfb20: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cfb24: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfb28: 0x8e060018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cfb2c: 0x27a900c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cfb30: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfb34: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1cfb3c);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1cfb3c
// Address: 0x1cfb3c - 0x1cfb7c

void entry_1cfb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfb3c: 0xc6600358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 856)); ctx->f[0] = *(float*)&val; }
    // 0x1cfb40: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cfb44: 0xc6610158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 344)); ctx->f[1] = *(float*)&val; }
    // 0x1cfb48: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1cfb4c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cfb50: 0x1215000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CFB84; return;
    }
    // 0x1cfb58: 0x8e6706d4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cfb5c: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cfb60: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cfb64: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfb68: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfb6c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfb70: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cfb74: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cfb7c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cfb7c
// Address: 0x1cfb7c - 0x1cfbf8

void entry_1cfb7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfb7c) {
        switch (ctx->pc) {
            case 0x1cfb84: ctx->pc = 0; goto label_1cfb84;
            case 0x1cfbb0: ctx->pc = 0; goto label_1cfbb0;
            case 0x1cfbb4: ctx->pc = 0; goto label_1cfbb4;
            case 0x1cfbc0: ctx->pc = 0; goto label_1cfbc0;
            case 0x1cfbe8: ctx->pc = 0; goto label_1cfbe8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfb7c: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_1cfbb4;
    }
label_1cfb84:
    // 0x1cfb84: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cfb88: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1cfb8c: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cfb90: 0xc7a000c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[0] = *(float*)&val; }
    // 0x1cfb94: 0xafb000f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 240), GPR_U32(ctx, 16));
    // 0x1cfb98: 0xafa400e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 4));
    // 0x1cfb9c: 0x461705e9
    ctx->f[23] = std::min(ctx->f[0], ctx->f[23]);
    // 0x1cfba0: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cfba4: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cfba8: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1cfbac: 0xc7bc00d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[28] = *(float*)&val; }
label_1cfbb0:
    // 0x1cfbb0: 0x8e100050
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_1cfbb4:
    // 0x1cfbb4: 0x1600ff9a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFA20; return;
    }
    // 0x1cfbbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1cfbc0:
    // 0x1cfbc0: 0x8c5026e8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 9960)));
    // 0x1cfbc4: 0x1200007f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFDC4; return;
    }
    // 0x1cfbcc: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x1cfbd0: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1cfbd4: 0x27b60060
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1cfbd8: 0x27b70080
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1cfbdc: 0x3c1e001d
    SET_GPR_U32(ctx, 30, ((uint32_t)29 << 16));
    // 0x1cfbe0: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cfbe4: 0x0
    // NOP
label_1cfbe8:
    // 0x1cfbe8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfbec: 0x8e6606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cfbf0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cfbf8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cfbf8
// Address: 0x1cfbf8 - 0x1cfc28

void entry_1cfbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfbf8: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1cfbfc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cfc00: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1cfc04: 0x10400008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1cfc28(rdram, ctx, runtime); return;
    }
    // 0x1cfc0c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cfc10: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1cfc14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfc18: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfc1c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfc20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cfc28);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 220));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cfc28
// Address: 0x1cfc28 - 0x1cfc3c

void entry_1cfc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfc28: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cfc2c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfc30: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cfc34: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1cfc3c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1cfc3c
// Address: 0x1cfc3c - 0x1cfc80

void entry_1cfc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfc3c: 0xc6600108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1cfc40: 0xc7a10078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[1] = *(float*)&val; }
    // 0x1cfc44: 0xc6020058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[2] = *(float*)&val; }
    // 0x1cfc48: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1cfc4c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfc50: 0x0
    // NOP
    // 0x1cfc54: 0x45030058
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        ctx->pc = 0x1CFDB8; return;
    }
    // 0x1cfc5c: 0x7a620150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 336)));
    // 0x1cfc60: 0xafb30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 19));
    // 0x1cfc64: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x1cfc68: 0xafb00084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 16));
    // 0x1cfc6c: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1cfc70: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cfc74: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1cfc78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cfc80);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[20] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cfc80
// Address: 0x1cfc80 - 0x1cfca8

void entry_1cfc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfc80: 0x461503c1
    ctx->f[15] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x1cfc84: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cfc88: 0xc44d4e44
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20036)); ctx->f[13] = *(float*)&val; }
    // 0x1cfc8c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1cfc90: 0x27c4eab8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294961848));
    // 0x1cfc94: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1cfc98: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1cfc9c: 0x27a600e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1cfca0: 0xc07ac5a
    SET_GPR_U32(ctx, 31, 0x1cfca8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 196));
    MinimizeRange(rdram, ctx, runtime); return;
}


// Function: entry_1cfca8
// Address: 0x1cfca8 - 0x1cfcec

void entry_1cfca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfca8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1cfcac: 0xc7a100c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[1] = *(float*)&val; }
    // 0x1cfcb0: 0xc4604e10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19984)); ctx->f[0] = *(float*)&val; }
    // 0x1cfcb4: 0x46000b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1cfcb8: 0x12150010
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CFCFC; return;
    }
    // 0x1cfcc0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1cfcc4: 0xc4804e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20000)); ctx->f[0] = *(float*)&val; }
    // 0x1cfcc8: 0x460c0036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfccc: 0x0
    // NOP
    // 0x1cfcd0: 0x45030039
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        ctx->pc = 0x1CFDB8; return;
    }
    // 0x1cfcd8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1cfcdc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfce0: 0xc44d4e34
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20020)); ctx->f[13] = *(float*)&val; }
    // 0x1cfce4: 0xc073c4e
    SET_GPR_U32(ctx, 31, 0x1cfcec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cf138(rdram, ctx, runtime); return;
}


// Function: entry_1cfcec
// Address: 0x1cfcec - 0x1cfd10

void entry_1cfcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfcec) {
        switch (ctx->pc) {
            case 0x1cfcfc: ctx->pc = 0; goto label_1cfcfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfcec: 0x4600b836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[23], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfcf0: 0x0
    // NOP
    // 0x1cfcf4: 0x4501002f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 196), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1CFDB4; return;
    }
label_1cfcfc:
    // 0x1cfcfc: 0xc7ac00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[12] = *(float*)&val; }
    // 0x1cfd00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1cfd04: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cfd08: 0xc05a788
    SET_GPR_U32(ctx, 31, 0x1cfd10);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetHshapeHidePos__FP6HSHAPEfP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_1cfd10
// Address: 0x1cfd10 - 0x1cfd40

void entry_1cfd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfd10: 0x26710150
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 336));
    // 0x1cfd14: 0x27b40030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1cfd18: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1cfd1c: 0xafb40000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 20));
    // 0x1cfd20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfd24: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cfd28: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfd2c: 0x8e060018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1cfd30: 0x27a900c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1cfd34: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfd38: 0xc073964
    SET_GPR_U32(ctx, 31, 0x1cfd40);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_1cfd40
// Address: 0x1cfd40 - 0x1cfd80

void entry_1cfd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfd40: 0xc6600358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 856)); ctx->f[0] = *(float*)&val; }
    // 0x1cfd44: 0xc7ac00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[12] = *(float*)&val; }
    // 0x1cfd48: 0xc6610158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 344)); ctx->f[1] = *(float*)&val; }
    // 0x1cfd4c: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x1cfd50: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1cfd54: 0x1215000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1CFD88; return;
    }
    // 0x1cfd5c: 0x8e6706d4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 1748)));
    // 0x1cfd60: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1cfd64: 0x280502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1cfd68: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfd6c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfd70: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfd74: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1cfd78: 0xc073bb2
    SET_GPR_U32(ctx, 31, 0x1cfd80);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ceec8(rdram, ctx, runtime); return;
}


// Function: entry_1cfd80
// Address: 0x1cfd80 - 0x1cfde8

void entry_1cfd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfd80) {
        switch (ctx->pc) {
            case 0x1cfd88: ctx->pc = 0; goto label_1cfd88;
            case 0x1cfdb4: ctx->pc = 0; goto label_1cfdb4;
            case 0x1cfdb8: ctx->pc = 0; goto label_1cfdb8;
            case 0x1cfdc4: ctx->pc = 0; goto label_1cfdc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfd80: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        goto label_1cfdb8;
    }
label_1cfd88:
    // 0x1cfd88: 0xc7a000c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 196)); ctx->f[0] = *(float*)&val; }
    // 0x1cfd8c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1cfd90: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1cfd94: 0x46170029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[23]);
    // 0x1cfd98: 0xafb000f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 16));
    // 0x1cfd9c: 0x460005c6
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    // 0x1cfda0: 0xafa000e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 228), GPR_U32(ctx, 0));
    // 0x1cfda4: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1cfda8: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1cfdac: 0xc7b800c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[24] = *(float*)&val; }
    // 0x1cfdb0: 0xc7ba00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[26] = *(float*)&val; }
label_1cfdb4:
    // 0x1cfdb4: 0x8e100038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 56)));
label_1cfdb8:
    // 0x1cfdb8: 0x5600ff8b
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x1CFBE8; return;
    }
    // 0x1cfdc0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1cfdc4:
    // 0x1cfdc4: 0x8c432310
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8976)));
    // 0x1cfdc8: 0x1060000e
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFE04; return;
    }
    // 0x1cfdd0: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x1cfdd4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cfdd8: 0x3c0142f0
    SET_GPR_U32(ctx, 1, ((uint32_t)17136 << 16));
    // 0x1cfddc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1cfde0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1cfde8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 6232));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1cfde8
// Address: 0x1cfde8 - 0x1cfe5c

void entry_1cfde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfde8) {
        switch (ctx->pc) {
            case 0x1cfe04: ctx->pc = 0; goto label_1cfe04;
            case 0x1cfe08: ctx->pc = 0; goto label_1cfe08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfde8: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1cfdec: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1cfdf0: 0x0
    // NOP
    // 0x1cfdf4: 0x45000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1cfe08;
    }
    // 0x1cfdfc: 0x1000005f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF7C; return;
    }
label_1cfe04:
    // 0x1cfe04: 0x8fa400e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
label_1cfe08:
    // 0x1cfe08: 0x2c820008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 8));
    // 0x1cfe0c: 0x10400037
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFEEC; return;
    }
    // 0x1cfe14: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1cfe18: 0x2442dae0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957792));
    // 0x1cfe1c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1cfe20: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1cfe24: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1cfe2c: 0x8fa200e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 232)));
    // 0x1cfe30: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1cfe34: 0x1000003e
    WRITE32(ADD32(GPR_U32(ctx, 19), 9144), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
    // 0x1cfe3c: 0x8fa300ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 236)));
    // 0x1cfe40: 0xe67923c0
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 19), 9152), *(uint32_t*)&val); }
    // 0x1cfe44: 0xae6323bc
    WRITE32(ADD32(GPR_U32(ctx, 19), 9148), GPR_U32(ctx, 3));
    // 0x1cfe48: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1cfe4c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1cfe50: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1cfe54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1cfe5c);
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1cfe5c
// Address: 0x1cfe5c - 0x1cfeac

void entry_1cfe5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfe5c: 0xe66023c4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 9156), *(uint32_t*)&val); }
    // 0x1cfe60: 0x10000033
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
    // 0x1cfe68: 0x8fa400f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1cfe6c: 0xe67c23ac
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 19), 9132), *(uint32_t*)&val); }
    // 0x1cfe70: 0xae6423a8
    WRITE32(ADD32(GPR_U32(ctx, 19), 9128), GPR_U32(ctx, 4));
    // 0x1cfe74: 0x1000002e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
    // 0x1cfe7c: 0x8fa200f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x1cfe80: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1cfe84: 0xe67a23a4
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 19), 9124), *(uint32_t*)&val); }
    // 0x1cfe88: 0x10000029
    WRITE32(ADD32(GPR_U32(ctx, 19), 9120), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
    // 0x1cfe90: 0x8fa300f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x1cfe94: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfe98: 0xae602208
    WRITE32(ADD32(GPR_U32(ctx, 19), 8712), GPR_U32(ctx, 0));
    // 0x1cfe9c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfea0: 0xae632200
    WRITE32(ADD32(GPR_U32(ctx, 19), 8704), GPR_U32(ctx, 3));
    // 0x1cfea4: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1cfeac);
    WRITE32(ADD32(GPR_U32(ctx, 19), 8708), GPR_U32(ctx, 3));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1cfeac
// Address: 0x1cfeac - 0x1cfeb4

void entry_1cfeac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfeac: 0xc071a24
    SET_GPR_U32(ctx, 31, 0x1cfeb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    UpdateJtCane__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1cfeb4
// Address: 0x1cfeb4 - 0x1cfedc

void entry_1cfeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfeb4: 0x1000001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
    // 0x1cfebc: 0x8fa400fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x1cfec0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cfec4: 0xe67b220c
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 19), 8716), *(uint32_t*)&val); }
    // 0x1cfec8: 0xae642208
    WRITE32(ADD32(GPR_U32(ctx, 19), 8712), GPR_U32(ctx, 4));
    // 0x1cfecc: 0xae602204
    WRITE32(ADD32(GPR_U32(ctx, 19), 8708), GPR_U32(ctx, 0));
    // 0x1cfed0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1cfed4: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1cfedc);
    WRITE32(ADD32(GPR_U32(ctx, 19), 8704), GPR_U32(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1cfedc
// Address: 0x1cfedc - 0x1cfee4

void entry_1cfedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1cfedc: 0xc071a24
    SET_GPR_U32(ctx, 31, 0x1cfee4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    UpdateJtCane__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1cfee4
// Address: 0x1cfee4 - 0x1cff2c

void entry_1cfee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cfee4) {
        switch (ctx->pc) {
            case 0x1cfeec: ctx->pc = 0; goto label_1cfeec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cfee4: 0x10000012
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 15));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1CFF30; return;
    }
label_1cfeec:
    // 0x1cfeec: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1cfef0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1cfef4: 0xc44e2e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11812)); ctx->f[14] = *(float*)&val; }
    // 0x1cfef8: 0x2404007e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 126));
    // 0x1cfefc: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1cff00: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1cff04: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1cff08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cff0c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1cff10: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1cff14: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cff18: 0x26670140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1cff1c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1cff20: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1cff24: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1cff2c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1cff2c
// Address: 0x1cff2c - 0x1cffd0

void entry_1cff2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1cff2c) {
        switch (ctx->pc) {
            case 0x1cff30: ctx->pc = 0; goto label_1cff30;
            case 0x1cff7c: ctx->pc = 0; goto label_1cff7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1cff2c: 0x8e642228
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8744)));
label_1cff30:
    // 0x1cff30: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1cff34: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x1cff38: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1cff3c: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1cff40: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1cff44: 0x8e632514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9492)));
    // 0x1cff48: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1cff4c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1cff50: 0xe4600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 24), *(uint32_t*)&val); }
    // 0x1cff54: 0x8e642514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9492)));
    // 0x1cff58: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1cff5c: 0x7c830020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 3));
    // 0x1cff60: 0x8e652514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9492)));
    // 0x1cff64: 0xc4a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1cff68: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1cff6c: 0xe4a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 40), *(uint32_t*)&val); }
    // 0x1cff70: 0x8e642514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9492)));
    // 0x1cff74: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1cff78: 0x7c830030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 3));
label_1cff7c:
    // 0x1cff7c: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1cff80: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1cff84: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1cff88: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1cff8c: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1cff90: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1cff94: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1cff98: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1cff9c: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1cffa0: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1cffa4: 0xc7bc01f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[28] = *(float*)&val; }
    // 0x1cffa8: 0xc7bb01e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[27] = *(float*)&val; }
    // 0x1cffac: 0xc7ba01e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[26] = *(float*)&val; }
    // 0x1cffb0: 0xc7b901d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[25] = *(float*)&val; }
    // 0x1cffb4: 0xc7b801d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[24] = *(float*)&val; }
    // 0x1cffb8: 0xc7b701c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 456)); ctx->f[23] = *(float*)&val; }
    // 0x1cffbc: 0xc7b601c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[22] = *(float*)&val; }
    // 0x1cffc0: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x1cffc4: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x1cffc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 512));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtActiveHide__FP2JTP3JOY
// Address: 0x1cffd0 - 0x1d0058

void entry_1c0158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0158 inside entry_1c0148 (0x1c0148 - 0x1c0190)
    ctx->pc = 0x1c0158;
    entry_1c0148(rdram, ctx, runtime);
}

void entry_1c015c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c015c inside entry_1c0148 (0x1c0148 - 0x1c0190)
    ctx->pc = 0x1c015c;
    entry_1c0148(rdram, ctx, runtime);
}

void entry_1c01b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c01b8 inside entry_1c01ac (0x1c01ac - 0x1c0200)
    ctx->pc = 0x1c01b8;
    entry_1c01ac(rdram, ctx, runtime);
}

void entry_1c01bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c01bc inside entry_1c01ac (0x1c01ac - 0x1c0200)
    ctx->pc = 0x1c01bc;
    entry_1c01ac(rdram, ctx, runtime);
}

void entry_1c0254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0254 inside entry_1c0200 (0x1c0200 - 0x1c0280)
    ctx->pc = 0x1c0254;
    entry_1c0200(rdram, ctx, runtime);
}

void entry_1c0284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0284 inside entry_1c0280 (0x1c0280 - 0x1c02dc)
    ctx->pc = 0x1c0284;
    entry_1c0280(rdram, ctx, runtime);
}

void entry_1c028c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c028c inside entry_1c0280 (0x1c0280 - 0x1c02dc)
    ctx->pc = 0x1c028c;
    entry_1c0280(rdram, ctx, runtime);
}

void entry_1c02ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c02ac inside entry_1c0280 (0x1c0280 - 0x1c02dc)
    ctx->pc = 0x1c02ac;
    entry_1c0280(rdram, ctx, runtime);
}

void entry_1c02c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c02c0 inside entry_1c0280 (0x1c0280 - 0x1c02dc)
    ctx->pc = 0x1c02c0;
    entry_1c0280(rdram, ctx, runtime);
}

void entry_1c02e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c02e4 inside entry_1c02dc (0x1c02dc - 0x1c032c)
    ctx->pc = 0x1c02e4;
    entry_1c02dc(rdram, ctx, runtime);
}

void entry_1c02e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c02e8 inside entry_1c02dc (0x1c02dc - 0x1c032c)
    ctx->pc = 0x1c02e8;
    entry_1c02dc(rdram, ctx, runtime);
}

void entry_1c02ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c02ec inside entry_1c02dc (0x1c02dc - 0x1c032c)
    ctx->pc = 0x1c02ec;
    entry_1c02dc(rdram, ctx, runtime);
}

void entry_1c0318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0318 inside entry_1c02dc (0x1c02dc - 0x1c032c)
    ctx->pc = 0x1c0318;
    entry_1c02dc(rdram, ctx, runtime);
}

void entry_1c0338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0338 inside entry_1c032c (0x1c032c - 0x1c037c)
    ctx->pc = 0x1c0338;
    entry_1c032c(rdram, ctx, runtime);
}

void entry_1c0394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0394 inside entry_1c0390 (0x1c0390 - 0x1c03e0)
    ctx->pc = 0x1c0394;
    entry_1c0390(rdram, ctx, runtime);
}

void entry_1c03a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c03a0 inside entry_1c0390 (0x1c0390 - 0x1c03e0)
    ctx->pc = 0x1c03a0;
    entry_1c0390(rdram, ctx, runtime);
}

void entry_1c03e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c03e4 inside entry_1c03e0 (0x1c03e0 - 0x1c0428)
    ctx->pc = 0x1c03e4;
    entry_1c03e0(rdram, ctx, runtime);
}

void entry_1c0420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0420 inside entry_1c03e0 (0x1c03e0 - 0x1c0428)
    ctx->pc = 0x1c0420;
    entry_1c03e0(rdram, ctx, runtime);
}

void entry_1c045c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c045c inside entry_1c0428 (0x1c0428 - 0x1c0480)
    ctx->pc = 0x1c045c;
    entry_1c0428(rdram, ctx, runtime);
}

void entry_1c0460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0460 inside entry_1c0428 (0x1c0428 - 0x1c0480)
    ctx->pc = 0x1c0460;
    entry_1c0428(rdram, ctx, runtime);
}

void entry_1c04d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c04d8 inside entry_1c0480 (0x1c0480 - 0x1c04e0)
    ctx->pc = 0x1c04d8;
    entry_1c0480(rdram, ctx, runtime);
}

void entry_1c04ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c04ec inside entry_1c04e0 (0x1c04e0 - 0x1c04f4)
    ctx->pc = 0x1c04ec;
    entry_1c04e0(rdram, ctx, runtime);
}

void entry_1c04fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c04fc inside entry_1c04f4 (0x1c04f4 - 0x1c0514)
    ctx->pc = 0x1c04fc;
    entry_1c04f4(rdram, ctx, runtime);
}

void entry_1c0554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0554 inside entry_1c054c (0x1c054c - 0x1c055c)
    ctx->pc = 0x1c0554;
    entry_1c054c(rdram, ctx, runtime);
}

void entry_1c0574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0574 inside entry_1c0570 (0x1c0570 - 0x1c0594)
    ctx->pc = 0x1c0574;
    entry_1c0570(rdram, ctx, runtime);
}

void entry_1c058c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c058c inside entry_1c0570 (0x1c0570 - 0x1c0594)
    ctx->pc = 0x1c058c;
    entry_1c0570(rdram, ctx, runtime);
}

void entry_1c05a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c05a0 inside entry_1c0594 (0x1c0594 - 0x1c05d0)
    ctx->pc = 0x1c05a0;
    entry_1c0594(rdram, ctx, runtime);
}

void entry_1c0628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0628 inside MvgkUnknown1__F4MVGK (0x1c0600 - 0x1c0690)
    ctx->pc = 0x1c0628;
    MvgkUnknown1__F4MVGK(rdram, ctx, runtime);
}

void entry_1c0664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0664 inside MvgkUnknown1__F4MVGK (0x1c0600 - 0x1c0690)
    ctx->pc = 0x1c0664;
    MvgkUnknown1__F4MVGK(rdram, ctx, runtime);
}

void entry_1c0674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0674 inside MvgkUnknown1__F4MVGK (0x1c0600 - 0x1c0690)
    ctx->pc = 0x1c0674;
    MvgkUnknown1__F4MVGK(rdram, ctx, runtime);
}

void entry_1c0718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0718 inside entry_1c0714 (0x1c0714 - 0x1c0720)
    ctx->pc = 0x1c0718;
    entry_1c0714(rdram, ctx, runtime);
}

void entry_1c0778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0778 inside MvgkUnknown3 (0x1c0760 - 0x1c0784)
    ctx->pc = 0x1c0778;
    MvgkUnknown3(rdram, ctx, runtime);
}

void entry_1c0860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0860 inside KillSounds__Fi (0x1c0808 - 0x1c086c)
    ctx->pc = 0x1c0860;
    KillSounds__Fi(rdram, ctx, runtime);
}

void entry_1c0888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0888 inside entry_1c086c (0x1c086c - 0x1c0898)
    ctx->pc = 0x1c0888;
    entry_1c086c(rdram, ctx, runtime);
}

void entry_1c0890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0890 inside entry_1c086c (0x1c086c - 0x1c0898)
    ctx->pc = 0x1c0890;
    entry_1c086c(rdram, ctx, runtime);
}

void entry_1c0934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0934 inside entry_1c0908 (0x1c0908 - 0x1c0950)
    ctx->pc = 0x1c0934;
    entry_1c0908(rdram, ctx, runtime);
}

void entry_1c09c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c09c8 inside entry_1c09c4 (0x1c09c4 - 0x1c09d8)
    ctx->pc = 0x1c09c8;
    entry_1c09c4(rdram, ctx, runtime);
}

void entry_1c0ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0ab0 inside FUN_001C0A50 (0x1c0a50 - 0x1c0ab8)
    ctx->pc = 0x1c0ab0;
    FUN_001C0A50(rdram, ctx, runtime);
}

void entry_1c0b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0b00 inside FUN_001C0AB8 (0x1c0ab8 - 0x1c0b08)
    ctx->pc = 0x1c0b00;
    FUN_001C0AB8(rdram, ctx, runtime);
}

void entry_1c0b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0b30 inside FUN_001C0B08 (0x1c0b08 - 0x1c0b38)
    ctx->pc = 0x1c0b30;
    FUN_001C0B08(rdram, ctx, runtime);
}

void entry_1c0b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0b80 inside StartSwIntermittentSounds__FP2SW (0x1c0b38 - 0x1c0bc4)
    ctx->pc = 0x1c0b80;
    StartSwIntermittentSounds__FP2SW(rdram, ctx, runtime);
}

void entry_1c0bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0bdc inside entry_1c0bc4 (0x1c0bc4 - 0x1c0c08)
    ctx->pc = 0x1c0bdc;
    entry_1c0bc4(rdram, ctx, runtime);
}

void entry_1c0cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0cc8 inside FUN_001c0cb0__Fv (0x1c0cb0 - 0x1c0cd0)
    ctx->pc = 0x1c0cc8;
    FUN_001c0cb0__Fv(rdram, ctx, runtime);
}

void entry_1c0d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0d24 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0d24;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0d78 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0d78;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0d88 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0d88;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0db8 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0db8;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0dd8 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0dd8;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0e2c inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0e2c;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0e30 inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0e30;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c0e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c0e5c inside HsNextFootFall__Fv (0x1c0cf0 - 0x1c0e70)
    ctx->pc = 0x1c0e5c;
    HsNextFootFall__Fv(rdram, ctx, runtime);
}

void entry_1c105c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c105c inside entry_1c1058 (0x1c1058 - 0x1c1070)
    ctx->pc = 0x1c105c;
    entry_1c1058(rdram, ctx, runtime);
}

void entry_1c1090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1090 inside entry_1c108c (0x1c108c - 0x1c10a8)
    ctx->pc = 0x1c1090;
    entry_1c108c(rdram, ctx, runtime);
}

void entry_1c1210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1210 inside entry_1c11fc (0x1c11fc - 0x1c1220)
    ctx->pc = 0x1c1210;
    entry_1c11fc(rdram, ctx, runtime);
}

void entry_1c125c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c125c inside entry_1c1248 (0x1c1248 - 0x1c1280)
    ctx->pc = 0x1c125c;
    entry_1c1248(rdram, ctx, runtime);
}

void entry_1c1278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1278 inside entry_1c1248 (0x1c1248 - 0x1c1280)
    ctx->pc = 0x1c1278;
    entry_1c1248(rdram, ctx, runtime);
}

void entry_1c1288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1288 inside entry_1c1280 (0x1c1280 - 0x1c12a0)
    ctx->pc = 0x1c1288;
    entry_1c1280(rdram, ctx, runtime);
}

void entry_1c1298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1298 inside entry_1c1280 (0x1c1280 - 0x1c12a0)
    ctx->pc = 0x1c1298;
    entry_1c1280(rdram, ctx, runtime);
}

void entry_1c12a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c12a8 inside entry_1c12a0 (0x1c12a0 - 0x1c12b0)
    ctx->pc = 0x1c12a8;
    entry_1c12a0(rdram, ctx, runtime);
}

void entry_1c1308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1308 inside entry_1c12f4 (0x1c12f4 - 0x1c1310)
    ctx->pc = 0x1c1308;
    entry_1c12f4(rdram, ctx, runtime);
}

void entry_1c1358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1358 inside entry_1c1348 (0x1c1348 - 0x1c1364)
    ctx->pc = 0x1c1358;
    entry_1c1348(rdram, ctx, runtime);
}

void entry_1c13ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c13ac inside PframeFromIsplice__FiP2SW (0x1c1390 - 0x1c13d0)
    ctx->pc = 0x1c13ac;
    PframeFromIsplice__FiP2SW(rdram, ctx, runtime);
}

void entry_1c13d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c13d4 inside entry_1c13d0 (0x1c13d0 - 0x1c13e8)
    ctx->pc = 0x1c13d4;
    entry_1c13d0(rdram, ctx, runtime);
}

void entry_1c1480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1480 inside entry_1c147c (0x1c147c - 0x1c1488)
    ctx->pc = 0x1c1480;
    entry_1c147c(rdram, ctx, runtime);
}

void entry_1c14f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c14f0 inside PeopidFind__FP5BASICi (0x1c14c0 - 0x1c1530)
    ctx->pc = 0x1c14f0;
    PeopidFind__FP5BASICi(rdram, ctx, runtime);
}

void entry_1c1510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1510 inside PeopidFind__FP5BASICi (0x1c14c0 - 0x1c1530)
    ctx->pc = 0x1c1510;
    PeopidFind__FP5BASICi(rdram, ctx, runtime);
}

void entry_1c151c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c151c inside PeopidFind__FP5BASICi (0x1c14c0 - 0x1c1530)
    ctx->pc = 0x1c151c;
    PeopidFind__FP5BASICi(rdram, ctx, runtime);
}

void entry_1c1528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1528 inside PeopidFind__FP5BASICi (0x1c14c0 - 0x1c1530)
    ctx->pc = 0x1c1528;
    PeopidFind__FP5BASICi(rdram, ctx, runtime);
}

void entry_1c1594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1594 inside entry_1c158c (0x1c158c - 0x1c159c)
    ctx->pc = 0x1c1594;
    entry_1c158c(rdram, ctx, runtime);
}

void entry_1c15a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c15a0 inside entry_1c159c (0x1c159c - 0x1c15a8)
    ctx->pc = 0x1c15a0;
    entry_1c159c(rdram, ctx, runtime);
}

void entry_1c1648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1648 inside entry_1c1640 (0x1c1640 - 0x1c1664)
    ctx->pc = 0x1c1648;
    entry_1c1640(rdram, ctx, runtime);
}

void entry_1c1670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1670 inside entry_1c1664 (0x1c1664 - 0x1c16c4)
    ctx->pc = 0x1c1670;
    entry_1c1664(rdram, ctx, runtime);
}

void entry_1c1678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1678 inside entry_1c1664 (0x1c1664 - 0x1c16c4)
    ctx->pc = 0x1c1678;
    entry_1c1664(rdram, ctx, runtime);
}

void entry_1c1784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1784 inside entry_1c177c (0x1c177c - 0x1c17ac)
    ctx->pc = 0x1c1784;
    entry_1c177c(rdram, ctx, runtime);
}

void entry_1c1798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1798 inside entry_1c177c (0x1c177c - 0x1c17ac)
    ctx->pc = 0x1c1798;
    entry_1c177c(rdram, ctx, runtime);
}

void entry_1c17b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c17b4 inside entry_1c17ac (0x1c17ac - 0x1c17c8)
    ctx->pc = 0x1c17b4;
    entry_1c17ac(rdram, ctx, runtime);
}

void entry_1c17d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c17d0 inside entry_1c17c8 (0x1c17c8 - 0x1c1830)
    ctx->pc = 0x1c17d0;
    entry_1c17c8(rdram, ctx, runtime);
}

void entry_1c17d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c17d4 inside entry_1c17c8 (0x1c17c8 - 0x1c1830)
    ctx->pc = 0x1c17d4;
    entry_1c17c8(rdram, ctx, runtime);
}

void entry_1c17ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c17ec inside entry_1c17c8 (0x1c17c8 - 0x1c1830)
    ctx->pc = 0x1c17ec;
    entry_1c17c8(rdram, ctx, runtime);
}

void entry_1c17f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c17f8 inside entry_1c17c8 (0x1c17c8 - 0x1c1830)
    ctx->pc = 0x1c17f8;
    entry_1c17c8(rdram, ctx, runtime);
}

void entry_1c1848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1848 inside entry_1c1844 (0x1c1844 - 0x1c1850)
    ctx->pc = 0x1c1848;
    entry_1c1844(rdram, ctx, runtime);
}

void entry_1c1868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1868 inside entry_1c1864 (0x1c1864 - 0x1c1870)
    ctx->pc = 0x1c1868;
    entry_1c1864(rdram, ctx, runtime);
}

void entry_1c18c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c18c8 inside entry_1c18c4 (0x1c18c4 - 0x1c18d0)
    ctx->pc = 0x1c18c8;
    entry_1c18c4(rdram, ctx, runtime);
}

void entry_1c195c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c195c inside entry_1c1954 (0x1c1954 - 0x1c1984)
    ctx->pc = 0x1c195c;
    entry_1c1954(rdram, ctx, runtime);
}

void entry_1c19a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c19a4 inside entry_1c199c (0x1c199c - 0x1c19b4)
    ctx->pc = 0x1c19a4;
    entry_1c199c(rdram, ctx, runtime);
}

void entry_1c19b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c19b8 inside entry_1c19b4 (0x1c19b4 - 0x1c19c0)
    ctx->pc = 0x1c19b8;
    entry_1c19b4(rdram, ctx, runtime);
}

void entry_1c19c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c19c8 inside entry_1c19c0 (0x1c19c0 - 0x1c19dc)
    ctx->pc = 0x1c19c8;
    entry_1c19c0(rdram, ctx, runtime);
}

void entry_1c19ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c19ec inside entry_1c19e8 (0x1c19e8 - 0x1c19f4)
    ctx->pc = 0x1c19ec;
    entry_1c19e8(rdram, ctx, runtime);
}

void entry_1c1ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ab4 inside entry_1c1aa0 (0x1c1aa0 - 0x1c1ad8)
    ctx->pc = 0x1c1ab4;
    entry_1c1aa0(rdram, ctx, runtime);
}

void entry_1c1b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1b5c inside entry_1c1b54 (0x1c1b54 - 0x1c1b74)
    ctx->pc = 0x1c1b5c;
    entry_1c1b54(rdram, ctx, runtime);
}

void entry_1c1b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1b7c inside entry_1c1b74 (0x1c1b74 - 0x1c1b84)
    ctx->pc = 0x1c1b7c;
    entry_1c1b74(rdram, ctx, runtime);
}

void entry_1c1b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1b8c inside entry_1c1b84 (0x1c1b84 - 0x1c1ba0)
    ctx->pc = 0x1c1b8c;
    entry_1c1b84(rdram, ctx, runtime);
}

void entry_1c1bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1bb0 inside entry_1c1ba0 (0x1c1ba0 - 0x1c1bb8)
    ctx->pc = 0x1c1bb0;
    entry_1c1ba0(rdram, ctx, runtime);
}

void entry_1c1bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1bd0 inside entry_1c1bb8 (0x1c1bb8 - 0x1c1bd8)
    ctx->pc = 0x1c1bd0;
    entry_1c1bb8(rdram, ctx, runtime);
}

void entry_1c1bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1bdc inside entry_1c1bd8 (0x1c1bd8 - 0x1c1bf8)
    ctx->pc = 0x1c1bdc;
    entry_1c1bd8(rdram, ctx, runtime);
}

void entry_1c1c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1c50 inside entry_1c1c44 (0x1c1c44 - 0x1c1c5c)
    ctx->pc = 0x1c1c50;
    entry_1c1c44(rdram, ctx, runtime);
}

void entry_1c1d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1d0c inside entry_1c1ce8 (0x1c1ce8 - 0x1c1d14)
    ctx->pc = 0x1c1d0c;
    entry_1c1ce8(rdram, ctx, runtime);
}

void entry_1c1dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1dc0 inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1dc0;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1dd8 inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1dd8;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ddc inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1ddc;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1de0 inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1de0;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1de4 inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1de4;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1df4 inside entry_1c1d50 (0x1c1d50 - 0x1c1dfc)
    ctx->pc = 0x1c1df4;
    entry_1c1d50(rdram, ctx, runtime);
}

void entry_1c1e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1e98 inside entry_1c1e7c (0x1c1e7c - 0x1c1eb0)
    ctx->pc = 0x1c1e98;
    entry_1c1e7c(rdram, ctx, runtime);
}

void entry_1c1ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ebc inside entry_1c1eb0 (0x1c1eb0 - 0x1c1ed0)
    ctx->pc = 0x1c1ebc;
    entry_1c1eb0(rdram, ctx, runtime);
}

void entry_1c1ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ed8 inside entry_1c1ed0 (0x1c1ed0 - 0x1c1ee0)
    ctx->pc = 0x1c1ed8;
    entry_1c1ed0(rdram, ctx, runtime);
}

void entry_1c1ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ee4 inside entry_1c1ee0 (0x1c1ee0 - 0x1c1eec)
    ctx->pc = 0x1c1ee4;
    entry_1c1ee0(rdram, ctx, runtime);
}

void entry_1c1f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1f94 inside entry_1c1f88 (0x1c1f88 - 0x1c1fbc)
    ctx->pc = 0x1c1f94;
    entry_1c1f88(rdram, ctx, runtime);
}

void entry_1c1f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1f9c inside entry_1c1f88 (0x1c1f88 - 0x1c1fbc)
    ctx->pc = 0x1c1f9c;
    entry_1c1f88(rdram, ctx, runtime);
}

void entry_1c1fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1fdc inside entry_1c1fd4 (0x1c1fd4 - 0x1c1ff4)
    ctx->pc = 0x1c1fdc;
    entry_1c1fd4(rdram, ctx, runtime);
}

void entry_1c1ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c1ffc inside entry_1c1ff4 (0x1c1ff4 - 0x1c2070)
    ctx->pc = 0x1c1ffc;
    entry_1c1ff4(rdram, ctx, runtime);
}

void entry_1c2000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2000 inside entry_1c1ff4 (0x1c1ff4 - 0x1c2070)
    ctx->pc = 0x1c2000;
    entry_1c1ff4(rdram, ctx, runtime);
}

void entry_1c2018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2018 inside entry_1c1ff4 (0x1c1ff4 - 0x1c2070)
    ctx->pc = 0x1c2018;
    entry_1c1ff4(rdram, ctx, runtime);
}

void entry_1c2024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2024 inside entry_1c1ff4 (0x1c1ff4 - 0x1c2070)
    ctx->pc = 0x1c2024;
    entry_1c1ff4(rdram, ctx, runtime);
}

void entry_1c2068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2068 inside entry_1c1ff4 (0x1c1ff4 - 0x1c2070)
    ctx->pc = 0x1c2068;
    entry_1c1ff4(rdram, ctx, runtime);
}

void entry_1c20d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c20d4 inside entry_1c20b4 (0x1c20b4 - 0x1c20dc)
    ctx->pc = 0x1c20d4;
    entry_1c20b4(rdram, ctx, runtime);
}

void entry_1c2128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2128 inside entry_1c2120 (0x1c2120 - 0x1c2140)
    ctx->pc = 0x1c2128;
    entry_1c2120(rdram, ctx, runtime);
}

void entry_1c2148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2148 inside entry_1c2140 (0x1c2140 - 0x1c215c)
    ctx->pc = 0x1c2148;
    entry_1c2140(rdram, ctx, runtime);
}

void entry_1c2160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2160 inside entry_1c215c (0x1c215c - 0x1c2168)
    ctx->pc = 0x1c2160;
    entry_1c215c(rdram, ctx, runtime);
}

void entry_1c21ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c21ec inside entry_1c21e4 (0x1c21e4 - 0x1c21f4)
    ctx->pc = 0x1c21ec;
    entry_1c21e4(rdram, ctx, runtime);
}

void entry_1c2220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2220 inside entry_1c221c (0x1c221c - 0x1c2238)
    ctx->pc = 0x1c2220;
    entry_1c221c(rdram, ctx, runtime);
}

void entry_1c2288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2288 inside entry_1c2280 (0x1c2280 - 0x1c2298)
    ctx->pc = 0x1c2288;
    entry_1c2280(rdram, ctx, runtime);
}

void entry_1c229c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c229c inside entry_1c2298 (0x1c2298 - 0x1c22b8)
    ctx->pc = 0x1c229c;
    entry_1c2298(rdram, ctx, runtime);
}

void entry_1c2380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2380 inside entry_1c2378 (0x1c2378 - 0x1c2390)
    ctx->pc = 0x1c2380;
    entry_1c2378(rdram, ctx, runtime);
}

void entry_1c2394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2394 inside entry_1c2390 (0x1c2390 - 0x1c23b0)
    ctx->pc = 0x1c2394;
    entry_1c2390(rdram, ctx, runtime);
}

void entry_1c23f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c23f0 inside RefSetArgsFromSplice__FiP4CRefP4OTYPe (0x1c23b0 - 0x1c2418)
    ctx->pc = 0x1c23f0;
    RefSetArgsFromSplice__FiP4CRefP4OTYPe(rdram, ctx, runtime);
}

void entry_1c240c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c240c inside RefSetArgsFromSplice__FiP4CRefP4OTYPe (0x1c23b0 - 0x1c2418)
    ctx->pc = 0x1c240c;
    RefSetArgsFromSplice__FiP4CRefP4OTYPe(rdram, ctx, runtime);
}

void entry_1c24e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c24e8 inside entry_1c24c8 (0x1c24c8 - 0x1c2590)
    ctx->pc = 0x1c24e8;
    entry_1c24c8(rdram, ctx, runtime);
}

void entry_1c2530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2530 inside entry_1c24c8 (0x1c24c8 - 0x1c2590)
    ctx->pc = 0x1c2530;
    entry_1c24c8(rdram, ctx, runtime);
}

void entry_1c2538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2538 inside entry_1c24c8 (0x1c24c8 - 0x1c2590)
    ctx->pc = 0x1c2538;
    entry_1c24c8(rdram, ctx, runtime);
}

void entry_1c254c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c254c inside entry_1c24c8 (0x1c24c8 - 0x1c2590)
    ctx->pc = 0x1c254c;
    entry_1c24c8(rdram, ctx, runtime);
}

void entry_1c2650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2650 inside entry_1c2644 (0x1c2644 - 0x1c2754)
    ctx->pc = 0x1c2650;
    entry_1c2644(rdram, ctx, runtime);
}

void entry_1c266c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c266c inside entry_1c2644 (0x1c2644 - 0x1c2754)
    ctx->pc = 0x1c266c;
    entry_1c2644(rdram, ctx, runtime);
}

void entry_1c26a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c26a0 inside entry_1c2644 (0x1c2644 - 0x1c2754)
    ctx->pc = 0x1c26a0;
    entry_1c2644(rdram, ctx, runtime);
}

void entry_1c26e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c26e4 inside entry_1c2644 (0x1c2644 - 0x1c2754)
    ctx->pc = 0x1c26e4;
    entry_1c2644(rdram, ctx, runtime);
}

void entry_1c2780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2780 inside entry_1c2754 (0x1c2754 - 0x1c27a8)
    ctx->pc = 0x1c2780;
    entry_1c2754(rdram, ctx, runtime);
}

void entry_1c2820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2820 inside entry_1c27e8 (0x1c27e8 - 0x1c28e0)
    ctx->pc = 0x1c2820;
    entry_1c27e8(rdram, ctx, runtime);
}

void entry_1c2874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2874 inside entry_1c27e8 (0x1c27e8 - 0x1c28e0)
    ctx->pc = 0x1c2874;
    entry_1c27e8(rdram, ctx, runtime);
}

void entry_1c2880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2880 inside entry_1c27e8 (0x1c27e8 - 0x1c28e0)
    ctx->pc = 0x1c2880;
    entry_1c27e8(rdram, ctx, runtime);
}

void entry_1c28ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c28ac inside entry_1c27e8 (0x1c27e8 - 0x1c28e0)
    ctx->pc = 0x1c28ac;
    entry_1c27e8(rdram, ctx, runtime);
}

void entry_1c290c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c290c inside entry_1c28e0 (0x1c28e0 - 0x1c29c8)
    ctx->pc = 0x1c290c;
    entry_1c28e0(rdram, ctx, runtime);
}

void entry_1c2960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2960 inside entry_1c28e0 (0x1c28e0 - 0x1c29c8)
    ctx->pc = 0x1c2960;
    entry_1c28e0(rdram, ctx, runtime);
}

void entry_1c298c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c298c inside entry_1c28e0 (0x1c28e0 - 0x1c29c8)
    ctx->pc = 0x1c298c;
    entry_1c28e0(rdram, ctx, runtime);
}

void entry_1c29ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c29ac inside entry_1c28e0 (0x1c28e0 - 0x1c29c8)
    ctx->pc = 0x1c29ac;
    entry_1c28e0(rdram, ctx, runtime);
}

void entry_1c2a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2a98 inside UpdateSqtrm__FP5SQTRMP6VECTORP7MATRIX3ff (0x1c29f8 - 0x1c2af0)
    ctx->pc = 0x1c2a98;
    UpdateSqtrm__FP5SQTRMP6VECTORP7MATRIX3ff(rdram, ctx, runtime);
}

void entry_1c2b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2b00 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2b00;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2b58 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2b58;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ba8 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2ba8;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2bd0 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2bd0;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c08 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c08;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c10 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c10;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c58 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c58;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c68 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c68;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c70 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c70;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2c74 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2c74;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2cc0 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2cc0;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2d18 inside entry_1c2af0 (0x1c2af0 - 0x1c2d2c)
    ctx->pc = 0x1c2d18;
    entry_1c2af0(rdram, ctx, runtime);
}

void entry_1c2e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2e18 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2e18;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ea8 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2ea8;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ee4 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2ee4;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2f28 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2f28;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2f4c inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2f4c;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2f50 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2f50;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2f64 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2f64;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2fac inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2fac;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2fd0 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2fd0;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2fd4 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2fd4;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ff0 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2ff0;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ff4 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2ff4;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c2ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c2ff8 inside entry_1c2db4 (0x1c2db4 - 0x1c3028)
    ctx->pc = 0x1c2ff8;
    entry_1c2db4(rdram, ctx, runtime);
}

void entry_1c31b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c31b8 inside entry_1c3188 (0x1c3188 - 0x1c327c)
    ctx->pc = 0x1c31b8;
    entry_1c3188(rdram, ctx, runtime);
}

void entry_1c3218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3218 inside entry_1c3188 (0x1c3188 - 0x1c327c)
    ctx->pc = 0x1c3218;
    entry_1c3188(rdram, ctx, runtime);
}

void entry_1c3228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3228 inside entry_1c3188 (0x1c3188 - 0x1c327c)
    ctx->pc = 0x1c3228;
    entry_1c3188(rdram, ctx, runtime);
}

void entry_1c3264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3264 inside entry_1c3188 (0x1c3188 - 0x1c327c)
    ctx->pc = 0x1c3264;
    entry_1c3188(rdram, ctx, runtime);
}

void entry_1c3268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3268 inside entry_1c3188 (0x1c3188 - 0x1c327c)
    ctx->pc = 0x1c3268;
    entry_1c3188(rdram, ctx, runtime);
}

void entry_1c3324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3324 inside entry_1c3310 (0x1c3310 - 0x1c3340)
    ctx->pc = 0x1c3324;
    entry_1c3310(rdram, ctx, runtime);
}

void entry_1c3334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3334 inside entry_1c3310 (0x1c3310 - 0x1c3340)
    ctx->pc = 0x1c3334;
    entry_1c3310(rdram, ctx, runtime);
}

void entry_1c3338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3338 inside entry_1c3310 (0x1c3310 - 0x1c3340)
    ctx->pc = 0x1c3338;
    entry_1c3310(rdram, ctx, runtime);
}

void entry_1c3514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3514 inside entry_1c3510 (0x1c3510 - 0x1c3530)
    ctx->pc = 0x1c3514;
    entry_1c3510(rdram, ctx, runtime);
}

void entry_1c3534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3534 inside entry_1c3530 (0x1c3530 - 0x1c3548)
    ctx->pc = 0x1c3534;
    entry_1c3530(rdram, ctx, runtime);
}

void entry_1c3550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3550 inside entry_1c3548 (0x1c3548 - 0x1c3578)
    ctx->pc = 0x1c3550;
    entry_1c3548(rdram, ctx, runtime);
}

void entry_1c3580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3580 inside entry_1c3578 (0x1c3578 - 0x1c35a4)
    ctx->pc = 0x1c3580;
    entry_1c3578(rdram, ctx, runtime);
}

void entry_1c35bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c35bc inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c35bc;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c35c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c35c0 inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c35c0;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c3620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3620 inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c3620;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c3630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3630 inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c3630;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c363c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c363c inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c363c;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c3650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3650 inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c3650;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c36ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c36ac inside entry_1c35a4 (0x1c35a4 - 0x1c36b8)
    ctx->pc = 0x1c36ac;
    entry_1c35a4(rdram, ctx, runtime);
}

void entry_1c375c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c375c inside entry_1c370c (0x1c370c - 0x1c3780)
    ctx->pc = 0x1c375c;
    entry_1c370c(rdram, ctx, runtime);
}

void entry_1c3764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3764 inside entry_1c370c (0x1c370c - 0x1c3780)
    ctx->pc = 0x1c3764;
    entry_1c370c(rdram, ctx, runtime);
}

void entry_1c37dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c37dc inside entry_1c3780 (0x1c3780 - 0x1c38dc)
    ctx->pc = 0x1c37dc;
    entry_1c3780(rdram, ctx, runtime);
}

void entry_1c3820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3820 inside entry_1c3780 (0x1c3780 - 0x1c38dc)
    ctx->pc = 0x1c3820;
    entry_1c3780(rdram, ctx, runtime);
}

void entry_1c3830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3830 inside entry_1c3780 (0x1c3780 - 0x1c38dc)
    ctx->pc = 0x1c3830;
    entry_1c3780(rdram, ctx, runtime);
}

void entry_1c38d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c38d0 inside entry_1c3780 (0x1c3780 - 0x1c38dc)
    ctx->pc = 0x1c38d0;
    entry_1c3780(rdram, ctx, runtime);
}

void entry_1c396c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c396c inside entry_1c3964 (0x1c3964 - 0x1c397c)
    ctx->pc = 0x1c396c;
    entry_1c3964(rdram, ctx, runtime);
}

void entry_1c3994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3994 inside entry_1c3990 (0x1c3990 - 0x1c39a0)
    ctx->pc = 0x1c3994;
    entry_1c3990(rdram, ctx, runtime);
}

void entry_1c39f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c39f8 inside FUN_001c39a0 (0x1c39a0 - 0x1c3a08)
    ctx->pc = 0x1c39f8;
    FUN_001c39a0(rdram, ctx, runtime);
}

void entry_1c3a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3a10 inside entry_1c3a08 (0x1c3a08 - 0x1c3a1c)
    ctx->pc = 0x1c3a10;
    entry_1c3a08(rdram, ctx, runtime);
}

void entry_1c3a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3a20 inside entry_1c3a1c (0x1c3a1c - 0x1c3a74)
    ctx->pc = 0x1c3a20;
    entry_1c3a1c(rdram, ctx, runtime);
}

void entry_1c3a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3a24 inside entry_1c3a1c (0x1c3a1c - 0x1c3a74)
    ctx->pc = 0x1c3a24;
    entry_1c3a1c(rdram, ctx, runtime);
}

void entry_1c3a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3a48 inside entry_1c3a1c (0x1c3a1c - 0x1c3a74)
    ctx->pc = 0x1c3a48;
    entry_1c3a1c(rdram, ctx, runtime);
}

void entry_1c3b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3b00 inside entry_1c3af8 (0x1c3af8 - 0x1c3b14)
    ctx->pc = 0x1c3b00;
    entry_1c3af8(rdram, ctx, runtime);
}

void entry_1c3b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3b18 inside entry_1c3b14 (0x1c3b14 - 0x1c3b20)
    ctx->pc = 0x1c3b18;
    entry_1c3b14(rdram, ctx, runtime);
}

void entry_1c3c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3c50 inside entry_1c3c34 (0x1c3c34 - 0x1c3c6c)
    ctx->pc = 0x1c3c50;
    entry_1c3c34(rdram, ctx, runtime);
}

void entry_1c3c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3c64 inside entry_1c3c34 (0x1c3c34 - 0x1c3c6c)
    ctx->pc = 0x1c3c64;
    entry_1c3c34(rdram, ctx, runtime);
}

void entry_1c3c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3c7c inside entry_1c3c6c (0x1c3c6c - 0x1c3d28)
    ctx->pc = 0x1c3c7c;
    entry_1c3c6c(rdram, ctx, runtime);
}

void entry_1c3c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3c80 inside entry_1c3c6c (0x1c3c6c - 0x1c3d28)
    ctx->pc = 0x1c3c80;
    entry_1c3c6c(rdram, ctx, runtime);
}

void entry_1c3d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3d20 inside entry_1c3c6c (0x1c3c6c - 0x1c3d28)
    ctx->pc = 0x1c3d20;
    entry_1c3c6c(rdram, ctx, runtime);
}

void entry_1c3d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3d50 inside entry_1c3d48 (0x1c3d48 - 0x1c3d60)
    ctx->pc = 0x1c3d50;
    entry_1c3d48(rdram, ctx, runtime);
}

void entry_1c3d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3d54 inside entry_1c3d48 (0x1c3d48 - 0x1c3d60)
    ctx->pc = 0x1c3d54;
    entry_1c3d48(rdram, ctx, runtime);
}

void entry_1c3db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3db8 inside entry_1c3db4 (0x1c3db4 - 0x1c3de0)
    ctx->pc = 0x1c3db8;
    entry_1c3db4(rdram, ctx, runtime);
}

void entry_1c3dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3dcc inside entry_1c3db4 (0x1c3db4 - 0x1c3de0)
    ctx->pc = 0x1c3dcc;
    entry_1c3db4(rdram, ctx, runtime);
}

void entry_1c3e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3e08 inside entry_1c3df0 (0x1c3df0 - 0x1c3e10)
    ctx->pc = 0x1c3e08;
    entry_1c3df0(rdram, ctx, runtime);
}

void entry_1c3e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3e38 inside entry_1c3e34 (0x1c3e34 - 0x1c3e80)
    ctx->pc = 0x1c3e38;
    entry_1c3e34(rdram, ctx, runtime);
}

void entry_1c3e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3e74 inside entry_1c3e34 (0x1c3e34 - 0x1c3e80)
    ctx->pc = 0x1c3e74;
    entry_1c3e34(rdram, ctx, runtime);
}

void entry_1c3f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3f30 inside FUN_001c3eb0 (0x1c3eb0 - 0x1c3f58)
    ctx->pc = 0x1c3f30;
    FUN_001c3eb0(rdram, ctx, runtime);
}

void entry_1c3f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c3f3c inside FUN_001c3eb0 (0x1c3eb0 - 0x1c3f58)
    ctx->pc = 0x1c3f3c;
    FUN_001c3eb0(rdram, ctx, runtime);
}

void entry_1c4010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4010 inside FUN_001c3fc8 (0x1c3fc8 - 0x1c4034)
    ctx->pc = 0x1c4010;
    FUN_001c3fc8(rdram, ctx, runtime);
}

void entry_1c4138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4138 inside entry_1c4130 (0x1c4130 - 0x1c4154)
    ctx->pc = 0x1c4138;
    entry_1c4130(rdram, ctx, runtime);
}

void entry_1c4164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4164 inside entry_1c4154 (0x1c4154 - 0x1c4180)
    ctx->pc = 0x1c4164;
    entry_1c4154(rdram, ctx, runtime);
}

void entry_1c4200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4200 inside FUN_001c41a0 (0x1c41a0 - 0x1c422c)
    ctx->pc = 0x1c4200;
    FUN_001c41a0(rdram, ctx, runtime);
}

void entry_1c4218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4218 inside FUN_001c41a0 (0x1c41a0 - 0x1c422c)
    ctx->pc = 0x1c4218;
    FUN_001c41a0(rdram, ctx, runtime);
}

void entry_1c4268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4268 inside entry_1c422c (0x1c422c - 0x1c4280)
    ctx->pc = 0x1c4268;
    entry_1c422c(rdram, ctx, runtime);
}

void entry_1c4298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4298 inside entry_1c4280 (0x1c4280 - 0x1c42a4)
    ctx->pc = 0x1c4298;
    entry_1c4280(rdram, ctx, runtime);
}

void entry_1c42d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c42d4 inside entry_1c42a4 (0x1c42a4 - 0x1c4324)
    ctx->pc = 0x1c42d4;
    entry_1c42a4(rdram, ctx, runtime);
}

void entry_1c42e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c42e8 inside entry_1c42a4 (0x1c42a4 - 0x1c4324)
    ctx->pc = 0x1c42e8;
    entry_1c42a4(rdram, ctx, runtime);
}

void entry_1c4300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4300 inside entry_1c42a4 (0x1c42a4 - 0x1c4324)
    ctx->pc = 0x1c4300;
    entry_1c42a4(rdram, ctx, runtime);
}

void entry_1c4314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4314 inside entry_1c42a4 (0x1c42a4 - 0x1c4324)
    ctx->pc = 0x1c4314;
    entry_1c42a4(rdram, ctx, runtime);
}

void entry_1c4400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4400 inside entry_1c43fc (0x1c43fc - 0x1c4458)
    ctx->pc = 0x1c4400;
    entry_1c43fc(rdram, ctx, runtime);
}

void entry_1c4530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4530 inside entry_1c4524 (0x1c4524 - 0x1c4578)
    ctx->pc = 0x1c4530;
    entry_1c4524(rdram, ctx, runtime);
}

void entry_1c4540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4540 inside entry_1c4524 (0x1c4524 - 0x1c4578)
    ctx->pc = 0x1c4540;
    entry_1c4524(rdram, ctx, runtime);
}

void entry_1c45b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c45b0 inside LimitStepHands__FP4STEPi (0x1c4578 - 0x1c4618)
    ctx->pc = 0x1c45b0;
    LimitStepHands__FP4STEPi(rdram, ctx, runtime);
}

void entry_1c45b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c45b8 inside LimitStepHands__FP4STEPi (0x1c4578 - 0x1c4618)
    ctx->pc = 0x1c45b8;
    LimitStepHands__FP4STEPi(rdram, ctx, runtime);
}

void entry_1c45c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c45c0 inside LimitStepHands__FP4STEPi (0x1c4578 - 0x1c4618)
    ctx->pc = 0x1c45c0;
    LimitStepHands__FP4STEPi(rdram, ctx, runtime);
}

void entry_1c45fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c45fc inside LimitStepHands__FP4STEPi (0x1c4578 - 0x1c4618)
    ctx->pc = 0x1c45fc;
    LimitStepHands__FP4STEPi(rdram, ctx, runtime);
}

void entry_1c4610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4610 inside LimitStepHands__FP4STEPi (0x1c4578 - 0x1c4618)
    ctx->pc = 0x1c4610;
    LimitStepHands__FP4STEPi(rdram, ctx, runtime);
}

void entry_1c46d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c46d4 inside entry_1c466c (0x1c466c - 0x1c4790)
    ctx->pc = 0x1c46d4;
    entry_1c466c(rdram, ctx, runtime);
}

void entry_1c46e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c46e4 inside entry_1c466c (0x1c466c - 0x1c4790)
    ctx->pc = 0x1c46e4;
    entry_1c466c(rdram, ctx, runtime);
}

void entry_1c4774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4774 inside entry_1c466c (0x1c466c - 0x1c4790)
    ctx->pc = 0x1c4774;
    entry_1c466c(rdram, ctx, runtime);
}

void entry_1c47e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c47e4 inside entry_1c47c4 (0x1c47c4 - 0x1c4848)
    ctx->pc = 0x1c47e4;
    entry_1c47c4(rdram, ctx, runtime);
}

void entry_1c4814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4814 inside entry_1c47c4 (0x1c47c4 - 0x1c4848)
    ctx->pc = 0x1c4814;
    entry_1c47c4(rdram, ctx, runtime);
}

void entry_1c4838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4838 inside entry_1c47c4 (0x1c47c4 - 0x1c4848)
    ctx->pc = 0x1c4838;
    entry_1c47c4(rdram, ctx, runtime);
}

void entry_1c4a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4a54 inside entry_1c4a4c (0x1c4a4c - 0x1c4a80)
    ctx->pc = 0x1c4a54;
    entry_1c4a4c(rdram, ctx, runtime);
}

void entry_1c4a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4a60 inside entry_1c4a4c (0x1c4a4c - 0x1c4a80)
    ctx->pc = 0x1c4a60;
    entry_1c4a4c(rdram, ctx, runtime);
}

void entry_1c4b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4b28 inside entry_1c4b10 (0x1c4b10 - 0x1c4b4c)
    ctx->pc = 0x1c4b28;
    entry_1c4b10(rdram, ctx, runtime);
}

void entry_1c4b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4b2c inside entry_1c4b10 (0x1c4b10 - 0x1c4b4c)
    ctx->pc = 0x1c4b2c;
    entry_1c4b10(rdram, ctx, runtime);
}

void entry_1c4b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4b7c inside entry_1c4b68 (0x1c4b68 - 0x1c4b88)
    ctx->pc = 0x1c4b7c;
    entry_1c4b68(rdram, ctx, runtime);
}

void entry_1c4bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4bbc inside entry_1c4b88 (0x1c4b88 - 0x1c4bf8)
    ctx->pc = 0x1c4bbc;
    entry_1c4b88(rdram, ctx, runtime);
}

void entry_1c4c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4c04 inside entry_1c4c00 (0x1c4c00 - 0x1c4c20)
    ctx->pc = 0x1c4c04;
    entry_1c4c00(rdram, ctx, runtime);
}

void entry_1c4c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4c80 inside UpdateStepPhys__FP4STEP (0x1c4c20 - 0x1c4cf4)
    ctx->pc = 0x1c4c80;
    UpdateStepPhys__FP4STEP(rdram, ctx, runtime);
}

void entry_1c4cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4cd0 inside UpdateStepPhys__FP4STEP (0x1c4c20 - 0x1c4cf4)
    ctx->pc = 0x1c4cd0;
    UpdateStepPhys__FP4STEP(rdram, ctx, runtime);
}

void entry_1c4d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4d34 inside entry_1c4cf4 (0x1c4cf4 - 0x1c4d60)
    ctx->pc = 0x1c4d34;
    entry_1c4cf4(rdram, ctx, runtime);
}

void entry_1c4d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4d94 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4d94;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4dc0 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4dc0;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4e18 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4e18;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4e5c inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4e5c;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4e60 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4e60;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4e78 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4e78;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4e88 inside SetStepPhys__FP4STEPP2SOi (0x1c4d60 - 0x1c4e9c)
    ctx->pc = 0x1c4e88;
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime);
}

void entry_1c4eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4eb8 inside entry_1c4eb4 (0x1c4eb4 - 0x1c4ed0)
    ctx->pc = 0x1c4eb8;
    entry_1c4eb4(rdram, ctx, runtime);
}

void entry_1c4ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c4ebc inside entry_1c4eb4 (0x1c4eb4 - 0x1c4ed0)
    ctx->pc = 0x1c4ebc;
    entry_1c4eb4(rdram, ctx, runtime);
}

void entry_1c5050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5050 inside entry_1c5034 (0x1c5034 - 0x1c50b4)
    ctx->pc = 0x1c5050;
    entry_1c5034(rdram, ctx, runtime);
}

void entry_1c50bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c50bc inside entry_1c50b4 (0x1c50b4 - 0x1c5118)
    ctx->pc = 0x1c50bc;
    entry_1c50b4(rdram, ctx, runtime);
}

void entry_1c50e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c50e8 inside entry_1c50b4 (0x1c50b4 - 0x1c5118)
    ctx->pc = 0x1c50e8;
    entry_1c50b4(rdram, ctx, runtime);
}

void entry_1c50f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c50f8 inside entry_1c50b4 (0x1c50b4 - 0x1c5118)
    ctx->pc = 0x1c50f8;
    entry_1c50b4(rdram, ctx, runtime);
}

void entry_1c5190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5190 inside entry_1c5174 (0x1c5174 - 0x1c51d4)
    ctx->pc = 0x1c5190;
    entry_1c5174(rdram, ctx, runtime);
}

void entry_1c5230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5230 inside entry_1c522c (0x1c522c - 0x1c5248)
    ctx->pc = 0x1c5230;
    entry_1c522c(rdram, ctx, runtime);
}

void entry_1c5258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5258 inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c5258;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c5260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5260 inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c5260;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c52b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c52b8 inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c52b8;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c52cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c52cc inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c52cc;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c52ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c52ec inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c52ec;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c530c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c530c inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c530c;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c5314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5314 inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c5314;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c5330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5330 inside FCheckStepXpBase__FP4STEPP2XPi (0x1c5248 - 0x1c5338)
    ctx->pc = 0x1c5330;
    FCheckStepXpBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c536c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c536c inside entry_1c5354 (0x1c5354 - 0x1c5388)
    ctx->pc = 0x1c536c;
    entry_1c5354(rdram, ctx, runtime);
}

void entry_1c5374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5374 inside entry_1c5354 (0x1c5354 - 0x1c5388)
    ctx->pc = 0x1c5374;
    entry_1c5354(rdram, ctx, runtime);
}

void entry_1c54ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c54ac inside entry_1c5464 (0x1c5464 - 0x1c54d0)
    ctx->pc = 0x1c54ac;
    entry_1c5464(rdram, ctx, runtime);
}

void entry_1c54bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c54bc inside entry_1c5464 (0x1c5464 - 0x1c54d0)
    ctx->pc = 0x1c54bc;
    entry_1c5464(rdram, ctx, runtime);
}

void entry_1c551c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c551c inside AdjustStepXpVelocityBase__FP4STEPP2XPi (0x1c54d0 - 0x1c56cc)
    ctx->pc = 0x1c551c;
    AdjustStepXpVelocityBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c5528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5528 inside AdjustStepXpVelocityBase__FP4STEPP2XPi (0x1c54d0 - 0x1c56cc)
    ctx->pc = 0x1c5528;
    AdjustStepXpVelocityBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c55fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c55fc inside AdjustStepXpVelocityBase__FP4STEPP2XPi (0x1c54d0 - 0x1c56cc)
    ctx->pc = 0x1c55fc;
    AdjustStepXpVelocityBase__FP4STEPP2XPi(rdram, ctx, runtime);
}

void entry_1c56fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c56fc inside entry_1c56e8 (0x1c56e8 - 0x1c5724)
    ctx->pc = 0x1c56fc;
    entry_1c56e8(rdram, ctx, runtime);
}

void entry_1c5728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5728 inside entry_1c5724 (0x1c5724 - 0x1c57c8)
    ctx->pc = 0x1c5728;
    entry_1c5724(rdram, ctx, runtime);
}

void entry_1c5820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5820 inside AdjustStepXps__FP4STEP (0x1c57c8 - 0x1c5860)
    ctx->pc = 0x1c5820;
    AdjustStepXps__FP4STEP(rdram, ctx, runtime);
}

void entry_1c582c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c582c inside AdjustStepXps__FP4STEP (0x1c57c8 - 0x1c5860)
    ctx->pc = 0x1c582c;
    AdjustStepXps__FP4STEP(rdram, ctx, runtime);
}

void entry_1c5840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5840 inside AdjustStepXps__FP4STEP (0x1c57c8 - 0x1c5860)
    ctx->pc = 0x1c5840;
    AdjustStepXps__FP4STEP(rdram, ctx, runtime);
}

void entry_1c58f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c58f8 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c58f8;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c58fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c58fc inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c58fc;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5904 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5904;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5914 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5914;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5928 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5928;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5958 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5958;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c597c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c597c inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c597c;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5994 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5994;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c59b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c59b0 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c59b0;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c59c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c59c0 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c59c0;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c59d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c59d8 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c59d8;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c59f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c59f0 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c59f0;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5a08 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5a08;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5a14 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5a14;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5a44 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5a44;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5a48 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5a48;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5ad8 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5ad8;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5ae4 inside entry_1c5860 (0x1c5860 - 0x1c5b70)
    ctx->pc = 0x1c5ae4;
    entry_1c5860(rdram, ctx, runtime);
}

void entry_1c5b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5b74 inside entry_1c5b70 (0x1c5b70 - 0x1c5bb8)
    ctx->pc = 0x1c5b74;
    entry_1c5b70(rdram, ctx, runtime);
}

void entry_1c5b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5b7c inside entry_1c5b70 (0x1c5b70 - 0x1c5bb8)
    ctx->pc = 0x1c5b7c;
    entry_1c5b70(rdram, ctx, runtime);
}

void entry_1c5b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5b88 inside entry_1c5b70 (0x1c5b70 - 0x1c5bb8)
    ctx->pc = 0x1c5b88;
    entry_1c5b70(rdram, ctx, runtime);
}

void entry_1c5b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5b94 inside entry_1c5b70 (0x1c5b70 - 0x1c5bb8)
    ctx->pc = 0x1c5b94;
    entry_1c5b70(rdram, ctx, runtime);
}

void entry_1c5bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5bb0 inside entry_1c5b70 (0x1c5b70 - 0x1c5bb8)
    ctx->pc = 0x1c5bb0;
    entry_1c5b70(rdram, ctx, runtime);
}

void entry_1c5c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5c9c inside entry_1c5c54 (0x1c5c54 - 0x1c5cd8)
    ctx->pc = 0x1c5c9c;
    entry_1c5c54(rdram, ctx, runtime);
}

void entry_1c5ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5ce0 inside entry_1c5cd8 (0x1c5cd8 - 0x1c5d3c)
    ctx->pc = 0x1c5ce0;
    entry_1c5cd8(rdram, ctx, runtime);
}

void entry_1c5d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5d40 inside entry_1c5d3c (0x1c5d3c - 0x1c5d58)
    ctx->pc = 0x1c5d40;
    entry_1c5d3c(rdram, ctx, runtime);
}

void entry_1c5d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5d44 inside entry_1c5d3c (0x1c5d3c - 0x1c5d58)
    ctx->pc = 0x1c5d44;
    entry_1c5d3c(rdram, ctx, runtime);
}

void entry_1c5f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5f88 inside GetActaddPositionGoal__FP6ACTADDfP6VECTORT2 (0x1c5f18 - 0x1c5fbc)
    ctx->pc = 0x1c5f88;
    GetActaddPositionGoal__FP6ACTADDfP6VECTORT2(rdram, ctx, runtime);
}

void entry_1c5fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5fe8 inside entry_1c5fbc (0x1c5fbc - 0x1c6028)
    ctx->pc = 0x1c5fe8;
    entry_1c5fbc(rdram, ctx, runtime);
}

void entry_1c5fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c5fec inside entry_1c5fbc (0x1c5fbc - 0x1c6028)
    ctx->pc = 0x1c5fec;
    entry_1c5fbc(rdram, ctx, runtime);
}

void entry_1c6000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6000 inside entry_1c5fbc (0x1c5fbc - 0x1c6028)
    ctx->pc = 0x1c6000;
    entry_1c5fbc(rdram, ctx, runtime);
}

void entry_1c6004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6004 inside entry_1c5fbc (0x1c5fbc - 0x1c6028)
    ctx->pc = 0x1c6004;
    entry_1c5fbc(rdram, ctx, runtime);
}

void entry_1c60e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c60e0 inside entry_1c60a0 (0x1c60a0 - 0x1c6114)
    ctx->pc = 0x1c60e0;
    entry_1c60a0(rdram, ctx, runtime);
}

void entry_1c61a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c61a0 inside entry_1c6124 (0x1c6124 - 0x1c61e0)
    ctx->pc = 0x1c61a0;
    entry_1c6124(rdram, ctx, runtime);
}

void entry_1c61a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c61a4 inside entry_1c6124 (0x1c6124 - 0x1c61e0)
    ctx->pc = 0x1c61a4;
    entry_1c6124(rdram, ctx, runtime);
}

void entry_1c61bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c61bc inside entry_1c6124 (0x1c6124 - 0x1c61e0)
    ctx->pc = 0x1c61bc;
    entry_1c6124(rdram, ctx, runtime);
}

void entry_1c6248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6248 inside SetJtJtcs__FP2JT4JTCS (0x1c61e0 - 0x1c626c)
    ctx->pc = 0x1c6248;
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime);
}

void entry_1c6270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6270 inside entry_1c626c (0x1c626c - 0x1c62f8)
    ctx->pc = 0x1c6270;
    entry_1c626c(rdram, ctx, runtime);
}

void entry_1c62bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c62bc inside entry_1c626c (0x1c626c - 0x1c62f8)
    ctx->pc = 0x1c62bc;
    entry_1c626c(rdram, ctx, runtime);
}

void entry_1c6484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6484 inside entry_1c6410 (0x1c6410 - 0x1c64dc)
    ctx->pc = 0x1c6484;
    entry_1c6410(rdram, ctx, runtime);
}

void entry_1c64c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c64c4 inside entry_1c6410 (0x1c6410 - 0x1c64dc)
    ctx->pc = 0x1c64c4;
    entry_1c6410(rdram, ctx, runtime);
}

void entry_1c650c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c650c inside entry_1c64dc (0x1c64dc - 0x1c6524)
    ctx->pc = 0x1c650c;
    entry_1c64dc(rdram, ctx, runtime);
}

void entry_1c6554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6554 inside entry_1c6524 (0x1c6524 - 0x1c656c)
    ctx->pc = 0x1c6554;
    entry_1c6524(rdram, ctx, runtime);
}

void entry_1c659c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c659c inside entry_1c6598 (0x1c6598 - 0x1c65c4)
    ctx->pc = 0x1c659c;
    entry_1c6598(rdram, ctx, runtime);
}

void entry_1c65ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c65ac inside entry_1c6598 (0x1c6598 - 0x1c65c4)
    ctx->pc = 0x1c65ac;
    entry_1c6598(rdram, ctx, runtime);
}

void entry_1c65f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c65f4 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c65f4;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6600 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6600;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6608 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6608;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6620 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6620;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6624 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6624;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c666c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c666c inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c666c;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6690 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6690;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6698 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c6698;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c669c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c669c inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c669c;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66a0 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66a0;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66bc inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66bc;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66c4 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66c4;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66d8 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66d8;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66dc inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66dc;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c66f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c66f4 inside entry_1c65f0 (0x1c65f0 - 0x1c6708)
    ctx->pc = 0x1c66f4;
    entry_1c65f0(rdram, ctx, runtime);
}

void entry_1c6738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6738 inside entry_1c6730 (0x1c6730 - 0x1c6748)
    ctx->pc = 0x1c6738;
    entry_1c6730(rdram, ctx, runtime);
}

void entry_1c6774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6774 inside entry_1c6770 (0x1c6770 - 0x1c67a0)
    ctx->pc = 0x1c6774;
    entry_1c6770(rdram, ctx, runtime);
}

void entry_1c67d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c67d8 inside entry_1c67a0 (0x1c67a0 - 0x1c6860)
    ctx->pc = 0x1c67d8;
    entry_1c67a0(rdram, ctx, runtime);
}

void entry_1c67f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c67f4 inside entry_1c67a0 (0x1c67a0 - 0x1c6860)
    ctx->pc = 0x1c67f4;
    entry_1c67a0(rdram, ctx, runtime);
}

void entry_1c6810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6810 inside entry_1c67a0 (0x1c67a0 - 0x1c6860)
    ctx->pc = 0x1c6810;
    entry_1c67a0(rdram, ctx, runtime);
}

void entry_1c681c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c681c inside entry_1c67a0 (0x1c67a0 - 0x1c6860)
    ctx->pc = 0x1c681c;
    entry_1c67a0(rdram, ctx, runtime);
}

void entry_1c68d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c68d8 inside entry_1c68d4 (0x1c68d4 - 0x1c68f4)
    ctx->pc = 0x1c68d8;
    entry_1c68d4(rdram, ctx, runtime);
}

void entry_1c68fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c68fc inside entry_1c68f4 (0x1c68f4 - 0x1c6914)
    ctx->pc = 0x1c68fc;
    entry_1c68f4(rdram, ctx, runtime);
}

void entry_1c6918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6918 inside entry_1c6914 (0x1c6914 - 0x1c6928)
    ctx->pc = 0x1c6918;
    entry_1c6914(rdram, ctx, runtime);
}

void entry_1c69ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c69ac inside entry_1c698c (0x1c698c - 0x1c69f4)
    ctx->pc = 0x1c69ac;
    entry_1c698c(rdram, ctx, runtime);
}

void entry_1c69e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c69e8 inside entry_1c698c (0x1c698c - 0x1c69f4)
    ctx->pc = 0x1c69e8;
    entry_1c698c(rdram, ctx, runtime);
}

void entry_1c69fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c69fc inside entry_1c69f4 (0x1c69f4 - 0x1c6a04)
    ctx->pc = 0x1c69fc;
    entry_1c69f4(rdram, ctx, runtime);
}

void entry_1c6a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6a14 inside entry_1c6a04 (0x1c6a04 - 0x1c6a90)
    ctx->pc = 0x1c6a14;
    entry_1c6a04(rdram, ctx, runtime);
}

void entry_1c6a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6a34 inside entry_1c6a04 (0x1c6a04 - 0x1c6a90)
    ctx->pc = 0x1c6a34;
    entry_1c6a04(rdram, ctx, runtime);
}

void entry_1c6a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6a64 inside entry_1c6a04 (0x1c6a04 - 0x1c6a90)
    ctx->pc = 0x1c6a64;
    entry_1c6a04(rdram, ctx, runtime);
}

void entry_1c6a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6a88 inside entry_1c6a04 (0x1c6a04 - 0x1c6a90)
    ctx->pc = 0x1c6a88;
    entry_1c6a04(rdram, ctx, runtime);
}

void entry_1c6b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6b98 inside entry_1c6b50 (0x1c6b50 - 0x1c6bc0)
    ctx->pc = 0x1c6b98;
    entry_1c6b50(rdram, ctx, runtime);
}

void entry_1c6c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6c4c inside entry_1c6c1c (0x1c6c1c - 0x1c6c74)
    ctx->pc = 0x1c6c4c;
    entry_1c6c1c(rdram, ctx, runtime);
}

void entry_1c6cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6cac inside entry_1c6c80 (0x1c6c80 - 0x1c6d00)
    ctx->pc = 0x1c6cac;
    entry_1c6c80(rdram, ctx, runtime);
}

void entry_1c6cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6cb0 inside entry_1c6c80 (0x1c6c80 - 0x1c6d00)
    ctx->pc = 0x1c6cb0;
    entry_1c6c80(rdram, ctx, runtime);
}

void entry_1c6cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6cb8 inside entry_1c6c80 (0x1c6c80 - 0x1c6d00)
    ctx->pc = 0x1c6cb8;
    entry_1c6c80(rdram, ctx, runtime);
}

void entry_1c6d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6d40 inside ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL (0x1c6d00 - 0x1c6d68)
    ctx->pc = 0x1c6d40;
    ChooseJtSweepTarget__FP2JTP2BLP6ASEGBL(rdram, ctx, runtime);
}

void entry_1c6dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6dbc inside entry_1c6d68 (0x1c6d68 - 0x1c6e08)
    ctx->pc = 0x1c6dbc;
    entry_1c6d68(rdram, ctx, runtime);
}

void entry_1c6dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6dc4 inside entry_1c6d68 (0x1c6d68 - 0x1c6e08)
    ctx->pc = 0x1c6dc4;
    entry_1c6d68(rdram, ctx, runtime);
}

void entry_1c6de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6de0 inside entry_1c6d68 (0x1c6d68 - 0x1c6e08)
    ctx->pc = 0x1c6de0;
    entry_1c6d68(rdram, ctx, runtime);
}

void entry_1c6e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6e44 inside entry_1c6e40 (0x1c6e40 - 0x1c6e58)
    ctx->pc = 0x1c6e44;
    entry_1c6e40(rdram, ctx, runtime);
}

void entry_1c6ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c6ff0 inside entry_1c6f70 (0x1c6f70 - 0x1c7054)
    ctx->pc = 0x1c6ff0;
    entry_1c6f70(rdram, ctx, runtime);
}

void entry_1c7020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7020 inside entry_1c6f70 (0x1c6f70 - 0x1c7054)
    ctx->pc = 0x1c7020;
    entry_1c6f70(rdram, ctx, runtime);
}

void entry_1c721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c721c inside entry_1c7214 (0x1c7214 - 0x1c722c)
    ctx->pc = 0x1c721c;
    entry_1c7214(rdram, ctx, runtime);
}

void entry_1c7230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7230 inside entry_1c722c (0x1c722c - 0x1c7250)
    ctx->pc = 0x1c7230;
    entry_1c722c(rdram, ctx, runtime);
}

void entry_1c7258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7258 inside entry_1c7250 (0x1c7250 - 0x1c7260)
    ctx->pc = 0x1c7258;
    entry_1c7250(rdram, ctx, runtime);
}

void entry_1c7310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7310 inside entry_1c7304 (0x1c7304 - 0x1c734c)
    ctx->pc = 0x1c7310;
    entry_1c7304(rdram, ctx, runtime);
}

void entry_1c7314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7314 inside entry_1c7304 (0x1c7304 - 0x1c734c)
    ctx->pc = 0x1c7314;
    entry_1c7304(rdram, ctx, runtime);
}

void entry_1c7368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7368 inside entry_1c734c (0x1c734c - 0x1c737c)
    ctx->pc = 0x1c7368;
    entry_1c734c(rdram, ctx, runtime);
}

void entry_1c73bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c73bc inside entry_1c73a8 (0x1c73a8 - 0x1c73e0)
    ctx->pc = 0x1c73bc;
    entry_1c73a8(rdram, ctx, runtime);
}

void entry_1c73e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c73e8 inside entry_1c73e0 (0x1c73e0 - 0x1c73fc)
    ctx->pc = 0x1c73e8;
    entry_1c73e0(rdram, ctx, runtime);
}

void entry_1c7400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7400 inside entry_1c73fc (0x1c73fc - 0x1c740c)
    ctx->pc = 0x1c7400;
    entry_1c73fc(rdram, ctx, runtime);
}

void entry_1c74ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c74ac inside entry_1c74a0 (0x1c74a0 - 0x1c74e8)
    ctx->pc = 0x1c74ac;
    entry_1c74a0(rdram, ctx, runtime);
}

void entry_1c74d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c74d4 inside entry_1c74a0 (0x1c74a0 - 0x1c74e8)
    ctx->pc = 0x1c74d4;
    entry_1c74a0(rdram, ctx, runtime);
}

void entry_1c7514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7514 inside entry_1c7510 (0x1c7510 - 0x1c7520)
    ctx->pc = 0x1c7514;
    entry_1c7510(rdram, ctx, runtime);
}

void entry_1c7550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7550 inside entry_1c7548 (0x1c7548 - 0x1c7560)
    ctx->pc = 0x1c7550;
    entry_1c7548(rdram, ctx, runtime);
}

void entry_1c7568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7568 inside entry_1c7560 (0x1c7560 - 0x1c7578)
    ctx->pc = 0x1c7568;
    entry_1c7560(rdram, ctx, runtime);
}

void entry_1c757c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c757c inside entry_1c7578 (0x1c7578 - 0x1c75b0)
    ctx->pc = 0x1c757c;
    entry_1c7578(rdram, ctx, runtime);
}

void entry_1c7678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7678 inside entry_1c7664 (0x1c7664 - 0x1c76ac)
    ctx->pc = 0x1c7678;
    entry_1c7664(rdram, ctx, runtime);
}

void entry_1c76fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c76fc inside entry_1c76ac (0x1c76ac - 0x1c77ec)
    ctx->pc = 0x1c76fc;
    entry_1c76ac(rdram, ctx, runtime);
}

void entry_1c7710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7710 inside entry_1c76ac (0x1c76ac - 0x1c77ec)
    ctx->pc = 0x1c7710;
    entry_1c76ac(rdram, ctx, runtime);
}

void entry_1c7790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7790 inside entry_1c76ac (0x1c76ac - 0x1c77ec)
    ctx->pc = 0x1c7790;
    entry_1c76ac(rdram, ctx, runtime);
}

void entry_1c77a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c77a4 inside entry_1c76ac (0x1c76ac - 0x1c77ec)
    ctx->pc = 0x1c77a4;
    entry_1c76ac(rdram, ctx, runtime);
}

void entry_1c77a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c77a8 inside entry_1c76ac (0x1c76ac - 0x1c77ec)
    ctx->pc = 0x1c77a8;
    entry_1c76ac(rdram, ctx, runtime);
}

void entry_1c7838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7838 inside entry_1c7828 (0x1c7828 - 0x1c787c)
    ctx->pc = 0x1c7838;
    entry_1c7828(rdram, ctx, runtime);
}

void entry_1c78d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c78d4 inside entry_1c78cc (0x1c78cc - 0x1c78e0)
    ctx->pc = 0x1c78d4;
    entry_1c78cc(rdram, ctx, runtime);
}

void entry_1c78d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c78d8 inside entry_1c78cc (0x1c78cc - 0x1c78e0)
    ctx->pc = 0x1c78d8;
    entry_1c78cc(rdram, ctx, runtime);
}

void entry_1c78e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c78e8 inside entry_1c78e0 (0x1c78e0 - 0x1c799c)
    ctx->pc = 0x1c78e8;
    entry_1c78e0(rdram, ctx, runtime);
}

void entry_1c7924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7924 inside entry_1c78e0 (0x1c78e0 - 0x1c799c)
    ctx->pc = 0x1c7924;
    entry_1c78e0(rdram, ctx, runtime);
}

void entry_1c792c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c792c inside entry_1c78e0 (0x1c78e0 - 0x1c799c)
    ctx->pc = 0x1c792c;
    entry_1c78e0(rdram, ctx, runtime);
}

void entry_1c7974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7974 inside entry_1c78e0 (0x1c78e0 - 0x1c799c)
    ctx->pc = 0x1c7974;
    entry_1c78e0(rdram, ctx, runtime);
}

void entry_1c7988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7988 inside entry_1c78e0 (0x1c78e0 - 0x1c799c)
    ctx->pc = 0x1c7988;
    entry_1c78e0(rdram, ctx, runtime);
}

void entry_1c7a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7a34 inside entry_1c7a2c (0x1c7a2c - 0x1c7a3c)
    ctx->pc = 0x1c7a34;
    entry_1c7a2c(rdram, ctx, runtime);
}

void entry_1c7a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7a40 inside entry_1c7a3c (0x1c7a3c - 0x1c7a60)
    ctx->pc = 0x1c7a40;
    entry_1c7a3c(rdram, ctx, runtime);
}

void entry_1c7ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7ac8 inside entry_1c7ac0 (0x1c7ac0 - 0x1c7ae0)
    ctx->pc = 0x1c7ac8;
    entry_1c7ac0(rdram, ctx, runtime);
}

void entry_1c7acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7acc inside entry_1c7ac0 (0x1c7ac0 - 0x1c7ae0)
    ctx->pc = 0x1c7acc;
    entry_1c7ac0(rdram, ctx, runtime);
}

void entry_1c7b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7b34 inside entry_1c7b2c (0x1c7b2c - 0x1c7b48)
    ctx->pc = 0x1c7b34;
    entry_1c7b2c(rdram, ctx, runtime);
}

void entry_1c7b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7b4c inside entry_1c7b48 (0x1c7b48 - 0x1c7b60)
    ctx->pc = 0x1c7b4c;
    entry_1c7b48(rdram, ctx, runtime);
}

void entry_1c7bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7bb0 inside FUN_001c7b60 (0x1c7b60 - 0x1c7bb8)
    ctx->pc = 0x1c7bb0;
    FUN_001c7b60(rdram, ctx, runtime);
}

void entry_1c7bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7bbc inside entry_1c7bb8 (0x1c7bb8 - 0x1c7bc8)
    ctx->pc = 0x1c7bbc;
    entry_1c7bb8(rdram, ctx, runtime);
}

void entry_1c7bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7bdc inside entry_1c7bc8 (0x1c7bc8 - 0x1c7be8)
    ctx->pc = 0x1c7bdc;
    entry_1c7bc8(rdram, ctx, runtime);
}

void entry_1c7be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7be0 inside entry_1c7bc8 (0x1c7bc8 - 0x1c7be8)
    ctx->pc = 0x1c7be0;
    entry_1c7bc8(rdram, ctx, runtime);
}

void entry_1c7c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7c98 inside entry_1c7c2c (0x1c7c2c - 0x1c7ca4)
    ctx->pc = 0x1c7c98;
    entry_1c7c2c(rdram, ctx, runtime);
}

void entry_1c7c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7c9c inside entry_1c7c2c (0x1c7c2c - 0x1c7ca4)
    ctx->pc = 0x1c7c9c;
    entry_1c7c2c(rdram, ctx, runtime);
}

void entry_1c7cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7cf0 inside entry_1c7cec (0x1c7cec - 0x1c7d18)
    ctx->pc = 0x1c7cf0;
    entry_1c7cec(rdram, ctx, runtime);
}

void entry_1c7d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7d84 inside entry_1c7d7c (0x1c7d7c - 0x1c7db4)
    ctx->pc = 0x1c7d84;
    entry_1c7d7c(rdram, ctx, runtime);
}

void entry_1c7d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7d98 inside entry_1c7d7c (0x1c7d7c - 0x1c7db4)
    ctx->pc = 0x1c7d98;
    entry_1c7d7c(rdram, ctx, runtime);
}

void entry_1c7dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7dd4 inside entry_1c7db4 (0x1c7db4 - 0x1c7ddc)
    ctx->pc = 0x1c7dd4;
    entry_1c7db4(rdram, ctx, runtime);
}

void entry_1c7df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7df4 inside entry_1c7ddc (0x1c7ddc - 0x1c7e00)
    ctx->pc = 0x1c7df4;
    entry_1c7ddc(rdram, ctx, runtime);
}

void entry_1c7e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7e04 inside entry_1c7e00 (0x1c7e00 - 0x1c7e18)
    ctx->pc = 0x1c7e04;
    entry_1c7e00(rdram, ctx, runtime);
}

void entry_1c7eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7eac inside entry_1c7e88 (0x1c7e88 - 0x1c7ed0)
    ctx->pc = 0x1c7eac;
    entry_1c7e88(rdram, ctx, runtime);
}

void entry_1c7eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7eb0 inside entry_1c7e88 (0x1c7e88 - 0x1c7ed0)
    ctx->pc = 0x1c7eb0;
    entry_1c7e88(rdram, ctx, runtime);
}

void entry_1c7ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7ebc inside entry_1c7e88 (0x1c7e88 - 0x1c7ed0)
    ctx->pc = 0x1c7ebc;
    entry_1c7e88(rdram, ctx, runtime);
}

void entry_1c7f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7f50 inside entry_1c7f14 (0x1c7f14 - 0x1c7f78)
    ctx->pc = 0x1c7f50;
    entry_1c7f14(rdram, ctx, runtime);
}

void entry_1c7f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7f64 inside entry_1c7f14 (0x1c7f14 - 0x1c7f78)
    ctx->pc = 0x1c7f64;
    entry_1c7f14(rdram, ctx, runtime);
}

void entry_1c7fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c7fe8 inside entry_1c7f88 (0x1c7f88 - 0x1c7ff0)
    ctx->pc = 0x1c7fe8;
    entry_1c7f88(rdram, ctx, runtime);
}

void entry_1c8080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8080 inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c8080;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c8084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8084 inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c8084;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c8088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8088 inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c8088;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c80cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c80cc inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c80cc;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c80dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c80dc inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c80dc;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c812c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c812c inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c812c;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c81c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c81c0 inside entry_1c8030 (0x1c8030 - 0x1c81c8)
    ctx->pc = 0x1c81c0;
    entry_1c8030(rdram, ctx, runtime);
}

void entry_1c820c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c820c inside entry_1c81c8 (0x1c81c8 - 0x1c8244)
    ctx->pc = 0x1c820c;
    entry_1c81c8(rdram, ctx, runtime);
}

void entry_1c8214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8214 inside entry_1c81c8 (0x1c81c8 - 0x1c8244)
    ctx->pc = 0x1c8214;
    entry_1c81c8(rdram, ctx, runtime);
}

void entry_1c824c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c824c inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c824c;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c8268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8268 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c8268;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c8294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8294 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c8294;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c82a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c82a4 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c82a4;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c82b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c82b0 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c82b0;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c82b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c82b4 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c82b4;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c82cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c82cc inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c82cc;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c8310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8310 inside entry_1c8244 (0x1c8244 - 0x1c8328)
    ctx->pc = 0x1c8310;
    entry_1c8244(rdram, ctx, runtime);
}

void entry_1c8330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8330 inside entry_1c8328 (0x1c8328 - 0x1c8338)
    ctx->pc = 0x1c8330;
    entry_1c8328(rdram, ctx, runtime);
}

void entry_1c8394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8394 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c8394;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c83d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c83d0 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c83d0;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c83f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c83f0 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c83f0;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c83f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c83f8 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c83f8;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c83fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c83fc inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c83fc;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c8400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8400 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c8400;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c8404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8404 inside entry_1c8384 (0x1c8384 - 0x1c8418)
    ctx->pc = 0x1c8404;
    entry_1c8384(rdram, ctx, runtime);
}

void entry_1c8494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8494 inside entry_1c8448 (0x1c8448 - 0x1c84c0)
    ctx->pc = 0x1c8494;
    entry_1c8448(rdram, ctx, runtime);
}

void entry_1c849c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c849c inside entry_1c8448 (0x1c8448 - 0x1c84c0)
    ctx->pc = 0x1c849c;
    entry_1c8448(rdram, ctx, runtime);
}

void entry_1c84a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c84a8 inside entry_1c8448 (0x1c8448 - 0x1c84c0)
    ctx->pc = 0x1c84a8;
    entry_1c8448(rdram, ctx, runtime);
}

void entry_1c84b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c84b4 inside entry_1c8448 (0x1c8448 - 0x1c84c0)
    ctx->pc = 0x1c84b4;
    entry_1c8448(rdram, ctx, runtime);
}

void entry_1c84dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c84dc inside FReachedStepguardGoal__FP9STEPGUARD (0x1c84c0 - 0x1c84e8)
    ctx->pc = 0x1c84dc;
    FReachedStepguardGoal__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1c8540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8540 inside FFilterStepguardJump__FP9STEPGUARDP2SO (0x1c84e8 - 0x1c8548)
    ctx->pc = 0x1c8540;
    FFilterStepguardJump__FP9STEPGUARDP2SO(rdram, ctx, runtime);
}

void entry_1c857c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c857c inside entry_1c8570 (0x1c8570 - 0x1c8590)
    ctx->pc = 0x1c857c;
    entry_1c8570(rdram, ctx, runtime);
}

void entry_1c8580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8580 inside entry_1c8570 (0x1c8570 - 0x1c8590)
    ctx->pc = 0x1c8580;
    entry_1c8570(rdram, ctx, runtime);
}

void entry_1c8600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8600 inside MoveStepguardToGoal__FP9STEPGUARD (0x1c8590 - 0x1c86a0)
    ctx->pc = 0x1c8600;
    MoveStepguardToGoal__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1c8688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8688 inside MoveStepguardToGoal__FP9STEPGUARD (0x1c8590 - 0x1c86a0)
    ctx->pc = 0x1c8688;
    MoveStepguardToGoal__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1c868c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c868c inside MoveStepguardToGoal__FP9STEPGUARD (0x1c8590 - 0x1c86a0)
    ctx->pc = 0x1c868c;
    MoveStepguardToGoal__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1c86a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c86a8 inside entry_1c86a0 (0x1c86a0 - 0x1c873c)
    ctx->pc = 0x1c86a8;
    entry_1c86a0(rdram, ctx, runtime);
}

void entry_1c86b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c86b0 inside entry_1c86a0 (0x1c86a0 - 0x1c873c)
    ctx->pc = 0x1c86b0;
    entry_1c86a0(rdram, ctx, runtime);
}

void entry_1c86e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c86e8 inside entry_1c86a0 (0x1c86a0 - 0x1c873c)
    ctx->pc = 0x1c86e8;
    entry_1c86a0(rdram, ctx, runtime);
}

void entry_1c8778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8778 inside entry_1c873c (0x1c873c - 0x1c8788)
    ctx->pc = 0x1c8778;
    entry_1c873c(rdram, ctx, runtime);
}

void entry_1c884c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c884c inside entry_1c8810 (0x1c8810 - 0x1c8874)
    ctx->pc = 0x1c884c;
    entry_1c8810(rdram, ctx, runtime);
}

void entry_1c886c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c886c inside entry_1c8810 (0x1c8810 - 0x1c8874)
    ctx->pc = 0x1c886c;
    entry_1c8810(rdram, ctx, runtime);
}

void entry_1c8880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8880 inside entry_1c8874 (0x1c8874 - 0x1c88a0)
    ctx->pc = 0x1c8880;
    entry_1c8874(rdram, ctx, runtime);
}

void entry_1c88a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c88a4 inside entry_1c88a0 (0x1c88a0 - 0x1c8920)
    ctx->pc = 0x1c88a4;
    entry_1c88a0(rdram, ctx, runtime);
}

void entry_1c88c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c88c8 inside entry_1c88a0 (0x1c88a0 - 0x1c8920)
    ctx->pc = 0x1c88c8;
    entry_1c88a0(rdram, ctx, runtime);
}

void entry_1c88cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c88cc inside entry_1c88a0 (0x1c88a0 - 0x1c8920)
    ctx->pc = 0x1c88cc;
    entry_1c88a0(rdram, ctx, runtime);
}

void entry_1c88e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c88e4 inside entry_1c88a0 (0x1c88a0 - 0x1c8920)
    ctx->pc = 0x1c88e4;
    entry_1c88a0(rdram, ctx, runtime);
}

void entry_1c8960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8960 inside entry_1c8940 (0x1c8940 - 0x1c8a3c)
    ctx->pc = 0x1c8960;
    entry_1c8940(rdram, ctx, runtime);
}

void entry_1c89a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c89a4 inside entry_1c8940 (0x1c8940 - 0x1c8a3c)
    ctx->pc = 0x1c89a4;
    entry_1c8940(rdram, ctx, runtime);
}

void entry_1c89b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c89b8 inside entry_1c8940 (0x1c8940 - 0x1c8a3c)
    ctx->pc = 0x1c89b8;
    entry_1c8940(rdram, ctx, runtime);
}

void entry_1c89dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c89dc inside entry_1c8940 (0x1c8940 - 0x1c8a3c)
    ctx->pc = 0x1c89dc;
    entry_1c8940(rdram, ctx, runtime);
}

void entry_1c89f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c89f4 inside entry_1c8940 (0x1c8940 - 0x1c8a3c)
    ctx->pc = 0x1c89f4;
    entry_1c8940(rdram, ctx, runtime);
}

void entry_1c8a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8a44 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8a44;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8a48 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8a48;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8a60 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8a60;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8ac4 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8ac4;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8b0c inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8b0c;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8b20 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8b20;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8b6c inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8b6c;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8b80 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8b80;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8ba4 inside entry_1c8a3c (0x1c8a3c - 0x1c8bac)
    ctx->pc = 0x1c8ba4;
    entry_1c8a3c(rdram, ctx, runtime);
}

void entry_1c8c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8c9c inside entry_1c8c64 (0x1c8c64 - 0x1c8cb8)
    ctx->pc = 0x1c8c9c;
    entry_1c8c64(rdram, ctx, runtime);
}

void entry_1c8cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8cc0 inside entry_1c8cb8 (0x1c8cb8 - 0x1c8ccc)
    ctx->pc = 0x1c8cc0;
    entry_1c8cb8(rdram, ctx, runtime);
}

void entry_1c8d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8d08 inside entry_1c8cf8 (0x1c8cf8 - 0x1c8d18)
    ctx->pc = 0x1c8d08;
    entry_1c8cf8(rdram, ctx, runtime);
}

void entry_1c8d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8d0c inside entry_1c8cf8 (0x1c8cf8 - 0x1c8d18)
    ctx->pc = 0x1c8d0c;
    entry_1c8cf8(rdram, ctx, runtime);
}

void entry_1c8d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8d34 inside entry_1c8d30 (0x1c8d30 - 0x1c8d40)
    ctx->pc = 0x1c8d34;
    entry_1c8d30(rdram, ctx, runtime);
}

void entry_1c8d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8d6c inside FUN_001c8d40 (0x1c8d40 - 0x1c8d78)
    ctx->pc = 0x1c8d6c;
    FUN_001c8d40(rdram, ctx, runtime);
}

void entry_1c8e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8e04 inside entry_1c8de8 (0x1c8de8 - 0x1c8e28)
    ctx->pc = 0x1c8e04;
    entry_1c8de8(rdram, ctx, runtime);
}

void entry_1c8e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8e14 inside entry_1c8de8 (0x1c8de8 - 0x1c8e28)
    ctx->pc = 0x1c8e14;
    entry_1c8de8(rdram, ctx, runtime);
}

void entry_1c8e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8e18 inside entry_1c8de8 (0x1c8de8 - 0x1c8e28)
    ctx->pc = 0x1c8e18;
    entry_1c8de8(rdram, ctx, runtime);
}

void entry_1c8f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8f10 inside entry_1c8f0c (0x1c8f0c - 0x1c8f20)
    ctx->pc = 0x1c8f10;
    entry_1c8f0c(rdram, ctx, runtime);
}

void entry_1c8fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c8fec inside SetStepguardSgsExternal__FP9STEPGUARD3SGSP4ASEG (0x1c8fd0 - 0x1c8ffc)
    ctx->pc = 0x1c8fec;
    SetStepguardSgsExternal__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime);
}

void entry_1c9044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9044 inside OnStepguardExitingSgs__FP9STEPGUARD3SGS (0x1c9008 - 0x1c907c)
    ctx->pc = 0x1c9044;
    OnStepguardExitingSgs__FP9STEPGUARD3SGS(rdram, ctx, runtime);
}

void entry_1c9068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9068 inside OnStepguardExitingSgs__FP9STEPGUARD3SGS (0x1c9008 - 0x1c907c)
    ctx->pc = 0x1c9068;
    OnStepguardExitingSgs__FP9STEPGUARD3SGS(rdram, ctx, runtime);
}

void entry_1c908c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c908c inside entry_1c907c (0x1c907c - 0x1c90e0)
    ctx->pc = 0x1c908c;
    entry_1c907c(rdram, ctx, runtime);
}

void entry_1c9104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9104 inside entry_1c90fc (0x1c90fc - 0x1c9114)
    ctx->pc = 0x1c9104;
    entry_1c90fc(rdram, ctx, runtime);
}

void entry_1c9180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9180 inside entry_1c916c (0x1c916c - 0x1c9194)
    ctx->pc = 0x1c9180;
    entry_1c916c(rdram, ctx, runtime);
}

void entry_1c91ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c91ac inside entry_1c9194 (0x1c9194 - 0x1c91c8)
    ctx->pc = 0x1c91ac;
    entry_1c9194(rdram, ctx, runtime);
}

void entry_1c9200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9200 inside OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG (0x1c91c8 - 0x1c9230)
    ctx->pc = 0x1c9200;
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime);
}

void entry_1c9210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9210 inside OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG (0x1c91c8 - 0x1c9230)
    ctx->pc = 0x1c9210;
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime);
}

void entry_1c9224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9224 inside OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG (0x1c91c8 - 0x1c9230)
    ctx->pc = 0x1c9224;
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime);
}

void entry_1c9294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9294 inside entry_1c928c (0x1c928c - 0x1c92a0)
    ctx->pc = 0x1c9294;
    entry_1c928c(rdram, ctx, runtime);
}

void entry_1c9324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9324 inside entry_1c9308 (0x1c9308 - 0x1c9348)
    ctx->pc = 0x1c9324;
    entry_1c9308(rdram, ctx, runtime);
}

void entry_1c93a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c93a8 inside entry_1c939c (0x1c939c - 0x1c93c0)
    ctx->pc = 0x1c93a8;
    entry_1c939c(rdram, ctx, runtime);
}

void entry_1c93d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c93d0 inside entry_1c93c0 (0x1c93c0 - 0x1c93d8)
    ctx->pc = 0x1c93d0;
    entry_1c93c0(rdram, ctx, runtime);
}

void entry_1c93dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c93dc inside entry_1c93d8 (0x1c93d8 - 0x1c93e4)
    ctx->pc = 0x1c93dc;
    entry_1c93d8(rdram, ctx, runtime);
}

void entry_1c9408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9408 inside entry_1c9400 (0x1c9400 - 0x1c9428)
    ctx->pc = 0x1c9408;
    entry_1c9400(rdram, ctx, runtime);
}

void entry_1c9420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9420 inside entry_1c9400 (0x1c9400 - 0x1c9428)
    ctx->pc = 0x1c9420;
    entry_1c9400(rdram, ctx, runtime);
}

void entry_1c942c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c942c inside entry_1c9428 (0x1c9428 - 0x1c9468)
    ctx->pc = 0x1c942c;
    entry_1c9428(rdram, ctx, runtime);
}

void entry_1c948c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c948c inside entry_1c9468 (0x1c9468 - 0x1c94d4)
    ctx->pc = 0x1c948c;
    entry_1c9468(rdram, ctx, runtime);
}

void entry_1c94d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c94d8 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c94d8;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c94e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c94e4 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c94e4;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c94f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c94f8 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c94f8;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9510 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c9510;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9530 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c9530;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9548 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c9548;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9564 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c9564;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9590 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c9590;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95a8 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95a8;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95b4 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95b4;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95b8 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95b8;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95c4 inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95c4;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95dc inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95dc;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c95fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c95fc inside entry_1c94d4 (0x1c94d4 - 0x1c9618)
    ctx->pc = 0x1c95fc;
    entry_1c94d4(rdram, ctx, runtime);
}

void entry_1c9620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9620 inside entry_1c9618 (0x1c9618 - 0x1c9648)
    ctx->pc = 0x1c9620;
    entry_1c9618(rdram, ctx, runtime);
}

void entry_1c964c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c964c inside entry_1c9648 (0x1c9648 - 0x1c9684)
    ctx->pc = 0x1c964c;
    entry_1c9648(rdram, ctx, runtime);
}

void entry_1c9650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9650 inside entry_1c9648 (0x1c9648 - 0x1c9684)
    ctx->pc = 0x1c9650;
    entry_1c9648(rdram, ctx, runtime);
}

void entry_1c9698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9698 inside entry_1c9694 (0x1c9694 - 0x1c96b8)
    ctx->pc = 0x1c9698;
    entry_1c9694(rdram, ctx, runtime);
}

void entry_1c96cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c96cc inside SggsGetStepguard__FP9STEPGUARD (0x1c96b8 - 0x1c96d8)
    ctx->pc = 0x1c96cc;
    SggsGetStepguard__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1c9734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9734 inside entry_1c972c (0x1c972c - 0x1c9744)
    ctx->pc = 0x1c9734;
    entry_1c972c(rdram, ctx, runtime);
}

void entry_1c973c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c973c inside entry_1c972c (0x1c972c - 0x1c9744)
    ctx->pc = 0x1c973c;
    entry_1c972c(rdram, ctx, runtime);
}

void entry_1c9780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9780 inside entry_1c9744 (0x1c9744 - 0x1c9804)
    ctx->pc = 0x1c9780;
    entry_1c9744(rdram, ctx, runtime);
}

void entry_1c97a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c97a0 inside entry_1c9744 (0x1c9744 - 0x1c9804)
    ctx->pc = 0x1c97a0;
    entry_1c9744(rdram, ctx, runtime);
}

void entry_1c9840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9840 inside entry_1c983c (0x1c983c - 0x1c985c)
    ctx->pc = 0x1c9840;
    entry_1c983c(rdram, ctx, runtime);
}

void entry_1c98d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c98d0 inside entry_1c985c (0x1c985c - 0x1c9948)
    ctx->pc = 0x1c98d0;
    entry_1c985c(rdram, ctx, runtime);
}

void entry_1c98d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c98d4 inside entry_1c985c (0x1c985c - 0x1c9948)
    ctx->pc = 0x1c98d4;
    entry_1c985c(rdram, ctx, runtime);
}

void entry_1c9924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9924 inside entry_1c985c (0x1c985c - 0x1c9948)
    ctx->pc = 0x1c9924;
    entry_1c985c(rdram, ctx, runtime);
}

void entry_1c9930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9930 inside entry_1c985c (0x1c985c - 0x1c9948)
    ctx->pc = 0x1c9930;
    entry_1c985c(rdram, ctx, runtime);
}

void entry_1c9934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9934 inside entry_1c985c (0x1c985c - 0x1c9948)
    ctx->pc = 0x1c9934;
    entry_1c985c(rdram, ctx, runtime);
}

void entry_1c9970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9970 inside entry_1c996c (0x1c996c - 0x1c9990)
    ctx->pc = 0x1c9970;
    entry_1c996c(rdram, ctx, runtime);
}

void entry_1c99f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c99f0 inside entry_1c99d0 (0x1c99d0 - 0x1c9a2c)
    ctx->pc = 0x1c99f0;
    entry_1c99d0(rdram, ctx, runtime);
}

void entry_1c9a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9a10 inside entry_1c99d0 (0x1c99d0 - 0x1c9a2c)
    ctx->pc = 0x1c9a10;
    entry_1c99d0(rdram, ctx, runtime);
}

void entry_1c9a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9a14 inside entry_1c99d0 (0x1c99d0 - 0x1c9a2c)
    ctx->pc = 0x1c9a14;
    entry_1c99d0(rdram, ctx, runtime);
}

void entry_1c9a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9a30 inside entry_1c9a2c (0x1c9a2c - 0x1c9a48)
    ctx->pc = 0x1c9a30;
    entry_1c9a2c(rdram, ctx, runtime);
}

void entry_1c9aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9aa4 inside entry_1c9a9c (0x1c9a9c - 0x1c9ae8)
    ctx->pc = 0x1c9aa4;
    entry_1c9a9c(rdram, ctx, runtime);
}

void entry_1c9abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9abc inside entry_1c9a9c (0x1c9a9c - 0x1c9ae8)
    ctx->pc = 0x1c9abc;
    entry_1c9a9c(rdram, ctx, runtime);
}

void entry_1c9ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9ad0 inside entry_1c9a9c (0x1c9a9c - 0x1c9ae8)
    ctx->pc = 0x1c9ad0;
    entry_1c9a9c(rdram, ctx, runtime);
}

void entry_1c9c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9c68 inside entry_1c9c40 (0x1c9c40 - 0x1c9c70)
    ctx->pc = 0x1c9c68;
    entry_1c9c40(rdram, ctx, runtime);
}

void entry_1c9ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9ccc inside entry_1c9c70 (0x1c9c70 - 0x1c9cf8)
    ctx->pc = 0x1c9ccc;
    entry_1c9c70(rdram, ctx, runtime);
}

void entry_1c9cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9cdc inside entry_1c9c70 (0x1c9c70 - 0x1c9cf8)
    ctx->pc = 0x1c9cdc;
    entry_1c9c70(rdram, ctx, runtime);
}

void entry_1c9d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9d94 inside FUN_001c9d50 (0x1c9d50 - 0x1c9dc0)
    ctx->pc = 0x1c9d94;
    FUN_001c9d50(rdram, ctx, runtime);
}

void entry_1c9dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9dd4 inside entry_1c9dc0 (0x1c9dc0 - 0x1c9de0)
    ctx->pc = 0x1c9dd4;
    entry_1c9dc0(rdram, ctx, runtime);
}

void entry_1c9e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9e64 inside entry_1c9e20 (0x1c9e20 - 0x1c9e78)
    ctx->pc = 0x1c9e64;
    entry_1c9e20(rdram, ctx, runtime);
}

void entry_1c9eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9eec inside entry_1c9eac (0x1c9eac - 0x1c9f1c)
    ctx->pc = 0x1c9eec;
    entry_1c9eac(rdram, ctx, runtime);
}

void entry_1c9f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9f10 inside entry_1c9eac (0x1c9eac - 0x1c9f1c)
    ctx->pc = 0x1c9f10;
    entry_1c9eac(rdram, ctx, runtime);
}

void entry_1c9f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9f14 inside entry_1c9eac (0x1c9eac - 0x1c9f1c)
    ctx->pc = 0x1c9f14;
    entry_1c9eac(rdram, ctx, runtime);
}

void entry_1c9f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9f68 inside entry_1c9f60 (0x1c9f60 - 0x1c9ff4)
    ctx->pc = 0x1c9f68;
    entry_1c9f60(rdram, ctx, runtime);
}

void entry_1c9fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1c9fc8 inside entry_1c9f60 (0x1c9f60 - 0x1c9ff4)
    ctx->pc = 0x1c9fc8;
    entry_1c9f60(rdram, ctx, runtime);
}

void entry_1ca1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca1c4 inside entry_1ca1b8 (0x1ca1b8 - 0x1ca1e0)
    ctx->pc = 0x1ca1c4;
    entry_1ca1b8(rdram, ctx, runtime);
}

void entry_1ca1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca1d8 inside entry_1ca1b8 (0x1ca1b8 - 0x1ca1e0)
    ctx->pc = 0x1ca1d8;
    entry_1ca1b8(rdram, ctx, runtime);
}

void entry_1ca254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca254 inside entry_1ca24c (0x1ca24c - 0x1ca25c)
    ctx->pc = 0x1ca254;
    entry_1ca24c(rdram, ctx, runtime);
}

void entry_1ca340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca340 inside entry_1ca32c (0x1ca32c - 0x1ca358)
    ctx->pc = 0x1ca340;
    entry_1ca32c(rdram, ctx, runtime);
}

void entry_1ca3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca3a4 inside entry_1ca358 (0x1ca358 - 0x1ca3f8)
    ctx->pc = 0x1ca3a4;
    entry_1ca358(rdram, ctx, runtime);
}

void entry_1ca3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca3a8 inside entry_1ca358 (0x1ca358 - 0x1ca3f8)
    ctx->pc = 0x1ca3a8;
    entry_1ca358(rdram, ctx, runtime);
}

void entry_1ca3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca3b4 inside entry_1ca358 (0x1ca358 - 0x1ca3f8)
    ctx->pc = 0x1ca3b4;
    entry_1ca358(rdram, ctx, runtime);
}

void entry_1ca3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca3d4 inside entry_1ca358 (0x1ca358 - 0x1ca3f8)
    ctx->pc = 0x1ca3d4;
    entry_1ca358(rdram, ctx, runtime);
}

void entry_1ca428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca428 inside entry_1ca3f8 (0x1ca3f8 - 0x1ca460)
    ctx->pc = 0x1ca428;
    entry_1ca3f8(rdram, ctx, runtime);
}

void entry_1ca42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca42c inside entry_1ca3f8 (0x1ca3f8 - 0x1ca460)
    ctx->pc = 0x1ca42c;
    entry_1ca3f8(rdram, ctx, runtime);
}

void entry_1ca430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca430 inside entry_1ca3f8 (0x1ca3f8 - 0x1ca460)
    ctx->pc = 0x1ca430;
    entry_1ca3f8(rdram, ctx, runtime);
}

void entry_1ca434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca434 inside entry_1ca3f8 (0x1ca3f8 - 0x1ca460)
    ctx->pc = 0x1ca434;
    entry_1ca3f8(rdram, ctx, runtime);
}

void entry_1ca4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca4c8 inside entry_1ca4bc (0x1ca4bc - 0x1ca500)
    ctx->pc = 0x1ca4c8;
    entry_1ca4bc(rdram, ctx, runtime);
}

void entry_1ca55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca55c inside entry_1ca510 (0x1ca510 - 0x1ca5b4)
    ctx->pc = 0x1ca55c;
    entry_1ca510(rdram, ctx, runtime);
}

void entry_1ca56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca56c inside entry_1ca510 (0x1ca510 - 0x1ca5b4)
    ctx->pc = 0x1ca56c;
    entry_1ca510(rdram, ctx, runtime);
}

void entry_1ca5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca5c4 inside entry_1ca5b4 (0x1ca5b4 - 0x1ca5e0)
    ctx->pc = 0x1ca5c4;
    entry_1ca5b4(rdram, ctx, runtime);
}

void entry_1ca640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca640 inside entry_1ca630 (0x1ca630 - 0x1ca658)
    ctx->pc = 0x1ca640;
    entry_1ca630(rdram, ctx, runtime);
}

void entry_1ca6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca6a4 inside entry_1ca680 (0x1ca680 - 0x1ca6b0)
    ctx->pc = 0x1ca6a4;
    entry_1ca680(rdram, ctx, runtime);
}

void entry_1ca6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca6b4 inside entry_1ca6b0 (0x1ca6b0 - 0x1ca6d0)
    ctx->pc = 0x1ca6b4;
    entry_1ca6b0(rdram, ctx, runtime);
}

void entry_1ca704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca704 inside entry_1ca6f0 (0x1ca6f0 - 0x1ca720)
    ctx->pc = 0x1ca704;
    entry_1ca6f0(rdram, ctx, runtime);
}

void entry_1ca708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca708 inside entry_1ca6f0 (0x1ca6f0 - 0x1ca720)
    ctx->pc = 0x1ca708;
    entry_1ca6f0(rdram, ctx, runtime);
}

void entry_1ca74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca74c inside UseStepguardDeathAnimation__FP9STEPGUARDi3OID (0x1ca720 - 0x1ca758)
    ctx->pc = 0x1ca74c;
    UseStepguardDeathAnimation__FP9STEPGUARDi3OID(rdram, ctx, runtime);
}

void entry_1ca7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca7a8 inside entry_1ca7a4 (0x1ca7a4 - 0x1ca7c0)
    ctx->pc = 0x1ca7a8;
    entry_1ca7a4(rdram, ctx, runtime);
}

void entry_1ca7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca7e8 inside LoadStepguardAnimations__FP9STEPGUARD (0x1ca7c0 - 0x1ca7fc)
    ctx->pc = 0x1ca7e8;
    LoadStepguardAnimations__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1ca808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca808 inside entry_1ca7fc (0x1ca7fc - 0x1ca83c)
    ctx->pc = 0x1ca808;
    entry_1ca7fc(rdram, ctx, runtime);
}

void entry_1ca828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca828 inside entry_1ca7fc (0x1ca7fc - 0x1ca83c)
    ctx->pc = 0x1ca828;
    entry_1ca7fc(rdram, ctx, runtime);
}

void entry_1ca848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca848 inside entry_1ca83c (0x1ca83c - 0x1ca878)
    ctx->pc = 0x1ca848;
    entry_1ca83c(rdram, ctx, runtime);
}

void entry_1ca858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca858 inside entry_1ca83c (0x1ca83c - 0x1ca878)
    ctx->pc = 0x1ca858;
    entry_1ca83c(rdram, ctx, runtime);
}

void entry_1ca8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca8d0 inside entry_1ca8c0 (0x1ca8c0 - 0x1ca8e8)
    ctx->pc = 0x1ca8d0;
    entry_1ca8c0(rdram, ctx, runtime);
}

void entry_1ca910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca910 inside LoadStepguardPhys__FP9STEPGUARD (0x1ca8e8 - 0x1ca928)
    ctx->pc = 0x1ca910;
    LoadStepguardPhys__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1ca98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca98c inside AddStepguardEffect__FP9STEPGUARD3OID3ZPK (0x1ca960 - 0x1ca998)
    ctx->pc = 0x1ca98c;
    AddStepguardEffect__FP9STEPGUARD3OID3ZPK(rdram, ctx, runtime);
}

void entry_1ca9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca9c0 inside SetStepguardPathzone__FP9STEPGUARD3OID (0x1ca998 - 0x1ca9d0)
    ctx->pc = 0x1ca9c0;
    SetStepguardPathzone__FP9STEPGUARD3OID(rdram, ctx, runtime);
}

void entry_1ca9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca9dc inside entry_1ca9d0 (0x1ca9d0 - 0x1caa08)
    ctx->pc = 0x1ca9dc;
    entry_1ca9d0(rdram, ctx, runtime);
}

void entry_1ca9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca9e8 inside entry_1ca9d0 (0x1ca9d0 - 0x1caa08)
    ctx->pc = 0x1ca9e8;
    entry_1ca9d0(rdram, ctx, runtime);
}

void entry_1ca9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ca9f4 inside entry_1ca9d0 (0x1ca9d0 - 0x1caa08)
    ctx->pc = 0x1ca9f4;
    entry_1ca9d0(rdram, ctx, runtime);
}

void entry_1caa3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caa3c inside PsoEnemyStepguard__FP9STEPGUARD (0x1caa08 - 0x1caa44)
    ctx->pc = 0x1caa3c;
    PsoEnemyStepguard__FP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1caa48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caa48 inside entry_1caa44 (0x1caa44 - 0x1caa50)
    ctx->pc = 0x1caa48;
    entry_1caa44(rdram, ctx, runtime);
}

void entry_1caa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caa7c inside entry_1caa70 (0x1caa70 - 0x1caa9c)
    ctx->pc = 0x1caa7c;
    entry_1caa70(rdram, ctx, runtime);
}

void entry_1caabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caabc inside entry_1caab4 (0x1caab4 - 0x1caad0)
    ctx->pc = 0x1caabc;
    entry_1caab4(rdram, ctx, runtime);
}

void entry_1caba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caba0 inside entry_1cab3c (0x1cab3c - 0x1cac28)
    ctx->pc = 0x1caba0;
    entry_1cab3c(rdram, ctx, runtime);
}

void entry_1cabec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cabec inside entry_1cab3c (0x1cab3c - 0x1cac28)
    ctx->pc = 0x1cabec;
    entry_1cab3c(rdram, ctx, runtime);
}

void entry_1cac04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cac04 inside entry_1cab3c (0x1cab3c - 0x1cac28)
    ctx->pc = 0x1cac04;
    entry_1cab3c(rdram, ctx, runtime);
}

void entry_1cac0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cac0c inside entry_1cab3c (0x1cab3c - 0x1cac28)
    ctx->pc = 0x1cac0c;
    entry_1cab3c(rdram, ctx, runtime);
}

void entry_1cac6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cac6c inside FUN_001cac30 (0x1cac30 - 0x1cac80)
    ctx->pc = 0x1cac6c;
    FUN_001cac30(rdram, ctx, runtime);
}

void entry_1cac98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cac98 inside entry_1cac80 (0x1cac80 - 0x1cacb0)
    ctx->pc = 0x1cac98;
    entry_1cac80(rdram, ctx, runtime);
}

void entry_1cac9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cac9c inside entry_1cac80 (0x1cac80 - 0x1cacb0)
    ctx->pc = 0x1cac9c;
    entry_1cac80(rdram, ctx, runtime);
}

void entry_1cad10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cad10 inside entry_1cacd4 (0x1cacd4 - 0x1cad28)
    ctx->pc = 0x1cad10;
    entry_1cacd4(rdram, ctx, runtime);
}

void entry_1cad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cad14 inside entry_1cacd4 (0x1cacd4 - 0x1cad28)
    ctx->pc = 0x1cad14;
    entry_1cacd4(rdram, ctx, runtime);
}

void entry_1cad90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cad90 inside MatchStepguardAnimationPhase__FP9STEPGUARD3OIDN31 (0x1cad60 - 0x1cad98)
    ctx->pc = 0x1cad90;
    MatchStepguardAnimationPhase__FP9STEPGUARD3OIDN31(rdram, ctx, runtime);
}

void entry_1cae24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cae24 inside entry_1cae18 (0x1cae18 - 0x1cae40)
    ctx->pc = 0x1cae24;
    entry_1cae18(rdram, ctx, runtime);
}

void entry_1cae38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cae38 inside entry_1cae18 (0x1cae18 - 0x1cae40)
    ctx->pc = 0x1cae38;
    entry_1cae18(rdram, ctx, runtime);
}

void entry_1cae80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cae80 inside entry_1cae78 (0x1cae78 - 0x1caea0)
    ctx->pc = 0x1cae80;
    entry_1cae78(rdram, ctx, runtime);
}

void entry_1caea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caea4 inside entry_1caea0 (0x1caea0 - 0x1caee0)
    ctx->pc = 0x1caea4;
    entry_1caea0(rdram, ctx, runtime);
}

void entry_1caeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caeb4 inside entry_1caea0 (0x1caea0 - 0x1caee0)
    ctx->pc = 0x1caeb4;
    entry_1caea0(rdram, ctx, runtime);
}

void entry_1caeb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1caeb8 inside entry_1caea0 (0x1caea0 - 0x1caee0)
    ctx->pc = 0x1caeb8;
    entry_1caea0(rdram, ctx, runtime);
}

void entry_1cafb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cafb4 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cafb4;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb024 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb024;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb028 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb028;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb064 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb064;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0a0 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0a0;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0a4 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0a4;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0b0 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0b0;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0d0 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0d0;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0d4 inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0d4;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb0dc inside entry_1caf78 (0x1caf78 - 0x1cb104)
    ctx->pc = 0x1cb0dc;
    entry_1caf78(rdram, ctx, runtime);
}

void entry_1cb184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb184 inside entry_1cb14c (0x1cb14c - 0x1cb1b8)
    ctx->pc = 0x1cb184;
    entry_1cb14c(rdram, ctx, runtime);
}

void entry_1cb21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb21c inside entry_1cb1f8 (0x1cb1f8 - 0x1cb234)
    ctx->pc = 0x1cb21c;
    entry_1cb1f8(rdram, ctx, runtime);
}

void entry_1cb224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb224 inside entry_1cb1f8 (0x1cb1f8 - 0x1cb234)
    ctx->pc = 0x1cb224;
    entry_1cb1f8(rdram, ctx, runtime);
}

void entry_1cb23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb23c inside entry_1cb234 (0x1cb234 - 0x1cb24c)
    ctx->pc = 0x1cb23c;
    entry_1cb234(rdram, ctx, runtime);
}

void entry_1cb29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb29c inside entry_1cb298 (0x1cb298 - 0x1cb2c4)
    ctx->pc = 0x1cb29c;
    entry_1cb298(rdram, ctx, runtime);
}

void entry_1cb2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2b0 inside entry_1cb298 (0x1cb298 - 0x1cb2c4)
    ctx->pc = 0x1cb2b0;
    entry_1cb298(rdram, ctx, runtime);
}

void entry_1cb2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2dc inside entry_1cb2c4 (0x1cb2c4 - 0x1cb2f4)
    ctx->pc = 0x1cb2dc;
    entry_1cb2c4(rdram, ctx, runtime);
}

void entry_1cb2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2e0 inside entry_1cb2c4 (0x1cb2c4 - 0x1cb2f4)
    ctx->pc = 0x1cb2e0;
    entry_1cb2c4(rdram, ctx, runtime);
}

void entry_1cb2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2e8 inside entry_1cb2c4 (0x1cb2c4 - 0x1cb2f4)
    ctx->pc = 0x1cb2e8;
    entry_1cb2c4(rdram, ctx, runtime);
}

void entry_1cb2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2ec inside entry_1cb2c4 (0x1cb2c4 - 0x1cb2f4)
    ctx->pc = 0x1cb2ec;
    entry_1cb2c4(rdram, ctx, runtime);
}

void entry_1cb2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb2fc inside entry_1cb2f4 (0x1cb2f4 - 0x1cb328)
    ctx->pc = 0x1cb2fc;
    entry_1cb2f4(rdram, ctx, runtime);
}

void entry_1cb368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb368 inside entry_1cb360 (0x1cb360 - 0x1cb370)
    ctx->pc = 0x1cb368;
    entry_1cb360(rdram, ctx, runtime);
}

void entry_1cb38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb38c inside entry_1cb370 (0x1cb370 - 0x1cb3ac)
    ctx->pc = 0x1cb38c;
    entry_1cb370(rdram, ctx, runtime);
}

void entry_1cb3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb3b0 inside entry_1cb3ac (0x1cb3ac - 0x1cb3c0)
    ctx->pc = 0x1cb3b0;
    entry_1cb3ac(rdram, ctx, runtime);
}

void entry_1cb454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb454 inside entry_1cb404 (0x1cb404 - 0x1cb46c)
    ctx->pc = 0x1cb454;
    entry_1cb404(rdram, ctx, runtime);
}

void entry_1cb488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb488 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb488;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb4a4 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb4a4;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb4bc inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb4bc;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb4e4 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb4e4;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb500 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb500;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb518 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb518;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb53c inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb53c;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb54c inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb54c;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb55c inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb55c;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb560 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb560;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb564 inside entry_1cb46c (0x1cb46c - 0x1cb578)
    ctx->pc = 0x1cb564;
    entry_1cb46c(rdram, ctx, runtime);
}

void entry_1cb5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb5ac inside FUN_001cb578 (0x1cb578 - 0x1cb5b8)
    ctx->pc = 0x1cb5ac;
    FUN_001cb578(rdram, ctx, runtime);
}

void entry_1cb5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb5b0 inside FUN_001cb578 (0x1cb578 - 0x1cb5b8)
    ctx->pc = 0x1cb5b0;
    FUN_001cb578(rdram, ctx, runtime);
}

void entry_1cb690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb690 inside entry_1cb670 (0x1cb670 - 0x1cb6a8)
    ctx->pc = 0x1cb690;
    entry_1cb670(rdram, ctx, runtime);
}

void entry_1cb6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb6c8 inside AddSggGuardName__FP3SGG3OID (0x1cb6a8 - 0x1cb6d0)
    ctx->pc = 0x1cb6c8;
    AddSggGuardName__FP3SGG3OID(rdram, ctx, runtime);
}

void entry_1cb6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb6f0 inside AddSggSearchXfmName__FP3SGG3OID (0x1cb6d0 - 0x1cb6f8)
    ctx->pc = 0x1cb6f0;
    AddSggSearchXfmName__FP3SGG3OID(rdram, ctx, runtime);
}

void entry_1cb730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb730 inside RemoveSggGuard__FP3SGGP9STEPGUARD (0x1cb6f8 - 0x1cb774)
    ctx->pc = 0x1cb730;
    RemoveSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1cb748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb748 inside RemoveSggGuard__FP3SGGP9STEPGUARD (0x1cb6f8 - 0x1cb774)
    ctx->pc = 0x1cb748;
    RemoveSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime);
}

void entry_1cb790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb790 inside entry_1cb78c (0x1cb78c - 0x1cb7a0)
    ctx->pc = 0x1cb790;
    entry_1cb78c(rdram, ctx, runtime);
}

void entry_1cb7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb7d8 inside BindSgg__FP3SGG (0x1cb7a0 - 0x1cb7e8)
    ctx->pc = 0x1cb7d8;
    BindSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cb818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb818 inside entry_1cb7e8 (0x1cb7e8 - 0x1cb858)
    ctx->pc = 0x1cb818;
    entry_1cb7e8(rdram, ctx, runtime);
}

void entry_1cb81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb81c inside entry_1cb7e8 (0x1cb7e8 - 0x1cb858)
    ctx->pc = 0x1cb81c;
    entry_1cb7e8(rdram, ctx, runtime);
}

void entry_1cb82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb82c inside entry_1cb7e8 (0x1cb7e8 - 0x1cb858)
    ctx->pc = 0x1cb82c;
    entry_1cb7e8(rdram, ctx, runtime);
}

void entry_1cb848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb848 inside entry_1cb7e8 (0x1cb7e8 - 0x1cb858)
    ctx->pc = 0x1cb848;
    entry_1cb7e8(rdram, ctx, runtime);
}

void entry_1cb884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb884 inside entry_1cb858 (0x1cb858 - 0x1cb8b8)
    ctx->pc = 0x1cb884;
    entry_1cb858(rdram, ctx, runtime);
}

void entry_1cb888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb888 inside entry_1cb858 (0x1cb858 - 0x1cb8b8)
    ctx->pc = 0x1cb888;
    entry_1cb858(rdram, ctx, runtime);
}

void entry_1cb898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb898 inside entry_1cb858 (0x1cb858 - 0x1cb8b8)
    ctx->pc = 0x1cb898;
    entry_1cb858(rdram, ctx, runtime);
}

void entry_1cb918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb918 inside entry_1cb8fc (0x1cb8fc - 0x1cb930)
    ctx->pc = 0x1cb918;
    entry_1cb8fc(rdram, ctx, runtime);
}

void entry_1cb960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb960 inside entry_1cb930 (0x1cb930 - 0x1cb998)
    ctx->pc = 0x1cb960;
    entry_1cb930(rdram, ctx, runtime);
}

void entry_1cb978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb978 inside entry_1cb930 (0x1cb930 - 0x1cb998)
    ctx->pc = 0x1cb978;
    entry_1cb930(rdram, ctx, runtime);
}

void entry_1cb9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb9d0 inside entry_1cb9ac (0x1cb9ac - 0x1cba18)
    ctx->pc = 0x1cb9d0;
    entry_1cb9ac(rdram, ctx, runtime);
}

void entry_1cb9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cb9e8 inside entry_1cb9ac (0x1cb9ac - 0x1cba18)
    ctx->pc = 0x1cb9e8;
    entry_1cb9ac(rdram, ctx, runtime);
}

void entry_1cba1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba1c inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba1c;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cba2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba2c inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba2c;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cba40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba40 inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba40;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cba44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba44 inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba44;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cba54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba54 inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba54;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cba68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cba68 inside entry_1cba18 (0x1cba18 - 0x1cba70)
    ctx->pc = 0x1cba68;
    entry_1cba18(rdram, ctx, runtime);
}

void entry_1cbaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbaec inside entry_1cbae8 (0x1cbae8 - 0x1cbaf8)
    ctx->pc = 0x1cbaec;
    entry_1cbae8(rdram, ctx, runtime);
}

void entry_1cbb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbb58 inside entry_1cbb4c (0x1cbb4c - 0x1cbb60)
    ctx->pc = 0x1cbb58;
    entry_1cbb4c(rdram, ctx, runtime);
}

void entry_1cbb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbb78 inside entry_1cbb68 (0x1cbb68 - 0x1cbb88)
    ctx->pc = 0x1cbb78;
    entry_1cbb68(rdram, ctx, runtime);
}

void entry_1cbbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbbc8 inside SggsNextSgg__FP3SGG (0x1cbb88 - 0x1cbc10)
    ctx->pc = 0x1cbbc8;
    SggsNextSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbbd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbbd8 inside SggsNextSgg__FP3SGG (0x1cbb88 - 0x1cbc10)
    ctx->pc = 0x1cbbd8;
    SggsNextSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbbf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbbf0 inside SggsNextSgg__FP3SGG (0x1cbb88 - 0x1cbc10)
    ctx->pc = 0x1cbbf0;
    SggsNextSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbbf4 inside SggsNextSgg__FP3SGG (0x1cbb88 - 0x1cbc10)
    ctx->pc = 0x1cbbf4;
    SggsNextSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbc28 inside entry_1cbc10 (0x1cbc10 - 0x1cbc68)
    ctx->pc = 0x1cbc28;
    entry_1cbc10(rdram, ctx, runtime);
}

void entry_1cbc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbc70 inside entry_1cbc68 (0x1cbc68 - 0x1cbc8c)
    ctx->pc = 0x1cbc70;
    entry_1cbc68(rdram, ctx, runtime);
}

void entry_1cbc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbc84 inside entry_1cbc68 (0x1cbc68 - 0x1cbc8c)
    ctx->pc = 0x1cbc84;
    entry_1cbc68(rdram, ctx, runtime);
}

void entry_1cbc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbc94 inside entry_1cbc8c (0x1cbc8c - 0x1cbcb8)
    ctx->pc = 0x1cbc94;
    entry_1cbc8c(rdram, ctx, runtime);
}

void entry_1cbc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbc9c inside entry_1cbc8c (0x1cbc8c - 0x1cbcb8)
    ctx->pc = 0x1cbc9c;
    entry_1cbc8c(rdram, ctx, runtime);
}

void entry_1cbca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbca4 inside entry_1cbc8c (0x1cbc8c - 0x1cbcb8)
    ctx->pc = 0x1cbca4;
    entry_1cbc8c(rdram, ctx, runtime);
}

void entry_1cbce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbce0 inside FDetectSgg__FP3SGG (0x1cbcb8 - 0x1cbd08)
    ctx->pc = 0x1cbce0;
    FDetectSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbce4 inside FDetectSgg__FP3SGG (0x1cbcb8 - 0x1cbd08)
    ctx->pc = 0x1cbce4;
    FDetectSgg__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbd3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbd3c inside entry_1cbd28 (0x1cbd28 - 0x1cbd58)
    ctx->pc = 0x1cbd3c;
    entry_1cbd28(rdram, ctx, runtime);
}

void entry_1cbd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbd98 inside FAbandonSggSearch__FP3SGG (0x1cbd58 - 0x1cbdac)
    ctx->pc = 0x1cbd98;
    FAbandonSggSearch__FP3SGG(rdram, ctx, runtime);
}

void entry_1cbdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbdd0 inside entry_1cbdac (0x1cbdac - 0x1cbe20)
    ctx->pc = 0x1cbdd0;
    entry_1cbdac(rdram, ctx, runtime);
}

void entry_1cbde0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbde0 inside entry_1cbdac (0x1cbdac - 0x1cbe20)
    ctx->pc = 0x1cbde0;
    entry_1cbdac(rdram, ctx, runtime);
}

void entry_1cbde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbde4 inside entry_1cbdac (0x1cbdac - 0x1cbe20)
    ctx->pc = 0x1cbde4;
    entry_1cbdac(rdram, ctx, runtime);
}

void entry_1cbdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbdf4 inside entry_1cbdac (0x1cbdac - 0x1cbe20)
    ctx->pc = 0x1cbdf4;
    entry_1cbdac(rdram, ctx, runtime);
}

void entry_1cbdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbdf8 inside entry_1cbdac (0x1cbdac - 0x1cbe20)
    ctx->pc = 0x1cbdf8;
    entry_1cbdac(rdram, ctx, runtime);
}

void entry_1cbe30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbe30 inside EnsureSggAlarm__FP3SGGP5ALARM (0x1cbe20 - 0x1cbe70)
    ctx->pc = 0x1cbe30;
    EnsureSggAlarm__FP3SGGP5ALARM(rdram, ctx, runtime);
}

void entry_1cbe48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbe48 inside EnsureSggAlarm__FP3SGGP5ALARM (0x1cbe20 - 0x1cbe70)
    ctx->pc = 0x1cbe48;
    EnsureSggAlarm__FP3SGGP5ALARM(rdram, ctx, runtime);
}

void entry_1cbe68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbe68 inside EnsureSggAlarm__FP3SGGP5ALARM (0x1cbe20 - 0x1cbe70)
    ctx->pc = 0x1cbe68;
    EnsureSggAlarm__FP3SGGP5ALARM(rdram, ctx, runtime);
}

void entry_1cbea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbea8 inside TriggerSggAlarms__FP3SGG4ALTK (0x1cbe70 - 0x1cbeb8)
    ctx->pc = 0x1cbea8;
    TriggerSggAlarms__FP3SGG4ALTK(rdram, ctx, runtime);
}

void entry_1cbec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbec8 inside entry_1cbeb8 (0x1cbeb8 - 0x1cbee8)
    ctx->pc = 0x1cbec8;
    entry_1cbeb8(rdram, ctx, runtime);
}

void entry_1cbf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbf60 inside entry_1cbf44 (0x1cbf44 - 0x1cbf74)
    ctx->pc = 0x1cbf60;
    entry_1cbf44(rdram, ctx, runtime);
}

void entry_1cbf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbf98 inside entry_1cbf74 (0x1cbf74 - 0x1cbfc8)
    ctx->pc = 0x1cbf98;
    entry_1cbf74(rdram, ctx, runtime);
}

void entry_1cbfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbfb8 inside entry_1cbf74 (0x1cbf74 - 0x1cbfc8)
    ctx->pc = 0x1cbfb8;
    entry_1cbf74(rdram, ctx, runtime);
}

void entry_1cbfe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbfe8 inside entry_1cbfc8 (0x1cbfc8 - 0x1cc030)
    ctx->pc = 0x1cbfe8;
    entry_1cbfc8(rdram, ctx, runtime);
}

void entry_1cbfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cbfec inside entry_1cbfc8 (0x1cbfc8 - 0x1cc030)
    ctx->pc = 0x1cbfec;
    entry_1cbfc8(rdram, ctx, runtime);
}

void entry_1cc00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc00c inside entry_1cbfc8 (0x1cbfc8 - 0x1cc030)
    ctx->pc = 0x1cc00c;
    entry_1cbfc8(rdram, ctx, runtime);
}

void entry_1cc024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc024 inside entry_1cbfc8 (0x1cbfc8 - 0x1cc030)
    ctx->pc = 0x1cc024;
    entry_1cbfc8(rdram, ctx, runtime);
}

void entry_1cc060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc060 inside entry_1cc040 (0x1cc040 - 0x1cc074)
    ctx->pc = 0x1cc060;
    entry_1cc040(rdram, ctx, runtime);
}

void entry_1cc088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc088 inside entry_1cc074 (0x1cc074 - 0x1cc090)
    ctx->pc = 0x1cc088;
    entry_1cc074(rdram, ctx, runtime);
}

void entry_1cc09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc09c inside entry_1cc090 (0x1cc090 - 0x1cc0c0)
    ctx->pc = 0x1cc09c;
    entry_1cc090(rdram, ctx, runtime);
}

void entry_1cc0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc0b8 inside entry_1cc090 (0x1cc090 - 0x1cc0c0)
    ctx->pc = 0x1cc0b8;
    entry_1cc090(rdram, ctx, runtime);
}

void entry_1cc0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc0c8 inside entry_1cc0c0 (0x1cc0c0 - 0x1cc0d0)
    ctx->pc = 0x1cc0c8;
    entry_1cc0c0(rdram, ctx, runtime);
}

void entry_1cc0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc0d8 inside entry_1cc0d0 (0x1cc0d0 - 0x1cc0e0)
    ctx->pc = 0x1cc0d8;
    entry_1cc0d0(rdram, ctx, runtime);
}

void entry_1cc0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc0e4 inside entry_1cc0e0 (0x1cc0e0 - 0x1cc120)
    ctx->pc = 0x1cc0e4;
    entry_1cc0e0(rdram, ctx, runtime);
}

void entry_1cc0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc0f0 inside entry_1cc0e0 (0x1cc0e0 - 0x1cc120)
    ctx->pc = 0x1cc0f0;
    entry_1cc0e0(rdram, ctx, runtime);
}

void entry_1cc1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc1a8 inside entry_1cc174 (0x1cc174 - 0x1cc1f0)
    ctx->pc = 0x1cc1a8;
    entry_1cc174(rdram, ctx, runtime);
}

void entry_1cc1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc1d8 inside entry_1cc174 (0x1cc174 - 0x1cc1f0)
    ctx->pc = 0x1cc1d8;
    entry_1cc174(rdram, ctx, runtime);
}

void entry_1cc238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc238 inside entry_1cc1f0 (0x1cc1f0 - 0x1cc274)
    ctx->pc = 0x1cc238;
    entry_1cc1f0(rdram, ctx, runtime);
}

void entry_1cc24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc24c inside entry_1cc1f0 (0x1cc1f0 - 0x1cc274)
    ctx->pc = 0x1cc24c;
    entry_1cc1f0(rdram, ctx, runtime);
}

void entry_1cc2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc2ac inside entry_1cc28c (0x1cc28c - 0x1cc2b4)
    ctx->pc = 0x1cc2ac;
    entry_1cc28c(rdram, ctx, runtime);
}

void entry_1cc314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc314 inside entry_1cc30c (0x1cc30c - 0x1cc354)
    ctx->pc = 0x1cc314;
    entry_1cc30c(rdram, ctx, runtime);
}

void entry_1cc318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc318 inside entry_1cc30c (0x1cc30c - 0x1cc354)
    ctx->pc = 0x1cc318;
    entry_1cc30c(rdram, ctx, runtime);
}

void entry_1cc340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc340 inside entry_1cc30c (0x1cc30c - 0x1cc354)
    ctx->pc = 0x1cc340;
    entry_1cc30c(rdram, ctx, runtime);
}

void entry_1cc3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc3b4 inside entry_1cc3a4 (0x1cc3a4 - 0x1cc410)
    ctx->pc = 0x1cc3b4;
    entry_1cc3a4(rdram, ctx, runtime);
}

void entry_1cc47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc47c inside entry_1cc470 (0x1cc470 - 0x1cc490)
    ctx->pc = 0x1cc47c;
    entry_1cc470(rdram, ctx, runtime);
}

void entry_1cc538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc538 inside AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX (0x1cc490 - 0x1cc5f4)
    ctx->pc = 0x1cc538;
    AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX(rdram, ctx, runtime);
}

void entry_1cc550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc550 inside AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX (0x1cc490 - 0x1cc5f4)
    ctx->pc = 0x1cc550;
    AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX(rdram, ctx, runtime);
}

void entry_1cc57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc57c inside AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX (0x1cc490 - 0x1cc5f4)
    ctx->pc = 0x1cc57c;
    AnticipateJtForce__FP2JTP2SOP6VECTORT2P2FX(rdram, ctx, runtime);
}

void entry_1cc680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc680 inside entry_1cc630 (0x1cc630 - 0x1cc70c)
    ctx->pc = 0x1cc680;
    entry_1cc630(rdram, ctx, runtime);
}

void entry_1cc6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc6a8 inside entry_1cc630 (0x1cc630 - 0x1cc70c)
    ctx->pc = 0x1cc6a8;
    entry_1cc630(rdram, ctx, runtime);
}

void entry_1cc738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc738 inside entry_1cc724 (0x1cc724 - 0x1cc7c0)
    ctx->pc = 0x1cc738;
    entry_1cc724(rdram, ctx, runtime);
}

void entry_1cc8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc8ec inside entry_1cc888 (0x1cc888 - 0x1cc928)
    ctx->pc = 0x1cc8ec;
    entry_1cc888(rdram, ctx, runtime);
}

void entry_1cc8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc8fc inside entry_1cc888 (0x1cc888 - 0x1cc928)
    ctx->pc = 0x1cc8fc;
    entry_1cc888(rdram, ctx, runtime);
}

void entry_1cc998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cc998 inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1cc998;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1cca58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cca58 inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1cca58;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1cca64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cca64 inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1cca64;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1ccac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccac0 inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1ccac0;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1ccacc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccacc inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1ccacc;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1ccad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccad0 inside entry_1cc928 (0x1cc928 - 0x1ccb10)
    ctx->pc = 0x1ccad0;
    entry_1cc928(rdram, ctx, runtime);
}

void entry_1ccb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccb78 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccb78;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccbac inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccbac;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccbb8 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccbb8;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccc50 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccc50;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccc60 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccc60;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccc84 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccc84;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccc88 inside entry_1ccb10 (0x1ccb10 - 0x1cccb8)
    ctx->pc = 0x1ccc88;
    entry_1ccb10(rdram, ctx, runtime);
}

void entry_1ccd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccd6c inside entry_1ccd64 (0x1ccd64 - 0x1ccdb8)
    ctx->pc = 0x1ccd6c;
    entry_1ccd64(rdram, ctx, runtime);
}

void entry_1ccd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccd70 inside entry_1ccd64 (0x1ccd64 - 0x1ccdb8)
    ctx->pc = 0x1ccd70;
    entry_1ccd64(rdram, ctx, runtime);
}

void entry_1ccd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccd84 inside entry_1ccd64 (0x1ccd64 - 0x1ccdb8)
    ctx->pc = 0x1ccd84;
    entry_1ccd64(rdram, ctx, runtime);
}

void entry_1ccdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccdf4 inside entry_1ccdec (0x1ccdec - 0x1cce9c)
    ctx->pc = 0x1ccdf4;
    entry_1ccdec(rdram, ctx, runtime);
}

void entry_1ccdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccdf8 inside entry_1ccdec (0x1ccdec - 0x1cce9c)
    ctx->pc = 0x1ccdf8;
    entry_1ccdec(rdram, ctx, runtime);
}

void entry_1cce08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cce08 inside entry_1ccdec (0x1ccdec - 0x1cce9c)
    ctx->pc = 0x1cce08;
    entry_1ccdec(rdram, ctx, runtime);
}

void entry_1cce50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cce50 inside entry_1ccdec (0x1ccdec - 0x1cce9c)
    ctx->pc = 0x1cce50;
    entry_1ccdec(rdram, ctx, runtime);
}

void entry_1cce60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cce60 inside entry_1ccdec (0x1ccdec - 0x1cce9c)
    ctx->pc = 0x1cce60;
    entry_1ccdec(rdram, ctx, runtime);
}

void entry_1ccf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccf5c inside entry_1ccf54 (0x1ccf54 - 0x1ccf98)
    ctx->pc = 0x1ccf5c;
    entry_1ccf54(rdram, ctx, runtime);
}

void entry_1ccf64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ccf64 inside entry_1ccf54 (0x1ccf54 - 0x1ccf98)
    ctx->pc = 0x1ccf64;
    entry_1ccf54(rdram, ctx, runtime);
}

void entry_1cd130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd130 inside entry_1cd128 (0x1cd128 - 0x1cd144)
    ctx->pc = 0x1cd130;
    entry_1cd128(rdram, ctx, runtime);
}

void entry_1cd1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd1a0 inside entry_1cd154 (0x1cd154 - 0x1cd1dc)
    ctx->pc = 0x1cd1a0;
    entry_1cd154(rdram, ctx, runtime);
}

void entry_1cd1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd1c0 inside entry_1cd154 (0x1cd154 - 0x1cd1dc)
    ctx->pc = 0x1cd1c0;
    entry_1cd154(rdram, ctx, runtime);
}

void entry_1cd1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd1cc inside entry_1cd154 (0x1cd154 - 0x1cd1dc)
    ctx->pc = 0x1cd1cc;
    entry_1cd154(rdram, ctx, runtime);
}

void entry_1cd1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd1d0 inside entry_1cd154 (0x1cd154 - 0x1cd1dc)
    ctx->pc = 0x1cd1d0;
    entry_1cd154(rdram, ctx, runtime);
}

void entry_1cd1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd1d4 inside entry_1cd154 (0x1cd154 - 0x1cd1dc)
    ctx->pc = 0x1cd1d4;
    entry_1cd154(rdram, ctx, runtime);
}

void entry_1cd23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd23c inside entry_1cd1dc (0x1cd1dc - 0x1cd25c)
    ctx->pc = 0x1cd23c;
    entry_1cd1dc(rdram, ctx, runtime);
}

void entry_1cd248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd248 inside entry_1cd1dc (0x1cd1dc - 0x1cd25c)
    ctx->pc = 0x1cd248;
    entry_1cd1dc(rdram, ctx, runtime);
}

void entry_1cd2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd2e4 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd2e4;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd300 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd300;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd310 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd310;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd32c inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd32c;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd33c inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd33c;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd354 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd354;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd374 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd374;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd3a4 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd3a4;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd3b8 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd3b8;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd3cc inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd3cc;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd428 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd428;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd430 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd430;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd444 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd444;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd450 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd450;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd464 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd464;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd470 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd470;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd4cc inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd4cc;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd4d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd4d0 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd4d0;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd4d4 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd4d4;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd4d8 inside entry_1cd2b8 (0x1cd2b8 - 0x1cd4e0)
    ctx->pc = 0x1cd4d8;
    entry_1cd2b8(rdram, ctx, runtime);
}

void entry_1cd500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd500 inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd500;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd52c inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd52c;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd540 inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd540;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd550 inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd550;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd564 inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd564;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd58c inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd58c;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd594 inside entry_1cd4fc (0x1cd4fc - 0x1cd5b0)
    ctx->pc = 0x1cd594;
    entry_1cd4fc(rdram, ctx, runtime);
}

void entry_1cd644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd644 inside entry_1cd610 (0x1cd610 - 0x1cd68c)
    ctx->pc = 0x1cd644;
    entry_1cd610(rdram, ctx, runtime);
}

void entry_1cd694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd694 inside entry_1cd68c (0x1cd68c - 0x1cd6c0)
    ctx->pc = 0x1cd694;
    entry_1cd68c(rdram, ctx, runtime);
}

void entry_1cd744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd744 inside entry_1cd6ec (0x1cd6ec - 0x1cd764)
    ctx->pc = 0x1cd744;
    entry_1cd6ec(rdram, ctx, runtime);
}

void entry_1cd7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd7d0 inside entry_1cd798 (0x1cd798 - 0x1cd7e0)
    ctx->pc = 0x1cd7d0;
    entry_1cd798(rdram, ctx, runtime);
}

void entry_1cd7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd7d4 inside entry_1cd798 (0x1cd798 - 0x1cd7e0)
    ctx->pc = 0x1cd7d4;
    entry_1cd798(rdram, ctx, runtime);
}

void entry_1cd800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd800 inside UpdateJtHookOx__FP2JTP2LOi (0x1cd7e0 - 0x1cd82c)
    ctx->pc = 0x1cd800;
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime);
}

void entry_1cd858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd858 inside entry_1cd854 (0x1cd854 - 0x1cd870)
    ctx->pc = 0x1cd858;
    entry_1cd854(rdram, ctx, runtime);
}

void entry_1cd8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd8dc inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd8dc;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd8e8 inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd8e8;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd918 inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd918;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd930 inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd930;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd938 inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd938;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd93c inside entry_1cd8d4 (0x1cd8d4 - 0x1cd954)
    ctx->pc = 0x1cd93c;
    entry_1cd8d4(rdram, ctx, runtime);
}

void entry_1cd95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd95c inside entry_1cd954 (0x1cd954 - 0x1cda2c)
    ctx->pc = 0x1cd95c;
    entry_1cd954(rdram, ctx, runtime);
}

void entry_1cd980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd980 inside entry_1cd954 (0x1cd954 - 0x1cda2c)
    ctx->pc = 0x1cd980;
    entry_1cd954(rdram, ctx, runtime);
}

void entry_1cd9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cd9fc inside entry_1cd954 (0x1cd954 - 0x1cda2c)
    ctx->pc = 0x1cd9fc;
    entry_1cd954(rdram, ctx, runtime);
}

void entry_1cda30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cda30 inside entry_1cda2c (0x1cda2c - 0x1cda8c)
    ctx->pc = 0x1cda30;
    entry_1cda2c(rdram, ctx, runtime);
}

void entry_1cda5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cda5c inside entry_1cda2c (0x1cda2c - 0x1cda8c)
    ctx->pc = 0x1cda5c;
    entry_1cda2c(rdram, ctx, runtime);
}

void entry_1cdabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdabc inside entry_1cda8c (0x1cda8c - 0x1cdaf0)
    ctx->pc = 0x1cdabc;
    entry_1cda8c(rdram, ctx, runtime);
}

void entry_1cdad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdad4 inside entry_1cda8c (0x1cda8c - 0x1cdaf0)
    ctx->pc = 0x1cdad4;
    entry_1cda8c(rdram, ctx, runtime);
}

void entry_1cdaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdaf4 inside entry_1cdaf0 (0x1cdaf0 - 0x1cdb28)
    ctx->pc = 0x1cdaf4;
    entry_1cdaf0(rdram, ctx, runtime);
}

void entry_1cdafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdafc inside entry_1cdaf0 (0x1cdaf0 - 0x1cdb28)
    ctx->pc = 0x1cdafc;
    entry_1cdaf0(rdram, ctx, runtime);
}

void entry_1cdc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdc64 inside entry_1cdbfc (0x1cdbfc - 0x1cdc94)
    ctx->pc = 0x1cdc64;
    entry_1cdbfc(rdram, ctx, runtime);
}

void entry_1cdc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdc70 inside entry_1cdbfc (0x1cdbfc - 0x1cdc94)
    ctx->pc = 0x1cdc70;
    entry_1cdbfc(rdram, ctx, runtime);
}

void entry_1cdfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdfa0 inside entry_1cdf98 (0x1cdf98 - 0x1cdfa8)
    ctx->pc = 0x1cdfa0;
    entry_1cdf98(rdram, ctx, runtime);
}

void entry_1cdfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cdfac inside entry_1cdfa8 (0x1cdfa8 - 0x1cdfb8)
    ctx->pc = 0x1cdfac;
    entry_1cdfa8(rdram, ctx, runtime);
}

void entry_1ce014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce014 inside JtbsChooseJtHide__FP2JTP2LOP4JTHK (0x1cdfb8 - 0x1ce040)
    ctx->pc = 0x1ce014;
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime);
}

void entry_1ce01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce01c inside JtbsChooseJtHide__FP2JTP2LOP4JTHK (0x1cdfb8 - 0x1ce040)
    ctx->pc = 0x1ce01c;
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime);
}

void entry_1ce030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce030 inside JtbsChooseJtHide__FP2JTP2LOP4JTHK (0x1cdfb8 - 0x1ce040)
    ctx->pc = 0x1ce030;
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime);
}

void entry_1ce0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce0b8 inside entry_1ce06c (0x1ce06c - 0x1ce0f0)
    ctx->pc = 0x1ce0b8;
    entry_1ce06c(rdram, ctx, runtime);
}

void entry_1ce0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce0c8 inside entry_1ce06c (0x1ce06c - 0x1ce0f0)
    ctx->pc = 0x1ce0c8;
    entry_1ce06c(rdram, ctx, runtime);
}

void entry_1ce0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce0d4 inside entry_1ce06c (0x1ce06c - 0x1ce0f0)
    ctx->pc = 0x1ce0d4;
    entry_1ce06c(rdram, ctx, runtime);
}

void entry_1ce0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce0e8 inside entry_1ce06c (0x1ce06c - 0x1ce0f0)
    ctx->pc = 0x1ce0e8;
    entry_1ce06c(rdram, ctx, runtime);
}

void entry_1ce148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce148 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce148;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce154 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce154;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce160 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce160;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce178 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce178;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce1c8 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce1c8;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce1d4 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce1d4;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce1e0 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce1e0;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce1f8 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce1f8;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce224 inside entry_1ce0f0 (0x1ce0f0 - 0x1ce22c)
    ctx->pc = 0x1ce224;
    entry_1ce0f0(rdram, ctx, runtime);
}

void entry_1ce294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce294 inside entry_1ce23c (0x1ce23c - 0x1ce2d0)
    ctx->pc = 0x1ce294;
    entry_1ce23c(rdram, ctx, runtime);
}

void entry_1ce29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce29c inside entry_1ce23c (0x1ce23c - 0x1ce2d0)
    ctx->pc = 0x1ce29c;
    entry_1ce23c(rdram, ctx, runtime);
}

void entry_1ce2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce2a0 inside entry_1ce23c (0x1ce23c - 0x1ce2d0)
    ctx->pc = 0x1ce2a0;
    entry_1ce23c(rdram, ctx, runtime);
}

void entry_1ce2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce2a8 inside entry_1ce23c (0x1ce23c - 0x1ce2d0)
    ctx->pc = 0x1ce2a8;
    entry_1ce23c(rdram, ctx, runtime);
}

void entry_1ce2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce2c0 inside entry_1ce23c (0x1ce23c - 0x1ce2d0)
    ctx->pc = 0x1ce2c0;
    entry_1ce23c(rdram, ctx, runtime);
}

void entry_1ce370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce370 inside entry_1ce314 (0x1ce314 - 0x1ce3bc)
    ctx->pc = 0x1ce370;
    entry_1ce314(rdram, ctx, runtime);
}

void entry_1ce384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce384 inside entry_1ce314 (0x1ce314 - 0x1ce3bc)
    ctx->pc = 0x1ce384;
    entry_1ce314(rdram, ctx, runtime);
}

void entry_1ce390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce390 inside entry_1ce314 (0x1ce314 - 0x1ce3bc)
    ctx->pc = 0x1ce390;
    entry_1ce314(rdram, ctx, runtime);
}

void entry_1ce430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce430 inside entry_1ce3d8 (0x1ce3d8 - 0x1ce4bc)
    ctx->pc = 0x1ce430;
    entry_1ce3d8(rdram, ctx, runtime);
}

void entry_1ce43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce43c inside entry_1ce3d8 (0x1ce3d8 - 0x1ce4bc)
    ctx->pc = 0x1ce43c;
    entry_1ce3d8(rdram, ctx, runtime);
}

void entry_1ce440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce440 inside entry_1ce3d8 (0x1ce3d8 - 0x1ce4bc)
    ctx->pc = 0x1ce440;
    entry_1ce3d8(rdram, ctx, runtime);
}

void entry_1ce51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce51c inside entry_1ce4f8 (0x1ce4f8 - 0x1ce524)
    ctx->pc = 0x1ce51c;
    entry_1ce4f8(rdram, ctx, runtime);
}

void entry_1ce540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce540 inside entry_1ce524 (0x1ce524 - 0x1ce590)
    ctx->pc = 0x1ce540;
    entry_1ce524(rdram, ctx, runtime);
}

void entry_1ce548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce548 inside entry_1ce524 (0x1ce524 - 0x1ce590)
    ctx->pc = 0x1ce548;
    entry_1ce524(rdram, ctx, runtime);
}

void entry_1ce54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce54c inside entry_1ce524 (0x1ce524 - 0x1ce590)
    ctx->pc = 0x1ce54c;
    entry_1ce524(rdram, ctx, runtime);
}

void entry_1ce678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce678 inside entry_1ce618 (0x1ce618 - 0x1ce720)
    ctx->pc = 0x1ce678;
    entry_1ce618(rdram, ctx, runtime);
}

void entry_1ce698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce698 inside entry_1ce618 (0x1ce618 - 0x1ce720)
    ctx->pc = 0x1ce698;
    entry_1ce618(rdram, ctx, runtime);
}

void entry_1ce6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce6d8 inside entry_1ce618 (0x1ce618 - 0x1ce720)
    ctx->pc = 0x1ce6d8;
    entry_1ce618(rdram, ctx, runtime);
}

void entry_1ce6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce6e4 inside entry_1ce618 (0x1ce618 - 0x1ce720)
    ctx->pc = 0x1ce6e4;
    entry_1ce618(rdram, ctx, runtime);
}

void entry_1ce7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce7b8 inside entry_1ce76c (0x1ce76c - 0x1ce800)
    ctx->pc = 0x1ce7b8;
    entry_1ce76c(rdram, ctx, runtime);
}

void entry_1ce7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce7c4 inside entry_1ce76c (0x1ce76c - 0x1ce800)
    ctx->pc = 0x1ce7c4;
    entry_1ce76c(rdram, ctx, runtime);
}

void entry_1ce7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce7d0 inside entry_1ce76c (0x1ce76c - 0x1ce800)
    ctx->pc = 0x1ce7d0;
    entry_1ce76c(rdram, ctx, runtime);
}

void entry_1ce7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce7d4 inside entry_1ce76c (0x1ce76c - 0x1ce800)
    ctx->pc = 0x1ce7d4;
    entry_1ce76c(rdram, ctx, runtime);
}

void entry_1ce9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ce9a4 inside entry_1ce978 (0x1ce978 - 0x1ce9e8)
    ctx->pc = 0x1ce9a4;
    entry_1ce978(rdram, ctx, runtime);
}

void entry_1cec10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec10 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec10;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cec38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec38 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec38;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cec50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec50 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec50;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cec54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec54 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec54;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cec60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec60 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec60;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cec84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cec84 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cec84;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cecd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cecd8 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cecd8;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cece8 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cece8;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1ced7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ced7c inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1ced7c;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cedb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cedb0 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cedb0;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cedd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cedd4 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cedd4;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cedd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cedd8 inside entry_1cebb4 (0x1cebb4 - 0x1cedf8)
    ctx->pc = 0x1cedd8;
    entry_1cebb4(rdram, ctx, runtime);
}

void entry_1cef50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cef50 inside entry_1cef20 (0x1cef20 - 0x1cef84)
    ctx->pc = 0x1cef50;
    entry_1cef20(rdram, ctx, runtime);
}

void entry_1cef5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cef5c inside entry_1cef20 (0x1cef20 - 0x1cef84)
    ctx->pc = 0x1cef5c;
    entry_1cef20(rdram, ctx, runtime);
}

void entry_1cef90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cef90 inside entry_1cef84 (0x1cef84 - 0x1cefe8)
    ctx->pc = 0x1cef90;
    entry_1cef84(rdram, ctx, runtime);
}

void entry_1cef94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cef94 inside entry_1cef84 (0x1cef84 - 0x1cefe8)
    ctx->pc = 0x1cef94;
    entry_1cef84(rdram, ctx, runtime);
}

void entry_1cefb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cefb8 inside entry_1cef84 (0x1cef84 - 0x1cefe8)
    ctx->pc = 0x1cefb8;
    entry_1cef84(rdram, ctx, runtime);
}

void entry_1cf064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf064 inside entry_1cf018 (0x1cf018 - 0x1cf084)
    ctx->pc = 0x1cf064;
    entry_1cf018(rdram, ctx, runtime);
}

void entry_1cf0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf0e8 inside entry_1cf084 (0x1cf084 - 0x1cf0f0)
    ctx->pc = 0x1cf0e8;
    entry_1cf084(rdram, ctx, runtime);
}

void entry_1cf104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf104 inside entry_1cf0f0 (0x1cf0f0 - 0x1cf138)
    ctx->pc = 0x1cf104;
    entry_1cf0f0(rdram, ctx, runtime);
}

void entry_1cf150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf150 inside FUN_001cf138 (0x1cf138 - 0x1cf158)
    ctx->pc = 0x1cf150;
    FUN_001cf138(rdram, ctx, runtime);
}

void entry_1cf1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf1c8 inside FUN_001cf158 (0x1cf158 - 0x1cf1e4)
    ctx->pc = 0x1cf1c8;
    FUN_001cf158(rdram, ctx, runtime);
}

void entry_1cf1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf1d0 inside FUN_001cf158 (0x1cf158 - 0x1cf1e4)
    ctx->pc = 0x1cf1d0;
    FUN_001cf158(rdram, ctx, runtime);
}

void entry_1cf208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf208 inside entry_1cf1e4 (0x1cf1e4 - 0x1cf210)
    ctx->pc = 0x1cf208;
    entry_1cf1e4(rdram, ctx, runtime);
}

void entry_1cf234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf234 inside entry_1cf210 (0x1cf210 - 0x1cf260)
    ctx->pc = 0x1cf234;
    entry_1cf210(rdram, ctx, runtime);
}

void entry_1cf2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf2e4 inside entry_1cf2dc (0x1cf2dc - 0x1cf350)
    ctx->pc = 0x1cf2e4;
    entry_1cf2dc(rdram, ctx, runtime);
}

void entry_1cf30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf30c inside entry_1cf2dc (0x1cf2dc - 0x1cf350)
    ctx->pc = 0x1cf30c;
    entry_1cf2dc(rdram, ctx, runtime);
}

void entry_1cf310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf310 inside entry_1cf2dc (0x1cf2dc - 0x1cf350)
    ctx->pc = 0x1cf310;
    entry_1cf2dc(rdram, ctx, runtime);
}

void entry_1cf320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf320 inside entry_1cf2dc (0x1cf2dc - 0x1cf350)
    ctx->pc = 0x1cf320;
    entry_1cf2dc(rdram, ctx, runtime);
}

void entry_1cf340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf340 inside entry_1cf2dc (0x1cf2dc - 0x1cf350)
    ctx->pc = 0x1cf340;
    entry_1cf2dc(rdram, ctx, runtime);
}

void entry_1cf3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf3b8 inside entry_1cf394 (0x1cf394 - 0x1cf3d4)
    ctx->pc = 0x1cf3b8;
    entry_1cf394(rdram, ctx, runtime);
}

void entry_1cf480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf480 inside entry_1cf470 (0x1cf470 - 0x1cf498)
    ctx->pc = 0x1cf480;
    entry_1cf470(rdram, ctx, runtime);
}

void entry_1cf50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf50c inside entry_1cf504 (0x1cf504 - 0x1cf5a4)
    ctx->pc = 0x1cf50c;
    entry_1cf504(rdram, ctx, runtime);
}

void entry_1cf538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf538 inside entry_1cf504 (0x1cf504 - 0x1cf5a4)
    ctx->pc = 0x1cf538;
    entry_1cf504(rdram, ctx, runtime);
}

void entry_1cf53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf53c inside entry_1cf504 (0x1cf504 - 0x1cf5a4)
    ctx->pc = 0x1cf53c;
    entry_1cf504(rdram, ctx, runtime);
}

void entry_1cf544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf544 inside entry_1cf504 (0x1cf504 - 0x1cf5a4)
    ctx->pc = 0x1cf544;
    entry_1cf504(rdram, ctx, runtime);
}

void entry_1cf570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf570 inside entry_1cf504 (0x1cf504 - 0x1cf5a4)
    ctx->pc = 0x1cf570;
    entry_1cf504(rdram, ctx, runtime);
}

void entry_1cf5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf5ac inside entry_1cf5a4 (0x1cf5a4 - 0x1cf5b4)
    ctx->pc = 0x1cf5ac;
    entry_1cf5a4(rdram, ctx, runtime);
}

void entry_1cf61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf61c inside entry_1cf5b4 (0x1cf5b4 - 0x1cf664)
    ctx->pc = 0x1cf61c;
    entry_1cf5b4(rdram, ctx, runtime);
}

void entry_1cf624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf624 inside entry_1cf5b4 (0x1cf5b4 - 0x1cf664)
    ctx->pc = 0x1cf624;
    entry_1cf5b4(rdram, ctx, runtime);
}

void entry_1cf70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf70c inside entry_1cf704 (0x1cf704 - 0x1cf798)
    ctx->pc = 0x1cf70c;
    entry_1cf704(rdram, ctx, runtime);
}

void entry_1cf748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf748 inside entry_1cf704 (0x1cf704 - 0x1cf798)
    ctx->pc = 0x1cf748;
    entry_1cf704(rdram, ctx, runtime);
}

void entry_1cf74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf74c inside entry_1cf704 (0x1cf704 - 0x1cf798)
    ctx->pc = 0x1cf74c;
    entry_1cf704(rdram, ctx, runtime);
}

void entry_1cf754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf754 inside entry_1cf704 (0x1cf704 - 0x1cf798)
    ctx->pc = 0x1cf754;
    entry_1cf704(rdram, ctx, runtime);
}

void entry_1cf788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf788 inside entry_1cf704 (0x1cf704 - 0x1cf798)
    ctx->pc = 0x1cf788;
    entry_1cf704(rdram, ctx, runtime);
}

void entry_1cf84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf84c inside entry_1cf7dc (0x1cf7dc - 0x1cf870)
    ctx->pc = 0x1cf84c;
    entry_1cf7dc(rdram, ctx, runtime);
}

void entry_1cf854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf854 inside entry_1cf7dc (0x1cf7dc - 0x1cf870)
    ctx->pc = 0x1cf854;
    entry_1cf7dc(rdram, ctx, runtime);
}

void entry_1cf8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf8e0 inside entry_1cf8d0 (0x1cf8d0 - 0x1cf910)
    ctx->pc = 0x1cf8e0;
    entry_1cf8d0(rdram, ctx, runtime);
}

void entry_1cf9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf9ac inside entry_1cf9a4 (0x1cf9a4 - 0x1cfa28)
    ctx->pc = 0x1cf9ac;
    entry_1cf9a4(rdram, ctx, runtime);
}

void entry_1cf9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf9ec inside entry_1cf9a4 (0x1cf9a4 - 0x1cfa28)
    ctx->pc = 0x1cf9ec;
    entry_1cf9a4(rdram, ctx, runtime);
}

void entry_1cf9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf9f0 inside entry_1cf9a4 (0x1cf9a4 - 0x1cfa28)
    ctx->pc = 0x1cf9f0;
    entry_1cf9a4(rdram, ctx, runtime);
}

void entry_1cf9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cf9fc inside entry_1cf9a4 (0x1cf9a4 - 0x1cfa28)
    ctx->pc = 0x1cf9fc;
    entry_1cf9a4(rdram, ctx, runtime);
}

void entry_1cfa20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfa20 inside entry_1cf9a4 (0x1cf9a4 - 0x1cfa28)
    ctx->pc = 0x1cfa20;
    entry_1cf9a4(rdram, ctx, runtime);
}

void entry_1cfaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfaf8 inside entry_1cfae8 (0x1cfae8 - 0x1cfb0c)
    ctx->pc = 0x1cfaf8;
    entry_1cfae8(rdram, ctx, runtime);
}

void entry_1cfb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfb84 inside entry_1cfb7c (0x1cfb7c - 0x1cfbf8)
    ctx->pc = 0x1cfb84;
    entry_1cfb7c(rdram, ctx, runtime);
}

void entry_1cfbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfbb0 inside entry_1cfb7c (0x1cfb7c - 0x1cfbf8)
    ctx->pc = 0x1cfbb0;
    entry_1cfb7c(rdram, ctx, runtime);
}

void entry_1cfbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfbb4 inside entry_1cfb7c (0x1cfb7c - 0x1cfbf8)
    ctx->pc = 0x1cfbb4;
    entry_1cfb7c(rdram, ctx, runtime);
}

void entry_1cfbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfbc0 inside entry_1cfb7c (0x1cfb7c - 0x1cfbf8)
    ctx->pc = 0x1cfbc0;
    entry_1cfb7c(rdram, ctx, runtime);
}

void entry_1cfbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfbe8 inside entry_1cfb7c (0x1cfb7c - 0x1cfbf8)
    ctx->pc = 0x1cfbe8;
    entry_1cfb7c(rdram, ctx, runtime);
}

void entry_1cfcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfcfc inside entry_1cfcec (0x1cfcec - 0x1cfd10)
    ctx->pc = 0x1cfcfc;
    entry_1cfcec(rdram, ctx, runtime);
}

void entry_1cfd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfd88 inside entry_1cfd80 (0x1cfd80 - 0x1cfde8)
    ctx->pc = 0x1cfd88;
    entry_1cfd80(rdram, ctx, runtime);
}

void entry_1cfdb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfdb4 inside entry_1cfd80 (0x1cfd80 - 0x1cfde8)
    ctx->pc = 0x1cfdb4;
    entry_1cfd80(rdram, ctx, runtime);
}

void entry_1cfdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfdb8 inside entry_1cfd80 (0x1cfd80 - 0x1cfde8)
    ctx->pc = 0x1cfdb8;
    entry_1cfd80(rdram, ctx, runtime);
}

void entry_1cfdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfdc4 inside entry_1cfd80 (0x1cfd80 - 0x1cfde8)
    ctx->pc = 0x1cfdc4;
    entry_1cfd80(rdram, ctx, runtime);
}

void entry_1cfe04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfe04 inside entry_1cfde8 (0x1cfde8 - 0x1cfe5c)
    ctx->pc = 0x1cfe04;
    entry_1cfde8(rdram, ctx, runtime);
}

void entry_1cfe08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfe08 inside entry_1cfde8 (0x1cfde8 - 0x1cfe5c)
    ctx->pc = 0x1cfe08;
    entry_1cfde8(rdram, ctx, runtime);
}

void entry_1cfeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cfeec inside entry_1cfee4 (0x1cfee4 - 0x1cff2c)
    ctx->pc = 0x1cfeec;
    entry_1cfee4(rdram, ctx, runtime);
}

void entry_1cff30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cff30 inside entry_1cff2c (0x1cff2c - 0x1cffd0)
    ctx->pc = 0x1cff30;
    entry_1cff2c(rdram, ctx, runtime);
}

void entry_1cff7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1cff7c inside entry_1cff2c (0x1cff2c - 0x1cffd0)
    ctx->pc = 0x1cff7c;
    entry_1cff2c(rdram, ctx, runtime);
}

