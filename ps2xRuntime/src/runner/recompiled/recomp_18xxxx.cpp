// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_180068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180068: 0x5e2018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18006c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x180074);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_180074
// Address: 0x180074 - 0x180098

void entry_180074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x180074) {
        switch (ctx->pc) {
            case 0x180088: ctx->pc = 0; goto label_180088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x180074: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x180078: 0x18600013
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1800C8; return;
    }
    // 0x180080: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180084: 0x8e300008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_180088:
    // 0x180088: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18008c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x180090: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x180098);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_180098
// Address: 0x180098 - 0x1800a8

void entry_180098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180098: 0x2673000c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 12));
    // 0x18009c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1800a0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1800a8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1800a8
// Address: 0x1800a8 - 0x1800b4

void entry_1800a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1800a8: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1800ac: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1800b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1800b4
// Address: 0x1800b4 - 0x180108

void entry_1800b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1800b4) {
        switch (ctx->pc) {
            case 0x1800c8: ctx->pc = 0; goto label_1800c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1800b4: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1800b8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1800bc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1800c0: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x180088; return;
    }
label_1800c8:
    // 0x1800c8: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1800cc: 0x2a020005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 5));
    // 0x1800d0: 0x1440ffc3
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17FFE0; return;
    }
    // 0x1800d8: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1800dc: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1800e0: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1800e4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1800e8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1800ec: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1800f0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1800f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1800f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1800fc: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x180100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawKeyholeMask__FP7KEYHOLEffff
// Address: 0x180108 - 0x18017c

void entry_18017c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18017c: 0xe7b50030
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x180180: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x180184: 0xe7b40034
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    // 0x180188: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18018c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180190: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x180198);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_180198
// Address: 0x180198 - 0x1801ac

void entry_180198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180198: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18019c: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1801a0: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1801a4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1801ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1801ac
// Address: 0x1801ac - 0x1801bc

void entry_1801ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1801ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1801b0: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1801b4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1801bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1801bc
// Address: 0x1801bc - 0x1801ec

void entry_1801bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1801bc) {
        switch (ctx->pc) {
            case 0x1801c0: ctx->pc = 0; goto label_1801c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1801bc: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
label_1801c0:
    // 0x1801c0: 0x2221018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1801c4: 0x24420064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 100));
    // 0x1801c8: 0x2c29021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x1801cc: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1801d0: 0x1860005c
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x180344; return;
    }
    // 0x1801d8: 0x26e42280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8832));
    // 0x1801dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1801e0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1801e4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1801ec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1801ec
// Address: 0x1801ec - 0x180248

void entry_1801ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1801ec) {
        switch (ctx->pc) {
            case 0x180204: ctx->pc = 0; goto label_180204;
            case 0x18020c: ctx->pc = 0; goto label_18020c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1801ec: 0x2622fffd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967293));
    // 0x1801f0: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1801f4: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_180204;
    }
    // 0x1801fc: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16536));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18020c;
    }
label_180204:
    // 0x180204: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x180208: 0x244240a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16544));
label_18020c:
    // 0x18020c: 0x88430003
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x180210: 0x98430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x180214: 0xaba30043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180218: 0xbba30040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18021c: 0x2634ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x180220: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x180224: 0x93a20043
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x180228: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18022c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180230: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180234: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180238: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x18023c: 0xa3a20043
    WRITE8(ADD32(GPR_U32(ctx, 29), 67), (uint8_t)GPR_U32(ctx, 2));
    // 0x180240: 0xc058516
    SET_GPR_U32(ctx, 31, 0x180248);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_180248
// Address: 0x180248 - 0x18026c

void entry_180248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180248: 0x83a20043
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x18024c: 0x24030043
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 67));
    // 0x180250: 0x24050083
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 131));
    // 0x180254: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x180258: 0x28420000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 0));
    // 0x18025c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x180260: 0x62280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x180264: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18026c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18026c
// Address: 0x18026c - 0x1802e8

void entry_18026c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18026c) {
        switch (ctx->pc) {
            case 0x1802a8: ctx->pc = 0; goto label_1802a8;
            case 0x1802c0: ctx->pc = 0; goto label_1802c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18026c: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x180270: 0x18400034
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x180344; return;
    }
    // 0x180278: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x18027c: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x180280: 0x2415000c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 12));
    // 0x180284: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x180288: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x18028c: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x180290: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x180294: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x180298: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x18029c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1802a0: 0x951818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1802a4: 0x0
    // NOP
label_1802a8:
    // 0x1802a8: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1802ac: 0x24930001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1802b0: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1802b4: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1802b8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1802bc: 0x0
    // NOP
label_1802c0:
    // 0x1802c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1802c4: 0x8ec50038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 56)));
    // 0x1802c8: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1802cc: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1802d0: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1802d4: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1802d8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1802dc: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1802e0: 0xc0621d0
    SET_GPR_U32(ctx, 31, 0x1802e8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G10VU_VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_1802e8
// Address: 0x1802e8 - 0x180328

void entry_1802e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1802e8: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x1802ec: 0x26e42280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 8832));
    // 0x1802f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1802f4: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x1802f8: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x1802fc: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x180300: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180304: 0x46150000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x180308: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x18030c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180310: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180314: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180318: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x18031c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180320: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180328);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180328
// Address: 0x180328 - 0x180398

void entry_180328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x180328) {
        switch (ctx->pc) {
            case 0x180344: ctx->pc = 0; goto label_180344;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x180328: 0x623ffe5
    if (GPR_S32(ctx, 17) >= 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1802C0; return;
    }
    // 0x180330: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x180334: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x180338: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x18033c: 0x1440ffda
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1802A8; return;
    }
label_180344:
    // 0x180344: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x180348: 0x1e20ff9d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 17) > 0) {
        ctx->pc = 0x1801C0; return;
    }
    // 0x180350: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x180354: 0x7bbe00f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x180358: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x18035c: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x180360: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x180364: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x180368: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18036c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x180370: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x180374: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x180378: 0xc7b80130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[24] = *(float*)&val; }
    // 0x18037c: 0xc7b70128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[23] = *(float*)&val; }
    // 0x180380: 0xc7b60120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[22] = *(float*)&val; }
    // 0x180384: 0xc7b50118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[21] = *(float*)&val; }
    // 0x180388: 0xc7b40110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[20] = *(float*)&val; }
    // 0x18038c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x180394: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x180398; return;
}


// Function: DrawKeyhole__FP7KEYHOLEf
// Address: 0x180398 - 0x180430

void entry_180430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180430: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x180438);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_180438
// Address: 0x180438 - 0x180454

void entry_180438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180438: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18043c: 0x12000051
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x180584; return;
    }
    // 0x180444: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x180448: 0x8c62015c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 348)));
    // 0x18044c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x180454);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_180454
// Address: 0x180454 - 0x180470

void entry_180454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180454: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x180458: 0x1200004a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x180584; return;
    }
    // 0x180460: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x180464: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x180468: 0x40f809
    SET_GPR_U32(ctx, 31, 0x180470);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_180470
// Address: 0x180470 - 0x18048c

void entry_180470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180470: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x180474: 0x14430043
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x180584; return;
    }
    // 0x18047c: 0x26050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    // 0x180480: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x180484: 0xc051070
    SET_GPR_U32(ctx, 31, 0x18048c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_18048c
// Address: 0x18048c - 0x1805bc

void entry_18048c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18048c) {
        switch (ctx->pc) {
            case 0x1804d8: ctx->pc = 0; goto label_1804d8;
            case 0x180548: ctx->pc = 0; goto label_180548;
            case 0x180558: ctx->pc = 0; goto label_180558;
            case 0x180584: ctx->pc = 0; goto label_180584;
            case 0x1805a0: ctx->pc = 0; goto label_1805a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18048c: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x180490: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x180494: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x180498: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x18049c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1804a0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1804a4: 0x3c01441d
    SET_GPR_U32(ctx, 1, ((uint32_t)17437 << 16));
    // 0x1804a8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1804ac: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1804b0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1804b4: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1804b8: 0x0
    // NOP
    // 0x1804bc: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1804d8;
    }
    // 0x1804c4: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1804c8: 0x0
    // NOP
    // 0x1804cc: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1804d8;
    }
    // 0x1804d4: 0x46001846
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
label_1804d8:
    // 0x1804d8: 0x4601a942
    ctx->f[5] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x1804dc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1804e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1804e4: 0x3c01c376
    SET_GPR_U32(ctx, 1, ((uint32_t)50038 << 16));
    // 0x1804e8: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1804ec: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1804f0: 0xc7a10044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1804f4: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x1804f8: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x1804fc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x180500: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x180504: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x180508: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x18050c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x180510: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x180514: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x180518: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18051c: 0x3c0143ee
    SET_GPR_U32(ctx, 1, ((uint32_t)17390 << 16));
    // 0x180520: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x180524: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x180528: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x18052c: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x180530: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x180534: 0x0
    // NOP
    // 0x180538: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_180548;
    }
    // 0x180540: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180558;
    }
label_180548:
    // 0x180548: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18054c: 0x0
    // NOP
    // 0x180550: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[3]);
        goto label_180558;
    }
label_180558:
    // 0x180558: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18055c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x180560: 0x4601a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x180564: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x180568: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x18056c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x180570: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x180574: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x180578: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x18057c: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1805a0;
    }
label_180584:
    // 0x180584: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x180588: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18058c: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x180590: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x180594: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x180598: 0xe7a00030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x18059c: 0xe7a10034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
label_1805a0:
    // 0x1805a0: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1805a4: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1805a8: 0x26102280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8832));
    // 0x1805ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1805b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1805b4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1805bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1805bc
// Address: 0x1805bc - 0x1805e4

void entry_1805bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1805bc: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1805c0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1805c4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1805c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1805cc: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1805d0: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1805d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1805d8: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1805dc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1805e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1805e4
// Address: 0x1805e4 - 0x1805fc

void entry_1805e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1805e4: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1805e8: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1805ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1805f0: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1805f4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1805fc);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1805fc
// Address: 0x1805fc - 0x1808bc

void entry_1805fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1805fc) {
        switch (ctx->pc) {
            case 0x180608: ctx->pc = 0; goto label_180608;
            case 0x18065c: ctx->pc = 0; goto label_18065c;
            case 0x180690: ctx->pc = 0; goto label_180690;
            case 0x1806b8: ctx->pc = 0; goto label_1806b8;
            case 0x1806d0: ctx->pc = 0; goto label_1806d0;
            case 0x180708: ctx->pc = 0; goto label_180708;
            case 0x180730: ctx->pc = 0; goto label_180730;
            case 0x180748: ctx->pc = 0; goto label_180748;
            case 0x180780: ctx->pc = 0; goto label_180780;
            case 0x1807a8: ctx->pc = 0; goto label_1807a8;
            case 0x1807c0: ctx->pc = 0; goto label_1807c0;
            case 0x1807f8: ctx->pc = 0; goto label_1807f8;
            case 0x180820: ctx->pc = 0; goto label_180820;
            case 0x180844: ctx->pc = 0; goto label_180844;
            case 0x180884: ctx->pc = 0; goto label_180884;
            case 0x1808a0: ctx->pc = 0; goto label_1808a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1805fc: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x180600: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x180604: 0x0
    // NOP
label_180608:
    // 0x180608: 0xa21018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18060c: 0x24420064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 100));
    // 0x180610: 0x2a29021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x180614: 0x8a420003
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180618: 0x9a420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x18061c: 0xaba20053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180620: 0xbba20050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180624: 0x14a00087
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_180844;
    }
    // 0x18062c: 0x8a470003
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x180630: 0x9a470000
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x180634: 0xaba70073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180638: 0xbba70070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18063c: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x180640: 0xafa20080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 2));
    // 0x180644: 0x93a40070
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x180648: 0x93a30080
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18064c: 0x14830003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_18065c;
    }
    // 0x180654: 0x10000018
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1806b8;
    }
label_18065c:
    // 0x18065c: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[28], ctx->f[21]);
        goto label_180690;
    }
    // 0x180664: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x180668: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x18066c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x180670: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x180674: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180678: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x18067c: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x180680: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180684: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x180688: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1806b8;
    }
label_180690:
    // 0x180690: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x180694: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180698: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x18069c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1806a0: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1806a4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1806a8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1806ac: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1806b0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1806b4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1806b8:
    // 0x1806b8: 0x93a40071
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 113)));
    // 0x1806bc: 0x93a30081
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 129)));
    // 0x1806c0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 144), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1806d0;
    }
    // 0x1806c8: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180730;
    }
label_1806d0:
    // 0x1806d0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1806d4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[28], ctx->f[21]);
        goto label_180708;
    }
    // 0x1806dc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1806e0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1806e4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1806e8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1806ec: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1806f0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1806f4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1806f8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1806fc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x180700: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180730;
    }
label_180708:
    // 0x180708: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18070c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180710: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x180714: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x180718: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x18071c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x180720: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x180724: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180728: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18072c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_180730:
    // 0x180730: 0x93a40072
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 114)));
    // 0x180734: 0x93a30082
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 130)));
    // 0x180738: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 145), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_180748;
    }
    // 0x180740: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1807a8;
    }
label_180748:
    // 0x180748: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x18074c: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[28], ctx->f[21]);
        goto label_180780;
    }
    // 0x180754: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x180758: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x18075c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x180760: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x180764: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180768: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x18076c: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x180770: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180774: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x180778: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1807a8;
    }
label_180780:
    // 0x180780: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x180784: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180788: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x18078c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x180790: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180794: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x180798: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x18079c: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1807a0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1807a4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1807a8:
    // 0x1807a8: 0x93a40073
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 115)));
    // 0x1807ac: 0x93a30083
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 131)));
    // 0x1807b0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 146), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1807c0;
    }
    // 0x1807b8: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180820;
    }
label_1807c0:
    // 0x1807c0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1807c4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[28], ctx->f[21]);
        goto label_1807f8;
    }
    // 0x1807cc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1807d0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1807d4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1807d8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1807dc: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1807e0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1807e4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1807e8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1807ec: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1807f0: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180820;
    }
label_1807f8:
    // 0x1807f8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1807fc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180800: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x180804: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x180808: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x18080c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x180810: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x180814: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180818: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18081c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_180820:
    // 0x180820: 0xa3a20093
    WRITE8(ADD32(GPR_U32(ctx, 29), 147), (uint8_t)GPR_U32(ctx, 2));
    // 0x180824: 0x8ba20093
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 147); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180828: 0x9ba20090
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 144); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x18082c: 0xaba20063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180830: 0xbba20060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180834: 0x8ba70063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x180838: 0x9ba70060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x18083c: 0xaba70053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180840: 0xbba70050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
label_180844:
    // 0x180844: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x180848: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x18084c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x180850: 0x4600a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x180854: 0x0
    // NOP
    // 0x180858: 0x4500000a
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_180884;
    }
    // 0x180860: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x180864: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x180868: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18086c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180870: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x180874: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x180878: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x18087c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x180880: 0xa3a20053
    WRITE8(ADD32(GPR_U32(ctx, 29), 83), (uint8_t)GPR_U32(ctx, 2));
label_180884:
    // 0x180884: 0x54a00006
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        goto label_1808a0;
    }
    // 0x18088c: 0x8ba20053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180890: 0x9ba20050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x180894: 0xaba20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180898: 0xbba20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18089c: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1808a0:
    // 0x1808a0: 0x18400062
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x180A2C; return;
    }
    // 0x1808a8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1808ac: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1808b0: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1808b4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1808bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1808bc
// Address: 0x1808bc - 0x1808c8

void entry_1808bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1808bc: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1808c0: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1808c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1808c8
// Address: 0x1808c8 - 0x1808ec

void entry_1808c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1808c8: 0x83a20053
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    // 0x1808cc: 0x24030083
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 131));
    // 0x1808d0: 0x24050043
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 67));
    // 0x1808d4: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1808d8: 0x28420000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 0));
    // 0x1808dc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1808e0: 0x62280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1808e4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1808ec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1808ec
// Address: 0x1808ec - 0x18096c

void entry_1808ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1808ec) {
        switch (ctx->pc) {
            case 0x180938: ctx->pc = 0; goto label_180938;
            case 0x180948: ctx->pc = 0; goto label_180948;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1808ec: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1808f0: 0x1840004e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x180A2C; return;
    }
    // 0x1808f8: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1808fc: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x180900: 0x2416000c
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 12));
    // 0x180904: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x180908: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x18090c: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x180910: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x180914: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x180918: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x18091c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x180920: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x180924: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x180928: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x18092c: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x180930: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x180934: 0x961818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_180938:
    // 0x180938: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x18093c: 0x24930001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 4), 1));
    // 0x180940: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x180944: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_180948:
    // 0x180948: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18094c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x180950: 0x8ea50038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x180954: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x180958: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18095c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x180960: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x180964: 0xc0621d0
    SET_GPR_U32(ctx, 31, 0x18096c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G10VU_VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_18096c
// Address: 0x18096c - 0x1809b0

void entry_18096c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18096c: 0x7fa200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 2));
    // 0x180970: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x180974: 0x24e42280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 7), 8832));
    // 0x180978: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18097c: 0xc7a000a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[0] = *(float*)&val; }
    // 0x180980: 0xc7a100a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[1] = *(float*)&val; }
    // 0x180984: 0x461a0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x180988: 0x461b0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[27]);
    // 0x18098c: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x180990: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180994: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180998: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x18099c: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1809a0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1809a4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1809a8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1809b0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1809b0
// Address: 0x1809b0 - 0x180a50

void entry_1809b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1809b0) {
        switch (ctx->pc) {
            case 0x180a04: ctx->pc = 0; goto label_180a04;
            case 0x180a08: ctx->pc = 0; goto label_180a08;
            case 0x180a0c: ctx->pc = 0; goto label_180a0c;
            case 0x180a2c: ctx->pc = 0; goto label_180a2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1809b0: 0x16e00014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        goto label_180a04;
    }
    // 0x1809b8: 0xc7a000a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    // 0x1809bc: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1809c0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1809c4: 0x0
    // NOP
    // 0x1809c8: 0x4503000f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_180a08;
    }
    // 0x1809d0: 0x46180034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1809d4: 0x0
    // NOP
    // 0x1809d8: 0x4503000b
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_180a08;
    }
    // 0x1809e0: 0xc7a000a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[0] = *(float*)&val; }
    // 0x1809e4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1809e8: 0x0
    // NOP
    // 0x1809ec: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_180a08;
    }
    // 0x1809f4: 0x46170034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1809f8: 0x0
    // NOP
    // 0x1809fc: 0x45000003
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_180a0c;
    }
label_180a04:
    // 0x180a04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_180a08:
    // 0x180a08: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_180a0c:
    // 0x180a0c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x180a10: 0x621ffcd
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x180948; return;
    }
    // 0x180a18: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x180a1c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x180a20: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x180a24: 0x1440ffc4
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x180938; return;
    }
label_180a2c:
    // 0x180a2c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x180a30: 0x4a1fef5
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 5) >= 0) {
        ctx->pc = 0x180608; return;
    }
    // 0x180a38: 0x12e000e9
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        entry_180de0(rdram, ctx, runtime); return;
    }
    // 0x180a40: 0x7aa50040
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 21), 64)));
    // 0x180a44: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x180a48: 0xc0621d0
    SET_GPR_U32(ctx, 31, 0x180a50);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 8832));
    fn___ml__FRC7MATRIX4G10VU_VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_180a50
// Address: 0x180a50 - 0x180a6c

void entry_180a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180a50: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x180a54: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x180a58: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x180a5c: 0x7aa50050
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 21), 80)));
    // 0x180a60: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x180a64: 0xc0621d0
    SET_GPR_U32(ctx, 31, 0x180a6c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G10VU_VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_180a6c
// Address: 0x180a6c - 0x180ab4

void entry_180a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180a6c: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x180a70: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x180a74: 0x83a30043
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 67)));
    // 0x180a78: 0x24040084
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 132));
    // 0x180a7c: 0x24050044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    // 0x180a80: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x180a84: 0x28630000
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), 0));
    // 0x180a88: 0x2406000b
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 11));
    // 0x180a8c: 0x83280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 4));
    // 0x180a90: 0x24070444
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1092));
    // 0x180a94: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x180a98: 0x34e74444
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17476));
    // 0x180a9c: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x180aa0: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x180aa4: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x180aa8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x180aac: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x180ab4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_180ab4
// Address: 0x180ab4 - 0x180ac8

void entry_180ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ab4: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x180ab8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x180abc: 0x8fa50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x180ac0: 0xc058516
    SET_GPR_U32(ctx, 31, 0x180ac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_180ac8
// Address: 0x180ac8 - 0x180ae0

void entry_180ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ac8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180acc: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x180ad0: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x180ad4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180ad8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180ae0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180ae0
// Address: 0x180ae0 - 0x180b1c

void entry_180ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ae0: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x180ae4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180ae8: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x180aec: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180af0: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180af4: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180af8: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180afc: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180b00: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180b04: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180b08: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180b0c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180b10: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180b14: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180b1c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180b1c
// Address: 0x180b1c - 0x180b34

void entry_180b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180b1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180b20: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x180b24: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x180b28: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180b2c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180b34);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180b34
// Address: 0x180b34 - 0x180b70

void entry_180b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180b34: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x180b38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180b3c: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x180b40: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180b44: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180b48: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180b4c: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180b50: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180b54: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180b58: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180b5c: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180b60: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180b64: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180b68: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180b70);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180b70
// Address: 0x180b70 - 0x180b88

void entry_180b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180b70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180b74: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x180b78: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x180b7c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180b80: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180b88);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180b88
// Address: 0x180b88 - 0x180bc4

void entry_180b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180b88: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x180b8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180b90: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x180b94: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180b98: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180b9c: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180ba0: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180ba4: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180ba8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180bac: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180bb0: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180bb4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180bb8: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180bbc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180bc4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180bc4
// Address: 0x180bc4 - 0x180bdc

void entry_180bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180bc4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180bc8: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x180bcc: 0x34068700
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    // 0x180bd0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180bd4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180bdc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180bdc
// Address: 0x180bdc - 0x180c18

void entry_180bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180bdc: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x180be0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180be4: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x180be8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180bec: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180bf0: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180bf4: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180bf8: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180bfc: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180c00: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180c04: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180c08: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180c0c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180c10: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180c18);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180c18
// Address: 0x180c18 - 0x180c30

void entry_180c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180c18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180c1c: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x180c20: 0x24067900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    // 0x180c24: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180c28: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180c30);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180c30
// Address: 0x180c30 - 0x180c6c

void entry_180c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180c30: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x180c34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180c38: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x180c3c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180c40: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180c44: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180c48: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180c4c: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180c50: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180c54: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180c58: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180c5c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180c60: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180c64: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180c6c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180c6c
// Address: 0x180c6c - 0x180ce4

void entry_180c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180c6c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x180c70: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x180c74: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x180c78: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x180c7c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x180c80: 0x46151881
    ctx->f[2] = FPU_SUB_S(ctx->f[3], ctx->f[21]);
    // 0x180c84: 0x46001036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x180c88: 0x0
    // NOP
    // 0x180c8c: 0x45000054
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_180de0(rdram, ctx, runtime); return;
    }
    // 0x180c94: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x180c98: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x180c9c: 0x8ba20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180ca0: 0x9ba20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x180ca4: 0xaba20073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180ca8: 0xbba20070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180cac: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x180cb0: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x180cb4: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x180cb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180cbc: 0x93a20073
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 115)));
    // 0x180cc0: 0x24050044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    // 0x180cc4: 0x46011841
    ctx->f[1] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x180cc8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x180ccc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x180cd0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x180cd4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180cd8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x180cdc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x180ce4);
    WRITE8(ADD32(GPR_U32(ctx, 29), 115), (uint8_t)GPR_U32(ctx, 2));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_180ce4
// Address: 0x180ce4 - 0x180cf0

void entry_180ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ce4: 0x8fa50070
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x180ce8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x180cf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_180cf0
// Address: 0x180cf0 - 0x180d2c

void entry_180cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180cf0: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x180cf4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180cf8: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x180cfc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180d00: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180d04: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180d08: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180d0c: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180d10: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180d14: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180d18: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180d1c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180d20: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180d24: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180d2c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180d2c
// Address: 0x180d2c - 0x180d68

void entry_180d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180d2c: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x180d30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180d34: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x180d38: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180d3c: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180d40: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180d44: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180d48: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180d4c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180d50: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180d54: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180d58: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180d5c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180d60: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180d68);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180d68
// Address: 0x180d68 - 0x180da4

void entry_180d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180d68: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x180d6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180d70: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x180d74: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180d78: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180d7c: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180d80: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180d84: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180d88: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180d8c: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180d90: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180d94: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180d98: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180d9c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180da4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180da4
// Address: 0x180da4 - 0x180de0

void entry_180da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180da4: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x180da8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180dac: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x180db0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180db4: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x180db8: 0x46170840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[23]);
    // 0x180dbc: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x180dc0: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x180dc4: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x180dc8: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x180dcc: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x180dd0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x180dd4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x180dd8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x180de0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_180de0
// Address: 0x180de0 - 0x180e38

void entry_180de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180de0: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x180de4: 0x7bbe0130
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x180de8: 0x7bb70120
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x180dec: 0x7bb60110
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x180df0: 0x7bb50100
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x180df4: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x180df8: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x180dfc: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x180e00: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x180e04: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x180e08: 0xc7bc0190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[28] = *(float*)&val; }
    // 0x180e0c: 0xc7bb0188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[27] = *(float*)&val; }
    // 0x180e10: 0xc7ba0180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[26] = *(float*)&val; }
    // 0x180e14: 0xc7b90178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[25] = *(float*)&val; }
    // 0x180e18: 0xc7b80170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[24] = *(float*)&val; }
    // 0x180e1c: 0xc7b70168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[23] = *(float*)&val; }
    // 0x180e20: 0xc7b60160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[22] = *(float*)&val; }
    // 0x180e24: 0xc7b50158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[21] = *(float*)&val; }
    // 0x180e28: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x180e2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x180e34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x180e38; return;
}


// Function: keyhole__static_initialization_and_destruction_0
// Address: 0x180e38 - 0x180e90

void FUN_00180e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180e90: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x180e94: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x180e98: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x180e9c: 0xc06038e
    SET_GPR_U32(ctx, 31, 0x180ea4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    keyhole__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_180ea4
// Address: 0x180ea4 - 0x180eb0

void entry_180ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ea4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x180ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnLandingAdd__FP7LANDING
// Address: 0x180eb0 - 0x180ec4

void entry_180ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ec4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x180ec8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180ecc: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x180ed4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7324));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_180ed4
// Address: 0x180ed4 - 0x180ee8

void entry_180ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180ed4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x180ed8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x180edc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x180ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x180ee8; return;
}


// Function: OnLandingRemove__FP7LANDING
// Address: 0x180ee8 - 0x180efc

void entry_180efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180efc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x180f00: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180f04: 0xc054980
    SET_GPR_U32(ctx, 31, 0x180f0c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7324));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_180f0c
// Address: 0x180f0c - 0x180f20

void entry_180f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180f0c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x180f10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x180f14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x180f1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x180f20; return;
}


// Function: CloneLanding__FP7LANDINGT0
// Address: 0x180f20 - 0x180f48

void entry_180f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180f48: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x180f4c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x180f50: 0xb202003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x180f54: 0xb6020038
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x180f58: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x180f5c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x180f60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitLgn__FP3LGN
// Address: 0x180f68 - 0x180f7c

void entry_180f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180f7c: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x180f80: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x180f84: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x180f88: 0xe6000bf4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3060), *(uint32_t*)&val); }
    // 0x180f8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x180f90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLgnLoad__FP3LGN
// Address: 0x180f98 - 0x180fb0

void entry_180fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180fb0: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x180fb4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180fb8: 0x24c640b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16560));
    // 0x180fbc: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x180fc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_180fc4
// Address: 0x180fc4 - 0x180fd8

void entry_180fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180fc4: 0x8e040bb8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3000)));
    // 0x180fc8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x180fcc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x180fd0: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x180fd8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_180fd8
// Address: 0x180fd8 - 0x180fec

void entry_180fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180fd8: 0x8e040bcc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3020)));
    // 0x180fdc: 0x26060bd0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 3024));
    // 0x180fe0: 0xae020bbc
    WRITE32(ADD32(GPR_U32(ctx, 16), 3004), GPR_U32(ctx, 2));
    // 0x180fe4: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x180fec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_180fec
// Address: 0x180fec - 0x181014

void entry_180fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x180fec: 0x8e030bd0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3024)));
    // 0x180ff0: 0x24040009
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 9));
    // 0x180ff4: 0xa0640010
    WRITE8(ADD32(GPR_U32(ctx, 3), 16), (uint8_t)GPR_U32(ctx, 4));
    // 0x180ff8: 0x8e020bd0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3024)));
    // 0x180ffc: 0xa0440011
    WRITE8(ADD32(GPR_U32(ctx, 2), 17), (uint8_t)GPR_U32(ctx, 4));
    // 0x181000: 0x8e040bcc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3020)));
    // 0x181004: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181008: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x18100c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181014);
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181014
// Address: 0x181014 - 0x18102c

void entry_181014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181014: 0x8e060bcc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 3020)));
    // 0x181018: 0x26070be0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 3040));
    // 0x18101c: 0x8e050bc0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3008)));
    // 0x181020: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x181024: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x18102c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_18102c
// Address: 0x18102c - 0x181038

void entry_18102c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18102c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181030: 0xc06076a
    SET_GPR_U32(ctx, 31, 0x181038);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime); return;
}


// Function: entry_181038
// Address: 0x181038 - 0x181060

void entry_181038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181038: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x18103c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x181040: 0xc441b164
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294947172)); ctx->f[1] = *(float*)&val; }
    // 0x181044: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x181048: 0x26310650
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1616));
    // 0x18104c: 0xe6010864
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 2148), *(uint32_t*)&val); }
    // 0x181050: 0xaa22028b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 651); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x181054: 0xba220288
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 648); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x181058: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x181060);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 874));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_181060
// Address: 0x181060 - 0x181078

void entry_181060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181060: 0xae220284
    WRITE32(ADD32(GPR_U32(ctx, 17), 644), GPR_U32(ctx, 2));
    // 0x181064: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181068: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18106c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181070: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateLgnActive__FP3LGNP3JOYf
// Address: 0x181078 - 0x1810a4

void entry_1810a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1810a4: 0x27b20090
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1810a8: 0x8e640bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    // 0x1810ac: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1810b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1810b4
// Address: 0x1810b4 - 0x1810c4

void entry_1810b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1810b4: 0x27b10094
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 148));
    // 0x1810b8: 0x8e640bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    // 0x1810bc: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1810c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1810c4
// Address: 0x1810c4 - 0x1810fc

void entry_1810c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1810c4) {
        switch (ctx->pc) {
            case 0x1810e4: ctx->pc = 0; goto label_1810e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1810c4: 0x8e630bb0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2992)));
    // 0x1810c8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1810cc: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1810e4;
    }
    // 0x1810d4: 0x1062000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x181114; return;
    }
    // 0x1810dc: 0x1000003a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966433));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1811C8; return;
    }
label_1810e4:
    // 0x1810e4: 0x960200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x1810e8: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x1810ec: 0x10400005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181104; return;
    }
    // 0x1810f4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1810fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 864));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1810fc
// Address: 0x1810fc - 0x18110c

void entry_1810fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1810fc) {
        switch (ctx->pc) {
            case 0x181104: ctx->pc = 0; goto label_181104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1810fc: 0x10000031
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1811C4; return;
    }
label_181104:
    // 0x181104: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x18110c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 863));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_18110c
// Address: 0x18110c - 0x181134

void entry_18110c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18110c) {
        switch (ctx->pc) {
            case 0x181114: ctx->pc = 0; goto label_181114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18110c: 0x1000002d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1811C4; return;
    }
label_181114:
    // 0x181114: 0x8fa30090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x181118: 0x2402035f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 863));
    // 0x18111c: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x18113C; return;
    }
    // 0x181124: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x181128: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x18112c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181134);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181134
// Address: 0x181134 - 0x181150

void entry_181134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181134) {
        switch (ctx->pc) {
            case 0x18113c: ctx->pc = 0; goto label_18113c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181134: 0x10000023
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1811C4; return;
    }
label_18113c:
    // 0x18113c: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x181140: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18115C; return;
    }
    // 0x181148: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x181150);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_181150
// Address: 0x181150 - 0x18119c

void entry_181150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181150) {
        switch (ctx->pc) {
            case 0x18115c: ctx->pc = 0; goto label_18115c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181150: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181154: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x181158: 0xe6600bfc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 3068), *(uint32_t*)&val); }
label_18115c:
    // 0x18115c: 0x8e620c00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3072)));
    // 0x181160: 0x10400017
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1811c0(rdram, ctx, runtime); return;
    }
    // 0x181168: 0xc6620bfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 3068)); ctx->f[2] = *(float*)&val; }
    // 0x18116c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x181170: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181174: 0xc4414128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16680)); ctx->f[1] = *(float*)&val; }
    // 0x181178: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x18117c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181180: 0x0
    // NOP
    // 0x181184: 0x4500000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1811C4; return;
    }
    // 0x18118c: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x181190: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x181194: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18119c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18119c
// Address: 0x18119c - 0x1811a8

void entry_18119c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18119c: 0x8e640bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    // 0x1811a0: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1811a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 863));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1811a8
// Address: 0x1811a8 - 0x1811b4

void entry_1811a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1811a8: 0x8e640bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    // 0x1811ac: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1811b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1811b4
// Address: 0x1811b4 - 0x1811c0

void entry_1811b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1811b4: 0x8e640bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3004)));
    // 0x1811b8: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1811c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1811c0
// Address: 0x1811c0 - 0x181214

void entry_1811c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1811c0) {
        switch (ctx->pc) {
            case 0x1811c4: ctx->pc = 0; goto label_1811c4;
            case 0x1811c8: ctx->pc = 0; goto label_1811c8;
            case 0x1811f0: ctx->pc = 0; goto label_1811f0;
            case 0x181208: ctx->pc = 0; goto label_181208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1811c0: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
label_1811c4:
    // 0x1811c4: 0x2442fca1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966433));
label_1811c8:
    // 0x1811c8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1811cc: 0x10400095
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_181424(rdram, ctx, runtime); return;
    }
    // 0x1811d4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1811d8: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 863));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1811f0;
    }
    // 0x1811e0: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 864));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1811f0;
    }
    // 0x1811e8: 0x1462008f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x181428; return;
    }
label_1811f0:
    // 0x1811f0: 0x8e630bb0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 2992)));
    // 0x1811f4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1811f8: 0x14620003
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_181208;
    }
    // 0x181200: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181204: 0x24502d38
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 11576));
label_181208:
    // 0x181208: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18120c: 0xc0607b4
    SET_GPR_U32(ctx, 31, 0x181214);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1616));
    UpdateLgnrAim__FP4LGNRP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_181214
// Address: 0x181214 - 0x1812c0

void entry_181214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181214) {
        switch (ctx->pc) {
            case 0x181280: ctx->pc = 0; goto label_181280;
            case 0x18128c: ctx->pc = 0; goto label_18128c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181214: 0xda630130
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 304)));
    // 0x181218: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18121c: 0x7a640120
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 19), 288)));
    // 0x181220: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x181224: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x181228: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18122c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x181230: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x181234: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x181238: 0xd8610080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    // 0x18123c: 0x4bc11afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x181240: 0x4bc3086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x181244: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181248: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18124c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x181250: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x181254: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x181258: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18125c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x181260: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x181264: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x181268: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18126c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181270: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_181280;
    }
    // 0x181278: 0x10000004
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18128c;
    }
label_181280:
    // 0x181280: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x181284: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x181288: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_18128c:
    // 0x18128c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181290: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181294: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x181298: 0x4bc2086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18129c: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1812a0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1812a4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1812a8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1812ac: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1812b0: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x1812b4: 0x8e620bc4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3012)));
    // 0x1812b8: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1812c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1812c0
// Address: 0x1812c0 - 0x1812e4

void entry_1812c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1812c0: 0x8e640bc4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3012)));
    // 0x1812c4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1812c8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1812cc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1812d0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1812d4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1812d8: 0x24c64130
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16688));
    // 0x1812dc: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x1812e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 208));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_1812e4
// Address: 0x1812e4 - 0x1812f8

void entry_1812e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1812e4: 0x8e640bc4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3012)));
    // 0x1812e8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1812ec: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1812f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1812f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1812f8
// Address: 0x1812f8 - 0x18130c

void entry_1812f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1812f8: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1812fc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x181300: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x181304: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x18130c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2240));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_18130c
// Address: 0x18130c - 0x181338

void entry_18130c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18130c: 0x8e620bc0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x181310: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x181314: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181318: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18131c: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x181320: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181324: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181328: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18132c: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x181330: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x181338);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_181338
// Address: 0x181338 - 0x181350

void entry_181338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181338: 0x8e620bc0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x18133c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181340: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181344: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x181348: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x181350);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_181350
// Address: 0x181350 - 0x181364

void entry_181350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181350: 0x8e640bc0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x181354: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181358: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x18135c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181364);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181364
// Address: 0x181364 - 0x1813b8

void entry_181364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181364: 0xda630be0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 3040)));
    // 0x181368: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18136c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181370: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181374: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181378: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x18137c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x181380: 0x4bc3104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x181384: 0x8e42413c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16700)));
    // 0x181388: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18138c: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181390: 0x8e630bc0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x181394: 0x4be50858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181398: 0x8e620bcc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3020)));
    // 0x18139c: 0x8e670bd0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 3024)));
    // 0x1813a0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1813a4: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1813a8: 0x24e70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 32));
    // 0x1813ac: 0x8c640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1813b0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1813b8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1813b8
// Address: 0x1813b8 - 0x1813d0

void entry_1813b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1813b8: 0x8e640bc0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x1813bc: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1813c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1813c4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1813c8: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1813d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 416));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1813d0
// Address: 0x1813d0 - 0x1813ec

void entry_1813d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1813d0: 0x8e630bc0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 3008)));
    // 0x1813d4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1813d8: 0x8e620bcc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 3020)));
    // 0x1813dc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1813e0: 0x8c640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1813e4: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x1813ec);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_1813ec
// Address: 0x1813ec - 0x181400

void entry_1813ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1813ec: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1813f0: 0x27a50098
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 152));
    // 0x1813f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1813f8: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x181400);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_181400
// Address: 0x181400 - 0x18141c

void entry_181400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181400: 0xc640413c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16700)); ctx->f[0] = *(float*)&val; }
    // 0x181404: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x181408: 0xc7ac0098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[12] = *(float*)&val; }
    // 0x18140c: 0x8e650bd0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 3024)));
    // 0x181410: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x181414: 0xc062214
    SET_GPR_U32(ctx, 31, 0x18141c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_18141c
// Address: 0x18141c - 0x181424

void entry_18141c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18141c: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x181424);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_181424
// Address: 0x181424 - 0x181448

void entry_181424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181424) {
        switch (ctx->pc) {
            case 0x181428: ctx->pc = 0; goto label_181428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181424: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_181428:
    // 0x181428: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18142c: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x181430: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x181434: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x181438: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x18143c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181448; return;
}


// Function: UpdateLgn__FP3LGNf
// Address: 0x181448 - 0x181490

void entry_181490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181490) {
        switch (ctx->pc) {
            case 0x1814b0: ctx->pc = 0; goto label_1814b0;
            case 0x1814c8: ctx->pc = 0; goto label_1814c8;
            case 0x1814f8: ctx->pc = 0; goto label_1814f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181490: 0x8e450c04
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3076)));
    // 0x181494: 0x10a00032
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181560; return;
    }
    // 0x18149c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1814a0: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1814a4: 0x24160004
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1814a8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1814ac: 0x0
    // NOP
label_1814b0:
    // 0x1814b0: 0x521026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1814b4: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1814b8: 0x2621023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1814bc: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1814c0: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1814c4: 0x8c500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_1814c8:
    // 0x1814c8: 0x5200001e
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x181544; return;
    }
    // 0x1814d0: 0x8e0204e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1248)));
    // 0x1814d4: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_1814c8;
    }
    // 0x1814dc: 0x52000019
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x181544; return;
    }
    // 0x1814e4: 0x10530004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        goto label_1814f8;
    }
    // 0x1814ec: 0x54560015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x181544; return;
    }
    // 0x1814f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1814f8:
    // 0x1814f8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1814fc: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x181504);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_181504
// Address: 0x181504 - 0x181524

void entry_181504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181504) {
        switch (ctx->pc) {
            case 0x181508: ctx->pc = 0; goto label_181508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181504: 0x0
    // NOP
label_181508:
    // 0x181508: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18152C; return;
    }
    // 0x181510: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x181514: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x181518: 0x8c62012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 300)));
    // 0x18151c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181524);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181524
// Address: 0x181524 - 0x181540

void entry_181524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181524) {
        switch (ctx->pc) {
            case 0x18152c: ctx->pc = 0; goto label_18152c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181524: 0x5040fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x181508; return;
    }
label_18152c:
    // 0x18152c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x181530: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x181534: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x181538: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181540);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181540
// Address: 0x181540 - 0x181558

void entry_181540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181540) {
        switch (ctx->pc) {
            case 0x181544: ctx->pc = 0; goto label_181544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181540: 0x8e3100d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
label_181544:
    // 0x181544: 0x5620ffda
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1814B0; return;
    }
    // 0x18154c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x181550: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x181558);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3076)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_181558
// Address: 0x181558 - 0x1815d0

void entry_181558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181558) {
        switch (ctx->pc) {
            case 0x181560: ctx->pc = 0; goto label_181560;
            case 0x1815ac: ctx->pc = 0; goto label_1815ac;
            case 0x1815c0: ctx->pc = 0; goto label_1815c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181558: 0xae400c04
    WRITE32(ADD32(GPR_U32(ctx, 18), 3076), GPR_U32(ctx, 0));
    // 0x18155c: 0x26e21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
label_181560:
    // 0x181560: 0xc6430bf4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3060)); ctx->f[3] = *(float*)&val; }
    // 0x181564: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x181568: 0x26a34140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 16704));
    // 0x18156c: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x181570: 0x26825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 23648));
    // 0x181574: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x181578: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18157c: 0xc6a34140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 16704)); ctx->f[3] = *(float*)&val; }
    // 0x181580: 0xc68c5c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 23648)); ctx->f[12] = *(float*)&val; }
    // 0x181584: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x181588: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x18158c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x181590: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x181594: 0x460c1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181598: 0x0
    // NOP
    // 0x18159c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1815ac;
    }
    // 0x1815a4: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1815c0;
    }
label_1815ac:
    // 0x1815ac: 0x46032034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1815b0: 0x0
    // NOP
    // 0x1815b4: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1815c0;
    }
    // 0x1815bc: 0x46002506
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
label_1815c0:
    // 0x1815c0: 0xc7cc4150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 16720)); ctx->f[12] = *(float*)&val; }
    // 0x1815c4: 0x8e440bcc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3020)));
    // 0x1815c8: 0xc04a784
    SET_GPR_U32(ctx, 31, 0x1815d0);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    SetAloPositionSpring__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1815d0
// Address: 0x1815d0 - 0x1815e4

void entry_1815d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1815d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1815d4: 0x8e440bcc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3020)));
    // 0x1815d8: 0xc44c4154
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16724)); ctx->f[12] = *(float*)&val; }
    // 0x1815dc: 0xc04a7ec
    SET_GPR_U32(ctx, 31, 0x1815e4);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    SetAloRotationSpring__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1815e4
// Address: 0x1815e4 - 0x181658

void entry_1815e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1815e4) {
        switch (ctx->pc) {
            case 0x181620: ctx->pc = 0; goto label_181620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1815e4: 0x8e420bf0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3056)));
    // 0x1815e8: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_181620;
    }
    // 0x1815f0: 0x8e430bb0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2992)));
    // 0x1815f4: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_181620;
    }
    // 0x1815fc: 0xc6420bf8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3064)); ctx->f[2] = *(float*)&val; }
    // 0x181600: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x181604: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x181608: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18160c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x181610: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181614: 0x0
    // NOP
    // 0x181618: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 3056), GPR_U32(ctx, 0));
        goto label_181620;
    }
label_181620:
    // 0x181620: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x181624: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x181628: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18162c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x181630: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x181634: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x181638: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18163c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181640: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181644: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181648: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x18164c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181654: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181658; return;
}


// Function: FUN_00181658
// Address: 0x181658 - 0x181674

void FUN_00181658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181658: 0x27bdfee0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967008));
    // 0x18165c: 0x7fb20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 18));
    // 0x181660: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x181664: 0x7fbf0110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 31));
    // 0x181668: 0x7fb100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 17));
    // 0x18166c: 0xc076b86
    SET_GPR_U32(ctx, 31, 0x181674);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 16));
    UpdateSuvXfWorld__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_181674
// Address: 0x181674 - 0x1816b0

void entry_181674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181674: 0x8e440830
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 2096)));
    // 0x181678: 0x1080003b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181768; return;
    }
    // 0x181680: 0x8e420c08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3080)));
    // 0x181684: 0x50400039
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
        ctx->pc = 0x18176C; return;
    }
    // 0x18168c: 0x8c840034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 52)));
    // 0x181690: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181694: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x181698: 0x10400005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1816b0(rdram, ctx, runtime); return;
    }
    // 0x1816a0: 0xc64c0838
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2104)); ctx->f[12] = *(float*)&val; }
    // 0x1816a4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1816a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1816b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1816b0
// Address: 0x1816b0 - 0x1816c4

void entry_1816b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1816b0: 0x8e450c08
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 3080)));
    // 0x1816b4: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1816b8: 0x264401a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 416));
    // 0x1816bc: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1816c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 416));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1816c4
// Address: 0x1816c4 - 0x1816dc

void entry_1816c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1816c4: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1816c8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1816cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1816d0: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1816d4: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1816dc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1816dc
// Address: 0x1816dc - 0x181750

void entry_1816dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1816dc: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1816e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1816e4: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1816e8: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1816ec: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1816f0: 0xdba60060
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1816f4: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1816f8: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1816fc: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x181700: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x181704: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x181708: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18170c: 0xdba40070
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x181710: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x181714: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x181718: 0x4bc408ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18171c: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x181720: 0xfba60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x181724: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x181728: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x18172c: 0xfba60090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x181730: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x181734: 0x8e440c08
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3080)));
    // 0x181738: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x18173c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181740: 0xfba600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x181744: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x181748: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181750);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181750
// Address: 0x181750 - 0x181764

void entry_181750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181750: 0x8e440c08
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3080)));
    // 0x181754: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181758: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x18175c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181764);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181764
// Address: 0x181764 - 0x181780

void entry_181764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181764) {
        switch (ctx->pc) {
            case 0x181768: ctx->pc = 0; goto label_181768;
            case 0x18176c: ctx->pc = 0; goto label_18176c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181764: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_181768:
    // 0x181768: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
label_18176c:
    // 0x18176c: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x181770: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x181774: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18177c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181780; return;
}


// Function: OnLgnActive__FP3LGNiP2PO
// Address: 0x181780 - 0x18179c

void entry_18179c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18179c: 0x12000012
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1817E8; return;
    }
    // 0x1817a4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1817a8: 0x8e030650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x1817ac: 0x26100650
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1616));
    // 0x1817b0: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1817b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1817bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1817bc
// Address: 0x1817bc - 0x181800

void entry_1817bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1817bc) {
        switch (ctx->pc) {
            case 0x1817e8: ctx->pc = 0; goto label_1817e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1817bc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1817c0: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1817c4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1817c8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1817cc: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1817d0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1817d4: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1817d8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1817dc: 0x7e020270
    WRITE128(ADD32(GPR_U32(ctx, 16), 624), GPR_VEC(ctx, 2));
    // 0x1817e0: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181804; return;
    }
label_1817e8:
    // 0x1817e8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1817ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1817f0: 0x8c830650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1616)));
    // 0x1817f4: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1817f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181800);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1616));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181800
// Address: 0x181800 - 0x181818

void entry_181800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181800) {
        switch (ctx->pc) {
            case 0x181804: ctx->pc = 0; goto label_181804;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181800: 0xae200bf0
    WRITE32(ADD32(GPR_U32(ctx, 17), 3056), GPR_U32(ctx, 0));
label_181804:
    // 0x181804: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181808: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18180c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181810: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderLgnAll__FP3LGNP2CMP2RO
// Address: 0x181818 - 0x1818a4

void entry_1818a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1818a4) {
        switch (ctx->pc) {
            case 0x181900: ctx->pc = 0; goto label_181900;
            case 0x181944: ctx->pc = 0; goto label_181944;
            case 0x181954: ctx->pc = 0; goto label_181954;
            case 0x181a08: ctx->pc = 0; goto label_181a08;
            case 0x181a20: ctx->pc = 0; goto label_181a20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1818a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1818a8: 0x46000186
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    // 0x1818ac: 0x24434160
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16736));
    // 0x1818b0: 0xc4424160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16736)); ctx->f[2] = *(float*)&val; }
    // 0x1818b4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1818b8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1818bc: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1818c0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1818c4: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1818c8: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1818cc: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1818d0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1818d4: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1818d8: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1818dc: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1818e0: 0x0
    // NOP
    // 0x1818e4: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_181900;
    }
    // 0x1818ec: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1818f0: 0x0
    // NOP
    // 0x1818f4: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_181900;
    }
    // 0x1818fc: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_181900:
    // 0x181900: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181904: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x181908: 0x24434170
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16752));
    // 0x18190c: 0xc4424170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16752)); ctx->f[2] = *(float*)&val; }
    // 0x181910: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x181914: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x181918: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18191c: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x181920: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x181924: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x181928: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x18192c: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181930: 0x0
    // NOP
    // 0x181934: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_181944;
    }
    // 0x18193c: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_181954;
    }
label_181944:
    // 0x181944: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181948: 0x0
    // NOP
    // 0x18194c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_181954;
    }
label_181954:
    // 0x181954: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181958: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x18195c: 0x904323e0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 9184)));
    // 0x181960: 0x244423e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x181964: 0x93a20010
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181968: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x18196c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x181970: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x181974: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x181978: 0x90830002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 2)));
    // 0x18197c: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x181980: 0x46802960
    ctx->f[5] = FPU_CVT_S_W(*(int32_t*)&ctx->f[5]);
    // 0x181984: 0x93a50012
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x181988: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x18198c: 0x90860001
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 1)));
    // 0x181990: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x181994: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x181998: 0x93a70011
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x18199c: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1819a0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1819a4: 0x44863800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 6);
    // 0x1819a8: 0x468039e0
    ctx->f[7] = FPU_CVT_S_W(*(int32_t*)&ctx->f[7]);
    // 0x1819ac: 0x90820003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 3)));
    // 0x1819b0: 0x44873000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 7);
    // 0x1819b4: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x1819b8: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1819bc: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x1819c0: 0x46052142
    ctx->f[5] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x1819c4: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1819c8: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1819cc: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1819d0: 0x46062102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[6]);
    // 0x1819d4: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x1819d8: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1819dc: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1819e0: 0x46001864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[3]);
    // 0x1819e4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1819e8: 0x46001064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1819ec: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1819f0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1819f4: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1819f8: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1819fc: 0xa3a30002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 3));
    // 0x181a00: 0x10000007
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_181a20;
    }
label_181a08:
    // 0x181a08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181a0c: 0x244623e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x181a10: 0x88c30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x181a14: 0x98c30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x181a18: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x181a1c: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
label_181a20:
    // 0x181a20: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181a24: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x181a2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_181a2c
// Address: 0x181a2c - 0x181a3c

void entry_181a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181a2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181a30: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x181a34: 0xc049724
    SET_GPR_U32(ctx, 31, 0x181a3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_181a3c
// Address: 0x181a3c - 0x181a58

void entry_181a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181a3c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x181a40: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x181a44: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181a48: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181a4c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x181a50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetLgnCpdefi__FP3LGNfP6CPDEFI
// Address: 0x181a58 - 0x181a74

void entry_181a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181a74: 0x8e030bc0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3008)));
    // 0x181a78: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181a7c: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x181a80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181a84: 0x7e220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 2));
    // 0x181a88: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181a8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181a94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181a98; return;
}


// Function: FInvulnerableLgn__FP3LGN3ZPK
// Address: 0x181a98 - 0x181ac4

void entry_181ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181ac4) {
        switch (ctx->pc) {
            case 0x181ad0: ctx->pc = 0; goto label_181ad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181ac4: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_181ad0;
    }
    // 0x181acc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_181ad0:
    // 0x181ad0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181ad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181adc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181ae0; return;
}


// Function: JthsCurrentLgn__FP3LGN
// Address: 0x181ae0 - 0x181af0

void entry_181b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181b08: 0xc06076a
    SET_GPR_U32(ctx, 31, 0x181b10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime); return;
}


// Function: entry_181b10
// Address: 0x181b10 - 0x181b20

void entry_181b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b10: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181b14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181b18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyLgnThrow__FP3LGNP2PO
// Address: 0x181b20 - 0x181b48

void entry_181b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181b4c: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x181b50: 0xc44c4190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16784)); ctx->f[12] = *(float*)&val; }
    // 0x181b54: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181b58: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x181b5c: 0xc06f098
    SET_GPR_U32(ctx, 31, 0x181b64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateSoTrajectoryApex__FP2SOP6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_181b64
// Address: 0x181b64 - 0x181b78

void entry_181b64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b64: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x181b68: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x181b6c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x181b70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181b78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181b78
// Address: 0x181b78 - 0x181b84

void entry_181b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b78: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x181b7c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x181b84);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_181b84
// Address: 0x181b84 - 0x181b98

void entry_181b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b84: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x181b88: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x181b8c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x181b90: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x181b98);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_181b98
// Address: 0x181b98 - 0x181ba4

void entry_181b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181b98: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x181b9c: 0xc071756
    SET_GPR_U32(ctx, 31, 0x181ba4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_181ba4
// Address: 0x181ba4 - 0x181bb4

void entry_181ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181ba4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181ba8: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x181bac: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x181bb4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_181bb4
// Address: 0x181bb4 - 0x181bc8

void entry_181bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181bb4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x181bb8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181bbc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181bc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FTakeLgnDamage__FP3LGNP3ZPR
// Address: 0x181bc8 - 0x181bf4

void entry_181bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181bf4: 0x14400045
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x181D0C; return;
    }
    // 0x181bfc: 0xc058316
    SET_GPR_U32(ctx, 31, 0x181c04);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_181c04
// Address: 0x181c04 - 0x181c20

void entry_181c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181c04) {
        switch (ctx->pc) {
            case 0x181c10: ctx->pc = 0; goto label_181c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181c04: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_181c10;
    }
    // 0x181c0c: 0xae020bf0
    WRITE32(ADD32(GPR_U32(ctx, 16), 3056), GPR_U32(ctx, 2));
label_181c10:
    // 0x181c10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x181c14: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x181c18: 0xc058316
    SET_GPR_U32(ctx, 31, 0x181c20);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3060), *(uint32_t*)&val); }
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_181c20
// Address: 0x181c20 - 0x181c44

void entry_181c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181c20) {
        switch (ctx->pc) {
            case 0x181c3c: ctx->pc = 0; goto label_181c3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181c20: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_181c3c;
    }
    // 0x181c28: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x181c2c: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x181c30: 0x54800006
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        ctx->pc = 0x181C4C; return;
    }
    // 0x181c38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_181c3c:
    // 0x181c3c: 0xc06076a
    SET_GPR_U32(ctx, 31, 0x181c44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime); return;
}


// Function: entry_181c44
// Address: 0x181c44 - 0x181c58

void entry_181c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181c44) {
        switch (ctx->pc) {
            case 0x181c4c: ctx->pc = 0; goto label_181c4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181c44: 0x10000028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181CE8; return;
    }
label_181c4c:
    // 0x181c4c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x181c50: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181c58);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181c58
// Address: 0x181c58 - 0x181c6c

void entry_181c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181c58: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x181c5c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181c60: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x181c64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181c6c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3016)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181c6c
// Address: 0x181c6c - 0x181c80

void entry_181c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181c6c: 0x8e040bc8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3016)));
    // 0x181c70: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x181c74: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x181c78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181c80);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181c80
// Address: 0x181c80 - 0x181c8c

void entry_181c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181c80: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x181c84: 0xc064a64
    SET_GPR_U32(ctx, 31, 0x181c8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetPoPlayable__FP2POi(rdram, ctx, runtime); return;
}


// Function: entry_181c8c
// Address: 0x181c8c - 0x181c9c

void entry_181c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181c8c: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x181c90: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x181c94: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x181c9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_181c9c
// Address: 0x181c9c - 0x181ca4

void entry_181c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181c9c: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x181ca4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_181ca4
// Address: 0x181ca4 - 0x181cb0

void entry_181ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181ca4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181ca8: 0xc06076a
    SET_GPR_U32(ctx, 31, 0x181cb0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime); return;
}


// Function: entry_181cb0
// Address: 0x181cb0 - 0x181cc0

void entry_181cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181cb0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181cb4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x181cb8: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x181cc0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_181cc0
// Address: 0x181cc0 - 0x181ce4

void entry_181cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181cc0: 0x3c020018
    SET_GPR_U32(ctx, 2, ((uint32_t)24 << 16));
    // 0x181cc4: 0x8e262e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x181cc8: 0x24421b20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6944));
    // 0x181ccc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181cd0: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x181cd4: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x181cd8: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x181cdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x181ce4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_181ce4
// Address: 0x181ce4 - 0x181d08

void entry_181ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181ce4) {
        switch (ctx->pc) {
            case 0x181ce8: ctx->pc = 0; goto label_181ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181ce4: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_181ce8:
    // 0x181ce8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x181cec: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x181cf0: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x181cf4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x181cf8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x181cfc: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x181d00: 0x60f809
    SET_GPR_U32(ctx, 31, 0x181d08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_181d08
// Address: 0x181d08 - 0x181d28

void entry_181d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181d08) {
        switch (ctx->pc) {
            case 0x181d0c: ctx->pc = 0; goto label_181d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181d08: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_181d0c:
    // 0x181d0c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x181d10: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181d14: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181d18: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181d1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181d24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181d28; return;
}


// Function: HandleLgnMessage__FP3LGN5MSGIDPv
// Address: 0x181d28 - 0x181d7c

void entry_181d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181d7c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181d80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00181d88
// Address: 0x181d88 - 0x181d98

void FUN_00181d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181d88: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x181d8c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x181d90: 0xc06f136
    SET_GPR_U32(ctx, 31, 0x181d98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 3076));
    FUN_001bc4d8(rdram, ctx, runtime); return;
}


// Function: entry_181d98
// Address: 0x181d98 - 0x181da8

void entry_181d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181d98: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181d9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181da4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181da8; return;
}


// Function: SetLgnLgns__FP3LGN4LGNS
// Address: 0x181da8 - 0x181e34

void entry_181e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181e34) {
        switch (ctx->pc) {
            case 0x181e3c: ctx->pc = 0; goto label_181e3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181e34: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181E74; return;
    }
label_181e3c:
    // 0x181e3c: 0x8e040bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3004)));
    // 0x181e40: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x181e48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 863));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_181e48
// Address: 0x181e48 - 0x181e68

void entry_181e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181e48) {
        switch (ctx->pc) {
            case 0x181e50: ctx->pc = 0; goto label_181e50;
            case 0x181e5c: ctx->pc = 0; goto label_181e5c;
            case 0x181e60: ctx->pc = 0; goto label_181e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181e48: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x181E74; return;
    }
label_181e50:
    // 0x181e50: 0x8e040bbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3004)));
    // 0x181e54: 0x10000002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 865));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_181e60;
    }
label_181e5c:
    // 0x181e5c: 0x24050362
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 866));
label_181e60:
    // 0x181e60: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x181e68);
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_181e68
// Address: 0x181e68 - 0x181ed0

void entry_181e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181e68) {
        switch (ctx->pc) {
            case 0x181e74: ctx->pc = 0; goto label_181e74;
            case 0x181e9c: ctx->pc = 0; goto label_181e9c;
            case 0x181ea0: ctx->pc = 0; goto label_181ea0;
            case 0x181ea4: ctx->pc = 0; goto label_181ea4;
            case 0x181eb4: ctx->pc = 0; goto label_181eb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181e68: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x181e6c: 0xc440b168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294947176)); ctx->f[0] = *(float*)&val; }
    // 0x181e70: 0xe6000bf8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3064), *(uint32_t*)&val); }
label_181e74:
    // 0x181e74: 0x5220000b
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 0));
        goto label_181ea4;
    }
    // 0x181e7c: 0x6200007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 4));
    if (GPR_S32(ctx, 17) < 0) {
        goto label_181e9c;
    }
    // 0x181e84: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_181e9c;
    }
    // 0x181e8c: 0x14400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_181ea0;
    }
    // 0x181e94: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_181ea4;
    }
label_181e9c:
    // 0x181e9c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_181ea0:
    // 0x181ea0: 0xae020580
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 2));
label_181ea4:
    // 0x181ea4: 0xae110bb0
    WRITE32(ADD32(GPR_U32(ctx, 16), 2992), GPR_U32(ctx, 17));
    // 0x181ea8: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x181eac: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x181eb0: 0xe6000bb4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2996), *(uint32_t*)&val); }
label_181eb4:
    // 0x181eb4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x181eb8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x181ebc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x181ec0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x181ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x181ed0; return;
}


// Function: UpdateLgnrAim__FP4LGNRP3JOY
// Address: 0x181ed0 - 0x181f80

void entry_181f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x181f80: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x181f84: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x181f88: 0xc051070
    SET_GPR_U32(ctx, 31, 0x181f90);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_181f90
// Address: 0x181f90 - 0x182060

void entry_181f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x181f90) {
        switch (ctx->pc) {
            case 0x181ff4: ctx->pc = 0; goto label_181ff4;
            case 0x182028: ctx->pc = 0; goto label_182028;
            case 0x182030: ctx->pc = 0; goto label_182030;
            case 0x182034: ctx->pc = 0; goto label_182034;
            case 0x18203c: ctx->pc = 0; goto label_18203c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x181f90: 0xc7a20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[2] = *(float*)&val; }
    // 0x181f94: 0x46171034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181f98: 0x0
    // NOP
    // 0x181f9c: 0x45030025
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        goto label_182034;
    }
    // 0x181fa4: 0x8e421990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x181fa8: 0xc601008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 140)); ctx->f[1] = *(float*)&val; }
    // 0x181fac: 0xc44001f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 496)); ctx->f[0] = *(float*)&val; }
    // 0x181fb0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x181fb4: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x181fb8: 0xda210270
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 624)));
    // 0x181fbc: 0x4be1106c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x181fc0: 0x8e220280
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 640)));
    // 0x181fc4: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181fc8: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181fcc: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x181fd0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x181fd4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x181fd8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x181fdc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x181fe0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x181fe4: 0x46010041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x181fe8: 0x16020002
    ctx->f[1] = std::max(ctx->f[21], ctx->f[1]);
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_181ff4;
    }
    // 0x181ff0: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
label_181ff4:
    // 0x181ff4: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x181ff8: 0x0
    // NOP
    // 0x181ffc: 0x4503000a
    if ((ctx->fcr31 & 0x800000)) {
        WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
        goto label_182028;
    }
    // 0x182004: 0x46140832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182008: 0x0
    // NOP
    // 0x18200c: 0x45000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_182030;
    }
    // 0x182014: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182018: 0x0
    // NOP
    // 0x18201c: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
        goto label_182034;
    }
    // 0x182024: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_182028:
    // 0x182028: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    // 0x18202c: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_182030:
    // 0x182030: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
label_182034:
    // 0x182034: 0x1600ffd0
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x181F78; return;
    }
label_18203c:
    // 0x18203c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x182040: 0x26901858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x182044: 0x24524198
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 16792));
    // 0x182048: 0xc66d0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 64)); ctx->f[13] = *(float*)&val; }
    // 0x18204c: 0xc62c0260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 608)); ctx->f[12] = *(float*)&val; }
    // 0x182050: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x182054: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x182058: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x182060);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_182060
// Address: 0x182060 - 0x182094

void entry_182060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182060) {
        switch (ctx->pc) {
            case 0x182080: ctx->pc = 0; goto label_182080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182060: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x182064: 0xe6200260
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 608), *(uint32_t*)&val); }
    // 0x182068: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x18206c: 0x8c6219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x182070: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x182074: 0x10400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 68)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_182080;
    }
    // 0x18207c: 0x46006b47
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
label_182080:
    // 0x182080: 0xc62c0264
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 612)); ctx->f[12] = *(float*)&val; }
    // 0x182084: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x182088: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x18208c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x182094);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_182094
// Address: 0x182094 - 0x182170

void entry_182094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182094) {
        switch (ctx->pc) {
            case 0x1820d8: ctx->pc = 0; goto label_1820d8;
            case 0x1820e8: ctx->pc = 0; goto label_1820e8;
            case 0x182130: ctx->pc = 0; goto label_182130;
            case 0x182140: ctx->pc = 0; goto label_182140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182094: 0xe6200264
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 612), *(uint32_t*)&val); }
    // 0x182098: 0xc6220260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 608)); ctx->f[2] = *(float*)&val; }
    // 0x18209c: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1820a0: 0xc6c341a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 16804)); ctx->f[3] = *(float*)&val; }
    // 0x1820a4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1820a8: 0xc6210270
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 624)); ctx->f[1] = *(float*)&val; }
    // 0x1820ac: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1820b0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1820b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1820b8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1820bc: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1820c0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1820c4: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1820c8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1820d8;
    }
    // 0x1820d0: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1820e8;
    }
label_1820d8:
    // 0x1820d8: 0x46012834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1820dc: 0x0
    // NOP
    // 0x1820e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[5]);
        goto label_1820e8;
    }
label_1820e8:
    // 0x1820e8: 0xe6210270
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 624), *(uint32_t*)&val); }
    // 0x1820ec: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x1820f0: 0xc6210264
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 612)); ctx->f[1] = *(float*)&val; }
    // 0x1820f4: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1820f8: 0xc6c341a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 16804)); ctx->f[3] = *(float*)&val; }
    // 0x1820fc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x182100: 0xc6220274
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 628)); ctx->f[2] = *(float*)&val; }
    // 0x182104: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x182108: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18210c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x182110: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x182114: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x182118: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x18211c: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182120: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_182130;
    }
    // 0x182128: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_182140;
    }
label_182130:
    // 0x182130: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182134: 0x0
    // NOP
    // 0x182138: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[4]);
        goto label_182140;
    }
label_182140:
    // 0x182140: 0xe6220274
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 628), *(uint32_t*)&val); }
    // 0x182144: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x182148: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x18214c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x182150: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x182154: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x182158: 0x248441a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16808));
    // 0x18215c: 0xc62c0278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 632)); ctx->f[12] = *(float*)&val; }
    // 0x182160: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x182164: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x182168: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x182170);
    ctx->f[13] = std::max(ctx->f[13], ctx->f[0]);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_182170
// Address: 0x182170 - 0x1821b0

void entry_182170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182170: 0xae350280
    WRITE32(ADD32(GPR_U32(ctx, 17), 640), GPR_U32(ctx, 21));
    // 0x182174: 0xe6200278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 632), *(uint32_t*)&val); }
    // 0x182178: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18217c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x182180: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x182184: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x182188: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18218c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x182190: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x182194: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x182198: 0xc7b700c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[23] = *(float*)&val; }
    // 0x18219c: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x1821a0: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1821a4: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1821a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawLgnr__FP4LGNR
// Address: 0x1821b0 - 0x182200

void entry_182200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182200) {
        switch (ctx->pc) {
            case 0x182214: ctx->pc = 0; goto label_182214;
            case 0x18222c: ctx->pc = 0; goto label_18222c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182200: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x182204: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_182214;
    }
    // 0x18220c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x182210: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_182214:
    // 0x182214: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x182218: 0x8c640224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x18221c: 0x10800003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_18222c;
    }
    // 0x182224: 0x10000008
    { float val = ctx->f[13]; WRITE32(ADD32(GPR_U32(ctx, 17), 648), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182248; return;
    }
label_18222c:
    // 0x18222c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x182230: 0xc44e186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[14] = *(float*)&val; }
    // 0x182234: 0x248441b8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16824));
    // 0x182238: 0xc62c0288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 648)); ctx->f[12] = *(float*)&val; }
    // 0x18223c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x182244);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_182244
// Address: 0x182244 - 0x1822b8

void entry_182244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182244) {
        switch (ctx->pc) {
            case 0x182248: ctx->pc = 0; goto label_182248;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182244: 0xe6200288
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 648), *(uint32_t*)&val); }
label_182248:
    // 0x182248: 0xc6210288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 648)); ctx->f[1] = *(float*)&val; }
    // 0x18224c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x182250: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182254: 0x0
    // NOP
    // 0x182258: 0x45010077
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x182438; return;
    }
    // 0x182260: 0x8e220284
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 644)));
    // 0x182264: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x182268: 0x26102280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8832));
    // 0x18226c: 0x3c0143a0
    SET_GPR_U32(ctx, 1, ((uint32_t)17312 << 16));
    // 0x182270: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x182274: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x182278: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18227c: 0x200a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182280: 0x3c01c376
    SET_GPR_U32(ctx, 1, ((uint32_t)50038 << 16));
    // 0x182284: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x182288: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x18228c: 0x8c660004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x182290: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x182294: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x182298: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x18229c: 0x3c014376
    SET_GPR_U32(ctx, 1, ((uint32_t)17270 << 16));
    // 0x1822a0: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1822a4: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1822a8: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1822ac: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1822b0: 0xc054b38
    SET_GPR_U32(ctx, 31, 0x1822b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    AddDmaBulk__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1822b8
// Address: 0x1822b8 - 0x1822d4

void entry_1822b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1822b8: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1822bc: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1822c0: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1822c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1822c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1822cc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1822d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1822d4
// Address: 0x1822d4 - 0x1822f8

void entry_1822d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1822d4: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1822d8: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1822dc: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1822e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1822e4: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1822e8: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1822ec: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1822f0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1822f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1822f8
// Address: 0x1822f8 - 0x182328

void entry_1822f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1822f8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1822fc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x182300: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x182304: 0x3c0280ff
    SET_GPR_U32(ctx, 2, ((uint32_t)33023 << 16));
    // 0x182308: 0xc48c41c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 16836)); ctx->f[12] = *(float*)&val; }
    // 0x18230c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x182310: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x182314: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x182318: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x18231c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x182320: 0xc062214
    SET_GPR_U32(ctx, 31, 0x182328);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_182328
// Address: 0x182328 - 0x18233c

void entry_182328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182328: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18232c: 0x2405005c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 92));
    // 0x182330: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x182334: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18233c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1042));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18233c
// Address: 0x18233c - 0x1823e0

void entry_18233c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18233c) {
        switch (ctx->pc) {
            case 0x182370: ctx->pc = 0; goto label_182370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18233c: 0x93a30003
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 3)));
    // 0x182340: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x182344: 0xc6200288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 648)); ctx->f[0] = *(float*)&val; }
    // 0x182348: 0x245041c8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 16840));
    // 0x18234c: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x182350: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x182354: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x182358: 0x249241f0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 4), 16880));
    // 0x18235c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x182360: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x182364: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x182368: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x18236c: 0xc6220270
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 624)); ctx->f[2] = *(float*)&val; }
label_182370:
    // 0x182370: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x182374: 0xc6230274
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 628)); ctx->f[3] = *(float*)&val; }
    // 0x182378: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x18237c: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x182380: 0x46151082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[21]);
    // 0x182384: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182388: 0x461a18c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[26]);
    // 0x18238c: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x182390: 0x26520010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 16));
    // 0x182394: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x182398: 0x46151080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[21]);
    // 0x18239c: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1823a0: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1823a4: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1823a8: 0x461918c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[25]);
    // 0x1823ac: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1823b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1823b4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1823b8: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1823bc: 0xc7a10044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1823c0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1823c4: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1823c8: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1823cc: 0xc60d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1823d0: 0x26100008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1823d4: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x1823d8: 0xc058548
    SET_GPR_U32(ctx, 31, 0x1823e0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    PackSTQ__4GIFSfff(rdram, ctx, runtime); return;
}


// Function: entry_1823e0
// Address: 0x1823e0 - 0x1823ec

void entry_1823e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1823e0: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1823e4: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1823ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1823ec
// Address: 0x1823ec - 0x182428

void entry_1823ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1823ec: 0xc7a00044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[0] = *(float*)&val; }
    // 0x1823f0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1823f4: 0xc7a10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1823f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1823fc: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x182400: 0x46180840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[24]);
    // 0x182404: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x182408: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x18240c: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x182410: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x182414: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x182418: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x18241c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x182420: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x182428);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_182428
// Address: 0x182428 - 0x182470

void entry_182428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182428) {
        switch (ctx->pc) {
            case 0x182438: ctx->pc = 0; goto label_182438;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182428: 0x2e620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 4));
    // 0x18242c: 0x5440ffd0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 624)); ctx->f[2] = *(float*)&val; }
        ctx->pc = 0x182370; return;
    }
    // 0x182434: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_182438:
    // 0x182438: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18243c: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x182440: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x182444: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x182448: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18244c: 0xc7ba00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[26] = *(float*)&val; }
    // 0x182450: 0xc7b900d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[25] = *(float*)&val; }
    // 0x182454: 0xc7b800d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[24] = *(float*)&val; }
    // 0x182458: 0xc7b700c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[23] = *(float*)&val; }
    // 0x18245c: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x182460: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x182464: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x182468: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSwp__FP3SWP
// Address: 0x182470 - 0x182484

void entry_182484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182484: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x182488: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18248c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x182490: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x182494: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x182498: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x18249c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1824a0: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x1824a4: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1824a8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1824ac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1824b0: 0xe60106dc
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1756), *(uint32_t*)&val); }
    // 0x1824b4: 0xe60006d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1748), *(uint32_t*)&val); }
    // 0x1824b8: 0xe60206e0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1760), *(uint32_t*)&val); }
    // 0x1824bc: 0xe60306d8
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1752), *(uint32_t*)&val); }
    // 0x1824c0: 0xe60406cc
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 1740), *(uint32_t*)&val); }
    // 0x1824c4: 0xae0006d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1744), GPR_U32(ctx, 0));
    // 0x1824c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1824cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1824d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSwpLoad__FP3SWP
// Address: 0x1824d8 - 0x1824ec

void entry_1824ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1824ec: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1824f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1824f4: 0x24c64230
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16944));
    // 0x1824f8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x182500);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_182500
// Address: 0x182500 - 0x182514

void entry_182500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182500: 0x8e0406c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1732)));
    // 0x182504: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182508: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18250c: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x182514);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 878));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_182514
// Address: 0x182514 - 0x182520

void entry_182514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182514: 0xae0206c8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1736), GPR_U32(ctx, 2));
    // 0x182518: 0xc048458
    SET_GPR_U32(ctx, 31, 0x182520);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_182520
// Address: 0x182520 - 0x182530

void entry_182520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182520: 0xae0206e8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1768), GPR_U32(ctx, 2));
    // 0x182524: 0x24040c00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3072));
    // 0x182528: 0xc063540
    SET_GPR_U32(ctx, 31, 0x182530);
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 0));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_182530
// Address: 0x182530 - 0x182548

void entry_182530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182530: 0x8e0306e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1768)));
    // 0x182534: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182538: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18253c: 0xac62000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 2));
    // 0x182540: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSwp__FP3SWPf
// Address: 0x182548 - 0x18256c

void entry_18256c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18256c: 0x8e0206e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1768)));
    // 0x182570: 0x1040006c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_182724(rdram, ctx, runtime); return;
    }
    // 0x182578: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x182580);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_182580
// Address: 0x182580 - 0x182590

void entry_182580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182580: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x182584: 0x24050016
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    // 0x182588: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x182590);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_182590
// Address: 0x182590 - 0x1825e8

void entry_182590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182590) {
        switch (ctx->pc) {
            case 0x182598: ctx->pc = 0; goto label_182598;
            case 0x1825c4: ctx->pc = 0; goto label_1825c4;
            case 0x1825d4: ctx->pc = 0; goto label_1825d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182590: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1568)));
        goto label_182598;
    }
label_182598:
    // 0x182598: 0xc60006e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1760)); ctx->f[0] = *(float*)&val; }
    // 0x18259c: 0xc60106e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1764)); ctx->f[1] = *(float*)&val; }
    // 0x1825a0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1825a4: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1825a8: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1825ac: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1825b0: 0x0
    // NOP
    // 0x1825b4: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1756)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1825c4;
    }
    // 0x1825bc: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1825d4;
    }
label_1825c4:
    // 0x1825c4: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1825c8: 0x0
    // NOP
    // 0x1825cc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1825d4;
    }
label_1825d4:
    // 0x1825d4: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1825d8: 0x8e0406c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
    // 0x1825dc: 0xe60006e4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1764), *(uint32_t*)&val); }
    // 0x1825e0: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1825e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1825e8
// Address: 0x1825e8 - 0x182604

void entry_1825e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1825e8: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1825ec: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1825f0: 0x14620006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 879));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18260C; return;
    }
    // 0x1825f8: 0x8e0406c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
    // 0x1825fc: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x182604);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_182604
// Address: 0x182604 - 0x1826ac

void entry_182604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182604) {
        switch (ctx->pc) {
            case 0x18260c: ctx->pc = 0; goto label_18260c;
            case 0x182660: ctx->pc = 0; goto label_182660;
            case 0x182678: ctx->pc = 0; goto label_182678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182604: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182608: 0x2402036f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 879));
label_18260c:
    // 0x18260c: 0x14620014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_182660;
    }
    // 0x182614: 0x12200012
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_182660;
    }
    // 0x18261c: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x182620: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x182624: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182628: 0xc441424c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16972)); ctx->f[1] = *(float*)&val; }
    // 0x18262c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182630: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x182634: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182638: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18263c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182640: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x182644: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x182648: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18264c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x182650: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182654: 0x0
    // NOP
    // 0x182658: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_182678;
    }
label_182660:
    // 0x182660: 0xc60106e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1764)); ctx->f[1] = *(float*)&val; }
    // 0x182664: 0xc60006dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1756)); ctx->f[0] = *(float*)&val; }
    // 0x182668: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18266c: 0x0
    // NOP
    // 0x182670: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_182678;
    }
label_182678:
    // 0x182678: 0x1080001e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1826F4; return;
    }
    // 0x182680: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x182684: 0x8c4723c0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x182688: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18268c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182690: 0x8ce219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 6616)));
    // 0x182694: 0x8ce319dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 6620)));
    // 0x182698: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x18269c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1826a0: 0x38420505
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1285));
    // 0x1826a4: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1826ac);
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1826ac
// Address: 0x1826ac - 0x1826c0

void entry_1826ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1826ac: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1826b0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1826b4: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1826b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1826c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1826c0
// Address: 0x1826c0 - 0x1826c8

void entry_1826c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1826c0: 0xc0561cc
    SET_GPR_U32(ctx, 31, 0x1826c8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1772)));
    ExplodeExpl__FP4EXPL(rdram, ctx, runtime); return;
}


// Function: entry_1826c8
// Address: 0x1826c8 - 0x1826d8

void entry_1826c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1826c8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1826cc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1826d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1826d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1826d8
// Address: 0x1826d8 - 0x1826ec

void entry_1826d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1826d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1826dc: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1826e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1826e4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1826ec);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1826ec
// Address: 0x1826ec - 0x182724

void entry_1826ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1826ec) {
        switch (ctx->pc) {
            case 0x1826f4: ctx->pc = 0; goto label_1826f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1826ec: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182730; return;
    }
label_1826f4:
    // 0x1826f4: 0x8e0406c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
    // 0x1826f8: 0x1080000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_182724(rdram, ctx, runtime); return;
    }
    // 0x182700: 0xc60006dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1756)); ctx->f[0] = *(float*)&val; }
    // 0x182704: 0xc60106e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1764)); ctx->f[1] = *(float*)&val; }
    // 0x182708: 0xc4424248
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16968)); ctx->f[2] = *(float*)&val; }
    // 0x18270c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x182710: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x182714: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        entry_182724(rdram, ctx, runtime); return;
    }
    // 0x18271c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x182724);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 879));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_182724
// Address: 0x182724 - 0x18272c

void entry_182724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182724: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x18272c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_18272c
// Address: 0x18272c - 0x182748

void entry_18272c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18272c) {
        switch (ctx->pc) {
            case 0x182730: ctx->pc = 0; goto label_182730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18272c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_182730:
    // 0x182730: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x182734: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x182738: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18273c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x182740: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectSwpTransform__FP3SWPfi
// Address: 0x182748 - 0x18279c

void entry_18279c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18279c: 0x8e4206c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1728)));
    // 0x1827a0: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1827a4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1827a8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1827ac: 0x10400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1827c0(rdram, ctx, runtime); return;
    }
    // 0x1827b4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1827b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1827c0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1827c0
// Address: 0x1827c0 - 0x1827fc

void entry_1827c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1827c0: 0x8fa20084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1827c4: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1827c8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1827cc: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1827d0: 0x8e4206c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1728)));
    // 0x1827d4: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1827d8: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1827dc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1827e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1827e4: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1827e8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1827ec: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1827f0: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1827f4: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x1827fc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_1827fc
// Address: 0x1827fc - 0x182858

void entry_1827fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1827fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x182800: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x182804: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x182808: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x18280c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x182810: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x182814: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x182818: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x18281c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x182820: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182824: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x182828: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18282c: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x182830: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x182834: 0xda410350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 848)));
    // 0x182838: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18283c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x182840: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x182844: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x182848: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18284c: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x182850: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x182858);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_182858
// Address: 0x182858 - 0x182888

void entry_182858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182858: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18285c: 0x264400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 208));
    // 0x182860: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x182864: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x182868: 0x7e430100
    WRITE128(ADD32(GPR_U32(ctx, 18), 256), GPR_VEC(ctx, 3));
    // 0x18286c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x182870: 0x7e420150
    WRITE128(ADD32(GPR_U32(ctx, 18), 336), GPR_VEC(ctx, 2));
    // 0x182874: 0x24c64250
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16976));
    // 0x182878: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x18287c: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x182880: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x182888);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 352));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_182888
// Address: 0x182888 - 0x1828e8

void entry_182888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182888) {
        switch (ctx->pc) {
            case 0x1828c8: ctx->pc = 0; goto label_1828c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182888: 0x26430034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 52));
    // 0x18288c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x182890: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x182894: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x182898: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x18289c: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1828a0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1828a4: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1828a8: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1828ac: 0x8e430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x1828b0: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1828b4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1828b8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1828bc: 0x10800010
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182900; return;
    }
    // 0x1828c4: 0x0
    // NOP
label_1828c8:
    // 0x1828c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1828cc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1828d0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1828d4: 0x10400004
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1828e8(rdram, ctx, runtime); return;
    }
    // 0x1828dc: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1828e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1828e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1828e8
// Address: 0x1828e8 - 0x182920

void entry_1828e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1828e8) {
        switch (ctx->pc) {
            case 0x182900: ctx->pc = 0; goto label_182900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1828e8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1828ec: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1828f0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1828f4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1828f8: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1828C8; return;
    }
label_182900:
    // 0x182900: 0x16600008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x182924; return;
    }
    // 0x182908: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18290c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x182910: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
        ctx->pc = 0x182924; return;
    }
    // 0x182918: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182920);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182920
// Address: 0x182920 - 0x182948

void entry_182920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182920) {
        switch (ctx->pc) {
            case 0x182924: ctx->pc = 0; goto label_182924;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182920: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
label_182924:
    // 0x182924: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x182928: 0xae02b314
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947604), GPR_U32(ctx, 2));
    // 0x18292c: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x182930: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x182934: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x182938: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18293c: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x182940: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSwpShape__FP3SWPP5SHAPEf
// Address: 0x182948 - 0x182998

void entry_182998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182998: 0xaed006c0
    WRITE32(ADD32(GPR_U32(ctx, 22), 1728), GPR_U32(ctx, 16));
    // 0x18299c: 0xe6d606dc
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 22), 1756), *(uint32_t*)&val); }
    // 0x1829a0: 0x8e100034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1829a4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1829a8: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1829ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1829b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1829b4
// Address: 0x1829b4 - 0x1829d0

void entry_1829b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1829b4: 0x8e14000c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1829b8: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1829bc: 0x8ec206e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 1768)));
    // 0x1829c0: 0x142080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 20), 2));
    // 0x1829c4: 0x8c57000c
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1829c8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1829d0);
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 20));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1829d0
// Address: 0x1829d0 - 0x182a1c

void entry_1829d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1829d0) {
        switch (ctx->pc) {
            case 0x1829e8: ctx->pc = 0; goto label_1829e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1829d0: 0x1a80003e
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x182ACC; return;
    }
    // 0x1829d8: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1829dc: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1829e0: 0x3c0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1829e4: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1829e8:
    // 0x1829e8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1829ec: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1829f0: 0x10600015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_182a48(rdram, ctx, runtime); return;
    }
    // 0x1829f8: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1829fc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x182a00: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x182a04: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x182a08: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x182a0c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x182a10: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x182a14: 0x60f809
    SET_GPR_U32(ctx, 31, 0x182a1c);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_182a1c
// Address: 0x182a1c - 0x182a48

void entry_182a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182a1c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182a20: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x182a24: 0x10600008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_182a48(rdram, ctx, runtime); return;
    }
    // 0x182a2c: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x182a30: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x182a34: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x182a38: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x182a3c: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x182a40: 0x60f809
    SET_GPR_U32(ctx, 31, 0x182a48);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_182a48
// Address: 0x182a48 - 0x182ab0

void entry_182a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182a48: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182a4c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182a50: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182a54: 0xc6c206d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 1752)); ctx->f[2] = *(float*)&val; }
    // 0x182a58: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182a5c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x182a60: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182a64: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x182a68: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x182a6c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x182a70: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x182a74: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x182a78: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x182a7c: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x182a80: 0x46020044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x182a84: 0xe6610000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x182a88: 0x4617ab40
    ctx->f[13] = FPU_ADD_S(ctx->f[21], ctx->f[23]);
    // 0x182a8c: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x182a90: 0x26c406cc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 1740));
    // 0x182a94: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x182a98: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x182a9c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x182aa0: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x182aa4: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x182aa8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x182ab0);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_182ab0
// Address: 0x182ab0 - 0x182bcc

void entry_182ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182ab0) {
        switch (ctx->pc) {
            case 0x182acc: ctx->pc = 0; goto label_182acc;
            case 0x182ae8: ctx->pc = 0; goto label_182ae8;
            case 0x182b08: ctx->pc = 0; goto label_182b08;
            case 0x182b30: ctx->pc = 0; goto label_182b30;
            case 0x182b54: ctx->pc = 0; goto label_182b54;
            case 0x182b68: ctx->pc = 0; goto label_182b68;
            case 0x182b90: ctx->pc = 0; goto label_182b90;
            case 0x182ba0: ctx->pc = 0; goto label_182ba0;
            case 0x182bbc: ctx->pc = 0; goto label_182bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182ab0: 0xc6610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[1] = *(float*)&val; }
    // 0x182ab4: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x182ab8: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x182abc: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x182ac0: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x182ac4: 0x1440ffc8
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1829E8; return;
    }
label_182acc:
    // 0x182acc: 0x1a800021
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_182b54;
    }
    // 0x182ad4: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x182ad8: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x182adc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x182ae0: 0x2e0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x182ae4: 0x0
    // NOP
label_182ae8:
    // 0x182ae8: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x182aec: 0x60902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x182af0: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x182af4: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x182af8: 0x16200003
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_182b08;
    }
    // 0x182b00: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_182b30;
    }
label_182b08:
    // 0x182b08: 0xc640ffec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4294967276)); ctx->f[0] = *(float*)&val; }
    // 0x182b0c: 0xc4820000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[2] = *(float*)&val; }
    // 0x182b10: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x182b14: 0xc483fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294967292)); ctx->f[3] = *(float*)&val; }
    // 0x182b18: 0xc641ffe8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4294967272)); ctx->f[1] = *(float*)&val; }
    // 0x182b1c: 0x46031080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x182b20: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x182b24: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x182b28: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x182b2c: 0xe6410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_182b30:
    // 0x182b30: 0xac660008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 6));
    // 0x182b34: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x182b38: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x182b3c: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x182b40: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x182b44: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x182b48: 0xe460000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 12), *(uint32_t*)&val); }
    // 0x182b4c: 0x1440ffe6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 24));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_182ae8;
    }
label_182b54:
    // 0x182b54: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x182b58: 0x1a80000d
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[22] * 0.0f); } else ctx->f[12] = ctx->f[22] / ctx->f[0];
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_182b90;
    }
    // 0x182b60: 0x2e0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x182b64: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_182b68:
    // 0x182b68: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x182b6c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x182b70: 0xc641000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[1] = *(float*)&val; }
    // 0x182b74: 0x26420018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 24));
    // 0x182b78: 0xc6400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[0] = *(float*)&val; }
    // 0x182b7c: 0x460c0843
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[12];
    // 0x182b80: 0x460c0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x182b84: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x182b88: 0x1620fff7
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_182b68;
    }
label_182b90:
    // 0x182b90: 0x1a80000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_182bbc;
    }
    // 0x182b98: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x182b9c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
label_182ba0:
    // 0x182ba0: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x182ba4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x182ba8: 0xac430010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 3));
    // 0x182bac: 0xe4400014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    // 0x182bb0: 0x0
    // NOP
    // 0x182bb4: 0x1620fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_182ba0;
    }
label_182bbc:
    // 0x182bbc: 0x8ec406c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 1736)));
    // 0x182bc0: 0x2405036e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 878));
    // 0x182bc4: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x182bcc);
    WRITE32(ADD32(GPR_U32(ctx, 22), 1764), GPR_U32(ctx, 0));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_182bcc
// Address: 0x182bcc - 0x182bd4

void entry_182bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182bcc: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x182bd4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_182bd4
// Address: 0x182bd4 - 0x182c18

void entry_182bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182bd4: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x182bd8: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x182bdc: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x182be0: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x182be4: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x182be8: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x182bec: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x182bf0: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x182bf4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x182bf8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x182bfc: 0xc7b700e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[23] = *(float*)&val; }
    // 0x182c00: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x182c04: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x182c08: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x182c0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182c14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182c18; return;
}


// Function: InitLo__FP2LO
// Address: 0x182c18 - 0x182c38

void entry_182c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182c38: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182c3c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x182c40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182c48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182c48
// Address: 0x182c48 - 0x182c58

void entry_182c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182c48: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182c4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182c50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLoLoad__FP2LO
// Address: 0x182c58 - 0x182c70

void entry_182c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182c70: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182c74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182c7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182c80; return;
}


// Function: AddLo__FP2LO
// Address: 0x182c80 - 0x182cb4

void entry_182cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182cb4: 0x1440000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x182CEC; return;
    }
    // 0x182cbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x182cc0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x182cc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_182cc8
// Address: 0x182cc8 - 0x182cd0

void entry_182cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182cc8: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x182cd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_182cd0
// Address: 0x182cd0 - 0x182ce8

void entry_182cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182cd0: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182CEC; return;
    }
    // 0x182cd8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182cdc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x182ce0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182ce8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182ce8
// Address: 0x182ce8 - 0x182d00

void entry_182ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182ce8) {
        switch (ctx->pc) {
            case 0x182cec: ctx->pc = 0; goto label_182cec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182ce8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_182cec:
    // 0x182cec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182cf0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182d00; return;
}


// Function: AddLoHierarchy__FP2LO
// Address: 0x182d00 - 0x182d20

void entry_182d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182d20: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182d24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182d28: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x182d2c: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x182d30: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182d38);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182d38
// Address: 0x182d38 - 0x182d48

void entry_182d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182d38: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182d3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182d40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnLoAdd__FP2LO
// Address: 0x182d48 - 0x182d50

void entry_182d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182d84: 0x10400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182DC8; return;
    }
    // 0x182d8c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x182d94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_182d94
// Address: 0x182d94 - 0x182da4

void entry_182d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182d94: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182DBC; return;
    }
    // 0x182d9c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x182da4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_182da4
// Address: 0x182da4 - 0x182db4

void entry_182da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182da4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182da8: 0x8c620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 36)));
    // 0x182dac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182db4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182db4
// Address: 0x182db4 - 0x182dc4

void entry_182db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182db4) {
        switch (ctx->pc) {
            case 0x182dbc: ctx->pc = 0; goto label_182dbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182db4: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182DC8; return;
    }
label_182dbc:
    // 0x182dbc: 0xc054980
    SET_GPR_U32(ctx, 31, 0x182dc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_182dc4
// Address: 0x182dc4 - 0x182dd8

void entry_182dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182dc4) {
        switch (ctx->pc) {
            case 0x182dc8: ctx->pc = 0; goto label_182dc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182dc4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_182dc8:
    // 0x182dc8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182dcc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182dd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DeferLoRemove__FP2LO
// Address: 0x182dd8 - 0x182e14

void entry_182e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182e14) {
        switch (ctx->pc) {
            case 0x182e2c: ctx->pc = 0; goto label_182e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182e14: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x182e18: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x182e1c: 0x8e0402c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 708)));
    // 0x182e20: 0xac440004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 4));
    // 0x182e24: 0xae0202c4
    WRITE32(ADD32(GPR_U32(ctx, 16), 708), GPR_U32(ctx, 2));
    // 0x182e28: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_182e2c:
    // 0x182e2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182e30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182e34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182e3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182e40; return;
}


// Function: SetLoSuckHideLimits__FP2LOP2LM
// Address: 0x182e40 - 0x182e64

void entry_182e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182e64: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182E78; return;
    }
    // 0x182e6c: 0xc060b76
    SET_GPR_U32(ctx, 31, 0x182e74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DeferLoRemove__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_182e74
// Address: 0x182e74 - 0x182e88

void entry_182e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182e74) {
        switch (ctx->pc) {
            case 0x182e78: ctx->pc = 0; goto label_182e78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182e74: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_182e78:
    // 0x182e78: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182e7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182e84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182e88; return;
}


// Function: RemoveLoHierarchy__FP2LO
// Address: 0x182e88 - 0x182ea8

void entry_182ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182ea8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182eac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x182eb0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x182eb4: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x182eb8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182ec0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182ec0
// Address: 0x182ec0 - 0x182ed0

void entry_182ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182ec0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182ec4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182ec8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnLoRemove__FP2LO
// Address: 0x182ed0 - 0x182ed8

void entry_182eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182eec: 0x10400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x182F30; return;
    }
    // 0x182ef4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182ef8: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x182efc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x182F10; return;
    }
    // 0x182f04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182f0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182f0c
// Address: 0x182f0c - 0x182f1c

void entry_182f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182f0c) {
        switch (ctx->pc) {
            case 0x182f10: ctx->pc = 0; goto label_182f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182f0c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_182f10:
    // 0x182f10: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x182f14: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182f1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182f1c
// Address: 0x182f1c - 0x182f2c

void entry_182f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182f1c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182f20: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x182f24: 0x40f809
    SET_GPR_U32(ctx, 31, 0x182f2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_182f2c
// Address: 0x182f2c - 0x182f40

void entry_182f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182f2c) {
        switch (ctx->pc) {
            case 0x182f30: ctx->pc = 0; goto label_182f30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182f2c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_182f30:
    // 0x182f30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182f34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182f3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182f40; return;
}


// Function: FFindLoParent__FP2LOP3ALO
// Address: 0x182f40 - 0x182f78

void entry_182f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182f9c: 0xae110018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 17));
    // 0x182fa0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x182fa4: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x182fa8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x182fb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_182fb0
// Address: 0x182fb0 - 0x182fc8

void entry_182fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x182fb0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x182fb4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x182fb8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x182fbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x182fc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x182fc8; return;
}


// Function: FIsLoInWorld__FP2LO
// Address: 0x182fc8 - 0x182ff8

void entry_182ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x182ff8) {
        switch (ctx->pc) {
            case 0x183008: ctx->pc = 0; goto label_183008;
            case 0x183010: ctx->pc = 0; goto label_183010;
            case 0x183014: ctx->pc = 0; goto label_183014;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x182ff8: 0x14400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_183008;
    }
    // 0x183000: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_183014;
    }
label_183008:
    // 0x183008: 0x54a0fff5
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 5), 24)));
        ctx->pc = 0x182FE0; return;
    }
label_183010:
    // 0x183010: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_183014:
    // 0x183014: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183018: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18301c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183024: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183028; return;
}


// Function: GetLoInWorld__FP2LOPi
// Address: 0x183028 - 0x18303c

void entry_18303c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18303c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x183040: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183044: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183048: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00183050
// Address: 0x183050 - 0x183058

void entry_183080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183080: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183084: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183088: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18308c: 0x8c620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x183090: 0x40f809
    SET_GPR_U32(ctx, 31, 0x183098);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_183098
// Address: 0x183098 - 0x1830b0

void entry_183098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183098: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18309c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1830a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1830a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1830a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneLoHierarchy__FP2LOT0
// Address: 0x1830b0 - 0x1830c8

void entry_1830c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1830c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1830cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1830d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1830d8; return;
}


// Function: CloneLo__FP2LOT0
// Address: 0x1830d8 - 0x183108

void entry_183108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183108: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18310c: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x183110: 0xc046fb8
    SET_GPR_U32(ctx, 31, 0x183118);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneTo__8CSidebagP8CSidebag(rdram, ctx, runtime); return;
}


// Function: entry_183118
// Address: 0x183118 - 0x18312c

void entry_183118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183118: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18311c: 0xae500004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    // 0x183120: 0x24849f38
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    // 0x183124: 0xc0469c2
    SET_GPR_U32(ctx, 31, 0x18312c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRootSidebag__3CGcP8CSidebag(rdram, ctx, runtime); return;
}


// Function: entry_18312c
// Address: 0x18312c - 0x183148

void entry_18312c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18312c: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x183130: 0x26440034
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 52));
    // 0x183134: 0x8e500014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x183138: 0x26650034
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 52));
    // 0x18313c: 0x8c46000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x183140: 0xc063600
    SET_GPR_U32(ctx, 31, 0x183148);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967244));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_183148
// Address: 0x183148 - 0x183154

void entry_183148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183148: 0x8e450008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x18314c: 0xc0567c8
    SET_GPR_U32(ctx, 31, 0x183154);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdlFromSwOid__FP2SW3OID(rdram, ctx, runtime); return;
}


// Function: entry_183154
// Address: 0x183154 - 0x183160

void entry_183154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183154: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183158: 0xc054980
    SET_GPR_U32(ctx, 31, 0x183160);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_183160
// Address: 0x183160 - 0x18316c

void entry_183160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183160: 0x8e650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x183164: 0xc0567c8
    SET_GPR_U32(ctx, 31, 0x18316c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PdlFromSwOid__FP2SW3OID(rdram, ctx, runtime); return;
}


// Function: entry_18316c
// Address: 0x18316c - 0x183178

void entry_18316c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18316c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183170: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x183178);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_183178
// Address: 0x183178 - 0x183198

void entry_183178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183178: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x18317c: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x183180: 0x8e63002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 44)));
    // 0x183184: 0x1060000e
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1831c0(rdram, ctx, runtime); return;
    }
    // 0x18318c: 0x26319f38
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294942520));
    // 0x183190: 0xc046a00
    SET_GPR_U32(ctx, 31, 0x183198);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateRecyclable__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_183198
// Address: 0x183198 - 0x1831a0

void entry_183198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183198: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x1831a0);
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1831a0
// Address: 0x1831a0 - 0x1831b0

void entry_1831a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1831a0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1831a4: 0x8e64002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 44)));
    // 0x1831a8: 0xc04696c
    SET_GPR_U32(ctx, 31, 0x1831b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneTo__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1831b0
// Address: 0x1831b0 - 0x1831c0

void entry_1831b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1831b0: 0xae50002c
    WRITE32(ADD32(GPR_U32(ctx, 18), 44), GPR_U32(ctx, 16));
    // 0x1831b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1831b8: 0xc0469b0
    SET_GPR_U32(ctx, 31, 0x1831c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRootFrame__3CGcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1831c0
// Address: 0x1831c0 - 0x1831e8

void entry_1831c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1831c0: 0x8e620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 48)));
    // 0x1831c4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1831c8: 0xae420030
    WRITE32(ADD32(GPR_U32(ctx, 18), 48), GPR_U32(ctx, 2));
    // 0x1831cc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1831d0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1831d4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1831d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1831dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1831e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1831e8; return;
}


// Function: SubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv
// Address: 0x1831e8 - 0x18320c

void entry_18320c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18320c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x183210: 0xac510004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 17));
    // 0x183214: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183218: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18321c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183220: 0xac430010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 3));
    // 0x183224: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x183228: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18322c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnsubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv
// Address: 0x183238 - 0x183284

void entry_183284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183284) {
        switch (ctx->pc) {
            case 0x183288: ctx->pc = 0; goto label_183288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183284: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_183288:
    // 0x183288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeLoStruct__FP2LOPFPv5MSGIDPv_vPv
// Address: 0x183290 - 0x1832b4

void entry_1832b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1832b4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1832b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnsubscribeLoStruct__FP2LOPFPv5MSGIDPv_vPv
// Address: 0x1832c0 - 0x1832e4

void entry_1832e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1832e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1832e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeLoObject__FP2LOT0
// Address: 0x1832f0 - 0x183310

void entry_183310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183310: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183314: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18331c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183320; return;
}


// Function: UnsubscribeLoObject__FP2LOT0
// Address: 0x183320 - 0x183340

void entry_183340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183340: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183344: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18334c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183350; return;
}


// Function: SendLoMessage__FP2LO5MSGIDPv
// Address: 0x183350 - 0x183384

void entry_183384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183384) {
        switch (ctx->pc) {
            case 0x183398: ctx->pc = 0; goto label_183398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183384: 0x8e100028
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x183388: 0x1200000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1833B8; return;
    }
    // 0x183390: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x183394: 0x0
    // NOP
label_183398:
    // 0x183398: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18339c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1833a0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1833a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1833ac);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1833ac
// Address: 0x1833ac - 0x1833d0

void entry_1833ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1833ac) {
        switch (ctx->pc) {
            case 0x1833b8: ctx->pc = 0; goto label_1833b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1833ac: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x183398; return;
    }
    // 0x1833b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1833b8:
    // 0x1833b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1833bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1833c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1833c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1833cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1833d0; return;
}


// Function: LoadLoFromBrx__FP2LOP18CBinaryInputStream
// Address: 0x1833d0 - 0x1833e0

void entry_1833e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1833e0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1833e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1833ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1833f0; return;
}


// Function: FMatchesLoName__FP2LO3OID
// Address: 0x1833f0 - 0x183438

void entry_18348c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18348c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x183490: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183494: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183498: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostSpliceEventCallback__FP2LOUiPv
// Address: 0x1834a0 - 0x1834dc

void entry_1834dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1834dc: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1834e0: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1834e8);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1834e8
// Address: 0x1834e8 - 0x1834f4

void entry_1834e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1834e8: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1834ec: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1834f4);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1834f4
// Address: 0x1834f4 - 0x183500

void entry_1834f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1834f4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1834f8: 0xc046a00
    SET_GPR_U32(ctx, 31, 0x183500);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    UpdateRecyclable__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_183500
// Address: 0x183500 - 0x183514

void entry_183500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183500: 0x8e24002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 44)));
    // 0x183504: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183508: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18350c: 0xc046926
    SET_GPR_U32(ctx, 31, 0x183514);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183514
// Address: 0x183514 - 0x183524

void entry_183514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183514: 0x1440000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x183544; return;
    }
    // 0x18351c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183524);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183524
// Address: 0x183524 - 0x183530

void entry_183524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183524: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x183528: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183530);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183530
// Address: 0x183530 - 0x18353c

void entry_183530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183530: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183534: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x18353c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_18353c
// Address: 0x18353c - 0x18354c

void entry_18353c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18353c) {
        switch (ctx->pc) {
            case 0x183544: ctx->pc = 0; goto label_183544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18353c: 0x10000040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x183640; return;
    }
label_183544:
    // 0x183544: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x18354c);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18354c
// Address: 0x18354c - 0x18355c

void entry_18354c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18354c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183550: 0x8e850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x183554: 0xc0468ca
    SET_GPR_U32(ctx, 31, 0x18355c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSingleParent__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_18355c
// Address: 0x18355c - 0x183568

void entry_18355c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18355c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183560: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x183568);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_183568
// Address: 0x183568 - 0x183588

void entry_183568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183568: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x18356c: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x183570: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x183574: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183578: 0x8c460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x18357c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x183580: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x183588);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183588
// Address: 0x183588 - 0x183594

void entry_183588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183588: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x18358c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x183594);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183594
// Address: 0x183594 - 0x1835a0

void entry_183594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183594: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183598: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1835a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1835a0
// Address: 0x1835a0 - 0x1835cc

void entry_1835a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1835a0) {
        switch (ctx->pc) {
            case 0x1835b8: ctx->pc = 0; goto label_1835b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1835a0: 0x12400013
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1835F0; return;
    }
    // 0x1835a8: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x1835ac: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1835b0: 0x8c510008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1835b4: 0x0
    // NOP
label_1835b8:
    // 0x1835b8: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1835bc: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1835c0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1835c4: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x1835cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1835cc
// Address: 0x1835cc - 0x1835d8

void entry_1835cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1835cc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1835d0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1835d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1835d8
// Address: 0x1835d8 - 0x1835e4

void entry_1835d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1835d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1835dc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1835e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1835e4
// Address: 0x1835e4 - 0x183600

void entry_1835e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1835e4) {
        switch (ctx->pc) {
            case 0x1835f0: ctx->pc = 0; goto label_1835f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1835e4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1835e8: 0x1600fff3
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1835B8; return;
    }
label_1835f0:
    // 0x1835f0: 0x8e850010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1835f4: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1835f8: 0xc046696
    SET_GPR_U32(ctx, 31, 0x183600);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    RefEvalLambdaBody__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_183600
// Address: 0x183600 - 0x18360c

void entry_183600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183600: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x183604: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x18360c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_18360c
// Address: 0x18360c - 0x183618

void entry_18360c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18360c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x183610: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183618);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183618
// Address: 0x183618 - 0x183624

void entry_183618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183618: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x18361c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183624);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183624
// Address: 0x183624 - 0x183630

void entry_183624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183624: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x183628: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183630);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183630
// Address: 0x183630 - 0x18363c

void entry_183630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183630: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183634: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x18363c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_18363c
// Address: 0x18363c - 0x183668

void entry_18363c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18363c) {
        switch (ctx->pc) {
            case 0x183640: ctx->pc = 0; goto label_183640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18363c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_183640:
    // 0x183640: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x183644: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x183648: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18364c: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x183650: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x183654: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x183658: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18365c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183660: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFilterSpliceEvent__FP2LO7SYMEVIDiPPv
// Address: 0x183668 - 0x1837bc

void entry_1837bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1837bc) {
        switch (ctx->pc) {
            case 0x1837c4: ctx->pc = 0; goto label_1837c4;
            case 0x1837d0: ctx->pc = 0; goto label_1837d0;
            case 0x1837d4: ctx->pc = 0; goto label_1837d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1837bc: 0x10000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1837d4;
    }
label_1837c4:
    // 0x1837c4: 0x8ca50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x1837c8: 0x54a0ffdb
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
        ctx->pc = 0x183738; return;
    }
label_1837d0:
    // 0x1837d0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1837d4:
    // 0x1837d4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1837d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleLoSpliceEvent__FP2LOUiiPPv
// Address: 0x1837e0 - 0x183814

void entry_183814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183814: 0x8e44002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x183818: 0x10800006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x183834; return;
    }
    // 0x183820: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x183824: 0xc046926
    SET_GPR_U32(ctx, 31, 0x18382c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_18382c
// Address: 0x18382c - 0x183840

void entry_18382c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18382c) {
        switch (ctx->pc) {
            case 0x183834: ctx->pc = 0; goto label_183834;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18382c: 0x14400006
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x183848; return;
    }
label_183834:
    // 0x183834: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183838: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183840);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183840
// Address: 0x183840 - 0x183850

void entry_183840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183840) {
        switch (ctx->pc) {
            case 0x183848: ctx->pc = 0; goto label_183848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183840: 0x1000002c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1838F4; return;
    }
label_183848:
    // 0x183848: 0xc046a00
    SET_GPR_U32(ctx, 31, 0x183850);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    UpdateRecyclable__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_183850
// Address: 0x183850 - 0x183864

void entry_183850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183850: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183854: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x183858: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18385c: 0xc060d9a
    SET_GPR_U32(ctx, 31, 0x183864);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime); return;
}


// Function: entry_183864
// Address: 0x183864 - 0x1838a8

void entry_183864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183864: 0x14400020
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1838E8; return;
    }
    // 0x18386c: 0x12200016
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1838C8; return;
    }
    // 0x183874: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x183878: 0x24424ec0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 20160));
    // 0x18387c: 0x3c080024
    SET_GPR_U32(ctx, 8, ((uint32_t)36 << 16));
    // 0x183880: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x183884: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183888: 0x8c660000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18388c: 0x25084dfc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 19964));
    // 0x183890: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x183894: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183898: 0x63080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    // 0x18389c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1838a0: 0xc070792
    SET_GPR_U32(ctx, 31, 0x1838a8);
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    RefSetArgListFromPvs__FiP4OTYPPPv(rdram, ctx, runtime); return;
}


// Function: entry_1838a8
// Address: 0x1838a8 - 0x1838b4

void entry_1838a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1838a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1838ac: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1838b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1838b4
// Address: 0x1838b4 - 0x1838c0

void entry_1838b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1838b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1838b8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1838c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1838c0
// Address: 0x1838c0 - 0x1838e4

void entry_1838c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1838c0) {
        switch (ctx->pc) {
            case 0x1838c8: ctx->pc = 0; goto label_1838c8;
            case 0x1838cc: ctx->pc = 0; goto label_1838cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1838c0: 0x10000002
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1838cc;
    }
label_1838c8:
    // 0x1838c8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1838cc:
    // 0x1838cc: 0x3c050018
    SET_GPR_U32(ctx, 5, ((uint32_t)24 << 16));
    // 0x1838d0: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1838d4: 0x24a534a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 13472));
    // 0x1838d8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1838dc: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1838e4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1838e4
// Address: 0x1838e4 - 0x1838f0

void entry_1838e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1838e4) {
        switch (ctx->pc) {
            case 0x1838e8: ctx->pc = 0; goto label_1838e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1838e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1838e8:
    // 0x1838e8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1838f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1838f0
// Address: 0x1838f0 - 0x183910

void entry_1838f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1838f0) {
        switch (ctx->pc) {
            case 0x1838f4: ctx->pc = 0; goto label_1838f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1838f0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1838f4:
    // 0x1838f4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1838f8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1838fc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183900: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183904: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183908: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureLoSidebagBool__FP2LO5OPTIDi
// Address: 0x183910 - 0x183938

void entry_183938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183938: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18393c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x183944);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_183944
// Address: 0x183944 - 0x18395c

void entry_183944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183944: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183948: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18394c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183950: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183954: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x18395c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_18395c
// Address: 0x18395c - 0x183968

void entry_18395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18395c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183960: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183968);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183968
// Address: 0x183968 - 0x183974

void entry_183968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183968: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18396c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183974);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183974
// Address: 0x183974 - 0x183990

void entry_183974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183974: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x183978: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18397c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183980: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183984: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18398c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183990; return;
}


// Function: EnsureLoSidebagInt__FP2LO5OPTIDi
// Address: 0x183990 - 0x1839b8

void entry_1839b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1839b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1839bc: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1839c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1839c4
// Address: 0x1839c4 - 0x1839dc

void entry_1839c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1839c4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1839c8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1839cc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1839d0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1839d4: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x1839dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1839dc
// Address: 0x1839dc - 0x1839e8

void entry_1839dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1839dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1839e0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1839e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1839e8
// Address: 0x1839e8 - 0x1839f4

void entry_1839e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1839e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1839ec: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1839f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1839f4
// Address: 0x1839f4 - 0x183a10

void entry_1839f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1839f4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1839f8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1839fc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183a00: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183a04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183a0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183a10; return;
}


// Function: EnsureLoSidebagFloat__FP2LO5OPTIDf
// Address: 0x183a10 - 0x183a38

void entry_183a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183a38: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x183a3c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x183a44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_183a44
// Address: 0x183a44 - 0x183a5c

void entry_183a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183a44: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183a48: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183a4c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183a50: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183a54: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x183a5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183a5c
// Address: 0x183a5c - 0x183a68

void entry_183a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183a5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183a60: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183a68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183a68
// Address: 0x183a68 - 0x183a74

void entry_183a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183a68: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183a6c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183a74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183a74
// Address: 0x183a74 - 0x183a90

void entry_183a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183a74: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183a78: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183a7c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183a80: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x183a84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183a8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183a90; return;
}


// Function: EnsureLoSidebagClq__FP2LO5OPTIDP3CLQ
// Address: 0x183a90 - 0x183ab8

void entry_183ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183ab8: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x183ac0);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_183ac0
// Address: 0x183ac0 - 0x183ad4

void entry_183ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183ac0: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x183ac4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183ac8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183acc: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x183ad4);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_183ad4
// Address: 0x183ad4 - 0x183aec

void entry_183ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183ad4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183ad8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183adc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183ae0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183ae4: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x183aec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183aec
// Address: 0x183aec - 0x183af8

void entry_183aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183aec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183af0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183af8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183af8
// Address: 0x183af8 - 0x183b04

void entry_183af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183af8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183afc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183b04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183b04
// Address: 0x183b04 - 0x183b20

void entry_183b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b04: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x183b08: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183b0c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183b10: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183b14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183b1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183b20; return;
}


// Function: EnsureLoSidebagLm__FP2LO5OPTIDP2LM
// Address: 0x183b20 - 0x183b48

void entry_183b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b48: 0xc047216
    SET_GPR_U32(ctx, 31, 0x183b50);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_183b50
// Address: 0x183b50 - 0x183b6c

void entry_183b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b50: 0x6a030007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x183b54: 0x6e030000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x183b58: 0xb0430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183b5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183b60: 0xb4430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183b64: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x183b6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_183b6c
// Address: 0x183b6c - 0x183b84

void entry_183b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b6c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183b70: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183b74: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183b78: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183b7c: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x183b84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183b84
// Address: 0x183b84 - 0x183b90

void entry_183b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b84: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183b88: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183b90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183b90
// Address: 0x183b90 - 0x183b9c

void entry_183b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183b94: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183b9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183b9c
// Address: 0x183b9c - 0x183bb8

void entry_183b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183b9c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x183ba0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183ba4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183ba8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183bac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183bb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183bb8; return;
}


// Function: EnsureLoSidebagOid__FP2LO5OPTID3OID
// Address: 0x183bb8 - 0x183be0

void entry_183be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183be0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183be4: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x183bec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_183bec
// Address: 0x183bec - 0x183c04

void entry_183bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183bec: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183bf0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183bf4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183bf8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183bfc: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x183c04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183c04
// Address: 0x183c04 - 0x183c10

void entry_183c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183c08: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183c10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183c10
// Address: 0x183c10 - 0x183c1c

void entry_183c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183c14: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183c1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183c1c
// Address: 0x183c1c - 0x183c38

void entry_183c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c1c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x183c20: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183c24: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183c28: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183c2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183c38; return;
}


// Function: EnsureLoSidebagVector__FP2LO5OPTIDP6VECTOR
// Address: 0x183c38 - 0x183c60

void entry_183c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c60: 0xc047142
    SET_GPR_U32(ctx, 31, 0x183c68);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_183c68
// Address: 0x183c68 - 0x183c7c

void entry_183c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c68: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x183c6c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x183c70: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183c74: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x183c7c);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_183c7c
// Address: 0x183c7c - 0x183c94

void entry_183c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c7c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x183c80: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x183c84: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183c88: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x183c8c: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x183c94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_183c94
// Address: 0x183c94 - 0x183ca0

void entry_183c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183c94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x183c98: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183ca0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183ca0
// Address: 0x183ca0 - 0x183cac

void entry_183ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183ca0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x183ca4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x183cac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_183cac
// Address: 0x183cac - 0x183cc8

void entry_183cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183cac: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x183cb0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x183cb4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183cb8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183cbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183cc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183cc8; return;
}


// Function: InitLight__FP5LIGHT
// Address: 0x183cc8 - 0x183d70

void entry_183d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183d70: 0xc048fb4
    SET_GPR_U32(ctx, 31, 0x183d78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_183d78
// Address: 0x183d78 - 0x183d88

void entry_183d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183d78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183d7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183d80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateLightXfWorldHierarchy__FP5LIGHT
// Address: 0x183d88 - 0x183d9c

void entry_183d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183d9c: 0xc061074
    SET_GPR_U32(ctx, 31, 0x183da4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildLightVifs__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183da4
// Address: 0x183da4 - 0x183dac

void entry_183da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183da4: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x183dac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183dac
// Address: 0x183dac - 0x183dc0

void entry_183dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183dac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183db0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183db4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183dbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183dc0; return;
}


// Function: RemoveLightFromSw__FP5LIGHT
// Address: 0x183dc0 - 0x183de0

void entry_183de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183de0: 0xc06106c
    SET_GPR_U32(ctx, 31, 0x183de8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InvalidateLight__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183de8
// Address: 0x183de8 - 0x183df8

void entry_183de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183de8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183dec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183df0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddLightToSw__FP5LIGHT
// Address: 0x183df8 - 0x183e18

void entry_183e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183e18: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x183e1c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x183e20: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x183E34; return;
    }
    // 0x183e28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x183e30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_183e30
// Address: 0x183e30 - 0x183e40

void entry_183e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183e30) {
        switch (ctx->pc) {
            case 0x183e34: ctx->pc = 0; goto label_183e34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183e30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_183e34:
    // 0x183e34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183e38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnLightAdd__FP5LIGHT
// Address: 0x183e40 - 0x183e54

void entry_183e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183e54: 0xc060f7e
    SET_GPR_U32(ctx, 31, 0x183e5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddLightToSw__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183e5c
// Address: 0x183e5c - 0x183e70

void entry_183e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183e5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183e60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183e64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183e6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183e70; return;
}


// Function: OnLightRemove__FP5LIGHT
// Address: 0x183e70 - 0x183e84

void entry_183e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183e84: 0xc060f70
    SET_GPR_U32(ctx, 31, 0x183e8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveLightFromSw__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183e8c
// Address: 0x183e8c - 0x183ea0

void entry_183e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183e8c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183e90: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183e94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183e9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183ea0; return;
}


// Function: CloneLight__FP5LIGHTT0
// Address: 0x183ea0 - 0x183ec4

void entry_183ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183ec4) {
        switch (ctx->pc) {
            case 0x183edc: ctx->pc = 0; goto label_183edc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183ec4: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_183edc;
    }
    // 0x183ecc: 0x8e020304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 772)));
    // 0x183ed0: 0x8e430304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 772)));
    // 0x183ed4: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x183ed8: 0x2882b
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_183edc:
    // 0x183edc: 0x12200004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x183EF0; return;
    }
    // 0x183ee4: 0xc060f70
    SET_GPR_U32(ctx, 31, 0x183eec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveLightFromSw__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183eec
// Address: 0x183eec - 0x183f08

void entry_183eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183eec) {
        switch (ctx->pc) {
            case 0x183ef0: ctx->pc = 0; goto label_183ef0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183eec: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_183ef0:
    // 0x183ef0: 0x6a020417
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1047); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x183ef4: 0x6e020410
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1040); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x183ef8: 0xb3a20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183efc: 0xb7a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183f00: 0xc049c12
    SET_GPR_U32(ctx, 31, 0x183f08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneAlo__FP3ALOT0(rdram, ctx, runtime); return;
}


// Function: entry_183f08
// Address: 0x183f08 - 0x183f28

void entry_183f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x183f08: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x183f0c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x183f10: 0xb2020417
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1047); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183f14: 0xb6020410
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1040); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x183f18: 0x12200004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x183F2C; return;
    }
    // 0x183f20: 0xc060f7e
    SET_GPR_U32(ctx, 31, 0x183f28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddLightToSw__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_183f28
// Address: 0x183f28 - 0x183f40

void entry_183f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183f28) {
        switch (ctx->pc) {
            case 0x183f2c: ctx->pc = 0; goto label_183f2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183f28: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_183f2c:
    // 0x183f2c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x183f30: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183f34: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183f38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FitLinearFunction__FffffPfT4
// Address: 0x183f40 - 0x183f8c

void entry_183f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x183f8c) {
        switch (ctx->pc) {
            case 0x183fa0: ctx->pc = 0; goto label_183fa0;
            case 0x183fb8: ctx->pc = 0; goto label_183fb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x183f8c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
        goto label_183fa0;
    }
    // 0x183f94: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    // 0x183f98: 0x10000007
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_183fb8;
    }
label_183fa0:
    // 0x183fa0: 0x4614b881
    ctx->f[2] = FPU_SUB_S(ctx->f[23], ctx->f[20]);
    // 0x183fa4: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x183fa8: 0x46140042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x183fac: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x183fb0: 0x4601a841
    ctx->f[1] = FPU_SUB_S(ctx->f[21], ctx->f[1]);
    // 0x183fb4: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_183fb8:
    // 0x183fb8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x183fbc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x183fc0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x183fc4: 0xc7b70048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[23] = *(float*)&val; }
    // 0x183fc8: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x183fcc: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x183fd0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x183fd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x183fdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x183fe0; return;
}


// Function: FitRecipFunction__FffffPfT4
// Address: 0x183fe0 - 0x184034

void entry_184034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184034) {
        switch (ctx->pc) {
            case 0x184068: ctx->pc = 0; goto label_184068;
            case 0x184070: ctx->pc = 0; goto label_184070;
            case 0x184090: ctx->pc = 0; goto label_184090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184034: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
        goto label_184068;
    }
    // 0x18403c: 0x4600a005
    ctx->f[0] = FPU_ABS_S(ctx->f[20]);
    // 0x184040: 0x46170034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x184044: 0x0
    // NOP
    // 0x184048: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
        goto label_184068;
    }
    // 0x184050: 0x4600a805
    ctx->f[0] = FPU_ABS_S(ctx->f[21]);
    // 0x184054: 0x46170034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x184058: 0x0
    // NOP
    // 0x18405c: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[24], ctx->f[22]);
        goto label_184070;
    }
    // 0x184064: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
label_184068:
    // 0x184068: 0x10000009
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184090;
    }
label_184070:
    // 0x184070: 0x4615a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x184074: 0x4615a081
    ctx->f[2] = FPU_SUB_S(ctx->f[20], ctx->f[21]);
    // 0x184078: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18407c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x184080: 0x46140043
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[20];
    // 0x184084: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x184088: 0x4601b041
    ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[1]);
    // 0x18408c: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_184090:
    // 0x184090: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x184094: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184098: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18409c: 0xc7b80050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[24] = *(float*)&val; }
    // 0x1840a0: 0xc7b70048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[23] = *(float*)&val; }
    // 0x1840a4: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x1840a8: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1840ac: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1840b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertFallOff__FP2LMPfT1
// Address: 0x1840b8 - 0x1840e4

void entry_1840e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1840e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1840e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertAngleStrength__FffffPfT4
// Address: 0x1840f0 - 0x18413c

void entry_18413c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18413c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x184140: 0x4615b302
    ctx->f[12] = FPU_MUL_S(ctx->f[22], ctx->f[21]);
    // 0x184144: 0x4614a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x184148: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x18414c: 0xc081484
    SET_GPR_U32(ctx, 31, 0x184154);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_184154
// Address: 0x184154 - 0x184184

void entry_184154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184154: 0x46000382
    ctx->f[14] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x184158: 0x3c013b80
    SET_GPR_U32(ctx, 1, ((uint32_t)15232 << 16));
    // 0x18415c: 0x34218081
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32897));
    // 0x184160: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x184164: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x184168: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18416c: 0x460dbbc2
    ctx->f[15] = FPU_MUL_S(ctx->f[23], ctx->f[13]);
    // 0x184170: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x184174: 0x46007382
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[0]);
    // 0x184178: 0x460dc342
    ctx->f[13] = FPU_MUL_S(ctx->f[24], ctx->f[13]);
    // 0x18417c: 0xc060fd0
    SET_GPR_U32(ctx, 31, 0x184184);
    ctx->f[14] = FPU_ADD_S(ctx->f[0], ctx->f[14]);
    FitLinearFunction__FffffPfT4(rdram, ctx, runtime); return;
}


// Function: entry_184184
// Address: 0x184184 - 0x1841b0

void entry_184184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184184: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x184188: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18418c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184190: 0xc7b80050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[24] = *(float*)&val; }
    // 0x184194: 0xc7b70048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[23] = *(float*)&val; }
    // 0x184198: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x18419c: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1841a0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1841a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1841ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1841b0; return;
}


// Function: InvalidateLight__FP5LIGHT
// Address: 0x1841b0 - 0x1841d0

void entry_184210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184210: 0xc06106c
    SET_GPR_U32(ctx, 31, 0x184218);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    InvalidateLight__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_184218
// Address: 0x184218 - 0x1842a4

void entry_184218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184218) {
        switch (ctx->pc) {
            case 0x184254: ctx->pc = 0; goto label_184254;
            case 0x184264: ctx->pc = 0; goto label_184264;
            case 0x184290: ctx->pc = 0; goto label_184290;
            case 0x184294: ctx->pc = 0; goto label_184294;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184218: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18421c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x184220: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x184224: 0xc68002f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 760)); ctx->f[0] = *(float*)&val; }
    // 0x184228: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18422c: 0x0
    // NOP
    // 0x184230: 0x4502000c
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 764)); ctx->f[0] = *(float*)&val; }
        goto label_184264;
    }
    // 0x184238: 0xc68002e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 744)); ctx->f[0] = *(float*)&val; }
    // 0x18423c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x184240: 0x0
    // NOP
    // 0x184244: 0x45000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_184254;
    }
    // 0x18424c: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 20), 724), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184294;
    }
label_184254:
    // 0x184254: 0xc68002fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 764)); ctx->f[0] = *(float*)&val; }
    // 0x184258: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18425c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x184260: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
label_184264:
    // 0x184264: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x184268: 0x0
    // NOP
    // 0x18426c: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 724), GPR_U32(ctx, 0));
        goto label_184294;
    }
    // 0x184274: 0xc68002f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 752)); ctx->f[0] = *(float*)&val; }
    // 0x184278: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18427c: 0x0
    // NOP
    // 0x184280: 0x45000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_184290;
    }
    // 0x184288: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 20), 724), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184294;
    }
label_184290:
    // 0x184290: 0xae8002d4
    WRITE32(ADD32(GPR_U32(ctx, 20), 724), GPR_U32(ctx, 0));
label_184294:
    // 0x184294: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184298: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x18429c: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1842a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 1056));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1842a4
// Address: 0x1842a4 - 0x1842d0

void entry_1842a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1842a4: 0xc68102e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 744)); ctx->f[1] = *(float*)&val; }
    // 0x1842a8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1842ac: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1842b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1842b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1842b8: 0x0
    // NOP
    // 0x1842bc: 0x4500000f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1842FC; return;
    }
    // 0x1842c4: 0x268402e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 736));
    // 0x1842c8: 0xc06d160
    SET_GPR_U32(ctx, 31, 0x1842d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertUserHsvToUserRgb__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1842d0
// Address: 0x1842d0 - 0x18431c

void entry_1842d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1842d0) {
        switch (ctx->pc) {
            case 0x1842fc: ctx->pc = 0; goto label_1842fc;
            case 0x184304: ctx->pc = 0; goto label_184304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1842d0: 0xc68102e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 744)); ctx->f[1] = *(float*)&val; }
    // 0x1842d4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1842d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1842dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1842e0: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1842e4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1842e8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1842ec: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1842f0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1842f4: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184304;
    }
label_1842fc:
    // 0x1842fc: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x184300: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
label_184304:
    // 0x184304: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x184308: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18430c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184310: 0x24080016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    // 0x184314: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x18431c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_18431c
// Address: 0x18431c - 0x184340

void entry_18431c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18431c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x184320: 0xc68c02f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 760)); ctx->f[12] = *(float*)&val; }
    // 0x184324: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x184328: 0xc68f02e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 744)); ctx->f[15] = *(float*)&val; }
    // 0x18432c: 0x27a40068
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 104));
    // 0x184330: 0x27a50058
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 88));
    // 0x184334: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x184338: 0xc06103c
    SET_GPR_U32(ctx, 31, 0x184340);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    ConvertAngleStrength__FffffPfT4(rdram, ctx, runtime); return;
}


// Function: entry_184340
// Address: 0x184340 - 0x18435c

void entry_184340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184340: 0xc68c02fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 764)); ctx->f[12] = *(float*)&val; }
    // 0x184344: 0x27a40064
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 100));
    // 0x184348: 0xc68f02f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 752)); ctx->f[15] = *(float*)&val; }
    // 0x18434c: 0x27a50054
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 84));
    // 0x184350: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x184354: 0xc06103c
    SET_GPR_U32(ctx, 31, 0x18435c);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    ConvertAngleStrength__FffffPfT4(rdram, ctx, runtime); return;
}


// Function: entry_18435c
// Address: 0x18435c - 0x184380

void entry_18435c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18435c: 0x3c0143b4
    SET_GPR_U32(ctx, 1, ((uint32_t)17332 << 16));
    // 0x184360: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x184364: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x184368: 0xc68c0300
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 768)); ctx->f[12] = *(float*)&val; }
    // 0x18436c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x184370: 0xc68f02f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 756)); ctx->f[15] = *(float*)&val; }
    // 0x184374: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184378: 0xc06103c
    SET_GPR_U32(ctx, 31, 0x184380);
    ctx->f[12] = FPU_SUB_S(ctx->f[14], ctx->f[12]);
    ConvertAngleStrength__FffffPfT4(rdram, ctx, runtime); return;
}


// Function: entry_184380
// Address: 0x184380 - 0x184398

void entry_184380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184380: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184384: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184388: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x18438c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x184390: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x184398);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 23));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_184398
// Address: 0x184398 - 0x1843e8

void entry_184398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184398) {
        switch (ctx->pc) {
            case 0x1843c0: ctx->pc = 0; goto label_1843c0;
            case 0x1843d0: ctx->pc = 0; goto label_1843d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184398: 0x8e8302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 720)));
    // 0x18439c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1843a0: 0x1062001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x184418; return;
    }
    // 0x1843a8: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1843c0;
    }
    // 0x1843b0: 0x10600007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 1048));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1843d0;
    }
    // 0x1843b8: 0x100000d6
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_184714(rdram, ctx, runtime); return;
    }
label_1843c0:
    // 0x1843c0: 0x104000d4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 1048));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_184714(rdram, ctx, runtime); return;
    }
    // 0x1843c8: 0x1000002f
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x184488; return;
    }
label_1843d0:
    // 0x1843d0: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1843d4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1843d8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1843dc: 0x26860320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 800));
    // 0x1843e0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1843e8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1843e8
// Address: 0x1843e8 - 0x184400

void entry_1843e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1843e8: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1843ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1843f0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1843f4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1843f8: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x184400);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 25));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_184400
// Address: 0x184400 - 0x184410

void entry_184400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184400: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x184404: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184408: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x184410);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 3056));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_184410
// Address: 0x184410 - 0x184440

void entry_184410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184410) {
        switch (ctx->pc) {
            case 0x184418: ctx->pc = 0; goto label_184418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184410: 0x100000c0
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_184714(rdram, ctx, runtime); return;
    }
label_184418:
    // 0x184418: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x18441c: 0xc68c0330
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 816)); ctx->f[12] = *(float*)&val; }
    // 0x184420: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x184424: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x184428: 0x27a50044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 68));
    // 0x18442c: 0xc68e0334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 820)); ctx->f[14] = *(float*)&val; }
    // 0x184430: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x184434: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184438: 0xc060ff8
    SET_GPR_U32(ctx, 31, 0x184440);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 1048));
    FitRecipFunction__FffffPfT4(rdram, ctx, runtime); return;
}


// Function: entry_184440
// Address: 0x184440 - 0x184458

void entry_184440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184440: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184444: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184448: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x18444c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184450: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x184458);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 25));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_184458
// Address: 0x184458 - 0x184470

void entry_184458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184458: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x18445c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184460: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184464: 0x26870140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 320));
    // 0x184468: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x184470);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 26));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_184470
// Address: 0x184470 - 0x184480

void entry_184470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184470: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x184474: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184478: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x184480);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 3376));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_184480
// Address: 0x184480 - 0x1844a0

void entry_184480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184480) {
        switch (ctx->pc) {
            case 0x184488: ctx->pc = 0; goto label_184488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184480: 0x100000a4
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_184714(rdram, ctx, runtime); return;
    }
label_184488:
    // 0x184488: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18448c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x184490: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x184494: 0x26860320
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 800));
    // 0x184498: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1844a0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 992));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1844a0
// Address: 0x1844a0 - 0x1844dc

void entry_1844a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1844a0: 0x26930370
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 20), 880));
    // 0x1844a4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1844a8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1844ac: 0x27b20070
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1844b0: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1844b4: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1844b8: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1844bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1844c0: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1844c4: 0x26860340
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 832));
    // 0x1844c8: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1844cc: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1844d0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1844d4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1844dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1844dc
// Address: 0x1844dc - 0x1844f4

void entry_1844dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1844dc: 0x200b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1844e0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1844e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1844e8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1844ec: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1844f4);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 20), 320));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1844f4
// Address: 0x1844f4 - 0x184514

void entry_1844f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1844f4: 0x26910418
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 20), 1048));
    // 0x1844f8: 0x26820330
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 816));
    // 0x1844fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184500: 0xafa20144
    WRITE32(ADD32(GPR_U32(ctx, 29), 324), GPR_U32(ctx, 2));
    // 0x184504: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x184508: 0xc68c0350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 848)); ctx->f[12] = *(float*)&val; }
    // 0x18450c: 0xc0510f2
    SET_GPR_U32(ctx, 31, 0x184514);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 852)); ctx->f[13] = *(float*)&val; }
    BuildFrustrum(rdram, ctx, runtime); return;
}


// Function: entry_184514
// Address: 0x184514 - 0x184628

void entry_184514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184514) {
        switch (ctx->pc) {
            case 0x184538: ctx->pc = 0; goto label_184538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184514: 0x27a4012c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 300));
    // 0x184518: 0x268303b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 944));
    // 0x18451c: 0xafa40140
    WRITE32(ADD32(GPR_U32(ctx, 29), 320), GPR_U32(ctx, 4));
    // 0x184520: 0x268503c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 960));
    // 0x184524: 0x27b00090
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 144));
    // 0x184528: 0x27b600d0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 208));
    // 0x18452c: 0x27b20110
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 272));
    // 0x184530: 0x27be011c
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 284));
    // 0x184534: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_184538:
    // 0x184538: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x18453c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x184540: 0xda810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x184544: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184548: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18454c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184550: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x184554: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x184558: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18455c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x184560: 0xe660000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 12), *(uint32_t*)&val); }
    // 0x184564: 0x441fff4
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_184538;
    }
    // 0x18456c: 0xc6820334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 820)); ctx->f[2] = *(float*)&val; }
    // 0x184570: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184574: 0xda8203e0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 992)));
    // 0x184578: 0xda810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x18457c: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x184580: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184584: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x184588: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18458c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x184590: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x184594: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x184598: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18459c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1845a0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1845a4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1845a8: 0xfa8203b0
    WRITE128(ADD32(GPR_U32(ctx, 20), 944), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1845ac: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1845b0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1845b4: 0x7fa20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 2));
    // 0x1845b8: 0x46001c06
    ctx->f[16] = FPU_MOV_S(ctx->f[3]);
    // 0x1845bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1845c0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1845c4: 0xe462000c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 12), *(uint32_t*)&val); }
    // 0x1845c8: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1845cc: 0xdba10130
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1845d0: 0xda8203e0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 992)));
    // 0x1845d4: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1845d8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1845dc: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1845e0: 0xda810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x1845e4: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1845e8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1845ec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1845f0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1845f4: 0xfa8203c0
    WRITE128(ADD32(GPR_U32(ctx, 20), 960), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1845f8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1845fc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x184600: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x184604: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x184608: 0x7fa20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    // 0x18460c: 0xe4a3000c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 5), 12), *(uint32_t*)&val); }
    // 0x184610: 0xc68c0350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 848)); ctx->f[12] = *(float*)&val; }
    // 0x184614: 0xc68d0354
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 852)); ctx->f[13] = *(float*)&val; }
    // 0x184618: 0x460ca303
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[12] = ctx->f[20] / ctx->f[12];
    // 0x18461c: 0xc6910334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 820)); ctx->f[17] = *(float*)&val; }
    // 0x184620: 0xc0627d6
    SET_GPR_U32(ctx, 31, 0x184628);
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[13] = ctx->f[20] / ctx->f[13];
    BuildSimpleProjectionMatrix__FffffffP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_184628
// Address: 0x184628 - 0x18463c

void entry_184628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184628: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18462c: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x184630: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184634: 0xc0510b2
    SET_GPR_U32(ctx, 31, 0x18463c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    CombineEyeLookAtProj(rdram, ctx, runtime); return;
}


// Function: entry_18463c
// Address: 0x18463c - 0x184670

void entry_18463c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18463c: 0xdba20130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x184640: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x184644: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x184648: 0x8e8202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 720)));
    // 0x18464c: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184650: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x184654: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x184658: 0x1443000c
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x18468C; return;
    }
    // 0x184660: 0x27a60120
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 288));
    // 0x184664: 0x26840360
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 864));
    // 0x184668: 0xc06102e
    SET_GPR_U32(ctx, 31, 0x184670);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertFallOff__FP2LMPfT1(rdram, ctx, runtime); return;
}


// Function: entry_184670
// Address: 0x184670 - 0x184680

void entry_184670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184670: 0x26840368
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 872));
    // 0x184674: 0x27a50114
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 276));
    // 0x184678: 0xc06102e
    SET_GPR_U32(ctx, 31, 0x184680);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 292));
    ConvertFallOff__FP2LMPfT1(rdram, ctx, runtime); return;
}


// Function: entry_184680
// Address: 0x184680 - 0x1846ac

void entry_184680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184680) {
        switch (ctx->pc) {
            case 0x18468c: ctx->pc = 0; goto label_18468c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184680: 0xe7b40118
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 280), *(uint32_t*)&val); }
    // 0x184684: 0x10000009
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 296), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1846ac(rdram, ctx, runtime); return;
    }
label_18468c:
    // 0x18468c: 0xe7b40114
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 276), *(uint32_t*)&val); }
    // 0x184690: 0x26840358
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 856));
    // 0x184694: 0xe7b50124
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 292), *(uint32_t*)&val); }
    // 0x184698: 0x27a50118
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 280));
    // 0x18469c: 0xe7b40110
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 272), *(uint32_t*)&val); }
    // 0x1846a0: 0x27a60128
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 296));
    // 0x1846a4: 0xc06102e
    SET_GPR_U32(ctx, 31, 0x1846ac);
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 288), *(uint32_t*)&val); }
    ConvertFallOff__FP2LMPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1846ac
// Address: 0x1846ac - 0x1846bc

void entry_1846ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1846ac: 0x8fa40144
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x1846b0: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1846b4: 0xc06102e
    SET_GPR_U32(ctx, 31, 0x1846bc);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    ConvertFallOff__FP2LMPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1846bc
// Address: 0x1846bc - 0x1846d4

void entry_1846bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1846bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1846c0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1846c4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1846c8: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1846cc: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x1846d4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 25));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_1846d4
// Address: 0x1846d4 - 0x1846ec

void entry_1846d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1846d4: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1846d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1846dc: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1846e0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1846e4: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x1846ec);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 27));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_1846ec
// Address: 0x1846ec - 0x184704

void entry_1846ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1846ec: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1846f0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1846f4: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1846f8: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1846fc: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x184704);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 28));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_184704
// Address: 0x184704 - 0x184714

void entry_184704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184704: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x184708: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18470c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x184714);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 3824));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_184714
// Address: 0x184714 - 0x18471c

void entry_184714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184714: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x18471c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_18471c
// Address: 0x18471c - 0x18472c

void entry_18471c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18471c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x184720: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x184724: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x18472c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18472c
// Address: 0x18472c - 0x184768

void entry_18472c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18472c: 0x7bbf01e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x184730: 0x7bbe01d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x184734: 0x7bb701c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x184738: 0x7bb601b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x18473c: 0x7bb501a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x184740: 0x7bb40190
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x184744: 0x7bb30180
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x184748: 0x7bb20170
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x18474c: 0x7bb10160
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x184750: 0x7bb00150
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x184754: 0xc7b501f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[21] = *(float*)&val; }
    // 0x184758: 0xc7b401f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[20] = *(float*)&val; }
    // 0x18475c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 512));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184764: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184768; return;
}


// Function: SetLightKind__FP5LIGHT6LIGHTK
// Address: 0x184768 - 0x1847d4

void entry_1847d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1847d4: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x1847dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1847dc
// Address: 0x1847dc - 0x1847f0

void entry_1847dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1847dc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1847e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1847e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1847ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1847f0; return;
}


// Function: SetLightHighlightColor__FP5LIGHTP6VECTOR
// Address: 0x1847f0 - 0x184808

void entry_184808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184808: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18480c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184814: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184818; return;
}


// Function: SetLightMidtoneStrength__FP5LIGHTf
// Address: 0x184818 - 0x184828

void entry_184828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184828: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18482c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184838; return;
}


// Function: SetLightShadowStrength__FP5LIGHTf
// Address: 0x184838 - 0x184848

void entry_184848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184848: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18484c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184854: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184858; return;
}


// Function: SetLightHighlightAngle__FP5LIGHTf
// Address: 0x184858 - 0x184868

void entry_184868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184868: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18486c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184874: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184878; return;
}


// Function: SetLightMidtoneAngle__FP5LIGHTf
// Address: 0x184878 - 0x184888

void entry_184888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184888: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18488c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184894: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184898; return;
}


// Function: SetLightShadowAngle__FP5LIGHTf
// Address: 0x184898 - 0x1848a8

void entry_1848a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1848a8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1848ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1848b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1848b8; return;
}


// Function: SetLightDirection__FP5LIGHTP6VECTOR
// Address: 0x1848b8 - 0x18494c

void entry_18494c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18494c: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x184954);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_184954
// Address: 0x184954 - 0x184968

void entry_184954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184954: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x184958: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18495c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184964: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184968; return;
}


// Function: SetLightDynamic__FP5LIGHTi
// Address: 0x184968 - 0x184984

void entry_184984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184984) {
        switch (ctx->pc) {
            case 0x184988: ctx->pc = 0; goto label_184988;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184984: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_184988:
    // 0x184988: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLightFallOff__FP5LIGHTP2LM
// Address: 0x184990 - 0x1849b8

void entry_1849b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1849b8: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x1849c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1849c0
// Address: 0x1849c0 - 0x1849d0

void entry_1849c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1849c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1849c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1849c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLightConeAngle__FP5LIGHTf
// Address: 0x1849d0 - 0x1849e8

void entry_1849e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1849e8: 0xc061074
    SET_GPR_U32(ctx, 31, 0x1849f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildLightVifs__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1849f0
// Address: 0x1849f0 - 0x1849f8

void entry_1849f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1849f0: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x1849f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1849f8
// Address: 0x1849f8 - 0x184a08

void entry_1849f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1849f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1849fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184a00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLightHotSpotAngle__FP5LIGHTf
// Address: 0x184a08 - 0x184a20

void entry_184a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184a20: 0xc061074
    SET_GPR_U32(ctx, 31, 0x184a28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildLightVifs__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_184a28
// Address: 0x184a28 - 0x184a38

void entry_184a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184a28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184a2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184a30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLightFrustrumUp__FP5LIGHTP6VECTOR
// Address: 0x184a38 - 0x184a54

void entry_184a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184a54: 0xc0612d6
    SET_GPR_U32(ctx, 31, 0x184a5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_184a5c
// Address: 0x184a5c - 0x184a70

void entry_184a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184a5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184a60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184a64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184a6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184a70; return;
}


// Function: RebuildLightFrustrum__FP5LIGHT
// Address: 0x184a70 - 0x184afc

void entry_184afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184afc: 0x4614ab02
    ctx->f[12] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x184b00: 0xe6000350
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 848), *(uint32_t*)&val); }
    // 0x184b04: 0xc08153c
    SET_GPR_U32(ctx, 31, 0x184b0c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 852), *(uint32_t*)&val); }
    tanf(rdram, ctx, runtime); return;
}


// Function: entry_184b0c
// Address: 0x184b0c - 0x184b58

void entry_184b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184b0c: 0xc6020350
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 848)); ctx->f[2] = *(float*)&val; }
    // 0x184b10: 0xc6030354
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 852)); ctx->f[3] = *(float*)&val; }
    // 0x184b14: 0x46020083
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[2];
    // 0x184b18: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x184b1c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x184b20: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x184b24: 0xe6010364
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 868), *(uint32_t*)&val); }
    // 0x184b28: 0xe601036c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 876), *(uint32_t*)&val); }
    // 0x184b2c: 0xe6020360
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 864), *(uint32_t*)&val); }
    // 0x184b30: 0xe6000368
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 872), *(uint32_t*)&val); }
    // 0x184b34: 0x46020004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x184b38: 0xe601035c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 860), *(uint32_t*)&val); }
    // 0x184b3c: 0xe6000358
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 856), *(uint32_t*)&val); }
    // 0x184b40: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184b44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184b48: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x184b4c: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x184b50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateLightBeamGrfzon__FP5LIGHT
// Address: 0x184b58 - 0x184bd8

void entry_184bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184bd8) {
        switch (ctx->pc) {
            case 0x184be0: ctx->pc = 0; goto label_184be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184bd8: 0x10000038
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x184CBC; return;
    }
label_184be0:
    // 0x184be0: 0xc6000334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 820)); ctx->f[0] = *(float*)&val; }
    // 0x184be4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x184be8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x184bec: 0x3c013c0e
    SET_GPR_U32(ctx, 1, ((uint32_t)15374 << 16));
    // 0x184bf0: 0x3421fa36
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 64054));
    // 0x184bf4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x184bf8: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x184bfc: 0x460c0b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    // 0x184c00: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x184c04: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x184c08: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x184c0c: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x184c10: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x184c14: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x184c18: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x184c1c: 0xc08153c
    SET_GPR_U32(ctx, 31, 0x184c24);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    tanf(rdram, ctx, runtime); return;
}


// Function: entry_184c24
// Address: 0x184c24 - 0x184cb8

void entry_184c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184c24: 0xc6010334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 820)); ctx->f[1] = *(float*)&val; }
    // 0x184c28: 0x260603d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 976));
    // 0x184c2c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184c30: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x184c34: 0x46150d42
    ctx->f[21] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x184c38: 0xda0303e0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 992)));
    // 0x184c3c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x184c40: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x184c44: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x184c48: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x184c4c: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x184c50: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x184c54: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x184c58: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x184c5c: 0x4be418d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x184c60: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x184c64: 0x4be208ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184c68: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x184c6c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x184c70: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x184c74: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x184c78: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x184c7c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x184c80: 0x4b02288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x184c84: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x184c88: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x184c8c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x184c90: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x184c94: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x184c98: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x184c9c: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x184ca0: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x184ca4: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x184ca8: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x184cac: 0x8c641ec4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7876)));
    // 0x184cb0: 0xc07bad8
    SET_GPR_U32(ctx, 31, 0x184cb8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_184cb8
// Address: 0x184cb8 - 0x184cd0

void entry_184cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184cb8) {
        switch (ctx->pc) {
            case 0x184cbc: ctx->pc = 0; goto label_184cbc;
            case 0x184cc0: ctx->pc = 0; goto label_184cc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184cb8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_184cbc:
    // 0x184cbc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_184cc0:
    // 0x184cc0: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x184cc4: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x184cc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLightDiffuse_Old__FP5LIGHTf
// Address: 0x184cd0 - 0x184cec

void entry_184cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184cec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184cf0: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x184cf8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_184cf8
// Address: 0x184cf8 - 0x184d10

void entry_184cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184cf8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184cfc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184d00: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x184d04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184d0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184d10; return;
}


// Function: GetLightDiffuse_Old__FP5LIGHTPf
// Address: 0x184d10 - 0x184d20

void entry_184d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184d3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x184d40: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x184d48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_184d48
// Address: 0x184d48 - 0x184d58

void entry_184d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184d48: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x184d4c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x184d50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetLightSaturate_Old__FP5LIGHTP6VECTOR
// Address: 0x184d58 - 0x184d68

void entry_184d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184d68: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x184d6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x184d74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x184d78; return;
}


// Function: NCmpFindLight__FPP5LIGHTT0
// Address: 0x184d78 - 0x184de8

void entry_184e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184e80) {
        switch (ctx->pc) {
            case 0x184eb8: ctx->pc = 0; goto label_184eb8;
            case 0x184f28: ctx->pc = 0; goto label_184f28;
            case 0x184f2c: ctx->pc = 0; goto label_184f2c;
            case 0x184f30: ctx->pc = 0; goto label_184f30;
            case 0x184f64: ctx->pc = 0; goto label_184f64;
            case 0x184f7c: ctx->pc = 0; goto label_184f7c;
            case 0x184f80: ctx->pc = 0; goto label_184f80;
            case 0x184f90: ctx->pc = 0; goto label_184f90;
            case 0x184f94: ctx->pc = 0; goto label_184f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184e80: 0xaea04668
    WRITE32(ADD32(GPR_U32(ctx, 21), 18024), GPR_U32(ctx, 0));
    // 0x184e84: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x184e88: 0x1a600042
    WRITE32(ADD32(GPR_U32(ctx, 22), 16996), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_184f94;
    }
    // 0x184e90: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x184e94: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x184e98: 0x24584670
    SET_GPR_S32(ctx, 24, ADD32(GPR_U32(ctx, 2), 18032));
    // 0x184e9c: 0x240e0002
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 0), 2));
    // 0x184ea0: 0x240d0001
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184ea4: 0x34128000
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 0), 32768));
    // 0x184ea8: 0x1295f8
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << 23);
    // 0x184eac: 0x2a0782d
    SET_GPR_U64(ctx, 15, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x184eb0: 0x602d
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x184eb4: 0x140582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
label_184eb8:
    // 0x184eb8: 0x8d480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 10), 0)));
    // 0x184ebc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x184ec0: 0x8d020304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 772)));
    // 0x184ec4: 0x8d050308
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 776)));
    // 0x184ec8: 0x1a2300a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 13));
    // 0x184ecc: 0x8d0702d0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 8), 720)));
    // 0x184ed0: 0x34c20002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), 2));
    // 0x184ed4: 0xdd0302c8
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 8), 712)));
    // 0x184ed8: 0x45300b
    if (GPR_U32(ctx, 5) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x184edc: 0x38e40003
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 7), 3));
    // 0x184ee0: 0x721824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x184ee4: 0x34c20004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 6), 4));
    // 0x184ee8: 0x43300b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x184eec: 0x1200000e
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 14));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_184f28;
    }
    // 0x184ef4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x184ef8: 0x28620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16));
    // 0x184efc: 0x1040000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 15), 18024)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_184f2c;
    }
    // 0x184f04: 0x9602000c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x184f08: 0x14470008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 7)) {
        goto label_184f2c;
    }
    // 0x184f10: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x184f14: 0x14460006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        goto label_184f30;
    }
    // 0x184f1c: 0x24620001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    // 0x184f20: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184f64;
    }
label_184f28:
    // 0x184f28: 0x8de44668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 15), 18024)));
label_184f2c:
    // 0x184f2c: 0x2c820010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 16));
label_184f30:
    // 0x184f30: 0x10400017
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_184f90;
    }
    // 0x184f38: 0x24830001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    // 0x184f3c: 0x588021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 24)));
    // 0x184f40: 0xaea34668
    WRITE32(ADD32(GPR_U32(ctx, 21), 18024), GPR_U32(ctx, 3));
    // 0x184f44: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184f48: 0xae060008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 6));
    // 0x184f4c: 0xae040004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 4));
    // 0x184f50: 0xa607000c
    WRITE16(ADD32(GPR_U32(ctx, 16), 12), (uint16_t)GPR_U32(ctx, 7));
    // 0x184f54: 0xae0b0000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 11));
    // 0x184f58: 0xa611000e
    WRITE16(ADD32(GPR_U32(ctx, 16), 14), (uint16_t)GPR_U32(ctx, 17));
    // 0x184f5c: 0x8d020304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 772)));
    // 0x184f60: 0x82600b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 12, GPR_U32(ctx, 4));
label_184f64:
    // 0x184f64: 0x50ed0005
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 13)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_184f7c;
    }
    // 0x184f6c: 0x50ee0003
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 14)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6));
        goto label_184f7c;
    }
    // 0x184f74: 0x10000002
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_184f80;
    }
label_184f7c:
    // 0x184f7c: 0x25290001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 1));
label_184f80:
    // 0x184f80: 0x256b0004
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4));
    // 0x184f84: 0x133102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 19)));
    // 0x184f88: 0x1440ffcb
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_184eb8;
    }
label_184f90:
    // 0x184f90: 0xaecc4264
    WRITE32(ADD32(GPR_U32(ctx, 22), 16996), GPR_U32(ctx, 12));
label_184f94:
    // 0x184f94: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x184f9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_184f9c
// Address: 0x184f9c - 0x184fa4

void entry_184f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184f9c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x184fa4);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_184fa4
// Address: 0x184fa4 - 0x184fb0

void entry_184fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184fa4: 0x24050102
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 258));
    // 0x184fa8: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x184fb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_184fb0
// Address: 0x184fb0 - 0x184fb8

void entry_184fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184fb0: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x184fb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_184fb8
// Address: 0x184fb8 - 0x184fd4

void entry_184fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x184fb8: 0x3c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x184fbc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x184fc0: 0x2e0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x184fc4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x184fc8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x184fcc: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x184fd4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_184fd4
// Address: 0x184fd4 - 0x1850f4

void entry_184fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x184fd4) {
        switch (ctx->pc) {
            case 0x184ff0: ctx->pc = 0; goto label_184ff0;
            case 0x185020: ctx->pc = 0; goto label_185020;
            case 0x185058: ctx->pc = 0; goto label_185058;
            case 0x185094: ctx->pc = 0; goto label_185094;
            case 0x1850a0: ctx->pc = 0; goto label_1850a0;
            case 0x1850d8: ctx->pc = 0; goto label_1850d8;
            case 0x1850dc: ctx->pc = 0; goto label_1850dc;
            case 0x1850e0: ctx->pc = 0; goto label_1850e0;
            case 0x1850ec: ctx->pc = 0; goto label_1850ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x184fd4: 0x1a600045
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_1850ec;
    }
    // 0x184fdc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x184fe0: 0x240c0001
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 1));
    // 0x184fe4: 0x244b4268
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 2), 17000));
    // 0x184fe8: 0x91080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 2));
    // 0x184fec: 0x0
    // NOP
label_184ff0:
    // 0x184ff0: 0x4b1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x184ff4: 0x8c480000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x184ff8: 0x8d0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 720)));
    // 0x184ffc: 0x504c0008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 12)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 320)); ctx->f[1] = *(float*)&val; }
        goto label_185020;
    }
    // 0x185004: 0x18400035
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 9), 1));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1850dc;
    }
    // 0x18500c: 0x28420004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    // 0x185010: 0x50400033
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 9, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
        goto label_1850e0;
    }
    // 0x185018: 0x1000001e
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_185094;
    }
label_185020:
    // 0x185020: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x185024: 0x8fa60054
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x185028: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x18502c: 0xe7a10040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x185030: 0xc5000144
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 324)); ctx->f[0] = *(float*)&val; }
    // 0x185034: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x185038: 0xe7a00044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x18503c: 0xc5010148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 328)); ctx->f[1] = *(float*)&val; }
    // 0x185040: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x185044: 0xe7a10048
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    // 0x185048: 0xc5000334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 820)); ctx->f[0] = *(float*)&val; }
    // 0x18504c: 0xe7a0004c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 76), *(uint32_t*)&val); }
    // 0x185050: 0x252a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 9), 1));
    // 0x185054: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_185058:
    // 0x185058: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x18505c: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x185060: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x185064: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x185068: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x18506c: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x185070: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x185074: 0xacc30004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 3));
    // 0x185078: 0xacc40008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 4));
    // 0x18507c: 0xacc5000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    // 0x185080: 0x501fff5
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_185058;
    }
    // 0x185088: 0x8fa20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x18508c: 0x10000012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1850d8;
    }
label_185094:
    // 0x185094: 0x25060370
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 8), 880));
    // 0x185098: 0x252a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 9), 1));
    // 0x18509c: 0x24080014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 20));
label_1850a0:
    // 0x1850a0: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1850a4: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x1850a8: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x1850ac: 0x8cc40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1850b0: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1850b4: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x1850b8: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1850bc: 0xace30004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 3));
    // 0x1850c0: 0xace40008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 4));
    // 0x1850c4: 0xace5000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 5));
    // 0x1850c8: 0x501fff5
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_1850a0;
    }
    // 0x1850d0: 0x8fa20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1850d4: 0x24420060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 96));
label_1850d8:
    // 0x1850d8: 0xafa20054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
label_1850dc:
    // 0x1850dc: 0x140482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
label_1850e0:
    // 0x1850e0: 0x133102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 19)));
    // 0x1850e4: 0x1440ffc2
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_184ff0;
    }
label_1850ec:
    // 0x1850ec: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x1850f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1850f4
// Address: 0x1850f4 - 0x185104

void entry_1850f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1850f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1850f8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1850fc: 0xc054ab8
    SET_GPR_U32(ctx, 31, 0x185104);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 7956)));
    Send__4DMASP10sceDmaChan(rdram, ctx, runtime); return;
}


// Function: entry_185104
// Address: 0x185104 - 0x185118

void entry_185104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185104: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x185108: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18510c: 0x8c441f14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7956)));
    // 0x185110: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x185118);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_185118
// Address: 0x185118 - 0x185120

void entry_185118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185118: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x185120);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_185120
// Address: 0x185120 - 0x185150

void entry_185120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185120: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x185124: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x185128: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18512c: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x185130: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x185134: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x185138: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18513c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x185140: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x185144: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x185148: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT
// Address: 0x185150 - 0x185358

void entry_18536c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18536c: 0x3c014448
    SET_GPR_U32(ctx, 1, ((uint32_t)17480 << 16));
    // 0x185370: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x185374: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x185378: 0xae080020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 8));
    // 0x18537c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x185380: 0xe6000040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    // 0x185384: 0x24424770
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18288));
    // 0x185388: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x18538c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x185390: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x185394: 0x24634790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 18320));
    // 0x185398: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x18539c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1853a0: 0x7e040050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 4));
    // 0x1853a4: 0x24ca4780
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 18304));
    // 0x1853a8: 0x69420007
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1853ac: 0x6d420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1853b0: 0xb2020067
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 103); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1853b4: 0xb6020060
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 96); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1853b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1853bc: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1853c0: 0x7e020070
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), GPR_VEC(ctx, 2));
    // 0x1853c4: 0x24a647a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 5), 18336));
    // 0x1853c8: 0x68c20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1853cc: 0x6cc20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1853d0: 0xb2020087
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1853d4: 0xb6020080
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1853d8: 0xae080048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 8));
    // 0x1853dc: 0xae070044
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 7));
    // 0x1853e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1853e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1853ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1853f0; return;
}


// Function: SetActlaTarget__FP5ACTLAP3ALOP6VECTOR
// Address: 0x1853f0 - 0x18541c

void entry_18541c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18541c) {
        switch (ctx->pc) {
            case 0x185424: ctx->pc = 0; goto label_185424;
            case 0x18543c: ctx->pc = 0; goto label_18543c;
            case 0x185448: ctx->pc = 0; goto label_185448;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18541c: 0x16020007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_18543c;
    }
label_185424:
    // 0x185424: 0xae20001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 0));
    // 0x185428: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x18542c: 0xae200024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x185430: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x185434: 0x10000004
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_185448;
    }
label_18543c:
    // 0x18543c: 0xae300024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 16));
    // 0x185440: 0xae23001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 3));
    // 0x185444: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
label_185448:
    // 0x185448: 0x7e220030
    WRITE128(ADD32(GPR_U32(ctx, 17), 48), GPR_VEC(ctx, 2));
    // 0x18544c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x185450: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185454: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x185458: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18545c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185464: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185468; return;
}


// Function: PaloGetActlaTarget__FP5ACTLA
// Address: 0x185468 - 0x18548c

void entry_18548c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18548c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x185490: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateActla__FP5ACTLAf
// Address: 0x185498 - 0x1854b4

void entry_1854b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1854b4) {
        switch (ctx->pc) {
            case 0x185500: ctx->pc = 0; goto label_185500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1854b4: 0x1040001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x185524; return;
    }
    // 0x1854bc: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1854c0: 0xc6010040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1854c4: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1854c8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1854cc: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1854d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1854d4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1854d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1854dc: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1854e0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1854e4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1854e8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1854ec: 0x0
    // NOP
    // 0x1854f0: 0x45000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_185500;
    }
    // 0x1854f8: 0x10000003
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_185508(rdram, ctx, runtime); return;
    }
label_185500:
    // 0x185500: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x185508);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_185508
// Address: 0x185508 - 0x185520

void entry_185508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185508: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x18550c: 0x12220005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x185524; return;
    }
    // 0x185514: 0xae110014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 17));
    // 0x185518: 0xc04a696
    SET_GPR_U32(ctx, 31, 0x185520);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    ResortAloActList__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_185520
// Address: 0x185520 - 0x185538

void entry_185520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185520) {
        switch (ctx->pc) {
            case 0x185524: ctx->pc = 0; goto label_185524;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185520: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_185524:
    // 0x185524: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x185528: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18552c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185534: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185538; return;
}


// Function: GetActlaRotationGoal__FP5ACTLAfP7MATRIX3P6VECTOR
// Address: 0x185538 - 0x18559c

void entry_18559c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18559c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1855a0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1855a4: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1855a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1855ac: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1855b0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1855b4: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1855bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1855bc
// Address: 0x1855bc - 0x1855fc

void entry_1855bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1855bc: 0xda030030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1855c0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1855c4: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1855c8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1855cc: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1855d0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1855d4: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1855d8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1855dc: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1855e0: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1855e4: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1855e8: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1855ec: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1855f0: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1855f4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1855fc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1855fc
// Address: 0x1855fc - 0x18567c

void entry_1855fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1855fc) {
        switch (ctx->pc) {
            case 0x18564c: ctx->pc = 0; goto label_18564c;
            case 0x185670: ctx->pc = 0; goto label_185670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1855fc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x185600: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x185604: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x185608: 0xd8420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x18560c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x185610: 0xc6010040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[1] = *(float*)&val; }
    // 0x185614: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x185618: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18561c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x185620: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x185624: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x185628: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18562c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x185630: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x185634: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x185638: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18563c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x185640: 0x0
    // NOP
    // 0x185644: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_18564c;
    }
label_18564c:
    // 0x18564c: 0x10600008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_185670;
    }
    // 0x185654: 0x7a2201a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 416)));
    // 0x185658: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x18565c: 0x7a2301b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 432)));
    // 0x185660: 0x7e430010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 3));
    // 0x185664: 0x7a2201c0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 448)));
    // 0x185668: 0x10000033
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_185738(rdram, ctx, runtime); return;
    }
label_185670:
    // 0x185670: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x185674: 0xc07b76c
    SET_GPR_U32(ctx, 31, 0x18567c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 84));
    CalculateVectorPanTilt__FP6VECTORPfT1(rdram, ctx, runtime); return;
}


// Function: entry_18567c
// Address: 0x18567c - 0x185738

void entry_18567c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18567c) {
        switch (ctx->pc) {
            case 0x1856bc: ctx->pc = 0; goto label_1856bc;
            case 0x1856cc: ctx->pc = 0; goto label_1856cc;
            case 0x185710: ctx->pc = 0; goto label_185710;
            case 0x185724: ctx->pc = 0; goto label_185724;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18567c: 0x26020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 80));
    // 0x185680: 0xc7a20050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[2] = *(float*)&val; }
    // 0x185684: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x185688: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x18568c: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x185690: 0xc6030050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[3] = *(float*)&val; }
    // 0x185694: 0xc6040060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 96)); ctx->f[4] = *(float*)&val; }
    // 0x185698: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x18569c: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1856a0: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1856a4: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1856a8: 0x0
    // NOP
    // 0x1856ac: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 100)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1856bc;
    }
    // 0x1856b4: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1856cc;
    }
label_1856bc:
    // 0x1856bc: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1856c0: 0x0
    // NOP
    // 0x1856c4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1856cc;
    }
label_1856cc:
    // 0x1856cc: 0xe7a30050
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1856d0: 0x26020070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 112));
    // 0x1856d4: 0xc7a20054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[2] = *(float*)&val; }
    // 0x1856d8: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1856dc: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1856e0: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1856e4: 0xc6030070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[3] = *(float*)&val; }
    // 0x1856e8: 0xc6040080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 128)); ctx->f[4] = *(float*)&val; }
    // 0x1856ec: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1856f0: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1856f4: 0x46021b40
    ctx->f[13] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1856f8: 0x46046834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1856fc: 0x0
    // NOP
    // 0x185700: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 132)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_185710;
    }
    // 0x185708: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_185724;
    }
label_185710:
    // 0x185710: 0x460d2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x185714: 0x0
    // NOP
    // 0x185718: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_185724;
    }
    // 0x185720: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_185724:
    // 0x185724: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x185728: 0x46001b46
    ctx->f[13] = FPU_MOV_S(ctx->f[3]);
    // 0x18572c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x185730: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x185738);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_185738
// Address: 0x185738 - 0x185758

void entry_185738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185738: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18573c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x185740: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x185744: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x185748: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x18574c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185758; return;
}


// Function: game_main
// Address: 0x185758 - 0x1857a0

void entry_1857a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1857a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1857a4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1857a8: 0xac504834
    WRITE32(ADD32(GPR_U32(ctx, 2), 18484), GPR_U32(ctx, 16));
    // 0x1857ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1857b0: 0xac714838
    WRITE32(ADD32(GPR_U32(ctx, 3), 18488), GPR_U32(ctx, 17));
    // 0x1857b4: 0xc0616ce
    SET_GPR_U32(ctx, 31, 0x1857bc);
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 2), 4294941184));
    Startup__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1857bc
// Address: 0x1857bc - 0x1857e8

void entry_1857bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1857bc) {
        switch (ctx->pc) {
            case 0x1857c8: ctx->pc = 0; goto label_1857c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1857bc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1857c0: 0x24575f80
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 24448));
    // 0x1857c4: 0x0
    // NOP
label_1857c8:
    // 0x1857c8: 0x8fc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x1857cc: 0x10400009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 23280)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1857F4; return;
    }
    // 0x1857d4: 0x8ee20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 4)));
    // 0x1857d8: 0x10560006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 23280)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 22)) {
        ctx->pc = 0x1857F4; return;
    }
    // 0x1857e0: 0xc057c84
    SET_GPR_U32(ctx, 31, 0x1857e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FlushFrames__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1857e8
// Address: 0x1857e8 - 0x1857f0

void entry_1857e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1857e8: 0xc063c52
    SET_GPR_U32(ctx, 31, 0x1857f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    ExecuteOids__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_1857f0
// Address: 0x1857f0 - 0x185804

void entry_1857f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1857f0) {
        switch (ctx->pc) {
            case 0x1857f4: ctx->pc = 0; goto label_1857f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1857f0: 0x8ea25af0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 23280)));
label_1857f4:
    // 0x1857f4: 0x10400005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 23280));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18580c(rdram, ctx, runtime); return;
    }
    // 0x1857fc: 0xc057c84
    SET_GPR_U32(ctx, 31, 0x185804);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FlushFrames__Fi(rdram, ctx, runtime); return;
}


// Function: entry_185804
// Address: 0x185804 - 0x18580c

void entry_185804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185804: 0xc0793aa
    SET_GPR_U32(ctx, 31, 0x18580c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Execute__11CTransition(rdram, ctx, runtime); return;
}


// Function: entry_18580c
// Address: 0x18580c - 0x185834
// FIXED: Branch delay slot bug - recompiler executed delay slot BEFORE checking branch condition

void entry_18580c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18580c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x185810: 0x24509a00
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294941184));
    // 0x185814: 0x8e020004  - Load g_mpeg.oid_1 into $2
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x185818: 0x10400009  - beqz $2, .L00185840 (skip MPEG if oid_1 == 0)
    // FIX: Save branch condition BEFORE delay slot modifies $2
    {
        uint32_t branch_cond = GPR_U32(ctx, 2);  // oid_1 value
        // 0x18581c: lui $2, 0x0026 (delay slot)
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        if (branch_cond == 0) {
            ctx->pc = 0x185840; return;
        }
    }
    // 0x185820: 0x8ee20004  - Load g_pwipe->wipes into $2
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 4)));
    // 0x185824: 0x10560006  - beq $2, $22, .L00185840 (skip if wipes == WIPES_WipingOut)
    // FIX: Same delay slot bug
    {
        uint32_t branch_cond = GPR_U32(ctx, 2);  // wipes value
        // Delay slot: lui $2, 0x0026
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        if (branch_cond == GPR_U32(ctx, 22)) {
            ctx->pc = 0x185840; return;
        }
    }
    // 0x18582c: 0xc057c84
    SET_GPR_U32(ctx, 31, 0x185834);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FlushFrames__Fi(rdram, ctx, runtime); return;
}


// Function: entry_185834
// Address: 0x185834 - 0x18583c

void entry_185834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185834: 0xc063c52
    SET_GPR_U32(ctx, 31, 0x18583c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ExecuteOids__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_18583c
// Address: 0x18583c - 0x185850

void entry_18583c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18583c) {
        switch (ctx->pc) {
            case 0x185840: ctx->pc = 0; goto label_185840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18583c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_185840:
    // 0x185840: 0x24442c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 11376));
    // 0x185844: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x185848: 0xc05b88e
    SET_GPR_U32(ctx, 31, 0x185850);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 23488));
    UpdateJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_185850
// Address: 0x185850 - 0x18585c

void entry_185850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185850: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x185854: 0xc05bcb8
    SET_GPR_U32(ctx, 31, 0x18585c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    UpdateCodes__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18585c
// Address: 0x18585c - 0x185868

void entry_18585c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18585c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x185860: 0xc062f72
    SET_GPR_U32(ctx, 31, 0x185868);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 19008));
    UpdateSave__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_185868
// Address: 0x185868 - 0x185870

void entry_185868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185868: 0xc07a442
    SET_GPR_U32(ctx, 31, 0x185870);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateUi__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_185870
// Address: 0x185870 - 0x185878

void entry_185870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185870: 0xc0581f4
    SET_GPR_U32(ctx, 31, 0x185878);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    UpdateGameState__Ff(rdram, ctx, runtime); return;
}


// Function: entry_185878
// Address: 0x185878 - 0x18588c

void entry_185878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185878: 0x8e625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    // 0x18587c: 0x1040001a
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1858e8(rdram, ctx, runtime); return;
    }
    // 0x185884: 0xc05109c
    SET_GPR_U32(ctx, 31, 0x18588c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    SetupCm__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_18588c
// Address: 0x18588c - 0x185894

void entry_18588c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18588c: 0xc057a7c
    SET_GPR_U32(ctx, 31, 0x185894);
    OpenFrame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_185894
// Address: 0x185894 - 0x18589c

void entry_185894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185894: 0xc050bc4
    SET_GPR_U32(ctx, 31, 0x18589c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    MarkClockTick__FP5CLOCK(rdram, ctx, runtime); return;
}


// Function: entry_18589c
// Address: 0x18589c - 0x1858b8

void entry_18589c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18589c: 0x8e645710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    // 0x1858a0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1858a4: 0x8c420054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x1858a8: 0x10400004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1858BC; return;
    }
    // 0x1858b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1858b8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1858b8
// Address: 0x1858b8 - 0x1858c4

void entry_1858b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1858b8) {
        switch (ctx->pc) {
            case 0x1858bc: ctx->pc = 0; goto label_1858bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1858b8: 0x8e051990
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
label_1858bc:
    // 0x1858bc: 0xc0675b0
    SET_GPR_U32(ctx, 31, 0x1858c4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    RenderSw__FP2SWP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1858c4
// Address: 0x1858c4 - 0x1858cc

void entry_1858c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1858c4: 0xc07a59a
    SET_GPR_U32(ctx, 31, 0x1858cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderUi__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1858cc
// Address: 0x1858cc - 0x1858d8

void entry_1858cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1858cc: 0x8e051990
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1858d0: 0xc067726
    SET_GPR_U32(ctx, 31, 0x1858d8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    DrawSw__FP2SWP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1858d8
// Address: 0x1858d8 - 0x1858e0

void entry_1858d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1858d8: 0xc07a592
    SET_GPR_U32(ctx, 31, 0x1858e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    DrawUi__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1858e0
// Address: 0x1858e0 - 0x1858e8

void entry_1858e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1858e0: 0xc057b1a
    SET_GPR_U32(ctx, 31, 0x1858e8);
    CloseFrame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1858e8
// Address: 0x1858e8 - 0x1858f8

void entry_1858e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1858e8: 0x8e8222cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8908)));
    // 0x1858ec: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1858f0: 0x1000ffb5
    WRITE32(ADD32(GPR_U32(ctx, 20), 8908), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1857C8; return;
    }
    // Fall-through to next function
    ctx->pc = 0x1858f8; return;
}


// Function: StartupSif__Fv
// Address: 0x1858f8 - 0x18591c

void entry_18591c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18591c: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x185924);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_185924
// Address: 0x185924 - 0x18592c

void entry_185924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185924: 0xc080d52
    SET_GPR_U32(ctx, 31, 0x18592c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdInit(rdram, ctx, runtime); return;
}


// Function: entry_18592c
// Address: 0x18592c - 0x185934

void entry_18592c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18592c: 0xc05025a
    SET_GPR_U32(ctx, 31, 0x185934);
    FValidCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_185934
// Address: 0x185934 - 0x185964

void entry_185934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185934) {
        switch (ctx->pc) {
            case 0x185940: ctx->pc = 0; goto label_185940;
            case 0x18595c: ctx->pc = 0; goto label_18595c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185934: 0x14400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18595c;
    }
    // 0x18593c: 0x0
    // NOP
label_185940:
    // 0x185940: 0x0
    // NOP
    // 0x185944: 0x0
    // NOP
    // 0x185948: 0x0
    // NOP
    // 0x18594c: 0x0
    // NOP
    // 0x185950: 0x0
    // NOP
    // 0x185954: 0x1000fffa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_185940;
    }
label_18595c:
    // 0x18595c: 0xc05026a
    SET_GPR_U32(ctx, 31, 0x185964);
    SetCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_185964
// Address: 0x185964 - 0x18596c

void entry_185964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185964: 0xc07e2fe
    SET_GPR_U32(ctx, 31, 0x18596c);
    sceFsReset(rdram, ctx, runtime); return;
}


// Function: entry_18596c
// Address: 0x18596c - 0x185978

void entry_18596c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18596c) {
        switch (ctx->pc) {
            case 0x185970: ctx->pc = 0; goto label_185970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18596c: 0x0
    // NOP
label_185970:
    // 0x185970: 0xc07e714
    SET_GPR_U32(ctx, 31, 0x185978);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    sceSifRebootIop(rdram, ctx, runtime); return;
}


// Function: entry_185978
// Address: 0x185978 - 0x185988

void entry_185978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185978) {
        switch (ctx->pc) {
            case 0x185980: ctx->pc = 0; goto label_185980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185978: 0x1040fffd
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x185970; return;
    }
label_185980:
    // 0x185980: 0xc07e706
    SET_GPR_U32(ctx, 31, 0x185988);
    sceSifSyncIop(rdram, ctx, runtime); return;
}


// Function: entry_185988
// Address: 0x185988 - 0x185998

void entry_185988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185988: 0x1040fffd
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x185980; return;
    }
    // 0x185990: 0xc07defa
    SET_GPR_U32(ctx, 31, 0x185998);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifInitRpc(rdram, ctx, runtime); return;
}


// Function: entry_185998
// Address: 0x185998 - 0x1859a0

void entry_185998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185998: 0xc07e608
    SET_GPR_U32(ctx, 31, 0x1859a0);
    sceSifLoadFileReset(rdram, ctx, runtime); return;
}


// Function: entry_1859a0
// Address: 0x1859a0 - 0x1859a8

void entry_1859a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1859a0: 0xc080d52
    SET_GPR_U32(ctx, 31, 0x1859a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdInit(rdram, ctx, runtime); return;
}


// Function: entry_1859a8
// Address: 0x1859a8 - 0x1859b0

void entry_1859a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1859a8: 0xc05025a
    SET_GPR_U32(ctx, 31, 0x1859b0);
    FValidCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1859b0
// Address: 0x1859b0 - 0x1859dc

void entry_1859b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1859b0) {
        switch (ctx->pc) {
            case 0x1859b8: ctx->pc = 0; goto label_1859b8;
            case 0x1859d4: ctx->pc = 0; goto label_1859d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1859b0: 0x14400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1859d4;
    }
label_1859b8:
    // 0x1859b8: 0x0
    // NOP
    // 0x1859bc: 0x0
    // NOP
    // 0x1859c0: 0x0
    // NOP
    // 0x1859c4: 0x0
    // NOP
    // 0x1859c8: 0x0
    // NOP
    // 0x1859cc: 0x1000fffa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1859b8;
    }
label_1859d4:
    // 0x1859d4: 0xc05026a
    SET_GPR_U32(ctx, 31, 0x1859dc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCdMmode__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1859dc
// Address: 0x1859dc - 0x1859e4

void entry_1859dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1859dc: 0xc07e2fe
    SET_GPR_U32(ctx, 31, 0x1859e4);
    sceFsReset(rdram, ctx, runtime); return;
}


// Function: entry_1859e4
// Address: 0x1859e4 - 0x1859ec

void entry_1859e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1859e4: 0xc080e0a
    SET_GPR_U32(ctx, 31, 0x1859ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceCdDiskReady(rdram, ctx, runtime); return;
}


// Function: entry_1859ec
// Address: 0x1859ec - 0x1859f4

void entry_1859ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1859ec: 0xc05035a
    SET_GPR_U32(ctx, 31, 0x1859f4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FCdCompleted__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1859f4
// Address: 0x1859f4 - 0x185a1c

void entry_1859f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1859f4) {
        switch (ctx->pc) {
            case 0x185a08: ctx->pc = 0; goto label_185a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1859f4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1859f8: 0x247147a8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 18344));
    // 0x1859fc: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x185a00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185a04: 0x0
    // NOP
label_185a08:
    // 0x185a08: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x185a0c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x185a10: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x185a14: 0xc0502d8
    SET_GPR_U32(ctx, 31, 0x185a1c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    CdPath__FPcT0i(rdram, ctx, runtime); return;
}


// Function: entry_185a1c
// Address: 0x185a1c - 0x185a2c

void entry_185a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185a1c) {
        switch (ctx->pc) {
            case 0x185a20: ctx->pc = 0; goto label_185a20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185a1c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_185a20:
    // 0x185a20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x185a24: 0xc07e6a4
    SET_GPR_U32(ctx, 31, 0x185a2c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifLoadModule(rdram, ctx, runtime); return;
}


// Function: entry_185a2c
// Address: 0x185a2c - 0x185a58

void entry_185a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185a2c: 0x440fffc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x185A20; return;
    }
    // 0x185a34: 0x2e020006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 6));
    // 0x185a38: 0x5440fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
        ctx->pc = 0x185A08; return;
    }
    // 0x185a40: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x185a44: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x185a48: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x185a4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185a54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185a58; return;
}


// Function: StartupVU0__Fv
// Address: 0x185a58 - 0x185a80

void entry_185a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185a80: 0x8e041f14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7956)));
    // 0x185a84: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x185a88: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x185a90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 7696));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_185a90
// Address: 0x185a90 - 0x185aa0

void entry_185a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185a90: 0x8e041f14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7956)));
    // 0x185a94: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x185a98: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x185aa0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_185aa0
// Address: 0x185aa0 - 0x185ac8

void entry_185aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185aa0: 0x8e041f14
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7956)));
    // 0x185aa4: 0x2403ffbf
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967231));
    // 0x185aa8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x185aac: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x185ab0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x185ab4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x185ab8: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x185abc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185ac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185ac8; return;
}


// Function: StartupVU1__Fv
// Address: 0x185ac8 - 0x185af0

void entry_185af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185af0: 0x8e041f18
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7960)));
    // 0x185af4: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x185af8: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x185b00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8464));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_185b00
// Address: 0x185b00 - 0x185b10

void entry_185b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185b00: 0x8e041f18
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7960)));
    // 0x185b04: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x185b08: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x185b10);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_185b10
// Address: 0x185b10 - 0x185b38

void entry_185b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185b10: 0x8e041f18
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 7960)));
    // 0x185b14: 0x2403ffbf
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967231));
    // 0x185b18: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x185b1c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x185b20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x185b24: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x185b28: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x185b2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x185b34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x185b38; return;
}


// Function: Startup__Fv
// Address: 0x185b38 - 0x185b8c

void entry_185b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185b8c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x185b90: 0xc06479c
    SET_GPR_U32(ctx, 31, 0x185b98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    SetPhase__F5PHASE(rdram, ctx, runtime); return;
}


// Function: entry_185b98
// Address: 0x185b98 - 0x185ba0

void entry_185b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185b98: 0xc064c9c
    SET_GPR_U32(ctx, 31, 0x185ba0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Begin__5CProg(rdram, ctx, runtime); return;
}


// Function: entry_185ba0
// Address: 0x185ba0 - 0x185bc4

void entry_185ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185ba0) {
        switch (ctx->pc) {
            case 0x185bb0: ctx->pc = 0; goto label_185bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185ba0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x185ba4: 0x245147c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 18368));
    // 0x185ba8: 0x2a020003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    // 0x185bac: 0x0
    // NOP
label_185bb0:
    // 0x185bb0: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        entry_185bc8(rdram, ctx, runtime); return;
    }
    // 0x185bb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185bbc: 0xc064ca2
    SET_GPR_U32(ctx, 31, 0x185bc4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetRemain__5CProgi(rdram, ctx, runtime); return;
}


// Function: entry_185bc4
// Address: 0x185bc4 - 0x185bc8

void entry_185bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185bc4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // Fall-through to next function
    ctx->pc = 0x185bc8; return;
}


// Function: entry_185bc8
// Address: 0x185bc8 - 0x185bd8

void entry_185bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185bc8: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x185bcc: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x185bd0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x185bd8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_185bd8
// Address: 0x185bd8 - 0x185bf0

void entry_185bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185bd8: 0x2e02001d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 29));
    // 0x185bdc: 0x1440fff4
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x185BB0; return;
    }
    // 0x185be4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185be8: 0xc064ca2
    SET_GPR_U32(ctx, 31, 0x185bf0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetRemain__5CProgi(rdram, ctx, runtime); return;
}


// Function: entry_185bf0
// Address: 0x185bf0 - 0x185bf8

void entry_185bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185bf0: 0xc064cc0
    SET_GPR_U32(ctx, 31, 0x185bf8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    End__5CProg(rdram, ctx, runtime); return;
}


// Function: entry_185bf8
// Address: 0x185bf8 - 0x185c00

void entry_185bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185bf8: 0xc0647ac
    SET_GPR_U32(ctx, 31, 0x185c00);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    ClearPhase__F5PHASE(rdram, ctx, runtime); return;
}


// Function: entry_185c00
// Address: 0x185c00 - 0x185c18

void entry_185c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185c00: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x185c04: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x185c08: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x185c0c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x185c10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MuFromAmtlk__FP4MTLK
// Address: 0x185c18 - 0x185ca0

void entry_185d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185d84) {
        switch (ctx->pc) {
            case 0x185da8: ctx->pc = 0; goto label_185da8;
            case 0x185dc4: ctx->pc = 0; goto label_185dc4;
            case 0x185dcc: ctx->pc = 0; goto label_185dcc;
            case 0x185e18: ctx->pc = 0; goto label_185e18;
            case 0x185e44: ctx->pc = 0; goto label_185e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185d84: 0x27a30020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 32));
    // 0x185d88: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x185d8c: 0xafa3002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 3));
    // 0x185d90: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x185d94: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x185d98: 0xe4740090
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 144), *(uint32_t*)&val); }
    // 0x185d9c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x185da0: 0x7ac20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x185da4: 0x7c620080
    WRITE128(ADD32(GPR_U32(ctx, 3), 128), GPR_VEC(ctx, 2));
label_185da8:
    // 0x185da8: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x185dac: 0x233800b
    if (GPR_U32(ctx, 19) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 17));
    // 0x185db0: 0x12000004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_185dc4;
    }
    // 0x185db8: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x185dbc: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_185dcc;
    }
label_185dc4:
    // 0x185dc4: 0xf8810030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x185dc8: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
label_185dcc:
    // 0x185dcc: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x185dd0: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x185dd4: 0x1440fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_185da8;
    }
    // 0x185ddc: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
    // 0x185de0: 0x7aa30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x185de4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185de8: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x185dec: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185df0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x185df4: 0x7c430010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 3));
    // 0x185df8: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x185dfc: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x185e00: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x185e04: 0xdac20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x185e08: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x185e0c: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x185e10: 0xac57009c
    WRITE32(ADD32(GPR_U32(ctx, 2), 156), GPR_U32(ctx, 23));
    // 0x185e14: 0xf8410050
    WRITE128(ADD32(GPR_U32(ctx, 2), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_185e18:
    // 0x185e18: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185e1c: 0x131180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 6));
    // 0x185e20: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x185e24: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x185e28: 0x16000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_185e44;
    }
    // 0x185e30: 0x7a220010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x185e34: 0x7e220020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
    // 0x185e38: 0xae400000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 0));
    // 0x185e3c: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x185E60; return;
    }
label_185e44:
    // 0x185e44: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x185e48: 0x26260010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 16));
    // 0x185e4c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x185e54);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 32));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_185e54
// Address: 0x185e54 - 0x185e7c

void entry_185e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185e54) {
        switch (ctx->pc) {
            case 0x185e60: ctx->pc = 0; goto label_185e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185e54: 0x820202c8
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x185e58: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x185e5c: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
label_185e60:
    // 0x185e60: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x185e64: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x185e68: 0x1440ffeb
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x185E18; return;
    }
    // 0x185e70: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185e74: 0xc061706
    SET_GPR_U32(ctx, 31, 0x185e7c);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MuFromAmtlk__FP4MTLK(rdram, ctx, runtime); return;
}


// Function: entry_185e7c
// Address: 0x185e7c - 0x185e8c

void entry_185e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185e7c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185e80: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x185e84: 0xc061728
    SET_GPR_U32(ctx, 31, 0x185e8c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 148), *(uint32_t*)&val); }
    ElasFromAmtlk__FP4MTLK(rdram, ctx, runtime); return;
}


// Function: entry_185e8c
// Address: 0x185e8c - 0x185ebc

void entry_185e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185e8c) {
        switch (ctx->pc) {
            case 0x185ea8: ctx->pc = 0; goto label_185ea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185e8c: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185e90: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x185e94: 0xe4400098
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 152), *(uint32_t*)&val); }
    // 0x185e98: 0xac4300a4
    WRITE32(ADD32(GPR_U32(ctx, 2), 164), GPR_U32(ctx, 3));
    // 0x185e9c: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x185ea0: 0xac4400a0
    WRITE32(ADD32(GPR_U32(ctx, 2), 160), GPR_U32(ctx, 4));
    // 0x185ea4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_185ea8:
    // 0x185ea8: 0x131980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 6));
    // 0x185eac: 0x24050100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 256));
    // 0x185eb0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x185eb4: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x185ebc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_185ebc
// Address: 0x185ebc - 0x185ee0

void entry_185ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185ebc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x185ec0: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x185EE4; return;
    }
    // 0x185ec8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x185ecc: 0x8c420100
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x185ed0: 0x10400003
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_185ee0(rdram, ctx, runtime); return;
    }
    // 0x185ed8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x185ee0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_185ee0
// Address: 0x185ee0 - 0x185f00

void entry_185ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185ee0) {
        switch (ctx->pc) {
            case 0x185ee4: ctx->pc = 0; goto label_185ee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185ee0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_185ee4:
    // 0x185ee4: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x185ee8: 0x1440ffef
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x185EA8; return;
    }
    // 0x185ef0: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x185ef4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x185ef8: 0xc06182a
    SET_GPR_U32(ctx, 31, 0x185f00);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_185f00
// Address: 0x185f00 - 0x185f48

void entry_185f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x185f00: 0x8fc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x185f04: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185f08: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x185f0c: 0xac6200d0
    WRITE32(ADD32(GPR_U32(ctx, 3), 208), GPR_U32(ctx, 2));
    // 0x185f10: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x185f14: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x185f18: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x185f1c: 0xafc20000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 2));
    // 0x185f20: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x185f24: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x185f28: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x185f2c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x185f30: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x185f34: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x185f38: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x185f3c: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x185f40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RecalcSwXpPos__FP2SWiPP2XP
// Address: 0x185f48 - 0x185ff0

void entry_185ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x185ff0) {
        switch (ctx->pc) {
            case 0x185ff8: ctx->pc = 0; goto label_185ff8;
            case 0x18600c: ctx->pc = 0; goto label_18600c;
            case 0x186010: ctx->pc = 0; goto label_186010;
            case 0x186038: ctx->pc = 0; goto label_186038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x185ff0: 0x10000015
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x186048; return;
    }
label_185ff8:
    // 0x185ff8: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x185ffc: 0x10430003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_18600c;
    }
    // 0x186004: 0x1443000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_186038;
    }
label_18600c:
    // 0x18600c: 0xc48003cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[0] = *(float*)&val; }
label_186010:
    // 0x186010: 0xd8830140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x186014: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x186018: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18601c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x186020: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x186024: 0xda210080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x186028: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x18602c: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x186030: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_186044(rdram, ctx, runtime); return;
    }
label_186038:
    // 0x186038: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18603c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x186044);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_186044
// Address: 0x186044 - 0x1860a8

void entry_186044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186044) {
        switch (ctx->pc) {
            case 0x186048: ctx->pc = 0; goto label_186048;
            case 0x186074: ctx->pc = 0; goto label_186074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186044: 0x26d60001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
label_186048:
    // 0x186048: 0x26730040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 64));
    // 0x18604c: 0x26520040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 64));
    // 0x186050: 0x26b50040
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 64));
    // 0x186054: 0x26940040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 64));
    // 0x186058: 0x2ac20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 2));
    // 0x18605c: 0x1440ffd4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x185FB0; return;
    }
    // 0x186064: 0x2e0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x186068: 0x7e102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 30)));
    // 0x18606c: 0x1440ffc6
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x185F88; return;
    }
label_186074:
    // 0x186074: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x186078: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18607c: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x186080: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x186084: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x186088: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18608c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x186090: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x186094: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x186098: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18609c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1860a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1860a8; return;
}


// Function: RecalcSwXpMovement__FP2SWiPP2XP
// Address: 0x1860a8 - 0x186124

void entry_186124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x186124: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x186128: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18612c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x186130: 0x8c6200fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 252)));
    // 0x186134: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18613c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18613c
// Address: 0x18613c - 0x18616c

void entry_18613c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18613c) {
        switch (ctx->pc) {
            case 0x186160: ctx->pc = 0; goto label_186160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18613c: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x186140: 0x26730040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 64));
    // 0x186144: 0x26520040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 64));
    // 0x186148: 0x2a820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 2));
    // 0x18614c: 0x1440ffec
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186100; return;
    }
    // 0x186154: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x186158: 0x26300004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4));
    // 0x18615c: 0x0
    // NOP
label_186160:
    // 0x186160: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x186164: 0xc06ed50
    SET_GPR_U32(ctx, 31, 0x18616c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    PsoFindSoPhysHook__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_18616c
// Address: 0x18616c - 0x186190

void entry_18616c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18616c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x186170: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x186194; return;
    }
    // 0x186178: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18617c: 0x8c420104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 260)));
    // 0x186180: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_186190(rdram, ctx, runtime); return;
    }
    // 0x186188: 0x40f809
    SET_GPR_U32(ctx, 31, 0x186190);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_186190
// Address: 0x186190 - 0x1861e8

void entry_186190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186190) {
        switch (ctx->pc) {
            case 0x186194: ctx->pc = 0; goto label_186194;
            case 0x1861bc: ctx->pc = 0; goto label_1861bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186190: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
label_186194:
    // 0x186194: 0x2a820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 2));
    // 0x186198: 0x1440fff1
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186160; return;
    }
    // 0x1861a0: 0xda210030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1861a4: 0x2a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1861a8: 0xda220070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x1861ac: 0x76102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 22)));
    // 0x1861b0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1861b4: 0x1440ffca
    WRITE128(ADD32(GPR_U32(ctx, 17), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1860E0; return;
    }
label_1861bc:
    // 0x1861bc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1861c0: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1861c4: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1861c8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1861cc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1861d0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1861d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1861d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1861dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1861e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreeSwXpList__FP2SWP2XP
// Address: 0x1861e8 - 0x186214

void entry_186214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186214) {
        switch (ctx->pc) {
            case 0x18621c: ctx->pc = 0; goto label_18621c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186214: 0x1600fffc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186208; return;
    }
label_18621c:
    // 0x18621c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x186220: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x186224: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x186228: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindClosestPointOnLine__FP6VECTORN20PfT3
// Address: 0x186230 - 0x186320

void entry_1864e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1864e0) {
        switch (ctx->pc) {
            case 0x186508: ctx->pc = 0; goto label_186508;
            case 0x186528: ctx->pc = 0; goto label_186528;
            case 0x186534: ctx->pc = 0; goto label_186534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1864e0: 0x2629821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1864e4: 0x233102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    // 0x1864e8: 0x1040000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_186528;
    }
    // 0x1864f0: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1864f4: 0x2241018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1864f8: 0x2718823
    SET_GPR_U32(ctx, 17, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 17)));
    // 0x1864fc: 0x24420058
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 88));
    // 0x186500: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x186504: 0x0
    // NOP
label_186508:
    // 0x186508: 0xac520000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 18));
    // 0x18650c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x186510: 0x0
    // NOP
    // 0x186514: 0x0
    // NOP
    // 0x186518: 0x0
    // NOP
    // 0x18651c: 0x1620fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 112));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_186508;
    }
    // 0x186524: 0x260882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_186528:
    // 0x186528: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18652c: 0x601ffde
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1864A8; return;
    }
label_186534:
    // 0x186534: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x186538: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18653c: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x186540: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x186544: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x186548: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18654c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x186550: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x186554: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x186558: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18655c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x186560: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG
// Address: 0x186568 - 0x186700

void entry_186700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186700) {
        switch (ctx->pc) {
            case 0x186728: ctx->pc = 0; goto label_186728;
            case 0x186748: ctx->pc = 0; goto label_186748;
            case 0x18674c: ctx->pc = 0; goto label_18674c;
            case 0x186754: ctx->pc = 0; goto label_186754;
            case 0x186758: ctx->pc = 0; goto label_186758;
            case 0x186764: ctx->pc = 0; goto label_186764;
            case 0x186778: ctx->pc = 0; goto label_186778;
            case 0x186794: ctx->pc = 0; goto label_186794;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186700: 0x2429021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x186704: 0x7bab0010
    SET_GPR_VEC(ctx, 11, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x186708: 0x232102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 18)));
    // 0x18670c: 0x1040000e
    SET_GPR_VEC(ctx, 12, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_186748;
    }
    // 0x186714: 0x2371018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 23); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x186718: 0x2518823
    SET_GPR_U32(ctx, 17, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    // 0x18671c: 0x24420058
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 88));
    // 0x186720: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x186724: 0x0
    // NOP
label_186728:
    // 0x186728: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x18672c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x186730: 0x0
    // NOP
    // 0x186734: 0x0
    // NOP
    // 0x186738: 0x0
    // NOP
    // 0x18673c: 0x1620fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 112));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_186728;
    }
    // 0x186744: 0x240882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_186748:
    // 0x186748: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_18674c:
    // 0x18674c: 0x5600ffd6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 6)));
        ctx->pc = 0x1866A8; return;
    }
label_186754:
    // 0x186754: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_186758:
    // 0x186758: 0x4c1ffc1
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 6) >= 0) {
        ctx->pc = 0x186660; return;
    }
    // 0x186760: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_186764:
    // 0x186764: 0x2446ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x186768: 0x4c0000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 6) < 0) {
        goto label_186794;
    }
    // 0x186770: 0xc21818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x186774: 0x6c3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 12)));
label_186778:
    // 0x186778: 0x8ce80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x18677c: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x186780: 0x24e7fff4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967284));
    // 0x186784: 0x9502001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 8), 28)));
    // 0x186788: 0x3042fffc
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65532));
    // 0x18678c: 0x4c1fffa
    WRITE16(ADD32(GPR_U32(ctx, 8), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 6) >= 0) {
        goto label_186778;
    }
label_186794:
    // 0x186794: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x186798: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18679c: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1867a0: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1867a4: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1867a8: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1867ac: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1867b0: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1867b4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1867b8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1867bc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1867c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CategorizeAlsg__FiP3LSGPiT2PP3LSGT4
// Address: 0x1867c8 - 0x186a04

void entry_186a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x186a04: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x186a08: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x186a0c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x186a10: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x186a18);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967292));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_186a18
// Address: 0x186a18 - 0x186a70

void entry_186a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186a18) {
        switch (ctx->pc) {
            case 0x186a20: ctx->pc = 0; goto label_186a20;
            case 0x186a38: ctx->pc = 0; goto label_186a38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186a18: 0x26b5fffc
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967292));
    // 0x186a1c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_186a20:
    // 0x186a20: 0x26b50004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    // 0x186a24: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x186a28: 0x26940004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4));
    // 0x186a2c: 0x236102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 22)));
    // 0x186a30: 0x1440ffd1
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186978; return;
    }
label_186a38:
    // 0x186a38: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x186a3c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x186a40: 0xac560000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 22));
    // 0x186a44: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x186a48: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x186a4c: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x186a50: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x186a54: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x186a58: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x186a5c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x186a60: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x186a64: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x186a68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG
// Address: 0x186a70 - 0x186ba8

void entry_186c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x186c04: 0x8fa57524
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    // 0x186c08: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x186c0c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x186c10: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x186c14: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x186c18: 0x24080080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 128));
    // 0x186c1c: 0xc06195a
    SET_GPR_U32(ctx, 31, 0x186c24);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 14352));
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_186c24
// Address: 0x186c24 - 0x186c8c

void entry_186c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186c24) {
        switch (ctx->pc) {
            case 0x186c3c: ctx->pc = 0; goto label_186c3c;
            case 0x186c70: ctx->pc = 0; goto label_186c70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186c24: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x186c28: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x186c2c: 0x14400003
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_186c3c;
    }
    // 0x186c34: 0x1060017d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 30160)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18722C; return;
    }
label_186c3c:
    // 0x186c3c: 0x27a27010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 28688));
    // 0x186c40: 0x27a37020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 28704));
    // 0x186c44: 0x27a57220
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 29216));
    // 0x186c48: 0xafa27528
    WRITE32(ADD32(GPR_U32(ctx, 29), 29992), GPR_U32(ctx, 2));
    // 0x186c4c: 0xafa37530
    WRITE32(ADD32(GPR_U32(ctx, 29), 30000), GPR_U32(ctx, 3));
    // 0x186c50: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x186c54: 0xafa5752c
    WRITE32(ADD32(GPR_U32(ctx, 29), 29996), GPR_U32(ctx, 5));
    // 0x186c58: 0x27b07420
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 29728));
    // 0x186c5c: 0xa0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x186c60: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x186c64: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x186c68: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x186c6c: 0x24160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
label_186c70:
    // 0x186c70: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x186c74: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x186c78: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x186c7c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x186c80: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x186c84: 0xc0619f2
    SET_GPR_U32(ctx, 31, 0x186c8c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime); return;
}


// Function: entry_186c8c
// Address: 0x186c8c - 0x186e74

void entry_186c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186c8c) {
        switch (ctx->pc) {
            case 0x186cc0: ctx->pc = 0; goto label_186cc0;
            case 0x186ce8: ctx->pc = 0; goto label_186ce8;
            case 0x186d38: ctx->pc = 0; goto label_186d38;
            case 0x186d88: ctx->pc = 0; goto label_186d88;
            case 0x186de0: ctx->pc = 0; goto label_186de0;
            case 0x186de4: ctx->pc = 0; goto label_186de4;
            case 0x186dec: ctx->pc = 0; goto label_186dec;
            case 0x186e10: ctx->pc = 0; goto label_186e10;
            case 0x186e18: ctx->pc = 0; goto label_186e18;
            case 0x186e28: ctx->pc = 0; goto label_186e28;
            case 0x186e44: ctx->pc = 0; goto label_186e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186c8c: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x186c90: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x186c94: 0x26b50100
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 256));
    // 0x186c98: 0x26940100
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 256));
    // 0x186c9c: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x186ca0: 0x26d6ffff
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x186ca4: 0x6c1fff2
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 14336));
    if (GPR_S32(ctx, 22) >= 0) {
        ctx->pc = 0x186C70; return;
    }
    // 0x186cac: 0x8fa27524
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    // 0x186cb0: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x186cb4: 0xafb77430
    WRITE32(ADD32(GPR_U32(ctx, 29), 29744), GPR_U32(ctx, 23));
    // 0x186cb8: 0xafa27434
    WRITE32(ADD32(GPR_U32(ctx, 29), 29748), GPR_U32(ctx, 2));
    // 0x186cbc: 0x0
    // NOP
label_186cc0:
    // 0x186cc0: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x186cc4: 0x8fa37528
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 29992)));
    // 0x186cc8: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x186ccc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x186cd0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x186cd4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x186cd8: 0x1860008a
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x186F04; return;
    }
    // 0x186ce0: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x186ce4: 0x0
    // NOP
label_186ce8:
    // 0x186ce8: 0x161200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 8));
    // 0x186cec: 0x8fa57530
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 30000)));
    // 0x186cf0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x186cf4: 0x8fa47430
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 29744)));
    // 0x186cf8: 0x24d30001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 6), 1));
    // 0x186cfc: 0xa31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x186d00: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x186d04: 0x8fa5752c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29996)));
    // 0x186d08: 0x8c4a0000
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x186d0c: 0xa31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x186d10: 0x8c8903ac
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 940)));
    // 0x186d14: 0x8c710000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x186d18: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x186d1c: 0xa1100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 10), 4));
    // 0x186d20: 0xc4a3b258
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294947416)); ctx->f[3] = *(float*)&val; }
    // 0x186d24: 0x1223021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x186d28: 0x1220003b
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_186e18;
    }
    // 0x186d30: 0x8ce50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 84)));
    // 0x186d34: 0x0
    // NOP
label_186d38:
    // 0x186d38: 0x94a3001c
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 28)));
    // 0x186d3c: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x186d40: 0x54400033
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 96)));
        goto label_186e10;
    }
    // 0x186d48: 0x34620008
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 8));
    // 0x186d4c: 0xd8a30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x186d50: 0xa4a2001c
    WRITE16(ADD32(GPR_U32(ctx, 5), 28), (uint16_t)GPR_U32(ctx, 2));
    // 0x186d54: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x186d58: 0xd8c10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x186d5c: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186d60: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x186d64: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186d68: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x186d6c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x186d70: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x186d74: 0x1200001d
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_186dec;
    }
    // 0x186d7c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x186d80: 0x8e020054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x186d84: 0x0
    // NOP
label_186d88:
    // 0x186d88: 0x50450016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 96)));
        goto label_186de4;
    }
    // 0x186d90: 0x8e03005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 92)));
    // 0x186d94: 0x8e040058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x186d98: 0x1031823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 8), GPR_U32(ctx, 3)));
    // 0x186d9c: 0xd8a30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x186da0: 0x31840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    // 0x186da4: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x186da8: 0x84820000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x186dac: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x186db0: 0x491021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x186db4: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x186db8: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186dbc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x186dc0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186dc4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x186dc8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x186dcc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x186dd0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x186dd4: 0x0
    // NOP
    // 0x186dd8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_186de0;
    }
label_186de0:
    // 0x186de0: 0x8e100060
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 96)));
label_186de4:
    // 0x186de4: 0x5600ffe8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 84)));
        goto label_186d88;
    }
label_186dec:
    // 0x186dec: 0xc4a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[0] = *(float*)&val; }
    // 0x186df0: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x186df4: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x186df8: 0x0
    // NOP
    // 0x186dfc: 0x45000004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 96)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_186e10;
    }
    // 0x186e04: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x186e08: 0x460008c6
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    // 0x186e0c: 0x46001506
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
label_186e10:
    // 0x186e10: 0x54e0ffc9
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 84)));
        goto label_186d38;
    }
label_186e18:
    // 0x186e18: 0xa4100
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 10), 4));
    // 0x186e1c: 0x12200009
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_186e44;
    }
    // 0x186e24: 0x8ce30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 84)));
label_186e28:
    // 0x186e28: 0x9462001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x186e2c: 0x3042fff7
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65527));
    // 0x186e30: 0xa462001c
    WRITE16(ADD32(GPR_U32(ctx, 3), 28), (uint16_t)GPR_U32(ctx, 2));
    // 0x186e34: 0x8ce70060
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 96)));
    // 0x186e38: 0x0
    // NOP
    // 0x186e3c: 0x54e0fffa
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 84)));
        goto label_186e28;
    }
label_186e44:
    // 0x186e44: 0x8fa47430
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 29744)));
    // 0x186e48: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x186e4c: 0xc64c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[12] = *(float*)&val; }
    // 0x186e50: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x186e54: 0x8c8903ac
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 940)));
    // 0x186e58: 0x3c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x186e5c: 0x460ca301
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[12]);
    // 0x186e60: 0x8fa57434
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29748)));
    // 0x186e64: 0x1284821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 8)));
    // 0x186e68: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x186e6c: 0xc061748
    SET_GPR_U32(ctx, 31, 0x186e74);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_186e74
// Address: 0x186e74 - 0x186edc

void entry_186e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186e74) {
        switch (ctx->pc) {
            case 0x186e80: ctx->pc = 0; goto label_186e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186e74: 0x1200001d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29992)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x186EEC; return;
    }
    // 0x186e7c: 0x8e020054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 84)));
label_186e80:
    // 0x186e80: 0x10520016
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        entry_186edc(rdram, ctx, runtime); return;
    }
    // 0x186e88: 0xda010010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x186e8c: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x186e90: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186e94: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x186e98: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x186e9c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x186ea0: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x186ea4: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x186ea8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x186eac: 0x0
    // NOP
    // 0x186eb0: 0x4500000a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_186edc(rdram, ctx, runtime); return;
    }
    // 0x186eb8: 0xc64c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[12] = *(float*)&val; }
    // 0x186ebc: 0x8fa47430
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 29744)));
    // 0x186ec0: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x186ec4: 0x460c0301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x186ec8: 0x8fa57434
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29748)));
    // 0x186ecc: 0x8e090058
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x186ed0: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x186ed4: 0xc061748
    SET_GPR_U32(ctx, 31, 0x186edc);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_186edc
// Address: 0x186edc - 0x186f64

void entry_186edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186edc) {
        switch (ctx->pc) {
            case 0x186eec: ctx->pc = 0; goto label_186eec;
            case 0x186f04: ctx->pc = 0; goto label_186f04;
            case 0x186f30: ctx->pc = 0; goto label_186f30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186edc: 0x8e100060
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x186ee0: 0x5600ffe7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 84)));
        ctx->pc = 0x186E80; return;
    }
    // 0x186ee8: 0x8fa27528
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29992)));
label_186eec:
    // 0x186eec: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x186ef0: 0x541821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x186ef4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x186ef8: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x186efc: 0x1440ff7a
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186CE8; return;
    }
label_186f04:
    // 0x186f04: 0x8fa27430
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29744)));
    // 0x186f08: 0x2a0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x186f0c: 0x8fa37434
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 29748)));
    // 0x186f10: 0x2ac40002
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 22), 2));
    // 0x186f14: 0xafa27434
    WRITE32(ADD32(GPR_U32(ctx, 29), 29748), GPR_U32(ctx, 2));
    // 0x186f18: 0x1480ff69
    WRITE32(ADD32(GPR_U32(ctx, 29), 29744), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x186CC0; return;
    }
    // 0x186f20: 0x8fb17420
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 29728)));
    // 0x186f24: 0x122000c0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x187228; return;
    }
    // 0x186f2c: 0x8e250050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 80)));
label_186f30:
    // 0x186f30: 0x50a000bb
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
        ctx->pc = 0x187220; return;
    }
    // 0x186f38: 0x8e260054
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 84)));
    // 0x186f3c: 0x10c000b7
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_18721c(rdram, ctx, runtime); return;
    }
    // 0x186f44: 0x27a87440
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 29760));
    // 0x186f48: 0x8fa77424
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 29732)));
    // 0x186f4c: 0x8c6403b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 948)));
    // 0x186f50: 0xa42823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x186f54: 0xc43023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x186f58: 0x52943
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 5), 5));
    // 0x186f5c: 0xc061a9c
    SET_GPR_U32(ctx, 31, 0x186f64);
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 5));
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_186f64
// Address: 0x186f64 - 0x187000

void entry_186f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x186f64) {
        switch (ctx->pc) {
            case 0x186f88: ctx->pc = 0; goto label_186f88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x186f64: 0x18400053
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 29760));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1870B4; return;
    }
    // 0x186f6c: 0x184000ab
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_18721c(rdram, ctx, runtime); return;
    }
    // 0x186f74: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x186f78: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x186f7c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x186f80: 0x27b374d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 29904));
    // 0x186f84: 0x8e220058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 88)));
label_186f88:
    // 0x186f88: 0x27a97520
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 29984));
    // 0x186f8c: 0x8ee503ac
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 23), 940)));
    // 0x186f90: 0x27a874c0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 29888));
    // 0x186f94: 0x84440000
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x186f98: 0x260502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x186f9c: 0x8fa27524
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    // 0x186fa0: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x186fa4: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x186fa8: 0x8e900000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x186fac: 0x8c4b03ac
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 2), 940)));
    // 0x186fb0: 0xa42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x186fb4: 0xafa47500
    WRITE32(ADD32(GPR_U32(ctx, 29), 29952), GPR_U32(ctx, 4));
    // 0x186fb8: 0x26940004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4));
    // 0x186fbc: 0x8e230058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    // 0x186fc0: 0x84620002
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x186fc4: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x186fc8: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x186fcc: 0xafa57504
    WRITE32(ADD32(GPR_U32(ctx, 29), 29956), GPR_U32(ctx, 5));
    // 0x186fd0: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x186fd4: 0x84460000
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x186fd8: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x186fdc: 0x1663021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 6)));
    // 0x186fe0: 0xafa67508
    WRITE32(ADD32(GPR_U32(ctx, 29), 29960), GPR_U32(ctx, 6));
    // 0x186fe4: 0x8e030058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x186fe8: 0x84620002
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x186fec: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x186ff0: 0x1625821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 2)));
    // 0x186ff4: 0x160382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x186ff8: 0xc07b6a0
    SET_GPR_U32(ctx, 31, 0x187000);
    WRITE32(ADD32(GPR_U32(ctx, 29), 29964), GPR_U32(ctx, 11));
    FindClosestPointBetweenLines__FP6VECTORN30PfT4T0(rdram, ctx, runtime); return;
}


// Function: entry_187000
// Address: 0x187000 - 0x1870a4

void entry_187000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x187000: 0xc7a074c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 29888)); ctx->f[0] = *(float*)&val; }
    // 0x187004: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x187008: 0x8fa27500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29952)));
    // 0x18700c: 0x27a674e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 29920));
    // 0x187010: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x187014: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x187018: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x18701c: 0xc7a174c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 29892)); ctx->f[1] = *(float*)&val; }
    // 0x187020: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x187024: 0x8fa97508
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 29960)));
    // 0x187028: 0x8fa37504
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 29956)));
    // 0x18702c: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    // 0x187030: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x187034: 0x3c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x187038: 0x48a51000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x18703c: 0x4601a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x187040: 0xfba27510
    WRITE128(ADD32(GPR_U32(ctx, 29), 29968), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x187044: 0xc7ac7520
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 29984)); ctx->f[12] = *(float*)&val; }
    // 0x187048: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x18704c: 0xd8460000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x187050: 0x48a51800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x187054: 0xfba47510
    WRITE128(ADD32(GPR_U32(ctx, 29), 29968), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x187058: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x18705c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x187060: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x187064: 0x8fa57524
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    // 0x187068: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18706c: 0x4be231bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x187070: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187074: 0xfba37510
    WRITE128(ADD32(GPR_U32(ctx, 29), 29968), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x187078: 0xfba274e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 29920), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18707c: 0x8fa2750c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 29964)));
    // 0x187080: 0xd9220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x187084: 0xfba57510
    WRITE128(ADD32(GPR_U32(ctx, 29), 29968), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x187088: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18708c: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x187090: 0x4be508c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187094: 0xfba374f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 29936), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x187098: 0x8e0a0058
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x18709c: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1870a4);
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1870a4
// Address: 0x1870a4 - 0x18721c

void entry_1870a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1870a4) {
        switch (ctx->pc) {
            case 0x1870b4: ctx->pc = 0; goto label_1870b4;
            case 0x1870d8: ctx->pc = 0; goto label_1870d8;
            case 0x187118: ctx->pc = 0; goto label_187118;
            case 0x187180: ctx->pc = 0; goto label_187180;
            case 0x187184: ctx->pc = 0; goto label_187184;
            case 0x1871a0: ctx->pc = 0; goto label_1871a0;
            case 0x1871d8: ctx->pc = 0; goto label_1871d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1870a4: 0x5640ffb8
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 88)));
        ctx->pc = 0x186F88; return;
    }
    // 0x1870ac: 0x1000005c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x187220; return;
    }
label_1870b4:
    // 0x1870b4: 0x8faa0004
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1870b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1870bc: 0x19400016
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    if (GPR_S32(ctx, 10) <= 0) {
        goto label_187118;
    }
    // 0x1870c4: 0x85220004
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 9), 4)));
    // 0x1870c8: 0x27a53810
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 14352));
    // 0x1870cc: 0x8ee803b4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 23), 948)));
    // 0x1870d0: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1870d4: 0x1023021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
label_1870d8:
    // 0x1870d8: 0x8ca40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x1870dc: 0x50860050
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 6)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
        ctx->pc = 0x187220; return;
    }
    // 0x1870e4: 0x85220006
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 9), 6)));
    // 0x1870e8: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1870ec: 0x1021821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x1870f0: 0x5083004b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
        ctx->pc = 0x187220; return;
    }
    // 0x1870f8: 0x8ca20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 84)));
    // 0x1870fc: 0x50460048
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 6)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
        ctx->pc = 0x187220; return;
    }
    // 0x187104: 0x10430045
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_18721c(rdram, ctx, runtime); return;
    }
    // 0x18710c: 0xea102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 10)));
    // 0x187110: 0x1440fff1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1870d8;
    }
label_187118:
    // 0x187118: 0xdae10140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 23), 320)));
    // 0x18711c: 0xda240000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x187120: 0xda230010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x187124: 0x4be4092c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187128: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18712c: 0xda220020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x187130: 0xda230030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x187134: 0x4bc2212a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x187138: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18713c: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x187140: 0x4b04290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187144: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187148: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18714c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187150: 0x4b01304a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187154: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x187158: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18715c: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x187160: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x187164: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x187168: 0x0
    // NOP
    // 0x18716c: 0x45000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 92)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_187180;
    }
    // 0x187174: 0x8e280050
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x187178: 0x10000002
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187184;
    }
label_187180:
    // 0x187180: 0x8e280054
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 84)));
label_187184:
    // 0x187184: 0x21040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 1));
    // 0x187188: 0x8ee403ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 940)));
    // 0x18718c: 0x1221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x187190: 0x8fc50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x187194: 0x84430000
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x187198: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x18719c: 0x833021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
label_1871a0:
    // 0x1871a0: 0x50a0000d
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 8), 0)));
        goto label_1871d8;
    }
    // 0x1871a8: 0x8ca2009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 156)));
    // 0x1871ac: 0x5455fffc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 208)));
        goto label_1871a0;
    }
    // 0x1871b4: 0x8ca200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 160)));
    // 0x1871b8: 0x5446fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 6)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 208)));
        goto label_1871a0;
    }
    // 0x1871c0: 0x8ca200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 164)));
    // 0x1871c4: 0x5448fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 8)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 208)));
        goto label_1871a0;
    }
    // 0x1871cc: 0x54a00014
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
        ctx->pc = 0x187220; return;
    }
    // 0x1871d4: 0xd9010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 8), 0)));
label_1871d8:
    // 0x1871d8: 0x100382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1871dc: 0xd8c20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1871e0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1871e4: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1871e8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1871ec: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1871f0: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1871f4: 0xc5000010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1871f8: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1871fc: 0x8fa57524
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 29988)));
    // 0x187200: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x187204: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x187208: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x18720c: 0xc0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x187210: 0xe0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x187214: 0xc061748
    SET_GPR_U32(ctx, 31, 0x18721c);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_18721c
// Address: 0x18721c - 0x187260

void entry_18721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18721c) {
        switch (ctx->pc) {
            case 0x187220: ctx->pc = 0; goto label_187220;
            case 0x187228: ctx->pc = 0; goto label_187228;
            case 0x18722c: ctx->pc = 0; goto label_18722c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18721c: 0x8e310060
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 96)));
label_187220:
    // 0x187220: 0x5620ff43
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 80)));
        ctx->pc = 0x186F30; return;
    }
label_187228:
    // 0x187228: 0x7bbf75d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 30160)));
label_18722c:
    // 0x18722c: 0x7bbe75c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 30144)));
    // 0x187230: 0x7bb775b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 30128)));
    // 0x187234: 0x7bb675a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 30112)));
    // 0x187238: 0x7bb57590
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 30096)));
    // 0x18723c: 0x7bb47580
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 30080)));
    // 0x187240: 0x7bb37570
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 30064)));
    // 0x187244: 0x7bb27560
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 30048)));
    // 0x187248: 0x7bb17550
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 30032)));
    // 0x18724c: 0x7bb07540
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 30016)));
    // 0x187250: 0xc7b475e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 30176)); ctx->f[20] = *(float*)&val; }
    // 0x187254: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 30192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18725c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x187260; return;
}


// Function: CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI
// Address: 0x187260 - 0x1872c0

void entry_1872c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1872c0: 0x1a6001ae
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5952)));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x18797C; return;
    }
    // 0x1872c8: 0x14400019
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x187330; return;
    }
    // 0x1872d0: 0x8fa21744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
    // 0x1872d4: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1872d8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1872e0);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1872e0
// Address: 0x1872e0 - 0x1872fc

void entry_1872e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1872e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1872e4: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1872e8: 0xafb01740
    WRITE32(ADD32(GPR_U32(ctx, 29), 5952), GPR_U32(ctx, 16));
    // 0x1872ec: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1872f0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1872f4: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x1872fc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 5952));
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_1872fc
// Address: 0x1872fc - 0x1874f8

void entry_1872fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1872fc) {
        switch (ctx->pc) {
            case 0x187330: ctx->pc = 0; goto label_187330;
            case 0x187348: ctx->pc = 0; goto label_187348;
            case 0x187454: ctx->pc = 0; goto label_187454;
            case 0x18745c: ctx->pc = 0; goto label_18745c;
            case 0x187470: ctx->pc = 0; goto label_187470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1872fc: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x187300: 0x1443019e
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 5952)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x18797C; return;
    }
    // 0x187308: 0x200b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18730c: 0x3c02aaaa
    SET_GPR_U32(ctx, 2, ((uint32_t)43690 << 16));
    // 0x187310: 0x971823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 23)));
    // 0x187314: 0x3442aaab
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 43691));
    // 0x187318: 0x621818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18731c: 0x2484fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967284));
    // 0x187320: 0xafa41740
    WRITE32(ADD32(GPR_U32(ctx, 29), 5952), GPR_U32(ctx, 4));
    // 0x187324: 0x31883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 2));
    // 0x187328: 0xafa31744
    WRITE32(ADD32(GPR_U32(ctx, 29), 5956), GPR_U32(ctx, 3));
    // 0x18732c: 0x8fa31744
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
label_187330:
    // 0x187330: 0x2471ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x187334: 0x6200049
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 17) < 0) {
        goto label_18745c;
    }
    // 0x18733c: 0x44802000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 0);
    // 0x187340: 0x2221818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187344: 0x773021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
label_187348:
    // 0x187348: 0x8cd00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x18734c: 0x8ea20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x187350: 0x8ea50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x187354: 0x2021023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x187358: 0x8ea4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 28)));
    // 0x18735c: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x187360: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x187364: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x187368: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18736c: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x187370: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x187374: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x187378: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18737c: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x187380: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x187384: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187388: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18738c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187390: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187394: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x187398: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x18739c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1873a0: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1873a4: 0x0
    // NOP
    // 0x1873a8: 0x4503002a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        goto label_187454;
    }
    // 0x1873b0: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1873b4: 0x4615a8c2
    ctx->f[3] = FPU_MUL_S(ctx->f[21], ctx->f[21]);
    // 0x1873b8: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1873bc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1873c0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1873c4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1873c8: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1873cc: 0x48270800
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1873d0: 0x44871000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 7);
    // 0x1873d4: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1873d8: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x1873dc: 0x46021082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[2]);
    // 0x1873e0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1873e4: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1873e8: 0xfba11000
    WRITE128(ADD32(GPR_U32(ctx, 29), 4096), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1873ec: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1873f0: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1873f4: 0x4be11048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1873f8: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1873fc: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x187400: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187404: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187408: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18740c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187410: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187414: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187418: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18741c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x187420: 0x48270800
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x187424: 0x44870000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 7);
    // 0x187428: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x18742c: 0x46040028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[4]);
    // 0x187430: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x187434: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x187438: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18743c: 0x0
    // NOP
    // 0x187440: 0x45010004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_187454;
    }
    // 0x187448: 0x9602001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x18744c: 0x34420010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16));
    // 0x187450: 0xa602001c
    WRITE16(ADD32(GPR_U32(ctx, 16), 28), (uint16_t)GPR_U32(ctx, 2));
label_187454:
    // 0x187454: 0x621ffbc
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967284));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_187348;
    }
label_18745c:
    // 0x18745c: 0x8fa21744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
    // 0x187460: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x187464: 0x6200106
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x187880; return;
    }
    // 0x18746c: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
label_187470:
    // 0x187470: 0x2221818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187474: 0x771021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x187478: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18747c: 0x9603001c
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x187480: 0x30620010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    // 0x187484: 0x10400057
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1875E4; return;
    }
    // 0x18748c: 0x54400056
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x1875E8; return;
    }
    // 0x187494: 0x34620040
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 64));
    // 0x187498: 0x4404a800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[21]);
    // 0x18749c: 0xa602001c
    WRITE16(ADD32(GPR_U32(ctx, 16), 28), (uint16_t)GPR_U32(ctx, 2));
    // 0x1874a0: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1874a4: 0xfba21730
    WRITE128(ADD32(GPR_U32(ctx, 29), 5936), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1874a8: 0x4600ad07
    ctx->f[20] = FPU_NEG_S(ctx->f[21]);
    // 0x1874ac: 0x8fa41740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 5952)));
    // 0x1874b0: 0x27a51000
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 4096));
    // 0x1874b4: 0x27a61010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 4112));
    // 0x1874b8: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1874bc: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1874c0: 0x27a91020
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 4128));
    // 0x1874c4: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1874c8: 0x4407a000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[20]);
    // 0x1874cc: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1874d0: 0x4be20888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1874d4: 0x48a72000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 7));
    // 0x1874d8: 0xfba21000
    WRITE128(ADD32(GPR_U32(ctx, 29), 4096), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1874dc: 0xfba41730
    WRITE128(ADD32(GPR_U32(ctx, 29), 5936), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1874e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1874e4: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1874e8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1874ec: 0x4be408c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1874f0: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1874f8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 4112), _mm_castps_si128(ctx->vu0_vf[3]));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1874f8
// Address: 0x1874f8 - 0x187984

void entry_1874f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1874f8) {
        switch (ctx->pc) {
            case 0x187508: ctx->pc = 0; goto label_187508;
            case 0x187544: ctx->pc = 0; goto label_187544;
            case 0x1875d8: ctx->pc = 0; goto label_1875d8;
            case 0x1875e4: ctx->pc = 0; goto label_1875e4;
            case 0x1875e8: ctx->pc = 0; goto label_1875e8;
            case 0x187608: ctx->pc = 0; goto label_187608;
            case 0x187650: ctx->pc = 0; goto label_187650;
            case 0x1876fc: ctx->pc = 0; goto label_1876fc;
            case 0x18772c: ctx->pc = 0; goto label_18772c;
            case 0x187750: ctx->pc = 0; goto label_187750;
            case 0x187798: ctx->pc = 0; goto label_187798;
            case 0x1877ac: ctx->pc = 0; goto label_1877ac;
            case 0x18782c: ctx->pc = 0; goto label_18782c;
            case 0x187868: ctx->pc = 0; goto label_187868;
            case 0x18786c: ctx->pc = 0; goto label_18786c;
            case 0x187874: ctx->pc = 0; goto label_187874;
            case 0x187878: ctx->pc = 0; goto label_187878;
            case 0x187880: ctx->pc = 0; goto label_187880;
            case 0x1878b0: ctx->pc = 0; goto label_1878b0;
            case 0x1878c8: ctx->pc = 0; goto label_1878c8;
            case 0x1878f4: ctx->pc = 0; goto label_1878f4;
            case 0x18793c: ctx->pc = 0; goto label_18793c;
            case 0x187940: ctx->pc = 0; goto label_187940;
            case 0x187948: ctx->pc = 0; goto label_187948;
            case 0x187960: ctx->pc = 0; goto label_187960;
            case 0x18797c: ctx->pc = 0; goto label_18797c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1874f8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1874fc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x187500: 0x27a61020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 4128));
    // 0x187504: 0x0
    // NOP
label_187508:
    // 0x187508: 0x85182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x18750c: 0x10600035
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1875e4;
    }
    // 0x187514: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x187518: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18751c: 0x823818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187520: 0xe61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x187524: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x187528: 0xc4410044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[1] = *(float*)&val; }
    // 0x18752c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x187530: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x187534: 0x0
    // NOP
    // 0x187538: 0x45020002
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 84)));
        goto label_187544;
    }
    // 0x187540: 0x8c420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 80)));
label_187544:
    // 0x187544: 0x5450fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_187508;
    }
    // 0x18754c: 0x50600026
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        goto label_1875e8;
    }
    // 0x187554: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x187558: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18755c: 0xda830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x187560: 0xfba21730
    WRITE128(ADD32(GPR_U32(ctx, 29), 5936), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x187564: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x187568: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18756c: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x187570: 0x4be20848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187574: 0x10400018
    WRITE128(ADD32(GPR_U32(ctx, 29), 5920), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1875d8;
    }
    // 0x18757c: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x187580: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x187584: 0x2422018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187588: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x18758c: 0x9e2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 30)));
    // 0x187590: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x187594: 0x253202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x187598: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18759c: 0x7ca20010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    // 0x1875a0: 0xdba21720
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 5920)));
    // 0x1875a4: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1875a8: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1875ac: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1875b0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1875b4: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1875b8: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1875bc: 0x48271000
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1875c0: 0xaca30024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 3));
    // 0x1875c4: 0x44870000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 7);
    // 0x1875c8: 0xacb00028
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 16));
    // 0x1875cc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1875d0: 0x108000dd
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_187948;
    }
label_1875d8:
    // 0x1875d8: 0x9602001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1875dc: 0x34420080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 128));
    // 0x1875e0: 0xa602001c
    WRITE16(ADD32(GPR_U32(ctx, 16), 28), (uint16_t)GPR_U32(ctx, 2));
label_1875e4:
    // 0x1875e4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_1875e8:
    // 0x1875e8: 0x621ffa1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x187470; return;
    }
    // 0x1875f0: 0x8fa21744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
    // 0x1875f4: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1875f8: 0x62000a1
    SET_GPR_U64(ctx, 13, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) < 0) {
        goto label_187880;
    }
    // 0x187600: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x187604: 0x0
    // NOP
label_187608:
    // 0x187608: 0x8ea80008
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    // 0x18760c: 0x2221818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187610: 0x771021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x187614: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x187618: 0x9603001c
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x18761c: 0x30620010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    // 0x187620: 0x10400094
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 21), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_187874;
    }
    // 0x187628: 0x306200a0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 160));
    // 0x18762c: 0x54400092
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        goto label_187878;
    }
    // 0x187634: 0x34620020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 32));
    // 0x187638: 0x8e060014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x18763c: 0x10c0008d
    WRITE16(ADD32(GPR_U32(ctx, 16), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_187874;
    }
    // 0x187644: 0x161180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 6));
    // 0x187648: 0x5d3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x18764c: 0x84c20006
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 6)));
label_187650:
    // 0x187650: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x187654: 0x1221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x187658: 0x9442001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x18765c: 0x30430010
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 16));
    // 0x187660: 0x10600081
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_187868;
    }
    // 0x187668: 0x54400080
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
        goto label_18786c;
    }
    // 0x187670: 0x84c20000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x187674: 0x84c30002
    SET_GPR_S32(ctx, 3, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 2)));
    // 0x187678: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x18767c: 0xda850000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x187680: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x187684: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x187688: 0x1031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 3)));
    // 0x18768c: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x187690: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x187694: 0x4be2092c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187698: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18769c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1876a0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1876a4: 0xfba41000
    WRITE128(ADD32(GPR_U32(ctx, 29), 4096), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1876a8: 0x4bc420aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1876ac: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1876b0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1876b4: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1876b8: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1876bc: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1876c0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1876c4: 0x4be1286c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1876c8: 0x4bc408ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1876cc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1876d0: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1876d4: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1876d8: 0xfba11010
    WRITE128(ADD32(GPR_U32(ctx, 29), 4112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1876dc: 0x48241800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1876e0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1876e4: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x1876e8: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1876ec: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1876fc;
    }
    // 0x1876f4: 0x10000016
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187750;
    }
label_1876fc:
    // 0x1876fc: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x187700: 0x3421f972
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63858));
    // 0x187704: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x187708: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18770c: 0x0
    // NOP
    // 0x187710: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
        goto label_18772c;
    }
    // 0x187718: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18771c: 0x4be1286c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x187720: 0x84c50002
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 2)));
    // 0x187724: 0x1000000a
    WRITE128(ADD32(GPR_U32(ctx, 29), 4112), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187750;
    }
label_18772c:
    // 0x18772c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x187730: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x187734: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x187738: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18773c: 0x4be22048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187740: 0xfba21040
    WRITE128(ADD32(GPR_U32(ctx, 29), 4160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x187744: 0x4be128ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x187748: 0xfba11030
    WRITE128(ADD32(GPR_U32(ctx, 29), 4144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18774c: 0xfba31010
    WRITE128(ADD32(GPR_U32(ctx, 29), 4112), _mm_castps_si128(ctx->vu0_vf[3]));
label_187750:
    // 0x187750: 0xdba11010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 4112)));
    // 0x187754: 0x4615a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[21]);
    // 0x187758: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18775c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x187760: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x187764: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x187768: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18776c: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x187770: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x187774: 0x0
    // NOP
    // 0x187778: 0x4503003c
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
        goto label_18786c;
    }
    // 0x187780: 0x4a0000a
    if (GPR_S32(ctx, 5) < 0) {
        goto label_1877ac;
    }
    // 0x187788: 0x26c3ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x18778c: 0x4600007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 6));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1877ac;
    }
    // 0x187794: 0x5d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
label_187798:
    // 0x187798: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18779c: 0x10450032
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_187868;
    }
    // 0x1877a4: 0x461fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967232));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_187798;
    }
label_1877ac:
    // 0x1877ac: 0x46010084
    ctx->f[2] = FPU_SQRT_S(ctx->f[0]);
    // 0x1877b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1877b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1877b8: 0x4600a847
    ctx->f[1] = FPU_NEG_S(ctx->f[21]);
    // 0x1877bc: 0xda840000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1877c0: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1877c4: 0xdba21010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 4112)));
    // 0x1877c8: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1877cc: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1877d0: 0x46151081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[21]);
    // 0x1877d4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1877d8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1877dc: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1877e0: 0xfba11040
    WRITE128(ADD32(GPR_U32(ctx, 29), 4160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1877e4: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1877e8: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1877ec: 0xfba21020
    WRITE128(ADD32(GPR_U32(ctx, 29), 4128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1877f0: 0xfba31040
    WRITE128(ADD32(GPR_U32(ctx, 29), 4160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1877f4: 0x4a0000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 4144), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_S32(ctx, 5) < 0) {
        goto label_18782c;
    }
    // 0x1877fc: 0x2ec20040
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), 64));
    // 0x187800: 0x5040001a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
        goto label_18786c;
    }
    // 0x187808: 0x24e70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 64));
    // 0x18780c: 0x26d60001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    // 0x187810: 0xace5ffc0
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294967232), GPR_U32(ctx, 5));
    // 0x187814: 0x7ba21030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 4144)));
    // 0x187818: 0x7ce2ffd0
    WRITE128(ADD32(GPR_U32(ctx, 7), 4294967248), GPR_VEC(ctx, 2));
    // 0x18781c: 0x7ba31020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 4128)));
    // 0x187820: 0xe4e2fff0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 7), 4294967280), *(uint32_t*)&val); }
    // 0x187824: 0x10000010
    WRITE128(ADD32(GPR_U32(ctx, 7), 4294967264), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187868;
    }
label_18782c:
    // 0x18782c: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x187830: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_187868;
    }
    // 0x187838: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x18783c: 0x2421818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187840: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x187844: 0x7e2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 30)));
    // 0x187848: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18784c: 0x253182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x187850: 0x7ba21020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 4128)));
    // 0x187854: 0xe4a20020
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 5), 32), *(uint32_t*)&val); }
    // 0x187858: 0x7ca20010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    // 0x18785c: 0xaca40024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 4));
    // 0x187860: 0x10600039
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_187948;
    }
label_187868:
    // 0x187868: 0x8cc60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
label_18786c:
    // 0x18786c: 0x54c0ff78
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 6)));
        goto label_187650;
    }
label_187874:
    // 0x187874: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_187878:
    // 0x187878: 0x621ff63
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_187608;
    }
label_187880:
    // 0x187880: 0x26c9ffff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x187884: 0x5200030
    SET_GPR_U64(ctx, 12, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 9) < 0) {
        goto label_187948;
    }
    // 0x18788c: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x187890: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x187894: 0x1a21018
    { int64_t result = (int64_t)GPR_S32(ctx, 13) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187898: 0x2435818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18789c: 0x92180
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 9), 6));
    // 0x1878a0: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1878a4: 0x9d3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
    // 0x1878a8: 0x24480028
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 40));
    // 0x1878ac: 0x0
    // NOP
label_1878b0:
    // 0x1878b0: 0x1a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 13) + GPR_U64(ctx, 0));
    // 0x1878b4: 0xcc102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 12)));
    // 0x1878b8: 0x1040000e
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1878f4;
    }
    // 0x1878c0: 0x11e2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 30)));
    // 0x1878c4: 0x0
    // NOP
label_1878c8:
    // 0x1878c8: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1878cc: 0x84620000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1878d0: 0x5044001b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294967295));
        goto label_187940;
    }
    // 0x1878d8: 0x84620002
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x1878dc: 0x50440018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294967295));
        goto label_187940;
    }
    // 0x1878e4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1878e8: 0xcc102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 12)));
    // 0x1878ec: 0x1440fff6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 48));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1878c8;
    }
label_1878f4:
    // 0x1878f4: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x1878f8: 0x10400010
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18793c;
    }
    // 0x187900: 0x78e20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x187904: 0x3cb2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 11)));
    // 0x187908: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x18790c: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x187910: 0x256b0030
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 48));
    // 0x187914: 0x253182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x187918: 0x78e20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 32)));
    // 0x18791c: 0x7ca20010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    // 0x187920: 0xc4e00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 48)); ctx->f[0] = *(float*)&val; }
    // 0x187924: 0xacaa0024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 10));
    // 0x187928: 0xe4a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 32), *(uint32_t*)&val); }
    // 0x18792c: 0x8ea20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    // 0x187930: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x187934: 0x10600004
    WRITE32(ADD32(GPR_U32(ctx, 5), 40), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_187948;
    }
label_18793c:
    // 0x18793c: 0x2529ffff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294967295));
label_187940:
    // 0x187940: 0x521ffdb
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967232));
    if (GPR_S32(ctx, 9) >= 0) {
        goto label_1878b0;
    }
label_187948:
    // 0x187948: 0x8fa21744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 5956)));
    // 0x18794c: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x187950: 0x620000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 17) < 0) {
        goto label_18797c;
    }
    // 0x187958: 0x2221818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18795c: 0x772021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
label_187960:
    // 0x187960: 0x8c900000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x187964: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x187968: 0x2484fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967284));
    // 0x18796c: 0x9602001c
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x187970: 0x3042ff0f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 65295));
    // 0x187974: 0x621fffa
    WRITE16(ADD32(GPR_U32(ctx, 16), 28), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_187960;
    }
label_18797c:
    // 0x18797c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x187984);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_187984
// Address: 0x187984 - 0x1879c0

void entry_187984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x187984: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x187988: 0x7bbf17e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 6112)));
    // 0x18798c: 0x7bbe17d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 6096)));
    // 0x187990: 0x7bb717c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 6080)));
    // 0x187994: 0x7bb617b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 6064)));
    // 0x187998: 0x7bb517a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 6048)));
    // 0x18799c: 0x7bb41790
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 6032)));
    // 0x1879a0: 0x7bb31780
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 6016)));
    // 0x1879a4: 0x7bb21770
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 6000)));
    // 0x1879a8: 0x7bb11760
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 5984)));
    // 0x1879ac: 0x7bb01750
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 5968)));
    // 0x1879b0: 0xc7b517f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 6136)); ctx->f[21] = *(float*)&val; }
    // 0x1879b4: 0xc7b417f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 6128)); ctx->f[20] = *(float*)&val; }
    // 0x1879b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 6144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP
// Address: 0x1879c0 - 0x187a0c

void entry_187a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187a0c) {
        switch (ctx->pc) {
            case 0x187a28: ctx->pc = 0; goto label_187a28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187a0c: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x187a10: 0x6200013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x187A60; return;
    }
    // 0x187a18: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x187a1c: 0x2221018
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187a20: 0x629021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x187a24: 0x5d8021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
label_187a28:
    // 0x187a28: 0xc60c0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[12] = *(float*)&val; }
    // 0x187a2c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x187a30: 0x8e080024
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x187a34: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x187a38: 0x8e0a0028
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x187a3c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x187a40: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x187a44: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x187a48: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x187a4c: 0xc061748
    SET_GPR_U32(ctx, 31, 0x187a54);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967248));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_187a54
// Address: 0x187a54 - 0x187a88

void entry_187a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187a54) {
        switch (ctx->pc) {
            case 0x187a60: ctx->pc = 0; goto label_187a60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187a54: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x187a58: 0x621fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967248));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x187A28; return;
    }
label_187a60:
    // 0x187a60: 0x7bbf0c60
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 3168)));
    // 0x187a64: 0x7bb50c50
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 3152)));
    // 0x187a68: 0x7bb40c40
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 3136)));
    // 0x187a6c: 0x7bb30c30
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 3120)));
    // 0x187a70: 0x7bb20c20
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 3104)));
    // 0x187a74: 0x7bb10c10
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 3088)));
    // 0x187a78: 0x7bb00c00
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 3072)));
    // 0x187a7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 3184));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x187a84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x187a88; return;
}


// Function: MarkSoContactsSphereSphere__FP2SOT0PP2XP
// Address: 0x187a88 - 0x187b54

void entry_187b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187b54) {
        switch (ctx->pc) {
            case 0x187b58: ctx->pc = 0; goto label_187b58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187b54: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_187b58:
    // 0x187b58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateCenterContact__FP2SOP6VECTORfT1Pf
// Address: 0x187b60 - 0x187c28

void entry_187c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187c6c) {
        switch (ctx->pc) {
            case 0x187c80: ctx->pc = 0; goto label_187c80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187c6c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x187c70: 0x18600003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_187c80;
    }
    // 0x187c78: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x187c7c: 0x2c440001
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 2), 1));
label_187c80:
    // 0x187c80: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x187c84: 0x10400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x187CE4; return;
    }
    // 0x187c8c: 0x27b100e0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 224));
    // 0x187c90: 0x821818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x187c94: 0x27a700f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 240));
    // 0x187c98: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x187c9c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x187ca0: 0x7d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 29)));
    // 0x187ca4: 0x8c500050
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x187ca8: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x187cac: 0xc061ed8
    SET_GPR_U32(ctx, 31, 0x187cb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime); return;
}


// Function: entry_187cb4
// Address: 0x187cb4 - 0x187cdc

void entry_187cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x187cb4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x187cb8: 0xc7ac00f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[12] = *(float*)&val; }
    // 0x187cbc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x187cc0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x187cc4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x187cc8: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x187ccc: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x187cd0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x187cd4: 0xc061748
    SET_GPR_U32(ctx, 31, 0x187cdc);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_187cdc
// Address: 0x187cdc - 0x187d08

void entry_187cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187cdc) {
        switch (ctx->pc) {
            case 0x187ce4: ctx->pc = 0; goto label_187ce4;
            case 0x187ce8: ctx->pc = 0; goto label_187ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187cdc: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187ce8;
    }
label_187ce4:
    // 0x187ce4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_187ce8:
    // 0x187ce8: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x187cec: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x187cf0: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x187cf4: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x187cf8: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x187cfc: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x187d00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4
// Address: 0x187d08 - 0x187e88

void entry_187ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x187ed4: 0x10400012
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x187F20; return;
    }
    // 0x187edc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x187ee0: 0x27a70024
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 36));
    // 0x187ee4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x187ee8: 0xc061ed8
    SET_GPR_U32(ctx, 31, 0x187ef0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime); return;
}


// Function: entry_187ef0
// Address: 0x187ef0 - 0x187f18

void entry_187ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x187ef0: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x187ef4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x187ef8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x187efc: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x187f00: 0x260582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x187f04: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x187f08: 0x24080009
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 9));
    // 0x187f0c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x187f10: 0xc061748
    SET_GPR_U32(ctx, 31, 0x187f18);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_187f18
// Address: 0x187f18 - 0x187f40

void entry_187f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x187f18) {
        switch (ctx->pc) {
            case 0x187f20: ctx->pc = 0; goto label_187f20;
            case 0x187f24: ctx->pc = 0; goto label_187f24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x187f18: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_187f24;
    }
label_187f20:
    // 0x187f20: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_187f24:
    // 0x187f24: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x187f28: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x187f2c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x187f30: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x187f34: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x187f38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSoXps__FP2SOT0iiP3BSPT4PP2XP
// Address: 0x187f40 - 0x188088

void entry_188088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188088) {
        switch (ctx->pc) {
            case 0x188090: ctx->pc = 0; goto label_188090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188088: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1880a8(rdram, ctx, runtime); return;
    }
label_188090:
    // 0x188090: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188094: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x188098: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18809c: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1880a0: 0xc061f0a
    SET_GPR_U32(ctx, 31, 0x1880a8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FMarkSoContactsCenterBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1880a8
// Address: 0x1880a8 - 0x188128

void entry_1880a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1880a8) {
        switch (ctx->pc) {
            case 0x1880c0: ctx->pc = 0; goto label_1880c0;
            case 0x1880c4: ctx->pc = 0; goto label_1880c4;
            case 0x1880cc: ctx->pc = 0; goto label_1880cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1880a8: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        goto label_1880c4;
    }
    // 0x1880b0: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1880b4: 0x541025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1880b8: 0x1000005c
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18822c(rdram, ctx, runtime); return;
    }
label_1880c0:
    // 0x1880c0: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_1880c4:
    // 0x1880c4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1880c8: 0x31f78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 29);
label_1880cc:
    // 0x1880cc: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1880d0: 0x54400022
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x18815C; return;
    }
    // 0x1880d8: 0xda210370
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 880)));
    // 0x1880dc: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1880e0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1880e4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1880e8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1880ec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1880f0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1880f4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1880f8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1880fc: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x188100: 0x0
    // NOP
    // 0x188104: 0x45020015
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x18815C; return;
    }
    // 0x18810c: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x188110: 0x5e1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x188114: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188130; return;
    }
    // 0x18811c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x188120: 0xc061fa2
    SET_GPR_U32(ctx, 31, 0x188128);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FMarkSoContactsCenterSphere__FP2SOT0PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_188128
// Address: 0x188128 - 0x188148

void entry_188128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188128) {
        switch (ctx->pc) {
            case 0x188130: ctx->pc = 0; goto label_188130;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188128: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_188148(rdram, ctx, runtime); return;
    }
label_188130:
    // 0x188130: 0x8e0703f8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x188134: 0x8e0603f0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1008)));
    // 0x188138: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18813c: 0xe0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x188140: 0xc061f0a
    SET_GPR_U32(ctx, 31, 0x188148);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FMarkSoContactsCenterBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_188148
// Address: 0x188148 - 0x188188

void entry_188148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188148) {
        switch (ctx->pc) {
            case 0x18815c: ctx->pc = 0; goto label_18815c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188148: 0x10400004
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18815c;
    }
    // 0x188150: 0x541025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x188154: 0x10000035
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18822c(rdram, ctx, runtime); return;
    }
label_18815c:
    // 0x18815c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x188160: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x188164: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x188168: 0x10400011
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1881B0; return;
    }
    // 0x188170: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x188174: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188190; return;
    }
    // 0x18817c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188180: 0xc061ea2
    SET_GPR_U32(ctx, 31, 0x188188);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    MarkSoContactsSphereSphere__FP2SOT0PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_188188
// Address: 0x188188 - 0x18820c

void entry_188188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188188) {
        switch (ctx->pc) {
            case 0x188190: ctx->pc = 0; goto label_188190;
            case 0x1881b0: ctx->pc = 0; goto label_1881b0;
            case 0x1881dc: ctx->pc = 0; goto label_1881dc;
            case 0x1881e4: ctx->pc = 0; goto label_1881e4;
            case 0x188204: ctx->pc = 0; goto label_188204;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188188: 0x10000029
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188230; return;
    }
label_188190:
    // 0x188190: 0xc62c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[12] = *(float*)&val; }
    // 0x188194: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188198: 0x8e0703f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1012)));
    // 0x18819c: 0x26250140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1881a0: 0x8e0803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x1881a4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1881a8: 0x10000016
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_188204;
    }
label_1881b0:
    // 0x1881b0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1881b4: 0x10400017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188214; return;
    }
    // 0x1881bc: 0x16170007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 23)) {
        goto label_1881dc;
    }
    // 0x1881c4: 0xc60103cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 972)); ctx->f[1] = *(float*)&val; }
    // 0x1881c8: 0xc60003d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 980)); ctx->f[0] = *(float*)&val; }
    // 0x1881cc: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1881d0: 0x0
    // NOP
    // 0x1881d4: 0x45010003
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1881e4;
    }
label_1881dc:
    // 0x1881dc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1881e0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1881e4:
    // 0x1881e4: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1881e8: 0xc60c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1881ec: 0x262480a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 9, GPR_U32(ctx, 19));
    // 0x1881f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1881f4: 0x26050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1881f8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1881fc: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x188200: 0x2a2400a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 21));
label_188204:
    // 0x188204: 0xc061e70
    SET_GPR_U32(ctx, 31, 0x18820c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_18820c
// Address: 0x18820c - 0x18822c

void entry_18820c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18820c) {
        switch (ctx->pc) {
            case 0x188214: ctx->pc = 0; goto label_188214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18820c: 0x10000008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188230; return;
    }
label_188214:
    // 0x188214: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188218: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x18821c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x188220: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x188224: 0xc061aea
    SET_GPR_U32(ctx, 31, 0x18822c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    MarkSoContactsBspBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_18822c
// Address: 0x18822c - 0x188270

void entry_18822c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18822c) {
        switch (ctx->pc) {
            case 0x188230: ctx->pc = 0; goto label_188230;
            case 0x188238: ctx->pc = 0; goto label_188238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18822c: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_188230:
    // 0x188230: 0x5600ff5f
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x187FB0; return;
    }
label_188238:
    // 0x188238: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18823c: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x188240: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x188244: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x188248: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18824c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x188250: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x188254: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x188258: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18825c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x188260: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x188264: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18826c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x188270; return;
}


// Function: PxpMarkSwContactsRoot__FP2SWPP2SOi
// Address: 0x188270 - 0x18830c

void entry_18830c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18830c: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x188310: 0xc063596
    SET_GPR_U32(ctx, 31, 0x188318);
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_188318
// Address: 0x188318 - 0x18838c

void entry_188318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188318) {
        switch (ctx->pc) {
            case 0x188350: ctx->pc = 0; goto label_188350;
            case 0x188370: ctx->pc = 0; goto label_188370;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188318: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18831c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x188320: 0x8c5002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 728)));
    // 0x188324: 0x1200003a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188410; return;
    }
    // 0x18832c: 0x3c13aaaa
    SET_GPR_U32(ctx, 19, ((uint32_t)43690 << 16));
    // 0x188330: 0x341e8000
    SET_GPR_U32(ctx, 30, OR32(GPR_U32(ctx, 0), 32768));
    // 0x188334: 0x1ef738
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 30) << 28);
    // 0x188338: 0x34178000
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 32768));
    // 0x18833c: 0x17be78
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 23) << 25);
    // 0x188340: 0x24160002
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 2));
    // 0x188344: 0x3673aaab
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 19), 43691));
    // 0x188348: 0xde030538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x18834c: 0x0
    // NOP
label_188350:
    // 0x188350: 0x7e1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 30)));
    // 0x188354: 0x5440002b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x188404; return;
    }
    // 0x18835c: 0x771024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x188360: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
        goto label_188370;
    }
    // 0x188368: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1883AC; return;
    }
label_188370:
    // 0x188370: 0x10800023
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_188400(rdram, ctx, runtime); return;
    }
    // 0x188378: 0x27a60014
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 20));
    // 0x18837c: 0xafb20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 18));
    // 0x188380: 0xc4ac03d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 980)); ctx->f[12] = *(float*)&val; }
    // 0x188384: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x18838c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 992));
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_18838c
// Address: 0x18838c - 0x1883d8

void entry_18838c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18838c) {
        switch (ctx->pc) {
            case 0x1883ac: ctx->pc = 0; goto label_1883ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18838c: 0x5456001d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x188404; return;
    }
    // 0x188394: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x188398: 0x521823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x18839c: 0x731818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1883a0: 0x2442fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967284));
    // 0x1883a4: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x1883a8: 0x3a083
    SET_GPR_S32(ctx, 20, SRA32(GPR_S32(ctx, 3), 2));
label_1883ac:
    // 0x1883ac: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1883b0: 0x27b10018
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 24));
    // 0x1883b4: 0x8fa90014
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1883b8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1883bc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1883c0: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1883c4: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1883c8: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1883cc: 0x8c6200f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 244)));
    // 0x1883d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1883d8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1883d8
// Address: 0x1883d8 - 0x188400

void entry_1883d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1883d8: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1883dc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1883e0: 0x8c4200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 248)));
    // 0x1883e4: 0x10400006
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_188400(rdram, ctx, runtime); return;
    }
    // 0x1883ec: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1883f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1883f4: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1883f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x188400);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_188400
// Address: 0x188400 - 0x188478

void entry_188400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188400) {
        switch (ctx->pc) {
            case 0x188404: ctx->pc = 0; goto label_188404;
            case 0x188410: ctx->pc = 0; goto label_188410;
            case 0x188430: ctx->pc = 0; goto label_188430;
            case 0x188454: ctx->pc = 0; goto label_188454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188400: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_188404:
    // 0x188404: 0x5600ffd2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x188350; return;
    }
    // 0x18840c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_188410:
    // 0x188410: 0x8c5002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 728)));
    // 0x188414: 0x1200001b
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x188484; return;
    }
    // 0x18841c: 0x34128000
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 0), 32768));
    // 0x188420: 0x129738
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << 28);
    // 0x188424: 0x34118000
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 0), 32768));
    // 0x188428: 0x118e78
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << 25);
    // 0x18842c: 0xde030538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
label_188430:
    // 0x188430: 0x721024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x188434: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x18847C; return;
    }
    // 0x18843c: 0x711024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x188440: 0x14400004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_188454;
    }
    // 0x188448: 0x8e0203f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x18844c: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x18847C; return;
    }
label_188454:
    // 0x188454: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x188458: 0x8c4200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 248)));
    // 0x18845c: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_188478(rdram, ctx, runtime); return;
    }
    // 0x188464: 0x8e0703f8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1016)));
    // 0x188468: 0x8e0603f0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1008)));
    // 0x18846c: 0x27a90018
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 24));
    // 0x188470: 0x40f809
    SET_GPR_U32(ctx, 31, 0x188478);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_188478
// Address: 0x188478 - 0x18848c

void entry_188478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188478) {
        switch (ctx->pc) {
            case 0x18847c: ctx->pc = 0; goto label_18847c;
            case 0x188484: ctx->pc = 0; goto label_188484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188478: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_18847c:
    // 0x18847c: 0x5600ffec
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x188430; return;
    }
label_188484:
    // 0x188484: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x18848c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18848c
// Address: 0x18848c - 0x1884c0

void entry_18848c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18848c: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x188490: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x188494: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x188498: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18849c: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1884a0: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1884a4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1884a8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1884ac: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1884b0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1884b4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1884b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostCopyMatrix3__7MATRIX4
// Address: 0x1884c0 - 0x1884e0

void entry_18850c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18850c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x188510: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x188514: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x188518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MatMulMatTransMat__FRC7MATRIX3T0
// Address: 0x188520 - 0x1885e0

void entry_1885fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1885fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x188600: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x188604: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x188608: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x18860c: 0xe600003c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    // 0x188610: 0xe6000028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x188614: 0xe6000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x188618: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18861c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x188624: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x188628; return;
}


// Function: fn___ml__FRC7MATRIX4G8VU_FLOAT
// Address: 0x188628 - 0x188668

void entry_188874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188874) {
        switch (ctx->pc) {
            case 0x188890: ctx->pc = 0; goto label_188890;
            case 0x1888a0: ctx->pc = 0; goto label_1888a0;
            case 0x1888e8: ctx->pc = 0; goto label_1888e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188874: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x188878: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18887c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x188880: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x188884: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188888: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18888c: 0x460101c1
    ctx->f[7] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_188890:
    // 0x188890: 0xd01821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    // 0x188894: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x188898: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18889c: 0x0
    // NOP
label_1888a0:
    // 0x1888a0: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1888a4: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1888a8: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1888ac: 0x46003802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[0]);
    // 0x1888b0: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1888b4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1888b8: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1888bc: 0x481fff8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1888a0;
    }
    // 0x1888c4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1888c8: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1888cc: 0x28e20003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 3));
    // 0x1888d0: 0x1440ffef
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_188890;
    }
    // 0x1888d8: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1888dc: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1888e0: 0x2604003c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 60));
    // 0x1888e4: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
label_1888e8:
    // 0x1888e8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1888ec: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1888f0: 0x24630014
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 20));
    // 0x1888f4: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1888f8: 0x5440fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
        goto label_1888e8;
    }
    // 0x188900: 0xc6220008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[2] = *(float*)&val; }
    // 0x188904: 0xc7a60000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[6] = *(float*)&val; }
    // 0x188908: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x18890c: 0x460231c2
    ctx->f[7] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x188910: 0xc6000010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[0] = *(float*)&val; }
    // 0x188914: 0xc6030008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[3] = *(float*)&val; }
    // 0x188918: 0xc6020020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[2] = *(float*)&val; }
    // 0x18891c: 0x46070001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[7]);
    // 0x188920: 0xc6050018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[5] = *(float*)&val; }
    // 0x188924: 0x46070840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[7]);
    // 0x188928: 0xc6040024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 36)); ctx->f[4] = *(float*)&val; }
    // 0x18892c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x188930: 0xe6000010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x188934: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x188938: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18893c: 0x460031c2
    ctx->f[7] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x188940: 0x46071080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[7]);
    // 0x188944: 0x460718c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[7]);
    // 0x188948: 0xe6020020
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x18894c: 0xe6030008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x188950: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x188954: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x188958: 0x460031c2
    ctx->f[7] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x18895c: 0x46072101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[7]);
    // 0x188960: 0x46072940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[7]);
    // 0x188964: 0xe6040024
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x188968: 0xe6050018
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    // 0x18896c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x188970: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRotateMatrix__FP6VECTORP7MATRIX3
// Address: 0x188978 - 0x1889ec

void entry_1889ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1889ec) {
        switch (ctx->pc) {
            case 0x1889f4: ctx->pc = 0; goto label_1889f4;
            case 0x188a18: ctx->pc = 0; goto label_188a18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1889ec: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_188a18;
    }
label_1889f4:
    // 0x1889f4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1889f8: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x1889fc: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x188a00: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x188a04: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x188a08: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x188a0c: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x188a10: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x188a14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_188a18:
    // 0x188a18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRotateMatrixEuler__FP6VECTORP7MATRIX3
// Address: 0x188a20 - 0x188a48

void entry_188a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x188a48: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x188a4c: 0x37a40008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 29), 8));
    // 0x188a50: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x188a58);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 12));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_188a58
// Address: 0x188a58 - 0x188a68

void entry_188a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x188a58: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x188a5c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x188a60: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x188a68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 20));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_188a68
// Address: 0x188a68 - 0x188b08

void entry_188a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x188a68: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x188a6c: 0xc7a60004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[6] = *(float*)&val; }
    // 0x188a70: 0xc7ab0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[11] = *(float*)&val; }
    // 0x188a74: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x188a78: 0x460b6042
    ctx->f[1] = FPU_MUL_S(ctx->f[12], ctx->f[11]);
    // 0x188a7c: 0xc7a20014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[2] = *(float*)&val; }
    // 0x188a80: 0x460b30c2
    ctx->f[3] = FPU_MUL_S(ctx->f[6], ctx->f[11]);
    // 0x188a84: 0xc7aa000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[10] = *(float*)&val; }
    // 0x188a88: 0x46026342
    ctx->f[13] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x188a8c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x188a90: 0x46000942
    ctx->f[5] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x188a94: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x188a98: 0x460019c2
    ctx->f[7] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x188a9c: 0x46003202
    ctx->f[8] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x188aa0: 0x46023242
    ctx->f[9] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x188aa4: 0x46006102
    ctx->f[4] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x188aa8: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x188aac: 0x460218c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x188ab0: 0x46092940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[9]);
    // 0x188ab4: 0x46080841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[8]);
    // 0x188ab8: 0x460418c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x188abc: 0x460d39c1
    ctx->f[7] = FPU_SUB_S(ctx->f[7], ctx->f[13]);
    // 0x188ac0: 0xe6250014
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    // 0x188ac4: 0x460a3182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[10]);
    // 0x188ac8: 0xe6210010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x188acc: 0x46005ac7
    ctx->f[11] = FPU_NEG_S(ctx->f[11]);
    // 0x188ad0: 0xe6230020
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 17), 32), *(uint32_t*)&val); }
    // 0x188ad4: 0x46025082
    ctx->f[2] = FPU_MUL_S(ctx->f[10], ctx->f[2]);
    // 0x188ad8: 0xe6270024
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 17), 36), *(uint32_t*)&val); }
    // 0x188adc: 0x46005002
    ctx->f[0] = FPU_MUL_S(ctx->f[10], ctx->f[0]);
    // 0x188ae0: 0xe6260028
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 17), 40), *(uint32_t*)&val); }
    // 0x188ae4: 0x460a6302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[10]);
    // 0x188ae8: 0xe62b0008
    { float val = ctx->f[11]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x188aec: 0xe6220000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x188af0: 0xe6200004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    // 0x188af4: 0xe62c0018
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 17), 24), *(uint32_t*)&val); }
    // 0x188af8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x188afc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x188b04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x188b08; return;
}


// Function: LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4
// Address: 0x188b08 - 0x188b48

void entry_188d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x188d1c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x188d20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR
// Address: 0x188d28 - 0x188f44

void entry_188f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x188f44) {
        switch (ctx->pc) {
            case 0x188f70: ctx->pc = 0; goto label_188f70;
            case 0x188f94: ctx->pc = 0; goto label_188f94;
            case 0x188fb4: ctx->pc = 0; goto label_188fb4;
            case 0x188fb8: ctx->pc = 0; goto label_188fb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x188f44: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x188f48: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x188f4c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x188f50: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x188f54: 0x0
    // NOP
    // 0x188f58: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[1] = *(float*)&val; }
        goto label_188f70;
    }
    // 0x188f60: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x188f64: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x188f68: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x188f6c: 0xc6210020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[1] = *(float*)&val; }
label_188f70:
    // 0x188f70: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x188f74: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x188f78: 0x0
    // NOP
    // 0x188f7c: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[1] = *(float*)&val; }
        goto label_188f94;
    }
    // 0x188f84: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x188f88: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x188f8c: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x188f90: 0xc6210018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[1] = *(float*)&val; }
label_188f94:
    // 0x188f94: 0xc6200024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 36)); ctx->f[0] = *(float*)&val; }
    // 0x188f98: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x188f9c: 0x0
    // NOP
    // 0x188fa0: 0x45000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_188fb8;
    }
    // 0x188fa8: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x188fac: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x188fb0: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_188fb4:
    // 0x188fb4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_188fb8:
    // 0x188fb8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x188fbc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x188fc0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x188fc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x188fcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x188fd0; return;
}


// Function: junk_00188FD0
// Address: 0x188fd0 - 0x188fd8

void entry_18900c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18900c: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x189010: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x189014: 0x0
    // NOP
    // 0x189018: 0x45000013
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x189068; return;
    }
    // 0x189020: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
    // 0x189024: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x189028: 0x0
    // NOP
    // 0x18902c: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        ctx->pc = 0x189050; return;
    }
    // 0x189034: 0xc60c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[12] = *(float*)&val; }
    // 0x189038: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x189040);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 40)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_189040
// Address: 0x189040 - 0x189060

void entry_189040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x189040) {
        switch (ctx->pc) {
            case 0x189050: ctx->pc = 0; goto label_189050;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x189040: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x189044: 0xc60d0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[13] = *(float*)&val; }
    // 0x189048: 0x1000000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x189078; return;
    }
label_189050:
    // 0x189050: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x189054: 0xc60d0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[13] = *(float*)&val; }
    // 0x189058: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x189060);
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_189060
// Address: 0x189060 - 0x189080

void entry_189060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x189060) {
        switch (ctx->pc) {
            case 0x189068: ctx->pc = 0; goto label_189068;
            case 0x189078: ctx->pc = 0; goto label_189078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x189060: 0x10000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_189080(rdram, ctx, runtime); return;
    }
label_189068:
    // 0x189068: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x18906c: 0xc60c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[12] = *(float*)&val; }
    // 0x189070: 0xc60d0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[13] = *(float*)&val; }
    // 0x189074: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
label_189078:
    // 0x189078: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x189080);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_189080
// Address: 0x189080 - 0x1890a0

void entry_189080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189080: 0xe6200008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x189084: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x189088: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18908c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x189090: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x189094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18909c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1890a0; return;
}


// Function: NormalizeRotateMatrix3__FP7MATRIX3
// Address: 0x1890a0 - 0x189150

void entry_1891e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1891e8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1891ec: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1891f0: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1891f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1891f8
// Address: 0x1891f8 - 0x189230

void entry_1891f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1891f8: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1891fc: 0x7ba40050
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x189200: 0x7ba50060
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x189204: 0x7ba20070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x189208: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
    // 0x18920c: 0x7e020030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 2));
    // 0x189210: 0x7e040010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 4));
    // 0x189214: 0x7e050020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 5));
    // 0x189218: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18921c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x189220: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x189224: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18922c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x189230; return;
}


// Function: DecomposeRotateMatrixPanTilt__FP7MATRIX3PfT1
// Address: 0x189230 - 0x18925c

void entry_18925c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18925c: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x189260: 0xc6010000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[1] = *(float*)&val; }
    // 0x189264: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x189268: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x18926c: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x189270: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x189274: 0x46010344
    ctx->f[13] = FPU_SQRT_S(ctx->f[0]);
    // 0x189278: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x189280);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_189280
// Address: 0x189280 - 0x1892a0

void entry_189280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189280: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x189284: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x189288: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18928c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x189290: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x189294: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18929c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1892a0; return;
}


// Function: LoadRotateMatrixPanTilt__FffP7MATRIX3
// Address: 0x1892a0 - 0x1892c8

void entry_1892c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1892c8: 0x4600a307
    ctx->f[12] = FPU_NEG_S(ctx->f[20]);
    // 0x1892cc: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1892d0: 0x24848d10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937872));
    // 0x1892d4: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1892dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1892dc
// Address: 0x1892dc - 0x189350

void entry_1892dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1892dc: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1892e0: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1892e4: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1892e8: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1892ec: 0xdba50040
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1892f0: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1892f4: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1892f8: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1892fc: 0xdba60050
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x189300: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x189304: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x189308: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18930c: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x189310: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x189314: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x189318: 0xfa030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18931c: 0xfa010020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189320: 0xfa050010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x189324: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x189328: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18932c: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x189330: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x189334: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x189338: 0xfba500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x18933c: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x189340: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189344: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189348: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadLookAtMatrix__FP6VECTORP7MATRIX3
// Address: 0x189350 - 0x189368

void entry_189368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189368: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18936c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x189374: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x189378; return;
}


// Function: TiltMatUpright__FP7MATRIX3N20
// Address: 0x189378 - 0x1893b0

void entry_1893b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1893b0) {
        switch (ctx->pc) {
            case 0x18941c: ctx->pc = 0; goto label_18941c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1893b0: 0x1240001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_18941c;
    }
    // 0x1893b8: 0xda040020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1893bc: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1893c0: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1893c4: 0xda260020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1893c8: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1893cc: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1893d0: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1893d4: 0x4bc6218a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1893d8: 0xda250010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1893dc: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1893e0: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1893e4: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1893e8: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1893ec: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1893f0: 0x4bc5204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1893f4: 0xfa460020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1893f8: 0xfa430000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1893fc: 0xfa410010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189400: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x189404: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x189408: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18940c: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189410: 0xfba60080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x189414: 0xfba60050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x189418: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_18941c:
    // 0x18941c: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x189420: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x189424: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x189428: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00189430
// Address: 0x189430 - 0x189438

void entry_18946c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18946c: 0x2528018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x189470: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x189474: 0xc063596
    SET_GPR_U32(ctx, 31, 0x18947c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_18947c
// Address: 0x18947c - 0x189490

void entry_18947c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18947c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x189480: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x189484: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x189488: 0xc063600
    SET_GPR_U32(ctx, 31, 0x189490);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_189490
// Address: 0x189490 - 0x1897c4

void entry_189490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x189490) {
        switch (ctx->pc) {
            case 0x1894a0: ctx->pc = 0; goto label_1894a0;
            case 0x1894c0: ctx->pc = 0; goto label_1894c0;
            case 0x1894cc: ctx->pc = 0; goto label_1894cc;
            case 0x1894dc: ctx->pc = 0; goto label_1894dc;
            case 0x1894ec: ctx->pc = 0; goto label_1894ec;
            case 0x189500: ctx->pc = 0; goto label_189500;
            case 0x189538: ctx->pc = 0; goto label_189538;
            case 0x18955c: ctx->pc = 0; goto label_18955c;
            case 0x189568: ctx->pc = 0; goto label_189568;
            case 0x1895a0: ctx->pc = 0; goto label_1895a0;
            case 0x1895d8: ctx->pc = 0; goto label_1895d8;
            case 0x1895dc: ctx->pc = 0; goto label_1895dc;
            case 0x189600: ctx->pc = 0; goto label_189600;
            case 0x189638: ctx->pc = 0; goto label_189638;
            case 0x189678: ctx->pc = 0; goto label_189678;
            case 0x189688: ctx->pc = 0; goto label_189688;
            case 0x189698: ctx->pc = 0; goto label_189698;
            case 0x1896a8: ctx->pc = 0; goto label_1896a8;
            case 0x1896c8: ctx->pc = 0; goto label_1896c8;
            case 0x189700: ctx->pc = 0; goto label_189700;
            case 0x189740: ctx->pc = 0; goto label_189740;
            case 0x189750: ctx->pc = 0; goto label_189750;
            case 0x18975c: ctx->pc = 0; goto label_18975c;
            case 0x189768: ctx->pc = 0; goto label_189768;
            case 0x189790: ctx->pc = 0; goto label_189790;
            case 0x1897a8: ctx->pc = 0; goto label_1897a8;
            case 0x1897b8: ctx->pc = 0; goto label_1897b8;
            case 0x1897bc: ctx->pc = 0; goto label_1897bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x189490: 0x1a400016
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1894ec;
    }
    // 0x189498: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18949c: 0x0
    // NOP
label_1894a0:
    // 0x1894a0: 0x1a40000e
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 8), 1));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1894dc;
    }
    // 0x1894a8: 0x1121018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1894ac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1894b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1894b4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1894b8: 0x541821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1894bc: 0x0
    // NOP
label_1894c0:
    // 0x1894c0: 0x55040002
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 4)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
        goto label_1894cc;
    }
    // 0x1894c8: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
label_1894cc:
    // 0x1894cc: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1894d0: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x1894d4: 0x1440fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1894c0;
    }
label_1894dc:
    // 0x1894dc: 0x160402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x1894e0: 0x112102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 18)));
    // 0x1894e4: 0x5440ffee
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1894a0;
    }
label_1894ec:
    // 0x1894ec: 0x1a40006a
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_189698;
    }
    // 0x1894f4: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1894f8: 0x1123018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1894fc: 0x0
    // NOP
label_189500:
    // 0x189500: 0x25050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 8), 1));
    // 0x189504: 0x100202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x189508: 0xb2182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 18)));
    // 0x18950c: 0xa0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x189510: 0xc81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x189514: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x189518: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x18951c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x189520: 0x10600011
    ctx->f[1] = FPU_ABS_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_189568;
    }
    // 0x189528: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x18952c: 0xb1880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 11), 2));
    // 0x189530: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x189534: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_189538:
    // 0x189538: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x18953c: 0x46000085
    ctx->f[2] = FPU_ABS_S(ctx->f[0]);
    // 0x189540: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x189544: 0x0
    // NOP
    // 0x189548: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_18955c;
    }
    // 0x189550: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    // 0x189554: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x189558: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_18955c:
    // 0x18955c: 0xb2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 18)));
    // 0x189560: 0x1440fff5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_189538;
    }
label_189568:
    // 0x189568: 0x46030832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18956c: 0x45010093
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1897bc;
    }
    // 0x189574: 0x10880019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 11), GPR_S32(ctx, 18)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 8)) {
        goto label_1895dc;
    }
    // 0x18957c: 0x1a400016
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1895d8;
    }
    // 0x189584: 0x81880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 8), 2));
    // 0x189588: 0x533821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x18958c: 0x733021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x189590: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x189594: 0x741821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x189598: 0x122080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 2));
    // 0x18959c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1895a0:
    // 0x1895a0: 0xc4e10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1895a4: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1895a8: 0xc4c00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1895ac: 0xe4c10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
    // 0x1895b0: 0xe4e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x1895b4: 0xc43021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x1895b8: 0xe43821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x1895bc: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1895c0: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1895c4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1895c8: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1895cc: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1895d0: 0x14a0fff3
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1895a0;
    }
label_1895d8:
    // 0x1895d8: 0x172102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 11), GPR_S32(ctx, 18)));
label_1895dc:
    // 0x1895dc: 0x1040002a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_189688;
    }
    // 0x1895e4: 0x1126018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1895e8: 0x84880
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 8), 2));
    // 0x1895ec: 0x1881021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 12), GPR_U32(ctx, 8)));
    // 0x1895f0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1895f4: 0x531821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1895f8: 0x1841021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 12), GPR_U32(ctx, 4)));
    // 0x1895fc: 0x0
    // NOP
label_189600:
    // 0x189600: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x189604: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x189608: 0x248a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 4), 1));
    // 0x18960c: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x189610: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x189614: 0x1a400018
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[1];
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_189678;
    }
    // 0x18961c: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x189620: 0x1344021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 20)));
    // 0x189624: 0x533021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x189628: 0x1333821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 19)));
    // 0x18962c: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x189630: 0x122080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 2));
    // 0x189634: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_189638:
    // 0x189638: 0xc4e10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[1] = *(float*)&val; }
    // 0x18963c: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x189640: 0xc4c00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 0)); ctx->f[0] = *(float*)&val; }
    // 0x189644: 0xe43821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 4)));
    // 0x189648: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x18964c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x189650: 0xe4c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
    // 0x189654: 0xc43021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 4)));
    // 0x189658: 0xc5000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 0)); ctx->f[0] = *(float*)&val; }
    // 0x18965c: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x189660: 0x1044021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x189664: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x189668: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x18966c: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x189670: 0x14a0fff1
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_189638;
    }
label_189678:
    // 0x189678: 0x140202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x18967c: 0x92102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 18)));
    // 0x189680: 0x1440ffdf
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 12), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_189600;
    }
label_189688:
    // 0x189688: 0x160402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x18968c: 0x112102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 18)));
    // 0x189690: 0x5440ff9b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
        goto label_189500;
    }
label_189698:
    // 0x189698: 0x2648ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x18969c: 0x500002f
    if (GPR_S32(ctx, 8) < 0) {
        goto label_18975c;
    }
    // 0x1896a4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1896a8:
    // 0x1896a8: 0x19000029
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 8), 4294967295));
    if (GPR_S32(ctx, 8) <= 0) {
        goto label_189750;
    }
    // 0x1896b0: 0x1125818
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1896b4: 0x84880
    SET_GPR_U32(ctx, 9, SLL32(GPR_U32(ctx, 8), 2));
    // 0x1896b8: 0x1681021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 8)));
    // 0x1896bc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1896c0: 0x536021
    SET_GPR_U32(ctx, 12, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1896c4: 0x1641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 4)));
label_1896c8:
    // 0x1896c8: 0xc5810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 12), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1896cc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1896d0: 0x248a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1896d4: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1896d8: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1896dc: 0x1a400018
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[2] = ctx->f[0] / ctx->f[1];
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_189740;
    }
    // 0x1896e4: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1896e8: 0x1343821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 20)));
    // 0x1896ec: 0x532021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1896f0: 0x1333021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 19)));
    // 0x1896f4: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1896f8: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1896fc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_189700:
    // 0x189700: 0xc4c10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 0)); ctx->f[1] = *(float*)&val; }
    // 0x189704: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x189708: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x18970c: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x189710: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x189714: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x189718: 0xe4800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x18971c: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x189720: 0xc4e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[0] = *(float*)&val; }
    // 0x189724: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x189728: 0xe33821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x18972c: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x189730: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x189734: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x189738: 0x14a0fff1
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_189700;
    }
label_189740:
    // 0x189740: 0x140202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x189744: 0x88102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 8)));
    // 0x189748: 0x1440ffdf
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1896c8;
    }
label_189750:
    // 0x189750: 0x1a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 13) + GPR_U64(ctx, 0));
    // 0x189754: 0x503ffd4
    if (GPR_S32(ctx, 8) >= 0) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1896a8;
    }
label_18975c:
    // 0x18975c: 0x1a400016
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1897b8;
    }
    // 0x189764: 0x1121818
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_189768:
    // 0x189768: 0x250b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 8), 1));
    // 0x18976c: 0x681021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x189770: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x189774: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x189778: 0x1a40000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[2] = *(float*)&val; }
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_1897a8;
    }
    // 0x189780: 0x81080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 8), 2));
    // 0x189784: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x189788: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x18978c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_189790:
    // 0x189790: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x189794: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x189798: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x18979c: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1897a0: 0x1480fffb
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_189790;
    }
label_1897a8:
    // 0x1897a8: 0x160402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x1897ac: 0x112102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 18)));
    // 0x1897b0: 0x1440ffed
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_189768;
    }
label_1897b8:
    // 0x1897b8: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
label_1897bc:
    // 0x1897bc: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1897c4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1897c4
// Address: 0x1897c4 - 0x1897f0

void entry_1897c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1897c4: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1897c8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1897cc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1897d0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1897d4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1897d8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1897dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1897e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1897e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1897ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1897f0; return;
}


// Function: FInvertMatrix3__FP7MATRIX3T0
// Address: 0x1897f0 - 0x189af0

void entry_189b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189b08: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x189b0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x189b14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x189b18; return;
}


// Function: BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3
// Address: 0x189b18 - 0x189c00

void entry_189c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189c00: 0xda010020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x189c04: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x189c08: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x189c0c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x189c10: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x189c14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x189c18: 0xfa010010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189c1c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x189c20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3
// Address: 0x189c28 - 0x189d10

void entry_189d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189d10: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x189d14: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x189d18: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x189d1c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x189d20: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x189d24: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x189d28: 0xfa010020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x189d2c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x189d30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3
// Address: 0x189d38 - 0x189f38

void entry_189f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189f38: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x189f3c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x189f40: 0xc062214
    SET_GPR_U32(ctx, 31, 0x189f48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_189f48
// Address: 0x189f48 - 0x189f58

void entry_189f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189f48: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x189f4c: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x189f50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildSimpleProjectionMatrix__FffffffP7MATRIX4
// Address: 0x189f58 - 0x189fa4

void entry_189fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x189fa4: 0x4614a841
    ctx->f[1] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
    // 0x189fa8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x189fac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x189fb0: 0x4614ad00
    ctx->f[20] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
    // 0x189fb4: 0xe6160000
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x189fb8: 0xe600002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    // 0x189fbc: 0xe6170020
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x189fc0: 0x4601a503
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[1];
    // 0x189fc4: 0xe6190014
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x189fc8: 0xe6180024
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x189fcc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x189fd0: 0xc7b90048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[25] = *(float*)&val; }
    // 0x189fd4: 0xc7b80040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[24] = *(float*)&val; }
    // 0x189fd8: 0xc7b70038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[23] = *(float*)&val; }
    // 0x189fdc: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x189fe0: 0xe6140028
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x189fe4: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x189fe8: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x189fec: 0x4600ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x189ff0: 0xe6150038
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x189ff4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x189ff8: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x189ffc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a004: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a008; return;
}


// Function: LoadScaleMatrixScalar__FP6VECTORfP7MATRIX4
// Address: 0x18a008 - 0x18a030

void entry_18a030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a030: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a040; return;
}


// Function: LoadScaleMatrixVector__FP6VECTORP7MATRIX3T0P7MATRIX4
// Address: 0x18a040 - 0x18a094

void entry_18a094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a094: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x18a098: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a09c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18a0a0: 0xc0622d2
    SET_GPR_U32(ctx, 31, 0x18a0a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRotInverse__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_18a0a8
// Address: 0x18a0a8 - 0x18a0b8

void entry_18a0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a0a8: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x18a0ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a0b0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18a0b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18a0b8
// Address: 0x18a0b8 - 0x18a0f0

void entry_18a0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a0b8: 0xc6630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[3] = *(float*)&val; }
    // 0x18a0bc: 0x27b10100
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 256));
    // 0x18a0c0: 0xc6620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[2] = *(float*)&val; }
    // 0x18a0c4: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x18a0c8: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18a0cc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18a0d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18a0d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18a0d8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a0dc: 0xe7a20080
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x18a0e0: 0xe7a00094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 148), *(uint32_t*)&val); }
    // 0x18a0e4: 0xe7a300a8
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 168), *(uint32_t*)&val); }
    // 0x18a0e8: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x18a0f0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 188), *(uint32_t*)&val); }
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_18a0f0
// Address: 0x18a0f0 - 0x18a120

void entry_18a0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a0f0: 0x7ba30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x18a0f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a0f8: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x18a0fc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18a100: 0x7ba80100
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18a104: 0x27a600c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 192));
    // 0x18a108: 0x7ba70110
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x18a10c: 0x7fa300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 3));
    // 0x18a110: 0x7fa200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 2));
    // 0x18a114: 0x7fa800c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 8));
    // 0x18a118: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x18a120);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 7));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_18a120
// Address: 0x18a120 - 0x18a160

void entry_18a120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a120: 0x7ba30100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18a124: 0x7ba40110
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x18a128: 0x7ba50120
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x18a12c: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x18a130: 0x7e830000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), GPR_VEC(ctx, 3));
    // 0x18a134: 0x7e820030
    WRITE128(ADD32(GPR_U32(ctx, 20), 48), GPR_VEC(ctx, 2));
    // 0x18a138: 0x7e840010
    WRITE128(ADD32(GPR_U32(ctx, 20), 16), GPR_VEC(ctx, 4));
    // 0x18a13c: 0x7e850020
    WRITE128(ADD32(GPR_U32(ctx, 20), 32), GPR_VEC(ctx, 5));
    // 0x18a140: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x18a144: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x18a148: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x18a14c: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x18a150: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x18a154: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x18a158: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3
// Address: 0x18a160 - 0x18a388

void entry_18a39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a39c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18a3a0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a3a4: 0xae020e3c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3644), GPR_U32(ctx, 2));
    // 0x18a3a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18a3ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a3b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a3b8; return;
}


// Function: LoadMbgFromBrx__FP3MBGP18CBinaryInputStream
// Address: 0x18a3b8 - 0x18a3cc

void entry_18a3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a3cc: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x18a3d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18a3d4: 0x24c64910
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 18704));
    // 0x18a3d8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x18a3e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_18a3e0
// Address: 0x18a3e0 - 0x18a3f0

void entry_18a3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a3e0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a3e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18a3e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostMbgLoad__FP3MBG
// Address: 0x18a3f0 - 0x18a418

void entry_18a418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a418: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x18a41c: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x18a424);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_18a424
// Address: 0x18a424 - 0x18a438

void entry_18a424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a424: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x18a428: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a42c: 0x24c64928
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 18728));
    // 0x18a430: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x18a438);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_18a438
// Address: 0x18a438 - 0x18a448

void entry_18a438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a438: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a43c: 0x26250c20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 3104));
    // 0x18a440: 0xc074dbc
    SET_GPR_U32(ctx, 31, 0x18a448);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 3584));
    PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_18a448
// Address: 0x18a448 - 0x18a464

void entry_18a448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a448: 0x8e220e00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3584)));
    // 0x18a44c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a450: 0x8e240e0c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3596)));
    // 0x18a454: 0x24060438
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1080));
    // 0x18a458: 0xae2207bc
    WRITE32(ADD32(GPR_U32(ctx, 17), 1980), GPR_U32(ctx, 2));
    // 0x18a45c: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x18a464);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_18a464
// Address: 0x18a464 - 0x18a484

void entry_18a464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a464) {
        switch (ctx->pc) {
            case 0x18a470: ctx->pc = 0; goto label_18a470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a464: 0xae220e10
    WRITE32(ADD32(GPR_U32(ctx, 17), 3600), GPR_U32(ctx, 2));
    // 0x18a468: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18a46c: 0x24504950
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 18768));
label_18a470:
    // 0x18a470: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18a474: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a478: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x18a47c: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18a484);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18a484
// Address: 0x18a484 - 0x18a4ac

void entry_18a484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a484: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x18a488: 0x661fff9
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x18A470; return;
    }
    // 0x18a490: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x18a494: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x18a498: 0x24a54960
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 18784));
    // 0x18a49c: 0xae220e20
    WRITE32(ADD32(GPR_U32(ctx, 17), 3616), GPR_U32(ctx, 2));
    // 0x18a4a0: 0x24040048
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 72));
    // 0x18a4a4: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x18a4ac);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_18a4ac
// Address: 0x18a4ac - 0x18a4e0

void entry_18a4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a4ac) {
        switch (ctx->pc) {
            case 0x18a4c0: ctx->pc = 0; goto label_18a4c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a4ac: 0x8e230e20
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 3616)));
    // 0x18a4b0: 0x18600010
    WRITE32(ADD32(GPR_U32(ctx, 17), 3620), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x18A4F4; return;
    }
    // 0x18a4b8: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a4bc: 0x8e300e24
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 3620)));
label_18a4c0:
    // 0x18a4c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18a4c4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x18a4c8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a4cc: 0x2138021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x18a4d0: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x18a4d4: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18a4d8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x18a4e0);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 12));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_18a4e0
// Address: 0x18a4e0 - 0x18a510

void entry_18a4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a4e0) {
        switch (ctx->pc) {
            case 0x18a4f4: ctx->pc = 0; goto label_18a4f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a4e0: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x18a4e4: 0x8e220e20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3616)));
    // 0x18a4e8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x18a4ec: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 3620)));
        ctx->pc = 0x18A4C0; return;
    }
label_18a4f4:
    // 0x18a4f4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18a4f8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18a4fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18a500: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a504: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18a508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018a510
// Address: 0x18a510 - 0x18a558

void FUN_0018a510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a510: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x18a514: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x18a518: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x18a51c: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x18a520: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18a524: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18a528: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x18a52c: 0x3c12002c
    SET_GPR_U32(ctx, 18, ((uint32_t)44 << 16));
    // 0x18a530: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18a534: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18a538: 0x8e8249a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 18856)));
    // 0x18a53c: 0x14400025
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A5D4; return;
    }
    // 0x18a544: 0x2650e490
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294960272));
    // 0x18a548: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a54c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18a550: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18a558);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18a558
// Address: 0x18a558 - 0x18a5dc

void entry_18a558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a558) {
        switch (ctx->pc) {
            case 0x18a5d4: ctx->pc = 0; goto label_18a5d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a558: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x18a55c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x18a560: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18a564: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x18a568: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18a56c: 0x3c0280ff
    SET_GPR_U32(ctx, 2, ((uint32_t)33023 << 16));
    // 0x18a570: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x18a574: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18a578: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x18a57c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x18a580: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18a584: 0xe6020004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x18a588: 0xe6000024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x18a58c: 0xe6010044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x18a590: 0xe6030034
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x18a594: 0xae43e490
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294960272), GPR_U32(ctx, 3));
    // 0x18a598: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18a59c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18a5a0: 0xe6030008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x18a5a4: 0xae020028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 2));
    // 0x18a5a8: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18a5ac: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x18a5b0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18a5b4: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x18a5b8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18a5bc: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
    // 0x18a5c0: 0xae8349a8
    WRITE32(ADD32(GPR_U32(ctx, 20), 18856), GPR_U32(ctx, 3));
    // 0x18a5c4: 0xe6000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    // 0x18a5c8: 0xe6020060
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x18a5cc: 0xe6010064
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 100), *(uint32_t*)&val); }
    // 0x18a5d0: 0xe6020054
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
label_18a5d4:
    // 0x18a5d4: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x18a5dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 349));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_18a5dc
// Address: 0x18a5dc - 0x18a608

void entry_18a5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a5dc: 0x2649e490
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 4294960272));
    // 0x18a5e0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x18a5e4: 0xad220070
    WRITE32(ADD32(GPR_U32(ctx, 9), 112), GPR_U32(ctx, 2));
    // 0x18a5e8: 0x260502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18a5ec: 0xad220074
    WRITE32(ADD32(GPR_U32(ctx, 9), 116), GPR_U32(ctx, 2));
    // 0x18a5f0: 0x26240140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    // 0x18a5f4: 0x24c65070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20592));
    // 0x18a5f8: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x18a5fc: 0x8e280e24
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 3620)));
    // 0x18a600: 0xc07559e
    SET_GPR_U32(ctx, 31, 0x18a608);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 3616)));
    DrawHaloSpks__FP6VECTORiP4SPKSP4SPKDP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_18a608
// Address: 0x18a608 - 0x18a628

void entry_18a608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a608: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18a60c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18a610: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18a614: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18a618: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a61c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18a620: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018a628
// Address: 0x18a628 - 0x18a644

void FUN_0018a628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a628: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x18a62c: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x18a630: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x18a634: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18a638: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x18a63c: 0xc072978
    SET_GPR_U32(ctx, 31, 0x18a644);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    RenderStepguardSelf__FP9STEPGUARDP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_18a644
// Address: 0x18a644 - 0x18a65c

void entry_18a644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a644: 0x8e220e2c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3628)));
    // 0x18a648: 0x10400017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18a6a8(rdram, ctx, runtime); return;
    }
    // 0x18a650: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a654: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18a65c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18a65c
// Address: 0x18a65c - 0x18a6a8

void entry_18a65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a65c: 0xda030040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x18a660: 0x3c030019
    SET_GPR_U32(ctx, 3, ((uint32_t)25 << 16));
    // 0x18a664: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x18a668: 0x2463a510
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944016));
    // 0x18a66c: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x18a670: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18a674: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18a678: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18a67c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18a680: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18a684: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x18a688: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18a68c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x18a690: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18a694: 0xafb10060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 17));
    // 0x18a698: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x18a69c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18a6a0: 0xc067504
    SET_GPR_U32(ctx, 31, 0x18a6a8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_18a6a8
// Address: 0x18a6a8 - 0x18a6c0

void entry_18a6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a6a8: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18a6ac: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18a6b0: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18a6b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a6bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a6c0; return;
}


// Function: PsoHitTestCylinderObjects__FiP6VECTORT1fiPP2SOP3LSG
// Address: 0x18a6c0 - 0x18a754

void entry_18a754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a754) {
        switch (ctx->pc) {
            case 0x18a778: ctx->pc = 0; goto label_18a778;
            case 0x18a77c: ctx->pc = 0; goto label_18a77c;
            case 0x18a7b8: ctx->pc = 0; goto label_18a7b8;
            case 0x18a7dc: ctx->pc = 0; goto label_18a7dc;
            case 0x18a7e0: ctx->pc = 0; goto label_18a7e0;
            case 0x18a7ec: ctx->pc = 0; goto label_18a7ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a754: 0x18400008
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_18a778;
    }
    // 0x18a75c: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x18a760: 0x46160032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18a764: 0x0
    // NOP
    // 0x18a768: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
        goto label_18a77c;
    }
    // 0x18a770: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18a774: 0x15180a
    if (GPR_U32(ctx, 21) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
label_18a778:
    // 0x18a778: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
label_18a77c:
    // 0x18a77c: 0x10400017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18a7dc;
    }
    // 0x18a784: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x18a788: 0x642018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18a78c: 0x9d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
    // 0x18a790: 0xc4400040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[0] = *(float*)&val; }
    // 0x18a794: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18a798: 0x0
    // NOP
    // 0x18a79c: 0x45020010
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
        goto label_18a7e0;
    }
    // 0x18a7a4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x18a7a8: 0x1240000c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_18a7dc;
    }
    // 0x18a7b0: 0x240182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18a7b4: 0x24440060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 96));
label_18a7b8:
    // 0x18a7b8: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18a7bc: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18a7c0: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x18a7c4: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x18a7c8: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x18a7cc: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_18a7b8;
    }
    // 0x18a7d4: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18a7d8: 0x7c640000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 4));
label_18a7dc:
    // 0x18a7dc: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
label_18a7e0:
    // 0x18a7e0: 0x234102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 20)));
    // 0x18a7e4: 0x1440ffd2
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A730; return;
    }
label_18a7ec:
    // 0x18a7ec: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18a7f0: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x18a7f4: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x18a7f8: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x18a7fc: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x18a800: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x18a804: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x18a808: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x18a80c: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18a810: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x18a814: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x18a818: 0xc7b60190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[22] = *(float*)&val; }
    // 0x18a81c: 0xc7b50188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[21] = *(float*)&val; }
    // 0x18a820: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x18a824: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a82c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a830; return;
}


// Function: FFilterMbgAttackObjects__FP3MBGP2SO
// Address: 0x18a830 - 0x18a87c

void entry_18a87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a87c) {
        switch (ctx->pc) {
            case 0x18a884: ctx->pc = 0; goto label_18a884;
            case 0x18a88c: ctx->pc = 0; goto label_18a88c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a87c: 0x1040fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A860; return;
    }
label_18a884:
    // 0x18a884: 0x1000001b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A8F4; return;
    }
label_18a88c:
    // 0x18a88c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18a890: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x18a894: 0x8c640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x18a898: 0x1082fffa
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18a884;
    }
    // 0x18a8a0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x18a8a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_18a8a8
// Address: 0x18a8a8 - 0x18a8c0

void entry_18a8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a8a8: 0x10400008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A8CC; return;
    }
    // 0x18a8b0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18a8b4: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x18a8b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18a8c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18a8c0
// Address: 0x18a8c0 - 0x18a8d4

void entry_18a8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a8c0) {
        switch (ctx->pc) {
            case 0x18a8cc: ctx->pc = 0; goto label_18a8cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a8c0: 0x1040000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A8F4; return;
    }
    // 0x18a8c8: 0x8e440050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 80)));
label_18a8cc:
    // 0x18a8cc: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x18a8d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1097));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_18a8d4
// Address: 0x18a8d4 - 0x18a8e8

void entry_18a8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a8d4: 0x14400007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18A8F4; return;
    }
    // 0x18a8dc: 0x8e440050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x18a8e0: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x18a8e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1098));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_18a8e8
// Address: 0x18a8e8 - 0x18a910

void entry_18a8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18a8e8) {
        switch (ctx->pc) {
            case 0x18a8f4: ctx->pc = 0; goto label_18a8f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18a8e8: 0x14400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18a8f4;
    }
    // 0x18a8f0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_18a8f4:
    // 0x18a8f4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18a8f8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18a8fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18a900: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18a904: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18a908: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FObstructedMbg__FP3MBGP6VECTORT1
// Address: 0x18a910 - 0x18a934

void entry_18a934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a934: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x18a938: 0x3c080019
    SET_GPR_U32(ctx, 8, ((uint32_t)25 << 16));
    // 0x18a93c: 0x27aa0070
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 112));
    // 0x18a940: 0x27ab0074
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 116));
    // 0x18a944: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18a948: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a94c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18a950: 0x2508a830
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294944816));
    // 0x18a954: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x18a95c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_18a95c
// Address: 0x18a95c - 0x18a980

void entry_18a95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a95c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18a960: 0x8fa70070
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18a964: 0xc44c49c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18884)); ctx->f[12] = *(float*)&val; }
    // 0x18a968: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18a96c: 0x8fa80074
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x18a970: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18a974: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18a978: 0xc0629b0
    SET_GPR_U32(ctx, 31, 0x18a980);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PsoHitTestCylinderObjects__FiP6VECTORT1fiPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_18a980
// Address: 0x18a980 - 0x18a988

void entry_18a980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a980: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x18a988);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18a988
// Address: 0x18a988 - 0x18a9a8

void entry_18a988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a988: 0x10102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 16)));
    // 0x18a98c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x18a990: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18a994: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18a998: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18a99c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18a9a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18a9a8; return;
}


// Function: FCanMbgAttack__FP3MBG
// Address: 0x18a9a8 - 0x18a9ec

void entry_18a9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18a9ec: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18a9f0: 0x12200034
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AAC4; return;
    }
    // 0x18a9f8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x18a9fc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x18aa00: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x18aa04: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3600)));
        ctx->pc = 0x18AA24; return;
    }
    // 0x18aa0c: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x18aa10: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18aa18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18aa18
// Address: 0x18aa18 - 0x18aa2c

void entry_18aa18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18aa18) {
        switch (ctx->pc) {
            case 0x18aa24: ctx->pc = 0; goto label_18aa24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18aa18: 0x1440002a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AAC4; return;
    }
    // 0x18aa20: 0x8e040e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3600)));
label_18aa24:
    // 0x18aa24: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18aa2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18aa2c
// Address: 0x18aa2c - 0x18aa7c

void entry_18aa2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18aa2c) {
        switch (ctx->pc) {
            case 0x18aa54: ctx->pc = 0; goto label_18aa54;
            case 0x18aa68: ctx->pc = 0; goto label_18aa68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18aa2c: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18aa30: 0x2402043c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1084));
    // 0x18aa34: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1085));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18aa68;
    }
    // 0x18aa3c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1082));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18aa54;
    }
    // 0x18aa44: 0x10620008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18aa68;
    }
    // 0x18aa4c: 0x1000001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AAC8; return;
    }
label_18aa54:
    // 0x18aa54: 0x2402043e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1086));
    // 0x18aa58: 0x1062000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18AA84; return;
    }
    // 0x18aa60: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AAC8; return;
    }
label_18aa68:
    // 0x18aa68: 0x26120140
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 320));
    // 0x18aa6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18aa70: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18aa74: 0xc062a44
    SET_GPR_U32(ctx, 31, 0x18aa7c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 320));
    FObstructedMbg__FP3MBGP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_18aa7c
// Address: 0x18aa7c - 0x18aaac

void entry_18aa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18aa7c) {
        switch (ctx->pc) {
            case 0x18aa84: ctx->pc = 0; goto label_18aa84;
            case 0x18aa8c: ctx->pc = 0; goto label_18aa8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18aa7c: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18aa8c;
    }
label_18aa84:
    // 0x18aa84: 0x1000000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AAC4; return;
    }
label_18aa8c:
    // 0x18aa8c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18aa90: 0xc44c49c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18888)); ctx->f[12] = *(float*)&val; }
    // 0x18aa94: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18aa98: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18aa9c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18aaa0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18aaa4: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x18aaac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_18aaac
// Address: 0x18aaac - 0x18aabc

void entry_18aaac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18aaac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18aab0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18aab4: 0xc062a44
    SET_GPR_U32(ctx, 31, 0x18aabc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FObstructedMbg__FP3MBGP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_18aabc
// Address: 0x18aabc - 0x18aae0

void entry_18aabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18aabc) {
        switch (ctx->pc) {
            case 0x18aac4: ctx->pc = 0; goto label_18aac4;
            case 0x18aac8: ctx->pc = 0; goto label_18aac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18aabc: 0x1040fff1
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AA84; return;
    }
label_18aac4:
    // 0x18aac4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_18aac8:
    // 0x18aac8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18aacc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18aad0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18aad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18aadc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18aae0; return;
}


// Function: FDetectMbg__FP3MBG
// Address: 0x18aae0 - 0x18aaf8

void entry_18aaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18aaf8: 0x1440001f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AB78; return;
    }
    // 0x18ab00: 0x8e020c10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3088)));
    // 0x18ab04: 0x1440001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AB78; return;
    }
    // 0x18ab0c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18ab10: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x18ab14: 0x10620015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18AB6C; return;
    }
    // 0x18ab1c: 0x10620016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18AB78; return;
    }
    // 0x18ab24: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18ab28: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x18ab2c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18ab34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18ab34
// Address: 0x18ab34 - 0x18ab48

void entry_18ab34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ab34: 0x10400010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AB78; return;
    }
    // 0x18ab3c: 0x8e040e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3600)));
    // 0x18ab40: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18ab48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ab48
// Address: 0x18ab48 - 0x18ab88

void entry_18ab48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ab48) {
        switch (ctx->pc) {
            case 0x18ab64: ctx->pc = 0; goto label_18ab64;
            case 0x18ab6c: ctx->pc = 0; goto label_18ab6c;
            case 0x18ab74: ctx->pc = 0; goto label_18ab74;
            case 0x18ab78: ctx->pc = 0; goto label_18ab78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ab48: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ab4c: 0x2402043c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1084));
    // 0x18ab50: 0x10620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1085));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18ab74;
    }
    // 0x18ab58: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1082));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18ab64;
    }
    // 0x18ab60: 0x2402043e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1086));
label_18ab64:
    // 0x18ab64: 0x10620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18ab78;
    }
label_18ab6c:
    // 0x18ab6c: 0x10000002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ab78;
    }
label_18ab74:
    // 0x18ab74: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_18ab78:
    // 0x18ab78: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18ab7c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ab80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018ab88__Fi
// Address: 0x18ab88 - 0x18ab9c

void FUN_0018ab88__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ab88: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18ab8c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18ab90: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18ab94: 0xc072472
    SET_GPR_U32(ctx, 31, 0x18ab9c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_18ab9c
// Address: 0x18ab9c - 0x18abd0

void entry_18ab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ab9c) {
        switch (ctx->pc) {
            case 0x18abc8: ctx->pc = 0; goto label_18abc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ab9c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18aba0: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x18aba4: 0x10620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18abc8;
    }
    // 0x18abac: 0x1462000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18ABE0; return;
    }
    // 0x18abb4: 0x8e020a68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2664)));
    // 0x18abb8: 0xae000c04
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 0));
    // 0x18abbc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x18abc0: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 2664), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18ABE0; return;
    }
label_18abc8:
    // 0x18abc8: 0xc0580fa
    SET_GPR_U32(ctx, 31, 0x18abd0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    DefeatBossFromWid(rdram, ctx, runtime); return;
}


// Function: entry_18abd0
// Address: 0x18abd0 - 0x18abdc

void entry_18abd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18abd0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18abd4: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x18abdc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_18abdc
// Address: 0x18abdc - 0x18abf0

void entry_18abdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18abdc) {
        switch (ctx->pc) {
            case 0x18abe0: ctx->pc = 0; goto label_18abe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18abdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18abe0:
    // 0x18abe0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18abe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18abec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18abf0; return;
}


// Function: FUN_0018abf0__Fi
// Address: 0x18abf0 - 0x18ac1c

void FUN_0018abf0__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18abf0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18abf4: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x18abf8: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x18abfc: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18ac00: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18ac04: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18ac08: 0x1443000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x18AC3C; return;
    }
    // 0x18ac10: 0x8e040e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3600)));
    // 0x18ac14: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18ac1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ac1c
// Address: 0x18ac1c - 0x18ac34

void entry_18ac1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ac1c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ac20: 0x24020438
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1080));
    // 0x18ac24: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18AC3C; return;
    }
    // 0x18ac2c: 0xc0725ae
    SET_GPR_U32(ctx, 31, 0x18ac34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SggsGetStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_18ac34
// Address: 0x18ac34 - 0x18ac44

void entry_18ac34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ac34) {
        switch (ctx->pc) {
            case 0x18ac3c: ctx->pc = 0; goto label_18ac3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ac34: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18ac44(rdram, ctx, runtime); return;
    }
label_18ac3c:
    // 0x18ac3c: 0xc072004
    SET_GPR_U32(ctx, 31, 0x18ac44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SgsNextStepguardAI__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_18ac44
// Address: 0x18ac44 - 0x18ac58

void entry_18ac44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ac44: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18ac48: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ac4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ac54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ac58; return;
}


// Function: FUN_0018ac58__Fi
// Address: 0x18ac58 - 0x18ac74

void FUN_0018ac58__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ac58: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18ac5c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18ac60: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18ac64: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18ac68: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18ac6c: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x18ac74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_18ac74
// Address: 0x18ac74 - 0x18ac9c

void entry_18ac74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ac74: 0x8e030e28
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3624)));
    // 0x18ac78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18ac7c: 0x244249d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18904));
    // 0x18ac80: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ac84: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18ac88: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18ac8c: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x18ac90: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18ac94: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x18ac9c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 3632)));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_18ac9c
// Address: 0x18ac9c - 0x18acd0

void entry_18ac9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ac9c: 0x8e040e28
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3624)));
    // 0x18aca0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x18aca4: 0x246349e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 18920));
    // 0x18aca8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18acac: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x18acb0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18acb4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x18acb8: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18acbc: 0xae040e28
    WRITE32(ADD32(GPR_U32(ctx, 16), 3624), GPR_U32(ctx, 4));
    // 0x18acc0: 0xae050e3c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3644), GPR_U32(ctx, 5));
    // 0x18acc4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18acc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateMbg__FP3MBGf
// Address: 0x18acd0 - 0x18ace0

void entry_18ace0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ace0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ace4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18acec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18acf0; return;
}


// Function: FUN_0018acf0
// Address: 0x18acf0 - 0x18ad04

void FUN_0018acf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18acf0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18acf4: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18acf8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18acfc: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18ad04);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 3600)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ad04
// Address: 0x18ad04 - 0x18ad44

void entry_18ad04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ad04) {
        switch (ctx->pc) {
            case 0x18ad30: ctx->pc = 0; goto label_18ad30;
            case 0x18ad3c: ctx->pc = 0; goto label_18ad3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ad04: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ad08: 0x2402043c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1084));
    // 0x18ad0c: 0x1062000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18ad3c;
    }
    // 0x18ad14: 0x2862043d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1085));
    // 0x18ad18: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1082));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18ad30;
    }
    // 0x18ad20: 0x10620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18ad3c;
    }
    // 0x18ad28: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AD48; return;
    }
label_18ad30:
    // 0x18ad30: 0x2402043e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1086));
    // 0x18ad34: 0x14620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18AD48; return;
    }
label_18ad3c:
    // 0x18ad3c: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x18ad44);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18ad44
// Address: 0x18ad44 - 0x18ad60

void entry_18ad44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ad44) {
        switch (ctx->pc) {
            case 0x18ad48: ctx->pc = 0; goto label_18ad48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ad44: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_18ad48:
    // 0x18ad48: 0x10800007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AD68; return;
    }
    // 0x18ad50: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x18ad54: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x18ad58: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18ad60);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18ad60
// Address: 0x18ad60 - 0x18ad78

void entry_18ad60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ad60) {
        switch (ctx->pc) {
            case 0x18ad68: ctx->pc = 0; goto label_18ad68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ad60: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AD7C; return;
    }
label_18ad68:
    // 0x18ad68: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x18ad6c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x18ad70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18ad78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18ad78
// Address: 0x18ad78 - 0x18ad88

void entry_18ad78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ad78) {
        switch (ctx->pc) {
            case 0x18ad7c: ctx->pc = 0; goto label_18ad7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ad78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18ad7c:
    // 0x18ad7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ad84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ad88; return;
}


// Function: UpdateMbgGoal__FP3MBGi
// Address: 0x18ad88 - 0x18adbc

void entry_18adbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18adbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18adc0: 0xc072106
    SET_GPR_U32(ctx, 31, 0x18adc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_18adc8
// Address: 0x18adc8 - 0x18add8

void entry_18adc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18adc8) {
        switch (ctx->pc) {
            case 0x18add0: ctx->pc = 0; goto label_18add0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18adc8: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AE2C; return;
    }
label_18add0:
    // 0x18add0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18add8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18add8
// Address: 0x18add8 - 0x18adfc

void entry_18add8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18add8: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18addc: 0x2862043a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1082));
    // 0x18ade0: 0x10400008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1080));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AE04; return;
    }
    // 0x18ade8: 0x14400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AE08; return;
    }
    // 0x18adf0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18adf4: 0xc072106
    SET_GPR_U32(ctx, 31, 0x18adfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_18adfc
// Address: 0x18adfc - 0x18ae18

void entry_18adfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18adfc) {
        switch (ctx->pc) {
            case 0x18ae04: ctx->pc = 0; goto label_18ae04;
            case 0x18ae08: ctx->pc = 0; goto label_18ae08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18adfc: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AE2C; return;
    }
label_18ae04:
    // 0x18ae04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_18ae08:
    // 0x18ae08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ae0c: 0x8c452e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x18ae10: 0xc072106
    SET_GPR_U32(ctx, 31, 0x18ae18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_18ae18
// Address: 0x18ae18 - 0x18ae28

void entry_18ae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ae18) {
        switch (ctx->pc) {
            case 0x18ae20: ctx->pc = 0; goto label_18ae20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ae18: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AE2C; return;
    }
label_18ae20:
    // 0x18ae20: 0xc072302
    SET_GPR_U32(ctx, 31, 0x18ae28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_18ae28
// Address: 0x18ae28 - 0x18ae38

void entry_18ae28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ae28) {
        switch (ctx->pc) {
            case 0x18ae2c: ctx->pc = 0; goto label_18ae2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ae28: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_18ae2c:
    // 0x18ae2c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18ae30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateMbgSgs__FP3MBG
// Address: 0x18ae38 - 0x18ae5c

void entry_18ae5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ae5c) {
        switch (ctx->pc) {
            case 0x18ae7c: ctx->pc = 0; goto label_18ae7c;
            case 0x18aea4: ctx->pc = 0; goto label_18aea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ae5c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18ae60: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x18ae64: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18ae7c;
    }
    // 0x18ae6c: 0x106200c6
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18B188; return;
    }
    // 0x18ae74: 0x10000115
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18B2CC; return;
    }
label_18ae7c:
    // 0x18ae7c: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x18ae80: 0x10400110
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18b2c4(rdram, ctx, runtime); return;
    }
    // 0x18ae88: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x18ae8c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_18aea4;
    }
    // 0x18ae94: 0x8c42275c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 10076)));
    // 0x18ae98: 0x1440010b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18B2C8; return;
    }
    // 0x18aea0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_18aea4:
    // 0x18aea4: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x18aea8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18aeb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18aeb0
// Address: 0x18aeb0 - 0x18afa0

void entry_18aeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18aeb0) {
        switch (ctx->pc) {
            case 0x18af28: ctx->pc = 0; goto label_18af28;
            case 0x18af3c: ctx->pc = 0; goto label_18af3c;
            case 0x18af80: ctx->pc = 0; goto label_18af80;
            case 0x18af94: ctx->pc = 0; goto label_18af94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18aeb0: 0x10400043
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18AFC0; return;
    }
    // 0x18aeb8: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x18aebc: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x18aec0: 0x24624a00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 18944));
    // 0x18aec4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18aec8: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x18aecc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18aed0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18aed4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18aed8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18aedc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18aee0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x18aee4: 0xc4624a00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 18944)); ctx->f[2] = *(float*)&val; }
    // 0x18aee8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18aeec: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x18aef0: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x18aef4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18aef8: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x18aefc: 0x24435c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x18af00: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18af04: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x18af08: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x18af0c: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x18af10: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18af14: 0x0
    // NOP
    // 0x18af18: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18af28;
    }
    // 0x18af20: 0x10000006
    ctx->f[21] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18af3c;
    }
label_18af28:
    // 0x18af28: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18af2c: 0x0
    // NOP
    // 0x18af30: 0x45000002
    ctx->f[21] = FPU_MOV_S(ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18af3c;
    }
    // 0x18af38: 0x46002d46
    ctx->f[21] = FPU_MOV_S(ctx->f[5]);
label_18af3c:
    // 0x18af3c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18af40: 0xc6255c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x18af44: 0x24434a10
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 18960));
    // 0x18af48: 0xc4424a10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18960)); ctx->f[2] = *(float*)&val; }
    // 0x18af4c: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x18af50: 0x26225c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 23648));
    // 0x18af54: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x18af58: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x18af5c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x18af60: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x18af64: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x18af68: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18af6c: 0x0
    // NOP
    // 0x18af70: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18af80;
    }
    // 0x18af78: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18af94;
    }
label_18af80:
    // 0x18af80: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18af84: 0x0
    // NOP
    // 0x18af88: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18af94;
    }
    // 0x18af90: 0x46002506
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
label_18af94:
    // 0x18af94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18af98: 0xc062d18
    SET_GPR_U32(ctx, 31, 0x18afa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    FUN_0018b460(rdram, ctx, runtime); return;
}


// Function: entry_18afa0
// Address: 0x18afa0 - 0x18afd8

void entry_18afa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18afa0) {
        switch (ctx->pc) {
            case 0x18afc0: ctx->pc = 0; goto label_18afc0;
            case 0x18afcc: ctx->pc = 0; goto label_18afcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18afa0: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x18afa4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18afa8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18afac: 0x46140082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x18afb0: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x18afb4: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x18afb8: 0x10000004
    ctx->f[20] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18afcc;
    }
label_18afc0:
    // 0x18afc0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18afc4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x18afc8: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
label_18afcc:
    // 0x18afcc: 0xc60c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 276)); ctx->f[12] = *(float*)&val; }
    // 0x18afd0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x18afd8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_18afd8
// Address: 0x18afd8 - 0x18afe4

void entry_18afd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18afd8: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x18afdc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x18afe4);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_18afe4
// Address: 0x18afe4 - 0x18b054

void entry_18afe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18afe4) {
        switch (ctx->pc) {
            case 0x18b02c: ctx->pc = 0; goto label_18b02c;
            case 0x18b03c: ctx->pc = 0; goto label_18b03c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18afe4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18afe8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18afec: 0x24824a20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 18976));
    // 0x18aff0: 0xc4834a20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 18976)); ctx->f[3] = *(float*)&val; }
    // 0x18aff4: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x18aff8: 0x26235c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 23648));
    // 0x18affc: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x18b000: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x18b004: 0xc6255c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x18b008: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x18b00c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18b010: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x18b014: 0x46051834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b018: 0x0
    // NOP
    // 0x18b01c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18b02c;
    }
    // 0x18b024: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b03c;
    }
label_18b02c:
    // 0x18b02c: 0x46032034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b030: 0x0
    // NOP
    // 0x18b034: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[4]);
        goto label_18b03c;
    }
label_18b03c:
    // 0x18b03c: 0x4603a342
    ctx->f[13] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x18b040: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x18b044: 0x8e060e00
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x18b048: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b04c: 0xc075028
    SET_GPR_U32(ctx, 31, 0x18b054);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 3104));
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_18b054
// Address: 0x18b054 - 0x18b060

void entry_18b054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b054: 0x8e040e00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x18b058: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x18b060);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_18b060
// Address: 0x18b060 - 0x18b088

void entry_18b060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b060: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x18b064: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b068: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x18b06c: 0x8c440010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18b070: 0x8e020e00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x18b074: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18b078: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x18b07c: 0xc44d0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[13] = *(float*)&val; }
    // 0x18b080: 0xc04e65c
    SET_GPR_U32(ctx, 31, 0x18b088);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime); return;
}


// Function: entry_18b088
// Address: 0x18b088 - 0x18b098

void entry_18b088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b088: 0x8e040e00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x18b08c: 0x2c520001
    SET_GPR_U32(ctx, 18, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x18b090: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x18b098);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_18b098
// Address: 0x18b098 - 0x18b0c0

void entry_18b098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b098: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x18b09c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b0a0: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x18b0a4: 0x8c440010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18b0a8: 0x8e020e00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x18b0ac: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18b0b0: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x18b0b4: 0xc44d0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[13] = *(float*)&val; }
    // 0x18b0b8: 0xc04e65c
    SET_GPR_U32(ctx, 31, 0x18b0c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    ImrsgLookUp__FffiP4MRSGPf(rdram, ctx, runtime); return;
}


// Function: entry_18b0c0
// Address: 0x18b0c0 - 0x18b0dc

void entry_18b0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b0c0: 0x12400016
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_18b11c(rdram, ctx, runtime); return;
    }
    // 0x18b0c8: 0x8e020e04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3588)));
    // 0x18b0cc: 0x14400013
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_18b11c(rdram, ctx, runtime); return;
    }
    // 0x18b0d4: 0xc05180a
    SET_GPR_U32(ctx, 31, 0x18b0dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    FUN_00146028__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_18b0dc
// Address: 0x18b0dc - 0x18b11c

void entry_18b0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b0dc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x18b0e0: 0x240401cc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 460));
    // 0x18b0e4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x18b0e8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x18b0ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x18b0f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b0f4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x18b0f8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x18b0fc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b100: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18b104: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x18b108: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b10c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x18b110: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b114: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x18b11c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_18b11c
// Address: 0x18b11c - 0x18b13c

void entry_18b11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b11c: 0x52200018
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 3592), GPR_U32(ctx, 17));
        ctx->pc = 0x18B180; return;
    }
    // 0x18b124: 0x8e020e08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3592)));
    // 0x18b128: 0x54400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 3592), GPR_U32(ctx, 17));
        ctx->pc = 0x18B180; return;
    }
    // 0x18b130: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18b134: 0xc05180a
    SET_GPR_U32(ctx, 31, 0x18b13c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    FUN_00146028__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_18b13c
// Address: 0x18b13c - 0x18b17c

void entry_18b13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b13c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x18b140: 0x240401cc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 460));
    // 0x18b144: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x18b148: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x18b14c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x18b150: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b154: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x18b158: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x18b15c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b160: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18b164: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x18b168: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b16c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x18b170: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b174: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x18b17c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_18b17c
// Address: 0x18b17c - 0x18b190

void entry_18b17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b17c) {
        switch (ctx->pc) {
            case 0x18b180: ctx->pc = 0; goto label_18b180;
            case 0x18b188: ctx->pc = 0; goto label_18b188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b17c: 0xae110e08
    WRITE32(ADD32(GPR_U32(ctx, 16), 3592), GPR_U32(ctx, 17));
label_18b180:
    // 0x18b180: 0x10000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 3588), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18b2c4(rdram, ctx, runtime); return;
    }
label_18b188:
    // 0x18b188: 0xc072d5e
    SET_GPR_U32(ctx, 31, 0x18b190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cb578(rdram, ctx, runtime); return;
}


// Function: entry_18b190
// Address: 0x18b190 - 0x18b1bc

void entry_18b190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b190: 0x1440004d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18B2C8; return;
    }
    // 0x18b198: 0x3c01392e
    SET_GPR_U32(ctx, 1, ((uint32_t)14638 << 16));
    // 0x18b19c: 0x3421c33e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49982));
    // 0x18b1a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18b1a4: 0x70002ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 0)));
    // 0x18b1a8: 0x7fa50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 5));
    // 0x18b1ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b1b0: 0x27a50024
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 36));
    // 0x18b1b4: 0xc062d18
    SET_GPR_U32(ctx, 31, 0x18b1bc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    FUN_0018b460(rdram, ctx, runtime); return;
}


// Function: entry_18b1bc
// Address: 0x18b1bc - 0x18b1fc

void entry_18b1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b1bc: 0xc7a10024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[1] = *(float*)&val; }
    // 0x18b1c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18b1c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18b1c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18b1cc: 0x244549d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 18896));
    // 0x18b1d0: 0xc44349d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18896)); ctx->f[3] = *(float*)&val; }
    // 0x18b1d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b1d8: 0x46010041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x18b1dc: 0xc4a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[2] = *(float*)&val; }
    // 0x18b1e0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18b1e4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x18b1e8: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x18b1ec: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x18b1f0: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x18b1f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18b1fc);
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18b1fc
// Address: 0x18b1fc - 0x18b298

void entry_18b1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b1fc) {
        switch (ctx->pc) {
            case 0x18b26c: ctx->pc = 0; goto label_18b26c;
            case 0x18b27c: ctx->pc = 0; goto label_18b27c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b1fc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18b200: 0x10800030
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_18b2c4(rdram, ctx, runtime); return;
    }
    // 0x18b208: 0xd8810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x18b20c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x18b210: 0x24435c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x18b214: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18b218: 0xc7a20018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[2] = *(float*)&val; }
    // 0x18b21c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18b220: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18b224: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x18b228: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18b22c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18b230: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x18b234: 0xc7a30010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[3] = *(float*)&val; }
    // 0x18b238: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18b23c: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x18b240: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x18b244: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x18b248: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x18b24c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18b250: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x18b254: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b258: 0x0
    // NOP
    // 0x18b25c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18b26c;
    }
    // 0x18b264: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b27c;
    }
label_18b26c:
    // 0x18b26c: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b270: 0x0
    // NOP
    // 0x18b274: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_18b27c;
    }
label_18b27c:
    // 0x18b27c: 0x46141b29
    ctx->f[12] = std::min(ctx->f[3], ctx->f[20]);
    // 0x18b280: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b284: 0x26060e40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 3648));
    // 0x18b288: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b28c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b290: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x18b298);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_18b298
// Address: 0x18b298 - 0x18b2b4

void entry_18b298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b298: 0xda010e40
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 3648)));
    // 0x18b29c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x18b2a0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18b2a4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18b2a8: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x18b2ac: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x18b2b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_18b2b4
// Address: 0x18b2b4 - 0x18b2c4

void entry_18b2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b2b4: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x18b2b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b2bc: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x18b2c4);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_18b2c4
// Address: 0x18b2c4 - 0x18b2e8

void entry_18b2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b2c4) {
        switch (ctx->pc) {
            case 0x18b2c8: ctx->pc = 0; goto label_18b2c8;
            case 0x18b2cc: ctx->pc = 0; goto label_18b2cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b2c4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_18b2c8:
    // 0x18b2c8: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_18b2cc:
    // 0x18b2cc: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18b2d0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18b2d4: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x18b2d8: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x18b2dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b2e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b2e8; return;
}


// Function: OnMgExitingSgs__FP3MBG3SGS
// Address: 0x18b2e8 - 0x18b300

void entry_18b300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b300: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18b304: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x18b308: 0x14620009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18B330; return;
    }
    // 0x18b310: 0x8e050e3c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3644)));
    // 0x18b314: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18b318: 0x50b10006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
        ctx->pc = 0x18B334; return;
    }
    // 0x18b320: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x18b328);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3600)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_18b328
// Address: 0x18b328 - 0x18b340

void entry_18b328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b328) {
        switch (ctx->pc) {
            case 0x18b330: ctx->pc = 0; goto label_18b330;
            case 0x18b334: ctx->pc = 0; goto label_18b334;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b328: 0xae110e3c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3644), GPR_U32(ctx, 17));
    // 0x18b32c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_18b330:
    // 0x18b330: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18b334:
    // 0x18b334: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b338: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleMbgMessage__FP3MBG5MSGIDPv
// Address: 0x18b340 - 0x18b3b4

void entry_18b3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b3b4) {
        switch (ctx->pc) {
            case 0x18b3dc: ctx->pc = 0; goto label_18b3dc;
            case 0x18b3f0: ctx->pc = 0; goto label_18b3f0;
            case 0x18b408: ctx->pc = 0; goto label_18b408;
            case 0x18b41c: ctx->pc = 0; goto label_18b41c;
            case 0x18b428: ctx->pc = 0; goto label_18b428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b3b4: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b3b8: 0x2402043c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1084));
    // 0x18b3bc: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1085));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18b3f0;
    }
    // 0x18b3c4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1082));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18b3dc;
    }
    // 0x18b3cc: 0x10620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18b3f0;
    }
    // 0x18b3d4: 0x10000014
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b428;
    }
label_18b3dc:
    // 0x18b3dc: 0x2402043e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1086));
    // 0x18b3e0: 0x10620009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18b408;
    }
    // 0x18b3e8: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b428;
    }
label_18b3f0:
    // 0x18b3f0: 0x7a230e40
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 3648)));
    // 0x18b3f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18b3f8: 0xc4414a34
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 18996)); ctx->f[1] = *(float*)&val; }
    // 0x18b3fc: 0x7e0300f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), GPR_VEC(ctx, 3));
    // 0x18b400: 0x10000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 328)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b41c;
    }
label_18b408:
    // 0x18b408: 0x7a230e40
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 3648)));
    // 0x18b40c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18b410: 0xc4414a38
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19000)); ctx->f[1] = *(float*)&val; }
    // 0x18b414: 0x7e0300f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), GPR_VEC(ctx, 3));
    // 0x18b418: 0xc60000f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 248)); ctx->f[0] = *(float*)&val; }
label_18b41c:
    // 0x18b41c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x18b420: 0xe60000f8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 248), *(uint32_t*)&val); }
    // 0x18b424: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_18b428:
    // 0x18b428: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x18b430);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_18b430
// Address: 0x18b430 - 0x18b448

void entry_18b430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b430) {
        switch (ctx->pc) {
            case 0x18b438: ctx->pc = 0; goto label_18b438;
            case 0x18b440: ctx->pc = 0; goto label_18b440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b430: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18B44C; return;
    }
label_18b438:
    // 0x18b438: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18b43c: 0xae220e2c
    WRITE32(ADD32(GPR_U32(ctx, 17), 3628), GPR_U32(ctx, 2));
label_18b440:
    // 0x18b440: 0xc072778
    SET_GPR_U32(ctx, 31, 0x18b448);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    HandleStepguardMessage__FP9STEPGUARD5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_18b448
// Address: 0x18b448 - 0x18b460

void entry_18b448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b448) {
        switch (ctx->pc) {
            case 0x18b44c: ctx->pc = 0; goto label_18b44c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b448: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_18b44c:
    // 0x18b44c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18b450: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b454: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b45c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b460; return;
}


// Function: FUN_0018b460
// Address: 0x18b460 - 0x18b47c

void FUN_0018b460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b460: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18b464: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x18b468: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18b46c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18b470: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18b474: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x18b47c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 3600)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_18b47c
// Address: 0x18b47c - 0x18b580

void entry_18b47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b47c) {
        switch (ctx->pc) {
            case 0x18b49c: ctx->pc = 0; goto label_18b49c;
            case 0x18b4e8: ctx->pc = 0; goto label_18b4e8;
            case 0x18b500: ctx->pc = 0; goto label_18b500;
            case 0x18b548: ctx->pc = 0; goto label_18b548;
            case 0x18b560: ctx->pc = 0; goto label_18b560;
            case 0x18b568: ctx->pc = 0; goto label_18b568;
            case 0x18b56c: ctx->pc = 0; goto label_18b56c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b47c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b480: 0x2402043a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1082));
    // 0x18b484: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1084));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18b49c;
    }
    // 0x18b48c: 0x1062001c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18b500;
    }
    // 0x18b494: 0x10000032
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b560;
    }
label_18b49c:
    // 0x18b49c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18b4a0: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x18b4a4: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x18b4a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18b4ac: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x18b4b0: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x18b4b4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x18b4b8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18b4bc: 0xc460000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[0] = *(float*)&val; }
    // 0x18b4c0: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x18b4c4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18b4c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18b4cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18b4d0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x18b4d4: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b4d8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18b4e8;
    }
    // 0x18b4e0: 0x10000021
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b568;
    }
label_18b4e8:
    // 0x18b4e8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b4ec: 0x0
    // NOP
    // 0x18b4f0: 0x4503001d
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_18b568;
    }
    // 0x18b4f8: 0x1000001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b56c;
    }
label_18b500:
    // 0x18b500: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x18b504: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x18b508: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18b50c: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x18b510: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x18b514: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x18b518: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18b51c: 0xc460000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[0] = *(float*)&val; }
    // 0x18b520: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x18b524: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18b528: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18b52c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18b530: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x18b534: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b538: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18b548;
    }
    // 0x18b540: 0x10000009
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b568;
    }
label_18b548:
    // 0x18b548: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18b54c: 0x0
    // NOP
    // 0x18b550: 0x45030005
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_18b568;
    }
    // 0x18b558: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b56c;
    }
label_18b560:
    // 0x18b560: 0xc460000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[0] = *(float*)&val; }
    // 0x18b564: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
label_18b568:
    // 0x18b568: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_18b56c:
    // 0x18b56c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18b570: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b57c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b580; return;
}


// Function: StartupMemcard__Fv
// Address: 0x18b580 - 0x18b590

void entry_18b590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b590: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18b594: 0xc062d70
    SET_GPR_U32(ctx, 31, 0x18b59c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    InitMemcard__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_18b59c
// Address: 0x18b59c - 0x18b5b0

void entry_18b59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b59c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18b5a0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b5a4: 0x24844a40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    // 0x18b5a8: 0xc062f56
    SET_GPR_U32(ctx, 31, 0x18b5b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitSave__FP4SAVEii(rdram, ctx, runtime); return;
}


// Function: entry_18b5b0
// Address: 0x18b5b0 - 0x18b5c0

void entry_18b5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b5b0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b5b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b5bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b5c0; return;
}


// Function: InitMemcard__FP7MEMCARD
// Address: 0x18b5c0 - 0x18b5dc

void entry_18b5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b5dc: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18b5e0: 0x24030022
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 34));
    // 0x18b5e4: 0xae030010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 3));
    // 0x18b5e8: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x18b5ec: 0xae040004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 4));
    // 0x18b5f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b5f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b5f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018b600__Fv
// Address: 0x18b600 - 0x18b61c

void FUN_0018b600__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b600: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18b604: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18b608: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x18b60c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18b610: 0x8e249990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294941072)));
    // 0x18b614: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x18b61c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_18b61c
// Address: 0x18b61c - 0x18b62c

void entry_18b61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b61c: 0x26309990
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294941072));
    // 0x18b620: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x18b624: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18b62c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18b62c
// Address: 0x18b62c - 0x18b650

void entry_18b62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b62c: 0x8e249990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294941072)));
    // 0x18b630: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18b634: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x18b638: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x18b63c: 0xac655960
    WRITE32(ADD32(GPR_U32(ctx, 3), 22880), GPR_U32(ctx, 5));
    // 0x18b640: 0xae050004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 5));
    // 0x18b644: 0xae000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
    // 0x18b648: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x18b650);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_18b650
// Address: 0x18b650 - 0x18b658

void entry_18b650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b650: 0xc07da8c
    SET_GPR_U32(ctx, 31, 0x18b658);
    ExitDeleteThread(rdram, ctx, runtime); return;
}


// Function: entry_18b658
// Address: 0x18b658 - 0x18b670

void entry_18b658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b658: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18b65c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b660: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b664: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b66c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b670; return;
}


// Function: CreateMemcardThread__FP7MEMCARDii
// Address: 0x18b670 - 0x18b694

void entry_18b694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b694: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x18b698: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x18b69c: 0xae12000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 18));
    // 0x18b6a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18b6a4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18b6a8: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x18b6ac: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18b6b4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18b6b4
// Address: 0x18b6b4 - 0x18b6f0

void entry_18b6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b6b4: 0x3c030019
    SET_GPR_U32(ctx, 3, ((uint32_t)25 << 16));
    // 0x18b6b8: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x18b6bc: 0x3c050028
    SET_GPR_U32(ctx, 5, ((uint32_t)40 << 16));
    // 0x18b6c0: 0x2463b600
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294948352));
    // 0x18b6c4: 0x24a532f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 13040));
    // 0x18b6c8: 0x24064000
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16384));
    // 0x18b6cc: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18b6d0: 0x2442ea10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961680));
    // 0x18b6d4: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x18b6d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18b6dc: 0xafa50010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 5));
    // 0x18b6e0: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x18b6e4: 0xafa6000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 6));
    // 0x18b6e8: 0xc07da84
    SET_GPR_U32(ctx, 31, 0x18b6f0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 7));
    CreateThread(rdram, ctx, runtime); return;
}


// Function: entry_18b6f0
// Address: 0x18b6f0 - 0x18b708

void entry_18b6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b6f0: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x18b6f4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x18b6f8: 0xac625960
    WRITE32(ADD32(GPR_U32(ctx, 3), 22880), GPR_U32(ctx, 2));
    // 0x18b6fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b700: 0xc07da88
    SET_GPR_U32(ctx, 31, 0x18b708);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    StartThread(rdram, ctx, runtime); return;
}


// Function: entry_18b708
// Address: 0x18b708 - 0x18b720

void entry_18b708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b708: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18b70c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18b710: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18b714: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18b718: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetMemcardThreadHighPrio__FP7MEMCARD
// Address: 0x18b720 - 0x18b73c

void entry_18b73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b73c: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18b750(rdram, ctx, runtime); return;
    }
    // 0x18b744: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x18b748: 0xc07da94
    SET_GPR_U32(ctx, 31, 0x18b750);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ChangeThreadPriority(rdram, ctx, runtime); return;
}


// Function: entry_18b750
// Address: 0x18b750 - 0x18b758

void entry_18b750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b750: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x18b758);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_18b758
// Address: 0x18b758 - 0x18b760

void entry_18b758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b758: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x18b760);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_18b760
// Address: 0x18b760 - 0x18b770

void entry_18b760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b760: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b764: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b768: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckMemcardThread__FP7MEMCARD
// Address: 0x18b770 - 0x18b780

void FUN_0018b780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b780: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18b784: 0x2406005c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 92));
    // 0x18b788: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18b78c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18b790: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18b794: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18b798: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18b79c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b7a0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18b7a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18b7a8
// Address: 0x18b7a8 - 0x18b7b4

void entry_18b7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18b7a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18b7ac: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x18b7b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 32));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_18b7b4
// Address: 0x18b7b4 - 0x18b910

void entry_18b7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b7b4) {
        switch (ctx->pc) {
            case 0x18b7dc: ctx->pc = 0; goto label_18b7dc;
            case 0x18b7f8: ctx->pc = 0; goto label_18b7f8;
            case 0x18b814: ctx->pc = 0; goto label_18b814;
            case 0x18b830: ctx->pc = 0; goto label_18b830;
            case 0x18b84c: ctx->pc = 0; goto label_18b84c;
            case 0x18b868: ctx->pc = 0; goto label_18b868;
            case 0x18b884: ctx->pc = 0; goto label_18b884;
            case 0x18b8a0: ctx->pc = 0; goto label_18b8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b7b4: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x18b7b8: 0xae030044
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 3));
    // 0x18b7bc: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x18b7c0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x18b7c4: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b7dc;
    }
    // 0x18b7cc: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b7d0: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x18b7d4: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b7d8: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b7dc:
    // 0x18b7dc: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x18b7e0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b7f8;
    }
    // 0x18b7e8: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b7ec: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x18b7f0: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b7f4: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b7f8:
    // 0x18b7f8: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x18b7fc: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b814;
    }
    // 0x18b804: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b808: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x18b80c: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b810: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b814:
    // 0x18b814: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x18b818: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b830;
    }
    // 0x18b820: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b824: 0x34420008
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    // 0x18b828: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b82c: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b830:
    // 0x18b830: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x18b834: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b84c;
    }
    // 0x18b83c: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b840: 0x34420010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16));
    // 0x18b844: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b848: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b84c:
    // 0x18b84c: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x18b850: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b868;
    }
    // 0x18b858: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b85c: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x18b860: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b864: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b868:
    // 0x18b868: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x18b86c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_18b884;
    }
    // 0x18b874: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b878: 0x34420040
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 64));
    // 0x18b87c: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b880: 0x96220014
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 20)));
label_18b884:
    // 0x18b884: 0x30421000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4096));
    // 0x18b888: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 5)));
        goto label_18b8a0;
    }
    // 0x18b890: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x18b894: 0x34420080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 128));
    // 0x18b898: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x18b89c: 0x92220005
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 5)));
label_18b8a0:
    // 0x18b8a0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18b8a4: 0xa202004a
    WRITE8(ADD32(GPR_U32(ctx, 16), 74), (uint8_t)GPR_U32(ctx, 2));
    // 0x18b8a8: 0x92230004
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x18b8ac: 0xa203004b
    WRITE8(ADD32(GPR_U32(ctx, 16), 75), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b8b0: 0x96220006
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
    // 0x18b8b4: 0xa602004c
    WRITE16(ADD32(GPR_U32(ctx, 16), 76), (uint16_t)GPR_U32(ctx, 2));
    // 0x18b8b8: 0x92230003
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 3)));
    // 0x18b8bc: 0xa203004e
    WRITE8(ADD32(GPR_U32(ctx, 16), 78), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b8c0: 0x92220002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 2)));
    // 0x18b8c4: 0xa202004f
    WRITE8(ADD32(GPR_U32(ctx, 16), 79), (uint8_t)GPR_U32(ctx, 2));
    // 0x18b8c8: 0x92230001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 1)));
    // 0x18b8cc: 0xa2030050
    WRITE8(ADD32(GPR_U32(ctx, 16), 80), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b8d0: 0x9222000d
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 13)));
    // 0x18b8d4: 0xa2020052
    WRITE8(ADD32(GPR_U32(ctx, 16), 82), (uint8_t)GPR_U32(ctx, 2));
    // 0x18b8d8: 0x9223000c
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x18b8dc: 0xa2030053
    WRITE8(ADD32(GPR_U32(ctx, 16), 83), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b8e0: 0x9622000e
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 14)));
    // 0x18b8e4: 0xa6020054
    WRITE16(ADD32(GPR_U32(ctx, 16), 84), (uint16_t)GPR_U32(ctx, 2));
    // 0x18b8e8: 0x9223000b
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 11)));
    // 0x18b8ec: 0xa2030056
    WRITE8(ADD32(GPR_U32(ctx, 16), 86), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b8f0: 0x9222000a
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x18b8f4: 0xa2020057
    WRITE8(ADD32(GPR_U32(ctx, 16), 87), (uint8_t)GPR_U32(ctx, 2));
    // 0x18b8f8: 0x92230009
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 9)));
    // 0x18b8fc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18b900: 0xa2030058
    WRITE8(ADD32(GPR_U32(ctx, 16), 88), (uint8_t)GPR_U32(ctx, 3));
    // 0x18b904: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18b908: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018b910__Fi
// Address: 0x18b910 - 0x18b930

void FUN_0018b910__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b910) {
        switch (ctx->pc) {
            case 0x18b928: ctx->pc = 0; goto label_18b928;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b910: 0x10800005
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 4)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_18b928;
    }
    // 0x18b918: 0x2403001e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 30));
    // 0x18b91c: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x18b920: 0x3e00008
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b928:
    // 0x18b928: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018b930__Fi
// Address: 0x18b930 - 0x18b988

void FUN_0018b930__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b930) {
        switch (ctx->pc) {
            case 0x18b954: ctx->pc = 0; goto label_18b954;
            case 0x18b964: ctx->pc = 0; goto label_18b964;
            case 0x18b96c: ctx->pc = 0; goto label_18b96c;
            case 0x18b974: ctx->pc = 0; goto label_18b974;
            case 0x18b97c: ctx->pc = 0; goto label_18b97c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b930: 0x1080000c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_18b964;
    }
    // 0x18b938: 0x1c800006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 4) > 0) {
        goto label_18b954;
    }
    // 0x18b940: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18b944: 0x1082000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18b974;
    }
    // 0x18b94c: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b97c;
    }
label_18b954:
    // 0x18b954: 0x10820005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18b96c;
    }
    // 0x18b95c: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18b97c;
    }
label_18b964:
    // 0x18b964: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b96c:
    // 0x18b96c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b974:
    // 0x18b974: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b97c:
    // 0x18b97c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18b984: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18b988; return;
}


// Function: FUN_0018b988
// Address: 0x18b988 - 0x18bc90

void FUN_0018b988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18b988) {
        switch (ctx->pc) {
            case 0x18b9d4: ctx->pc = 0; goto label_18b9d4;
            case 0x18b9e0: ctx->pc = 0; goto label_18b9e0;
            case 0x18b9e8: ctx->pc = 0; goto label_18b9e8;
            case 0x18b9f0: ctx->pc = 0; goto label_18b9f0;
            case 0x18b9f8: ctx->pc = 0; goto label_18b9f8;
            case 0x18b9fc: ctx->pc = 0; goto label_18b9fc;
            case 0x18ba00: ctx->pc = 0; goto label_18ba00;
            case 0x18ba34: ctx->pc = 0; goto label_18ba34;
            case 0x18ba54: ctx->pc = 0; goto label_18ba54;
            case 0x18ba5c: ctx->pc = 0; goto label_18ba5c;
            case 0x18bae8: ctx->pc = 0; goto label_18bae8;
            case 0x18baf0: ctx->pc = 0; goto label_18baf0;
            case 0x18bb1c: ctx->pc = 0; goto label_18bb1c;
            case 0x18bb30: ctx->pc = 0; goto label_18bb30;
            case 0x18bb54: ctx->pc = 0; goto label_18bb54;
            case 0x18bb70: ctx->pc = 0; goto label_18bb70;
            case 0x18bb8c: ctx->pc = 0; goto label_18bb8c;
            case 0x18bc04: ctx->pc = 0; goto label_18bc04;
            case 0x18bc08: ctx->pc = 0; goto label_18bc08;
            case 0x18bc10: ctx->pc = 0; goto label_18bc10;
            case 0x18bc58: ctx->pc = 0; goto label_18bc58;
            case 0x18bc74: ctx->pc = 0; goto label_18bc74;
            case 0x18bc7c: ctx->pc = 0; goto label_18bc7c;
            case 0x18bc84: ctx->pc = 0; goto label_18bc84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18b988: 0x2483ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x18b98c: 0x2c620015
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 21));
    // 0x18b990: 0x104000bc
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bc84;
    }
    // 0x18b998: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18b99c: 0x2442b280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947456));
    // 0x18b9a0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18b9a4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18b9a8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x18b9b0: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18b9b4: 0x10a2000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18b9e8;
    }
    // 0x18b9bc: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967291));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18b9d4;
    }
    // 0x18b9c4: 0x10a2000a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18b9f0;
    }
    // 0x18b9cc: 0x1000000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
label_18b9d4:
    // 0x18b9d4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18b9d8: 0x14a20043
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_18bae8;
    }
label_18b9e0:
    // 0x18b9e0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b9e8:
    // 0x18b9e8: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b9f0:
    // 0x18b9f0: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18b9f8:
    // 0x18b9f8: 0x28a4fff7
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
label_18b9fc:
    // 0x18b9fc: 0x2403000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
label_18ba00:
    // 0x18ba00: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x18ba04: 0x3e00008
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba0c: 0x24a30007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 7));
    // 0x18ba10: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x18ba14: 0x1040007e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bc10;
    }
    // 0x18ba1c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18ba20: 0x2442b2e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947552));
    // 0x18ba24: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18ba28: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18ba2c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
label_18ba34:
    // 0x18ba34: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba3c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba44: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba4c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 25));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18ba54:
    // 0x18ba54: 0x14a2ffe9
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_18b9fc;
    }
label_18ba5c:
    // 0x18ba5c: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba64: 0x2402fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x18ba68: 0x10a2fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18ba5c;
    }
    // 0x18ba70: 0x10000065
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bc08;
    }
    // 0x18ba78: 0x2402fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x18ba7c: 0x10a2fff7
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967293));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18ba5c;
    }
    // 0x18ba84: 0x1040005f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967291));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bc04;
    }
    // 0x18ba8c: 0x14a20060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 17));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_18bc10;
    }
    // 0x18ba94: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ba9c: 0x24a30008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 8));
    // 0x18baa0: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x18baa4: 0x1040005a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bc10;
    }
    // 0x18baac: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18bab0: 0x2442b300
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947584));
    // 0x18bab4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18bab8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18babc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x18bac4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bacc: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bad4: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18bad8: 0x10a20025
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
    // 0x18bae0: 0x1440ffdc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18ba54;
    }
label_18bae8:
    // 0x18bae8: 0x14a0ffc4
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_18b9fc;
    }
label_18baf0:
    // 0x18baf0: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18baf8: 0x2402fffd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x18bafc: 0x10a2ffcd
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967294));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18ba34;
    }
    // 0x18bb04: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bb1c;
    }
    // 0x18bb0c: 0x10a20008
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb30;
    }
    // 0x18bb14: 0x1000ffba
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
label_18bb1c:
    // 0x18bb1c: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18bb20: 0x10a20013
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
    // 0x18bb28: 0x1000ffef
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bae8;
    }
label_18bb30:
    // 0x18bb30: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bb38: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18bb3c: 0x10a2000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
    // 0x18bb44: 0x1040ffe8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bae8;
    }
    // 0x18bb4c: 0x14a2ffab
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_18b9fc;
    }
label_18bb54:
    // 0x18bb54: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bb5c: 0x2402fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x18bb60: 0x10a2fffc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb54;
    }
    // 0x18bb68: 0x10000027
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bc08;
    }
label_18bb70:
    // 0x18bb70: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bb78: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18bb7c: 0x10a2fffc
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
    // 0x18bb84: 0x1040ffd8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bae8;
    }
label_18bb8c:
    // 0x18bb8c: 0x14a2ff9b
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_18b9fc;
    }
    // 0x18bb94: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bb9c: 0x24a30006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 6));
    // 0x18bba0: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x18bba4: 0x1040ff94
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18b9f8;
    }
    // 0x18bbac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18bbb0: 0x2442b320
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947616));
    // 0x18bbb4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18bbb8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18bbbc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x18bbc4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bbcc: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bbd4: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bbdc: 0x10a0ff80
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_18b9e0;
    }
    // 0x18bbe4: 0x28a40000
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 0));
    // 0x18bbe8: 0x1000ff85
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
    // 0x18bbf0: 0x10a0ff7b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_18b9e0;
    }
    // 0x18bbf8: 0x28a40000
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 0));
    // 0x18bbfc: 0x1000ff80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
label_18bc04:
    // 0x18bc04: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
label_18bc08:
    // 0x18bc08: 0x10a2ffd9
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
label_18bc10:
    // 0x18bc10: 0x4a1ffb7
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967287));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_18baf0;
    }
    // 0x18bc18: 0x1000ff79
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
    // 0x18bc20: 0x2402fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x18bc24: 0x10a2ffd2
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bb70;
    }
    // 0x18bc2c: 0x1440ffd7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18bb8c;
    }
    // 0x18bc34: 0x1000ffac
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bae8;
    }
    // 0x18bc3c: 0x2402fe6d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294966893));
    // 0x18bc40: 0x10a20005
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18bc58;
    }
    // 0x18bc48: 0x14a0000a
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_18bc74;
    }
    // 0x18bc50: 0x1000ffa7
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18baf0;
    }
label_18bc58:
    // 0x18bc58: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 35));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bc60: 0x4a1ffa3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 100));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_18baf0;
    }
    // 0x18bc68: 0x2c420064
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 100));
    // 0x18bc6c: 0x10400003
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), 4294967197));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bc7c;
    }
label_18bc74:
    // 0x18bc74: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18bc7c:
    // 0x18bc7c: 0x1000ff60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 30));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ba00;
    }
label_18bc84:
    // 0x18bc84: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x18bc88: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018bc90
// Address: 0x18bc90 - 0x18bcb4

void FUN_0018bc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bc90: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x18bc94: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x18bc98: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x18bc9c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18bca0: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18bca4: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x18bca8: 0x37a60004
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 29), 4));
    // 0x18bcac: 0xc0826e0
    SET_GPR_U32(ctx, 31, 0x18bcb4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    wait_for_sif_rpc_done_2QMARK(rdram, ctx, runtime); return;
}


// Function: entry_18bcb4
// Address: 0x18bcb4 - 0x18bcbc

void entry_18bcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bcb4: 0xc062e4c
    SET_GPR_U32(ctx, 31, 0x18bcbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_0018b930__Fi(rdram, ctx, runtime); return;
}


// Function: entry_18bcbc
// Address: 0x18bcbc - 0x18bce4

void entry_18bcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bcbc) {
        switch (ctx->pc) {
            case 0x18bccc: ctx->pc = 0; goto label_18bccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bcbc: 0x12000003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_18bccc;
    }
    // 0x18bcc4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x18bcc8: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_18bccc:
    // 0x18bccc: 0x24020021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    // 0x18bcd0: 0x14620006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18BCEC; return;
    }
    // 0x18bcd8: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x18bcdc: 0xc062e62
    SET_GPR_U32(ctx, 31, 0x18bce4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0018b988(rdram, ctx, runtime); return;
}


// Function: entry_18bce4
// Address: 0x18bce4 - 0x18bd00

void entry_18bce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bce4) {
        switch (ctx->pc) {
            case 0x18bcec: ctx->pc = 0; goto label_18bcec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bce4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18bce8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_18bcec:
    // 0x18bcec: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18bcf0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18bcf4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18bcf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018bd00
// Address: 0x18bd00 - 0x18bd1c

void FUN_0018bd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bd00: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18bd04: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18bd08: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18bd0c: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18bd10: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18bd14: 0xc062e44
    SET_GPR_U32(ctx, 31, 0x18bd1c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_0018b910__Fi(rdram, ctx, runtime); return;
}


// Function: entry_18bd1c
// Address: 0x18bd1c - 0x18bd3c

void entry_18bd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bd1c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18bd20: 0x2402001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    // 0x18bd24: 0x14620007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18BD44; return;
    }
    // 0x18bd2c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18bd30: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18bd34: 0xc062f24
    SET_GPR_U32(ctx, 31, 0x18bd3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bc90(rdram, ctx, runtime); return;
}


// Function: entry_18bd3c
// Address: 0x18bd3c - 0x18bd58

void entry_18bd3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bd3c) {
        switch (ctx->pc) {
            case 0x18bd44: ctx->pc = 0; goto label_18bd44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bd3c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18bd40: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_18bd44:
    // 0x18bd44: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18bd48: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18bd4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18bd50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSave__FP4SAVEii
// Address: 0x18bd58 - 0x18bd84

void entry_18bd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bd84: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18bd88: 0xae000014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 0));
    // 0x18bd8c: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x18bd90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18bd94: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x18bd9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_18bd9c
// Address: 0x18bd9c - 0x18bdc8

void entry_18bd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bd9c: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x18bda0: 0xae120008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 18));
    // 0x18bda4: 0xae004f44
    WRITE32(ADD32(GPR_U32(ctx, 16), 20292), GPR_U32(ctx, 0));
    // 0x18bda8: 0xae004f48
    WRITE32(ADD32(GPR_U32(ctx, 16), 20296), GPR_U32(ctx, 0));
    // 0x18bdac: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18bdb0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18bdb4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18bdb8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18bdbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bdc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18bdc8; return;
}


// Function: UpdateSave__FP4SAVE
// Address: 0x18bdc8 - 0x18bdf4

void entry_18bdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18bdf4: 0x14400066
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF90; return;
    }
    // 0x18bdfc: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x18be00: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x18be04: 0x1445000d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x18BE3C; return;
    }
    // 0x18be0c: 0xc6010020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[1] = *(float*)&val; }
    // 0x18be10: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x18be14: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18be18: 0x0
    // NOP
    // 0x18be1c: 0x45000009
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_18be44(rdram, ctx, runtime); return;
    }
    // 0x18be24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18be28: 0x24a5d0a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294955168));
    // 0x18be2c: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x18be34);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_18be34
// Address: 0x18be34 - 0x18be44

void entry_18be34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18be34) {
        switch (ctx->pc) {
            case 0x18be3c: ctx->pc = 0; goto label_18be3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18be34: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18be44(rdram, ctx, runtime); return;
    }
label_18be3c:
    // 0x18be3c: 0xc06300a
    SET_GPR_U32(ctx, 31, 0x18be44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0018c028(rdram, ctx, runtime); return;
}


// Function: entry_18be44
// Address: 0x18be44 - 0x18be4c

void entry_18be44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18be44: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x18be4c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294941072));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_18be4c
// Address: 0x18be4c - 0x18beb8

void entry_18be4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18be4c: 0x14400050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF90; return;
    }
    // 0x18be54: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x18be58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18be5c: 0x5462004d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x18BF94; return;
    }
    // 0x18be64: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18be68: 0xc6020010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[2] = *(float*)&val; }
    // 0x18be6c: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x18be70: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x18be74: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x18be78: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18be7c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x18be80: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18be84: 0x0
    // NOP
    // 0x18be88: 0x45020042
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x18BF94; return;
    }
    // 0x18be90: 0x8e024f44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20292)));
    // 0x18be94: 0x1040000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BEC0; return;
    }
    // 0x18be9c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x18bea0: 0x1062003b
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18BF90; return;
    }
    // 0x18bea8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18beac: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x18beb0: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x18beb8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 21));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_18beb8
// Address: 0x18beb8 - 0x18bf00

void entry_18beb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18beb8) {
        switch (ctx->pc) {
            case 0x18bec0: ctx->pc = 0; goto label_18bec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18beb8: 0x10000035
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF90; return;
    }
label_18bec0:
    // 0x18bec0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x18bec4: 0x2464ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4294967144));
    // 0x18bec8: 0x8c82025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 604)));
    // 0x18becc: 0x1040000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF08; return;
    }
    // 0x18bed4: 0x8c830268
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 616)));
    // 0x18bed8: 0x24020011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 17));
    // 0x18bedc: 0x5462000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x18BF0C; return;
    }
    // 0x18bee4: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x18bee8: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x18beec: 0x10620028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18BF90; return;
    }
    // 0x18bef4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18bef8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x18bf00);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_18bf00
// Address: 0x18bf00 - 0x18bf74

void entry_18bf00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bf00) {
        switch (ctx->pc) {
            case 0x18bf08: ctx->pc = 0; goto label_18bf08;
            case 0x18bf0c: ctx->pc = 0; goto label_18bf0c;
            case 0x18bf30: ctx->pc = 0; goto label_18bf30;
            case 0x18bf4c: ctx->pc = 0; goto label_18bf4c;
            case 0x18bf58: ctx->pc = 0; goto label_18bf58;
            case 0x18bf64: ctx->pc = 0; goto label_18bf64;
            case 0x18bf6c: ctx->pc = 0; goto label_18bf6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bf00: 0x10000023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF90; return;
    }
label_18bf08:
    // 0x18bf08: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_18bf0c:
    // 0x18bf0c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18bf10: 0x10820011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18bf58;
    }
    // 0x18bf18: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18bf30;
    }
    // 0x18bf20: 0x1082000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18bf4c;
    }
    // 0x18bf28: 0x1000001a
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF94; return;
    }
label_18bf30:
    // 0x18bf30: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18bf34: 0x1082000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_18bf64;
    }
    // 0x18bf3c: 0x1082000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18BF7C; return;
    }
    // 0x18bf44: 0x10000013
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF94; return;
    }
label_18bf4c:
    // 0x18bf4c: 0x24a4ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967144));
    // 0x18bf50: 0x10000006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bf6c;
    }
label_18bf58:
    // 0x18bf58: 0x24a4ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967144));
    // 0x18bf5c: 0x10000003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18bf6c;
    }
label_18bf64:
    // 0x18bf64: 0x24a4ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967144));
    // 0x18bf68: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
label_18bf6c:
    // 0x18bf6c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x18bf74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_18bf74
// Address: 0x18bf74 - 0x18bf8c

void entry_18bf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bf74) {
        switch (ctx->pc) {
            case 0x18bf7c: ctx->pc = 0; goto label_18bf7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bf74: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18BF90; return;
    }
label_18bf7c:
    // 0x18bf7c: 0x24a4ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967144));
    // 0x18bf80: 0x2406000a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 10));
    // 0x18bf84: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x18bf8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_18bf8c
// Address: 0x18bf8c - 0x18bfa8

void entry_18bf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18bf8c) {
        switch (ctx->pc) {
            case 0x18bf90: ctx->pc = 0; goto label_18bf90;
            case 0x18bf94: ctx->pc = 0; goto label_18bf94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18bf8c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_18bf90:
    // 0x18bf90: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_18bf94:
    // 0x18bf94: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18bf98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18bf9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18bfa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18bfa8; return;
}


// Function: CompareSaves__FP4SAVET0
// Address: 0x18bfa8 - 0x18c028

void FUN_0018c028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c028) {
        switch (ctx->pc) {
            case 0x18c068: ctx->pc = 0; goto label_18c068;
            case 0x18c08c: ctx->pc = 0; goto label_18c08c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c028: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x18c02c: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x18c030: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18c034: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18c038: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x18c03c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c040: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x18c044: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x18c048: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18c04c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18c050: 0xe7b40070
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x18c054: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x18c058: 0x1262003d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18C150; return;
    }
    // 0x18c060: 0x50430001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 20296), GPR_U32(ctx, 0));
        goto label_18c068;
    }
label_18c068:
    // 0x18c068: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18c06c: 0x12620012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 4));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x18C0B8; return;
    }
    // 0x18c074: 0x14400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c08c;
    }
    // 0x18c07c: 0x12630017
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x18C0DC; return;
    }
    // 0x18c084: 0x1000002f
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C144; return;
    }
label_18c08c:
    // 0x18c08c: 0x1040002c
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C140; return;
    }
    // 0x18c094: 0x660002a
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    if (GPR_S32(ctx, 19) < 0) {
        ctx->pc = 0x18C140; return;
    }
    // 0x18c09c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18c0a0: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x18c0a4: 0x24a5d0a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294955168));
    // 0x18c0a8: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x18c0b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_18c0b0
// Address: 0x18c0b0 - 0x18c0d4

void entry_18c0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c0b0) {
        switch (ctx->pc) {
            case 0x18c0b8: ctx->pc = 0; goto label_18c0b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c0b0: 0x10000024
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C144; return;
    }
label_18c0b8:
    // 0x18c0b8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18c0bc: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x18c0c0: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x18c0c4: 0x24a5c420
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951968));
    // 0x18c0c8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18c0cc: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x18c0d4);
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_18c0d4
// Address: 0x18c0d4 - 0x18c118

void entry_18c0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c0d4) {
        switch (ctx->pc) {
            case 0x18c0dc: ctx->pc = 0; goto label_18c0dc;
            case 0x18c0f8: ctx->pc = 0; goto label_18c0f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c0d4: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C144; return;
    }
label_18c0dc:
    // 0x18c0dc: 0x26420030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 48));
    // 0x18c0e0: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x18c0e4: 0xae424f48
    WRITE32(ADD32(GPR_U32(ctx, 18), 20296), GPR_U32(ctx, 2));
    // 0x18c0e8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c0ec: 0x26511a30
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 6704));
    // 0x18c0f0: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18c0f4: 0x0
    // NOP
label_18c0f8:
    // 0x18c0f8: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x18c0fc: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18c100: 0x0
    // NOP
    // 0x18c104: 0x45010008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x18C128; return;
    }
    // 0x18c10c: 0x8e444f48
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20296)));
    // 0x18c110: 0xc062fea
    SET_GPR_U32(ctx, 31, 0x18c118);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6656));
    CompareSaves__FP4SAVET0(rdram, ctx, runtime); return;
}


// Function: entry_18c118
// Address: 0x18c118 - 0x18c130

void entry_18c118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c118) {
        switch (ctx->pc) {
            case 0x18c128: ctx->pc = 0; goto label_18c128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c118: 0x4420005
    if (GPR_S32(ctx, 2) < 0) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 20296), GPR_U32(ctx, 16));
        entry_18c130(rdram, ctx, runtime); return;
    }
    // 0x18c120: 0x10000004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6748));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C134; return;
    }
label_18c128:
    // 0x18c128: 0xc05817a
    SET_GPR_U32(ctx, 31, 0x18c130);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitGameState__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_18c130
// Address: 0x18c130 - 0x18c178

void entry_18c130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c130) {
        switch (ctx->pc) {
            case 0x18c134: ctx->pc = 0; goto label_18c134;
            case 0x18c140: ctx->pc = 0; goto label_18c140;
            case 0x18c144: ctx->pc = 0; goto label_18c144;
            case 0x18c150: ctx->pc = 0; goto label_18c150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c130: 0x26311a5c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6748));
label_18c134:
    // 0x18c134: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x18c138: 0x681ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6748));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x18C0F8; return;
    }
label_18c140:
    // 0x18c140: 0xae53000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 19));
label_18c144:
    // 0x18c144: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x18c148: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x18c14c: 0xe6400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
label_18c150:
    // 0x18c150: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18c154: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c158: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18c15c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18c160: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18c164: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18c168: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18c16c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x18c170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018c178_FP4SAVEi
// Address: 0x18c178 - 0x18c1a8

void FUN_0018c178_FP4SAVEi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c178) {
        switch (ctx->pc) {
            case 0x18c18c: ctx->pc = 0; goto label_18c18c;
            case 0x18c19c: ctx->pc = 0; goto label_18c19c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c178: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x18c17c: 0x10a20007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_18c19c;
    }
    // 0x18c184: 0x50a20001
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 20292), GPR_U32(ctx, 0));
        goto label_18c18c;
    }
label_18c18c:
    // 0x18c18c: 0xac850018
    WRITE32(ADD32(GPR_U32(ctx, 4), 24), GPR_U32(ctx, 5));
    // 0x18c190: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18c194: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x18c198: 0xe480001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 28), *(uint32_t*)&val); }
label_18c19c:
    // 0x18c19c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c1a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c1a8; return;
}


// Function: FUN_0018c1a8
// Address: 0x18c1a8 - 0x18c1bc

void FUN_0018c1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c1a8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18c1ac: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18c1b0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18c1b4: 0xc06347e
    SET_GPR_U32(ctx, 31, 0x18c1bc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    FUN_0018d1f8(rdram, ctx, runtime); return;
}


// Function: entry_18c1bc
// Address: 0x18c1bc - 0x18c1e8

void entry_18c1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c1bc) {
        switch (ctx->pc) {
            case 0x18c1cc: ctx->pc = 0; goto label_18c1cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c1bc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c1c0: 0x10600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18c1cc;
    }
    // 0x18c1c8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_18c1cc:
    // 0x18c1cc: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x18c1d0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18c1d4: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18c1d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18c1dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c1e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c1e8; return;
}


// Function: FUN_0018c1e8
// Address: 0x18c1e8 - 0x18c200

void FUN_0018c1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c1e8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18c1ec: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x18c1f0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c1f4: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18c1f8: 0xc063504
    SET_GPR_U32(ctx, 31, 0x18c200);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_18c200
// Address: 0x18c200 - 0x18c240

void entry_18c200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c200) {
        switch (ctx->pc) {
            case 0x18c210: ctx->pc = 0; goto label_18c210;
            case 0x18c230: ctx->pc = 0; goto label_18c230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c200: 0x56000003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_18c210;
    }
    // 0x18c208: 0x10000009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18c230;
    }
label_18c210:
    // 0x18c210: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x18c214: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x18c218: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18c21c: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18c220: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18c224: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x18c228: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x18c22c: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_18c230:
    // 0x18c230: 0x10600003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_18c240(rdram, ctx, runtime); return;
    }
    // 0x18c238: 0xc0501e8
    SET_GPR_U32(ctx, 31, 0x18c240);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_001407A0__FPUi(rdram, ctx, runtime); return;
}


// Function: entry_18c240
// Address: 0x18c240 - 0x18c250

void entry_18c240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c240: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18c244: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18c248: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018c250
// Address: 0x18c250 - 0x18c28c

void FUN_0018c250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c250: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x18c254: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x18c258: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x18c25c: 0x24c6b340
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947648));
    // 0x18c260: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x18c264: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c268: 0x7fb600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 22));
    // 0x18c26c: 0x7fb500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 21));
    // 0x18c270: 0x7fb400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 20));
    // 0x18c274: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x18c278: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x18c27c: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x18c280: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x18c284: 0xc08281e
    SET_GPR_U32(ctx, 31, 0x18c28c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    FUN_0020a078(rdram, ctx, runtime); return;
}


// Function: entry_18c28c
// Address: 0x18c28c - 0x18c29c

void entry_18c28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c28c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c290: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x18c294: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18c29c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18c29c
// Address: 0x18c29c - 0x18c2c4

void entry_18c29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c29c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c2a0: 0x14600055
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F8; return;
    }
    // 0x18c2a8: 0x8fa30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c2ac: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18c2b0: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18c2b4: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x18c2b8: 0x43800a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    // 0x18c2bc: 0xc06307a
    SET_GPR_U32(ctx, 31, 0x18c2c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935664));
    FUN_0018c1e8(rdram, ctx, runtime); return;
}


// Function: entry_18c2c4
// Address: 0x18c2c4 - 0x18c30c

void entry_18c2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c2c4: 0x26100005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 5));
    // 0x18c2c8: 0x244503ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 1023));
    // 0x18c2cc: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18c2d0: 0x244207fe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2046));
    // 0x18c2d4: 0x65182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x18c2d8: 0xa3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 5));
    // 0x18c2dc: 0x8e640028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 40)));
    // 0x18c2e0: 0x21283
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 10));
    // 0x18c2e4: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x18c2e8: 0x26100015
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 21));
    // 0x18c2ec: 0x90202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    // 0x18c2f0: 0x14800040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F4; return;
    }
    // 0x18c2f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18c2fc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18c300: 0x2450b348
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294947656));
    // 0x18c304: 0xc06348a
    SET_GPR_U32(ctx, 31, 0x18c30c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0018d228(rdram, ctx, runtime); return;
}


// Function: entry_18c30c
// Address: 0x18c30c - 0x18c338

void entry_18c30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c30c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c310: 0x14600038
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F4; return;
    }
    // 0x18c318: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18c31c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18c320: 0x2451b390
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294947728));
    // 0x18c324: 0x24a5b360
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294947680));
    // 0x18c328: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18c32c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c330: 0xc0634da
    SET_GPR_U32(ctx, 31, 0x18c338);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 10));
    FUN_0018d368(rdram, ctx, runtime); return;
}


// Function: entry_18c338
// Address: 0x18c338 - 0x18c354

void entry_18c338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c338: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c33c: 0x1460002d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F4; return;
    }
    // 0x18c344: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c348: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18c34c: 0xc063284
    SET_GPR_U32(ctx, 31, 0x18c354);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0018ca10(rdram, ctx, runtime); return;
}


// Function: entry_18c354
// Address: 0x18c354 - 0x18c36c

void entry_18c354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c354: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c358: 0x14600026
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F4; return;
    }
    // 0x18c360: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c364: 0xc0632fe
    SET_GPR_U32(ctx, 31, 0x18c36c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    calls_wac_related_notcalled(rdram, ctx, runtime); return;
}


// Function: entry_18c36c
// Address: 0x18c36c - 0x18c3ac

void entry_18c36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c36c) {
        switch (ctx->pc) {
            case 0x18c390: ctx->pc = 0; goto label_18c390;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c36c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c370: 0x14600020
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C3F4; return;
    }
    // 0x18c378: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18c37c: 0x3c160025
    SET_GPR_U32(ctx, 22, ((uint32_t)37 << 16));
    // 0x18c380: 0x3c150025
    SET_GPR_U32(ctx, 21, ((uint32_t)37 << 16));
    // 0x18c384: 0x3c140025
    SET_GPR_U32(ctx, 20, ((uint32_t)37 << 16));
    // 0x18c388: 0x26721a30
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 6704));
    // 0x18c38c: 0x26710030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 48));
label_18c390:
    // 0x18c390: 0x25100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 8), 1));
    // 0x18c394: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c398: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c39c: 0x26c5b3a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 4294947744));
    // 0x18c3a0: 0x26a6b3b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 21), 4294947760));
    // 0x18c3a4: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18c3ac);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 4294947784));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18c3ac
// Address: 0x18c3ac - 0x18c3c0

void entry_18c3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c3ac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18c3b0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c3b4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c3b8: 0xc06340a
    SET_GPR_U32(ctx, 31, 0x18c3c0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0018d028(rdram, ctx, runtime); return;
}


// Function: entry_18c3c0
// Address: 0x18c3c0 - 0x18c420

void entry_18c3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c3c0) {
        switch (ctx->pc) {
            case 0x18c3f0: ctx->pc = 0; goto label_18c3f0;
            case 0x18c3f4: ctx->pc = 0; goto label_18c3f4;
            case 0x18c3f8: ctx->pc = 0; goto label_18c3f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c3c0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c3c4: 0x1460000a
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 6748));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_18c3f0;
    }
    // 0x18c3cc: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c3d0: 0x29020003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), 3));
    // 0x18c3d4: 0x1440ffee
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6748));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C390; return;
    }
    // 0x18c3dc: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x18c3e0: 0x28420005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 5));
    // 0x18c3e4: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18c3f0;
    }
    // 0x18c3ec: 0xae620014
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 2));
label_18c3f0:
    // 0x18c3f0: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_18c3f4:
    // 0x18c3f4: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_18c3f8:
    // 0x18c3f8: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18c3fc: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x18c400: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18c404: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18c408: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18c40c: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18c410: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18c414: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c41c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c420; return;
}


// Function: FUN_0018c420
// Address: 0x18c420 - 0x18c46c

void FUN_0018c420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c420: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x18c424: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x18c428: 0x7fb400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 20));
    // 0x18c42c: 0x24c6b348
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947656));
    // 0x18c430: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x18c434: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18c438: 0x7fbf00e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 31));
    // 0x18c43c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c440: 0x7fb700d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 23));
    // 0x18c444: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18c448: 0x7fb600c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 22));
    // 0x18c44c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18c450: 0x7fb500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 21));
    // 0x18c454: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x18c458: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x18c45c: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x18c460: 0x8e640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x18c464: 0xc082792
    SET_GPR_U32(ctx, 31, 0x18c46c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    FUN_00209e48(rdram, ctx, runtime); return;
}


// Function: entry_18c46c
// Address: 0x18c46c - 0x18c47c

void entry_18c46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c46c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c470: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x18c474: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18c47c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18c47c
// Address: 0x18c47c - 0x18c494

void entry_18c47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c47c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c480: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c484: 0x1c40000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x18C4B8; return;
    }
    // 0x18c48c: 0xc06345a
    SET_GPR_U32(ctx, 31, 0x18c494);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 84));
    FUN_0018d168(rdram, ctx, runtime); return;
}


// Function: entry_18c494
// Address: 0x18c494 - 0x18c4f0

void entry_18c494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c494) {
        switch (ctx->pc) {
            case 0x18c4b8: ctx->pc = 0; goto label_18c4b8;
            case 0x18c4d8: ctx->pc = 0; goto label_18c4d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c494: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x18c498: 0x3402c3ff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 50175));
    // 0x18c49c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x18c4a0: 0x54400025
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
        ctx->pc = 0x18C538; return;
    }
    // 0x18c4a8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x18c4ac: 0xae620014
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 2));
    // 0x18c4b0: 0x10000021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C538; return;
    }
label_18c4b8:
    // 0x18c4b8: 0x1680001e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C534; return;
    }
    // 0x18c4c0: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x18c4c4: 0x3c160025
    SET_GPR_U32(ctx, 22, ((uint32_t)37 << 16));
    // 0x18c4c8: 0x3c150025
    SET_GPR_U32(ctx, 21, ((uint32_t)37 << 16));
    // 0x18c4cc: 0x26721a30
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 6704));
    // 0x18c4d0: 0x26710030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 48));
    // 0x18c4d4: 0x24700001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 1));
label_18c4d8:
    // 0x18c4d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c4dc: 0x26e5b3a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 23), 4294947744));
    // 0x18c4e0: 0x26c6b3b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 22), 4294947760));
    // 0x18c4e4: 0x26a7b3c8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 4294947784));
    // 0x18c4e8: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18c4f0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18c4f0
// Address: 0x18c4f0 - 0x18c504

void entry_18c4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c4f0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c4f4: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18c4f8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18c4fc: 0xc063376
    SET_GPR_U32(ctx, 31, 0x18c504);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_0018cdd8(rdram, ctx, runtime); return;
}


// Function: entry_18c504
// Address: 0x18c504 - 0x18c568

void entry_18c504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c504) {
        switch (ctx->pc) {
            case 0x18c534: ctx->pc = 0; goto label_18c534;
            case 0x18c538: ctx->pc = 0; goto label_18c538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c504: 0x26521a5c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 6748));
    // 0x18c508: 0x26311a5c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6748));
    // 0x18c50c: 0x16800009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        goto label_18c534;
    }
    // 0x18c514: 0x2a020003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 3));
    // 0x18c518: 0x1440ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C4D8; return;
    }
    // 0x18c520: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x18c524: 0x28420005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 5));
    // 0x18c528: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18c534;
    }
    // 0x18c530: 0xae620014
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 2));
label_18c534:
    // 0x18c534: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_18c538:
    // 0x18c538: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x18c53c: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18c540: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18c544: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x18c548: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18c54c: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18c550: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18c554: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18c558: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18c55c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c564: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c568; return;
}


// Function: FUN_0018c568
// Address: 0x18c568 - 0x18c628

void FUN_0018c568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c568) {
        switch (ctx->pc) {
            case 0x18c584: ctx->pc = 0; goto label_18c584;
            case 0x18c5a0: ctx->pc = 0; goto label_18c5a0;
            case 0x18c5f4: ctx->pc = 0; goto label_18c5f4;
            case 0x18c620: ctx->pc = 0; goto label_18c620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c568: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18c56c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18c570: 0x8c824f44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 20292)));
    // 0x18c574: 0x14400003
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c584;
    }
    // 0x18c57c: 0x1000002b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C62C; return;
    }
label_18c584:
    // 0x18c584: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c588: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18c58c: 0x8c6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x18c590: 0x831025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x18c594: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x18c598: 0x10400016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 6656));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18c5f4;
    }
label_18c5a0:
    // 0x18c5a0: 0x68860007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x18c5a4: 0x6c860000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x18c5a8: 0x6887000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x18c5ac: 0x6c870008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x18c5b0: 0x68880017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18c5b4: 0x6c880010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18c5b8: 0x6889001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x18c5bc: 0x6c890018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x18c5c0: 0xb0660007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5c4: 0xb4660000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5c8: 0xb067000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5cc: 0xb4670008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5d0: 0xb0680017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5d4: 0xb4680010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5d8: 0xb069001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5dc: 0xb4690018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c5e0: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x18c5e4: 0x1482ffee
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_18c5a0;
    }
    // 0x18c5ec: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18c620;
    }
label_18c5f4:
    // 0x18c5f4: 0xdc860000
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18c5f8: 0xdc870008
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18c5fc: 0xdc880010
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x18c600: 0xdc890018
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x18c604: 0xfc660000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 6));
    // 0x18c608: 0xfc670008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 7));
    // 0x18c60c: 0xfc680010
    WRITE64(ADD32(GPR_U32(ctx, 3), 16), GPR_U64(ctx, 8));
    // 0x18c610: 0xfc690018
    WRITE64(ADD32(GPR_U32(ctx, 3), 24), GPR_U64(ctx, 9));
    // 0x18c614: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x18c618: 0x1482fff6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_18c5f4;
    }
label_18c620:
    // 0x18c620: 0xc069fa4
    SET_GPR_U32(ctx, 31, 0x18c628);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 9152)));
    FUN_001A7E90(rdram, ctx, runtime); return;
}


// Function: entry_18c628
// Address: 0x18c628 - 0x18c638

void entry_18c628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c628) {
        switch (ctx->pc) {
            case 0x18c62c: ctx->pc = 0; goto label_18c62c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c628: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18c62c:
    // 0x18c62c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18c630: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018c638
// Address: 0x18c638 - 0x18c668

void FUN_0018c638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c638) {
        switch (ctx->pc) {
            case 0x18c660: ctx->pc = 0; goto label_18c660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c638: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x18c63c: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x18c640: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x18c644: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c648: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x18c64c: 0x8e224f44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20292)));
    // 0x18c650: 0x14400003
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c660;
    }
    // 0x18c658: 0x10000040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18c75c(rdram, ctx, runtime); return;
    }
label_18c660:
    // 0x18c660: 0xc069fa4
    SET_GPR_U32(ctx, 31, 0x18c668);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9152)));
    FUN_001A7E90(rdram, ctx, runtime); return;
}


// Function: entry_18c668
// Address: 0x18c668 - 0x18c74c

void entry_18c668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c668) {
        switch (ctx->pc) {
            case 0x18c68c: ctx->pc = 0; goto label_18c68c;
            case 0x18c6e0: ctx->pc = 0; goto label_18c6e0;
            case 0x18c6ec: ctx->pc = 0; goto label_18c6ec;
            case 0x18c71c: ctx->pc = 0; goto label_18c71c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c668: 0x8e0323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9152)));
    // 0x18c66c: 0x8e244f44
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20292)));
    // 0x18c670: 0x641025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18c674: 0x30420007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 7));
    // 0x18c678: 0x10400019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6656));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18c6e0;
    }
    // 0x18c680: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18c684: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x18c688: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
label_18c68c:
    // 0x18c68c: 0x68680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18c690: 0x6c680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18c694: 0x6869000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x18c698: 0x6c690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x18c69c: 0x686a0017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x18c6a0: 0x6c6a0010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 10, (GPR_U64(ctx, 10) & ~mask) | (aligned_data & mask)); }
    // 0x18c6a4: 0x686b001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 11, (GPR_U64(ctx, 11) & ~mask) | (aligned_data & mask)); }
    // 0x18c6a8: 0x6c6b0018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 11, (GPR_U64(ctx, 11) & ~mask) | (aligned_data & mask)); }
    // 0x18c6ac: 0xb0880007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6b0: 0xb4880000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6b4: 0xb089000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6b8: 0xb4890008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6bc: 0xb08a0017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6c0: 0xb48a0010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 10) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6c4: 0xb08b001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 11) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6c8: 0xb48b0018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 11) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18c6cc: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x18c6d0: 0x1462ffee
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_18c68c;
    }
    // 0x18c6d8: 0x10000010
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 20292)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18c71c;
    }
label_18c6e0:
    // 0x18c6e0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18c6e4: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x18c6e8: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
label_18c6ec:
    // 0x18c6ec: 0xdc680000
    SET_GPR_U64(ctx, 8, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18c6f0: 0xdc690008
    SET_GPR_U64(ctx, 9, READ64(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x18c6f4: 0xdc6a0010
    SET_GPR_U64(ctx, 10, READ64(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x18c6f8: 0xdc6b0018
    SET_GPR_U64(ctx, 11, READ64(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x18c6fc: 0xfc880000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 8));
    // 0x18c700: 0xfc890008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 9));
    // 0x18c704: 0xfc8a0010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 10));
    // 0x18c708: 0xfc8b0018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 11));
    // 0x18c70c: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x18c710: 0x1462fff6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_18c6ec;
    }
    // 0x18c718: 0x8e284f44
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 20292)));
label_18c71c:
    // 0x18c71c: 0x3c0226ff
    SET_GPR_U32(ctx, 2, ((uint32_t)9983 << 16));
    // 0x18c720: 0x3442d927
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 55591));
    // 0x18c724: 0x24a5b3a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294947744));
    // 0x18c728: 0x2508ffd0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967248));
    // 0x18c72c: 0x24c6b3b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947760));
    // 0x18c730: 0x1114023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 8), GPR_U32(ctx, 17)));
    // 0x18c734: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c738: 0x1024018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18c73c: 0x24e7b3c8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294947784));
    // 0x18c740: 0x84083
    SET_GPR_S32(ctx, 8, SRA32(GPR_S32(ctx, 8), 2));
    // 0x18c744: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18c74c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18c74c
// Address: 0x18c74c - 0x18c75c

void entry_18c74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c74c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c750: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c754: 0xc0633f0
    SET_GPR_U32(ctx, 31, 0x18c75c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 20292)));
    FUN_0018cfc0(rdram, ctx, runtime); return;
}


// Function: entry_18c75c
// Address: 0x18c75c - 0x18c770

void entry_18c75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c75c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18c760: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18c764: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c768: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018c770
// Address: 0x18c770 - 0x18c7c4

void FUN_0018c770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c770: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x18c774: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x18c778: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x18c77c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c780: 0x8e084f4c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 20300)));
    // 0x18c784: 0x11000016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967248));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C7E0; return;
    }
    // 0x18c78c: 0x3c0226ff
    SET_GPR_U32(ctx, 2, ((uint32_t)9983 << 16));
    // 0x18c790: 0x1104023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 8), GPR_U32(ctx, 16)));
    // 0x18c794: 0x3442d927
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 55591));
    // 0x18c798: 0x1024018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18c79c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18c7a0: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x18c7a4: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x18c7a8: 0x24a5b3a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294947744));
    // 0x18c7ac: 0x24c6b3b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294947760));
    // 0x18c7b0: 0x24e7b3c8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294947784));
    // 0x18c7b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c7b8: 0x84083
    SET_GPR_S32(ctx, 8, SRA32(GPR_S32(ctx, 8), 2));
    // 0x18c7bc: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18c7c4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18c7c4
// Address: 0x18c7c4 - 0x18c7d8

void entry_18c7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c7c4: 0x8e064f4c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20300)));
    // 0x18c7c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c7cc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18c7d0: 0xc06340a
    SET_GPR_U32(ctx, 31, 0x18c7d8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 6656));
    FUN_0018d028(rdram, ctx, runtime); return;
}


// Function: entry_18c7d8
// Address: 0x18c7d8 - 0x18c7f8

void entry_18c7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c7d8) {
        switch (ctx->pc) {
            case 0x18c7e0: ctx->pc = 0; goto label_18c7e0;
            case 0x18c7e8: ctx->pc = 0; goto label_18c7e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c7d8: 0x10000003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18c7e8;
    }
label_18c7e0:
    // 0x18c7e0: 0x2402002c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
    // 0x18c7e4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_18c7e8:
    // 0x18c7e8: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c7ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c7f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c7f8; return;
}


// Function: FUN_0018c7f8__FP4SAVE
// Address: 0x18c7f8 - 0x18c840

void FUN_0018c7f8__FP4SAVE(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c7f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18c7fc: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c800: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18c804: 0x8cc24f44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 20292)));
    // 0x18c808: 0x1040001b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18c878(rdram, ctx, runtime); return;
    }
    // 0x18c810: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x18c814: 0x8c8319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x18c818: 0x30630100
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 256));
    // 0x18c81c: 0x1460000a
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C848; return;
    }
    // 0x18c824: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18c828: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18c82c: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x18c830: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18c834: 0xac82027c
    WRITE32(ADD32(GPR_U32(ctx, 4), 636), GPR_U32(ctx, 2));
    // 0x18c838: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x18c840);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_18c840
// Address: 0x18c840 - 0x18c858

void entry_18c840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c840) {
        switch (ctx->pc) {
            case 0x18c848: ctx->pc = 0; goto label_18c848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c840: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C87C; return;
    }
label_18c848:
    // 0x18c848: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x18c84c: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x18c850: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x18c858);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952504));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_18c858
// Address: 0x18c858 - 0x18c878

void entry_18c858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c858: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x18c85c: 0x24a43eb0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 16048));
    // 0x18c860: 0xa8800263
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 611); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18c864: 0xb8800260
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 608); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18c868: 0x8ca23eb0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16048)));
    // 0x18c86c: 0x8c430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x18c870: 0x60f809
    SET_GPR_U32(ctx, 31, 0x18c878);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_18c878
// Address: 0x18c878 - 0x18c888

void entry_18c878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c878) {
        switch (ctx->pc) {
            case 0x18c87c: ctx->pc = 0; goto label_18c87c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c878: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_18c87c:
    // 0x18c87c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18c888; return;
}


// Function: FUN_0018c888
// Address: 0x18c888 - 0x18c8e0

void FUN_0018c888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c888) {
        switch (ctx->pc) {
            case 0x18c8d0: ctx->pc = 0; goto label_18c8d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c888: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x18c88c: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x18c890: 0x7fb60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 22));
    // 0x18c894: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18c898: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x18c89c: 0xe0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18c8a0: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x18c8a4: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18c8a8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18c8ac: 0x100982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x18c8b0: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x18c8b4: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18c8b8: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18c8bc: 0x2a820013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 19));
    // 0x18c8c0: 0x14400003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c8d0;
    }
    // 0x18c8c8: 0x10000033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 37));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C998; return;
    }
label_18c8d0:
    // 0x18c8d0: 0x1200000e
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C90C; return;
    }
    // 0x18c8d8: 0xc078840
    SET_GPR_U32(ctx, 31, 0x18c8e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_18c8e0
// Address: 0x18c8e0 - 0x18c904

void entry_18c8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c8e0) {
        switch (ctx->pc) {
            case 0x18c8f4: ctx->pc = 0; goto label_18c8f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c8e0: 0x2c420041
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 65));
    // 0x18c8e4: 0x14400003
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c8f4;
    }
    // 0x18c8ec: 0x1000002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C998; return;
    }
label_18c8f4:
    // 0x18c8f4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c8f8: 0x2484e9c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961600));
    // 0x18c8fc: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x18c904);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_18c904
// Address: 0x18c904 - 0x18c92c

void entry_18c904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c904) {
        switch (ctx->pc) {
            case 0x18c90c: ctx->pc = 0; goto label_18c90c;
            case 0x18c918: ctx->pc = 0; goto label_18c918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c904: 0x10000004
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18c918;
    }
label_18c90c:
    // 0x18c90c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18c910: 0x2450e9c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294961600));
    // 0x18c914: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
label_18c918:
    // 0x18c918: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18c91c: 0x2452e540
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 4294960448));
    // 0x18c920: 0x24060480
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1152));
    // 0x18c924: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18c92c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18c92c
// Address: 0x18c92c - 0x18c948

void entry_18c92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c92c: 0x8ea50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    // 0x18c930: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18c934: 0x8ea40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x18c938: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18c93c: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18c940: 0xc082792
    SET_GPR_U32(ctx, 31, 0x18c948);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00209e48(rdram, ctx, runtime); return;
}


// Function: entry_18c948
// Address: 0x18c948 - 0x18c958

void entry_18c948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c948: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18c94c: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x18c950: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18c958);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18c958
// Address: 0x18c958 - 0x18c97c

void entry_18c958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c958) {
        switch (ctx->pc) {
            case 0x18c970: ctx->pc = 0; goto label_18c970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c958: 0x14400010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C99C; return;
    }
    // 0x18c960: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x18c964: 0x1840000b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x18C994; return;
    }
    // 0x18c96c: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_18c970:
    // 0x18c970: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18c974: 0xc062de0
    SET_GPR_U32(ctx, 31, 0x18c97c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0018b780(rdram, ctx, runtime); return;
}


// Function: entry_18c97c
// Address: 0x18c97c - 0x18c9c0

void entry_18c97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c97c) {
        switch (ctx->pc) {
            case 0x18c994: ctx->pc = 0; goto label_18c994;
            case 0x18c998: ctx->pc = 0; goto label_18c998;
            case 0x18c99c: ctx->pc = 0; goto label_18c99c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c97c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x18c980: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x18c984: 0x2610005c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 92));
    // 0x18c988: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x18c98c: 0x1440fff8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18C970; return;
    }
label_18c994:
    // 0x18c994: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18c998:
    // 0x18c998: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_18c99c:
    // 0x18c99c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18c9a0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18c9a4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18c9a8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18c9ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18c9b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18c9b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18c9b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018c9c0
// Address: 0x18c9c0 - 0x18c9d8

void FUN_0018c9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18c9c0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18c9c4: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18c9c8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18c9cc: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18c9d0: 0xc063222
    SET_GPR_U32(ctx, 31, 0x18c9d8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_0018c888(rdram, ctx, runtime); return;
}


// Function: entry_18c9d8
// Address: 0x18c9d8 - 0x18ca10

void entry_18c9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18c9d8) {
        switch (ctx->pc) {
            case 0x18c9f0: ctx->pc = 0; goto label_18c9f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18c9d8: 0x14400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18c9f0;
    }
    // 0x18c9e0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18c9e4: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    // 0x18c9e8: 0x38630001
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 1));
    // 0x18c9ec: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
label_18c9f0:
    // 0x18c9f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18c9f8: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18c9fc: 0x0
    // NOP
    // 0x18ca00: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18ca04: 0x0
    // NOP
    // 0x18ca08: 0x27bd00b0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    // 0x18ca0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ca10; return;
}


// Function: FUN_0018ca10
// Address: 0x18ca10 - 0x18ca40

void FUN_0018ca10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ca10: 0x27bdfba0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966176));
    // 0x18ca14: 0x7fb20440
    WRITE128(ADD32(GPR_U32(ctx, 29), 1088), GPR_VEC(ctx, 18));
    // 0x18ca18: 0x7fb10430
    WRITE128(ADD32(GPR_U32(ctx, 29), 1072), GPR_VEC(ctx, 17));
    // 0x18ca1c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18ca20: 0x7fb00420
    WRITE128(ADD32(GPR_U32(ctx, 29), 1056), GPR_VEC(ctx, 16));
    // 0x18ca24: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18ca28: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18ca2c: 0x7fbf0450
    WRITE128(ADD32(GPR_U32(ctx, 29), 1104), GPR_VEC(ctx, 31));
    // 0x18ca30: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ca34: 0x240603c4
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 964));
    // 0x18ca38: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18ca40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18ca40
// Address: 0x18ca40 - 0x18cb6c

void entry_18ca40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ca40: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x18ca44: 0x3c013ef5
    SET_GPR_U32(ctx, 1, ((uint32_t)16117 << 16));
    // 0x18ca48: 0x3421c28f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49807));
    // 0x18ca4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18ca50: 0x2462b3d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294947792));
    // 0x18ca54: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x18ca58: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18ca5c: 0x90470004
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x18ca60: 0x240900ff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 255));
    // 0x18ca64: 0x3c013e0f
    SET_GPR_U32(ctx, 1, ((uint32_t)15887 << 16));
    // 0x18ca68: 0x34215c29
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 23593));
    // 0x18ca6c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18ca70: 0x240a0029
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 41));
    // 0x18ca74: 0x8c66b3d0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 4294947792)));
    // 0x18ca78: 0x2408006f
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 111));
    // 0x18ca7c: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x18ca80: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x18ca84: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x18ca88: 0x3c013ea8
    SET_GPR_U32(ctx, 1, ((uint32_t)16040 << 16));
    // 0x18ca8c: 0x3421f5c3
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 62915));
    // 0x18ca90: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x18ca94: 0x240b0087
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 135));
    // 0x18ca98: 0x3c01becc
    SET_GPR_U32(ctx, 1, ((uint32_t)48844 << 16));
    // 0x18ca9c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x18caa0: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x18caa4: 0x24020060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    // 0x18caa8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x18caac: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x18cab0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x18cab4: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x18cab8: 0x3c013cf5
    SET_GPR_U32(ctx, 1, ((uint32_t)15605 << 16));
    // 0x18cabc: 0x3421c28f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49807));
    // 0x18cac0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x18cac4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cac8: 0xe7a00088
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x18cacc: 0xa7a30006
    WRITE16(ADD32(GPR_U32(ctx, 29), 6), (uint16_t)GPR_U32(ctx, 3));
    // 0x18cad0: 0xafa60000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 6));
    // 0x18cad4: 0xafaa0034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 10));
    // 0x18cad8: 0xafa80038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 8));
    // 0x18cadc: 0xafa90048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 9));
    // 0x18cae0: 0xafa90018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 9));
    // 0x18cae4: 0xafaa0024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 10));
    // 0x18cae8: 0xafa80028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 8));
    // 0x18caec: 0xa3a70004
    WRITE8(ADD32(GPR_U32(ctx, 29), 4), (uint8_t)GPR_U32(ctx, 7));
    // 0x18caf0: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x18caf4: 0xafab0044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 11));
    // 0x18caf8: 0xe7a50064
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 100), *(uint32_t*)&val); }
    // 0x18cafc: 0xe7a30068
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x18cb00: 0xe7a60070
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x18cb04: 0xe7a40084
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 132), *(uint32_t*)&val); }
    // 0x18cb08: 0xe7a70098
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 29), 152), *(uint32_t*)&val); }
    // 0x18cb0c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x18cb10: 0xafab0014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 11));
    // 0x18cb14: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    // 0x18cb18: 0xafa00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
    // 0x18cb1c: 0xafa00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 0));
    // 0x18cb20: 0xafa00050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 0));
    // 0x18cb24: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x18cb28: 0xe7a60058
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x18cb2c: 0xe7a10060
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x18cb30: 0xe7a10074
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 116), *(uint32_t*)&val); }
    // 0x18cb34: 0xe7a10078
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 120), *(uint32_t*)&val); }
    // 0x18cb38: 0xe7a20080
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x18cb3c: 0xe7a70090
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x18cb40: 0xafa00094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 0));
    // 0x18cb44: 0x3c013ec2
    SET_GPR_U32(ctx, 1, ((uint32_t)16066 << 16));
    // 0x18cb48: 0x34218f5c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 36700));
    // 0x18cb4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18cb50: 0xe7a200a0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 160), *(uint32_t*)&val); }
    // 0x18cb54: 0xe7a200a4
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 164), *(uint32_t*)&val); }
    // 0x18cb58: 0xe7a000a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 168), *(uint32_t*)&val); }
    // 0x18cb5c: 0xe7a100b8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 184), *(uint32_t*)&val); }
    // 0x18cb60: 0xe7a100b0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x18cb64: 0xc06d710
    SET_GPR_U32(ctx, 31, 0x18cb6c);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    FUN_001b5c40(rdram, ctx, runtime); return;
}


// Function: entry_18cb6c
// Address: 0x18cb6c - 0x18cbcc

void entry_18cb6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cb6c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18cb70: 0x27b003d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 976));
    // 0x18cb74: 0x2446b3d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294947800));
    // 0x18cb78: 0x68c30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x18cb7c: 0x6cc30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x18cb80: 0xb3a3010b
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 267); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cb84: 0xb7a30104
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 260); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cb88: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x18cb8c: 0x2443b3d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294947800));
    // 0x18cb90: 0x68680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18cb94: 0x6c680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18cb98: 0xb3a8014b
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 331); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cb9c: 0xb7a80144
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 324); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cba0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18cba4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18cba8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cbac: 0x2443b3d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294947800));
    // 0x18cbb0: 0x68680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18cbb4: 0x6c680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x18cbb8: 0xb3a8018b
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 395); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cbbc: 0xb7a80184
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 388); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cbc0: 0x24a5b3e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294947808));
    // 0x18cbc4: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18cbcc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294947816));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18cbcc
// Address: 0x18cbcc - 0x18cbe0

void entry_18cbcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cbcc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18cbd0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cbd4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18cbd8: 0xc0634da
    SET_GPR_U32(ctx, 31, 0x18cbe0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 964));
    FUN_0018d368(rdram, ctx, runtime); return;
}


// Function: entry_18cbe0
// Address: 0x18cbe0 - 0x18cbf8

void entry_18cbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cbe0: 0x7bbf0450
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x18cbe4: 0x7bb20440
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x18cbe8: 0x7bb10430
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x18cbec: 0x7bb00420
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x18cbf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1120));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: calls_wac_related_notcalled
// Address: 0x18cbf8 - 0x18cc14

void entry_18cc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cc14: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18cc18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: load_file_from_disc
// Address: 0x18cc20 - 0x18cc58

void entry_18cc58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cc58: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18cc5c: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x18cc60: 0xafa210c0
    WRITE32(ADD32(GPR_U32(ctx, 29), 4288), GPR_U32(ctx, 2));
    // 0x18cc64: 0xc063596
    SET_GPR_U32(ctx, 31, 0x18cc6c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32832));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_18cc6c
// Address: 0x18cc6c - 0x18cc84

void entry_18cc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cc6c: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cc70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cc74: 0x34058040
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32832));
    // 0x18cc78: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18cc7c: 0xc04dca4
    SET_GPR_U32(ctx, 31, 0x18cc84);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    fn___18CBinaryInputStreamPvii(rdram, ctx, runtime); return;
}


// Function: entry_18cc84
// Address: 0x18cc84 - 0x18cc9c

void entry_18cc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cc84: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18cc88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18cc8c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18cc90: 0x24a5b3e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294947808));
    // 0x18cc94: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x18cc9c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_18cc9c
// Address: 0x18cc9c - 0x18ccb0

void entry_18cc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cc9c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18cca0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18cca4: 0x24060202
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 514));
    // 0x18cca8: 0xc06349a
    SET_GPR_U32(ctx, 31, 0x18ccb0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4288));
    FUN_0018d268(rdram, ctx, runtime); return;
}


// Function: entry_18ccb0
// Address: 0x18ccb0 - 0x18ccc4

void entry_18ccb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ccb0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18ccb4: 0x1600003a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CDA0; return;
    }
    // 0x18ccbc: 0xc063504
    SET_GPR_U32(ctx, 31, 0x18ccc4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_18ccc4
// Address: 0x18ccc4 - 0x18cd04

void entry_18ccc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ccc4) {
        switch (ctx->pc) {
            case 0x18ccd4: ctx->pc = 0; goto label_18ccd4;
            case 0x18ccf4: ctx->pc = 0; goto label_18ccf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ccc4: 0x56600003
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        goto label_18ccd4;
    }
    // 0x18cccc: 0x10000009
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18ccf4;
    }
label_18ccd4:
    // 0x18ccd4: 0x8e630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x18ccd8: 0x8e64001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x18ccdc: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x18cce0: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18cce4: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18cce8: 0xafa300b4
    WRITE32(ADD32(GPR_U32(ctx, 29), 180), GPR_U32(ctx, 3));
    // 0x18ccec: 0xafa200b0
    WRITE32(ADD32(GPR_U32(ctx, 29), 176), GPR_U32(ctx, 2));
    // 0x18ccf0: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_18ccf4:
    // 0x18ccf4: 0x10600005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CD0C; return;
    }
    // 0x18ccfc: 0xc04dcec
    SET_GPR_U32(ctx, 31, 0x18cd04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    FOpenFile__18CBinaryInputStreamP13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_18cd04
// Address: 0x18cd04 - 0x18cd48

void entry_18cd04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18cd04) {
        switch (ctx->pc) {
            case 0x18cd0c: ctx->pc = 0; goto label_18cd0c;
            case 0x18cd14: ctx->pc = 0; goto label_18cd14;
            case 0x18cd1c: ctx->pc = 0; goto label_18cd1c;
            case 0x18cd30: ctx->pc = 0; goto label_18cd30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18cd04: 0x14400005
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18cd1c;
    }
label_18cd0c:
    // 0x18cd0c: 0x1000001c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 39));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CD80; return;
    }
label_18cd14:
    // 0x18cd14: 0x1000001a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CD80; return;
    }
label_18cd1c:
    // 0x18cd1c: 0x1a200017
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 4095));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x18CD7C; return;
    }
    // 0x18cd24: 0x27b300c0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 192));
    // 0x18cd28: 0x2d1102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 17)));
    // 0x18cd2c: 0x0
    // NOP
label_18cd30:
    // 0x18cd30: 0x24121000
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4096));
    // 0x18cd34: 0x222900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 17));
    // 0x18cd38: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18cd3c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18cd40: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x18cd48);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_18cd48
// Address: 0x18cd48 - 0x18cd60

void entry_18cd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cd48: 0x8fa510c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4288)));
    // 0x18cd4c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18cd50: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18cd54: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18cd58: 0xc0634ca
    SET_GPR_U32(ctx, 31, 0x18cd60);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 4292));
    FUN_0018d328(rdram, ctx, runtime); return;
}


// Function: entry_18cd60
// Address: 0x18cd60 - 0x18cd88

void entry_18cd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18cd60) {
        switch (ctx->pc) {
            case 0x18cd7c: ctx->pc = 0; goto label_18cd7c;
            case 0x18cd80: ctx->pc = 0; goto label_18cd80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18cd60: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18cd64: 0x16000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4292)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_18cd80;
    }
    // 0x18cd6c: 0x1452ffe9
    SET_GPR_U32(ctx, 17, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x18CD14; return;
    }
    // 0x18cd74: 0x1e20ffee
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 17)));
    if (GPR_S32(ctx, 17) > 0) {
        ctx->pc = 0x18CD30; return;
    }
label_18cd7c:
    // 0x18cd7c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18cd80:
    // 0x18cd80: 0xc04dcf4
    SET_GPR_U32(ctx, 31, 0x18cd88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    Close__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_18cd88
// Address: 0x18cd88 - 0x18cd94

void entry_18cd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cd88: 0x8fa510c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4288)));
    // 0x18cd8c: 0xc0634ac
    SET_GPR_U32(ctx, 31, 0x18cd94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_0018d2b0(rdram, ctx, runtime); return;
}


// Function: entry_18cd94
// Address: 0x18cd94 - 0x18cd9c

void entry_18cd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cd94: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x18cd9c);
    if (GPR_U32(ctx, 16) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18cd9c
// Address: 0x18cd9c - 0x18cda8

void entry_18cd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18cd9c) {
        switch (ctx->pc) {
            case 0x18cda0: ctx->pc = 0; goto label_18cda0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18cd9c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_18cda0:
    // 0x18cda0: 0xc04dcb8
    SET_GPR_U32(ctx, 31, 0x18cda8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x1372e0; return;
}


// Function: entry_18cda8
// Address: 0x18cda8 - 0x18cdd8

void entry_18cda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cda8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cdac: 0x7bbf1140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 4416)));
    // 0x18cdb0: 0x7bb61130
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 4400)));
    // 0x18cdb4: 0x7bb51120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 4384)));
    // 0x18cdb8: 0x7bb41110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 4368)));
    // 0x18cdbc: 0x7bb31100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 4352)));
    // 0x18cdc0: 0x7bb210f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 4336)));
    // 0x18cdc4: 0x7bb110e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 4320)));
    // 0x18cdc8: 0x7bb010d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 4304)));
    // 0x18cdcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4432));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18cdd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18cdd8; return;
}


// Function: FUN_0018cdd8
// Address: 0x18cdd8 - 0x18cdf8

void FUN_0018cdd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cdd8: 0x27bde520
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294960416));
    // 0x18cddc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18cde0: 0x7fb11a80
    WRITE128(ADD32(GPR_U32(ctx, 29), 6784), GPR_VEC(ctx, 17));
    // 0x18cde4: 0x7fb51ac0
    WRITE128(ADD32(GPR_U32(ctx, 29), 6848), GPR_VEC(ctx, 21));
    // 0x18cde8: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18cdec: 0x7fb41ab0
    WRITE128(ADD32(GPR_U32(ctx, 29), 6832), GPR_VEC(ctx, 20));
    // 0x18cdf0: 0xe7880b
    if (GPR_U32(ctx, 7) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 7));
    // 0x18cdf4: 0x7fb21a90
    WRITE128(ADD32(GPR_U32(ctx, 29), 6800), GPR_VEC(ctx, 18));
    // Fall-through to next function
    ctx->pc = 0x18cdf8; return;
}


// Function: load_sly_icon_from_disc
// Address: 0x18cdf8 - 0x18ce24

void entry_18ce24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ce24: 0xc05817a
    SET_GPR_U32(ctx, 31, 0x18ce2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    InitGameState__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_18ce2c
// Address: 0x18ce2c - 0x18ce3c

void entry_18ce2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ce2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18ce30: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18ce34: 0xc063270
    SET_GPR_U32(ctx, 31, 0x18ce3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0018c9c0(rdram, ctx, runtime); return;
}


// Function: entry_18ce3c
// Address: 0x18ce3c - 0x18ce84

void entry_18ce3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ce3c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18ce40: 0x16000056
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 6864)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CF9C; return;
    }
    // 0x18ce48: 0x8e220048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x18ce4c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x18ce50: 0x304200d4
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 212));
    // 0x18ce54: 0x14430051
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x18CF9C; return;
    }
    // 0x18ce5c: 0x8e330044
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 68)));
    // 0x18ce60: 0x24021a00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6656));
    // 0x18ce64: 0x1662004d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18CF9C; return;
    }
    // 0x18ce6c: 0x27a71a60
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 6752));
    // 0x18ce70: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18ce74: 0xe0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18ce78: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18ce7c: 0xc06349a
    SET_GPR_U32(ctx, 31, 0x18ce84);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    FUN_0018d268(rdram, ctx, runtime); return;
}


// Function: entry_18ce84
// Address: 0x18ce84 - 0x18ceac

void entry_18ce84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ce84: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18ce88: 0x16000044
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 6864)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CF9C; return;
    }
    // 0x18ce90: 0x27b10060
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 96));
    // 0x18ce94: 0x8fa51a60
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 6752)));
    // 0x18ce98: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18ce9c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18cea0: 0x24071a00
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 6656));
    // 0x18cea4: 0xc0634ba
    SET_GPR_U32(ctx, 31, 0x18ceac);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 6756));
    FUN_0018d2e8(rdram, ctx, runtime); return;
}


// Function: entry_18ceac
// Address: 0x18ceac - 0x18cee8

void entry_18ceac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ceac: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18ceb0: 0x16000036
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 6752)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18CF8C; return;
    }
    // 0x18ceb8: 0x8fa41a64
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 6756)));
    // 0x18cebc: 0x14930033
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 19)) {
        ctx->pc = 0x18CF8C; return;
    }
    // 0x18cec4: 0x8fa30060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18cec8: 0x24020012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    // 0x18cecc: 0x1462002f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 28));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x18CF8C; return;
    }
    // 0x18ced4: 0x8fa20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    // 0x18ced8: 0x1444002c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x18CF8C; return;
    }
    // 0x18cee0: 0xc058194
    SET_GPR_U32(ctx, 31, 0x18cee8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_00160650(rdram, ctx, runtime); return;
}


// Function: entry_18cee8
// Address: 0x18cee8 - 0x18cf94

void entry_18cee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18cee8) {
        switch (ctx->pc) {
            case 0x18cf04: ctx->pc = 0; goto label_18cf04;
            case 0x18cf58: ctx->pc = 0; goto label_18cf58;
            case 0x18cf88: ctx->pc = 0; goto label_18cf88;
            case 0x18cf8c: ctx->pc = 0; goto label_18cf8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18cee8: 0x8fa30068
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 104)));
    // 0x18ceec: 0x14620026
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 27));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_18cf88;
    }
    // 0x18cef4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18cef8: 0x30820007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 7));
    // 0x18cefc: 0x10400016
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18cf58;
    }
label_18cf04:
    // 0x18cf04: 0x68c20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x18cf08: 0x6cc20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x18cf0c: 0x68c3000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x18cf10: 0x6cc30008
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x18cf14: 0x68c50017
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x18cf18: 0x6cc50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x18cf1c: 0x68c7001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x18cf20: 0x6cc70018
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x18cf24: 0xb0820007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf28: 0xb4820000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf2c: 0xb083000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf30: 0xb4830008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf34: 0xb0850017
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf38: 0xb4850010
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf3c: 0xb087001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf40: 0xb4870018
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x18cf44: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x18cf48: 0x14d4ffee
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 20)) {
        goto label_18cf04;
    }
    // 0x18cf50: 0x1000000d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18cf88;
    }
label_18cf58:
    // 0x18cf58: 0xdcc20000
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x18cf5c: 0xdcc30008
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x18cf60: 0xdcc50010
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x18cf64: 0xdcc70018
    SET_GPR_U64(ctx, 7, READ64(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x18cf68: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x18cf6c: 0xfc830008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 3));
    // 0x18cf70: 0xfc850010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 5));
    // 0x18cf74: 0xfc870018
    WRITE64(ADD32(GPR_U32(ctx, 4), 24), GPR_U64(ctx, 7));
    // 0x18cf78: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x18cf7c: 0x14d4fff6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 20)) {
        goto label_18cf58;
    }
    // 0x18cf84: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18cf88:
    // 0x18cf88: 0x8fa51a60
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 6752)));
label_18cf8c:
    // 0x18cf8c: 0xc0634ac
    SET_GPR_U32(ctx, 31, 0x18cf94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0018d2b0(rdram, ctx, runtime); return;
}


// Function: entry_18cf94
// Address: 0x18cf94 - 0x18cfc0

void entry_18cf94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18cf94) {
        switch (ctx->pc) {
            case 0x18cf9c: ctx->pc = 0; goto label_18cf9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18cf94: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cf98: 0x7bbf1ad0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 6864)));
label_18cf9c:
    // 0x18cf9c: 0x7bb51ac0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 6848)));
    // 0x18cfa0: 0x7bb41ab0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 6832)));
    // 0x18cfa4: 0x7bb31aa0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 6816)));
    // 0x18cfa8: 0x7bb21a90
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 6800)));
    // 0x18cfac: 0x7bb11a80
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 6784)));
    // 0x18cfb0: 0x7bb01a70
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 6768)));
    // 0x18cfb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 6880));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18cfbc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18cfc0; return;
}


// Function: FUN_0018cfc0
// Address: 0x18cfc0 - 0x18cff8

void FUN_0018cfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cfc0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x18cfc4: 0x24031a00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6656));
    // 0x18cfc8: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18cfcc: 0x24020012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    // 0x18cfd0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18cfd4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18cfd8: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18cfdc: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x18cfe0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18cfe4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18cfe8: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x18cfec: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18cff0: 0xc058194
    SET_GPR_U32(ctx, 31, 0x18cff8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    FUN_00160650(rdram, ctx, runtime); return;
}


// Function: entry_18cff8
// Address: 0x18cff8 - 0x18d010

void entry_18cff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18cff8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18cffc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18d000: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d004: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x18d008: 0xc0634da
    SET_GPR_U32(ctx, 31, 0x18d010);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 6656));
    FUN_0018d368(rdram, ctx, runtime); return;
}


// Function: entry_18d010
// Address: 0x18d010 - 0x18d028

void entry_18d010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d010: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18d014: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d018: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d01c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d028
// Address: 0x18d028 - 0x18d058

void FUN_0018d028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d028: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x18d02c: 0x7fb30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 19));
    // 0x18d030: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x18d034: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18d038: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18d03c: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x18d040: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x18d044: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d048: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18d04c: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x18d050: 0xc05817a
    SET_GPR_U32(ctx, 31, 0x18d058);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitGameState__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_18d058
// Address: 0x18d058 - 0x18d06c

void entry_18d058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d058: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d05c: 0x3b1880a
    if (GPR_U32(ctx, 17) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 29));
    // 0x18d060: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18d064: 0xc0633f0
    SET_GPR_U32(ctx, 31, 0x18d06c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0018cfc0(rdram, ctx, runtime); return;
}


// Function: entry_18d06c
// Address: 0x18d06c - 0x18d084

void entry_18d06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d06c: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18D088; return;
    }
    // 0x18d074: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18d078: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18d07c: 0xc063270
    SET_GPR_U32(ctx, 31, 0x18d084);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0018c9c0(rdram, ctx, runtime); return;
}


// Function: entry_18d084
// Address: 0x18d084 - 0x18d0a0

void entry_18d084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d084) {
        switch (ctx->pc) {
            case 0x18d088: ctx->pc = 0; goto label_18d088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d084: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_18d088:
    // 0x18d088: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18d08c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18d090: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18d094: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18d098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d0a0
// Address: 0x18d0a0 - 0x18d0c8

void FUN_0018d0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d0a0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18d0a4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18d0a8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18d0ac: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18d0b0: 0x26070028
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 40));
    // 0x18d0b4: 0x2608002c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 44));
    // 0x18d0b8: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x18d0bc: 0x26060024
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 36));
    // 0x18d0c0: 0xc08272e
    SET_GPR_U32(ctx, 31, 0x18d0c8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    FUN_00209cb8(rdram, ctx, runtime); return;
}


// Function: entry_18d0c8
// Address: 0x18d0c8 - 0x18d0d8

void entry_18d0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d0c8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18d0cc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d0d0: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d0d8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d0d8
// Address: 0x18d0d8 - 0x18d168

void entry_18d0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d0d8) {
        switch (ctx->pc) {
            case 0x18d134: ctx->pc = 0; goto label_18d134;
            case 0x18d138: ctx->pc = 0; goto label_18d138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d0d8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d0dc: 0x2ca2000d
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 13));
    // 0x18d0e0: 0x10400015
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18d138;
    }
    // 0x18d0e8: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x18d0ec: 0x2442b400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947840));
    // 0x18d0f0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18d0f4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18d0f8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x18d100: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18d104: 0x1000000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18d134;
    }
    // 0x18d10c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18d110: 0x10000008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18d134;
    }
    // 0x18d118: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x18d11c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18d134;
    }
    // 0x18d124: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x18d128: 0x28420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    // 0x18d12c: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18d138;
    }
label_18d134:
    // 0x18d134: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
label_18d138:
    // 0x18d138: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18d13c: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x18d140: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x18d144: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18d148: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x18d14c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d150: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d154: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x18d158: 0xe6000020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x18d15c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d160: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d168
// Address: 0x18d168 - 0x18d198

void FUN_0018d168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d168: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x18d16c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18d170: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18d174: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d178: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x18d17c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18d180: 0x26070028
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 40));
    // 0x18d184: 0x2608002c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 44));
    // 0x18d188: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x18d18c: 0x26060024
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 36));
    // 0x18d190: 0xc08272e
    SET_GPR_U32(ctx, 31, 0x18d198);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    FUN_00209cb8(rdram, ctx, runtime); return;
}


// Function: entry_18d198
// Address: 0x18d198 - 0x18d1a8

void entry_18d198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d198: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d19c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18d1a0: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d1a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d1a8
// Address: 0x18d1a8 - 0x18d1f8

void entry_18d1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d1a8) {
        switch (ctx->pc) {
            case 0x18d1c8: ctx->pc = 0; goto label_18d1c8;
            case 0x18d1cc: ctx->pc = 0; goto label_18d1cc;
            case 0x18d1e0: ctx->pc = 0; goto label_18d1e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d1a8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d1ac: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x18d1b0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_18d1c8;
    }
    // 0x18d1b8: 0x50620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
        goto label_18d1cc;
    }
    // 0x18d1c0: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18d1cc;
    }
label_18d1c8:
    // 0x18d1c8: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18d1cc:
    // 0x18d1cc: 0x54600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        goto label_18d1e0;
    }
    // 0x18d1d4: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x18d1d8: 0x21280
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 10));
    // 0x18d1dc: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_18d1e0:
    // 0x18d1e0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d1e4: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18d1e8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d1ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d1f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d1f8
// Address: 0x18d1f8 - 0x18d20c

void FUN_0018d1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d1f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18d1fc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18d200: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18d204: 0xc0827ea
    SET_GPR_U32(ctx, 31, 0x18d20c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    FUN_00209fa8(rdram, ctx, runtime); return;
}


// Function: entry_18d20c
// Address: 0x18d20c - 0x18d21c

void entry_18d20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d20c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d210: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x18d214: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d21c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d21c
// Address: 0x18d21c - 0x18d228

void entry_18d21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d21c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d220: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d228
// Address: 0x18d228 - 0x18d240

void FUN_0018d228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d228: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18d22c: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d230: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18d234: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18d238: 0xc0825ba
    SET_GPR_U32(ctx, 31, 0x18d240);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    FUN_002096e8(rdram, ctx, runtime); return;
}


// Function: entry_18d240
// Address: 0x18d240 - 0x18d250

void entry_18d240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d240: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d244: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x18d248: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d250);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d250
// Address: 0x18d250 - 0x18d268

void entry_18d250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d250: 0x38430018
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 2), 24));
    // 0x18d254: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d258: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x18d25c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d264: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d268; return;
}


// Function: FUN_0018d268
// Address: 0x18d268 - 0x18d290

void FUN_0018d268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d268: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18d26c: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d270: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18d274: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18d278: 0xe0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18d27c: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x18d280: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18d284: 0x8c840004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x18d288: 0xc08256c
    SET_GPR_U32(ctx, 31, 0x18d290);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_002095b0(rdram, ctx, runtime); return;
}


// Function: entry_18d290
// Address: 0x18d290 - 0x18d2a0

void entry_18d290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d290: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d294: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d298: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d2a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d2a0
// Address: 0x18d2a0 - 0x18d2b0

void entry_18d2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d2a0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d2a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d2a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d2b0
// Address: 0x18d2b0 - 0x18d2c0

void FUN_0018d2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d2b0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18d2b4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18d2b8: 0xc0825c8
    SET_GPR_U32(ctx, 31, 0x18d2c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_00209720(rdram, ctx, runtime); return;
}


// Function: entry_18d2c0
// Address: 0x18d2c0 - 0x18d2d0

void entry_18d2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d2c0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d2c4: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18d2c8: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d2d0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d2d0
// Address: 0x18d2d0 - 0x18d2e8

void entry_18d2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d2d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d2d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d2dc: 0x0
    // NOP
    // 0x18d2e0: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18d2e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d2e8; return;
}


// Function: FUN_0018d2e8
// Address: 0x18d2e8 - 0x18d308

void FUN_0018d2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d2e8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18d2ec: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d2f0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18d2f4: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18d2f8: 0x100802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x18d2fc: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18d300: 0xc08261c
    SET_GPR_U32(ctx, 31, 0x18d308);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    FUN_00209870(rdram, ctx, runtime); return;
}


// Function: entry_18d308
// Address: 0x18d308 - 0x18d318

void entry_18d308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d308: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d30c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d310: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d318);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d318
// Address: 0x18d318 - 0x18d328

void entry_18d318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d318: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d31c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d320: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d328
// Address: 0x18d328 - 0x18d348

void FUN_0018d328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d328: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18d32c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18d330: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18d334: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18d338: 0x100802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x18d33c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18d340: 0xc082664
    SET_GPR_U32(ctx, 31, 0x18d348);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    FUN_00209990(rdram, ctx, runtime); return;
}


// Function: entry_18d348
// Address: 0x18d348 - 0x18d358

void entry_18d348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d348: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d34c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d350: 0xc062f40
    SET_GPR_U32(ctx, 31, 0x18d358);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    FUN_0018bd00(rdram, ctx, runtime); return;
}


// Function: entry_18d358
// Address: 0x18d358 - 0x18d368

void entry_18d358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d358: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d35c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d360: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018d368
// Address: 0x18d368 - 0x18d3a0

void FUN_0018d368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d368: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x18d36c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x18d370: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x18d374: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x18d378: 0xe0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18d37c: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x18d380: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18d384: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18d388: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x18d38c: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x18d390: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x18d394: 0x24060202
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 514));
    // 0x18d398: 0xc06349a
    SET_GPR_U32(ctx, 31, 0x18d3a0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_0018d268(rdram, ctx, runtime); return;
}


// Function: entry_18d3a0
// Address: 0x18d3a0 - 0x18d3c4

void entry_18d3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d3a0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d3a4: 0x16000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18D3F0; return;
    }
    // 0x18d3ac: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d3b0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18d3b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18d3b8: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18d3bc: 0xc0634ca
    SET_GPR_U32(ctx, 31, 0x18d3c4);
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 29), 4));
    FUN_0018d328(rdram, ctx, runtime); return;
}


// Function: entry_18d3c4
// Address: 0x18d3c4 - 0x18d3e8

void entry_18d3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d3c4) {
        switch (ctx->pc) {
            case 0x18d3e0: ctx->pc = 0; goto label_18d3e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d3c4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d3c8: 0x16000005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_18d3e0;
    }
    // 0x18d3d0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x18d3d4: 0x24100007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 7));
    // 0x18d3d8: 0x531026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x18d3dc: 0x2800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
label_18d3e0:
    // 0x18d3e0: 0xc0634ac
    SET_GPR_U32(ctx, 31, 0x18d3e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0018d2b0(rdram, ctx, runtime); return;
}


// Function: entry_18d3e8
// Address: 0x18d3e8 - 0x18d410

void entry_18d3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d3e8) {
        switch (ctx->pc) {
            case 0x18d3f0: ctx->pc = 0; goto label_18d3f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d3e8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d3ec: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_18d3f0:
    // 0x18d3f0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18d3f4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18d3f8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d3fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d400: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d408: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18d40c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d410; return;
}


// Function: Clear__13CFileLocation
// Address: 0x18d410 - 0x18d424

void entry_18d424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d424: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d428: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupMemMgr__Fv
// Address: 0x18d430 - 0x18d4a4

void entry_18d4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d4a4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d4a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PvAllocGlobalImpl__Fi
// Address: 0x18d4b0 - 0x18d4f8

void entry_18d51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d51c) {
        switch (ctx->pc) {
            case 0x18d53c: ctx->pc = 0; goto label_18d53c;
            case 0x18d540: ctx->pc = 0; goto label_18d540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d51c: 0x3c05002c
    SET_GPR_U32(ctx, 5, ((uint32_t)44 << 16));
    // 0x18d520: 0x2603000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 15));
    // 0x18d524: 0x8ca22a1c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 10780)));
    // 0x18d528: 0x2404fff0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967280));
    // 0x18d52c: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18d530: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18d534: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 5), 10780), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18d540;
    }
label_18d53c:
    // 0x18d53c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18d540:
    // 0x18d540: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d544: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreeSw__Fv
// Address: 0x18d550 - 0x18d568

void entry_18d588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d588: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d58c: 0x12000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_18d5a0(rdram, ctx, runtime); return;
    }
    // 0x18d594: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18d598: 0xc063600
    SET_GPR_U32(ctx, 31, 0x18d5a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_18d5a0
// Address: 0x18d5a0 - 0x18d5c0

void entry_18d5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d5a0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d5a4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18d5a8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d5ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d5b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d5b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d5bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d5c0; return;
}


// Function: PvAllocSwClearImpl__Fi
// Address: 0x18d5c0 - 0x18d5d8

void entry_18d5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d5d8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d5dc: 0x12000004
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_18d5f0(rdram, ctx, runtime); return;
    }
    // 0x18d5e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d5e8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18d5f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18d5f0
// Address: 0x18d5f0 - 0x18d608

void entry_18d5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d5f0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d5f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d5f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d5fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitStackImpl__Fv
// Address: 0x18d608 - 0x18d61c

void entry_18d61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d61c: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x18d620: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x18d624: 0x8cc32a34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 10804)));
    // 0x18d628: 0x3c04002c
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    // 0x18d62c: 0x8c452a20
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 10784)));
    // 0x18d630: 0x24842a38
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 10808));
    // 0x18d634: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x18d638: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d63c: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18d640: 0xacc32a34
    WRITE32(ADD32(GPR_U32(ctx, 6), 10804), GPR_U32(ctx, 3));
    // 0x18d644: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18d648: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x18d64c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d654: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d658; return;
}


// Function: PvAllocStackImpl__Fi
// Address: 0x18d658 - 0x18d674

void entry_18d674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d674) {
        switch (ctx->pc) {
            case 0x18d694: ctx->pc = 0; goto label_18d694;
            case 0x18d698: ctx->pc = 0; goto label_18d698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d674: 0x3c05002c
    SET_GPR_U32(ctx, 5, ((uint32_t)44 << 16));
    // 0x18d678: 0x2603000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 15));
    // 0x18d67c: 0x8ca22a20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 10784)));
    // 0x18d680: 0x2404fff0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967280));
    // 0x18d684: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18d688: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18d68c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 5), 10784), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18d698;
    }
label_18d694:
    // 0x18d694: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18d698:
    // 0x18d698: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d69c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d6a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PvAllocStackClearImpl__Fi
// Address: 0x18d6a8 - 0x18d6c0

void entry_18d6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d6c0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18d6c4: 0x12000004
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_18d6d8(rdram, ctx, runtime); return;
    }
    // 0x18d6cc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d6d0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18d6d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18d6d8
// Address: 0x18d6d8 - 0x18d6f0

void entry_18d6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d6d8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d6dc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18d6e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d6e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d6e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreeStackImpl__Fv
// Address: 0x18d6f0 - 0x18d730

void entry_18d730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d730: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d73c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d740; return;
}


// Function: malloc
// Address: 0x18d740 - 0x18d748

void entry_18d768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d768: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d76c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d778; return;
}


// Function: fn___builtin_delete
// Address: 0x18d778 - 0x18d780

void entry_18d8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d8d4) {
        switch (ctx->pc) {
            case 0x18d8d8: ctx->pc = 0; goto label_18d8d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d8d4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_18d8d8:
    // 0x18d8d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitMissile__FP7MISSILE
// Address: 0x18d8e0 - 0x18d8f4

void entry_18d8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d8f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18d8f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d8fc: 0xae0206b8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1720), GPR_U32(ctx, 2));
    // 0x18d900: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d904: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d90c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d910; return;
}


// Function: LoadMissileFromBrx__FP7MISSILEP18CBinaryInputStream
// Address: 0x18d910 - 0x18d924

void entry_18d924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d924: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x18d928: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18d92c: 0x24c699b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294941104));
    // 0x18d930: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x18d938);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_18d938
// Address: 0x18d938 - 0x18d978

void entry_18d938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d938: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x18d93c: 0x2403fcff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x18d940: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x18d944: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x18d948: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x18d94c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x18d950: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x18d954: 0x42678
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 25);
    // 0x18d958: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18d95c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18d960: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18d964: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x18d968: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d96c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d974: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d978; return;
}


// Function: OnMissileRemove__FP7MISSILE
// Address: 0x18d978 - 0x18d98c

void entry_18d98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d98c: 0x8e0406b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1716)));
    // 0x18d990: 0x10800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18D9A8; return;
    }
    // 0x18d998: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x18d9a0);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_18d9a0
// Address: 0x18d9a0 - 0x18d9b8

void entry_18d9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18d9a0) {
        switch (ctx->pc) {
            case 0x18d9a8: ctx->pc = 0; goto label_18d9a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18d9a0: 0xae0006b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1716), GPR_U32(ctx, 0));
    // 0x18d9a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18d9a8:
    // 0x18d9a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18d9ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18d9b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18d9b8; return;
}


// Function: ProjectMissileTransform__FP7MISSILEfi
// Address: 0x18d9b8 - 0x18d9f4

void entry_18d9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18d9f4: 0x8e5101ec
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 18), 492)));
    // 0x18d9f8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x18d9fc: 0x8e5001f0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 496)));
    // 0x18da00: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18da04: 0xae4001ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 492), GPR_U32(ctx, 0));
    // 0x18da08: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18da0c: 0xc06f022
    SET_GPR_U32(ctx, 31, 0x18da14);
    WRITE32(ADD32(GPR_U32(ctx, 18), 496), GPR_U32(ctx, 0));
    ProjectSoTransform__FP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_18da14
// Address: 0x18da14 - 0x18da40

void entry_18da14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18da14: 0xae5001f0
    WRITE32(ADD32(GPR_U32(ctx, 18), 496), GPR_U32(ctx, 16));
    // 0x18da18: 0xae5101ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 492), GPR_U32(ctx, 17));
    // 0x18da1c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18da20: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18da24: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18da28: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18da2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18da30: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x18da34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18da3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18da40; return;
}


// Function: FireMissile__FP7MISSILEP3ALOP6VECTOR
// Address: 0x18da40 - 0x18da80

void entry_18da80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18da80) {
        switch (ctx->pc) {
            case 0x18dae4: ctx->pc = 0; goto label_18dae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18da80: 0x8e0206b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
    // 0x18da84: 0x10400021
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18db0c(rdram, ctx, runtime); return;
    }
    // 0x18da8c: 0x7a020150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x18da90: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18da94: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18da98: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x18da9c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18daa0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18daa4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18daa8: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18dae4;
    }
    // 0x18dab0: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x18dab4: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18dab8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18dabc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18dac0: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18dae4;
    }
    // 0x18dac8: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x18dacc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18dad0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18dad4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18dad8: 0x0
    // NOP
    // 0x18dadc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_18dae4;
    }
label_18dae4:
    // 0x18dae4: 0x1460000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DB10; return;
    }
    // 0x18daec: 0x26040150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 336));
    // 0x18daf0: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x18daf8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_18daf8
// Address: 0x18daf8 - 0x18db0c

void entry_18daf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18daf8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18dafc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18db00: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x18db04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18db0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18db0c
// Address: 0x18db0c - 0x18db20

void entry_18db0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18db0c) {
        switch (ctx->pc) {
            case 0x18db10: ctx->pc = 0; goto label_18db10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18db0c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_18db10:
    // 0x18db10: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18db14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18db1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18db20; return;
}


// Function: RenderMissileAll__FP7MISSILEP2CMP2RO
// Address: 0x18db20 - 0x18db7c

void entry_18db7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18db7c) {
        switch (ctx->pc) {
            case 0x18db84: ctx->pc = 0; goto label_18db84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18db7c: 0x1000003b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DC6C; return;
    }
label_18db84:
    // 0x18db84: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18db88: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x18db8c: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x18db90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18db98);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18db98
// Address: 0x18db98 - 0x18dbd4

void entry_18db98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18db98) {
        switch (ctx->pc) {
            case 0x18dba0: ctx->pc = 0; goto label_18dba0;
            case 0x18dbb0: ctx->pc = 0; goto label_18dbb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18db98: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18dbb0;
    }
label_18dba0:
    // 0x18dba0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x18dba4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18dba8: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x18dbac: 0x8e4401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 496)));
label_18dbb0:
    // 0x18dbb0: 0x1080000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DBDC; return;
    }
    // 0x18dbb8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18dbbc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x18dbc0: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18dbc4: 0x8c470014
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x18dbc8: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x18dbcc: 0xe0f809
    SET_GPR_U32(ctx, 31, 0x18dbd4);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 7); return;
}


// Function: entry_18dbd4
// Address: 0x18dbd4 - 0x18dc14

void entry_18dbd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dbd4) {
        switch (ctx->pc) {
            case 0x18dbdc: ctx->pc = 0; goto label_18dbdc;
            case 0x18dc04: ctx->pc = 0; goto label_18dc04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dbd4: 0x1000000b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18dc04;
    }
label_18dbdc:
    // 0x18dbdc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18dbe0: 0x27b30030
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 48));
    // 0x18dbe4: 0x244283d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x18dbe8: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x18dbec: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18dbf0: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18dbf4: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x18dbf8: 0x7fa40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 4));
    // 0x18dbfc: 0x7fa50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 5));
    // 0x18dc00: 0x27b100a0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
label_18dc04:
    // 0x18dc04: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18dc08: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18dc0c: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x18dc14);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_18dc14
// Address: 0x18dc14 - 0x18dc28

void entry_18dc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dc14: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x18dc18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18dc1c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18dc20: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x18dc28);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_18dc28
// Address: 0x18dc28 - 0x18dc38

void entry_18dc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dc28: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18dc2c: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x18dc30: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x18dc38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_18dc38
// Address: 0x18dc38 - 0x18dc68

void entry_18dc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dc38: 0x7ba800f0
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x18dc3c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18dc40: 0x7ba70100
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18dc44: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18dc48: 0x7ba30110
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x18dc4c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18dc50: 0x7ba20120
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x18dc54: 0x7fa800a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 8));
    // 0x18dc58: 0x7fa700b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 7));
    // 0x18dc5c: 0x7fa300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 3));
    // 0x18dc60: 0xc049724
    SET_GPR_U32(ctx, 31, 0x18dc68);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 2));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_18dc68
// Address: 0x18dc68 - 0x18dc88

void entry_18dc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dc68) {
        switch (ctx->pc) {
            case 0x18dc6c: ctx->pc = 0; goto label_18dc6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dc68: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
label_18dc6c:
    // 0x18dc6c: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x18dc70: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x18dc74: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x18dc78: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x18dc7c: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x18dc80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018dc88
// Address: 0x18dc88 - 0x18dcd4

void FUN_0018dc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dc88) {
        switch (ctx->pc) {
            case 0x18dcb4: ctx->pc = 0; goto label_18dcb4;
            case 0x18dcbc: ctx->pc = 0; goto label_18dcbc;
            case 0x18dcc8: ctx->pc = 0; goto label_18dcc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dc88: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x18dc8c: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x18dc90: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18dc94: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18dc98: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x18dc9c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18dca0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18dca4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18dca8: 0x8e4206e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1764)));
    // 0x18dcac: 0x56620003
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1724)));
        goto label_18dcbc;
    }
label_18dcb4:
    // 0x18dcb4: 0x1000001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18dd30(rdram, ctx, runtime); return;
    }
label_18dcbc:
    // 0x18dcbc: 0x1840000b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x18DCEC; return;
    }
    // 0x18dcc4: 0x265006c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1728));
label_18dcc8:
    // 0x18dcc8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18dccc: 0xc060cfc
    SET_GPR_U32(ctx, 31, 0x18dcd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime); return;
}


// Function: entry_18dcd4
// Address: 0x18dcd4 - 0x18dd0c

void entry_18dcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dcd4) {
        switch (ctx->pc) {
            case 0x18dcec: ctx->pc = 0; goto label_18dcec;
            case 0x18dd00: ctx->pc = 0; goto label_18dd00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dcd4: 0x1440fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DCB4; return;
    }
    // 0x18dcdc: 0x8e4206bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1724)));
    // 0x18dce0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x18dce4: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DCC8; return;
    }
label_18dcec:
    // 0x18dcec: 0x8e4206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1744)));
    // 0x18dcf0: 0x1840000c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x18DD24; return;
    }
    // 0x18dcf8: 0x265006d4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1748));
    // 0x18dcfc: 0x0
    // NOP
label_18dd00:
    // 0x18dd00: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x18dd04: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x18dd0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_18dd0c
// Address: 0x18dd0c - 0x18dd30

void entry_18dd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dd0c) {
        switch (ctx->pc) {
            case 0x18dd24: ctx->pc = 0; goto label_18dd24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dd0c: 0x1440ffe9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DCB4; return;
    }
    // 0x18dd14: 0x8e4206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1744)));
    // 0x18dd18: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x18dd1c: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18DD00; return;
    }
label_18dd24:
    // 0x18dd24: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18dd28: 0xc06e282
    SET_GPR_U32(ctx, 31, 0x18dd30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIgnoreSoIntersection__FP2SOT0(rdram, ctx, runtime); return;
}


// Function: entry_18dd30
// Address: 0x18dd30 - 0x18dd50

void entry_18dd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dd30: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18dd34: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18dd38: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18dd3c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18dd40: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18dd44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18dd4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18dd50; return;
}


// Function: FUN_0018dd50
// Address: 0x18dd50 - 0x18dd78

void FUN_0018dd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dd50) {
        switch (ctx->pc) {
            case 0x18dd70: ctx->pc = 0; goto label_18dd70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dd50: 0x8c8306bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1724)));
    // 0x18dd54: 0x2c620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x18dd58: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18dd70;
    }
    // 0x18dd60: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x18dd64: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x18dd68: 0xac4506c0
    WRITE32(ADD32(GPR_U32(ctx, 2), 1728), GPR_U32(ctx, 5));
    // 0x18dd6c: 0xac8306bc
    WRITE32(ADD32(GPR_U32(ctx, 4), 1724), GPR_U32(ctx, 3));
label_18dd70:
    // 0x18dd70: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018dd78
// Address: 0x18dd78 - 0x18dda0

void FUN_0018dd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18dd78) {
        switch (ctx->pc) {
            case 0x18dd98: ctx->pc = 0; goto label_18dd98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18dd78: 0x8c8306d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1744)));
    // 0x18dd7c: 0x2c620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 4));
    // 0x18dd80: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18dd98;
    }
    // 0x18dd88: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x18dd8c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x18dd90: 0xac4506d4
    WRITE32(ADD32(GPR_U32(ctx, 2), 1748), GPR_U32(ctx, 5));
    // 0x18dd94: 0xac8306d0
    WRITE32(ADD32(GPR_U32(ctx, 4), 1744), GPR_U32(ctx, 3));
label_18dd98:
    // 0x18dd98: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitAccmiss__FP7ACCMISS
// Address: 0x18dda0 - 0x18ddb4

void entry_18ddb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ddb4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18ddb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ddbc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x18ddc0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18ddc4: 0x7e030350
    WRITE128(ADD32(GPR_U32(ctx, 16), 848), GPR_VEC(ctx, 3));
    // 0x18ddc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ddcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ddd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ddd8; return;
}


// Function: FireAccmiss__FP7ACCMISSP3ALOP6VECTOR
// Address: 0x18ddd8 - 0x18ddec

void entry_18ddec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ddec) {
        switch (ctx->pc) {
            case 0x18de4c: ctx->pc = 0; goto label_18de4c;
            case 0x18de58: ctx->pc = 0; goto label_18de58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ddec: 0xda030150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x18ddf0: 0x8e0206f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1776)));
    // 0x18ddf4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x18ddf8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18ddfc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18de00: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18de04: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18de08: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18de0c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18de10: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x18de14: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18de18: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18de1c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x18de20: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18de24: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18de28: 0x26100700
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1792));
    // 0x18de2c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18de30: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18de34: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x18de38: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18de3c: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18de4c;
    }
    // 0x18de44: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18de58;
    }
label_18de4c:
    // 0x18de4c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18de50: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18de54: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_18de58:
    // 0x18de58: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18de5c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18de60: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18de64: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18de68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetAccmissAccel__FP7ACCMISSf
// Address: 0x18de70 - 0x18de8c

void entry_18de8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18de8c: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x18de90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18de94: 0xda010700
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1792)));
    // 0x18de98: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18de9c: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x18dea0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18dea4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18dea8: 0xc60c06f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1780)); ctx->f[12] = *(float*)&val; }
    // 0x18deac: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x18deb0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18deb4: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x18deb8: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18debc: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x18dec4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_18dec4
// Address: 0x18dec4 - 0x18ded0

void entry_18dec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dec4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18dec8: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x18ded0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_18ded0
// Address: 0x18ded0 - 0x18dee8

void entry_18ded0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ded0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18ded4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18ded8: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x18dedc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18dee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18dee8; return;
}


// Function: FireSplmiss__FP7SPLMISSP3ALOP6VECTOR
// Address: 0x18dee8 - 0x18df00

void entry_18df00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18df00) {
        switch (ctx->pc) {
            case 0x18df24: ctx->pc = 0; goto label_18df24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18df00: 0xc62106f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1776)); ctx->f[1] = *(float*)&val; }
    // 0x18df04: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x18df08: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18df0c: 0x0
    // NOP
    // 0x18df10: 0x45000004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18df24;
    }
    // 0x18df18: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x18df1c: 0x10000042
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E028; return;
    }
label_18df24:
    // 0x18df24: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18df28: 0x8e240694
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1684)));
    // 0x18df2c: 0xc44c99bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294941116)); ctx->f[12] = *(float*)&val; }
    // 0x18df30: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x18df34: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18df38: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18df3c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18df40: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x18df48);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_18df48
// Address: 0x18df48 - 0x18dfb0

void entry_18df48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18df48: 0xc62006f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1780)); ctx->f[0] = *(float*)&val; }
    // 0x18df4c: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x18df50: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x18df54: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x18df58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18df5c: 0xda2206a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1696)));
    // 0x18df60: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18df64: 0x460c0302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    // 0x18df68: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18df6c: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x18df70: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18df74: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18df78: 0xdba50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18df7c: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x18df80: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18df84: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18df88: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18df8c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18df90: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18df94: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x18df98: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18df9c: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18dfa0: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18dfa4: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18dfa8: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x18dfb0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_18dfb0
// Address: 0x18dfb0 - 0x18e000

void entry_18dfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18dfb0: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x18dfb4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18dfb8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x18dfbc: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x18dfc0: 0x24848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x18dfc4: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18dfc8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18dfcc: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18dfd0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18dfd4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18dfd8: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18dfdc: 0xc62c06f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1780)); ctx->f[12] = *(float*)&val; }
    // 0x18dfe0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18dfe4: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18dfe8: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18dfec: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x18dff0: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18dff4: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18dff8: 0xc050762
    SET_GPR_U32(ctx, 31, 0x18e000);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 96));
    ClsgClipLineToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_18e000
// Address: 0x18e000 - 0x18e040

void entry_18e000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e000) {
        switch (ctx->pc) {
            case 0x18e028: ctx->pc = 0; goto label_18e028;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e000: 0xc7a300a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[3] = *(float*)&val; }
    // 0x18e004: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18e008: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x18e00c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e010: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18e014: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18e018: 0x46030868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[3]);
    // 0x18e01c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x18e020: 0x46011083
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[1];
    // 0x18e024: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
label_18e028:
    // 0x18e028: 0xe62006fc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1788), *(uint32_t*)&val); }
    // 0x18e02c: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18e030: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x18e034: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x18e038: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectSplmissTransform__FP7SPLMISSfi
// Address: 0x18e040 - 0x18e0c0

void entry_18e0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e0c0) {
        switch (ctx->pc) {
            case 0x18e140: ctx->pc = 0; goto label_18e140;
            case 0x18e190: ctx->pc = 0; goto label_18e190;
            case 0x18e198: ctx->pc = 0; goto label_18e198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e0c0: 0x7a420700
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 1792)));
    // 0x18e0c4: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18e0c8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18e0cc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18e0d0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x18e0d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e0d8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e0dc: 0xda4206a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1696)));
    // 0x18e0e0: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18e0e4: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18e0e8: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18e0ec: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e0f0: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18e0f4: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x18e0f8: 0x4bc220bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18e0fc: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18e100: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18e104: 0x4500000e
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18e140;
    }
    // 0x18e10c: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x18e110: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18e114: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e118: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e11c: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18e140;
    }
    // 0x18e124: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x18e128: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18e12c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e130: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e134: 0x0
    // NOP
    // 0x18e138: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_18e140;
    }
label_18e140:
    // 0x18e140: 0x10600013
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18e190;
    }
    // 0x18e148: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x18e14c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18e150: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x18e154: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e158: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x18e15c: 0xda410100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x18e160: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18e164: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x18e168: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x18e16c: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x18e170: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x18e174: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18e178: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x18e17c: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18e180: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18e184: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18e188: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18e198;
    }
label_18e190:
    // 0x18e190: 0x7a420700
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 1792)));
    // 0x18e194: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
label_18e198:
    // 0x18e198: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18e19c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x18e1a0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x18e1a4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x18e1a8: 0x26440100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 256));
    // 0x18e1ac: 0x26450150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 336));
    // 0x18e1b0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x18e1b4: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x18e1b8: 0x27a80060
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 96));
    // 0x18e1bc: 0x27a90070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 112));
    // 0x18e1c0: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x18e1c8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_18e1c8
// Address: 0x18e1c8 - 0x18e300

void entry_18e1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e1c8) {
        switch (ctx->pc) {
            case 0x18e1dc: ctx->pc = 0; goto label_18e1dc;
            case 0x18e210: ctx->pc = 0; goto label_18e210;
            case 0x18e27c: ctx->pc = 0; goto label_18e27c;
            case 0x18e2d4: ctx->pc = 0; goto label_18e2d4;
            case 0x18e2e0: ctx->pc = 0; goto label_18e2e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e1c8: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18e1cc: 0x7ba30070
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18e1d0: 0x7e420100
    WRITE128(ADD32(GPR_U32(ctx, 18), 256), GPR_VEC(ctx, 2));
    // 0x18e1d4: 0x1000000e
    WRITE128(ADD32(GPR_U32(ctx, 18), 336), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18e210;
    }
label_18e1dc:
    // 0x18e1dc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18e1e0: 0x4404a800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[21]);
    // 0x18e1e4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x18e1e8: 0xda420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x18e1ec: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18e1f0: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x18e1f4: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x18e1f8: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18e1fc: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x18e200: 0x4be30888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18e204: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x18e208: 0xfa420100
    WRITE128(ADD32(GPR_U32(ctx, 18), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18e20c: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
label_18e210:
    // 0x18e210: 0x8e4206b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1720)));
    // 0x18e214: 0x1040004d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18e34c(rdram, ctx, runtime); return;
    }
    // 0x18e21c: 0x7a420150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x18e220: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18e224: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18e228: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x18e22c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e230: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e234: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e238: 0x0
    // NOP
    // 0x18e23c: 0x4500000f
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18e27c;
    }
    // 0x18e244: 0x700217c9
    SET_GPR_VEC(ctx, 2, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x18e248: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18e24c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e250: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e254: 0x0
    // NOP
    // 0x18e258: 0x45000008
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18e27c;
    }
    // 0x18e260: 0x700424a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 4)));
    // 0x18e264: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x18e268: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x18e26c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e270: 0x0
    // NOP
    // 0x18e274: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_18e27c;
    }
label_18e27c:
    // 0x18e27c: 0x14600034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 52));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E350; return;
    }
    // 0x18e284: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x18e288: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18e28c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18e290: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18e294: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x18e298: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x18e29c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e2a0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x18e2a4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18e2a8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x18e2ac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18e2b0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18e2b4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x18e2b8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x18e2bc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18e2c0: 0x0
    // NOP
    // 0x18e2c4: 0x45000003
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18e2d4;
    }
    // 0x18e2cc: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18e2e0;
    }
label_18e2d4:
    // 0x18e2d4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18e2d8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18e2dc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_18e2e0:
    // 0x18e2e0: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x18e2e4: 0x265100d0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 208));
    // 0x18e2e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18e2ec: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18e2f0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18e2f4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18e2f8: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x18e300);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_18e300
// Address: 0x18e300 - 0x18e34c

void entry_18e300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e300: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x18e304: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x18e308: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18e30c: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x18e310: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18e314: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x18e318: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18e31c: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x18e320: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18e324: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x18e328: 0x26440150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 336));
    // 0x18e32c: 0x8e4206f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1784)));
    // 0x18e330: 0xd8621ee0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x18e334: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x18e338: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18e33c: 0x4be32048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18e340: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x18e344: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x18e34c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_18e34c
// Address: 0x18e34c - 0x18e3a8

void entry_18e34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e34c) {
        switch (ctx->pc) {
            case 0x18e350: ctx->pc = 0; goto label_18e350;
            case 0x18e388: ctx->pc = 0; goto label_18e388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e34c: 0x26430034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 52));
label_18e350:
    // 0x18e350: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x18e354: 0xafa30014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    // 0x18e358: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18e35c: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x18e360: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x18e364: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x18e368: 0xac93b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 19));
    // 0x18e36c: 0xafa5001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 5));
    // 0x18e370: 0x8e430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x18e374: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x18e378: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18e37c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x18e380: 0x1080000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E3C0; return;
    }
label_18e388:
    // 0x18e388: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18e38c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x18e390: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x18e394: 0x10400004
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18e3a8(rdram, ctx, runtime); return;
    }
    // 0x18e39c: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x18e3a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18e3a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18e3a8
// Address: 0x18e3a8 - 0x18e3e0

void entry_18e3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e3a8) {
        switch (ctx->pc) {
            case 0x18e3c0: ctx->pc = 0; goto label_18e3c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e3a8: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x18e3ac: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x18e3b0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18e3b4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x18e3b8: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E388; return;
    }
label_18e3c0:
    // 0x18e3c0: 0x16800008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E3E4; return;
    }
    // 0x18e3c8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18e3cc: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x18e3d0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
        ctx->pc = 0x18E3E4; return;
    }
    // 0x18e3d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18e3e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18e3e0
// Address: 0x18e3e0 - 0x18e410

void entry_18e3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e3e0) {
        switch (ctx->pc) {
            case 0x18e3e4: ctx->pc = 0; goto label_18e3e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e3e0: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
label_18e3e4:
    // 0x18e3e4: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18e3e8: 0xae02b314
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947604), GPR_U32(ctx, 2));
    // 0x18e3ec: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18e3f0: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x18e3f4: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18e3f8: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18e3fc: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18e400: 0xc7b500e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[21] = *(float*)&val; }
    // 0x18e404: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x18e408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018e410
// Address: 0x18e410 - 0x18e480

void FUN_0018e410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e410) {
        switch (ctx->pc) {
            case 0x18e420: ctx->pc = 0; goto label_18e420;
            case 0x18e440: ctx->pc = 0; goto label_18e440;
            case 0x18e45c: ctx->pc = 0; goto label_18e45c;
            case 0x18e46c: ctx->pc = 0; goto label_18e46c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e410: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18e414: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18e418: 0x244784b0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294935728));
    // 0x18e41c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_18e420:
    // 0x18e420: 0x10e6000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 6)) {
        goto label_18e45c;
    }
    // 0x18e428: 0x10e0000c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_18e45c;
    }
    // 0x18e430: 0x54c00003
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 8)));
        goto label_18e440;
    }
    // 0x18e438: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18e45c;
    }
label_18e440:
    // 0x18e440: 0x8ce50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 24)));
    // 0x18e444: 0x8cc20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x18e448: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x18e44c: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18e450: 0x441026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18e454: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18e458: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_18e45c:
    // 0x18e45c: 0x50600003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
        goto label_18e46c;
    }
    // 0x18e464: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18e46c:
    // 0x18e46c: 0x29020010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), 16));
    // 0x18e470: 0x1440ffeb
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18e420;
    }
    // 0x18e478: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018e480
// Address: 0x18e480 - 0x18e4c0

void FUN_0018e480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e480) {
        switch (ctx->pc) {
            case 0x18e4a4: ctx->pc = 0; goto label_18e4a4;
            case 0x18e4b8: ctx->pc = 0; goto label_18e4b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e480: 0x2c820010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 16));
    // 0x18e484: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
        goto label_18e4a4;
    }
    // 0x18e48c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18e490: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x18e494: 0x244299c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941120));
    // 0x18e498: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18e49c: 0x3e00008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18e4a4:
    // 0x18e4a4: 0x50820004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
        goto label_18e4b8;
    }
    // 0x18e4ac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18e4b0: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948232));
    ctx->pc = GPR_U32(ctx, 31); return;
label_18e4b8:
    // 0x18e4b8: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018e4c0
// Address: 0x18e4c0 - 0x18e4e4

void FUN_0018e4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e4c0: 0x41140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 5));
    // 0x18e4c4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x18e4c8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18e4cc: 0x24a584b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935728));
    // 0x18e4d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18e4d4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18e4d8: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18e4dc: 0xc063c3a
    SET_GPR_U32(ctx, 31, 0x18e4e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941184));
    FUN_0018f0e8(rdram, ctx, runtime); return;
}


// Function: entry_18e4e4
// Address: 0x18e4e4 - 0x18e4f0

void entry_18e4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e4e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18e4e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018e4f0
// Address: 0x18e4f0 - 0x18e504

void FUN_0018e4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e4f0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x18e4f4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18e4f8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x18e4fc: 0xc063930
    SET_GPR_U32(ctx, 31, 0x18e504);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_0018e4c0(rdram, ctx, runtime); return;
}


// Function: entry_18e504
// Address: 0x18e504 - 0x18e558

void entry_18e504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e504) {
        switch (ctx->pc) {
            case 0x18e52c: ctx->pc = 0; goto label_18e52c;
            case 0x18e534: ctx->pc = 0; goto label_18e534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e504: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18e508: 0x101940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 5));
    // 0x18e50c: 0x244284b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935728));
    // 0x18e510: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x18e514: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18e518: 0x2e040010
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 16), 16));
    // 0x18e51c: 0x14800003
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294941192), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_18e52c;
    }
    // 0x18e524: 0x10000003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18e534;
    }
label_18e52c:
    // 0x18e52c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18e530: 0x2022804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 16) & 0x1F));
label_18e534:
    // 0x18e534: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18e538: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18e53c: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x18e540: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18e544: 0x8c8319f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6644)));
    // 0x18e548: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18e54c: 0xac8319f4
    WRITE32(ADD32(GPR_U32(ctx, 4), 6644), GPR_U32(ctx, 3));
    // 0x18e550: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018e558
// Address: 0x18e558 - 0x18e594

void FUN_0018e558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e558) {
        switch (ctx->pc) {
            case 0x18e588: ctx->pc = 0; goto label_18e588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e558: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x18e55c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18e560: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x18e564: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18e568: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18e56c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18e570: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18e574: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18e578: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x18e57c: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x18e580: 0x24509a00
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294941184));
    // 0x18e584: 0x8e040130
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 304)));
label_18e588:
    // 0x18e588: 0xae000134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 0));
    // 0x18e58c: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x18e594);
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_18e594
// Address: 0x18e594 - 0x18e5a8

void entry_18e594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e594: 0x8e241f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7964)));
    // 0x18e598: 0x8e050114
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 276)));
    // 0x18e59c: 0xae130134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 19));
    // 0x18e5a0: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x18e5a8);
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18e5a8
// Address: 0x18e5a8 - 0x18e5b4

void entry_18e5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5a8: 0xae120134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 18));
    // 0x18e5ac: 0xc05a13a
    SET_GPR_U32(ctx, 31, 0x18e5b4);
    RestoreGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18e5b4
// Address: 0x18e5b4 - 0x18e5c0

void entry_18e5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5b4: 0x8e241f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7964)));
    // 0x18e5b8: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x18e5c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18e5c0
// Address: 0x18e5c0 - 0x18e5c8

void entry_18e5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5c0: 0xc05a0fa
    SET_GPR_U32(ctx, 31, 0x18e5c8);
    SwapGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18e5c8
// Address: 0x18e5c8 - 0x18e5d4

void entry_18e5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5c8: 0x8e241f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7964)));
    // 0x18e5cc: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x18e5d4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18e5d4
// Address: 0x18e5d4 - 0x18e5dc

void entry_18e5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5d4: 0xc05a0fa
    SET_GPR_U32(ctx, 31, 0x18e5dc);
    SwapGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18e5dc
// Address: 0x18e5dc - 0x18e5e8

void entry_18e5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5dc: 0x1000ffea
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E588; return;
    }
    // 0x18e5e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18e5e8; return;
}


// Function: StartupMpeg__Fv
// Address: 0x18e5e8 - 0x18e5fc

void entry_18e5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e5fc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x18e600: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18e604: 0x24639a00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294941184));
    // 0x18e608: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18e60c: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x18e610: 0xac620130
    WRITE32(ADD32(GPR_U32(ctx, 3), 304), GPR_U32(ctx, 2));
    // 0x18e614: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18e61c);
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18e61c
// Address: 0x18e61c - 0x18e658

void entry_18e61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e61c: 0x3c030019
    SET_GPR_U32(ctx, 3, ((uint32_t)25 << 16));
    // 0x18e620: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x18e624: 0x3c050028
    SET_GPR_U32(ctx, 5, ((uint32_t)40 << 16));
    // 0x18e628: 0x2463e558
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294960472));
    // 0x18e62c: 0x24a532f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 13040));
    // 0x18e630: 0x24061000
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4096));
    // 0x18e634: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18e638: 0x24422b00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11008));
    // 0x18e63c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x18e640: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18e644: 0xafa50010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 5));
    // 0x18e648: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x18e64c: 0xafa6000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 6));
    // 0x18e650: 0xc07da84
    SET_GPR_U32(ctx, 31, 0x18e658);
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 7));
    CreateThread(rdram, ctx, runtime); return;
}


// Function: entry_18e658
// Address: 0x18e658 - 0x18e66c

void entry_18e658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e658: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x18e65c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18e660: 0xac625964
    WRITE32(ADD32(GPR_U32(ctx, 3), 22884), GPR_U32(ctx, 2));
    // 0x18e664: 0xc07da88
    SET_GPR_U32(ctx, 31, 0x18e66c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartThread(rdram, ctx, runtime); return;
}


// Function: entry_18e66c
// Address: 0x18e66c - 0x18e678

void entry_18e66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e66c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18e670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Init__15CQueueOutputIopii
// Address: 0x18e678 - 0x18e690

void entry_18e690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e690: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18e694: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18e69c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18e6a0; return;
}


// Function: Reset__15CQueueOutputIop
// Address: 0x18e6a0 - 0x18e6c0

void entry_18e78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e78c) {
        switch (ctx->pc) {
            case 0x18e798: ctx->pc = 0; goto label_18e798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e78c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18e790: 0x54c0ffe1
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x18E718; return;
    }
label_18e798:
    // 0x18e798: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18e79c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18e7a0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18e7a4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18e7a8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18e7ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18e7b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18e7b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18e7bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18e7c0; return;
}


// Function: CbSend__15CQueueOutputIopiPv
// Address: 0x18e7c0 - 0x18e7fc

void entry_18e7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e7fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18e800: 0xc07db28
    SET_GPR_U32(ctx, 31, 0x18e808);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    sceSifSetDma(rdram, ctx, runtime); return;
}


// Function: entry_18e808
// Address: 0x18e808 - 0x18e818

void entry_18e808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e808) {
        switch (ctx->pc) {
            case 0x18e810: ctx->pc = 0; goto label_18e810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e808: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18e80c: 0x0
    // NOP
label_18e810:
    // 0x18e810: 0xc07db24
    SET_GPR_U32(ctx, 31, 0x18e818);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifDmaStat(rdram, ctx, runtime); return;
}


// Function: entry_18e818
// Address: 0x18e818 - 0x18e838

void entry_18e818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e818: 0x441fffd
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x18E810; return;
    }
    // 0x18e820: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18e824: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18e828: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18e82c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18e834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18e838; return;
}


// Function: Update__15CQueueOutputIop
// Address: 0x18e838 - 0x18e84c

void entry_18e84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e84c) {
        switch (ctx->pc) {
            case 0x18e884: ctx->pc = 0; goto label_18e884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e84c: 0x3c0300ff
    SET_GPR_U32(ctx, 3, ((uint32_t)255 << 16));
    // 0x18e850: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x18e854: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x18e858: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x18e85c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18e860: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x18e864: 0x461023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x18e868: 0x451023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18e86c: 0x2442fc00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966272));
    // 0x18e870: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18e874: 0x44001a
    { int32_t divisor = GPR_S32(ctx, 4); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 4) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,4); } }
    // 0x18e878: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x18e87c: 0x50800001
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_18e884;
    }
label_18e884:
    // 0x18e884: 0x1810
    SET_GPR_U32(ctx, 3, ctx->hi);
    // 0x18e888: 0x831023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x18e88c: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x18e890: 0xa22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x18e894: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x18e898: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x18e89c: 0xa4001a
    { int32_t divisor = GPR_S32(ctx, 4); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 5) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 4) % divisor); } else { ctx->lo = (GPR_S32(ctx,5) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,4); } }
    // 0x18e8a0: 0xae050010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 5));
    // 0x18e8a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18e8a8: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x18e8ac: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x18e8b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18e8b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18e8bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18e8c0; return;
}


// Function: FAsyncDrain__15CQueueOutputIop
// Address: 0x18e8c0 - 0x18e8c8

void entry_18e960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e960: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18e964: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18e968: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x18e96c: 0xc07022c
    SET_GPR_U32(ctx, 31, 0x18e974);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PushSwReverb__FP2SW7REVERBKi(rdram, ctx, runtime); return;
}


// Function: entry_18e974
// Address: 0x18e974 - 0x18e97c

void entry_18e974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e974: 0xc047804
    SET_GPR_U32(ctx, 31, 0x18e97c);
    snd_StopAllStreams(rdram, ctx, runtime); return;
}


// Function: entry_18e97c
// Address: 0x18e97c - 0x18e988

void entry_18e97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e97c) {
        switch (ctx->pc) {
            case 0x18e980: ctx->pc = 0; goto label_18e980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e97c: 0x0
    // NOP
label_18e980:
    // 0x18e980: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x18e988);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_18e988
// Address: 0x18e988 - 0x18e998

void entry_18e988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e988: 0x1440fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18E980; return;
    }
    // 0x18e990: 0xc047844
    SET_GPR_U32(ctx, 31, 0x18e998);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCheckCDIdle(rdram, ctx, runtime); return;
}


// Function: entry_18e998
// Address: 0x18e998 - 0x18e9a0

void entry_18e998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e998: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x18e9a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_18e9a0
// Address: 0x18e9a0 - 0x18e9a8

void entry_18e9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e9a0: 0xc04752e
    SET_GPR_U32(ctx, 31, 0x18e9a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    snd_GetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18e9a8
// Address: 0x18e9a8 - 0x18e9b4

void entry_18e9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e9a8: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x18e9ac: 0xc04752e
    SET_GPR_U32(ctx, 31, 0x18e9b4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 140), GPR_U32(ctx, 2));
    snd_GetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18e9b4
// Address: 0x18e9b4 - 0x18e9c4

void entry_18e9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e9b4: 0xae020090
    WRITE32(ADD32(GPR_U32(ctx, 16), 144), GPR_U32(ctx, 2));
    // 0x18e9b8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18e9bc: 0xc047520
    SET_GPR_U32(ctx, 31, 0x18e9c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1024));
    snd_SetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18e9c4
// Address: 0x18e9c4 - 0x18e9d0

void entry_18e9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e9c4: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x18e9c8: 0xc047520
    SET_GPR_U32(ctx, 31, 0x18e9d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    snd_SetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18e9d0
// Address: 0x18e9d0 - 0x18e9e8

void entry_18e9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18e9d0: 0x24046000
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24576));
    // 0x18e9d4: 0x24050400
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x18e9d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18e9dc: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18e9e0: 0xc04790a
    SET_GPR_U32(ctx, 31, 0x18e9e8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    snd_InitMovieSound(rdram, ctx, runtime); return;
}


// Function: entry_18e9e8
// Address: 0x18e9e8 - 0x18ea10

void entry_18e9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18e9e8) {
        switch (ctx->pc) {
            case 0x18e9fc: ctx->pc = 0; goto label_18e9fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18e9e8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18e9ec: 0x6210003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_18e9fc;
    }
    // 0x18e9f4: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18ea34(rdram, ctx, runtime); return;
    }
label_18e9fc:
    // 0x18e9fc: 0x26060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 4));
    // 0x18ea00: 0x2604002c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 44));
    // 0x18ea04: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x18ea08: 0xc04f262
    SET_GPR_U32(ctx, 31, 0x18ea10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 40));
    Init__10CByteQueueiPv(rdram, ctx, runtime); return;
}


// Function: entry_18ea10
// Address: 0x18ea10 - 0x18ea24

void entry_18ea10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea10: 0x3c06002d
    SET_GPR_U32(ctx, 6, ((uint32_t)45 << 16));
    // 0x18ea14: 0x2604004c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 76));
    // 0x18ea18: 0x24c6bb40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294949696));
    // 0x18ea1c: 0xc04f262
    SET_GPR_U32(ctx, 31, 0x18ea24);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 49152));
    Init__10CByteQueueiPv(rdram, ctx, runtime); return;
}


// Function: entry_18ea24
// Address: 0x18ea24 - 0x18ea34

void entry_18ea24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea24: 0x2604006c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 108));
    // 0x18ea28: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18ea2c: 0xc06399e
    SET_GPR_U32(ctx, 31, 0x18ea34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24576));
    Init__15CQueueOutputIopii(rdram, ctx, runtime); return;
}


// Function: entry_18ea34
// Address: 0x18ea34 - 0x18ea48

void entry_18ea34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea34: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18ea38: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ea3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ea40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Reset__10CMpegAudio
// Address: 0x18ea48 - 0x18ea6c

void entry_18ea6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea6c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18ea70: 0x2604002c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 44));
    // 0x18ea74: 0xc04f26c
    SET_GPR_U32(ctx, 31, 0x18ea7c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    Reset__10CByteQueue(rdram, ctx, runtime); return;
}


// Function: entry_18ea7c
// Address: 0x18ea7c - 0x18ea84

void entry_18ea7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea7c: 0xc04f26c
    SET_GPR_U32(ctx, 31, 0x18ea84);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 76));
    Reset__10CByteQueue(rdram, ctx, runtime); return;
}


// Function: entry_18ea84
// Address: 0x18ea84 - 0x18ea8c

void entry_18ea84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ea84: 0xc0639a8
    SET_GPR_U32(ctx, 31, 0x18ea8c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 108));
    Reset__15CQueueOutputIop(rdram, ctx, runtime); return;
}


// Function: entry_18ea8c
// Address: 0x18ea8c - 0x18eaa0

void entry_18ea8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ea8c) {
        switch (ctx->pc) {
            case 0x18ea90: ctx->pc = 0; goto label_18ea90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ea8c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18ea90:
    // 0x18ea90: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ea94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ea9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18eaa0; return;
}


// Function: Close__10CMpegAudio
// Address: 0x18eaa0 - 0x18eab8

void entry_18eab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eab8: 0x8e05008c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 140)));
    // 0x18eabc: 0xc047520
    SET_GPR_U32(ctx, 31, 0x18eac4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    snd_SetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18eac4
// Address: 0x18eac4 - 0x18ead0

void entry_18eac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eac4: 0x8e050090
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x18eac8: 0xc047520
    SET_GPR_U32(ctx, 31, 0x18ead0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    snd_SetMasterVolume(rdram, ctx, runtime); return;
}


// Function: entry_18ead0
// Address: 0x18ead0 - 0x18eadc

void entry_18ead0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ead0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x18ead4: 0xc070254
    SET_GPR_U32(ctx, 31, 0x18eadc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    PopSwReverb__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_18eadc
// Address: 0x18eadc - 0x18eae8

void entry_18eadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eadc: 0x3c04ffff
    SET_GPR_U32(ctx, 4, ((uint32_t)65535 << 16));
    // 0x18eae0: 0xc0475b6
    SET_GPR_U32(ctx, 31, 0x18eae8);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    snd_ContinueAllSoundsInGroup(rdram, ctx, runtime); return;
}


// Function: entry_18eae8
// Address: 0x18eae8 - 0x18eaf8

void entry_18eae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eae8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18eaec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18eaf0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAccept__10CMpegAudioiPUc
// Address: 0x18eaf8 - 0x18eb40

void entry_18eb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18eb40) {
        switch (ctx->pc) {
            case 0x18eb58: ctx->pc = 0; goto label_18eb58;
            case 0x18eb68: ctx->pc = 0; goto label_18eb68;
            case 0x18eb70: ctx->pc = 0; goto label_18eb70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18eb40: 0x8e43003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 60)));
    // 0x18eb44: 0x2228821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x18eb48: 0x1c60000c
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 3) > 0) {
        entry_18eb7c(rdram, ctx, runtime); return;
    }
    // 0x18eb50: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18eb54: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
label_18eb58:
    // 0x18eb58: 0x8e42005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 92)));
    // 0x18eb5c: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x18eb60: 0x10400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 76));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18eb70;
    }
label_18eb68:
    // 0x18eb68: 0x10000005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18EB80; return;
    }
label_18eb70:
    // 0x18eb70: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18eb74: 0xc04f300
    SET_GPR_U32(ctx, 31, 0x18eb7c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CbFill__10CByteQueueiPUc(rdram, ctx, runtime); return;
}


// Function: entry_18eb7c
// Address: 0x18eb7c - 0x18eb98

void entry_18eb7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18eb7c) {
        switch (ctx->pc) {
            case 0x18eb80: ctx->pc = 0; goto label_18eb80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18eb7c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_18eb80:
    // 0x18eb80: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18eb84: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18eb88: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18eb8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18eb90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Update__10CMpegAudio
// Address: 0x18eb98 - 0x18ebdc

void entry_18ebdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ebdc: 0x8e230080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x18ebe0: 0x14600012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18EC2C; return;
    }
    // 0x18ebe8: 0x8e240070
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x18ebec: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ebf0: 0x8e250074
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 116)));
    // 0x18ebf4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ebf8: 0xc047930
    SET_GPR_U32(ctx, 31, 0x18ec00);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    snd_StartMovieSound(rdram, ctx, runtime); return;
}


// Function: entry_18ec00
// Address: 0x18ec00 - 0x18ec18

void entry_18ec00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ec00) {
        switch (ctx->pc) {
            case 0x18ec0c: ctx->pc = 0; goto label_18ec0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ec00: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18ec04: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18ec28(rdram, ctx, runtime); return;
    }
label_18ec0c:
    // 0x18ec0c: 0x2630006c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 108));
    // 0x18ec10: 0xc063a0e
    SET_GPR_U32(ctx, 31, 0x18ec18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Update__15CQueueOutputIop(rdram, ctx, runtime); return;
}


// Function: entry_18ec18
// Address: 0x18ec18 - 0x18ec28

void entry_18ec18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ec18: 0x8e250080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x18ec1c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ec20: 0xc04f2b6
    SET_GPR_U32(ctx, 31, 0x18ec28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 76));
    CbDrain__10CByteQueueiP12CQueueOutput(rdram, ctx, runtime); return;
}


// Function: entry_18ec28
// Address: 0x18ec28 - 0x18ec40

void entry_18ec28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ec28) {
        switch (ctx->pc) {
            case 0x18ec2c: ctx->pc = 0; goto label_18ec2c;
            case 0x18ec30: ctx->pc = 0; goto label_18ec30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ec28: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_18ec2c:
    // 0x18ec2c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_18ec30:
    // 0x18ec30: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ec34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ec3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ec40; return;
}


// Function: FMpegAcceptVideo__FP7sceMpegP16sceMpegCbDataStrP5CMpeg
// Address: 0x18ec40 - 0x18ec70

void entry_18ec70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ec70) {
        switch (ctx->pc) {
            case 0x18ec74: ctx->pc = 0; goto label_18ec74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ec70: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_18ec74:
    // 0x18ec74: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ec78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FMpegAcceptAudio__FP7sceMpegP16sceMpegCbDataStrP5CMpeg
// Address: 0x18ec80 - 0x18ec98

void entry_18ec98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ec98: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ec9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18eca4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18eca8; return;
}


// Function: FMpegDecodeVideo__FP7sceMpegP13sceMpegCbDataP5CMpeg
// Address: 0x18eca8 - 0x18ece8

void entry_18ece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ece8: 0x5440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 116)));
        ctx->pc = 0x18ECD0; return;
    }
    // 0x18ecf0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ecf4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ecf8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x18ed00);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_18ed00
// Address: 0x18ed00 - 0x18ed2c

void entry_18ed00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ed00: 0x8e050074
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 116)));
    // 0x18ed04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18ed08: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ed0c: 0x245182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 5)));
    // 0x18ed10: 0x24a2001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 31));
    // 0x18ed14: 0xa3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 5));
    // 0x18ed18: 0x21143
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 5));
    // 0x18ed1c: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x18ed20: 0xa22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x18ed24: 0xc04f300
    SET_GPR_U32(ctx, 31, 0x18ed2c);
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 5)));
    CbFill__10CByteQueueiPUc(rdram, ctx, runtime); return;
}


// Function: entry_18ed2c
// Address: 0x18ed2c - 0x18ed44

void entry_18ed2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ed2c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18ed30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18ed34: 0x2442b598
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948248));
    // 0x18ed38: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ed3c: 0xc04f312
    SET_GPR_U32(ctx, 31, 0x18ed44);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    FreeDrain__10CByteQueuei(rdram, ctx, runtime); return;
}


// Function: entry_18ed44
// Address: 0x18ed44 - 0x18ed54

void entry_18ed44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ed44: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18ed48: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ed4c: 0xc04f2b6
    SET_GPR_U32(ctx, 31, 0x18ed54);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CbDrain__10CByteQueueiP12CQueueOutput(rdram, ctx, runtime); return;
}


// Function: entry_18ed54
// Address: 0x18ed54 - 0x18ed78

void entry_18ed54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ed54: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18ed58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18ed5c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18ed60: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18ed64: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18ed68: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18ed6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ed74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ed78; return;
}


// Function: FMpegDecoderIdle__FP7sceMpegP13sceMpegCbDataP5CMpeg
// Address: 0x18ed78 - 0x18ed8c

void entry_18ed8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ed8c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ed90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18ed94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ed9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18eda0; return;
}


// Function: FMpegDecoderError__FP7sceMpegP13sceMpegCbDataP5CMpeg
// Address: 0x18eda0 - 0x18eda8

void entry_18ee00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ee04: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ee08: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x18ee10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7208));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18ee10
// Address: 0x18ee10 - 0x18ee18

void entry_18ee10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee10: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x18ee18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_18ee18
// Address: 0x18ee18 - 0x18ee2c

void entry_18ee18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ee1c: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x18ee20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ee24: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18ee2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18ee2c
// Address: 0x18ee2c - 0x18ee40

void entry_18ee2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee2c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ee30: 0x3406a1e0
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 41440));
    // 0x18ee34: 0x6313c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 4));
    // 0x18ee38: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18ee40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18ee40
// Address: 0x18ee40 - 0x18ee58

void entry_18ee40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee40: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x18ee44: 0x6303c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 0));
    // 0x18ee48: 0x34c60010
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 16));
    // 0x18ee4c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ee50: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18ee58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 82));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18ee58
// Address: 0x18ee58 - 0x18ee90

void entry_18ee58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ee58) {
        switch (ctx->pc) {
            case 0x18ee68: ctx->pc = 0; goto label_18ee68;
            case 0x18ee80: ctx->pc = 0; goto label_18ee80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ee58: 0x1ac00027
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x18EEF8; return;
    }
    // 0x18ee60: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ee64: 0x0
    // NOP
label_18ee68:
    // 0x18ee68: 0x1aa0001f
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x18EEE8; return;
    }
    // 0x18ee70: 0x3c110fff
    SET_GPR_U32(ctx, 17, ((uint32_t)4095 << 16));
    // 0x18ee74: 0x6993c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) << (32 + 4));
    // 0x18ee78: 0x3631ffff
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), 65535));
    // 0x18ee7c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_18ee80:
    // 0x18ee80: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x18ee84: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18ee88: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18ee90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18ee90
// Address: 0x18ee90 - 0x18eeac

void entry_18ee90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ee90: 0x103100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 16), 4));
    // 0x18ee94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ee98: 0x6343c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << (32 + 16));
    // 0x18ee9c: 0x24050051
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 81));
    // 0x18eea0: 0x2663025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 19), GPR_U32(ctx, 6)));
    // 0x18eea4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18eeac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18eeac
// Address: 0x18eeac - 0x18eebc

void entry_18eeac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eeac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18eeb0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18eeb4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18eebc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 83));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18eebc
// Address: 0x18eebc - 0x18eec8

void entry_18eebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eebc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18eec0: 0xc058656
    SET_GPR_U32(ctx, 31, 0x18eec8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    AddImage__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_18eec8
// Address: 0x18eec8 - 0x18eedc

void entry_18eec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18eec8: 0x2513024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    // 0x18eecc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18eed0: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x18eed4: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x18eedc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1024));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18eedc
// Address: 0x18eedc - 0x18ef0c

void entry_18eedc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18eedc) {
        switch (ctx->pc) {
            case 0x18eee8: ctx->pc = 0; goto label_18eee8;
            case 0x18eef8: ctx->pc = 0; goto label_18eef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18eedc: 0x215102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x18eee0: 0x1440ffe7
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18EE80; return;
    }
label_18eee8:
    // 0x18eee8: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x18eeec: 0xd6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 22)));
    // 0x18eef0: 0x1440ffdd
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18EE68; return;
    }
label_18eef8:
    // 0x18eef8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18eefc: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x18ef00: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ef04: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18ef0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18ef0c
// Address: 0x18ef0c - 0x18ef1c

void entry_18ef0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef0c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ef10: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x18ef14: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18ef1c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18ef1c
// Address: 0x18ef1c - 0x18ef2c

void entry_18ef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef1c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ef20: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x18ef24: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18ef2c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18ef2c
// Address: 0x18ef2c - 0x18ef34

void entry_18ef2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef2c: 0xc058480
    SET_GPR_U32(ctx, 31, 0x18ef34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_18ef34
// Address: 0x18ef34 - 0x18ef3c

void entry_18ef34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef34: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x18ef3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_18ef3c
// Address: 0x18ef3c - 0x18ef4c

void entry_18ef3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef3c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ef40: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18ef44: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x18ef4c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18ef4c
// Address: 0x18ef4c - 0x18ef78

void entry_18ef4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef4c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18ef50: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18ef54: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18ef58: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18ef5c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18ef60: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18ef64: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18ef68: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18ef6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ef74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ef78; return;
}


// Function: FUN_0018ef78
// Address: 0x18ef78 - 0x18efa0

void FUN_0018ef78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ef78: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x18ef7c: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x18ef80: 0x7fb20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 18));
    // 0x18ef84: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18ef88: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x18ef8c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18ef90: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x18ef94: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18ef98: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x18efa0);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_18efa0
// Address: 0x18efa0 - 0x18efb0

void entry_18efa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18efa0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18efa4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18efa8: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x18efb0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18efb0
// Address: 0x18efb0 - 0x18efb8

void entry_18efb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18efb0: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x18efb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_18efb8
// Address: 0x18efb8 - 0x18efcc

void entry_18efb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18efb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18efbc: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x18efc0: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x18efc4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18efcc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18efcc
// Address: 0x18efcc - 0x18efec

void entry_18efcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18efcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18efd0: 0x2406000a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 10));
    // 0x18efd4: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x18efd8: 0x34c6a802
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 43010));
    // 0x18efdc: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x18efe0: 0x34c69e00
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 40448));
    // 0x18efe4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18efec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18efec
// Address: 0x18efec - 0x18effc

void entry_18efec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18efec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18eff0: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x18eff4: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18effc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 97));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18effc
// Address: 0x18effc - 0x18f00c

void entry_18effc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18effc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f000: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x18f004: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18f00c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18f00c
// Address: 0x18f00c - 0x18f01c

void entry_18f00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f00c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f010: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x18f014: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18f01c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18f01c
// Address: 0x18f01c - 0x18f030

void entry_18f01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f01c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f020: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x18f024: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x18f028: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18f030);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18f030
// Address: 0x18f030 - 0x18f048

void entry_18f030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f030: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f034: 0x3c07000e
    SET_GPR_U32(ctx, 7, ((uint32_t)14 << 16));
    // 0x18f038: 0x34e74343
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17219));
    // 0x18f03c: 0x24050116
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 278));
    // 0x18f040: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x18f048);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_18f048
// Address: 0x18f048 - 0x18f058

void entry_18f048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f048: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f04c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x18f050: 0xc058532
    SET_GPR_U32(ctx, 31, 0x18f058);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_18f058
// Address: 0x18f058 - 0x18f070

void entry_18f058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f058: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f05c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f060: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f064: 0x24056c00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27648));
    // 0x18f068: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x18f070);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30976));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_18f070
// Address: 0x18f070 - 0x18f088

void entry_18f070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f070: 0x118900
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 4));
    // 0x18f074: 0x129100
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 18), 4));
    // 0x18f078: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f07c: 0x36250008
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 17), 8));
    // 0x18f080: 0xc058532
    SET_GPR_U32(ctx, 31, 0x18f088);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 18), 8));
    PackUV__4GIFSii(rdram, ctx, runtime); return;
}


// Function: entry_18f088
// Address: 0x18f088 - 0x18f0a0

void entry_18f088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f088: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f08c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f090: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f094: 0x34059400
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 37888));
    // 0x18f098: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x18f0a0);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 34560));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_18f0a0
// Address: 0x18f0a0 - 0x18f0b0

void entry_18f0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f0a4: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x18f0a8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x18f0b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_18f0b0
// Address: 0x18f0b0 - 0x18f0b8

void entry_18f0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0b0: 0xc058480
    SET_GPR_U32(ctx, 31, 0x18f0b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_18f0b8
// Address: 0x18f0b8 - 0x18f0c0

void entry_18f0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0b8: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x18f0c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_18f0c0
// Address: 0x18f0c0 - 0x18f0d0

void entry_18f0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f0c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f0c8: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x18f0d0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_18f0d0
// Address: 0x18f0d0 - 0x18f0e8

void entry_18f0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0d0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18f0d4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18f0d8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18f0dc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18f0e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018f0e8
// Address: 0x18f0e8 - 0x18f108

void FUN_0018f0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f0e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18f0ec: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18f0f0: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x18f0f4: 0x14400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F13C; return;
    }
    // 0x18f0fc: 0xac850004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 5));
    // 0x18f100: 0xc063904
    SET_GPR_U32(ctx, 31, 0x18f108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_0018e410(rdram, ctx, runtime); return;
}


// Function: entry_18f108
// Address: 0x18f108 - 0x18f148

void entry_18f108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f108) {
        switch (ctx->pc) {
            case 0x18f120: ctx->pc = 0; goto label_18f120;
            case 0x18f124: ctx->pc = 0; goto label_18f124;
            case 0x18f13c: ctx->pc = 0; goto label_18f13c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f108: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18f10c: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x18f110: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18f120;
    }
    // 0x18f118: 0x10000002
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f124;
    }
label_18f120:
    // 0x18f120: 0x622804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 3) & 0x1F));
label_18f124:
    // 0x18f124: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18f128: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x18f12c: 0x8c8319f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6644)));
    // 0x18f130: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18f134: 0xac8319f4
    WRITE32(ADD32(GPR_U32(ctx, 4), 6644), GPR_U32(ctx, 3));
    // 0x18f138: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_18f13c:
    // 0x18f13c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18f144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18f148; return;
}


// Function: ExecuteOids__5CMpeg
// Address: 0x18f148 - 0x18f170

void entry_18f170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f170: 0x12200003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_18f180(rdram, ctx, runtime); return;
    }
    // 0x18f178: 0xc063c66
    SET_GPR_U32(ctx, 31, 0x18f180);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Execute__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_18f180
// Address: 0x18f180 - 0x18f198

void entry_18f180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f180: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18f184: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f188: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f18c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18f194: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18f198; return;
}


// Function: Execute__5CMpeg
// Address: 0x18f198 - 0x18f1c4

void entry_18f1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f1c4: 0xc063904
    SET_GPR_U32(ctx, 31, 0x18f1cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0018e410(rdram, ctx, runtime); return;
}


// Function: entry_18f1cc
// Address: 0x18f1cc - 0x18f1e0

void entry_18f1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f1cc: 0x3c05002c
    SET_GPR_U32(ctx, 5, ((uint32_t)44 << 16));
    // 0x18f1d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f1d4: 0xae420000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    // 0x18f1d8: 0xc04bf3c
    SET_GPR_U32(ctx, 31, 0x18f1e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 15104));
    fn___18CBinaryAsyncStreamPv(rdram, ctx, runtime); return;
}


// Function: entry_18f1e0
// Address: 0x18f1e0 - 0x18f1e8

void entry_18f1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f1e0: 0xc063504
    SET_GPR_U32(ctx, 31, 0x18f1e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_18f1e8
// Address: 0x18f1e8 - 0x18f200

void entry_18f1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f1e8) {
        switch (ctx->pc) {
            case 0x18f1f8: ctx->pc = 0; goto label_18f1f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f1e8: 0x56200007
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x18F208; return;
    }
    // 0x18f1f0: 0x1000000d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F228; return;
    }
label_18f1f8:
    // 0x18f1f8: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x18f200);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2335));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_18f200
// Address: 0x18f200 - 0x18f23c

void entry_18f200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f200) {
        switch (ctx->pc) {
            case 0x18f208: ctx->pc = 0; goto label_18f208;
            case 0x18f228: ctx->pc = 0; goto label_18f228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f200: 0x1000005a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294935696));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F36C; return;
    }
label_18f208:
    // 0x18f208: 0x8e24001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x18f20c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x18f210: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x18f214: 0x441026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18f218: 0xafa20034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 2));
    // 0x18f21c: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x18f220: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x18f224: 0xafa30030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 3));
label_18f228:
    // 0x18f228: 0x10400069
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F3D0; return;
    }
    // 0x18f230: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f234: 0xc04bf5e
    SET_GPR_U32(ctx, 31, 0x18f23c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    FOpenFile__18CBinaryAsyncStreamP13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_18f23c
// Address: 0x18f23c - 0x18f250

void entry_18f23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f23c: 0x10400064
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F3D0; return;
    }
    // 0x18f244: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x18f248: 0xc063d12
    SET_GPR_U32(ctx, 31, 0x18f250);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Start__5CMpegP18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_18f250
// Address: 0x18f250 - 0x18f270

void entry_18f250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f250) {
        switch (ctx->pc) {
            case 0x18f260: ctx->pc = 0; goto label_18f260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f250: 0x3c140025
    SET_GPR_U32(ctx, 20, ((uint32_t)37 << 16));
    // 0x18f254: 0x10000041
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18f35c(rdram, ctx, runtime); return;
    }
    // 0x18f25c: 0x0
    // NOP
label_18f260:
    // 0x18f260: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18f264: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x18f268: 0xc050c0c
    SET_GPR_U32(ctx, 31, 0x18f270);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6232));
    MarkClockTickRealOnly__FP5CLOCK(rdram, ctx, runtime); return;
}


// Function: entry_18f270
// Address: 0x18f270 - 0x18f278

void entry_18f270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f270: 0xc05b88e
    SET_GPR_U32(ctx, 31, 0x18f278);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 11376));
    UpdateJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_18f278
// Address: 0x18f278 - 0x18f320

void entry_18f278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f278) {
        switch (ctx->pc) {
            case 0x18f28c: ctx->pc = 0; goto label_18f28c;
            case 0x18f2a4: ctx->pc = 0; goto label_18f2a4;
            case 0x18f2c0: ctx->pc = 0; goto label_18f2c0;
            case 0x18f2d0: ctx->pc = 0; goto label_18f2d0;
            case 0x18f2e8: ctx->pc = 0; goto label_18f2e8;
            case 0x18f2ec: ctx->pc = 0; goto label_18f2ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f278: 0x26828490
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294935696));
    // 0x18f27c: 0x16220003
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_18f28c;
    }
    // 0x18f284: 0x1000000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f2c0;
    }
label_18f28c:
    // 0x18f28c: 0x1220000c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_18f2c0;
    }
    // 0x18f294: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_18f2a4;
    }
    // 0x18f29c: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f2c0;
    }
label_18f2a4:
    // 0x18f2a4: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x18f2a8: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x18f2ac: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x18f2b0: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18f2b4: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18f2b8: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18f2bc: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_18f2c0:
    // 0x18f2c0: 0x10600003
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18f2d0;
    }
    // 0x18f2c8: 0x8c439b4c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294941516)));
    // 0x18f2cc: 0x3382b
    SET_GPR_U32(ctx, 7, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_18f2d0:
    // 0x18f2d0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18f2d4: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x18f2d8: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18f2e8;
    }
    // 0x18f2e0: 0x10000002
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f2ec;
    }
label_18f2e8:
    // 0x18f2e8: 0x623004
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 3) & 0x1F));
label_18f2ec:
    // 0x18f2ec: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x18f2f0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18f2f4: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x18f2f8: 0x8c6219f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6648)));
    // 0x18f2fc: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x18f300: 0xa2380b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 5));
    // 0x18f304: 0x10e0000c
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F338; return;
    }
    // 0x18f30c: 0x26102c70
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 11376));
    // 0x18f310: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x18f314: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f318: 0xc07c03c
    SET_GPR_U32(ctx, 31, 0x18f320);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    FCatchWipeButtonTrans__FP4WIPEP3JOY5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_18f320
// Address: 0x18f320 - 0x18f340

void entry_18f320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f320) {
        switch (ctx->pc) {
            case 0x18f338: ctx->pc = 0; goto label_18f338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f320: 0x14400012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294935696));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F36C; return;
    }
    // 0x18f328: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
    // 0x18f32c: 0x3042091f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2335));
    // 0x18f330: 0x1440ffb1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F1F8; return;
    }
label_18f338:
    // 0x18f338: 0xc050278
    SET_GPR_U32(ctx, 31, 0x18f340);
    UpdateCd__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18f340
// Address: 0x18f340 - 0x18f35c

void entry_18f340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f340: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18f344: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18f348: 0x8c4313ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 5100)));
    // 0x18f34c: 0x14640007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294935696));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x18F36C; return;
    }
    // 0x18f354: 0xc063dba
    SET_GPR_U32(ctx, 31, 0x18f35c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Update__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_18f35c
// Address: 0x18f35c - 0x18f364

void entry_18f35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f35c: 0xc082c2c
    SET_GPR_U32(ctx, 31, 0x18f364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    sceMpegIsEnd(rdram, ctx, runtime); return;
}


// Function: entry_18f364
// Address: 0x18f364 - 0x18f3c0

void entry_18f364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f364) {
        switch (ctx->pc) {
            case 0x18f36c: ctx->pc = 0; goto label_18f36c;
            case 0x18f38c: ctx->pc = 0; goto label_18f38c;
            case 0x18f3a8: ctx->pc = 0; goto label_18f3a8;
            case 0x18f3b8: ctx->pc = 0; goto label_18f3b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f364: 0x1040ffbe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 4294935696));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F260; return;
    }
label_18f36c:
    // 0x18f36c: 0x1222000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_18f3a8;
    }
    // 0x18f374: 0x1220000c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_18f3a8;
    }
    // 0x18f37c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_18f38c;
    }
    // 0x18f384: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f3a8;
    }
label_18f38c:
    // 0x18f38c: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x18f390: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x18f394: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x18f398: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18f39c: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x18f3a0: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18f3a4: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_18f3a8:
    // 0x18f3a8: 0x10600003
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18f3b8;
    }
    // 0x18f3b0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18f3b4: 0xac629b4c
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294941516), GPR_U32(ctx, 2));
label_18f3b8:
    // 0x18f3b8: 0xc063df4
    SET_GPR_U32(ctx, 31, 0x18f3c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Finish__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_18f3c0
// Address: 0x18f3c0 - 0x18f3c8

void entry_18f3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f3c0: 0xc04bf7a
    SET_GPR_U32(ctx, 31, 0x18f3c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Close__18CBinaryAsyncStream(rdram, ctx, runtime); return;
}


// Function: entry_18f3c8
// Address: 0x18f3c8 - 0x18f410

void entry_18f3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f3c8) {
        switch (ctx->pc) {
            case 0x18f3d0: ctx->pc = 0; goto label_18f3d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f3c8: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_18f410(rdram, ctx, runtime); return;
    }
label_18f3d0:
    // 0x18f3d0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x18f3d4: 0x2404007b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    // 0x18f3d8: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x18f3dc: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x18f3e0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x18f3e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f3e8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x18f3ec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x18f3f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f3f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18f3f8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x18f3fc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f400: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x18f404: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f408: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x18f410);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_18f410
// Address: 0x18f410 - 0x18f418

void entry_18f410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f410: 0xc0647ac
    SET_GPR_U32(ctx, 31, 0x18f418);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    ClearPhase__F5PHASE(rdram, ctx, runtime); return;
}


// Function: entry_18f418
// Address: 0x18f418 - 0x18f424

void entry_18f418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f418: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x18f41c: 0xc04bf4c
    SET_GPR_U32(ctx, 31, 0x18f424);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x12fd30; return;
}


// Function: entry_18f424
// Address: 0x18f424 - 0x18f448

void entry_18f424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f424: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18f428: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x18f42c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x18f430: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x18f434: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x18f438: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x18f43c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18f444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18f448; return;
}


// Function: Start__5CMpegP18CBinaryAsyncStream
// Address: 0x18f448 - 0x18f494

void entry_18f494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f494: 0x26300010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 16));
    // 0x18f498: 0xc063a50
    SET_GPR_U32(ctx, 31, 0x18f4a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 128));
    Init__10CMpegAudio(rdram, ctx, runtime); return;
}


// Function: entry_18f4a0
// Address: 0x18f4a0 - 0x18f4a8

void entry_18f4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f4a0: 0xc082b68
    SET_GPR_U32(ctx, 31, 0x18f4a8);
    FUN_0020ada0(rdram, ctx, runtime); return;
}


// Function: entry_18f4a8
// Address: 0x18f4a8 - 0x18f4bc

void entry_18f4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f4a8: 0x8e250058
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    // 0x18f4ac: 0x3c060015
    SET_GPR_U32(ctx, 6, ((uint32_t)21 << 16));
    // 0x18f4b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f4b4: 0xc082b90
    SET_GPR_U32(ctx, 31, 0x18f4bc);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 12136));
    sceMpegCreate(rdram, ctx, runtime); return;
}


// Function: entry_18f4bc
// Address: 0x18f4bc - 0x18f4d8

void entry_18f4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f4bc: 0x3c070019
    SET_GPR_U32(ctx, 7, ((uint32_t)25 << 16));
    // 0x18f4c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f4c4: 0x24e7ec40
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294962240));
    // 0x18f4c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f4cc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f4d0: 0xc08294e
    SET_GPR_U32(ctx, 31, 0x18f4d8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceMpegAddStrCallback(rdram, ctx, runtime); return;
}


// Function: entry_18f4d8
// Address: 0x18f4d8 - 0x18f4f4

void entry_18f4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f4d8: 0x3c070019
    SET_GPR_U32(ctx, 7, ((uint32_t)25 << 16));
    // 0x18f4dc: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x18f4e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f4e4: 0x24e7ec80
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294962304));
    // 0x18f4e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f4ec: 0xc08294e
    SET_GPR_U32(ctx, 31, 0x18f4f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    sceMpegAddStrCallback(rdram, ctx, runtime); return;
}


// Function: entry_18f4f4
// Address: 0x18f4f4 - 0x18f50c

void entry_18f4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f4f4: 0x3c060019
    SET_GPR_U32(ctx, 6, ((uint32_t)25 << 16));
    // 0x18f4f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f4fc: 0x24c6eca8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294962344));
    // 0x18f500: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18f504: 0xc082c5a
    SET_GPR_U32(ctx, 31, 0x18f50c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceMpegAddCallback(rdram, ctx, runtime); return;
}


// Function: entry_18f50c
// Address: 0x18f50c - 0x18f524

void entry_18f50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f50c: 0x3c060019
    SET_GPR_U32(ctx, 6, ((uint32_t)25 << 16));
    // 0x18f510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f514: 0x24c6ed78
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294962552));
    // 0x18f518: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x18f51c: 0xc082c5a
    SET_GPR_U32(ctx, 31, 0x18f524);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceMpegAddCallback(rdram, ctx, runtime); return;
}


// Function: entry_18f524
// Address: 0x18f524 - 0x18f53c

void entry_18f524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f524: 0x3c060019
    SET_GPR_U32(ctx, 6, ((uint32_t)25 << 16));
    // 0x18f528: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f52c: 0x24c6eda0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294962592));
    // 0x18f530: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f534: 0xc082c5a
    SET_GPR_U32(ctx, 31, 0x18f53c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceMpegAddCallback(rdram, ctx, runtime); return;
}


// Function: entry_18f53c
// Address: 0x18f53c - 0x18f548

void entry_18f53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f53c) {
        switch (ctx->pc) {
            case 0x18f540: ctx->pc = 0; goto label_18f540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f53c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_18f540:
    // 0x18f540: 0xc063e24
    SET_GPR_U32(ctx, 31, 0x18f548);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    CbDemuxed__5CMpegi(rdram, ctx, runtime); return;
}


// Function: entry_18f548
// Address: 0x18f548 - 0x18f610

void entry_18f548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f548) {
        switch (ctx->pc) {
            case 0x18f5b0: ctx->pc = 0; goto label_18f5b0;
            case 0x18f5c8: ctx->pc = 0; goto label_18f5c8;
            case 0x18f5dc: ctx->pc = 0; goto label_18f5dc;
            case 0x18f5e0: ctx->pc = 0; goto label_18f5e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f548: 0x1440fffd
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F540; return;
    }
    // 0x18f550: 0x3c030058
    SET_GPR_U32(ctx, 3, ((uint32_t)88 << 16));
    // 0x18f554: 0x3c02005a
    SET_GPR_U32(ctx, 2, ((uint32_t)90 << 16));
    // 0x18f558: 0x24636ac0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 27328));
    // 0x18f55c: 0x24422d40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11584));
    // 0x18f560: 0x3c04ffff
    SET_GPR_U32(ctx, 4, ((uint32_t)65535 << 16));
    // 0x18f564: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x18f568: 0xae220118
    WRITE32(ADD32(GPR_U32(ctx, 17), 280), GPR_U32(ctx, 2));
    // 0x18f56c: 0x24a59a00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294941184));
    // 0x18f570: 0xae230114
    WRITE32(ADD32(GPR_U32(ctx, 17), 276), GPR_U32(ctx, 3));
    // 0x18f574: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x18f578: 0x3c070010
    SET_GPR_U32(ctx, 7, ((uint32_t)16 << 16));
    // 0x18f57c: 0x3c060015
    SET_GPR_U32(ctx, 6, ((uint32_t)21 << 16));
    // 0x18f580: 0xaca40138
    WRITE32(ADD32(GPR_U32(ctx, 5), 312), GPR_U32(ctx, 4));
    // 0x18f584: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18f588: 0x34e70010
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 16));
    // 0x18f58c: 0xac4026cc
    WRITE32(ADD32(GPR_U32(ctx, 2), 9932), GPR_U32(ctx, 0));
    // 0x18f590: 0x24c68d68
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937960));
    // 0x18f594: 0x3c08edb8
    SET_GPR_U32(ctx, 8, ((uint32_t)60856 << 16));
    // 0x18f598: 0x3c03005a
    SET_GPR_U32(ctx, 3, ((uint32_t)90 << 16));
    // 0x18f59c: 0xaca7013c
    WRITE32(ADD32(GPR_U32(ctx, 5), 316), GPR_U32(ctx, 7));
    // 0x18f5a0: 0xaca60140
    WRITE32(ADD32(GPR_U32(ctx, 5), 320), GPR_U32(ctx, 6));
    // 0x18f5a4: 0x24692e60
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 3), 11872));
    // 0x18f5a8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f5ac: 0x35088320
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 33568));
label_18f5b0:
    // 0x18f5b0: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x18f5b4: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x18f5b8: 0x43880
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 4), 2));
    // 0x18f5bc: 0x24860001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1));
    // 0x18f5c0: 0x41842
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 4), 1));
    // 0x18f5c4: 0x0
    // NOP
label_18f5c8:
    // 0x18f5c8: 0x30820001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    // 0x18f5cc: 0x10400003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18f5dc;
    }
    // 0x18f5d4: 0x10000002
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f5e0;
    }
label_18f5dc:
    // 0x18f5dc: 0x42042
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 1));
label_18f5e0:
    // 0x18f5e0: 0x4a1fff9
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 4), 1));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_18f5c8;
    }
    // 0x18f5e8: 0x1271821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 7)));
    // 0x18f5ec: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x18f5f0: 0x28e20100
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), 256));
    // 0x18f5f4: 0x1440ffee
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18f5b0;
    }
    // 0x18f5fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18f600: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f604: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f608: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018f610__5CMpeg
// Address: 0x18f610 - 0x18f6e8

void FUN_0018f610__5CMpeg(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f610) {
        switch (ctx->pc) {
            case 0x18f6e0: ctx->pc = 0; goto label_18f6e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f610: 0x80482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18f614: 0x8d270140
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 9), 320)));
    // 0x18f618: 0x18e00031
    SET_GPR_U32(ctx, 4, ((uint32_t)90 << 16));
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_18f6e0;
    }
    // 0x18f620: 0x8d25013c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 9), 316)));
    // 0x18f624: 0x8d230138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 312)));
    // 0x18f628: 0x24842e60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11872));
    // 0x18f62c: 0x90a20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x18f630: 0x24e7fffc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294967292));
    // 0x18f634: 0x33202
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 3), 8));
    // 0x18f638: 0x24a80004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 5), 4));
    // 0x18f63c: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18f640: 0x306300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 255));
    // 0x18f644: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18f648: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18f64c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18f650: 0x461026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x18f654: 0xad220138
    WRITE32(ADD32(GPR_U32(ctx, 9), 312), GPR_U32(ctx, 2));
    // 0x18f658: 0x23202
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 2), 8));
    // 0x18f65c: 0x90a30001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 1)));
    // 0x18f660: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18f664: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x18f668: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x18f66c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18f670: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18f674: 0xad270140
    WRITE32(ADD32(GPR_U32(ctx, 9), 320), GPR_U32(ctx, 7));
    // 0x18f678: 0x661826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x18f67c: 0xad230138
    WRITE32(ADD32(GPR_U32(ctx, 9), 312), GPR_U32(ctx, 3));
    // 0x18f680: 0x33202
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 3), 8));
    // 0x18f684: 0x90a20002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x18f688: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18f68c: 0x306300ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 255));
    // 0x18f690: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18f694: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x18f698: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18f69c: 0x461026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x18f6a0: 0xad220138
    WRITE32(ADD32(GPR_U32(ctx, 9), 312), GPR_U32(ctx, 2));
    // 0x18f6a4: 0x23202
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 2), 8));
    // 0x18f6a8: 0x90a30003
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 3)));
    // 0x18f6ac: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18f6b0: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x18f6b4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x18f6b8: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x18f6bc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18f6c0: 0xad28013c
    WRITE32(ADD32(GPR_U32(ctx, 9), 316), GPR_U32(ctx, 8));
    // 0x18f6c4: 0x661826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x18f6c8: 0x14e00005
    WRITE32(ADD32(GPR_U32(ctx, 9), 312), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        goto label_18f6e0;
    }
    // 0x18f6d0: 0x10600003
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18f6e0;
    }
    // 0x18f6d8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18f6dc: 0xac629b48
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294941512), GPR_U32(ctx, 2));
label_18f6e0:
    // 0x18f6e0: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Update__5CMpeg
// Address: 0x18f6e8 - 0x18f720

void entry_18f720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f720) {
        switch (ctx->pc) {
            case 0x18f730: ctx->pc = 0; goto label_18f730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f720: 0x8e030134
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 308)));
    // 0x18f724: 0x1071fffc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x18F718; return;
    }
    // 0x18f72c: 0x8e05005c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 92)));
label_18f730:
    // 0x18f730: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x18f734: 0xc082c16
    SET_GPR_U32(ctx, 31, 0x18f73c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1200));
    sceMpegGetPicture(rdram, ctx, runtime); return;
}


// Function: entry_18f73c
// Address: 0x18f73c - 0x18f764

void entry_18f73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f73c: 0x4400020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x18F7C0; return;
    }
    // 0x18f744: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x18f748: 0x1440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_18f77c(rdram, ctx, runtime); return;
    }
    // 0x18f750: 0x8e040114
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 276)));
    // 0x18f754: 0x8e05005c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 92)));
    // 0x18f758: 0x8e060010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x18f75c: 0xc063b6a
    SET_GPR_U32(ctx, 31, 0x18f764);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    BuildMpegGifs__FP2QWP11sceIpuRGB32iiiii(rdram, ctx, runtime); return;
}


// Function: entry_18f764
// Address: 0x18f764 - 0x18f774

void entry_18f764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f764: 0x8e040118
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 280)));
    // 0x18f768: 0x8e050010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x18f76c: 0xc063bde
    SET_GPR_U32(ctx, 31, 0x18f774);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_0018ef78(rdram, ctx, runtime); return;
}


// Function: entry_18f774
// Address: 0x18f774 - 0x18f77c

void entry_18f774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f774: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x18f77c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_18f77c
// Address: 0x18f77c - 0x18f798

void entry_18f77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f77c) {
        switch (ctx->pc) {
            case 0x18f790: ctx->pc = 0; goto label_18f790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f77c: 0x8e020134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 308)));
    // 0x18f780: 0x1040000a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F7AC; return;
    }
    // 0x18f788: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f78c: 0x0
    // NOP
label_18f790:
    // 0x18f790: 0xc063e24
    SET_GPR_U32(ctx, 31, 0x18f798);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CbDemuxed__5CMpegi(rdram, ctx, runtime); return;
}


// Function: entry_18f798
// Address: 0x18f798 - 0x18f7a0

void entry_18f798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f798: 0xc063d84
    SET_GPR_U32(ctx, 31, 0x18f7a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0018f610__5CMpeg(rdram, ctx, runtime); return;
}


// Function: entry_18f7a0
// Address: 0x18f7a0 - 0x18f7b4

void entry_18f7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f7a0) {
        switch (ctx->pc) {
            case 0x18f7ac: ctx->pc = 0; goto label_18f7ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f7a0: 0x8e020134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 308)));
    // 0x18f7a4: 0x1440fffa
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F790; return;
    }
label_18f7ac:
    // 0x18f7ac: 0xc07dad0
    SET_GPR_U32(ctx, 31, 0x18f7b4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 304)));
    SignalSema(rdram, ctx, runtime); return;
}


// Function: entry_18f7b4
// Address: 0x18f7b4 - 0x18f7bc

void entry_18f7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f7b4: 0xc063ae6
    SET_GPR_U32(ctx, 31, 0x18f7bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Update__10CMpegAudio(rdram, ctx, runtime); return;
}


// Function: entry_18f7bc
// Address: 0x18f7bc - 0x18f7d0

void entry_18f7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f7bc) {
        switch (ctx->pc) {
            case 0x18f7c0: ctx->pc = 0; goto label_18f7c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f7bc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_18f7c0:
    // 0x18f7c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f7c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f7c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Finish__5CMpeg
// Address: 0x18f7d0 - 0x18f7fc

void entry_18f7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f7fc: 0xc063aa8
    SET_GPR_U32(ctx, 31, 0x18f804);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Close__10CMpegAudio(rdram, ctx, runtime); return;
}


// Function: entry_18f804
// Address: 0x18f804 - 0x18f80c

void entry_18f804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f804: 0xc082c30
    SET_GPR_U32(ctx, 31, 0x18f80c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceMpegReset(rdram, ctx, runtime); return;
}


// Function: entry_18f80c
// Address: 0x18f80c - 0x18f814

void entry_18f80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f80c: 0xc082c12
    SET_GPR_U32(ctx, 31, 0x18f814);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SyncVBlank1(rdram, ctx, runtime); return;
}


// Function: entry_18f814
// Address: 0x18f814 - 0x18f848

void entry_18f814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f814) {
        switch (ctx->pc) {
            case 0x18f820: ctx->pc = 0; goto label_18f820;
            case 0x18f83c: ctx->pc = 0; goto label_18f83c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f814: 0x8e430134
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 308)));
    // 0x18f818: 0x10600008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_18f83c;
    }
label_18f820:
    // 0x18f820: 0x8e420134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 308)));
    // 0x18f824: 0x0
    // NOP
    // 0x18f828: 0x0
    // NOP
    // 0x18f82c: 0x0
    // NOP
    // 0x18f830: 0x0
    // NOP
    // 0x18f834: 0x1440fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18f820;
    }
label_18f83c:
    // 0x18f83c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x18f840: 0xc06cd14
    SET_GPR_U32(ctx, 31, 0x18f848);
    WRITE32(ADD32(GPR_U32(ctx, 3), 9932), GPR_U32(ctx, 2));
    UploadPermShaders__Fv(rdram, ctx, runtime); return;
}


// Function: entry_18f848
// Address: 0x18f848 - 0x18f890

void entry_18f848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f848) {
        switch (ctx->pc) {
            case 0x18f860: ctx->pc = 0; goto label_18f860;
            case 0x18f864: ctx->pc = 0; goto label_18f864;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f848: 0x8e440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18f84c: 0x2c820010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 16));
    // 0x18f850: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18f860;
    }
    // 0x18f858: 0x10000002
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18f864;
    }
label_18f860:
    // 0x18f860: 0x828004
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 4) & 0x1F));
label_18f864:
    // 0x18f864: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18f868: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x18f86c: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x18f870: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18f874: 0x8c8319f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6648)));
    // 0x18f878: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f87c: 0x701825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x18f880: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f884: 0xac8319f8
    WRITE32(ADD32(GPR_U32(ctx, 4), 6648), GPR_U32(ctx, 3));
    // 0x18f888: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CbDemuxed__5CMpegi
// Address: 0x18f890 - 0x18f8b8

void entry_18f8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f8b8) {
        switch (ctx->pc) {
            case 0x18f8d4: ctx->pc = 0; goto label_18f8d4;
            case 0x18f8e0: ctx->pc = 0; goto label_18f8e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f8b8: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x18f8bc: 0x8c440020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x18f8c0: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x18f8c4: 0x14640006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_18f8e0;
    }
    // 0x18f8cc: 0x12000015
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18F924; return;
    }
label_18f8d4:
    // 0x18f8d4: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x18f8d8: 0x8c440020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x18f8dc: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
label_18f8e0:
    // 0x18f8e0: 0x1064fff3
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x18F8B0; return;
    }
    // 0x18f8e8: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x18f8f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_18f8f0
// Address: 0x18f8f0 - 0x18f910

void entry_18f8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f8f0: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x18f8f4: 0x26240010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 16));
    // 0x18f8f8: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x18f8fc: 0x8c45001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x18f900: 0x8c460018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x18f904: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x18f908: 0xc082946
    SET_GPR_U32(ctx, 31, 0x18f910);
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    sceMpegDemuxPss(rdram, ctx, runtime); return;
}


// Function: entry_18f910
// Address: 0x18f910 - 0x18f920

void entry_18f910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f910: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x18f914: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x18f918: 0xc04c036
    SET_GPR_U32(ctx, 31, 0x18f920);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Skip__18CBinaryAsyncStreami(rdram, ctx, runtime); return;
}


// Function: entry_18f920
// Address: 0x18f920 - 0x18f938

void entry_18f920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18f920) {
        switch (ctx->pc) {
            case 0x18f924: ctx->pc = 0; goto label_18f924;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18f920: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_18f924:
    // 0x18f924: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x18f928: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f92c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f930: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0018F938
// Address: 0x18f938 - 0x18f940

void FUN_0018f968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f968: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x18f96c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18f970: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x18f974: 0xc063e50
    SET_GPR_U32(ctx, 31, 0x18f97c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    mpeg__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_18f97c
// Address: 0x18f97c - 0x18f988

void entry_18f97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f97c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f980: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitMrkv__FP4MRKV
// Address: 0x18f988 - 0x18f99c

void entry_18f99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f99c: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x18f9a0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x18f9a4: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x18f9a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18f9ac: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18f9b0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18f9b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18f9b8: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x18f9bc: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x18f9c0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x18f9c8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_18f9c8
// Address: 0x18f9c8 - 0x18f9d8

void entry_18f9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18f9c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18f9cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18f9d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderMsGlobset__FP2MSP2CMP2RO
// Address: 0x18f9d8 - 0x18fa28

void entry_18fa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18fa28: 0x24030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 52));
    // 0x18fa2c: 0x3c020016
    SET_GPR_U32(ctx, 2, ((uint32_t)22 << 16));
    // 0x18fa30: 0xafa300d0
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 3));
    // 0x18fa34: 0x24426690
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 26256));
    // 0x18fa38: 0x2663022c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 556));
    // 0x18fa3c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x18fa40: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x18fa44: 0x26640140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 320));
    // 0x18fa48: 0xafa30074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 3));
    // 0x18fa4c: 0x26650110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 272));
    // 0x18fa50: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x18fa58);
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 19));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_18fa58
// Address: 0x18fa58 - 0x18faa0

void entry_18fa58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18fa58: 0x8e630238
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 568)));
    // 0x18fa5c: 0x24020033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 51));
    // 0x18fa60: 0x8fa700d0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18fa64: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x18fa68: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x18fa6c: 0x8e65023c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 572)));
    // 0x18fa70: 0x62380a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 3));
    // 0x18fa74: 0x24060028
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 40));
    // 0x18fa78: 0xafa700d0
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 7));
    // 0x18fa7c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fa80: 0x8e670240
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 576)));
    // 0x18fa84: 0x8fa200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18fa88: 0x440018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fa8c: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x18fa90: 0x460018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fa94: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x18fa98: 0xc07090c
    SET_GPR_U32(ctx, 31, 0x18faa0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    LoadSprBuf__Fie(rdram, ctx, runtime); return;
}


// Function: entry_18faa0
// Address: 0x18faa0 - 0x18facc

void entry_18faa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18faa0) {
        switch (ctx->pc) {
            case 0x18fab0: ctx->pc = 0; goto label_18fab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18faa0: 0x8e620238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 568)));
    // 0x18faa4: 0x18400109
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x18FECC; return;
    }
    // 0x18faac: 0x0
    // NOP
label_18fab0:
    // 0x18fab0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x18fab4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fab8: 0x8c441f24
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7972)));
    // 0x18fabc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fac0: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x18fac4: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x18facc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 80));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_18facc
// Address: 0x18facc - 0x18fb54

void entry_18facc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18facc: 0x241e0034
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 52));
    // 0x18fad0: 0x8fa200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18fad4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x18fad8: 0x8e234990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 18832)));
    // 0x18fadc: 0x261048f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 18672));
    // 0x18fae0: 0x2c2b821
    SET_GPR_U32(ctx, 23, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x18fae4: 0x240d0002
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 2));
    // 0x18fae8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x18faec: 0x240c0033
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 51));
    // 0x18faf0: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18faf4: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x18faf8: 0x521818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fafc: 0xae224990
    WRITE32(ADD32(GPR_U32(ctx, 17), 18832), GPR_U32(ctx, 2));
    // 0x18fb00: 0x24060028
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 40));
    // 0x18fb04: 0x2e47018
    { int64_t result = (int64_t)GPR_S32(ctx, 23) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb08: 0x2e67818
    { int64_t result = (int64_t)GPR_S32(ctx, 23) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb0c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fb10: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fb14: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fb18: 0x2031821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x18fb1c: 0xac6d004c
    WRITE32(ADD32(GPR_U32(ctx, 3), 76), GPR_U32(ctx, 13));
    // 0x18fb20: 0x8e620238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 568)));
    // 0x18fb24: 0x8e65023c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 572)));
    // 0x18fb28: 0x571023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x18fb2c: 0x8e670240
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 576)));
    // 0x18fb30: 0x182602a
    SET_GPR_U32(ctx, 12, SLT32(GPR_S32(ctx, 12), GPR_S32(ctx, 2)));
    // 0x18fb34: 0xae2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 14)));
    // 0x18fb38: 0x4cf00a
    if (GPR_U32(ctx, 12) == 0) SET_GPR_U32(ctx, 30, GPR_U32(ctx, 2));
    // 0x18fb3c: 0x3c40018
    { int64_t result = (int64_t)GPR_S32(ctx, 30) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb40: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x18fb44: 0x3c60018
    { int64_t result = (int64_t)GPR_S32(ctx, 30) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb48: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x18fb4c: 0xc07090c
    SET_GPR_U32(ctx, 31, 0x18fb54);
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 15)));
    LoadSprBuf__Fie(rdram, ctx, runtime); return;
}


// Function: entry_18fb54
// Address: 0x18fb54 - 0x18fc28

void entry_18fb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fb54) {
        switch (ctx->pc) {
            case 0x18fb88: ctx->pc = 0; goto label_18fb88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fb54: 0x8e224990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 18832)));
    // 0x18fb58: 0x26100008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    // 0x18fb5c: 0x521018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb60: 0x24430004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4));
    // 0x18fb64: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x18fb68: 0x701821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x18fb6c: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18fb70: 0xafa200d8
    WRITE32(ADD32(GPR_U32(ctx, 29), 216), GPR_U32(ctx, 2));
    // 0x18fb74: 0x8fa200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x18fb78: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18fb7c: 0x184000cd
    WRITE32(ADD32(GPR_U32(ctx, 29), 220), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x18FEB4; return;
    }
    // 0x18fb84: 0x8fa200dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 220)));
label_18fb88:
    // 0x18fb88: 0x24030028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    // 0x18fb8c: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x18fb90: 0x72839000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 3); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fb94: 0x8fa300d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 212)));
    // 0x18fb98: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x18fb9c: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x18fba0: 0x144300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x18FEA4; return;
    }
    // 0x18fba8: 0x8fa300d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 216)));
    // 0x18fbac: 0x24020070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 112));
    // 0x18fbb0: 0xdaa60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 64)));
    // 0x18fbb4: 0x4be001d3
    // Unhandled VU0 Special1 function: 0x13
    // 0x18fbb8: 0x600013
    ctx->lo = GPR_U32(ctx, 3);
    // 0x18fbbc: 0xdaa50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 80)));
    // 0x18fbc0: 0x72828800
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fbc4: 0xdaa40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 96)));
    // 0x18fbc8: 0xdaa30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 112)));
    // 0x18fbcc: 0xc62c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[12] = *(float*)&val; }
    // 0x18fbd0: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x18fbd4: 0x44076000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[12]);
    // 0x18fbd8: 0x4be610ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18fbdc: 0x48a70800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 7));
    // 0x18fbe0: 0x4be229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x18fbe4: 0x4be220bd
    { float val = (float)ctx->vi[31]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18fbe8: 0x4be218be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[31], ctx->vu0_vf[31], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x18fbec: 0x4be138fc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x18fbf0: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18fbf4: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18fbf8: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18fbfc: 0x4a0002ff
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x18fc00: 0x48428800
    SET_GPR_U32(ctx, 2, ctx->vu0_cmsar3);
    // 0x18fc04: 0x384200f0
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 240));
    // 0x18fc08: 0x144000a5
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FEA0; return;
    }
    // 0x18fc10: 0xc62d001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[13] = *(float*)&val; }
    // 0x18fc14: 0x48251000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18fc18: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18fc1c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18fc20: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x18fc28);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_18fc28
// Address: 0x18fc28 - 0x18fc64

void entry_18fc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18fc28: 0x1040009d
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FEA0; return;
    }
    // 0x18fc30: 0x8e220060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x18fc34: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FC84; return;
    }
    // 0x18fc3c: 0xc62d0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[13] = *(float*)&val; }
    // 0x18fc40: 0xc620001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[0] = *(float*)&val; }
    // 0x18fc44: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fc48: 0x0
    // NOP
    // 0x18fc4c: 0x45000009
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[2]));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x18FC74; return;
    }
    // 0x18fc54: 0xc62c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[12] = *(float*)&val; }
    // 0x18fc58: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18fc5c: 0xc0514ec
    SET_GPR_U32(ctx, 31, 0x18fc64);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 84));
    FInsideCmMrd(rdram, ctx, runtime); return;
}


// Function: entry_18fc64
// Address: 0x18fc64 - 0x18fcec

void entry_18fc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fc64) {
        switch (ctx->pc) {
            case 0x18fc74: ctx->pc = 0; goto label_18fc74;
            case 0x18fc80: ctx->pc = 0; goto label_18fc80;
            case 0x18fc84: ctx->pc = 0; goto label_18fc84;
            case 0x18fcb0: ctx->pc = 0; goto label_18fcb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fc64: 0x14400006
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18fc80;
    }
    // 0x18fc6c: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18fc80;
    }
label_18fc74:
    // 0x18fc74: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18fc78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x18fc7c: 0xe7a00054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
label_18fc80:
    // 0x18fc80: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_18fc84:
    // 0x18fc84: 0xc6410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[1] = *(float*)&val; }
    // 0x18fc88: 0x24441858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x18fc8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18fc90: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x18fc94: 0xc4800010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 16)); ctx->f[0] = *(float*)&val; }
    // 0x18fc98: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fc9c: 0x0
    // NOP
    // 0x18fca0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[12] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18fcb0;
    }
    // 0x18fca8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x18fcac: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_18fcb0:
    // 0x18fcb0: 0x460c6832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[13], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fcb4: 0x0
    // NOP
    // 0x18fcb8: 0x45030010
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x18FCFC; return;
    }
    // 0x18fcc0: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x18fcc4: 0x2961821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 22)));
    // 0x18fcc8: 0x621818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fccc: 0x8e700240
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 576)));
    // 0x18fcd0: 0xc48e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[14] = *(float*)&val; }
    // 0x18fcd4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x18fcd8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x18fcdc: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18fce0: 0x24849b50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941520));
    // 0x18fce4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x18fcec);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_18fcec
// Address: 0x18fcec - 0x18fe0c

void entry_18fcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fcec) {
        switch (ctx->pc) {
            case 0x18fcfc: ctx->pc = 0; goto label_18fcfc;
            case 0x18fd6c: ctx->pc = 0; goto label_18fd6c;
            case 0x18fd88: ctx->pc = 0; goto label_18fd88;
            case 0x18fde4: ctx->pc = 0; goto label_18fde4;
            case 0x18fde8: ctx->pc = 0; goto label_18fde8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fcec: 0xe6400010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    // 0x18fcf0: 0xe6000010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    // 0x18fcf4: 0xdba200e0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x18fcf8: 0xc6400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[0] = *(float*)&val; }
label_18fcfc:
    // 0x18fcfc: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x18fd00: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x18fd04: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x18fd08: 0x46020836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fd0c: 0x0
    // NOP
    // 0x18fd10: 0x45010063
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x18FEA0; return;
    }
    // 0x18fd18: 0x2962821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 22)));
    // 0x18fd1c: 0x24060070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 112));
    // 0x18fd20: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x18fd24: 0xa63018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fd28: 0xa22818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x18fd2c: 0x8e63023c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 572)));
    // 0x18fd30: 0x8e640240
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 576)));
    // 0x18fd34: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x18fd38: 0xc440b5e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948320)); ctx->f[0] = *(float*)&val; }
    // 0x18fd3c: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x18fd40: 0x852021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x18fd44: 0xafa30078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 3));
    // 0x18fd48: 0xafa4007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 4));
    // 0x18fd4c: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x18fd50: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x18fd54: 0xc6210024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 36)); ctx->f[1] = *(float*)&val; }
    // 0x18fd58: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fd5c: 0x45010003
    if ((ctx->fcr31 & 0x800000)) {
        goto label_18fd6c;
    }
    // 0x18fd64: 0x10000008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18fd88;
    }
label_18fd6c:
    // 0x18fd6c: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18fd70: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x18fd74: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x18fd78: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x18fd7c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x18fd80: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x18fd84: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
label_18fd88:
    // 0x18fd88: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x18fd8c: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x18fd90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x18fd94: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x18fd98: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x18fd9c: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x18fda0: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x18fda4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x18fda8: 0x4500000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_18fde8;
    }
    // 0x18fdb0: 0x2443fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967293));
    // 0x18fdb4: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x18fdb8: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18fde8;
    }
    // 0x18fdc0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x18fdc4: 0x2442b5f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948336));
    // 0x18fdc8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x18fdcc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18fdd0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x18fdd8: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_18fde4;
    }
    // 0x18fde0: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
label_18fde4:
    // 0x18fde4: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
label_18fde8:
    // 0x18fde8: 0x8e240038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    // 0x18fdec: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 104)));
        ctx->pc = 0x18FE10; return;
    }
    // 0x18fdf4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x18fdf8: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18fdfc: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_18fe0c(rdram, ctx, runtime); return;
    }
    // 0x18fe04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x18fe0c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_18fe0c
// Address: 0x18fe0c - 0x18fe20

void entry_18fe0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fe0c) {
        switch (ctx->pc) {
            case 0x18fe10: ctx->pc = 0; goto label_18fe10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fe0c: 0x8e260068
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 104)));
label_18fe10:
    // 0x18fe10: 0x10c0000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FE40; return;
    }
    // 0x18fe18: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x18fe20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_18fe20
// Address: 0x18fe20 - 0x18fe5c

void entry_18fe20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fe20) {
        switch (ctx->pc) {
            case 0x18fe40: ctx->pc = 0; goto label_18fe40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fe20: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x18fe24: 0x7ba300a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x18fe28: 0x7ba400b0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x18fe2c: 0x7ba500c0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x18fe30: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x18fe34: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x18fe38: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x18fe3c: 0x7fa50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 5));
label_18fe40:
    // 0x18fe40: 0x8e260034
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x18fe44: 0x10c00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_18fe5c(rdram, ctx, runtime); return;
    }
    // 0x18fe4c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x18fe50: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x18fe54: 0xc049b7a
    SET_GPR_U32(ctx, 31, 0x18fe5c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    AdjustAloRtckMat__FP3ALOP2CM4RTCKP6VECTORP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_18fe5c
// Address: 0x18fe5c - 0x18fe64

void entry_18fe5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18fe5c: 0xc067504
    SET_GPR_U32(ctx, 31, 0x18fe64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_18fe64
// Address: 0x18fe64 - 0x18fef8

void entry_18fe64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18fe64) {
        switch (ctx->pc) {
            case 0x18fe7c: ctx->pc = 0; goto label_18fe7c;
            case 0x18fea0: ctx->pc = 0; goto label_18fea0;
            case 0x18fea4: ctx->pc = 0; goto label_18fea4;
            case 0x18feb4: ctx->pc = 0; goto label_18feb4;
            case 0x18fecc: ctx->pc = 0; goto label_18fecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18fe64: 0x8e220068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 104)));
    // 0x18fe68: 0x14400004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_18fe7c;
    }
    // 0x18fe70: 0x8e220034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x18fe74: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18fea0;
    }
label_18fe7c:
    // 0x18fe7c: 0x24428400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935552));
    // 0x18fe80: 0x78460030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x18fe84: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x18fe88: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x18fe8c: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x18fe90: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x18fe94: 0x7fa40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 4));
    // 0x18fe98: 0x7fa50030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 5));
    // 0x18fe9c: 0x7fa60040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 6));
label_18fea0:
    // 0x18fea0: 0x8fa300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 208)));
label_18fea4:
    // 0x18fea4: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x18fea8: 0x283102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 3)));
    // 0x18feac: 0x1440ff36
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 220)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FB88; return;
    }
label_18feb4:
    // 0x18feb4: 0x8e620238
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 568)));
    // 0x18feb8: 0x2e0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x18febc: 0x2c2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), GPR_S32(ctx, 2)));
    // 0x18fec0: 0x1440fefb
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 30));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x18FAB0; return;
    }
    // 0x18fec8: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
label_18fecc:
    // 0x18fecc: 0x7bbe0170
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x18fed0: 0x7bb70160
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x18fed4: 0x7bb60150
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x18fed8: 0x7bb50140
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x18fedc: 0x7bb40130
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x18fee0: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x18fee4: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x18fee8: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x18feec: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x18fef0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitMurray__FP6MURRAY
// Address: 0x18fef8 - 0x18ff0c

void entry_18ff0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff0c: 0xae000bd0
    WRITE32(ADD32(GPR_U32(ctx, 16), 3024), GPR_U32(ctx, 0));
    // 0x18ff10: 0xae000bd4
    WRITE32(ADD32(GPR_U32(ctx, 16), 3028), GPR_U32(ctx, 0));
    // 0x18ff14: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ff18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ff1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x18ff24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x18ff28; return;
}


// Function: PostMurrayLoad__FP6MURRAY
// Address: 0x18ff28 - 0x18ff3c

void entry_18ff3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff3c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x18ff40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff44: 0x24c69b60
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294941536));
    // 0x18ff48: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x18ff50);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_18ff50
// Address: 0x18ff50 - 0x18ff5c

void entry_18ff50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff54: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18ff5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 239));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ff5c
// Address: 0x18ff5c - 0x18ff6c

void entry_18ff5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff60: 0xae0205f0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1520), GPR_U32(ctx, 2));
    // 0x18ff64: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18ff6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 364));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ff6c
// Address: 0x18ff6c - 0x18ff7c

void entry_18ff6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff70: 0xae020c38
    WRITE32(ADD32(GPR_U32(ctx, 16), 3128), GPR_U32(ctx, 2));
    // 0x18ff74: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18ff7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 365));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ff7c
// Address: 0x18ff7c - 0x18ff8c

void entry_18ff7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff80: 0xae020c3c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3132), GPR_U32(ctx, 2));
    // 0x18ff84: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18ff8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 362));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ff8c
// Address: 0x18ff8c - 0x18ff9c

void entry_18ff8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x18ff90: 0xae020c40
    WRITE32(ADD32(GPR_U32(ctx, 16), 3136), GPR_U32(ctx, 2));
    // 0x18ff94: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x18ff9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 363));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_18ff9c
// Address: 0x18ff9c - 0x18ffb0

void entry_18ff9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x18ff9c: 0xae020c44
    WRITE32(ADD32(GPR_U32(ctx, 16), 3140), GPR_U32(ctx, 2));
    // 0x18ffa0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x18ffa4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x18ffa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0018ffb0
// Address: 0x18ffb0 - 0x190058

void FUN_0018ffb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x18ffb0) {
        switch (ctx->pc) {
            case 0x18fff8: ctx->pc = 0; goto label_18fff8;
            case 0x19000c: ctx->pc = 0; goto label_19000c;
            case 0x190018: ctx->pc = 0; goto label_190018;
            case 0x190030: ctx->pc = 0; goto label_190030;
            case 0x190044: ctx->pc = 0; goto label_190044;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x18ffb0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x18ffb4: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x18ffb8: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x18ffbc: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x18ffc0: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x18ffc4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x18ffc8: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x18ffcc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x18ffd0: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x18ffd4: 0x10620016
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_190030;
    }
    // 0x18ffdc: 0x2862000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 12));
    // 0x18ffe0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_18fff8;
    }
    // 0x18ffe8: 0x10620008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19000c;
    }
    // 0x18fff0: 0x1000001b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190060; return;
    }
label_18fff8:
    // 0x18fff8: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x18fffc: 0x10620006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_190018;
    }
    // 0x190004: 0x10000016
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190060; return;
    }
label_19000c:
    // 0x19000c: 0xae000c28
    WRITE32(ADD32(GPR_U32(ctx, 16), 3112), GPR_U32(ctx, 0));
    // 0x190010: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 16), 3088), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_190058(rdram, ctx, runtime); return;
    }
label_190018:
    // 0x190018: 0x8e030c30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3120)));
    // 0x19001c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x190020: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 3132)));
        entry_190058(rdram, ctx, runtime); return;
    }
    // 0x190028: 0x1000000b
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 3140)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_190058(rdram, ctx, runtime); return;
    }
label_190030:
    // 0x190030: 0x8e030c30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3120)));
    // 0x190034: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x190038: 0x54620002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 3128)));
        goto label_190044;
    }
    // 0x190040: 0x8e110c40
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 3136)));
label_190044:
    // 0x190044: 0x8e040720
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
    // 0x190048: 0x10800004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19005C; return;
    }
    // 0x190050: 0xc072dbe
    SET_GPR_U32(ctx, 31, 0x190058);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveSggGuard__FP3SGGP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_190058
// Address: 0x190058 - 0x190068

void entry_180020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180020 inside entry_17ffe8 (0x17ffe8 - 0x180068)
    ctx->pc = 0x180020;
    entry_17ffe8(rdram, ctx, runtime);
}

void entry_180044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180044 inside entry_17ffe8 (0x17ffe8 - 0x180068)
    ctx->pc = 0x180044;
    entry_17ffe8(rdram, ctx, runtime);
}

void entry_180060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180060 inside entry_17ffe8 (0x17ffe8 - 0x180068)
    ctx->pc = 0x180060;
    entry_17ffe8(rdram, ctx, runtime);
}

void entry_180088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180088 inside entry_180074 (0x180074 - 0x180098)
    ctx->pc = 0x180088;
    entry_180074(rdram, ctx, runtime);
}

void entry_1800c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1800c8 inside entry_1800b4 (0x1800b4 - 0x180108)
    ctx->pc = 0x1800c8;
    entry_1800b4(rdram, ctx, runtime);
}

void entry_1801c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1801c0 inside entry_1801bc (0x1801bc - 0x1801ec)
    ctx->pc = 0x1801c0;
    entry_1801bc(rdram, ctx, runtime);
}

void entry_180204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180204 inside entry_1801ec (0x1801ec - 0x180248)
    ctx->pc = 0x180204;
    entry_1801ec(rdram, ctx, runtime);
}

void entry_18020c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18020c inside entry_1801ec (0x1801ec - 0x180248)
    ctx->pc = 0x18020c;
    entry_1801ec(rdram, ctx, runtime);
}

void entry_1802a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1802a8 inside entry_18026c (0x18026c - 0x1802e8)
    ctx->pc = 0x1802a8;
    entry_18026c(rdram, ctx, runtime);
}

void entry_1802c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1802c0 inside entry_18026c (0x18026c - 0x1802e8)
    ctx->pc = 0x1802c0;
    entry_18026c(rdram, ctx, runtime);
}

void entry_180344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180344 inside entry_180328 (0x180328 - 0x180398)
    ctx->pc = 0x180344;
    entry_180328(rdram, ctx, runtime);
}

void entry_1804d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1804d8 inside entry_18048c (0x18048c - 0x1805bc)
    ctx->pc = 0x1804d8;
    entry_18048c(rdram, ctx, runtime);
}

void entry_180548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180548 inside entry_18048c (0x18048c - 0x1805bc)
    ctx->pc = 0x180548;
    entry_18048c(rdram, ctx, runtime);
}

void entry_180558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180558 inside entry_18048c (0x18048c - 0x1805bc)
    ctx->pc = 0x180558;
    entry_18048c(rdram, ctx, runtime);
}

void entry_180584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180584 inside entry_18048c (0x18048c - 0x1805bc)
    ctx->pc = 0x180584;
    entry_18048c(rdram, ctx, runtime);
}

void entry_1805a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1805a0 inside entry_18048c (0x18048c - 0x1805bc)
    ctx->pc = 0x1805a0;
    entry_18048c(rdram, ctx, runtime);
}

void entry_180608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180608 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180608;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_18065c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18065c inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x18065c;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180690 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180690;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1806b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1806b8 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1806b8;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1806d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1806d0 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1806d0;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180708 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180708;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180730 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180730;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180748 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180748;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180780 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180780;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1807a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1807a8 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1807a8;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1807c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1807c0 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1807c0;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1807f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1807f8 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1807f8;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180820 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180820;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180844 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180844;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180884 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x180884;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_1808a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1808a0 inside entry_1805fc (0x1805fc - 0x1808bc)
    ctx->pc = 0x1808a0;
    entry_1805fc(rdram, ctx, runtime);
}

void entry_180938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180938 inside entry_1808ec (0x1808ec - 0x18096c)
    ctx->pc = 0x180938;
    entry_1808ec(rdram, ctx, runtime);
}

void entry_180948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180948 inside entry_1808ec (0x1808ec - 0x18096c)
    ctx->pc = 0x180948;
    entry_1808ec(rdram, ctx, runtime);
}

void entry_180a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180a04 inside entry_1809b0 (0x1809b0 - 0x180a50)
    ctx->pc = 0x180a04;
    entry_1809b0(rdram, ctx, runtime);
}

void entry_180a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180a08 inside entry_1809b0 (0x1809b0 - 0x180a50)
    ctx->pc = 0x180a08;
    entry_1809b0(rdram, ctx, runtime);
}

void entry_180a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180a0c inside entry_1809b0 (0x1809b0 - 0x180a50)
    ctx->pc = 0x180a0c;
    entry_1809b0(rdram, ctx, runtime);
}

void entry_180a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180a2c inside entry_1809b0 (0x1809b0 - 0x180a50)
    ctx->pc = 0x180a2c;
    entry_1809b0(rdram, ctx, runtime);
}

void entry_180e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x180e88 inside keyhole__static_initialization_and_destruction_0 (0x180e38 - 0x180e90)
    ctx->pc = 0x180e88;
    keyhole__static_initialization_and_destruction_0(rdram, ctx, runtime);
}

void entry_1810e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1810e4 inside entry_1810c4 (0x1810c4 - 0x1810fc)
    ctx->pc = 0x1810e4;
    entry_1810c4(rdram, ctx, runtime);
}

void entry_181104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181104 inside entry_1810fc (0x1810fc - 0x18110c)
    ctx->pc = 0x181104;
    entry_1810fc(rdram, ctx, runtime);
}

void entry_181114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181114 inside entry_18110c (0x18110c - 0x181134)
    ctx->pc = 0x181114;
    entry_18110c(rdram, ctx, runtime);
}

void entry_18113c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18113c inside entry_181134 (0x181134 - 0x181150)
    ctx->pc = 0x18113c;
    entry_181134(rdram, ctx, runtime);
}

void entry_18115c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18115c inside entry_181150 (0x181150 - 0x18119c)
    ctx->pc = 0x18115c;
    entry_181150(rdram, ctx, runtime);
}

void entry_1811c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1811c4 inside entry_1811c0 (0x1811c0 - 0x181214)
    ctx->pc = 0x1811c4;
    entry_1811c0(rdram, ctx, runtime);
}

void entry_1811c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1811c8 inside entry_1811c0 (0x1811c0 - 0x181214)
    ctx->pc = 0x1811c8;
    entry_1811c0(rdram, ctx, runtime);
}

void entry_1811f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1811f0 inside entry_1811c0 (0x1811c0 - 0x181214)
    ctx->pc = 0x1811f0;
    entry_1811c0(rdram, ctx, runtime);
}

void entry_181208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181208 inside entry_1811c0 (0x1811c0 - 0x181214)
    ctx->pc = 0x181208;
    entry_1811c0(rdram, ctx, runtime);
}

void entry_181280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181280 inside entry_181214 (0x181214 - 0x1812c0)
    ctx->pc = 0x181280;
    entry_181214(rdram, ctx, runtime);
}

void entry_18128c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18128c inside entry_181214 (0x181214 - 0x1812c0)
    ctx->pc = 0x18128c;
    entry_181214(rdram, ctx, runtime);
}

void entry_181428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181428 inside entry_181424 (0x181424 - 0x181448)
    ctx->pc = 0x181428;
    entry_181424(rdram, ctx, runtime);
}

void entry_1814b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1814b0 inside entry_181490 (0x181490 - 0x181504)
    ctx->pc = 0x1814b0;
    entry_181490(rdram, ctx, runtime);
}

void entry_1814c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1814c8 inside entry_181490 (0x181490 - 0x181504)
    ctx->pc = 0x1814c8;
    entry_181490(rdram, ctx, runtime);
}

void entry_1814f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1814f8 inside entry_181490 (0x181490 - 0x181504)
    ctx->pc = 0x1814f8;
    entry_181490(rdram, ctx, runtime);
}

void entry_181508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181508 inside entry_181504 (0x181504 - 0x181524)
    ctx->pc = 0x181508;
    entry_181504(rdram, ctx, runtime);
}

void entry_18152c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18152c inside entry_181524 (0x181524 - 0x181540)
    ctx->pc = 0x18152c;
    entry_181524(rdram, ctx, runtime);
}

void entry_181544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181544 inside entry_181540 (0x181540 - 0x181558)
    ctx->pc = 0x181544;
    entry_181540(rdram, ctx, runtime);
}

void entry_181560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181560 inside entry_181558 (0x181558 - 0x1815d0)
    ctx->pc = 0x181560;
    entry_181558(rdram, ctx, runtime);
}

void entry_1815ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1815ac inside entry_181558 (0x181558 - 0x1815d0)
    ctx->pc = 0x1815ac;
    entry_181558(rdram, ctx, runtime);
}

void entry_1815c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1815c0 inside entry_181558 (0x181558 - 0x1815d0)
    ctx->pc = 0x1815c0;
    entry_181558(rdram, ctx, runtime);
}

void entry_181620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181620 inside entry_1815e4 (0x1815e4 - 0x181658)
    ctx->pc = 0x181620;
    entry_1815e4(rdram, ctx, runtime);
}

void entry_181768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181768 inside entry_181764 (0x181764 - 0x181780)
    ctx->pc = 0x181768;
    entry_181764(rdram, ctx, runtime);
}

void entry_18176c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18176c inside entry_181764 (0x181764 - 0x181780)
    ctx->pc = 0x18176c;
    entry_181764(rdram, ctx, runtime);
}

void entry_1817e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1817e8 inside entry_1817bc (0x1817bc - 0x181800)
    ctx->pc = 0x1817e8;
    entry_1817bc(rdram, ctx, runtime);
}

void entry_181804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181804 inside entry_181800 (0x181800 - 0x181818)
    ctx->pc = 0x181804;
    entry_181800(rdram, ctx, runtime);
}

void entry_181880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181880 inside RenderLgnAll__FP3LGNP2CMP2RO (0x181818 - 0x1818a4)
    ctx->pc = 0x181880;
    RenderLgnAll__FP3LGNP2CMP2RO(rdram, ctx, runtime);
}

void entry_181888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181888 inside RenderLgnAll__FP3LGNP2CMP2RO (0x181818 - 0x1818a4)
    ctx->pc = 0x181888;
    RenderLgnAll__FP3LGNP2CMP2RO(rdram, ctx, runtime);
}

void entry_181900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181900 inside entry_1818a4 (0x1818a4 - 0x181a2c)
    ctx->pc = 0x181900;
    entry_1818a4(rdram, ctx, runtime);
}

void entry_181944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181944 inside entry_1818a4 (0x1818a4 - 0x181a2c)
    ctx->pc = 0x181944;
    entry_1818a4(rdram, ctx, runtime);
}

void entry_181954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181954 inside entry_1818a4 (0x1818a4 - 0x181a2c)
    ctx->pc = 0x181954;
    entry_1818a4(rdram, ctx, runtime);
}

void entry_181a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181a08 inside entry_1818a4 (0x1818a4 - 0x181a2c)
    ctx->pc = 0x181a08;
    entry_1818a4(rdram, ctx, runtime);
}

void entry_181a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181a20 inside entry_1818a4 (0x1818a4 - 0x181a2c)
    ctx->pc = 0x181a20;
    entry_1818a4(rdram, ctx, runtime);
}

void entry_181ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181ad0 inside entry_181ac4 (0x181ac4 - 0x181ae0)
    ctx->pc = 0x181ad0;
    entry_181ac4(rdram, ctx, runtime);
}

void entry_181c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181c10 inside entry_181c04 (0x181c04 - 0x181c20)
    ctx->pc = 0x181c10;
    entry_181c04(rdram, ctx, runtime);
}

void entry_181c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181c3c inside entry_181c20 (0x181c20 - 0x181c44)
    ctx->pc = 0x181c3c;
    entry_181c20(rdram, ctx, runtime);
}

void entry_181c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181c4c inside entry_181c44 (0x181c44 - 0x181c58)
    ctx->pc = 0x181c4c;
    entry_181c44(rdram, ctx, runtime);
}

void entry_181ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181ce8 inside entry_181ce4 (0x181ce4 - 0x181d08)
    ctx->pc = 0x181ce8;
    entry_181ce4(rdram, ctx, runtime);
}

void entry_181d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181d0c inside entry_181d08 (0x181d08 - 0x181d28)
    ctx->pc = 0x181d0c;
    entry_181d08(rdram, ctx, runtime);
}

void entry_181d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181d6c inside HandleLgnMessage__FP3LGN5MSGIDPv (0x181d28 - 0x181d7c)
    ctx->pc = 0x181d6c;
    HandleLgnMessage__FP3LGN5MSGIDPv(rdram, ctx, runtime);
}

void entry_181d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181d74 inside HandleLgnMessage__FP3LGN5MSGIDPv (0x181d28 - 0x181d7c)
    ctx->pc = 0x181d74;
    HandleLgnMessage__FP3LGN5MSGIDPv(rdram, ctx, runtime);
}

void entry_181df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181df0 inside SetLgnLgns__FP3LGN4LGNS (0x181da8 - 0x181e34)
    ctx->pc = 0x181df0;
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime);
}

void entry_181df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181df4 inside SetLgnLgns__FP3LGN4LGNS (0x181da8 - 0x181e34)
    ctx->pc = 0x181df4;
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime);
}

void entry_181e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e14 inside SetLgnLgns__FP3LGN4LGNS (0x181da8 - 0x181e34)
    ctx->pc = 0x181e14;
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime);
}

void entry_181e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e2c inside SetLgnLgns__FP3LGN4LGNS (0x181da8 - 0x181e34)
    ctx->pc = 0x181e2c;
    SetLgnLgns__FP3LGN4LGNS(rdram, ctx, runtime);
}

void entry_181e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e3c inside entry_181e34 (0x181e34 - 0x181e48)
    ctx->pc = 0x181e3c;
    entry_181e34(rdram, ctx, runtime);
}

void entry_181e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e50 inside entry_181e48 (0x181e48 - 0x181e68)
    ctx->pc = 0x181e50;
    entry_181e48(rdram, ctx, runtime);
}

void entry_181e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e5c inside entry_181e48 (0x181e48 - 0x181e68)
    ctx->pc = 0x181e5c;
    entry_181e48(rdram, ctx, runtime);
}

void entry_181e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e60 inside entry_181e48 (0x181e48 - 0x181e68)
    ctx->pc = 0x181e60;
    entry_181e48(rdram, ctx, runtime);
}

void entry_181e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e74 inside entry_181e68 (0x181e68 - 0x181ed0)
    ctx->pc = 0x181e74;
    entry_181e68(rdram, ctx, runtime);
}

void entry_181e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181e9c inside entry_181e68 (0x181e68 - 0x181ed0)
    ctx->pc = 0x181e9c;
    entry_181e68(rdram, ctx, runtime);
}

void entry_181ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181ea0 inside entry_181e68 (0x181e68 - 0x181ed0)
    ctx->pc = 0x181ea0;
    entry_181e68(rdram, ctx, runtime);
}

void entry_181ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181ea4 inside entry_181e68 (0x181e68 - 0x181ed0)
    ctx->pc = 0x181ea4;
    entry_181e68(rdram, ctx, runtime);
}

void entry_181eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181eb4 inside entry_181e68 (0x181e68 - 0x181ed0)
    ctx->pc = 0x181eb4;
    entry_181e68(rdram, ctx, runtime);
}

void entry_181f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181f78 inside UpdateLgnrAim__FP4LGNRP3JOY (0x181ed0 - 0x181f80)
    ctx->pc = 0x181f78;
    UpdateLgnrAim__FP4LGNRP3JOY(rdram, ctx, runtime);
}

void entry_181ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x181ff4 inside entry_181f90 (0x181f90 - 0x182060)
    ctx->pc = 0x181ff4;
    entry_181f90(rdram, ctx, runtime);
}

void entry_182028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182028 inside entry_181f90 (0x181f90 - 0x182060)
    ctx->pc = 0x182028;
    entry_181f90(rdram, ctx, runtime);
}

void entry_182030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182030 inside entry_181f90 (0x181f90 - 0x182060)
    ctx->pc = 0x182030;
    entry_181f90(rdram, ctx, runtime);
}

void entry_182034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182034 inside entry_181f90 (0x181f90 - 0x182060)
    ctx->pc = 0x182034;
    entry_181f90(rdram, ctx, runtime);
}

void entry_18203c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18203c inside entry_181f90 (0x181f90 - 0x182060)
    ctx->pc = 0x18203c;
    entry_181f90(rdram, ctx, runtime);
}

void entry_182080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182080 inside entry_182060 (0x182060 - 0x182094)
    ctx->pc = 0x182080;
    entry_182060(rdram, ctx, runtime);
}

void entry_1820d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1820d8 inside entry_182094 (0x182094 - 0x182170)
    ctx->pc = 0x1820d8;
    entry_182094(rdram, ctx, runtime);
}

void entry_1820e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1820e8 inside entry_182094 (0x182094 - 0x182170)
    ctx->pc = 0x1820e8;
    entry_182094(rdram, ctx, runtime);
}

void entry_182130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182130 inside entry_182094 (0x182094 - 0x182170)
    ctx->pc = 0x182130;
    entry_182094(rdram, ctx, runtime);
}

void entry_182140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182140 inside entry_182094 (0x182094 - 0x182170)
    ctx->pc = 0x182140;
    entry_182094(rdram, ctx, runtime);
}

void entry_182214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182214 inside entry_182200 (0x182200 - 0x182244)
    ctx->pc = 0x182214;
    entry_182200(rdram, ctx, runtime);
}

void entry_18222c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18222c inside entry_182200 (0x182200 - 0x182244)
    ctx->pc = 0x18222c;
    entry_182200(rdram, ctx, runtime);
}

void entry_182248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182248 inside entry_182244 (0x182244 - 0x1822b8)
    ctx->pc = 0x182248;
    entry_182244(rdram, ctx, runtime);
}

void entry_182370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182370 inside entry_18233c (0x18233c - 0x1823e0)
    ctx->pc = 0x182370;
    entry_18233c(rdram, ctx, runtime);
}

void entry_182438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182438 inside entry_182428 (0x182428 - 0x182470)
    ctx->pc = 0x182438;
    entry_182428(rdram, ctx, runtime);
}

void entry_182598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182598 inside entry_182590 (0x182590 - 0x1825e8)
    ctx->pc = 0x182598;
    entry_182590(rdram, ctx, runtime);
}

void entry_1825c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1825c4 inside entry_182590 (0x182590 - 0x1825e8)
    ctx->pc = 0x1825c4;
    entry_182590(rdram, ctx, runtime);
}

void entry_1825d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1825d4 inside entry_182590 (0x182590 - 0x1825e8)
    ctx->pc = 0x1825d4;
    entry_182590(rdram, ctx, runtime);
}

void entry_18260c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18260c inside entry_182604 (0x182604 - 0x1826ac)
    ctx->pc = 0x18260c;
    entry_182604(rdram, ctx, runtime);
}

void entry_182660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182660 inside entry_182604 (0x182604 - 0x1826ac)
    ctx->pc = 0x182660;
    entry_182604(rdram, ctx, runtime);
}

void entry_182678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182678 inside entry_182604 (0x182604 - 0x1826ac)
    ctx->pc = 0x182678;
    entry_182604(rdram, ctx, runtime);
}

void entry_1826f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1826f4 inside entry_1826ec (0x1826ec - 0x182724)
    ctx->pc = 0x1826f4;
    entry_1826ec(rdram, ctx, runtime);
}

void entry_182730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182730 inside entry_18272c (0x18272c - 0x182748)
    ctx->pc = 0x182730;
    entry_18272c(rdram, ctx, runtime);
}

void entry_1828c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1828c8 inside entry_182888 (0x182888 - 0x1828e8)
    ctx->pc = 0x1828c8;
    entry_182888(rdram, ctx, runtime);
}

void entry_182900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182900 inside entry_1828e8 (0x1828e8 - 0x182920)
    ctx->pc = 0x182900;
    entry_1828e8(rdram, ctx, runtime);
}

void entry_182924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182924 inside entry_182920 (0x182920 - 0x182948)
    ctx->pc = 0x182924;
    entry_182920(rdram, ctx, runtime);
}

void entry_1829e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1829e8 inside entry_1829d0 (0x1829d0 - 0x182a1c)
    ctx->pc = 0x1829e8;
    entry_1829d0(rdram, ctx, runtime);
}

void entry_182acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182acc inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182acc;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182ae8 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182ae8;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182b08 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182b08;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182b30 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182b30;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182b54 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182b54;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182b68 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182b68;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182b90 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182b90;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182ba0 inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182ba0;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182bbc inside entry_182ab0 (0x182ab0 - 0x182bcc)
    ctx->pc = 0x182bbc;
    entry_182ab0(rdram, ctx, runtime);
}

void entry_182ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182ca8 inside AddLo__FP2LO (0x182c80 - 0x182cb4)
    ctx->pc = 0x182ca8;
    AddLo__FP2LO(rdram, ctx, runtime);
}

void entry_182cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182cec inside entry_182ce8 (0x182ce8 - 0x182d00)
    ctx->pc = 0x182cec;
    entry_182ce8(rdram, ctx, runtime);
}

void entry_182d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182d78 inside RemoveLo__FP2LO (0x182d50 - 0x182d84)
    ctx->pc = 0x182d78;
    RemoveLo__FP2LO(rdram, ctx, runtime);
}

void entry_182dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182dbc inside entry_182db4 (0x182db4 - 0x182dc4)
    ctx->pc = 0x182dbc;
    entry_182db4(rdram, ctx, runtime);
}

void entry_182dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182dc8 inside entry_182dc4 (0x182dc4 - 0x182dd8)
    ctx->pc = 0x182dc8;
    entry_182dc4(rdram, ctx, runtime);
}

void entry_182e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182e04 inside DeferLoRemove__FP2LO (0x182dd8 - 0x182e14)
    ctx->pc = 0x182e04;
    DeferLoRemove__FP2LO(rdram, ctx, runtime);
}

void entry_182e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182e2c inside entry_182e14 (0x182e14 - 0x182e40)
    ctx->pc = 0x182e2c;
    entry_182e14(rdram, ctx, runtime);
}

void entry_182e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182e78 inside entry_182e74 (0x182e74 - 0x182e88)
    ctx->pc = 0x182e78;
    entry_182e74(rdram, ctx, runtime);
}

void entry_182f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182f10 inside entry_182f0c (0x182f0c - 0x182f1c)
    ctx->pc = 0x182f10;
    entry_182f0c(rdram, ctx, runtime);
}

void entry_182f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182f30 inside entry_182f2c (0x182f2c - 0x182f40)
    ctx->pc = 0x182f30;
    entry_182f2c(rdram, ctx, runtime);
}

void entry_182f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182f50 inside FFindLoParent__FP2LOP3ALO (0x182f40 - 0x182f78)
    ctx->pc = 0x182f50;
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime);
}

void entry_182f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182f58 inside FFindLoParent__FP2LOP3ALO (0x182f40 - 0x182f78)
    ctx->pc = 0x182f58;
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime);
}

void entry_182fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182fe0 inside FIsLoInWorld__FP2LO (0x182fc8 - 0x182ff8)
    ctx->pc = 0x182fe0;
    FIsLoInWorld__FP2LO(rdram, ctx, runtime);
}

void entry_182ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x182ff0 inside FIsLoInWorld__FP2LO (0x182fc8 - 0x182ff8)
    ctx->pc = 0x182ff0;
    FIsLoInWorld__FP2LO(rdram, ctx, runtime);
}

void entry_183008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183008 inside entry_182ff8 (0x182ff8 - 0x183028)
    ctx->pc = 0x183008;
    entry_182ff8(rdram, ctx, runtime);
}

void entry_183010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183010 inside entry_182ff8 (0x182ff8 - 0x183028)
    ctx->pc = 0x183010;
    entry_182ff8(rdram, ctx, runtime);
}

void entry_183014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183014 inside entry_182ff8 (0x182ff8 - 0x183028)
    ctx->pc = 0x183014;
    entry_182ff8(rdram, ctx, runtime);
}

void entry_183248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183248 inside UnsubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv (0x183238 - 0x183284)
    ctx->pc = 0x183248;
    UnsubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv(rdram, ctx, runtime);
}

void entry_18324c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18324c inside UnsubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv (0x183238 - 0x183284)
    ctx->pc = 0x18324c;
    UnsubscribeSwPpmqStruct__FP2SWPP2MQPFPv5MSGIDPv_vPv(rdram, ctx, runtime);
}

void entry_183288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183288 inside entry_183284 (0x183284 - 0x183290)
    ctx->pc = 0x183288;
    entry_183284(rdram, ctx, runtime);
}

void entry_183398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183398 inside entry_183384 (0x183384 - 0x1833ac)
    ctx->pc = 0x183398;
    entry_183384(rdram, ctx, runtime);
}

void entry_1833b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1833b8 inside entry_1833ac (0x1833ac - 0x1833d0)
    ctx->pc = 0x1833b8;
    entry_1833ac(rdram, ctx, runtime);
}

void entry_183404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183404 inside FMatchesLoName__FP2LO3OID (0x1833f0 - 0x183438)
    ctx->pc = 0x183404;
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime);
}

void entry_183424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183424 inside FMatchesLoName__FP2LO3OID (0x1833f0 - 0x183438)
    ctx->pc = 0x183424;
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime);
}

void entry_18342c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18342c inside FMatchesLoName__FP2LO3OID (0x1833f0 - 0x183438)
    ctx->pc = 0x18342c;
    FMatchesLoName__FP2LO3OID(rdram, ctx, runtime);
}

void entry_18344c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18344c inside OidProxyLo__FP2LO (0x183438 - 0x183458)
    ctx->pc = 0x18344c;
    OidProxyLo__FP2LO(rdram, ctx, runtime);
}

void entry_18346c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18346c inside OidProxyLoPreferred__FP2LO (0x183458 - 0x183478)
    ctx->pc = 0x18346c;
    OidProxyLoPreferred__FP2LO(rdram, ctx, runtime);
}

void entry_183544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183544 inside entry_18353c (0x18353c - 0x18354c)
    ctx->pc = 0x183544;
    entry_18353c(rdram, ctx, runtime);
}

void entry_1835b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1835b8 inside entry_1835a0 (0x1835a0 - 0x1835cc)
    ctx->pc = 0x1835b8;
    entry_1835a0(rdram, ctx, runtime);
}

void entry_1835f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1835f0 inside entry_1835e4 (0x1835e4 - 0x183600)
    ctx->pc = 0x1835f0;
    entry_1835e4(rdram, ctx, runtime);
}

void entry_183640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183640 inside entry_18363c (0x18363c - 0x183668)
    ctx->pc = 0x183640;
    entry_18363c(rdram, ctx, runtime);
}

void entry_1836dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1836dc inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x1836dc;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_1836f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1836f4 inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x1836f4;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_18370c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18370c inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x18370c;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_183738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183738 inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x183738;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_183770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183770 inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x183770;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_18379c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18379c inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x18379c;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_1837ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837ac inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x1837ac;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_1837b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837b0 inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x1837b0;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_1837b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837b4 inside FFilterSpliceEvent__FP2LO7SYMEVIDiPPv (0x183668 - 0x1837bc)
    ctx->pc = 0x1837b4;
    FFilterSpliceEvent__FP2LO7SYMEVIDiPPv(rdram, ctx, runtime);
}

void entry_1837c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837c4 inside entry_1837bc (0x1837bc - 0x1837e0)
    ctx->pc = 0x1837c4;
    entry_1837bc(rdram, ctx, runtime);
}

void entry_1837d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837d0 inside entry_1837bc (0x1837bc - 0x1837e0)
    ctx->pc = 0x1837d0;
    entry_1837bc(rdram, ctx, runtime);
}

void entry_1837d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1837d4 inside entry_1837bc (0x1837bc - 0x1837e0)
    ctx->pc = 0x1837d4;
    entry_1837bc(rdram, ctx, runtime);
}

void entry_183834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183834 inside entry_18382c (0x18382c - 0x183840)
    ctx->pc = 0x183834;
    entry_18382c(rdram, ctx, runtime);
}

void entry_183848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183848 inside entry_183840 (0x183840 - 0x183850)
    ctx->pc = 0x183848;
    entry_183840(rdram, ctx, runtime);
}

void entry_1838c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1838c8 inside entry_1838c0 (0x1838c0 - 0x1838e4)
    ctx->pc = 0x1838c8;
    entry_1838c0(rdram, ctx, runtime);
}

void entry_1838cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1838cc inside entry_1838c0 (0x1838c0 - 0x1838e4)
    ctx->pc = 0x1838cc;
    entry_1838c0(rdram, ctx, runtime);
}

void entry_1838e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1838e8 inside entry_1838e4 (0x1838e4 - 0x1838f0)
    ctx->pc = 0x1838e8;
    entry_1838e4(rdram, ctx, runtime);
}

void entry_1838f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1838f4 inside entry_1838f0 (0x1838f0 - 0x183910)
    ctx->pc = 0x1838f4;
    entry_1838f0(rdram, ctx, runtime);
}

void entry_183e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183e34 inside entry_183e30 (0x183e30 - 0x183e40)
    ctx->pc = 0x183e34;
    entry_183e30(rdram, ctx, runtime);
}

void entry_183edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183edc inside entry_183ec4 (0x183ec4 - 0x183eec)
    ctx->pc = 0x183edc;
    entry_183ec4(rdram, ctx, runtime);
}

void entry_183ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183ef0 inside entry_183eec (0x183eec - 0x183f08)
    ctx->pc = 0x183ef0;
    entry_183eec(rdram, ctx, runtime);
}

void entry_183f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183f2c inside entry_183f28 (0x183f28 - 0x183f40)
    ctx->pc = 0x183f2c;
    entry_183f28(rdram, ctx, runtime);
}

void entry_183fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183fa0 inside entry_183f8c (0x183f8c - 0x183fe0)
    ctx->pc = 0x183fa0;
    entry_183f8c(rdram, ctx, runtime);
}

void entry_183fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x183fb8 inside entry_183f8c (0x183f8c - 0x183fe0)
    ctx->pc = 0x183fb8;
    entry_183f8c(rdram, ctx, runtime);
}

void entry_184068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184068 inside entry_184034 (0x184034 - 0x1840b8)
    ctx->pc = 0x184068;
    entry_184034(rdram, ctx, runtime);
}

void entry_184070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184070 inside entry_184034 (0x184034 - 0x1840b8)
    ctx->pc = 0x184070;
    entry_184034(rdram, ctx, runtime);
}

void entry_184090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184090 inside entry_184034 (0x184034 - 0x1840b8)
    ctx->pc = 0x184090;
    entry_184034(rdram, ctx, runtime);
}

void entry_1841c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1841c8 inside InvalidateLight__FP5LIGHT (0x1841b0 - 0x1841d0)
    ctx->pc = 0x1841c8;
    InvalidateLight__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184254 inside entry_184218 (0x184218 - 0x1842a4)
    ctx->pc = 0x184254;
    entry_184218(rdram, ctx, runtime);
}

void entry_184264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184264 inside entry_184218 (0x184218 - 0x1842a4)
    ctx->pc = 0x184264;
    entry_184218(rdram, ctx, runtime);
}

void entry_184290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184290 inside entry_184218 (0x184218 - 0x1842a4)
    ctx->pc = 0x184290;
    entry_184218(rdram, ctx, runtime);
}

void entry_184294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184294 inside entry_184218 (0x184218 - 0x1842a4)
    ctx->pc = 0x184294;
    entry_184218(rdram, ctx, runtime);
}

void entry_1842fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1842fc inside entry_1842d0 (0x1842d0 - 0x18431c)
    ctx->pc = 0x1842fc;
    entry_1842d0(rdram, ctx, runtime);
}

void entry_184304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184304 inside entry_1842d0 (0x1842d0 - 0x18431c)
    ctx->pc = 0x184304;
    entry_1842d0(rdram, ctx, runtime);
}

void entry_1843c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1843c0 inside entry_184398 (0x184398 - 0x1843e8)
    ctx->pc = 0x1843c0;
    entry_184398(rdram, ctx, runtime);
}

void entry_1843d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1843d0 inside entry_184398 (0x184398 - 0x1843e8)
    ctx->pc = 0x1843d0;
    entry_184398(rdram, ctx, runtime);
}

void entry_184418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184418 inside entry_184410 (0x184410 - 0x184440)
    ctx->pc = 0x184418;
    entry_184410(rdram, ctx, runtime);
}

void entry_184488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184488 inside entry_184480 (0x184480 - 0x1844a0)
    ctx->pc = 0x184488;
    entry_184480(rdram, ctx, runtime);
}

void entry_184538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184538 inside entry_184514 (0x184514 - 0x184628)
    ctx->pc = 0x184538;
    entry_184514(rdram, ctx, runtime);
}

void entry_18468c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18468c inside entry_184680 (0x184680 - 0x1846ac)
    ctx->pc = 0x18468c;
    entry_184680(rdram, ctx, runtime);
}

void entry_1847ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1847ac inside SetLightKind__FP5LIGHT6LIGHTK (0x184768 - 0x1847d4)
    ctx->pc = 0x1847ac;
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime);
}

void entry_1847c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1847c8 inside SetLightKind__FP5LIGHT6LIGHTK (0x184768 - 0x1847d4)
    ctx->pc = 0x1847c8;
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime);
}

void entry_184938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184938 inside SetLightDirection__FP5LIGHTP6VECTOR (0x1848b8 - 0x18494c)
    ctx->pc = 0x184938;
    SetLightDirection__FP5LIGHTP6VECTOR(rdram, ctx, runtime);
}

void entry_184944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184944 inside SetLightDirection__FP5LIGHTP6VECTOR (0x1848b8 - 0x18494c)
    ctx->pc = 0x184944;
    SetLightDirection__FP5LIGHTP6VECTOR(rdram, ctx, runtime);
}

void entry_184988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184988 inside entry_184984 (0x184984 - 0x184990)
    ctx->pc = 0x184988;
    entry_184984(rdram, ctx, runtime);
}

void entry_184abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184abc inside RebuildLightFrustrum__FP5LIGHT (0x184a70 - 0x184afc)
    ctx->pc = 0x184abc;
    RebuildLightFrustrum__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184ae8 inside RebuildLightFrustrum__FP5LIGHT (0x184a70 - 0x184afc)
    ctx->pc = 0x184ae8;
    RebuildLightFrustrum__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184ba0 inside UpdateLightBeamGrfzon__FP5LIGHT (0x184b58 - 0x184bd8)
    ctx->pc = 0x184ba0;
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184bb0 inside UpdateLightBeamGrfzon__FP5LIGHT (0x184b58 - 0x184bd8)
    ctx->pc = 0x184bb0;
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184bc0 inside UpdateLightBeamGrfzon__FP5LIGHT (0x184b58 - 0x184bd8)
    ctx->pc = 0x184bc0;
    UpdateLightBeamGrfzon__FP5LIGHT(rdram, ctx, runtime);
}

void entry_184be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184be0 inside entry_184bd8 (0x184bd8 - 0x184c24)
    ctx->pc = 0x184be0;
    entry_184bd8(rdram, ctx, runtime);
}

void entry_184cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184cbc inside entry_184cb8 (0x184cb8 - 0x184cd0)
    ctx->pc = 0x184cbc;
    entry_184cb8(rdram, ctx, runtime);
}

void entry_184cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184cc0 inside entry_184cb8 (0x184cb8 - 0x184cd0)
    ctx->pc = 0x184cc0;
    entry_184cb8(rdram, ctx, runtime);
}

void entry_184ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184ddc inside NCmpFindLight__FPP5LIGHTT0 (0x184d78 - 0x184de8)
    ctx->pc = 0x184ddc;
    NCmpFindLight__FPP5LIGHTT0(rdram, ctx, runtime);
}

void entry_184e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184e48 inside PrepareSwLightsForDraw__FP2SW (0x184de8 - 0x184e80)
    ctx->pc = 0x184e48;
    PrepareSwLightsForDraw__FP2SW(rdram, ctx, runtime);
}

void entry_184e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184e64 inside PrepareSwLightsForDraw__FP2SW (0x184de8 - 0x184e80)
    ctx->pc = 0x184e64;
    PrepareSwLightsForDraw__FP2SW(rdram, ctx, runtime);
}

void entry_184eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184eb8 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184eb8;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f28 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f28;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f2c inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f2c;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f30 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f30;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f64 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f64;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f7c inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f7c;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f80 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f80;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f90 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f90;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184f94 inside entry_184e80 (0x184e80 - 0x184f9c)
    ctx->pc = 0x184f94;
    entry_184e80(rdram, ctx, runtime);
}

void entry_184ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x184ff0 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x184ff0;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_185020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185020 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x185020;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_185058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185058 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x185058;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_185094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185094 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x185094;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1850a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1850a0 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x1850a0;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1850d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1850d8 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x1850d8;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1850dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1850dc inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x1850dc;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1850e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1850e0 inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x1850e0;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1850ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1850ec inside entry_184fd4 (0x184fd4 - 0x1850f4)
    ctx->pc = 0x1850ec;
    entry_184fd4(rdram, ctx, runtime);
}

void entry_1851b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1851b0 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x1851b0;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_1851f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1851f0 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x1851f0;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185204 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185204;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185254 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185254;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185264 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185264;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185270 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185270;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_18527c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18527c inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x18527c;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185284 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185284;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_1852a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1852a8 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x1852a8;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_1852ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1852ec inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x1852ec;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185300 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185300;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185304 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185304;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_18531c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18531c inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x18531c;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185328 inside TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT (0x185150 - 0x185358)
    ctx->pc = 0x185328;
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime);
}

void entry_185424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185424 inside entry_18541c (0x18541c - 0x185468)
    ctx->pc = 0x185424;
    entry_18541c(rdram, ctx, runtime);
}

void entry_18543c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18543c inside entry_18541c (0x18541c - 0x185468)
    ctx->pc = 0x18543c;
    entry_18541c(rdram, ctx, runtime);
}

void entry_185448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185448 inside entry_18541c (0x18541c - 0x185468)
    ctx->pc = 0x185448;
    entry_18541c(rdram, ctx, runtime);
}

void entry_185484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185484 inside PaloGetActlaTarget__FP5ACTLA (0x185468 - 0x18548c)
    ctx->pc = 0x185484;
    PaloGetActlaTarget__FP5ACTLA(rdram, ctx, runtime);
}

void entry_185500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185500 inside entry_1854b4 (0x1854b4 - 0x185508)
    ctx->pc = 0x185500;
    entry_1854b4(rdram, ctx, runtime);
}

void entry_185524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185524 inside entry_185520 (0x185520 - 0x185538)
    ctx->pc = 0x185524;
    entry_185520(rdram, ctx, runtime);
}

void entry_185594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185594 inside GetActlaRotationGoal__FP5ACTLAfP7MATRIX3P6VECTOR (0x185538 - 0x18559c)
    ctx->pc = 0x185594;
    GetActlaRotationGoal__FP5ACTLAfP7MATRIX3P6VECTOR(rdram, ctx, runtime);
}

void entry_18564c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18564c inside entry_1855fc (0x1855fc - 0x18567c)
    ctx->pc = 0x18564c;
    entry_1855fc(rdram, ctx, runtime);
}

void entry_185670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185670 inside entry_1855fc (0x1855fc - 0x18567c)
    ctx->pc = 0x185670;
    entry_1855fc(rdram, ctx, runtime);
}

void entry_1856bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1856bc inside entry_18567c (0x18567c - 0x185738)
    ctx->pc = 0x1856bc;
    entry_18567c(rdram, ctx, runtime);
}

void entry_1856cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1856cc inside entry_18567c (0x18567c - 0x185738)
    ctx->pc = 0x1856cc;
    entry_18567c(rdram, ctx, runtime);
}

void entry_185710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185710 inside entry_18567c (0x18567c - 0x185738)
    ctx->pc = 0x185710;
    entry_18567c(rdram, ctx, runtime);
}

void entry_185724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185724 inside entry_18567c (0x18567c - 0x185738)
    ctx->pc = 0x185724;
    entry_18567c(rdram, ctx, runtime);
}

void entry_1857c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1857c8 inside entry_1857bc (0x1857bc - 0x1857e8)
    ctx->pc = 0x1857c8;
    entry_1857bc(rdram, ctx, runtime);
}

void entry_1857f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1857f4 inside entry_1857f0 (0x1857f0 - 0x185804)
    ctx->pc = 0x1857f4;
    entry_1857f0(rdram, ctx, runtime);
}

void entry_185840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185840 inside entry_18583c (0x18583c - 0x185850)
    ctx->pc = 0x185840;
    entry_18583c(rdram, ctx, runtime);
}

void entry_1858bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1858bc inside entry_1858b8 (0x1858b8 - 0x1858c4)
    ctx->pc = 0x1858bc;
    entry_1858b8(rdram, ctx, runtime);
}

void entry_185940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185940 inside entry_185934 (0x185934 - 0x185964)
    ctx->pc = 0x185940;
    entry_185934(rdram, ctx, runtime);
}

void entry_18595c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18595c inside entry_185934 (0x185934 - 0x185964)
    ctx->pc = 0x18595c;
    entry_185934(rdram, ctx, runtime);
}

void entry_185970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185970 inside entry_18596c (0x18596c - 0x185978)
    ctx->pc = 0x185970;
    entry_18596c(rdram, ctx, runtime);
}

void entry_185980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185980 inside entry_185978 (0x185978 - 0x185988)
    ctx->pc = 0x185980;
    entry_185978(rdram, ctx, runtime);
}

void entry_1859b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1859b8 inside entry_1859b0 (0x1859b0 - 0x1859dc)
    ctx->pc = 0x1859b8;
    entry_1859b0(rdram, ctx, runtime);
}

void entry_1859d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1859d4 inside entry_1859b0 (0x1859b0 - 0x1859dc)
    ctx->pc = 0x1859d4;
    entry_1859b0(rdram, ctx, runtime);
}

void entry_185a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185a08 inside entry_1859f4 (0x1859f4 - 0x185a1c)
    ctx->pc = 0x185a08;
    entry_1859f4(rdram, ctx, runtime);
}

void entry_185a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185a20 inside entry_185a1c (0x185a1c - 0x185a2c)
    ctx->pc = 0x185a20;
    entry_185a1c(rdram, ctx, runtime);
}

void entry_185bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185bb0 inside entry_185ba0 (0x185ba0 - 0x185bc4)
    ctx->pc = 0x185bb0;
    entry_185ba0(rdram, ctx, runtime);
}

void entry_185c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185c74 inside MuFromAmtlk__FP4MTLK (0x185c18 - 0x185ca0)
    ctx->pc = 0x185c74;
    MuFromAmtlk__FP4MTLK(rdram, ctx, runtime);
}

void entry_185c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185c98 inside MuFromAmtlk__FP4MTLK (0x185c18 - 0x185ca0)
    ctx->pc = 0x185c98;
    MuFromAmtlk__FP4MTLK(rdram, ctx, runtime);
}

void entry_185d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185d08 inside ElasFromAmtlk__FP4MTLK (0x185ca0 - 0x185d20)
    ctx->pc = 0x185d08;
    ElasFromAmtlk__FP4MTLK(rdram, ctx, runtime);
}

void entry_185d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185d18 inside ElasFromAmtlk__FP4MTLK (0x185ca0 - 0x185d20)
    ctx->pc = 0x185d18;
    ElasFromAmtlk__FP4MTLK(rdram, ctx, runtime);
}

void entry_185da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185da8 inside entry_185d84 (0x185d84 - 0x185e54)
    ctx->pc = 0x185da8;
    entry_185d84(rdram, ctx, runtime);
}

void entry_185dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185dc4 inside entry_185d84 (0x185d84 - 0x185e54)
    ctx->pc = 0x185dc4;
    entry_185d84(rdram, ctx, runtime);
}

void entry_185dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185dcc inside entry_185d84 (0x185d84 - 0x185e54)
    ctx->pc = 0x185dcc;
    entry_185d84(rdram, ctx, runtime);
}

void entry_185e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185e18 inside entry_185d84 (0x185d84 - 0x185e54)
    ctx->pc = 0x185e18;
    entry_185d84(rdram, ctx, runtime);
}

void entry_185e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185e44 inside entry_185d84 (0x185d84 - 0x185e54)
    ctx->pc = 0x185e44;
    entry_185d84(rdram, ctx, runtime);
}

void entry_185e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185e60 inside entry_185e54 (0x185e54 - 0x185e7c)
    ctx->pc = 0x185e60;
    entry_185e54(rdram, ctx, runtime);
}

void entry_185ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185ea8 inside entry_185e8c (0x185e8c - 0x185ebc)
    ctx->pc = 0x185ea8;
    entry_185e8c(rdram, ctx, runtime);
}

void entry_185ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185ee4 inside entry_185ee0 (0x185ee0 - 0x185f00)
    ctx->pc = 0x185ee4;
    entry_185ee0(rdram, ctx, runtime);
}

void entry_185f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185f88 inside RecalcSwXpPos__FP2SWiPP2XP (0x185f48 - 0x185ff0)
    ctx->pc = 0x185f88;
    RecalcSwXpPos__FP2SWiPP2XP(rdram, ctx, runtime);
}

void entry_185fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185fb0 inside RecalcSwXpPos__FP2SWiPP2XP (0x185f48 - 0x185ff0)
    ctx->pc = 0x185fb0;
    RecalcSwXpPos__FP2SWiPP2XP(rdram, ctx, runtime);
}

void entry_185fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185fe0 inside RecalcSwXpPos__FP2SWiPP2XP (0x185f48 - 0x185ff0)
    ctx->pc = 0x185fe0;
    RecalcSwXpPos__FP2SWiPP2XP(rdram, ctx, runtime);
}

void entry_185ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x185ff8 inside entry_185ff0 (0x185ff0 - 0x186044)
    ctx->pc = 0x185ff8;
    entry_185ff0(rdram, ctx, runtime);
}

void entry_18600c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18600c inside entry_185ff0 (0x185ff0 - 0x186044)
    ctx->pc = 0x18600c;
    entry_185ff0(rdram, ctx, runtime);
}

void entry_186010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186010 inside entry_185ff0 (0x185ff0 - 0x186044)
    ctx->pc = 0x186010;
    entry_185ff0(rdram, ctx, runtime);
}

void entry_186038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186038 inside entry_185ff0 (0x185ff0 - 0x186044)
    ctx->pc = 0x186038;
    entry_185ff0(rdram, ctx, runtime);
}

void entry_186048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186048 inside entry_186044 (0x186044 - 0x1860a8)
    ctx->pc = 0x186048;
    entry_186044(rdram, ctx, runtime);
}

void entry_186074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186074 inside entry_186044 (0x186044 - 0x1860a8)
    ctx->pc = 0x186074;
    entry_186044(rdram, ctx, runtime);
}

void entry_1860e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1860e0 inside RecalcSwXpMovement__FP2SWiPP2XP (0x1860a8 - 0x186124)
    ctx->pc = 0x1860e0;
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime);
}

void entry_186100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186100 inside RecalcSwXpMovement__FP2SWiPP2XP (0x1860a8 - 0x186124)
    ctx->pc = 0x186100;
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime);
}

void entry_186160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186160 inside entry_18613c (0x18613c - 0x18616c)
    ctx->pc = 0x186160;
    entry_18613c(rdram, ctx, runtime);
}

void entry_186194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186194 inside entry_186190 (0x186190 - 0x1861e8)
    ctx->pc = 0x186194;
    entry_186190(rdram, ctx, runtime);
}

void entry_1861bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1861bc inside entry_186190 (0x186190 - 0x1861e8)
    ctx->pc = 0x1861bc;
    entry_186190(rdram, ctx, runtime);
}

void entry_186208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186208 inside FreeSwXpList__FP2SWP2XP (0x1861e8 - 0x186214)
    ctx->pc = 0x186208;
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime);
}

void entry_18621c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18621c inside entry_186214 (0x186214 - 0x186230)
    ctx->pc = 0x18621c;
    entry_186214(rdram, ctx, runtime);
}

void entry_1862a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1862a0 inside FindClosestPointOnLine__FP6VECTORN20PfT3 (0x186230 - 0x186320)
    ctx->pc = 0x1862a0;
    FindClosestPointOnLine__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_186304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186304 inside FindClosestPointOnLine__FP6VECTORN20PfT3 (0x186230 - 0x186320)
    ctx->pc = 0x186304;
    FindClosestPointOnLine__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_186390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186390 inside FindClosestPointOnLineSegment__FP6VECTORN20PfT3 (0x186320 - 0x186450)
    ctx->pc = 0x186390;
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_1863c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1863c4 inside FindClosestPointOnLineSegment__FP6VECTORN20PfT3 (0x186320 - 0x186450)
    ctx->pc = 0x1863c4;
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_1863f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1863f4 inside FindClosestPointOnLineSegment__FP6VECTORN20PfT3 (0x186320 - 0x186450)
    ctx->pc = 0x1863f4;
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_18641c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18641c inside FindClosestPointOnLineSegment__FP6VECTORN20PfT3 (0x186320 - 0x186450)
    ctx->pc = 0x18641c;
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_186430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186430 inside FindClosestPointOnLineSegment__FP6VECTORN20PfT3 (0x186320 - 0x186450)
    ctx->pc = 0x186430;
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime);
}

void entry_1864a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1864a8 inside ClsgClipSoAllEdges__FP2SOT0P3BSPiP3LSG (0x186450 - 0x1864e0)
    ctx->pc = 0x1864a8;
    ClsgClipSoAllEdges__FP2SOT0P3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_186508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186508 inside entry_1864e0 (0x1864e0 - 0x186568)
    ctx->pc = 0x186508;
    entry_1864e0(rdram, ctx, runtime);
}

void entry_186528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186528 inside entry_1864e0 (0x1864e0 - 0x186568)
    ctx->pc = 0x186528;
    entry_1864e0(rdram, ctx, runtime);
}

void entry_186534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186534 inside entry_1864e0 (0x1864e0 - 0x186568)
    ctx->pc = 0x186534;
    entry_1864e0(rdram, ctx, runtime);
}

void entry_1865d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1865d0 inside ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG (0x186568 - 0x186700)
    ctx->pc = 0x1865d0;
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_186644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186644 inside ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG (0x186568 - 0x186700)
    ctx->pc = 0x186644;
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_18664c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18664c inside ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG (0x186568 - 0x186700)
    ctx->pc = 0x18664c;
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_186660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186660 inside ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG (0x186568 - 0x186700)
    ctx->pc = 0x186660;
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_1866a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1866a8 inside ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG (0x186568 - 0x186700)
    ctx->pc = 0x1866a8;
    ClsgClipSoBspEdges__FP2SOT0iP3BSPiP3LSG(rdram, ctx, runtime);
}

void entry_186728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186728 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186728;
    entry_186700(rdram, ctx, runtime);
}

void entry_186748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186748 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186748;
    entry_186700(rdram, ctx, runtime);
}

void entry_18674c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18674c inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x18674c;
    entry_186700(rdram, ctx, runtime);
}

void entry_186754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186754 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186754;
    entry_186700(rdram, ctx, runtime);
}

void entry_186758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186758 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186758;
    entry_186700(rdram, ctx, runtime);
}

void entry_186764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186764 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186764;
    entry_186700(rdram, ctx, runtime);
}

void entry_186778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186778 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186778;
    entry_186700(rdram, ctx, runtime);
}

void entry_186794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186794 inside entry_186700 (0x186700 - 0x1867c8)
    ctx->pc = 0x186794;
    entry_186700(rdram, ctx, runtime);
}

void entry_186828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186828 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186828;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186850 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186850;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186864 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186864;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_1868b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1868b8 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x1868b8;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_1868f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1868f0 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x1868f0;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_18690c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18690c inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x18690c;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186918 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186918;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_18693c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18693c inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x18693c;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186948 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186948;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186950 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186950;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186960 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186960;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186978 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x186978;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_1869a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1869a0 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x1869a0;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_1869c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1869c8 inside CategorizeAlsg__FiP3LSGPiT2PP3LSGT4 (0x1867c8 - 0x186a04)
    ctx->pc = 0x1869c8;
    CategorizeAlsg__FiP3LSGPiT2PP3LSGT4(rdram, ctx, runtime);
}

void entry_186a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186a20 inside entry_186a18 (0x186a18 - 0x186a70)
    ctx->pc = 0x186a20;
    entry_186a18(rdram, ctx, runtime);
}

void entry_186a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186a38 inside entry_186a18 (0x186a18 - 0x186a70)
    ctx->pc = 0x186a38;
    entry_186a18(rdram, ctx, runtime);
}

void entry_186a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186a90 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186a90;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186aa8 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186aa8;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186ac0 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186ac0;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186acc inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186acc;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186af0 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186af0;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186b14 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186b14;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186b4c inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186b4c;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186b54 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186b54;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186b68 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186b68;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186b78 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186b78;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186ba0 inside CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG (0x186a70 - 0x186ba8)
    ctx->pc = 0x186ba0;
    CplsgFindEdgePath__FP4SURFiiP3LSGPP3LSG(rdram, ctx, runtime);
}

void entry_186c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186c3c inside entry_186c24 (0x186c24 - 0x186c8c)
    ctx->pc = 0x186c3c;
    entry_186c24(rdram, ctx, runtime);
}

void entry_186c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186c70 inside entry_186c24 (0x186c24 - 0x186c8c)
    ctx->pc = 0x186c70;
    entry_186c24(rdram, ctx, runtime);
}

void entry_186cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186cc0 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186cc0;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186ce8 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186ce8;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186d38 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186d38;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186d88 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186d88;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186de0 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186de0;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186de4 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186de4;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186dec inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186dec;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186e10 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186e10;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186e18 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186e18;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186e28 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186e28;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186e44 inside entry_186c8c (0x186c8c - 0x186e74)
    ctx->pc = 0x186e44;
    entry_186c8c(rdram, ctx, runtime);
}

void entry_186e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186e80 inside entry_186e74 (0x186e74 - 0x186edc)
    ctx->pc = 0x186e80;
    entry_186e74(rdram, ctx, runtime);
}

void entry_186eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186eec inside entry_186edc (0x186edc - 0x186f64)
    ctx->pc = 0x186eec;
    entry_186edc(rdram, ctx, runtime);
}

void entry_186f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186f04 inside entry_186edc (0x186edc - 0x186f64)
    ctx->pc = 0x186f04;
    entry_186edc(rdram, ctx, runtime);
}

void entry_186f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186f30 inside entry_186edc (0x186edc - 0x186f64)
    ctx->pc = 0x186f30;
    entry_186edc(rdram, ctx, runtime);
}

void entry_186f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x186f88 inside entry_186f64 (0x186f64 - 0x187000)
    ctx->pc = 0x186f88;
    entry_186f64(rdram, ctx, runtime);
}

void entry_1870b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1870b4 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x1870b4;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_1870d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1870d8 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x1870d8;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_187118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187118 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x187118;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_187180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187180 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x187180;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_187184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187184 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x187184;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_1871a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1871a0 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x1871a0;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_1871d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1871d8 inside entry_1870a4 (0x1870a4 - 0x18721c)
    ctx->pc = 0x1871d8;
    entry_1870a4(rdram, ctx, runtime);
}

void entry_187220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187220 inside entry_18721c (0x18721c - 0x187260)
    ctx->pc = 0x187220;
    entry_18721c(rdram, ctx, runtime);
}

void entry_187228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187228 inside entry_18721c (0x18721c - 0x187260)
    ctx->pc = 0x187228;
    entry_18721c(rdram, ctx, runtime);
}

void entry_18722c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18722c inside entry_18721c (0x18721c - 0x187260)
    ctx->pc = 0x18722c;
    entry_18721c(rdram, ctx, runtime);
}

void entry_187330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187330 inside entry_1872fc (0x1872fc - 0x1874f8)
    ctx->pc = 0x187330;
    entry_1872fc(rdram, ctx, runtime);
}

void entry_187348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187348 inside entry_1872fc (0x1872fc - 0x1874f8)
    ctx->pc = 0x187348;
    entry_1872fc(rdram, ctx, runtime);
}

void entry_187454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187454 inside entry_1872fc (0x1872fc - 0x1874f8)
    ctx->pc = 0x187454;
    entry_1872fc(rdram, ctx, runtime);
}

void entry_18745c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18745c inside entry_1872fc (0x1872fc - 0x1874f8)
    ctx->pc = 0x18745c;
    entry_1872fc(rdram, ctx, runtime);
}

void entry_187470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187470 inside entry_1872fc (0x1872fc - 0x1874f8)
    ctx->pc = 0x187470;
    entry_1872fc(rdram, ctx, runtime);
}

void entry_187508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187508 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187508;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187544 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187544;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1875d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1875d8 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1875d8;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1875e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1875e4 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1875e4;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1875e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1875e8 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1875e8;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187608 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187608;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187650 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187650;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1876fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1876fc inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1876fc;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_18772c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18772c inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x18772c;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187750 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187750;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187798 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187798;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1877ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1877ac inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1877ac;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_18782c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18782c inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x18782c;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187868 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187868;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_18786c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18786c inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x18786c;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187874 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187874;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187878 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187878;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187880 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187880;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1878b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1878b0 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1878b0;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1878c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1878c8 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1878c8;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_1878f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1878f4 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x1878f4;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_18793c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18793c inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x18793c;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187940 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187940;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187948 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187948;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187960 inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x187960;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_18797c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18797c inside entry_1874f8 (0x1874f8 - 0x187984)
    ctx->pc = 0x18797c;
    entry_1874f8(rdram, ctx, runtime);
}

void entry_187a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187a28 inside entry_187a0c (0x187a0c - 0x187a54)
    ctx->pc = 0x187a28;
    entry_187a0c(rdram, ctx, runtime);
}

void entry_187a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187a60 inside entry_187a54 (0x187a54 - 0x187a88)
    ctx->pc = 0x187a60;
    entry_187a54(rdram, ctx, runtime);
}

void entry_187b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187b58 inside entry_187b54 (0x187b54 - 0x187b60)
    ctx->pc = 0x187b58;
    entry_187b54(rdram, ctx, runtime);
}

void entry_187bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187bb0 inside CalculateCenterContact__FP2SOP6VECTORfT1Pf (0x187b60 - 0x187c28)
    ctx->pc = 0x187bb0;
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime);
}

void entry_187be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187be8 inside CalculateCenterContact__FP2SOP6VECTORfT1Pf (0x187b60 - 0x187c28)
    ctx->pc = 0x187be8;
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime);
}

void entry_187bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187bf8 inside CalculateCenterContact__FP2SOP6VECTORfT1Pf (0x187b60 - 0x187c28)
    ctx->pc = 0x187bf8;
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime);
}

void entry_187c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187c18 inside CalculateCenterContact__FP2SOP6VECTORfT1Pf (0x187b60 - 0x187c28)
    ctx->pc = 0x187c18;
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime);
}

void entry_187c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187c1c inside CalculateCenterContact__FP2SOP6VECTORfT1Pf (0x187b60 - 0x187c28)
    ctx->pc = 0x187c1c;
    CalculateCenterContact__FP2SOP6VECTORfT1Pf(rdram, ctx, runtime);
}

void entry_187c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187c80 inside entry_187c6c (0x187c6c - 0x187cb4)
    ctx->pc = 0x187c80;
    entry_187c6c(rdram, ctx, runtime);
}

void entry_187ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187ce4 inside entry_187cdc (0x187cdc - 0x187d08)
    ctx->pc = 0x187ce4;
    entry_187cdc(rdram, ctx, runtime);
}

void entry_187ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187ce8 inside entry_187cdc (0x187cdc - 0x187d08)
    ctx->pc = 0x187ce8;
    entry_187cdc(rdram, ctx, runtime);
}

void entry_187de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187de4 inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187de4;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187dec inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187dec;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187e38 inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187e38;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187e44 inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187e44;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187e50 inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187e50;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187e7c inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187e7c;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187e80 inside FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4 (0x187d08 - 0x187e88)
    ctx->pc = 0x187e80;
    FClipEdgeToSphere__FP6VECTORfT0T0PfT0T0T4(rdram, ctx, runtime);
}

void entry_187f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187f20 inside entry_187f18 (0x187f18 - 0x187f40)
    ctx->pc = 0x187f20;
    entry_187f18(rdram, ctx, runtime);
}

void entry_187f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187f24 inside entry_187f18 (0x187f18 - 0x187f40)
    ctx->pc = 0x187f24;
    entry_187f18(rdram, ctx, runtime);
}

void entry_187fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187fb0 inside AddSoXps__FP2SOT0iiP3BSPT4PP2XP (0x187f40 - 0x188088)
    ctx->pc = 0x187fb0;
    AddSoXps__FP2SOT0iiP3BSPT4PP2XP(rdram, ctx, runtime);
}

void entry_187fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x187fdc inside AddSoXps__FP2SOT0iiP3BSPT4PP2XP (0x187f40 - 0x188088)
    ctx->pc = 0x187fdc;
    AddSoXps__FP2SOT0iiP3BSPT4PP2XP(rdram, ctx, runtime);
}

void entry_18801c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18801c inside AddSoXps__FP2SOT0iiP3BSPT4PP2XP (0x187f40 - 0x188088)
    ctx->pc = 0x18801c;
    AddSoXps__FP2SOT0iiP3BSPT4PP2XP(rdram, ctx, runtime);
}

void entry_188020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188020 inside AddSoXps__FP2SOT0iiP3BSPT4PP2XP (0x187f40 - 0x188088)
    ctx->pc = 0x188020;
    AddSoXps__FP2SOT0iiP3BSPT4PP2XP(rdram, ctx, runtime);
}

void entry_188090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188090 inside entry_188088 (0x188088 - 0x1880a8)
    ctx->pc = 0x188090;
    entry_188088(rdram, ctx, runtime);
}

void entry_1880c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1880c0 inside entry_1880a8 (0x1880a8 - 0x188128)
    ctx->pc = 0x1880c0;
    entry_1880a8(rdram, ctx, runtime);
}

void entry_1880c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1880c4 inside entry_1880a8 (0x1880a8 - 0x188128)
    ctx->pc = 0x1880c4;
    entry_1880a8(rdram, ctx, runtime);
}

void entry_1880cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1880cc inside entry_1880a8 (0x1880a8 - 0x188128)
    ctx->pc = 0x1880cc;
    entry_1880a8(rdram, ctx, runtime);
}

void entry_188130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188130 inside entry_188128 (0x188128 - 0x188148)
    ctx->pc = 0x188130;
    entry_188128(rdram, ctx, runtime);
}

void entry_18815c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18815c inside entry_188148 (0x188148 - 0x188188)
    ctx->pc = 0x18815c;
    entry_188148(rdram, ctx, runtime);
}

void entry_188190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188190 inside entry_188188 (0x188188 - 0x18820c)
    ctx->pc = 0x188190;
    entry_188188(rdram, ctx, runtime);
}

void entry_1881b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1881b0 inside entry_188188 (0x188188 - 0x18820c)
    ctx->pc = 0x1881b0;
    entry_188188(rdram, ctx, runtime);
}

void entry_1881dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1881dc inside entry_188188 (0x188188 - 0x18820c)
    ctx->pc = 0x1881dc;
    entry_188188(rdram, ctx, runtime);
}

void entry_1881e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1881e4 inside entry_188188 (0x188188 - 0x18820c)
    ctx->pc = 0x1881e4;
    entry_188188(rdram, ctx, runtime);
}

void entry_188204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188204 inside entry_188188 (0x188188 - 0x18820c)
    ctx->pc = 0x188204;
    entry_188188(rdram, ctx, runtime);
}

void entry_188214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188214 inside entry_18820c (0x18820c - 0x18822c)
    ctx->pc = 0x188214;
    entry_18820c(rdram, ctx, runtime);
}

void entry_188230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188230 inside entry_18822c (0x18822c - 0x188270)
    ctx->pc = 0x188230;
    entry_18822c(rdram, ctx, runtime);
}

void entry_188238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188238 inside entry_18822c (0x18822c - 0x188270)
    ctx->pc = 0x188238;
    entry_18822c(rdram, ctx, runtime);
}

void entry_1882cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1882cc inside PxpMarkSwContactsRoot__FP2SWPP2SOi (0x188270 - 0x18830c)
    ctx->pc = 0x1882cc;
    PxpMarkSwContactsRoot__FP2SWPP2SOi(rdram, ctx, runtime);
}

void entry_1882d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1882d4 inside PxpMarkSwContactsRoot__FP2SWPP2SOi (0x188270 - 0x18830c)
    ctx->pc = 0x1882d4;
    PxpMarkSwContactsRoot__FP2SWPP2SOi(rdram, ctx, runtime);
}

void entry_1882e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1882e8 inside PxpMarkSwContactsRoot__FP2SWPP2SOi (0x188270 - 0x18830c)
    ctx->pc = 0x1882e8;
    PxpMarkSwContactsRoot__FP2SWPP2SOi(rdram, ctx, runtime);
}

void entry_188304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188304 inside PxpMarkSwContactsRoot__FP2SWPP2SOi (0x188270 - 0x18830c)
    ctx->pc = 0x188304;
    PxpMarkSwContactsRoot__FP2SWPP2SOi(rdram, ctx, runtime);
}

void entry_188350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188350 inside entry_188318 (0x188318 - 0x18838c)
    ctx->pc = 0x188350;
    entry_188318(rdram, ctx, runtime);
}

void entry_188370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188370 inside entry_188318 (0x188318 - 0x18838c)
    ctx->pc = 0x188370;
    entry_188318(rdram, ctx, runtime);
}

void entry_1883ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1883ac inside entry_18838c (0x18838c - 0x1883d8)
    ctx->pc = 0x1883ac;
    entry_18838c(rdram, ctx, runtime);
}

void entry_188404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188404 inside entry_188400 (0x188400 - 0x188478)
    ctx->pc = 0x188404;
    entry_188400(rdram, ctx, runtime);
}

void entry_188410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188410 inside entry_188400 (0x188400 - 0x188478)
    ctx->pc = 0x188410;
    entry_188400(rdram, ctx, runtime);
}

void entry_188430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188430 inside entry_188400 (0x188400 - 0x188478)
    ctx->pc = 0x188430;
    entry_188400(rdram, ctx, runtime);
}

void entry_188454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188454 inside entry_188400 (0x188400 - 0x188478)
    ctx->pc = 0x188454;
    entry_188400(rdram, ctx, runtime);
}

void entry_18847c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18847c inside entry_188478 (0x188478 - 0x18848c)
    ctx->pc = 0x18847c;
    entry_188478(rdram, ctx, runtime);
}

void entry_188484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188484 inside entry_188478 (0x188478 - 0x18848c)
    ctx->pc = 0x188484;
    entry_188478(rdram, ctx, runtime);
}

void entry_1887a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1887a0 inside TransposeMatrix4__FP7MATRIX4T0 (0x188770 - 0x188810)
    ctx->pc = 0x1887a0;
    TransposeMatrix4__FP7MATRIX4T0(rdram, ctx, runtime);
}

void entry_1887d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1887d0 inside TransposeMatrix4__FP7MATRIX4T0 (0x188770 - 0x188810)
    ctx->pc = 0x1887d0;
    TransposeMatrix4__FP7MATRIX4T0(rdram, ctx, runtime);
}

void entry_1887f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1887f4 inside TransposeMatrix4__FP7MATRIX4T0 (0x188770 - 0x188810)
    ctx->pc = 0x1887f4;
    TransposeMatrix4__FP7MATRIX4T0(rdram, ctx, runtime);
}

void entry_188818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188818 inside AddMatrix4Matrix4__FP7MATRIX4N20 (0x188810 - 0x188848)
    ctx->pc = 0x188818;
    AddMatrix4Matrix4__FP7MATRIX4N20(rdram, ctx, runtime);
}

void entry_188890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188890 inside entry_188874 (0x188874 - 0x188978)
    ctx->pc = 0x188890;
    entry_188874(rdram, ctx, runtime);
}

void entry_1888a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1888a0 inside entry_188874 (0x188874 - 0x188978)
    ctx->pc = 0x1888a0;
    entry_188874(rdram, ctx, runtime);
}

void entry_1888e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1888e8 inside entry_188874 (0x188874 - 0x188978)
    ctx->pc = 0x1888e8;
    entry_188874(rdram, ctx, runtime);
}

void entry_1889f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1889f4 inside entry_1889ec (0x1889ec - 0x188a20)
    ctx->pc = 0x1889f4;
    entry_1889ec(rdram, ctx, runtime);
}

void entry_188a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188a18 inside entry_1889ec (0x1889ec - 0x188a20)
    ctx->pc = 0x188a18;
    entry_1889ec(rdram, ctx, runtime);
}

void entry_188c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188c20 inside LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x188c10 - 0x188cc8)
    ctx->pc = 0x188c20;
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_188c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188c30 inside LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x188c10 - 0x188cc8)
    ctx->pc = 0x188c30;
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_188c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188c70 inside LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x188c10 - 0x188cc8)
    ctx->pc = 0x188c70;
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_188c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188c98 inside LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x188c10 - 0x188cc8)
    ctx->pc = 0x188c98;
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_188db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188db4 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188db4;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188dd0 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188dd0;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188df4 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188df4;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188e04 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188e04;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188e9c inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188e9c;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188ea8 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188ea8;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188edc inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188edc;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188ee4 inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188ee4;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188efc inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188efc;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188f1c inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188f1c;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188f3c inside DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR (0x188d28 - 0x188f44)
    ctx->pc = 0x188f3c;
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime);
}

void entry_188f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188f70 inside entry_188f44 (0x188f44 - 0x188fd0)
    ctx->pc = 0x188f70;
    entry_188f44(rdram, ctx, runtime);
}

void entry_188f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188f94 inside entry_188f44 (0x188f44 - 0x188fd0)
    ctx->pc = 0x188f94;
    entry_188f44(rdram, ctx, runtime);
}

void entry_188fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188fb4 inside entry_188f44 (0x188f44 - 0x188fd0)
    ctx->pc = 0x188fb4;
    entry_188f44(rdram, ctx, runtime);
}

void entry_188fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x188fb8 inside entry_188f44 (0x188f44 - 0x188fd0)
    ctx->pc = 0x188fb8;
    entry_188f44(rdram, ctx, runtime);
}

void entry_189050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189050 inside entry_189040 (0x189040 - 0x189060)
    ctx->pc = 0x189050;
    entry_189040(rdram, ctx, runtime);
}

void entry_189068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189068 inside entry_189060 (0x189060 - 0x189080)
    ctx->pc = 0x189068;
    entry_189060(rdram, ctx, runtime);
}

void entry_189078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189078 inside entry_189060 (0x189060 - 0x189080)
    ctx->pc = 0x189078;
    entry_189060(rdram, ctx, runtime);
}

void entry_18941c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18941c inside entry_1893b0 (0x1893b0 - 0x189430)
    ctx->pc = 0x18941c;
    entry_1893b0(rdram, ctx, runtime);
}

void entry_1894a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1894a0 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1894a0;
    entry_189490(rdram, ctx, runtime);
}

void entry_1894c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1894c0 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1894c0;
    entry_189490(rdram, ctx, runtime);
}

void entry_1894cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1894cc inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1894cc;
    entry_189490(rdram, ctx, runtime);
}

void entry_1894dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1894dc inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1894dc;
    entry_189490(rdram, ctx, runtime);
}

void entry_1894ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1894ec inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1894ec;
    entry_189490(rdram, ctx, runtime);
}

void entry_189500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189500 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189500;
    entry_189490(rdram, ctx, runtime);
}

void entry_189538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189538 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189538;
    entry_189490(rdram, ctx, runtime);
}

void entry_18955c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18955c inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x18955c;
    entry_189490(rdram, ctx, runtime);
}

void entry_189568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189568 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189568;
    entry_189490(rdram, ctx, runtime);
}

void entry_1895a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1895a0 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1895a0;
    entry_189490(rdram, ctx, runtime);
}

void entry_1895d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1895d8 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1895d8;
    entry_189490(rdram, ctx, runtime);
}

void entry_1895dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1895dc inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1895dc;
    entry_189490(rdram, ctx, runtime);
}

void entry_189600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189600 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189600;
    entry_189490(rdram, ctx, runtime);
}

void entry_189638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189638 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189638;
    entry_189490(rdram, ctx, runtime);
}

void entry_189678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189678 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189678;
    entry_189490(rdram, ctx, runtime);
}

void entry_189688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189688 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189688;
    entry_189490(rdram, ctx, runtime);
}

void entry_189698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189698 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189698;
    entry_189490(rdram, ctx, runtime);
}

void entry_1896a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1896a8 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1896a8;
    entry_189490(rdram, ctx, runtime);
}

void entry_1896c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1896c8 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1896c8;
    entry_189490(rdram, ctx, runtime);
}

void entry_189700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189700 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189700;
    entry_189490(rdram, ctx, runtime);
}

void entry_189740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189740 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189740;
    entry_189490(rdram, ctx, runtime);
}

void entry_189750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189750 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189750;
    entry_189490(rdram, ctx, runtime);
}

void entry_18975c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18975c inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x18975c;
    entry_189490(rdram, ctx, runtime);
}

void entry_189768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189768 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189768;
    entry_189490(rdram, ctx, runtime);
}

void entry_189790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189790 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x189790;
    entry_189490(rdram, ctx, runtime);
}

void entry_1897a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1897a8 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1897a8;
    entry_189490(rdram, ctx, runtime);
}

void entry_1897b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1897b8 inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1897b8;
    entry_189490(rdram, ctx, runtime);
}

void entry_1897bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1897bc inside entry_189490 (0x189490 - 0x1897c4)
    ctx->pc = 0x1897bc;
    entry_189490(rdram, ctx, runtime);
}

void entry_189848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189848 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189848;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189888 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189888;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_1898ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1898ac inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x1898ac;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_1898b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1898b8 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x1898b8;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_1898e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1898e8 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x1898e8;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189920 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189920;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189940 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189940;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189970 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189970;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_1899c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1899c0 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x1899c0;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_1899e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1899e0 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x1899e0;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189a00 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189a00;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189a30 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189a30;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189a80 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189a80;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189a98 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189a98;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189ab0 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189ab0;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189ae4 inside FInvertMatrix3__FP7MATRIX3T0 (0x1897f0 - 0x189af0)
    ctx->pc = 0x189ae4;
    FInvertMatrix3__FP7MATRIX3T0(rdram, ctx, runtime);
}

void entry_189b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189b7c inside BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3 (0x189b18 - 0x189c00)
    ctx->pc = 0x189b7c;
    BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189b88 inside BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3 (0x189b18 - 0x189c00)
    ctx->pc = 0x189b88;
    BuildOrthonormalMatrixY__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189c8c inside BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3 (0x189c28 - 0x189d10)
    ctx->pc = 0x189c8c;
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189c98 inside BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3 (0x189c28 - 0x189d10)
    ctx->pc = 0x189c98;
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189dac inside BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3 (0x189d38 - 0x189f38)
    ctx->pc = 0x189dac;
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189db8 inside BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3 (0x189d38 - 0x189f38)
    ctx->pc = 0x189db8;
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189e14 inside BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3 (0x189d38 - 0x189f38)
    ctx->pc = 0x189e14;
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_189efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x189efc inside BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3 (0x189d38 - 0x189f38)
    ctx->pc = 0x189efc;
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a078 inside LoadScaleMatrixVector__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x18a040 - 0x18a094)
    ctx->pc = 0x18a078;
    LoadScaleMatrixVector__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_18a088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a088 inside LoadScaleMatrixVector__FP6VECTORP7MATRIX3T0P7MATRIX4 (0x18a040 - 0x18a094)
    ctx->pc = 0x18a088;
    LoadScaleMatrixVector__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime);
}

void entry_18a1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a1dc inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a1dc;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a1fc inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a1fc;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a250 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a250;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a260 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a260;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a2b0 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a2b0;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a2c8 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a2c8;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a308 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a308;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a380 inside LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3 (0x18a160 - 0x18a388)
    ctx->pc = 0x18a380;
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime);
}

void entry_18a470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a470 inside entry_18a464 (0x18a464 - 0x18a484)
    ctx->pc = 0x18a470;
    entry_18a464(rdram, ctx, runtime);
}

void entry_18a4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a4c0 inside entry_18a4ac (0x18a4ac - 0x18a4e0)
    ctx->pc = 0x18a4c0;
    entry_18a4ac(rdram, ctx, runtime);
}

void entry_18a4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a4f4 inside entry_18a4e0 (0x18a4e0 - 0x18a510)
    ctx->pc = 0x18a4f4;
    entry_18a4e0(rdram, ctx, runtime);
}

void entry_18a5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a5d4 inside entry_18a558 (0x18a558 - 0x18a5dc)
    ctx->pc = 0x18a5d4;
    entry_18a558(rdram, ctx, runtime);
}

void entry_18a730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a730 inside PsoHitTestCylinderObjects__FiP6VECTORT1fiPP2SOP3LSG (0x18a6c0 - 0x18a754)
    ctx->pc = 0x18a730;
    PsoHitTestCylinderObjects__FiP6VECTORT1fiPP2SOP3LSG(rdram, ctx, runtime);
}

void entry_18a778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a778 inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a778;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a77c inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a77c;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a7b8 inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a7b8;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a7dc inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a7dc;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a7e0 inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a7e0;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a7ec inside entry_18a754 (0x18a754 - 0x18a830)
    ctx->pc = 0x18a7ec;
    entry_18a754(rdram, ctx, runtime);
}

void entry_18a860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a860 inside FFilterMbgAttackObjects__FP3MBGP2SO (0x18a830 - 0x18a87c)
    ctx->pc = 0x18a860;
    FFilterMbgAttackObjects__FP3MBGP2SO(rdram, ctx, runtime);
}

void entry_18a864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a864 inside FFilterMbgAttackObjects__FP3MBGP2SO (0x18a830 - 0x18a87c)
    ctx->pc = 0x18a864;
    FFilterMbgAttackObjects__FP3MBGP2SO(rdram, ctx, runtime);
}

void entry_18a884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a884 inside entry_18a87c (0x18a87c - 0x18a8a8)
    ctx->pc = 0x18a884;
    entry_18a87c(rdram, ctx, runtime);
}

void entry_18a88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a88c inside entry_18a87c (0x18a87c - 0x18a8a8)
    ctx->pc = 0x18a88c;
    entry_18a87c(rdram, ctx, runtime);
}

void entry_18a8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a8cc inside entry_18a8c0 (0x18a8c0 - 0x18a8d4)
    ctx->pc = 0x18a8cc;
    entry_18a8c0(rdram, ctx, runtime);
}

void entry_18a8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18a8f4 inside entry_18a8e8 (0x18a8e8 - 0x18a910)
    ctx->pc = 0x18a8f4;
    entry_18a8e8(rdram, ctx, runtime);
}

void entry_18aa24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aa24 inside entry_18aa18 (0x18aa18 - 0x18aa2c)
    ctx->pc = 0x18aa24;
    entry_18aa18(rdram, ctx, runtime);
}

void entry_18aa54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aa54 inside entry_18aa2c (0x18aa2c - 0x18aa7c)
    ctx->pc = 0x18aa54;
    entry_18aa2c(rdram, ctx, runtime);
}

void entry_18aa68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aa68 inside entry_18aa2c (0x18aa2c - 0x18aa7c)
    ctx->pc = 0x18aa68;
    entry_18aa2c(rdram, ctx, runtime);
}

void entry_18aa84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aa84 inside entry_18aa7c (0x18aa7c - 0x18aaac)
    ctx->pc = 0x18aa84;
    entry_18aa7c(rdram, ctx, runtime);
}

void entry_18aa8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aa8c inside entry_18aa7c (0x18aa7c - 0x18aaac)
    ctx->pc = 0x18aa8c;
    entry_18aa7c(rdram, ctx, runtime);
}

void entry_18aac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aac4 inside entry_18aabc (0x18aabc - 0x18aae0)
    ctx->pc = 0x18aac4;
    entry_18aabc(rdram, ctx, runtime);
}

void entry_18aac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aac8 inside entry_18aabc (0x18aabc - 0x18aae0)
    ctx->pc = 0x18aac8;
    entry_18aabc(rdram, ctx, runtime);
}

void entry_18ab64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ab64 inside entry_18ab48 (0x18ab48 - 0x18ab88)
    ctx->pc = 0x18ab64;
    entry_18ab48(rdram, ctx, runtime);
}

void entry_18ab6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ab6c inside entry_18ab48 (0x18ab48 - 0x18ab88)
    ctx->pc = 0x18ab6c;
    entry_18ab48(rdram, ctx, runtime);
}

void entry_18ab74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ab74 inside entry_18ab48 (0x18ab48 - 0x18ab88)
    ctx->pc = 0x18ab74;
    entry_18ab48(rdram, ctx, runtime);
}

void entry_18ab78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ab78 inside entry_18ab48 (0x18ab48 - 0x18ab88)
    ctx->pc = 0x18ab78;
    entry_18ab48(rdram, ctx, runtime);
}

void entry_18abc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18abc8 inside entry_18ab9c (0x18ab9c - 0x18abd0)
    ctx->pc = 0x18abc8;
    entry_18ab9c(rdram, ctx, runtime);
}

void entry_18abe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18abe0 inside entry_18abdc (0x18abdc - 0x18abf0)
    ctx->pc = 0x18abe0;
    entry_18abdc(rdram, ctx, runtime);
}

void entry_18ac3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ac3c inside entry_18ac34 (0x18ac34 - 0x18ac44)
    ctx->pc = 0x18ac3c;
    entry_18ac34(rdram, ctx, runtime);
}

void entry_18ad30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ad30 inside entry_18ad04 (0x18ad04 - 0x18ad44)
    ctx->pc = 0x18ad30;
    entry_18ad04(rdram, ctx, runtime);
}

void entry_18ad3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ad3c inside entry_18ad04 (0x18ad04 - 0x18ad44)
    ctx->pc = 0x18ad3c;
    entry_18ad04(rdram, ctx, runtime);
}

void entry_18ad48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ad48 inside entry_18ad44 (0x18ad44 - 0x18ad60)
    ctx->pc = 0x18ad48;
    entry_18ad44(rdram, ctx, runtime);
}

void entry_18ad68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ad68 inside entry_18ad60 (0x18ad60 - 0x18ad78)
    ctx->pc = 0x18ad68;
    entry_18ad60(rdram, ctx, runtime);
}

void entry_18ad7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ad7c inside entry_18ad78 (0x18ad78 - 0x18ad88)
    ctx->pc = 0x18ad7c;
    entry_18ad78(rdram, ctx, runtime);
}

void entry_18add0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18add0 inside entry_18adc8 (0x18adc8 - 0x18add8)
    ctx->pc = 0x18add0;
    entry_18adc8(rdram, ctx, runtime);
}

void entry_18ae04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ae04 inside entry_18adfc (0x18adfc - 0x18ae18)
    ctx->pc = 0x18ae04;
    entry_18adfc(rdram, ctx, runtime);
}

void entry_18ae08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ae08 inside entry_18adfc (0x18adfc - 0x18ae18)
    ctx->pc = 0x18ae08;
    entry_18adfc(rdram, ctx, runtime);
}

void entry_18ae20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ae20 inside entry_18ae18 (0x18ae18 - 0x18ae28)
    ctx->pc = 0x18ae20;
    entry_18ae18(rdram, ctx, runtime);
}

void entry_18ae2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ae2c inside entry_18ae28 (0x18ae28 - 0x18ae38)
    ctx->pc = 0x18ae2c;
    entry_18ae28(rdram, ctx, runtime);
}

void entry_18ae7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ae7c inside entry_18ae5c (0x18ae5c - 0x18aeb0)
    ctx->pc = 0x18ae7c;
    entry_18ae5c(rdram, ctx, runtime);
}

void entry_18aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18aea4 inside entry_18ae5c (0x18ae5c - 0x18aeb0)
    ctx->pc = 0x18aea4;
    entry_18ae5c(rdram, ctx, runtime);
}

void entry_18af28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18af28 inside entry_18aeb0 (0x18aeb0 - 0x18afa0)
    ctx->pc = 0x18af28;
    entry_18aeb0(rdram, ctx, runtime);
}

void entry_18af3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18af3c inside entry_18aeb0 (0x18aeb0 - 0x18afa0)
    ctx->pc = 0x18af3c;
    entry_18aeb0(rdram, ctx, runtime);
}

void entry_18af80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18af80 inside entry_18aeb0 (0x18aeb0 - 0x18afa0)
    ctx->pc = 0x18af80;
    entry_18aeb0(rdram, ctx, runtime);
}

void entry_18af94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18af94 inside entry_18aeb0 (0x18aeb0 - 0x18afa0)
    ctx->pc = 0x18af94;
    entry_18aeb0(rdram, ctx, runtime);
}

void entry_18afc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18afc0 inside entry_18afa0 (0x18afa0 - 0x18afd8)
    ctx->pc = 0x18afc0;
    entry_18afa0(rdram, ctx, runtime);
}

void entry_18afcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18afcc inside entry_18afa0 (0x18afa0 - 0x18afd8)
    ctx->pc = 0x18afcc;
    entry_18afa0(rdram, ctx, runtime);
}

void entry_18b02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b02c inside entry_18afe4 (0x18afe4 - 0x18b054)
    ctx->pc = 0x18b02c;
    entry_18afe4(rdram, ctx, runtime);
}

void entry_18b03c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b03c inside entry_18afe4 (0x18afe4 - 0x18b054)
    ctx->pc = 0x18b03c;
    entry_18afe4(rdram, ctx, runtime);
}

void entry_18b180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b180 inside entry_18b17c (0x18b17c - 0x18b190)
    ctx->pc = 0x18b180;
    entry_18b17c(rdram, ctx, runtime);
}

void entry_18b188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b188 inside entry_18b17c (0x18b17c - 0x18b190)
    ctx->pc = 0x18b188;
    entry_18b17c(rdram, ctx, runtime);
}

void entry_18b26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b26c inside entry_18b1fc (0x18b1fc - 0x18b298)
    ctx->pc = 0x18b26c;
    entry_18b1fc(rdram, ctx, runtime);
}

void entry_18b27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b27c inside entry_18b1fc (0x18b1fc - 0x18b298)
    ctx->pc = 0x18b27c;
    entry_18b1fc(rdram, ctx, runtime);
}

void entry_18b2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b2c8 inside entry_18b2c4 (0x18b2c4 - 0x18b2e8)
    ctx->pc = 0x18b2c8;
    entry_18b2c4(rdram, ctx, runtime);
}

void entry_18b2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b2cc inside entry_18b2c4 (0x18b2c4 - 0x18b2e8)
    ctx->pc = 0x18b2cc;
    entry_18b2c4(rdram, ctx, runtime);
}

void entry_18b330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b330 inside entry_18b328 (0x18b328 - 0x18b340)
    ctx->pc = 0x18b330;
    entry_18b328(rdram, ctx, runtime);
}

void entry_18b334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b334 inside entry_18b328 (0x18b328 - 0x18b340)
    ctx->pc = 0x18b334;
    entry_18b328(rdram, ctx, runtime);
}

void entry_18b394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b394 inside HandleMbgMessage__FP3MBG5MSGIDPv (0x18b340 - 0x18b3b4)
    ctx->pc = 0x18b394;
    HandleMbgMessage__FP3MBG5MSGIDPv(rdram, ctx, runtime);
}

void entry_18b3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b3a8 inside HandleMbgMessage__FP3MBG5MSGIDPv (0x18b340 - 0x18b3b4)
    ctx->pc = 0x18b3a8;
    HandleMbgMessage__FP3MBG5MSGIDPv(rdram, ctx, runtime);
}

void entry_18b3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b3dc inside entry_18b3b4 (0x18b3b4 - 0x18b430)
    ctx->pc = 0x18b3dc;
    entry_18b3b4(rdram, ctx, runtime);
}

void entry_18b3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b3f0 inside entry_18b3b4 (0x18b3b4 - 0x18b430)
    ctx->pc = 0x18b3f0;
    entry_18b3b4(rdram, ctx, runtime);
}

void entry_18b408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b408 inside entry_18b3b4 (0x18b3b4 - 0x18b430)
    ctx->pc = 0x18b408;
    entry_18b3b4(rdram, ctx, runtime);
}

void entry_18b41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b41c inside entry_18b3b4 (0x18b3b4 - 0x18b430)
    ctx->pc = 0x18b41c;
    entry_18b3b4(rdram, ctx, runtime);
}

void entry_18b428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b428 inside entry_18b3b4 (0x18b3b4 - 0x18b430)
    ctx->pc = 0x18b428;
    entry_18b3b4(rdram, ctx, runtime);
}

void entry_18b438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b438 inside entry_18b430 (0x18b430 - 0x18b448)
    ctx->pc = 0x18b438;
    entry_18b430(rdram, ctx, runtime);
}

void entry_18b440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b440 inside entry_18b430 (0x18b430 - 0x18b448)
    ctx->pc = 0x18b440;
    entry_18b430(rdram, ctx, runtime);
}

void entry_18b44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b44c inside entry_18b448 (0x18b448 - 0x18b460)
    ctx->pc = 0x18b44c;
    entry_18b448(rdram, ctx, runtime);
}

void entry_18b49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b49c inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b49c;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b4e8 inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b4e8;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b500 inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b500;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b548 inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b548;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b560 inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b560;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b568 inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b568;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b56c inside entry_18b47c (0x18b47c - 0x18b580)
    ctx->pc = 0x18b56c;
    entry_18b47c(rdram, ctx, runtime);
}

void entry_18b7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b7dc inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b7dc;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b7f8 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b7f8;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b814 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b814;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b830 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b830;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b84c inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b84c;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b868 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b868;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b884 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b884;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b8a0 inside entry_18b7b4 (0x18b7b4 - 0x18b910)
    ctx->pc = 0x18b8a0;
    entry_18b7b4(rdram, ctx, runtime);
}

void entry_18b928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b928 inside FUN_0018b910__Fi (0x18b910 - 0x18b930)
    ctx->pc = 0x18b928;
    FUN_0018b910__Fi(rdram, ctx, runtime);
}

void entry_18b954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b954 inside FUN_0018b930__Fi (0x18b930 - 0x18b988)
    ctx->pc = 0x18b954;
    FUN_0018b930__Fi(rdram, ctx, runtime);
}

void entry_18b964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b964 inside FUN_0018b930__Fi (0x18b930 - 0x18b988)
    ctx->pc = 0x18b964;
    FUN_0018b930__Fi(rdram, ctx, runtime);
}

void entry_18b96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b96c inside FUN_0018b930__Fi (0x18b930 - 0x18b988)
    ctx->pc = 0x18b96c;
    FUN_0018b930__Fi(rdram, ctx, runtime);
}

void entry_18b974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b974 inside FUN_0018b930__Fi (0x18b930 - 0x18b988)
    ctx->pc = 0x18b974;
    FUN_0018b930__Fi(rdram, ctx, runtime);
}

void entry_18b97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b97c inside FUN_0018b930__Fi (0x18b930 - 0x18b988)
    ctx->pc = 0x18b97c;
    FUN_0018b930__Fi(rdram, ctx, runtime);
}

void entry_18b9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9d4 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9d4;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18b9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9e0 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9e0;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18b9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9e8 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9e8;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18b9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9f0 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9f0;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18b9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9f8 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9f8;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18b9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18b9fc inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18b9fc;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18ba00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ba00 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18ba00;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18ba34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ba34 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18ba34;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18ba54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ba54 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18ba54;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18ba5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ba5c inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18ba5c;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bae8 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bae8;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18baf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18baf0 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18baf0;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bb1c inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bb1c;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bb30 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bb30;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bb54 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bb54;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bb70 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bb70;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bb8c inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bb8c;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc04 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc04;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc08 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc08;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc10 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc10;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc58 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc58;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc74 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc74;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc7c inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc7c;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bc84 inside FUN_0018b988 (0x18b988 - 0x18bc90)
    ctx->pc = 0x18bc84;
    FUN_0018b988(rdram, ctx, runtime);
}

void entry_18bccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bccc inside entry_18bcbc (0x18bcbc - 0x18bce4)
    ctx->pc = 0x18bccc;
    entry_18bcbc(rdram, ctx, runtime);
}

void entry_18bcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bcec inside entry_18bce4 (0x18bce4 - 0x18bd00)
    ctx->pc = 0x18bcec;
    entry_18bce4(rdram, ctx, runtime);
}

void entry_18bd44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bd44 inside entry_18bd3c (0x18bd3c - 0x18bd58)
    ctx->pc = 0x18bd44;
    entry_18bd3c(rdram, ctx, runtime);
}

void entry_18be3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18be3c inside entry_18be34 (0x18be34 - 0x18be44)
    ctx->pc = 0x18be3c;
    entry_18be34(rdram, ctx, runtime);
}

void entry_18bec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bec0 inside entry_18beb8 (0x18beb8 - 0x18bf00)
    ctx->pc = 0x18bec0;
    entry_18beb8(rdram, ctx, runtime);
}

void entry_18bf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf08 inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf08;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf0c inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf0c;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf30 inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf30;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf4c inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf4c;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf58 inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf58;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf64 inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf64;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf6c inside entry_18bf00 (0x18bf00 - 0x18bf74)
    ctx->pc = 0x18bf6c;
    entry_18bf00(rdram, ctx, runtime);
}

void entry_18bf7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf7c inside entry_18bf74 (0x18bf74 - 0x18bf8c)
    ctx->pc = 0x18bf7c;
    entry_18bf74(rdram, ctx, runtime);
}

void entry_18bf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf90 inside entry_18bf8c (0x18bf8c - 0x18bfa8)
    ctx->pc = 0x18bf90;
    entry_18bf8c(rdram, ctx, runtime);
}

void entry_18bf94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18bf94 inside entry_18bf8c (0x18bf8c - 0x18bfa8)
    ctx->pc = 0x18bf94;
    entry_18bf8c(rdram, ctx, runtime);
}

void entry_18c01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c01c inside CompareSaves__FP4SAVET0 (0x18bfa8 - 0x18c028)
    ctx->pc = 0x18c01c;
    CompareSaves__FP4SAVET0(rdram, ctx, runtime);
}

void entry_18c068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c068 inside FUN_0018c028 (0x18c028 - 0x18c0b0)
    ctx->pc = 0x18c068;
    FUN_0018c028(rdram, ctx, runtime);
}

void entry_18c08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c08c inside FUN_0018c028 (0x18c028 - 0x18c0b0)
    ctx->pc = 0x18c08c;
    FUN_0018c028(rdram, ctx, runtime);
}

void entry_18c0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c0b8 inside entry_18c0b0 (0x18c0b0 - 0x18c0d4)
    ctx->pc = 0x18c0b8;
    entry_18c0b0(rdram, ctx, runtime);
}

void entry_18c0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c0dc inside entry_18c0d4 (0x18c0d4 - 0x18c118)
    ctx->pc = 0x18c0dc;
    entry_18c0d4(rdram, ctx, runtime);
}

void entry_18c0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c0f8 inside entry_18c0d4 (0x18c0d4 - 0x18c118)
    ctx->pc = 0x18c0f8;
    entry_18c0d4(rdram, ctx, runtime);
}

void entry_18c128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c128 inside entry_18c118 (0x18c118 - 0x18c130)
    ctx->pc = 0x18c128;
    entry_18c118(rdram, ctx, runtime);
}

void entry_18c134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c134 inside entry_18c130 (0x18c130 - 0x18c178)
    ctx->pc = 0x18c134;
    entry_18c130(rdram, ctx, runtime);
}

void entry_18c140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c140 inside entry_18c130 (0x18c130 - 0x18c178)
    ctx->pc = 0x18c140;
    entry_18c130(rdram, ctx, runtime);
}

void entry_18c144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c144 inside entry_18c130 (0x18c130 - 0x18c178)
    ctx->pc = 0x18c144;
    entry_18c130(rdram, ctx, runtime);
}

void entry_18c150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c150 inside entry_18c130 (0x18c130 - 0x18c178)
    ctx->pc = 0x18c150;
    entry_18c130(rdram, ctx, runtime);
}

void entry_18c18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c18c inside FUN_0018c178_FP4SAVEi (0x18c178 - 0x18c1a8)
    ctx->pc = 0x18c18c;
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime);
}

void entry_18c19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c19c inside FUN_0018c178_FP4SAVEi (0x18c178 - 0x18c1a8)
    ctx->pc = 0x18c19c;
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime);
}

void entry_18c1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c1cc inside entry_18c1bc (0x18c1bc - 0x18c1e8)
    ctx->pc = 0x18c1cc;
    entry_18c1bc(rdram, ctx, runtime);
}

void entry_18c210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c210 inside entry_18c200 (0x18c200 - 0x18c240)
    ctx->pc = 0x18c210;
    entry_18c200(rdram, ctx, runtime);
}

void entry_18c230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c230 inside entry_18c200 (0x18c200 - 0x18c240)
    ctx->pc = 0x18c230;
    entry_18c200(rdram, ctx, runtime);
}

void entry_18c390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c390 inside entry_18c36c (0x18c36c - 0x18c3ac)
    ctx->pc = 0x18c390;
    entry_18c36c(rdram, ctx, runtime);
}

void entry_18c3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c3f0 inside entry_18c3c0 (0x18c3c0 - 0x18c420)
    ctx->pc = 0x18c3f0;
    entry_18c3c0(rdram, ctx, runtime);
}

void entry_18c3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c3f4 inside entry_18c3c0 (0x18c3c0 - 0x18c420)
    ctx->pc = 0x18c3f4;
    entry_18c3c0(rdram, ctx, runtime);
}

void entry_18c3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c3f8 inside entry_18c3c0 (0x18c3c0 - 0x18c420)
    ctx->pc = 0x18c3f8;
    entry_18c3c0(rdram, ctx, runtime);
}

void entry_18c4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c4b8 inside entry_18c494 (0x18c494 - 0x18c4f0)
    ctx->pc = 0x18c4b8;
    entry_18c494(rdram, ctx, runtime);
}

void entry_18c4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c4d8 inside entry_18c494 (0x18c494 - 0x18c4f0)
    ctx->pc = 0x18c4d8;
    entry_18c494(rdram, ctx, runtime);
}

void entry_18c534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c534 inside entry_18c504 (0x18c504 - 0x18c568)
    ctx->pc = 0x18c534;
    entry_18c504(rdram, ctx, runtime);
}

void entry_18c538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c538 inside entry_18c504 (0x18c504 - 0x18c568)
    ctx->pc = 0x18c538;
    entry_18c504(rdram, ctx, runtime);
}

void entry_18c584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c584 inside FUN_0018c568 (0x18c568 - 0x18c628)
    ctx->pc = 0x18c584;
    FUN_0018c568(rdram, ctx, runtime);
}

void entry_18c5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c5a0 inside FUN_0018c568 (0x18c568 - 0x18c628)
    ctx->pc = 0x18c5a0;
    FUN_0018c568(rdram, ctx, runtime);
}

void entry_18c5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c5f4 inside FUN_0018c568 (0x18c568 - 0x18c628)
    ctx->pc = 0x18c5f4;
    FUN_0018c568(rdram, ctx, runtime);
}

void entry_18c620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c620 inside FUN_0018c568 (0x18c568 - 0x18c628)
    ctx->pc = 0x18c620;
    FUN_0018c568(rdram, ctx, runtime);
}

void entry_18c62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c62c inside entry_18c628 (0x18c628 - 0x18c638)
    ctx->pc = 0x18c62c;
    entry_18c628(rdram, ctx, runtime);
}

void entry_18c660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c660 inside FUN_0018c638 (0x18c638 - 0x18c668)
    ctx->pc = 0x18c660;
    FUN_0018c638(rdram, ctx, runtime);
}

void entry_18c68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c68c inside entry_18c668 (0x18c668 - 0x18c74c)
    ctx->pc = 0x18c68c;
    entry_18c668(rdram, ctx, runtime);
}

void entry_18c6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c6e0 inside entry_18c668 (0x18c668 - 0x18c74c)
    ctx->pc = 0x18c6e0;
    entry_18c668(rdram, ctx, runtime);
}

void entry_18c6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c6ec inside entry_18c668 (0x18c668 - 0x18c74c)
    ctx->pc = 0x18c6ec;
    entry_18c668(rdram, ctx, runtime);
}

void entry_18c71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c71c inside entry_18c668 (0x18c668 - 0x18c74c)
    ctx->pc = 0x18c71c;
    entry_18c668(rdram, ctx, runtime);
}

void entry_18c7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c7e0 inside entry_18c7d8 (0x18c7d8 - 0x18c7f8)
    ctx->pc = 0x18c7e0;
    entry_18c7d8(rdram, ctx, runtime);
}

void entry_18c7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c7e8 inside entry_18c7d8 (0x18c7d8 - 0x18c7f8)
    ctx->pc = 0x18c7e8;
    entry_18c7d8(rdram, ctx, runtime);
}

void entry_18c848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c848 inside entry_18c840 (0x18c840 - 0x18c858)
    ctx->pc = 0x18c848;
    entry_18c840(rdram, ctx, runtime);
}

void entry_18c87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c87c inside entry_18c878 (0x18c878 - 0x18c888)
    ctx->pc = 0x18c87c;
    entry_18c878(rdram, ctx, runtime);
}

void entry_18c8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c8d0 inside FUN_0018c888 (0x18c888 - 0x18c8e0)
    ctx->pc = 0x18c8d0;
    FUN_0018c888(rdram, ctx, runtime);
}

void entry_18c8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c8f4 inside entry_18c8e0 (0x18c8e0 - 0x18c904)
    ctx->pc = 0x18c8f4;
    entry_18c8e0(rdram, ctx, runtime);
}

void entry_18c90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c90c inside entry_18c904 (0x18c904 - 0x18c92c)
    ctx->pc = 0x18c90c;
    entry_18c904(rdram, ctx, runtime);
}

void entry_18c918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c918 inside entry_18c904 (0x18c904 - 0x18c92c)
    ctx->pc = 0x18c918;
    entry_18c904(rdram, ctx, runtime);
}

void entry_18c970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c970 inside entry_18c958 (0x18c958 - 0x18c97c)
    ctx->pc = 0x18c970;
    entry_18c958(rdram, ctx, runtime);
}

void entry_18c994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c994 inside entry_18c97c (0x18c97c - 0x18c9c0)
    ctx->pc = 0x18c994;
    entry_18c97c(rdram, ctx, runtime);
}

void entry_18c998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c998 inside entry_18c97c (0x18c97c - 0x18c9c0)
    ctx->pc = 0x18c998;
    entry_18c97c(rdram, ctx, runtime);
}

void entry_18c99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c99c inside entry_18c97c (0x18c97c - 0x18c9c0)
    ctx->pc = 0x18c99c;
    entry_18c97c(rdram, ctx, runtime);
}

void entry_18c9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18c9f0 inside entry_18c9d8 (0x18c9d8 - 0x18ca10)
    ctx->pc = 0x18c9f0;
    entry_18c9d8(rdram, ctx, runtime);
}

void entry_18ccd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ccd4 inside entry_18ccc4 (0x18ccc4 - 0x18cd04)
    ctx->pc = 0x18ccd4;
    entry_18ccc4(rdram, ctx, runtime);
}

void entry_18ccf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ccf4 inside entry_18ccc4 (0x18ccc4 - 0x18cd04)
    ctx->pc = 0x18ccf4;
    entry_18ccc4(rdram, ctx, runtime);
}

void entry_18cd0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd0c inside entry_18cd04 (0x18cd04 - 0x18cd48)
    ctx->pc = 0x18cd0c;
    entry_18cd04(rdram, ctx, runtime);
}

void entry_18cd14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd14 inside entry_18cd04 (0x18cd04 - 0x18cd48)
    ctx->pc = 0x18cd14;
    entry_18cd04(rdram, ctx, runtime);
}

void entry_18cd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd1c inside entry_18cd04 (0x18cd04 - 0x18cd48)
    ctx->pc = 0x18cd1c;
    entry_18cd04(rdram, ctx, runtime);
}

void entry_18cd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd30 inside entry_18cd04 (0x18cd04 - 0x18cd48)
    ctx->pc = 0x18cd30;
    entry_18cd04(rdram, ctx, runtime);
}

void entry_18cd7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd7c inside entry_18cd60 (0x18cd60 - 0x18cd88)
    ctx->pc = 0x18cd7c;
    entry_18cd60(rdram, ctx, runtime);
}

void entry_18cd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cd80 inside entry_18cd60 (0x18cd60 - 0x18cd88)
    ctx->pc = 0x18cd80;
    entry_18cd60(rdram, ctx, runtime);
}

void entry_18cda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cda0 inside entry_18cd9c (0x18cd9c - 0x18cda8)
    ctx->pc = 0x18cda0;
    entry_18cd9c(rdram, ctx, runtime);
}

void entry_18cf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cf04 inside entry_18cee8 (0x18cee8 - 0x18cf94)
    ctx->pc = 0x18cf04;
    entry_18cee8(rdram, ctx, runtime);
}

void entry_18cf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cf58 inside entry_18cee8 (0x18cee8 - 0x18cf94)
    ctx->pc = 0x18cf58;
    entry_18cee8(rdram, ctx, runtime);
}

void entry_18cf88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cf88 inside entry_18cee8 (0x18cee8 - 0x18cf94)
    ctx->pc = 0x18cf88;
    entry_18cee8(rdram, ctx, runtime);
}

void entry_18cf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cf8c inside entry_18cee8 (0x18cee8 - 0x18cf94)
    ctx->pc = 0x18cf8c;
    entry_18cee8(rdram, ctx, runtime);
}

void entry_18cf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18cf9c inside entry_18cf94 (0x18cf94 - 0x18cfc0)
    ctx->pc = 0x18cf9c;
    entry_18cf94(rdram, ctx, runtime);
}

void entry_18d088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d088 inside entry_18d084 (0x18d084 - 0x18d0a0)
    ctx->pc = 0x18d088;
    entry_18d084(rdram, ctx, runtime);
}

void entry_18d134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d134 inside entry_18d0d8 (0x18d0d8 - 0x18d168)
    ctx->pc = 0x18d134;
    entry_18d0d8(rdram, ctx, runtime);
}

void entry_18d138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d138 inside entry_18d0d8 (0x18d0d8 - 0x18d168)
    ctx->pc = 0x18d138;
    entry_18d0d8(rdram, ctx, runtime);
}

void entry_18d1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d1c8 inside entry_18d1a8 (0x18d1a8 - 0x18d1f8)
    ctx->pc = 0x18d1c8;
    entry_18d1a8(rdram, ctx, runtime);
}

void entry_18d1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d1cc inside entry_18d1a8 (0x18d1a8 - 0x18d1f8)
    ctx->pc = 0x18d1cc;
    entry_18d1a8(rdram, ctx, runtime);
}

void entry_18d1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d1e0 inside entry_18d1a8 (0x18d1a8 - 0x18d1f8)
    ctx->pc = 0x18d1e0;
    entry_18d1a8(rdram, ctx, runtime);
}

void entry_18d3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d3e0 inside entry_18d3c4 (0x18d3c4 - 0x18d3e8)
    ctx->pc = 0x18d3e0;
    entry_18d3c4(rdram, ctx, runtime);
}

void entry_18d3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d3f0 inside entry_18d3e8 (0x18d3e8 - 0x18d410)
    ctx->pc = 0x18d3f0;
    entry_18d3e8(rdram, ctx, runtime);
}

void entry_18d4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d4e4 inside PvAllocGlobalImpl__Fi (0x18d4b0 - 0x18d4f8)
    ctx->pc = 0x18d4e4;
    PvAllocGlobalImpl__Fi(rdram, ctx, runtime);
}

void entry_18d53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d53c inside entry_18d51c (0x18d51c - 0x18d550)
    ctx->pc = 0x18d53c;
    entry_18d51c(rdram, ctx, runtime);
}

void entry_18d540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d540 inside entry_18d51c (0x18d51c - 0x18d550)
    ctx->pc = 0x18d540;
    entry_18d51c(rdram, ctx, runtime);
}

void entry_18d694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d694 inside entry_18d674 (0x18d674 - 0x18d6a8)
    ctx->pc = 0x18d694;
    entry_18d674(rdram, ctx, runtime);
}

void entry_18d698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d698 inside entry_18d674 (0x18d674 - 0x18d6a8)
    ctx->pc = 0x18d698;
    entry_18d674(rdram, ctx, runtime);
}

void entry_18d798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d798 inside CopyAqw__FPvT0i (0x18d780 - 0x18d800)
    ctx->pc = 0x18d798;
    CopyAqw__FPvT0i(rdram, ctx, runtime);
}

void entry_18d7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d7b4 inside CopyAqw__FPvT0i (0x18d780 - 0x18d800)
    ctx->pc = 0x18d7b4;
    CopyAqw__FPvT0i(rdram, ctx, runtime);
}

void entry_18d7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d7c0 inside CopyAqw__FPvT0i (0x18d780 - 0x18d800)
    ctx->pc = 0x18d7c0;
    CopyAqw__FPvT0i(rdram, ctx, runtime);
}

void entry_18d7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d7f4 inside CopyAqw__FPvT0i (0x18d780 - 0x18d800)
    ctx->pc = 0x18d7f4;
    CopyAqw__FPvT0i(rdram, ctx, runtime);
}

void entry_18d820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d820 inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d820;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d844 inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d844;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d868 inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d868;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d884 inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d884;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d890 inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d890;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d8cc inside CopyAb__FPvT0Ui (0x18d800 - 0x18d8d4)
    ctx->pc = 0x18d8cc;
    CopyAb__FPvT0Ui(rdram, ctx, runtime);
}

void entry_18d8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d8d8 inside entry_18d8d4 (0x18d8d4 - 0x18d8e0)
    ctx->pc = 0x18d8d8;
    entry_18d8d4(rdram, ctx, runtime);
}

void entry_18d9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18d9a8 inside entry_18d9a0 (0x18d9a0 - 0x18d9b8)
    ctx->pc = 0x18d9a8;
    entry_18d9a0(rdram, ctx, runtime);
}

void entry_18dae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dae4 inside entry_18da80 (0x18da80 - 0x18daf8)
    ctx->pc = 0x18dae4;
    entry_18da80(rdram, ctx, runtime);
}

void entry_18db10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18db10 inside entry_18db0c (0x18db0c - 0x18db20)
    ctx->pc = 0x18db10;
    entry_18db0c(rdram, ctx, runtime);
}

void entry_18db84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18db84 inside entry_18db7c (0x18db7c - 0x18db98)
    ctx->pc = 0x18db84;
    entry_18db7c(rdram, ctx, runtime);
}

void entry_18dba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dba0 inside entry_18db98 (0x18db98 - 0x18dbd4)
    ctx->pc = 0x18dba0;
    entry_18db98(rdram, ctx, runtime);
}

void entry_18dbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dbb0 inside entry_18db98 (0x18db98 - 0x18dbd4)
    ctx->pc = 0x18dbb0;
    entry_18db98(rdram, ctx, runtime);
}

void entry_18dbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dbdc inside entry_18dbd4 (0x18dbd4 - 0x18dc14)
    ctx->pc = 0x18dbdc;
    entry_18dbd4(rdram, ctx, runtime);
}

void entry_18dc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dc04 inside entry_18dbd4 (0x18dbd4 - 0x18dc14)
    ctx->pc = 0x18dc04;
    entry_18dbd4(rdram, ctx, runtime);
}

void entry_18dc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dc6c inside entry_18dc68 (0x18dc68 - 0x18dc88)
    ctx->pc = 0x18dc6c;
    entry_18dc68(rdram, ctx, runtime);
}

void entry_18dcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dcb4 inside FUN_0018dc88 (0x18dc88 - 0x18dcd4)
    ctx->pc = 0x18dcb4;
    FUN_0018dc88(rdram, ctx, runtime);
}

void entry_18dcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dcbc inside FUN_0018dc88 (0x18dc88 - 0x18dcd4)
    ctx->pc = 0x18dcbc;
    FUN_0018dc88(rdram, ctx, runtime);
}

void entry_18dcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dcc8 inside FUN_0018dc88 (0x18dc88 - 0x18dcd4)
    ctx->pc = 0x18dcc8;
    FUN_0018dc88(rdram, ctx, runtime);
}

void entry_18dcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dcec inside entry_18dcd4 (0x18dcd4 - 0x18dd0c)
    ctx->pc = 0x18dcec;
    entry_18dcd4(rdram, ctx, runtime);
}

void entry_18dd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dd00 inside entry_18dcd4 (0x18dcd4 - 0x18dd0c)
    ctx->pc = 0x18dd00;
    entry_18dcd4(rdram, ctx, runtime);
}

void entry_18dd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dd24 inside entry_18dd0c (0x18dd0c - 0x18dd30)
    ctx->pc = 0x18dd24;
    entry_18dd0c(rdram, ctx, runtime);
}

void entry_18dd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dd70 inside FUN_0018dd50 (0x18dd50 - 0x18dd78)
    ctx->pc = 0x18dd70;
    FUN_0018dd50(rdram, ctx, runtime);
}

void entry_18dd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18dd98 inside FUN_0018dd78 (0x18dd78 - 0x18dda0)
    ctx->pc = 0x18dd98;
    FUN_0018dd78(rdram, ctx, runtime);
}

void entry_18de4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18de4c inside entry_18ddec (0x18ddec - 0x18de70)
    ctx->pc = 0x18de4c;
    entry_18ddec(rdram, ctx, runtime);
}

void entry_18de58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18de58 inside entry_18ddec (0x18ddec - 0x18de70)
    ctx->pc = 0x18de58;
    entry_18ddec(rdram, ctx, runtime);
}

void entry_18df24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18df24 inside entry_18df00 (0x18df00 - 0x18df48)
    ctx->pc = 0x18df24;
    entry_18df00(rdram, ctx, runtime);
}

void entry_18e028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e028 inside entry_18e000 (0x18e000 - 0x18e040)
    ctx->pc = 0x18e028;
    entry_18e000(rdram, ctx, runtime);
}

void entry_18e140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e140 inside entry_18e0c0 (0x18e0c0 - 0x18e1c8)
    ctx->pc = 0x18e140;
    entry_18e0c0(rdram, ctx, runtime);
}

void entry_18e190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e190 inside entry_18e0c0 (0x18e0c0 - 0x18e1c8)
    ctx->pc = 0x18e190;
    entry_18e0c0(rdram, ctx, runtime);
}

void entry_18e198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e198 inside entry_18e0c0 (0x18e0c0 - 0x18e1c8)
    ctx->pc = 0x18e198;
    entry_18e0c0(rdram, ctx, runtime);
}

void entry_18e1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e1dc inside entry_18e1c8 (0x18e1c8 - 0x18e300)
    ctx->pc = 0x18e1dc;
    entry_18e1c8(rdram, ctx, runtime);
}

void entry_18e210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e210 inside entry_18e1c8 (0x18e1c8 - 0x18e300)
    ctx->pc = 0x18e210;
    entry_18e1c8(rdram, ctx, runtime);
}

void entry_18e27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e27c inside entry_18e1c8 (0x18e1c8 - 0x18e300)
    ctx->pc = 0x18e27c;
    entry_18e1c8(rdram, ctx, runtime);
}

void entry_18e2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e2d4 inside entry_18e1c8 (0x18e1c8 - 0x18e300)
    ctx->pc = 0x18e2d4;
    entry_18e1c8(rdram, ctx, runtime);
}

void entry_18e2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e2e0 inside entry_18e1c8 (0x18e1c8 - 0x18e300)
    ctx->pc = 0x18e2e0;
    entry_18e1c8(rdram, ctx, runtime);
}

void entry_18e350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e350 inside entry_18e34c (0x18e34c - 0x18e3a8)
    ctx->pc = 0x18e350;
    entry_18e34c(rdram, ctx, runtime);
}

void entry_18e388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e388 inside entry_18e34c (0x18e34c - 0x18e3a8)
    ctx->pc = 0x18e388;
    entry_18e34c(rdram, ctx, runtime);
}

void entry_18e3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e3c0 inside entry_18e3a8 (0x18e3a8 - 0x18e3e0)
    ctx->pc = 0x18e3c0;
    entry_18e3a8(rdram, ctx, runtime);
}

void entry_18e3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e3e4 inside entry_18e3e0 (0x18e3e0 - 0x18e410)
    ctx->pc = 0x18e3e4;
    entry_18e3e0(rdram, ctx, runtime);
}

void entry_18e420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e420 inside FUN_0018e410 (0x18e410 - 0x18e480)
    ctx->pc = 0x18e420;
    FUN_0018e410(rdram, ctx, runtime);
}

void entry_18e440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e440 inside FUN_0018e410 (0x18e410 - 0x18e480)
    ctx->pc = 0x18e440;
    FUN_0018e410(rdram, ctx, runtime);
}

void entry_18e45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e45c inside FUN_0018e410 (0x18e410 - 0x18e480)
    ctx->pc = 0x18e45c;
    FUN_0018e410(rdram, ctx, runtime);
}

void entry_18e46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e46c inside FUN_0018e410 (0x18e410 - 0x18e480)
    ctx->pc = 0x18e46c;
    FUN_0018e410(rdram, ctx, runtime);
}

void entry_18e4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e4a4 inside FUN_0018e480 (0x18e480 - 0x18e4c0)
    ctx->pc = 0x18e4a4;
    FUN_0018e480(rdram, ctx, runtime);
}

void entry_18e4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e4b8 inside FUN_0018e480 (0x18e480 - 0x18e4c0)
    ctx->pc = 0x18e4b8;
    FUN_0018e480(rdram, ctx, runtime);
}

void entry_18e52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e52c inside entry_18e504 (0x18e504 - 0x18e558)
    ctx->pc = 0x18e52c;
    entry_18e504(rdram, ctx, runtime);
}

void entry_18e534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e534 inside entry_18e504 (0x18e504 - 0x18e558)
    ctx->pc = 0x18e534;
    entry_18e504(rdram, ctx, runtime);
}

void entry_18e588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e588 inside FUN_0018e558 (0x18e558 - 0x18e594)
    ctx->pc = 0x18e588;
    FUN_0018e558(rdram, ctx, runtime);
}

void entry_18e704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e704 inside CbWrite__15CQueueOutputIopiPv (0x18e6c0 - 0x18e78c)
    ctx->pc = 0x18e704;
    CbWrite__15CQueueOutputIopiPv(rdram, ctx, runtime);
}

void entry_18e710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e710 inside CbWrite__15CQueueOutputIopiPv (0x18e6c0 - 0x18e78c)
    ctx->pc = 0x18e710;
    CbWrite__15CQueueOutputIopiPv(rdram, ctx, runtime);
}

void entry_18e718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e718 inside CbWrite__15CQueueOutputIopiPv (0x18e6c0 - 0x18e78c)
    ctx->pc = 0x18e718;
    CbWrite__15CQueueOutputIopiPv(rdram, ctx, runtime);
}

void entry_18e738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e738 inside CbWrite__15CQueueOutputIopiPv (0x18e6c0 - 0x18e78c)
    ctx->pc = 0x18e738;
    CbWrite__15CQueueOutputIopiPv(rdram, ctx, runtime);
}

void entry_18e768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e768 inside CbWrite__15CQueueOutputIopiPv (0x18e6c0 - 0x18e78c)
    ctx->pc = 0x18e768;
    CbWrite__15CQueueOutputIopiPv(rdram, ctx, runtime);
}

void entry_18e798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e798 inside entry_18e78c (0x18e78c - 0x18e7c0)
    ctx->pc = 0x18e798;
    entry_18e78c(rdram, ctx, runtime);
}

void entry_18e810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e810 inside entry_18e808 (0x18e808 - 0x18e818)
    ctx->pc = 0x18e810;
    entry_18e808(rdram, ctx, runtime);
}

void entry_18e884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e884 inside entry_18e84c (0x18e84c - 0x18e8c0)
    ctx->pc = 0x18e884;
    entry_18e84c(rdram, ctx, runtime);
}

void entry_18e980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e980 inside entry_18e97c (0x18e97c - 0x18e988)
    ctx->pc = 0x18e980;
    entry_18e97c(rdram, ctx, runtime);
}

void entry_18e9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18e9fc inside entry_18e9e8 (0x18e9e8 - 0x18ea10)
    ctx->pc = 0x18e9fc;
    entry_18e9e8(rdram, ctx, runtime);
}

void entry_18ea90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ea90 inside entry_18ea8c (0x18ea8c - 0x18eaa0)
    ctx->pc = 0x18ea90;
    entry_18ea8c(rdram, ctx, runtime);
}

void entry_18eb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eb58 inside entry_18eb40 (0x18eb40 - 0x18eb7c)
    ctx->pc = 0x18eb58;
    entry_18eb40(rdram, ctx, runtime);
}

void entry_18eb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eb68 inside entry_18eb40 (0x18eb40 - 0x18eb7c)
    ctx->pc = 0x18eb68;
    entry_18eb40(rdram, ctx, runtime);
}

void entry_18eb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eb70 inside entry_18eb40 (0x18eb40 - 0x18eb7c)
    ctx->pc = 0x18eb70;
    entry_18eb40(rdram, ctx, runtime);
}

void entry_18eb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eb80 inside entry_18eb7c (0x18eb7c - 0x18eb98)
    ctx->pc = 0x18eb80;
    entry_18eb7c(rdram, ctx, runtime);
}

void entry_18ebcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ebcc inside Update__10CMpegAudio (0x18eb98 - 0x18ebdc)
    ctx->pc = 0x18ebcc;
    Update__10CMpegAudio(rdram, ctx, runtime);
}

void entry_18ec0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ec0c inside entry_18ec00 (0x18ec00 - 0x18ec18)
    ctx->pc = 0x18ec0c;
    entry_18ec00(rdram, ctx, runtime);
}

void entry_18ec2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ec2c inside entry_18ec28 (0x18ec28 - 0x18ec40)
    ctx->pc = 0x18ec2c;
    entry_18ec28(rdram, ctx, runtime);
}

void entry_18ec30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ec30 inside entry_18ec28 (0x18ec28 - 0x18ec40)
    ctx->pc = 0x18ec30;
    entry_18ec28(rdram, ctx, runtime);
}

void entry_18ec74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ec74 inside entry_18ec70 (0x18ec70 - 0x18ec80)
    ctx->pc = 0x18ec74;
    entry_18ec70(rdram, ctx, runtime);
}

void entry_18ecd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ecd0 inside FMpegDecodeVideo__FP7sceMpegP13sceMpegCbDataP5CMpeg (0x18eca8 - 0x18ece8)
    ctx->pc = 0x18ecd0;
    FMpegDecodeVideo__FP7sceMpegP13sceMpegCbDataP5CMpeg(rdram, ctx, runtime);
}

void entry_18ee68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ee68 inside entry_18ee58 (0x18ee58 - 0x18ee90)
    ctx->pc = 0x18ee68;
    entry_18ee58(rdram, ctx, runtime);
}

void entry_18ee80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18ee80 inside entry_18ee58 (0x18ee58 - 0x18ee90)
    ctx->pc = 0x18ee80;
    entry_18ee58(rdram, ctx, runtime);
}

void entry_18eee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eee8 inside entry_18eedc (0x18eedc - 0x18ef0c)
    ctx->pc = 0x18eee8;
    entry_18eedc(rdram, ctx, runtime);
}

void entry_18eef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18eef8 inside entry_18eedc (0x18eedc - 0x18ef0c)
    ctx->pc = 0x18eef8;
    entry_18eedc(rdram, ctx, runtime);
}

void entry_18f120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f120 inside entry_18f108 (0x18f108 - 0x18f148)
    ctx->pc = 0x18f120;
    entry_18f108(rdram, ctx, runtime);
}

void entry_18f124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f124 inside entry_18f108 (0x18f108 - 0x18f148)
    ctx->pc = 0x18f124;
    entry_18f108(rdram, ctx, runtime);
}

void entry_18f13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f13c inside entry_18f108 (0x18f108 - 0x18f148)
    ctx->pc = 0x18f13c;
    entry_18f108(rdram, ctx, runtime);
}

void entry_18f1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f1f8 inside entry_18f1e8 (0x18f1e8 - 0x18f200)
    ctx->pc = 0x18f1f8;
    entry_18f1e8(rdram, ctx, runtime);
}

void entry_18f208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f208 inside entry_18f200 (0x18f200 - 0x18f23c)
    ctx->pc = 0x18f208;
    entry_18f200(rdram, ctx, runtime);
}

void entry_18f228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f228 inside entry_18f200 (0x18f200 - 0x18f23c)
    ctx->pc = 0x18f228;
    entry_18f200(rdram, ctx, runtime);
}

void entry_18f260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f260 inside entry_18f250 (0x18f250 - 0x18f270)
    ctx->pc = 0x18f260;
    entry_18f250(rdram, ctx, runtime);
}

void entry_18f28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f28c inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f28c;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f2a4 inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f2a4;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f2c0 inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f2c0;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f2d0 inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f2d0;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f2e8 inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f2e8;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f2ec inside entry_18f278 (0x18f278 - 0x18f320)
    ctx->pc = 0x18f2ec;
    entry_18f278(rdram, ctx, runtime);
}

void entry_18f338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f338 inside entry_18f320 (0x18f320 - 0x18f340)
    ctx->pc = 0x18f338;
    entry_18f320(rdram, ctx, runtime);
}

void entry_18f36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f36c inside entry_18f364 (0x18f364 - 0x18f3c0)
    ctx->pc = 0x18f36c;
    entry_18f364(rdram, ctx, runtime);
}

void entry_18f38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f38c inside entry_18f364 (0x18f364 - 0x18f3c0)
    ctx->pc = 0x18f38c;
    entry_18f364(rdram, ctx, runtime);
}

void entry_18f3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f3a8 inside entry_18f364 (0x18f364 - 0x18f3c0)
    ctx->pc = 0x18f3a8;
    entry_18f364(rdram, ctx, runtime);
}

void entry_18f3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f3b8 inside entry_18f364 (0x18f364 - 0x18f3c0)
    ctx->pc = 0x18f3b8;
    entry_18f364(rdram, ctx, runtime);
}

void entry_18f3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f3d0 inside entry_18f3c8 (0x18f3c8 - 0x18f410)
    ctx->pc = 0x18f3d0;
    entry_18f3c8(rdram, ctx, runtime);
}

void entry_18f540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f540 inside entry_18f53c (0x18f53c - 0x18f548)
    ctx->pc = 0x18f540;
    entry_18f53c(rdram, ctx, runtime);
}

void entry_18f5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f5b0 inside entry_18f548 (0x18f548 - 0x18f610)
    ctx->pc = 0x18f5b0;
    entry_18f548(rdram, ctx, runtime);
}

void entry_18f5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f5c8 inside entry_18f548 (0x18f548 - 0x18f610)
    ctx->pc = 0x18f5c8;
    entry_18f548(rdram, ctx, runtime);
}

void entry_18f5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f5dc inside entry_18f548 (0x18f548 - 0x18f610)
    ctx->pc = 0x18f5dc;
    entry_18f548(rdram, ctx, runtime);
}

void entry_18f5e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f5e0 inside entry_18f548 (0x18f548 - 0x18f610)
    ctx->pc = 0x18f5e0;
    entry_18f548(rdram, ctx, runtime);
}

void entry_18f6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f6e0 inside FUN_0018f610__5CMpeg (0x18f610 - 0x18f6e8)
    ctx->pc = 0x18f6e0;
    FUN_0018f610__5CMpeg(rdram, ctx, runtime);
}

void entry_18f718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f718 inside Update__5CMpeg (0x18f6e8 - 0x18f720)
    ctx->pc = 0x18f718;
    Update__5CMpeg(rdram, ctx, runtime);
}

void entry_18f730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f730 inside entry_18f720 (0x18f720 - 0x18f73c)
    ctx->pc = 0x18f730;
    entry_18f720(rdram, ctx, runtime);
}

void entry_18f790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f790 inside entry_18f77c (0x18f77c - 0x18f798)
    ctx->pc = 0x18f790;
    entry_18f77c(rdram, ctx, runtime);
}

void entry_18f7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f7ac inside entry_18f7a0 (0x18f7a0 - 0x18f7b4)
    ctx->pc = 0x18f7ac;
    entry_18f7a0(rdram, ctx, runtime);
}

void entry_18f7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f7c0 inside entry_18f7bc (0x18f7bc - 0x18f7d0)
    ctx->pc = 0x18f7c0;
    entry_18f7bc(rdram, ctx, runtime);
}

void entry_18f820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f820 inside entry_18f814 (0x18f814 - 0x18f848)
    ctx->pc = 0x18f820;
    entry_18f814(rdram, ctx, runtime);
}

void entry_18f83c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f83c inside entry_18f814 (0x18f814 - 0x18f848)
    ctx->pc = 0x18f83c;
    entry_18f814(rdram, ctx, runtime);
}

void entry_18f860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f860 inside entry_18f848 (0x18f848 - 0x18f890)
    ctx->pc = 0x18f860;
    entry_18f848(rdram, ctx, runtime);
}

void entry_18f864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f864 inside entry_18f848 (0x18f848 - 0x18f890)
    ctx->pc = 0x18f864;
    entry_18f848(rdram, ctx, runtime);
}

void entry_18f8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f8b0 inside CbDemuxed__5CMpegi (0x18f890 - 0x18f8b8)
    ctx->pc = 0x18f8b0;
    CbDemuxed__5CMpegi(rdram, ctx, runtime);
}

void entry_18f8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f8d4 inside entry_18f8b8 (0x18f8b8 - 0x18f8f0)
    ctx->pc = 0x18f8d4;
    entry_18f8b8(rdram, ctx, runtime);
}

void entry_18f8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f8e0 inside entry_18f8b8 (0x18f8b8 - 0x18f8f0)
    ctx->pc = 0x18f8e0;
    entry_18f8b8(rdram, ctx, runtime);
}

void entry_18f924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f924 inside entry_18f920 (0x18f920 - 0x18f938)
    ctx->pc = 0x18f924;
    entry_18f920(rdram, ctx, runtime);
}

void entry_18f960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18f960 inside mpeg__static_initialization_and_destruction_0 (0x18f940 - 0x18f968)
    ctx->pc = 0x18f960;
    mpeg__static_initialization_and_destruction_0(rdram, ctx, runtime);
}

void entry_18fab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fab0 inside entry_18faa0 (0x18faa0 - 0x18facc)
    ctx->pc = 0x18fab0;
    entry_18faa0(rdram, ctx, runtime);
}

void entry_18fb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fb88 inside entry_18fb54 (0x18fb54 - 0x18fc28)
    ctx->pc = 0x18fb88;
    entry_18fb54(rdram, ctx, runtime);
}

void entry_18fc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fc74 inside entry_18fc64 (0x18fc64 - 0x18fcec)
    ctx->pc = 0x18fc74;
    entry_18fc64(rdram, ctx, runtime);
}

void entry_18fc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fc80 inside entry_18fc64 (0x18fc64 - 0x18fcec)
    ctx->pc = 0x18fc80;
    entry_18fc64(rdram, ctx, runtime);
}

void entry_18fc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fc84 inside entry_18fc64 (0x18fc64 - 0x18fcec)
    ctx->pc = 0x18fc84;
    entry_18fc64(rdram, ctx, runtime);
}

void entry_18fcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fcb0 inside entry_18fc64 (0x18fc64 - 0x18fcec)
    ctx->pc = 0x18fcb0;
    entry_18fc64(rdram, ctx, runtime);
}

void entry_18fcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fcfc inside entry_18fcec (0x18fcec - 0x18fe0c)
    ctx->pc = 0x18fcfc;
    entry_18fcec(rdram, ctx, runtime);
}

void entry_18fd6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fd6c inside entry_18fcec (0x18fcec - 0x18fe0c)
    ctx->pc = 0x18fd6c;
    entry_18fcec(rdram, ctx, runtime);
}

void entry_18fd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fd88 inside entry_18fcec (0x18fcec - 0x18fe0c)
    ctx->pc = 0x18fd88;
    entry_18fcec(rdram, ctx, runtime);
}

void entry_18fde4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fde4 inside entry_18fcec (0x18fcec - 0x18fe0c)
    ctx->pc = 0x18fde4;
    entry_18fcec(rdram, ctx, runtime);
}

void entry_18fde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fde8 inside entry_18fcec (0x18fcec - 0x18fe0c)
    ctx->pc = 0x18fde8;
    entry_18fcec(rdram, ctx, runtime);
}

void entry_18fe10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fe10 inside entry_18fe0c (0x18fe0c - 0x18fe20)
    ctx->pc = 0x18fe10;
    entry_18fe0c(rdram, ctx, runtime);
}

void entry_18fe40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fe40 inside entry_18fe20 (0x18fe20 - 0x18fe5c)
    ctx->pc = 0x18fe40;
    entry_18fe20(rdram, ctx, runtime);
}

void entry_18fe7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fe7c inside entry_18fe64 (0x18fe64 - 0x18fef8)
    ctx->pc = 0x18fe7c;
    entry_18fe64(rdram, ctx, runtime);
}

void entry_18fea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fea0 inside entry_18fe64 (0x18fe64 - 0x18fef8)
    ctx->pc = 0x18fea0;
    entry_18fe64(rdram, ctx, runtime);
}

void entry_18fea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fea4 inside entry_18fe64 (0x18fe64 - 0x18fef8)
    ctx->pc = 0x18fea4;
    entry_18fe64(rdram, ctx, runtime);
}

void entry_18feb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18feb4 inside entry_18fe64 (0x18fe64 - 0x18fef8)
    ctx->pc = 0x18feb4;
    entry_18fe64(rdram, ctx, runtime);
}

void entry_18fecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fecc inside entry_18fe64 (0x18fe64 - 0x18fef8)
    ctx->pc = 0x18fecc;
    entry_18fe64(rdram, ctx, runtime);
}

void entry_18fff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x18fff8 inside FUN_0018ffb0 (0x18ffb0 - 0x190058)
    ctx->pc = 0x18fff8;
    FUN_0018ffb0(rdram, ctx, runtime);
}

