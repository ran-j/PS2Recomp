// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1126bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1126bc) {
        switch (ctx->pc) {
            case 0x1126d0: ctx->pc = 0; goto label_1126d0;
            case 0x1126f8: ctx->pc = 0; goto label_1126f8;
            case 0x11271c: ctx->pc = 0; goto label_11271c;
            case 0x112720: ctx->pc = 0; goto label_112720;
            case 0x112730: ctx->pc = 0; goto label_112730;
            case 0x112748: ctx->pc = 0; goto label_112748;
            case 0x112750: ctx->pc = 0; goto label_112750;
            case 0x11275c: ctx->pc = 0; goto label_11275c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1126bc: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1126c0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1126c4: 0x10400002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1126d0;
    }
    // 0x1126cc: 0x8e11000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_1126d0:
    // 0x1126d0: 0x24020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1126d4: 0x1062002d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x11278C; return;
    }
    // 0x1126dc: 0x14400006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1126f8;
    }
    // 0x1126e4: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1126e8: 0x1062003c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1127DC; return;
    }
    // 0x1126f0: 0x10000090
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112934; return;
    }
label_1126f8:
    // 0x1126f8: 0x1440008e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x112934; return;
    }
    // 0x112700: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x112704: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
        goto label_11271c;
    }
    // 0x11270c: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x112710: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x112714: 0x10000002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_112720;
    }
label_11271c:
    // 0x11271c: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_112720:
    // 0x112720: 0x1220000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_11275c;
    }
    // 0x112728: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11272c: 0x0
    // NOP
label_112730:
    // 0x112730: 0x54440005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
        goto label_112748;
    }
    // 0x112738: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11273c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x112740: 0x10000003
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_112750;
    }
label_112748:
    // 0x112748: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11274c: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
label_112750:
    // 0x112750: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x112754: 0x5620fff6
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_112730;
    }
label_11275c:
    // 0x11275c: 0x10600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11277C; return;
    }
    // 0x112764: 0x46006024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[12]);
    // 0x112768: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x11276c: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x112774);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_112774
// Address: 0x112774 - 0x112784

void entry_112774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112774) {
        switch (ctx->pc) {
            case 0x11277c: ctx->pc = 0; goto label_11277c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112774: 0x1000006f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112934; return;
    }
label_11277c:
    // 0x11277c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x112784);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_112784
// Address: 0x112784 - 0x112794

void entry_112784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112784) {
        switch (ctx->pc) {
            case 0x11278c: ctx->pc = 0; goto label_11278c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112784: 0x1000006b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112934; return;
    }
label_11278c:
    // 0x11278c: 0xc047142
    SET_GPR_U32(ctx, 31, 0x112794);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112794
// Address: 0x112794 - 0x1127d4

void entry_112794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112794) {
        switch (ctx->pc) {
            case 0x1127b0: ctx->pc = 0; goto label_1127b0;
            case 0x1127cc: ctx->pc = 0; goto label_1127cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112794: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112798: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11279c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1127a0: 0x1220000a
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1127cc;
    }
    // 0x1127a8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1127ac: 0x0
    // NOP
label_1127b0:
    // 0x1127b0: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1127b4: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1127b8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1127bc: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1127c0: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1127c4: 0x5620fffa
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_1127b0;
    }
label_1127cc:
    // 0x1127cc: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1127d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1127d4
// Address: 0x1127d4 - 0x1127e4

void entry_1127d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1127d4) {
        switch (ctx->pc) {
            case 0x1127dc: ctx->pc = 0; goto label_1127dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1127d4: 0x10000057
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112934; return;
    }
label_1127dc:
    // 0x1127dc: 0xc047186
    SET_GPR_U32(ctx, 31, 0x1127e4);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1127e4
// Address: 0x1127e4 - 0x112930

void entry_1127e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1127e4) {
        switch (ctx->pc) {
            case 0x112818: ctx->pc = 0; goto label_112818;
            case 0x112924: ctx->pc = 0; goto label_112924;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1127e4: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1127e8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1127ec: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1127f0: 0x7ce20000
    WRITE128(ADD32(GPR_U32(ctx, 7), 0), GPR_VEC(ctx, 2));
    // 0x1127f4: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1127f8: 0x7ce30010
    WRITE128(ADD32(GPR_U32(ctx, 7), 16), GPR_VEC(ctx, 3));
    // 0x1127fc: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x112800: 0x7ce20020
    WRITE128(ADD32(GPR_U32(ctx, 7), 32), GPR_VEC(ctx, 2));
    // 0x112804: 0x78830030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x112808: 0x12200046
    WRITE128(ADD32(GPR_U32(ctx, 7), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_112924;
    }
    // 0x112810: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x112814: 0x0
    // NOP
label_112818:
    // 0x112818: 0xc4e10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11281c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x112820: 0xc4e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[2] = *(float*)&val; }
    // 0x112824: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x112828: 0xc4e30008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 8)); ctx->f[3] = *(float*)&val; }
    // 0x11282c: 0xc4e4000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 12)); ctx->f[4] = *(float*)&val; }
    // 0x112830: 0xc4e50010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 16)); ctx->f[5] = *(float*)&val; }
    // 0x112834: 0xe4e10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x112838: 0xc4e60014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[6] = *(float*)&val; }
    // 0x11283c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112840: 0xc4e10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[1] = *(float*)&val; }
    // 0x112844: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x112848: 0xc4e7001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 28)); ctx->f[7] = *(float*)&val; }
    // 0x11284c: 0xc4e80020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 32)); ctx->f[8] = *(float*)&val; }
    // 0x112850: 0xc4e90024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 36)); ctx->f[9] = *(float*)&val; }
    // 0x112854: 0xe4e20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 7), 4), *(uint32_t*)&val); }
    // 0x112858: 0xc4ea0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 40)); ctx->f[10] = *(float*)&val; }
    // 0x11285c: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x112860: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x112864: 0xe4e30008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 7), 8), *(uint32_t*)&val); }
    // 0x112868: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x11286c: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x112870: 0xe4e4000c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 7), 12), *(uint32_t*)&val); }
    // 0x112874: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x112878: 0x46002940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[0]);
    // 0x11287c: 0xe4e50010
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 7), 16), *(uint32_t*)&val); }
    // 0x112880: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x112884: 0x46003180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[0]);
    // 0x112888: 0xe4e60014
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 7), 20), *(uint32_t*)&val); }
    // 0x11288c: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x112890: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x112894: 0xe4e10018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 24), *(uint32_t*)&val); }
    // 0x112898: 0xc440001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[0] = *(float*)&val; }
    // 0x11289c: 0x460039c0
    ctx->f[7] = FPU_ADD_S(ctx->f[7], ctx->f[0]);
    // 0x1128a0: 0xe4e7001c
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 7), 28), *(uint32_t*)&val); }
    // 0x1128a4: 0xc4400020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1128a8: 0x46004200
    ctx->f[8] = FPU_ADD_S(ctx->f[8], ctx->f[0]);
    // 0x1128ac: 0xe4e80020
    { float val = ctx->f[8]; WRITE32(ADD32(GPR_U32(ctx, 7), 32), *(uint32_t*)&val); }
    // 0x1128b0: 0xc4400024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1128b4: 0x46004a40
    ctx->f[9] = FPU_ADD_S(ctx->f[9], ctx->f[0]);
    // 0x1128b8: 0xe4e90024
    { float val = ctx->f[9]; WRITE32(ADD32(GPR_U32(ctx, 7), 36), *(uint32_t*)&val); }
    // 0x1128bc: 0xc4400028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1128c0: 0x46005280
    ctx->f[10] = FPU_ADD_S(ctx->f[10], ctx->f[0]);
    // 0x1128c4: 0xe4ea0028
    { float val = ctx->f[10]; WRITE32(ADD32(GPR_U32(ctx, 7), 40), *(uint32_t*)&val); }
    // 0x1128c8: 0xc440002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 44)); ctx->f[0] = *(float*)&val; }
    // 0x1128cc: 0xc4e1002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1128d0: 0xc4e20030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 48)); ctx->f[2] = *(float*)&val; }
    // 0x1128d4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1128d8: 0xc4e30034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 52)); ctx->f[3] = *(float*)&val; }
    // 0x1128dc: 0xc4e40038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 56)); ctx->f[4] = *(float*)&val; }
    // 0x1128e0: 0xc4e5003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 60)); ctx->f[5] = *(float*)&val; }
    // 0x1128e4: 0xe4e1002c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 44), *(uint32_t*)&val); }
    // 0x1128e8: 0xc4400030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1128ec: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1128f0: 0xe4e20030
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 7), 48), *(uint32_t*)&val); }
    // 0x1128f4: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1128f8: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1128fc: 0xe4e30034
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 7), 52), *(uint32_t*)&val); }
    // 0x112900: 0xc4400038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
    // 0x112904: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x112908: 0xe4e40038
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 7), 56), *(uint32_t*)&val); }
    // 0x11290c: 0xc440003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[0] = *(float*)&val; }
    // 0x112910: 0x46002940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[0]);
    // 0x112914: 0xe4e5003c
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 7), 60), *(uint32_t*)&val); }
    // 0x112918: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x11291c: 0x5620ffbe
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_112818;
    }
label_112924:
    // 0x112924: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x112928: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x112930);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_112930
// Address: 0x112930 - 0x11293c

void entry_112930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112930) {
        switch (ctx->pc) {
            case 0x112934: ctx->pc = 0; goto label_112934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112930: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_112934:
    // 0x112934: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11293c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11293c
// Address: 0x11293c - 0x112948

void entry_11293c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11293c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x112940: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x112948);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_112948
// Address: 0x112948 - 0x112968

void entry_112948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112948: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11294c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x112950: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x112954: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x112958: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11295c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x112964: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x112968; return;
}


// Function: RefOpSub__FiP4CRefP6CFrame
// Address: 0x112968 - 0x11298c

void entry_11298c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11298c) {
        switch (ctx->pc) {
            case 0x1129a0: ctx->pc = 0; goto label_1129a0;
            case 0x1129c8: ctx->pc = 0; goto label_1129c8;
            case 0x1129ec: ctx->pc = 0; goto label_1129ec;
            case 0x1129f0: ctx->pc = 0; goto label_1129f0;
            case 0x112a00: ctx->pc = 0; goto label_112a00;
            case 0x112a18: ctx->pc = 0; goto label_112a18;
            case 0x112a20: ctx->pc = 0; goto label_112a20;
            case 0x112a2c: ctx->pc = 0; goto label_112a2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11298c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x112990: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x112994: 0x10400002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1129a0;
    }
    // 0x11299c: 0x8e11000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_1129a0:
    // 0x1129a0: 0x24020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1129a4: 0x1062002d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x112A5C; return;
    }
    // 0x1129ac: 0x14400006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1129c8;
    }
    // 0x1129b4: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1129b8: 0x1062003c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x112AAC; return;
    }
    // 0x1129c0: 0x10000090
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112C04; return;
    }
label_1129c8:
    // 0x1129c8: 0x1440008e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x112C04; return;
    }
    // 0x1129d0: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1129d4: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
        goto label_1129ec;
    }
    // 0x1129dc: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1129e0: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x1129e4: 0x10000002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1129f0;
    }
label_1129ec:
    // 0x1129ec: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1129f0:
    // 0x1129f0: 0x1220000e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_112a2c;
    }
    // 0x1129f8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1129fc: 0x0
    // NOP
label_112a00:
    // 0x112a00: 0x54440005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
        goto label_112a18;
    }
    // 0x112a08: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112a0c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x112a10: 0x10000003
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_112a20;
    }
label_112a18:
    // 0x112a18: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x112a1c: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
label_112a20:
    // 0x112a20: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x112a24: 0x5620fff6
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_112a00;
    }
label_112a2c:
    // 0x112a2c: 0x10600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112A4C; return;
    }
    // 0x112a34: 0x46006024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[12]);
    // 0x112a38: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x112a3c: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x112a44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_112a44
// Address: 0x112a44 - 0x112a54

void entry_112a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112a44) {
        switch (ctx->pc) {
            case 0x112a4c: ctx->pc = 0; goto label_112a4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112a44: 0x1000006f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112C04; return;
    }
label_112a4c:
    // 0x112a4c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x112a54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_112a54
// Address: 0x112a54 - 0x112a64

void entry_112a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112a54) {
        switch (ctx->pc) {
            case 0x112a5c: ctx->pc = 0; goto label_112a5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112a54: 0x1000006b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112C04; return;
    }
label_112a5c:
    // 0x112a5c: 0xc047142
    SET_GPR_U32(ctx, 31, 0x112a64);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112a64
// Address: 0x112a64 - 0x112aa4

void entry_112a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112a64) {
        switch (ctx->pc) {
            case 0x112a80: ctx->pc = 0; goto label_112a80;
            case 0x112a9c: ctx->pc = 0; goto label_112a9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112a64: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112a68: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112a6c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112a70: 0x1220000a
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_112a9c;
    }
    // 0x112a78: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x112a7c: 0x0
    // NOP
label_112a80:
    // 0x112a80: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x112a84: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x112a88: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x112a8c: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x112a90: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x112a94: 0x5620fffa
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_112a80;
    }
label_112a9c:
    // 0x112a9c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x112aa4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_112aa4
// Address: 0x112aa4 - 0x112ab4

void entry_112aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112aa4) {
        switch (ctx->pc) {
            case 0x112aac: ctx->pc = 0; goto label_112aac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112aa4: 0x10000057
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112C04; return;
    }
label_112aac:
    // 0x112aac: 0xc047186
    SET_GPR_U32(ctx, 31, 0x112ab4);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112ab4
// Address: 0x112ab4 - 0x112c00

void entry_112ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112ab4) {
        switch (ctx->pc) {
            case 0x112ae8: ctx->pc = 0; goto label_112ae8;
            case 0x112bf4: ctx->pc = 0; goto label_112bf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112ab4: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112ab8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112abc: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x112ac0: 0x7ce20000
    WRITE128(ADD32(GPR_U32(ctx, 7), 0), GPR_VEC(ctx, 2));
    // 0x112ac4: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x112ac8: 0x7ce30010
    WRITE128(ADD32(GPR_U32(ctx, 7), 16), GPR_VEC(ctx, 3));
    // 0x112acc: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x112ad0: 0x7ce20020
    WRITE128(ADD32(GPR_U32(ctx, 7), 32), GPR_VEC(ctx, 2));
    // 0x112ad4: 0x78830030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x112ad8: 0x12200046
    WRITE128(ADD32(GPR_U32(ctx, 7), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_112bf4;
    }
    // 0x112ae0: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x112ae4: 0x0
    // NOP
label_112ae8:
    // 0x112ae8: 0xc4e10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[1] = *(float*)&val; }
    // 0x112aec: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x112af0: 0xc4e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[2] = *(float*)&val; }
    // 0x112af4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x112af8: 0xc4e30008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 8)); ctx->f[3] = *(float*)&val; }
    // 0x112afc: 0xc4e4000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 12)); ctx->f[4] = *(float*)&val; }
    // 0x112b00: 0xc4e50010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 16)); ctx->f[5] = *(float*)&val; }
    // 0x112b04: 0xe4e10000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x112b08: 0xc4e60014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[6] = *(float*)&val; }
    // 0x112b0c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112b10: 0xc4e10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[1] = *(float*)&val; }
    // 0x112b14: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x112b18: 0xc4e7001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 28)); ctx->f[7] = *(float*)&val; }
    // 0x112b1c: 0xc4e80020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 32)); ctx->f[8] = *(float*)&val; }
    // 0x112b20: 0xc4e90024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 36)); ctx->f[9] = *(float*)&val; }
    // 0x112b24: 0xe4e20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 7), 4), *(uint32_t*)&val); }
    // 0x112b28: 0xc4ea0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 40)); ctx->f[10] = *(float*)&val; }
    // 0x112b2c: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x112b30: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x112b34: 0xe4e30008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 7), 8), *(uint32_t*)&val); }
    // 0x112b38: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x112b3c: 0x46002101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x112b40: 0xe4e4000c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 7), 12), *(uint32_t*)&val); }
    // 0x112b44: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x112b48: 0x46002941
    ctx->f[5] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    // 0x112b4c: 0xe4e50010
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 7), 16), *(uint32_t*)&val); }
    // 0x112b50: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x112b54: 0x46003181
    ctx->f[6] = FPU_SUB_S(ctx->f[6], ctx->f[0]);
    // 0x112b58: 0xe4e60014
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 7), 20), *(uint32_t*)&val); }
    // 0x112b5c: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x112b60: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x112b64: 0xe4e10018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 24), *(uint32_t*)&val); }
    // 0x112b68: 0xc440001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[0] = *(float*)&val; }
    // 0x112b6c: 0x460039c1
    ctx->f[7] = FPU_SUB_S(ctx->f[7], ctx->f[0]);
    // 0x112b70: 0xe4e7001c
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 7), 28), *(uint32_t*)&val); }
    // 0x112b74: 0xc4400020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 32)); ctx->f[0] = *(float*)&val; }
    // 0x112b78: 0x46004201
    ctx->f[8] = FPU_SUB_S(ctx->f[8], ctx->f[0]);
    // 0x112b7c: 0xe4e80020
    { float val = ctx->f[8]; WRITE32(ADD32(GPR_U32(ctx, 7), 32), *(uint32_t*)&val); }
    // 0x112b80: 0xc4400024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 36)); ctx->f[0] = *(float*)&val; }
    // 0x112b84: 0x46004a41
    ctx->f[9] = FPU_SUB_S(ctx->f[9], ctx->f[0]);
    // 0x112b88: 0xe4e90024
    { float val = ctx->f[9]; WRITE32(ADD32(GPR_U32(ctx, 7), 36), *(uint32_t*)&val); }
    // 0x112b8c: 0xc4400028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[0] = *(float*)&val; }
    // 0x112b90: 0x46005281
    ctx->f[10] = FPU_SUB_S(ctx->f[10], ctx->f[0]);
    // 0x112b94: 0xe4ea0028
    { float val = ctx->f[10]; WRITE32(ADD32(GPR_U32(ctx, 7), 40), *(uint32_t*)&val); }
    // 0x112b98: 0xc440002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 44)); ctx->f[0] = *(float*)&val; }
    // 0x112b9c: 0xc4e1002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 44)); ctx->f[1] = *(float*)&val; }
    // 0x112ba0: 0xc4e20030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 48)); ctx->f[2] = *(float*)&val; }
    // 0x112ba4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x112ba8: 0xc4e30034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 52)); ctx->f[3] = *(float*)&val; }
    // 0x112bac: 0xc4e40038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 56)); ctx->f[4] = *(float*)&val; }
    // 0x112bb0: 0xc4e5003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 60)); ctx->f[5] = *(float*)&val; }
    // 0x112bb4: 0xe4e1002c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 44), *(uint32_t*)&val); }
    // 0x112bb8: 0xc4400030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 48)); ctx->f[0] = *(float*)&val; }
    // 0x112bbc: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x112bc0: 0xe4e20030
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 7), 48), *(uint32_t*)&val); }
    // 0x112bc4: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x112bc8: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x112bcc: 0xe4e30034
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 7), 52), *(uint32_t*)&val); }
    // 0x112bd0: 0xc4400038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 56)); ctx->f[0] = *(float*)&val; }
    // 0x112bd4: 0x46002101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x112bd8: 0xe4e40038
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 7), 56), *(uint32_t*)&val); }
    // 0x112bdc: 0xc440003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 60)); ctx->f[0] = *(float*)&val; }
    // 0x112be0: 0x46002941
    ctx->f[5] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    // 0x112be4: 0xe4e5003c
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 7), 60), *(uint32_t*)&val); }
    // 0x112be8: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x112bec: 0x5620ffbe
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        goto label_112ae8;
    }
label_112bf4:
    // 0x112bf4: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x112bf8: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x112c00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_112c00
// Address: 0x112c00 - 0x112c0c

void entry_112c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112c00) {
        switch (ctx->pc) {
            case 0x112c04: ctx->pc = 0; goto label_112c04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112c00: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_112c04:
    // 0x112c04: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x112c0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_112c0c
// Address: 0x112c0c - 0x112c18

void entry_112c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112c0c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x112c10: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x112c18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_112c18
// Address: 0x112c18 - 0x112c38

void entry_112c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112c18: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x112c1c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x112c20: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x112c24: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x112c28: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x112c2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x112c34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x112c38; return;
}


// Function: RefOpMult__FiP4CRefP6CFrame
// Address: 0x112c38 - 0x112c8c

void entry_112c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112c8c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x112c90: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x112c94: 0x2443ffec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967276));
    // 0x112c98: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x112c9c: 0x10400033
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112ca4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x112ca8: 0x24428fe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938592));
    // 0x112cac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x112cb0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112cb4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x112cbc: 0x24170015
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 21));
    // 0x112cc0: 0xc6140004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[20] = *(float*)&val; }
    // 0x112cc4: 0x10000029
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112ccc: 0x24170015
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 21));
    // 0x112cd0: 0xc6140004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[20] = *(float*)&val; }
    // 0x112cd4: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x112cd8: 0x10000024
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112ce0: 0xc047142
    SET_GPR_U32(ctx, 31, 0x112ce8);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 22));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112ce8
// Address: 0x112ce8 - 0x112d04

void entry_112ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112ce8: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112cec: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112cf0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112cf4: 0x1000001d
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112cfc: 0xc047186
    SET_GPR_U32(ctx, 31, 0x112d04);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 23));
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112d04
// Address: 0x112d04 - 0x112d38

void entry_112d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112d04: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112d08: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112d0c: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x112d10: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
    // 0x112d14: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x112d18: 0x7e630010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 3));
    // 0x112d1c: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x112d20: 0x7e620020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 2));
    // 0x112d24: 0x78830030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x112d28: 0x10000010
    WRITE128(ADD32(GPR_U32(ctx, 19), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112d30: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x112d38);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 24));
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112d38
// Address: 0x112d38 - 0x112d54

void entry_112d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112d38: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112d3c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112d40: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112d44: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D6C; return;
    }
    // 0x112d4c: 0xc047216
    SET_GPR_U32(ctx, 31, 0x112d54);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 25));
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112d54
// Address: 0x112d54 - 0x112e00

void entry_112d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112d54) {
        switch (ctx->pc) {
            case 0x112d6c: ctx->pc = 0; goto label_112d6c;
            case 0x112d7c: ctx->pc = 0; goto label_112d7c;
            case 0x112d88: ctx->pc = 0; goto label_112d88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112d54: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x112d58: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112d5c: 0x68620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x112d60: 0x6c620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x112d64: 0xb2820007
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x112d68: 0xb6820000
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
label_112d6c:
    // 0x112d6c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x112d70: 0x10400002
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_112d7c;
    }
    // 0x112d78: 0x8e12000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_112d7c:
    // 0x112d7c: 0x124000f1
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 4294967275));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113144; return;
    }
    // 0x112d84: 0x0
    // NOP
label_112d88:
    // 0x112d88: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x112d8c: 0x104000ea
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112d94: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x112d98: 0x24429000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938624));
    // 0x112d9c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x112da0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112da4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x112dac: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x112db0: 0x2444ffec
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967276));
    // 0x112db4: 0x2c830006
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 6));
    // 0x112db8: 0x106000df
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112dc0: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x112dc4: 0x24429020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938656));
    // 0x112dc8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x112dcc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112dd0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x112dd8: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112ddc: 0xf02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x112de0: 0x100000d5
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112de8: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112dec: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x112df0: 0x100000d1
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112df8: 0xc047142
    SET_GPR_U32(ctx, 31, 0x112e00);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 22));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112e00
// Address: 0x112e00 - 0x112e2c

void entry_112e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e00: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x112e04: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112e08: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x112e0c: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x112e10: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x112e14: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x112e18: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x112e1c: 0x100000c6
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112e24: 0xc047186
    SET_GPR_U32(ctx, 31, 0x112e2c);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 23));
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112e2c
// Address: 0x112e2c - 0x112e48

void entry_112e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e2c: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x112e30: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x112e34: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112e38: 0x700334a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x112e3c: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x112e40: 0xc06218a
    SET_GPR_U32(ctx, 31, 0x112e48);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    fn___ml__FRC7MATRIX4G8VU_FLOAT(rdram, ctx, runtime); return;
}


// Function: entry_112e48
// Address: 0x112e48 - 0x112e58

void entry_112e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e48: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x112e4c: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x112e50: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x112e58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_112e58
// Address: 0x112e58 - 0x112e84

void entry_112e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e58: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x112e5c: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
    // 0x112e60: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x112e64: 0x7e630010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 3));
    // 0x112e68: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x112e6c: 0x7e620020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 2));
    // 0x112e70: 0x7ba30050
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x112e74: 0x100000b0
    WRITE128(ADD32(GPR_U32(ctx, 19), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112e7c: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x112e84);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 24));
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112e84
// Address: 0x112e84 - 0x112e98

void entry_112e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e84: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x112e88: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x112e8c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112e90: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x112e98);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_112e98
// Address: 0x112e98 - 0x112ea8

void entry_112e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112e98: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x112e9c: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x112ea0: 0xc046344
    SET_GPR_U32(ctx, 31, 0x112ea8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_112ea8
// Address: 0x112ea8 - 0x112ebc

void entry_112ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112ea8: 0x7ba500b0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x112eac: 0x10000084
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1130C0; return;
    }
    // 0x112eb4: 0xc047216
    SET_GPR_U32(ctx, 31, 0x112ebc);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 25));
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112ebc
// Address: 0x112ebc - 0x112fac

void entry_112ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112ebc) {
        switch (ctx->pc) {
            case 0x112f00: ctx->pc = 0; goto label_112f00;
            case 0x112f18: ctx->pc = 0; goto label_112f18;
            case 0x112f20: ctx->pc = 0; goto label_112f20;
            case 0x112f58: ctx->pc = 0; goto label_112f58;
            case 0x112f74: ctx->pc = 0; goto label_112f74;
            case 0x112f90: ctx->pc = 0; goto label_112f90;
            case 0x112fa4: ctx->pc = 0; goto label_112fa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112ebc: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x112ec0: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112ec4: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x112ec8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x112ecc: 0xe6800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
    // 0x112ed0: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x112ed4: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x112ed8: 0x10000097
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112ee0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x112ee4: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x112ee8: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_112f00;
    }
    // 0x112ef0: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        goto label_112f18;
    }
    // 0x112ef8: 0x10000090
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11313C; return;
    }
label_112f00:
    // 0x112f00: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112f04: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x112f08: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x112f0c: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x112f10: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_112f20;
    }
label_112f18:
    // 0x112f18: 0x48a51000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x112f1c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_112f20:
    // 0x112f20: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x112f24: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x112f28: 0x10000083
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x112f30: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x112f34: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x112f38: 0x10620015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 22));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_112f90;
    }
    // 0x112f40: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_112f58;
    }
    // 0x112f48: 0x1062000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_112f74;
    }
    // 0x112f50: 0x1000007a
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11313C; return;
    }
label_112f58:
    // 0x112f58: 0x24020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    // 0x112f5c: 0x10620020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x112FE0; return;
    }
    // 0x112f64: 0x50620029
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x11300C; return;
    }
    // 0x112f6c: 0x10000073
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11313C; return;
    }
label_112f74:
    // 0x112f74: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x112f78: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x112f7c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x112f80: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x112f84: 0x700234a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x112f88: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_112fa4;
    }
label_112f90:
    // 0x112f90: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x112f94: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x112f98: 0x700234a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x112f9c: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x112fa0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_112fa4:
    // 0x112fa4: 0xc06218a
    SET_GPR_U32(ctx, 31, 0x112fac);
    fn___ml__FRC7MATRIX4G8VU_FLOAT(rdram, ctx, runtime); return;
}


// Function: entry_112fac
// Address: 0x112fac - 0x112fbc

void entry_112fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112fac: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x112fb0: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x112fb4: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x112fbc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_112fbc
// Address: 0x112fbc - 0x112fe8

void entry_112fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x112fbc) {
        switch (ctx->pc) {
            case 0x112fe0: ctx->pc = 0; goto label_112fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x112fbc: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x112fc0: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
    // 0x112fc4: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x112fc8: 0x7e630010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 3));
    // 0x112fcc: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x112fd0: 0x7e620020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 2));
    // 0x112fd4: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x112fd8: 0x10000057
    WRITE128(ADD32(GPR_U32(ctx, 19), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
label_112fe0:
    // 0x112fe0: 0xc047142
    SET_GPR_U32(ctx, 31, 0x112fe8);
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 22));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_112fe8
// Address: 0x112fe8 - 0x113004

void entry_112fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x112fe8: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x112fec: 0x8e450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x112ff0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x112ff4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x112ff8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x112ffc: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x113004);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_113004
// Address: 0x113004 - 0x113018

void entry_113004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113004) {
        switch (ctx->pc) {
            case 0x11300c: ctx->pc = 0; goto label_11300c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113004: 0x1000004d
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11313C; return;
    }
label_11300c:
    // 0x11300c: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x113010: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x113018);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_113018
// Address: 0x113018 - 0x113088

void entry_113018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113018) {
        switch (ctx->pc) {
            case 0x113078: ctx->pc = 0; goto label_113078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113018: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11301c: 0x7ba30070
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x113020: 0x7ba50050
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x113024: 0x7ba40080
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x113028: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x11302c: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x113030: 0x7fa40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 4));
    // 0x113034: 0x7fa50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 5));
    // 0x113038: 0x7e650000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 5));
    // 0x11303c: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113040: 0x7e620010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 2));
    // 0x113044: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113048: 0x7e630020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 3));
    // 0x11304c: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x113050: 0x10000039
    WRITE128(ADD32(GPR_U32(ctx, 19), 48), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113138; return;
    }
    // 0x113058: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x11305c: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x113060: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_113078;
    }
    // 0x113068: 0x5062000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1130A0; return;
    }
    // 0x113070: 0x10000032
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11313C; return;
    }
label_113078:
    // 0x113078: 0xc64c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[12] = *(float*)&val; }
    // 0x11307c: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x113080: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x113088);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_113088
// Address: 0x113088 - 0x113098

void entry_113088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113088: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x11308c: 0x27a400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    // 0x113090: 0xc046344
    SET_GPR_U32(ctx, 31, 0x113098);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_113098
// Address: 0x113098 - 0x1130a8

void entry_113098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113098) {
        switch (ctx->pc) {
            case 0x1130a0: ctx->pc = 0; goto label_1130a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113098: 0x10000008
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1130BC; return;
    }
label_1130a0:
    // 0x1130a0: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1130a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 224));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1130a8
// Address: 0x1130a8 - 0x1130b8

void entry_1130a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1130a8: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1130ac: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1130b0: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1130b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1130b8
// Address: 0x1130b8 - 0x1130c8

void entry_1130b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1130b8) {
        switch (ctx->pc) {
            case 0x1130bc: ctx->pc = 0; goto label_1130bc;
            case 0x1130c0: ctx->pc = 0; goto label_1130c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1130b8: 0x7ba500f0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_1130bc:
    // 0x1130bc: 0x701024a9
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
label_1130c0:
    // 0x1130c0: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1130c8);
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1130c8
// Address: 0x1130c8 - 0x1130d4

void entry_1130c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1130c8: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1130cc: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1130d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1130d4
// Address: 0x1130d4 - 0x113180

void entry_1130d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1130d4) {
        switch (ctx->pc) {
            case 0x1130fc: ctx->pc = 0; goto label_1130fc;
            case 0x113120: ctx->pc = 0; goto label_113120;
            case 0x113138: ctx->pc = 0; goto label_113138;
            case 0x11313c: ctx->pc = 0; goto label_11313c;
            case 0x113144: ctx->pc = 0; goto label_113144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1130d4: 0x10000019
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11313c;
    }
    // 0x1130dc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1130e0: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1130e4: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1130fc;
    }
    // 0x1130ec: 0x5062000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
        goto label_113120;
    }
    // 0x1130f4: 0x10000011
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11313c;
    }
label_1130fc:
    // 0x1130fc: 0xc6420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[2] = *(float*)&val; }
    // 0x113100: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x113104: 0xc6810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 0)); ctx->f[1] = *(float*)&val; }
    // 0x113108: 0xc6800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11310c: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x113110: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x113114: 0xe6810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
    // 0x113118: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113138;
    }
label_113120:
    // 0x113120: 0xc6810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 0)); ctx->f[1] = *(float*)&val; }
    // 0x113124: 0xc6820004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[2] = *(float*)&val; }
    // 0x113128: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x11312c: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x113130: 0xe6810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
    // 0x113134: 0xe6820004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 20), 4), *(uint32_t*)&val); }
label_113138:
    // 0x113138: 0x8e520008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
label_11313c:
    // 0x11313c: 0x1640ff12
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 4294967275));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x112D88; return;
    }
label_113144:
    // 0x113144: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x113148: 0x10400029
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1131f0(rdram, ctx, runtime); return;
    }
    // 0x113150: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x113154: 0x24429040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938688));
    // 0x113158: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11315c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x113160: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x113168: 0x13c00007
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113188; return;
    }
    // 0x113170: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x113174: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x113178: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x113180);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113180
// Address: 0x113180 - 0x113190

void entry_113180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113180) {
        switch (ctx->pc) {
            case 0x113188: ctx->pc = 0; goto label_113188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113180: 0x1000001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
label_113188:
    // 0x113188: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x113190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_113190
// Address: 0x113190 - 0x1131a4

void entry_113190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113190: 0x10000018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
    // 0x113198: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11319c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1131a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1131a4
// Address: 0x1131a4 - 0x1131b4

void entry_1131a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1131a4: 0x12600013
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
    // 0x1131ac: 0xc0471c8
    SET_GPR_U32(ctx, 31, 0x1131b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    DeleteMatrix__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1131b4
// Address: 0x1131b4 - 0x1131c8

void entry_1131b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1131b4: 0x1000000f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
    // 0x1131bc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1131c0: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x1131c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1131c8
// Address: 0x1131c8 - 0x1131dc

void entry_1131c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1131c8: 0x1000000a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
    // 0x1131d0: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1131d4: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x1131dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_1131dc
// Address: 0x1131dc - 0x1131f0

void entry_1131dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1131dc: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1131F4; return;
    }
    // 0x1131e4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1131e8: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x1131f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1131f0
// Address: 0x1131f0 - 0x1131fc

void entry_1131f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1131f0) {
        switch (ctx->pc) {
            case 0x1131f4: ctx->pc = 0; goto label_1131f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1131f0: 0x8fa40100
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 256)));
label_1131f4:
    // 0x1131f4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1131fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1131fc
// Address: 0x1131fc - 0x113208

void entry_1131fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1131fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113200: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113208);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113208
// Address: 0x113208 - 0x113240

void entry_113208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113208: 0x8fa20100
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x11320c: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x113210: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x113214: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x113218: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x11321c: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x113220: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x113224: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x113228: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x11322c: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x113230: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x113234: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x113238: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpDiv__FiP4CRefP6CFrame
// Address: 0x113240 - 0x113294

void entry_113294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113294: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x113298: 0x8e140000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11329c: 0x2683ffec
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 4294967276));
    // 0x1132a0: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x1132a4: 0x10400032
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x1132ac: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1132b0: 0x24429060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938720));
    // 0x1132b4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1132b8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1132bc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1132c4: 0xc6140004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[20] = *(float*)&val; }
    // 0x1132c8: 0x10000029
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x1132d0: 0x24140015
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1132d4: 0xc6140004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[20] = *(float*)&val; }
    // 0x1132d8: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1132dc: 0x10000024
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x1132e4: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1132ec);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1132ec
// Address: 0x1132ec - 0x113308

void entry_1132ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1132ec: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1132f0: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1132f4: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1132f8: 0x1000001d
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x113300: 0xc047186
    SET_GPR_U32(ctx, 31, 0x113308);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_113308
// Address: 0x113308 - 0x11333c

void entry_113308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113308: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11330c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x113310: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x113314: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x113318: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x11331c: 0x7e430010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 3));
    // 0x113320: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x113324: 0x7e420020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    // 0x113328: 0x78830030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x11332c: 0x10000010
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x113334: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x11333c);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11333c
// Address: 0x11333c - 0x113358

void entry_11333c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11333c: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113340: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x113344: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x113348: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113370; return;
    }
    // 0x113350: 0xc047216
    SET_GPR_U32(ctx, 31, 0x113358);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_113358
// Address: 0x113358 - 0x1134a0

void entry_113358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113358) {
        switch (ctx->pc) {
            case 0x113370: ctx->pc = 0; goto label_113370;
            case 0x113380: ctx->pc = 0; goto label_113380;
            case 0x113390: ctx->pc = 0; goto label_113390;
            case 0x1133d8: ctx->pc = 0; goto label_1133d8;
            case 0x113408: ctx->pc = 0; goto label_113408;
            case 0x11342c: ctx->pc = 0; goto label_11342c;
            case 0x113444: ctx->pc = 0; goto label_113444;
            case 0x113474: ctx->pc = 0; goto label_113474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113358: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11335c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x113360: 0x68620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x113364: 0x6c620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x113368: 0xb2620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x11336c: 0xb6620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
label_113370:
    // 0x113370: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x113374: 0x10400002
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_113380;
    }
    // 0x11337c: 0x8e11000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_113380:
    // 0x113380: 0x122000b0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967275));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113644; return;
    }
    // 0x113388: 0x2e820005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 5));
    // 0x11338c: 0x0
    // NOP
label_113390:
    // 0x113390: 0x104000a9
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
    // 0x113398: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x11339c: 0x24429080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938752));
    // 0x1133a0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1133a4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1133a8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1133b0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1133b4: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1133b8: 0x10620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1133d8;
    }
    // 0x1133c0: 0x5462009e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x11363C; return;
    }
    // 0x1133c8: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1133cc: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1133d0: 0x10000099
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
label_1133d8:
    // 0x1133d8: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1133dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1133e0: 0x10000095
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
    // 0x1133e8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1133ec: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1133f0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_113408;
    }
    // 0x1133f8: 0x5062000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
        goto label_11342c;
    }
    // 0x113400: 0x1000008e
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11363C; return;
    }
label_113408:
    // 0x113408: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11340c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x113410: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113414: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x113418: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x11341c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x113420: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x113424: 0x10000007
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113444;
    }
label_11342c:
    // 0x11342c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113430: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x113434: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x113438: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x11343c: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x113440: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
label_113444:
    // 0x113444: 0xdac10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x113448: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11344c: 0x1000007a
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
    // 0x113454: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x113458: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x11345c: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_113474;
    }
    // 0x113464: 0x5062001b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x1134D4; return;
    }
    // 0x11346c: 0x10000073
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11363C; return;
    }
label_113474:
    // 0x113474: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x113478: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x11347c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113480: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x113484: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x113488: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11348c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x113490: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x113494: 0x700234a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x113498: 0xc06218a
    SET_GPR_U32(ctx, 31, 0x1134a0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G8VU_FLOAT(rdram, ctx, runtime); return;
}


// Function: entry_1134a0
// Address: 0x1134a0 - 0x1134b0

void entry_1134a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1134a0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1134a4: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1134a8: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x1134b0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_1134b0
// Address: 0x1134b0 - 0x1134f8

void entry_1134b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1134b0) {
        switch (ctx->pc) {
            case 0x1134d4: ctx->pc = 0; goto label_1134d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1134b0: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1134b4: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x1134b8: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1134bc: 0x7e430010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 3));
    // 0x1134c0: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1134c4: 0x7e420020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    // 0x1134c8: 0x7ba30050
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1134cc: 0x1000005a
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
label_1134d4:
    // 0x1134d4: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1134d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1134dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1134e0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1134e4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1134e8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1134ec: 0x700234a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1134f0: 0xc06218a
    SET_GPR_U32(ctx, 31, 0x1134f8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    fn___ml__FRC7MATRIX4G8VU_FLOAT(rdram, ctx, runtime); return;
}


// Function: entry_1134f8
// Address: 0x1134f8 - 0x113508

void entry_1134f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1134f8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1134fc: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x113500: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x113508);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_113508
// Address: 0x113508 - 0x113568

void entry_113508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113508) {
        switch (ctx->pc) {
            case 0x11354c: ctx->pc = 0; goto label_11354c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113508: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11350c: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
    // 0x113510: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113514: 0x7e430010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 3));
    // 0x113518: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11351c: 0x7e420020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    // 0x113520: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x113524: 0x10000044
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113638; return;
    }
    // 0x11352c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x113530: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x113534: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_11354c;
    }
    // 0x11353c: 0x50620010
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x113580; return;
    }
    // 0x113544: 0x1000003d
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11363C; return;
    }
label_11354c:
    // 0x11354c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x113550: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x113554: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113558: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x11355c: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x113560: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x113568);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_113568
// Address: 0x113568 - 0x113578

void entry_113568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113568: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11356c: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x113570: 0xc046344
    SET_GPR_U32(ctx, 31, 0x113578);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_113578
// Address: 0x113578 - 0x113594

void entry_113578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113578) {
        switch (ctx->pc) {
            case 0x113580: ctx->pc = 0; goto label_113580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113578: 0x1000000b
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1135A8; return;
    }
label_113580:
    // 0x113580: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x113584: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113588: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x11358c: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x113594);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_113594
// Address: 0x113594 - 0x1135a4

void entry_113594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113594: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x113598: 0x27a400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    // 0x11359c: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1135a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1135a4
// Address: 0x1135a4 - 0x1135b0

void entry_1135a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1135a4) {
        switch (ctx->pc) {
            case 0x1135a8: ctx->pc = 0; goto label_1135a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1135a4: 0x7ba500d0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1135a8:
    // 0x1135a8: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1135b0);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1135b0
// Address: 0x1135b0 - 0x1135bc

void entry_1135b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1135b0: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1135b4: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1135bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1135bc
// Address: 0x1135bc - 0x113680

void entry_1135bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1135bc) {
        switch (ctx->pc) {
            case 0x1135e4: ctx->pc = 0; goto label_1135e4;
            case 0x113614: ctx->pc = 0; goto label_113614;
            case 0x113638: ctx->pc = 0; goto label_113638;
            case 0x11363c: ctx->pc = 0; goto label_11363c;
            case 0x113644: ctx->pc = 0; goto label_113644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1135bc: 0x1000001f
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11363c;
    }
    // 0x1135c4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1135c8: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1135cc: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1135e4;
    }
    // 0x1135d4: 0x5062000f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[3] = *(float*)&val; }
        goto label_113614;
    }
    // 0x1135dc: 0x10000017
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11363c;
    }
label_1135e4:
    // 0x1135e4: 0xc6230004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1135e8: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1135ec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1135f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1135f4: 0xc6620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1135f8: 0xc6610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1135fc: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x113600: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x113604: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x113608: 0xe6610004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 4), *(uint32_t*)&val); }
    // 0x11360c: 0x1000000a
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113638;
    }
label_113614:
    // 0x113614: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x113618: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x11361c: 0xc6620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[2] = *(float*)&val; }
    // 0x113620: 0x46030843
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[3];
    // 0x113624: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
    // 0x113628: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x11362c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x113630: 0xe6620000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
    // 0x113634: 0xe6600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 4), *(uint32_t*)&val); }
label_113638:
    // 0x113638: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_11363c:
    // 0x11363c: 0x1620ff54
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 5));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x113390; return;
    }
label_113644:
    // 0x113644: 0x2e820005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 5));
    // 0x113648: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1136e0(rdram, ctx, runtime); return;
    }
    // 0x113650: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x113654: 0x244290a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938784));
    // 0x113658: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11365c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x113660: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x113668: 0x12e00007
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113688; return;
    }
    // 0x113670: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x113674: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x113678: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x113680);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113680
// Address: 0x113680 - 0x113690

void entry_113680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113680) {
        switch (ctx->pc) {
            case 0x113688: ctx->pc = 0; goto label_113688;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113680: 0x10000018
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1136E4; return;
    }
label_113688:
    // 0x113688: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x113690);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_113690
// Address: 0x113690 - 0x1136a4

void entry_113690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113690: 0x10000014
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1136E4; return;
    }
    // 0x113698: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11369c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1136a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1136a4
// Address: 0x1136a4 - 0x1136b8

void entry_1136a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1136a4: 0x1000000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1136E4; return;
    }
    // 0x1136ac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1136b0: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x1136b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1136b8
// Address: 0x1136b8 - 0x1136cc

void entry_1136b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1136b8: 0x1000000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1136E4; return;
    }
    // 0x1136c0: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1136c4: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x1136cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_1136cc
// Address: 0x1136cc - 0x1136e0

void entry_1136cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1136cc: 0x10000005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1136E4; return;
    }
    // 0x1136d4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1136d8: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x1136e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1136e0
// Address: 0x1136e0 - 0x1136ec

void entry_1136e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1136e0) {
        switch (ctx->pc) {
            case 0x1136e4: ctx->pc = 0; goto label_1136e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1136e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1136e4:
    // 0x1136e4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1136ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1136ec
// Address: 0x1136ec - 0x1136f8

void entry_1136ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1136ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1136f0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1136f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1136f8
// Address: 0x1136f8 - 0x113730

void entry_1136f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1136f8: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1136fc: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x113700: 0x7bbe0160
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x113704: 0x7bb70150
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x113708: 0x7bb60140
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x11370c: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x113710: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x113714: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x113718: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x11371c: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x113720: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x113724: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x113728: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpPrint__FiP4CRefP6CFrame
// Address: 0x113730 - 0x113748

void entry_113748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113748: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11374c: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x113754);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_113754
// Address: 0x113754 - 0x113760

void entry_113754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113754: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113758: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113760);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113760
// Address: 0x113760 - 0x11376c

void entry_113760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113760: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113764: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11376c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11376c
// Address: 0x11376c - 0x113780

void entry_11376c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11376c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113770: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113774: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpPrintFrame__FiP4CRefP6CFrame
// Address: 0x113780 - 0x113798

void entry_113798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113798: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11379c: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1137a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1137a4
// Address: 0x1137a4 - 0x1137b0

void entry_1137a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1137a4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1137a8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1137b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1137b0
// Address: 0x1137b0 - 0x1137bc

void entry_1137b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1137b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1137b4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1137bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1137bc
// Address: 0x1137bc - 0x1137d0

void entry_1137bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1137bc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1137c0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1137c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1137c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpPrintSidebag__FiP4CRefP6CFrame
// Address: 0x1137d0 - 0x1137e8

void entry_1137e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1137e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1137ec: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1137f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1137f4
// Address: 0x1137f4 - 0x113800

void entry_1137f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1137f4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1137f8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113800);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113800
// Address: 0x113800 - 0x11380c

void entry_113800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113800: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113804: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11380c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11380c
// Address: 0x11380c - 0x113820

void entry_11380c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11380c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113810: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113814: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpIntEqual__FiP4CRefP6CFrame
// Address: 0x113820 - 0x113840

void entry_113840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113840: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x113844: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113848: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11384c: 0xa32826
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x113850: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113858);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113858
// Address: 0x113858 - 0x113864

void entry_113858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113858: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11385c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113864);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113864
// Address: 0x113864 - 0x113870

void entry_113864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113864: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113868: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113870);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113870
// Address: 0x113870 - 0x113888

void entry_113870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113870: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113874: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113878: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11387c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113880: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefCmp__FP4CRef4CMPK
// Address: 0x113888 - 0x1138b8

void entry_1138b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1138b8) {
        switch (ctx->pc) {
            case 0x1138c8: ctx->pc = 0; goto label_1138c8;
            case 0x1138dc: ctx->pc = 0; goto label_1138dc;
            case 0x1138e4: ctx->pc = 0; goto label_1138e4;
            case 0x11391c: ctx->pc = 0; goto label_11391c;
            case 0x113934: ctx->pc = 0; goto label_113934;
            case 0x113948: ctx->pc = 0; goto label_113948;
            case 0x11395c: ctx->pc = 0; goto label_11395c;
            case 0x113970: ctx->pc = 0; goto label_113970;
            case 0x113978: ctx->pc = 0; goto label_113978;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1138b8: 0x24050015
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1138bc: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1138c0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1138c4: 0x0
    // NOP
label_1138c8:
    // 0x1138c8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1138cc: 0x14450003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_1138dc;
    }
    // 0x1138d4: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1138e4;
    }
label_1138dc:
    // 0x1138dc: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1138e0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
label_1138e4:
    // 0x1138e4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1138e8: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1138ec: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1138f0: 0x481fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1138c8;
    }
    // 0x1138f8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1138fc: 0x12220012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_113948;
    }
    // 0x113904: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11391c;
    }
    // 0x11390c: 0x12200009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_113934;
    }
    // 0x113914: 0x10000026
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1139B0; return;
    }
label_11391c:
    // 0x11391c: 0x1222000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_11395c;
    }
    // 0x113924: 0x12220018
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x113988; return;
    }
    // 0x11392c: 0x10000020
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1139B0; return;
    }
label_113934:
    // 0x113934: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x113938: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11393c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x113940: 0x1000000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113970;
    }
label_113948:
    // 0x113948: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11394c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x113950: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x113954: 0x10000006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113970;
    }
label_11395c:
    // 0x11395c: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x113960: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x113964: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x113968: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11396c: 0x0
    // NOP
label_113970:
    // 0x113970: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_113978;
    }
label_113978:
    // 0x113978: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113980);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113980
// Address: 0x113980 - 0x1139ac

void entry_113980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113980) {
        switch (ctx->pc) {
            case 0x113988: ctx->pc = 0; goto label_113988;
            case 0x1139a4: ctx->pc = 0; goto label_1139a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113980: 0x1000000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1139B0; return;
    }
label_113988:
    // 0x113988: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11398c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x113990: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x113994: 0x0
    // NOP
    // 0x113998: 0x45010002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1139a4;
    }
    // 0x1139a0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1139a4:
    // 0x1139a4: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1139ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1139ac
// Address: 0x1139ac - 0x1139b8

void entry_1139ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1139ac) {
        switch (ctx->pc) {
            case 0x1139b0: ctx->pc = 0; goto label_1139b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1139ac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1139b0:
    // 0x1139b0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1139b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1139b8
// Address: 0x1139b8 - 0x1139c4

void entry_1139b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1139b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1139bc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1139c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1139c4
// Address: 0x1139c4 - 0x1139e8

void entry_1139c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1139c4: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1139c8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1139cc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1139d0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1139d4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1139d8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1139dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1139e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1139e8; return;
}


// Function: RefOpL__FiP4CRefP6CFrame
// Address: 0x1139e8 - 0x113a04

void entry_113a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113a04: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113a08: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113a0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x113a10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpLE__FiP4CRefP6CFrame
// Address: 0x113a18 - 0x113a34

void entry_113a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113a34: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113a38: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113a3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x113a40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpG__FiP4CRefP6CFrame
// Address: 0x113a48 - 0x113a64

void entry_113a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113a64: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113a68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113a6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x113a70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpGE__FiP4CRefP6CFrame
// Address: 0x113a78 - 0x113a94

void entry_113a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113a94: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113a98: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113a9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x113aa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpEqv__FiP4CRefP6CFrame
// Address: 0x113aa8 - 0x113acc

void entry_113acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113acc) {
        switch (ctx->pc) {
            case 0x113ae4: ctx->pc = 0; goto label_113ae4;
            case 0x113b20: ctx->pc = 0; goto label_113b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113acc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113ad0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x113ad4: 0x10620003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_113ae4;
    }
    // 0x113adc: 0x10000010
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113b20;
    }
label_113ae4:
    // 0x113ae4: 0x2c620023
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 35));
    // 0x113ae8: 0x1040000d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_113b20;
    }
    // 0x113af0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x113af4: 0x244290c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938816));
    // 0x113af8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x113afc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x113b00: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x113b08: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113b0c: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x113b10: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x113b14: 0x10000002
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113b20;
    }
    // 0x113b1c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
label_113b20:
    // 0x113b20: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113b24: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113b2c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113b2c
// Address: 0x113b2c - 0x113b38

void entry_113b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113b2c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113b30: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113b38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113b38
// Address: 0x113b38 - 0x113b44

void entry_113b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113b38: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113b3c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113b44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113b44
// Address: 0x113b44 - 0x113b60

void entry_113b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113b44: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113b48: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x113b4c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113b50: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113b54: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113b58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEqualHelper__FP4CRefT0
// Address: 0x113b60 - 0x113b98

void entry_113b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113b98: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113b9c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x113ba0: 0x54620095
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113ba8: 0x2c620023
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 35));
    // 0x113bac: 0x10400092
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113DF8; return;
    }
    // 0x113bb4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x113bb8: 0x24429150
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294938960));
    // 0x113bbc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x113bc0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x113bc4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x113bcc: 0x8e130004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113bd0: 0x8e340004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x113bd4: 0x52740088
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 20)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113bdc: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x113be0: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x113be4: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x113be8: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x113bec: 0x54620082
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113bf4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x113bf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113bfc: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113c04);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113c04
// Address: 0x113c04 - 0x113c18

void entry_113c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c04: 0x27b20020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 32));
    // 0x113c08: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x113c0c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113c10: 0xc044ed8
    SET_GPR_U32(ctx, 31, 0x113c18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefEqualHelper__FP4CRefT0(rdram, ctx, runtime); return;
}


// Function: entry_113c18
// Address: 0x113c18 - 0x113c24

void entry_113c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113c1c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x113c24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113c24
// Address: 0x113c24 - 0x113c30

void entry_113c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c24: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113c28: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113c30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113c30
// Address: 0x113c30 - 0x113c5c

void entry_113c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113c30) {
        switch (ctx->pc) {
            case 0x113c44: ctx->pc = 0; goto label_113c44;
            case 0x113c54: ctx->pc = 0; goto label_113c54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113c30: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x113c34: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
        goto label_113c44;
    }
    // 0x113c3c: 0x10000022
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_113cc8(rdram, ctx, runtime); return;
    }
label_113c44:
    // 0x113c44: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_113c54;
    }
    // 0x113c4c: 0x1000001e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_113cc8(rdram, ctx, runtime); return;
    }
label_113c54:
    // 0x113c54: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113c5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113c5c
// Address: 0x113c5c - 0x113c68

void entry_113c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c5c: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x113c60: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113c68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113c68
// Address: 0x113c68 - 0x113c74

void entry_113c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c68: 0x8e650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x113c6c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x113c74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_113c74
// Address: 0x113c74 - 0x113c80

void entry_113c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c74: 0x8e850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x113c78: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x113c80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_113c80
// Address: 0x113c80 - 0x113c94

void entry_113c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c80: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x113c84: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113c88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113c8c: 0xc044ed8
    SET_GPR_U32(ctx, 31, 0x113c94);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefEqualHelper__FP4CRefT0(rdram, ctx, runtime); return;
}


// Function: entry_113c94
// Address: 0x113c94 - 0x113ca0

void entry_113c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113c94: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x113c98: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x113ca0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113ca0
// Address: 0x113ca0 - 0x113cac

void entry_113ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113ca0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113ca4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113cac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113cac
// Address: 0x113cac - 0x113cbc

void entry_113cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113cac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113cb0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x113cb4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113cbc);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113cbc
// Address: 0x113cbc - 0x113cc8

void entry_113cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113cbc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113cc0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113cc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113cc8
// Address: 0x113cc8 - 0x113d20

void entry_113cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113cc8) {
        switch (ctx->pc) {
            case 0x113d18: ctx->pc = 0; goto label_113d18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113cc8: 0x10000034
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113D9C; return;
    }
    // 0x113cd0: 0x8e100004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113cd4: 0x8e340004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x113cd8: 0x52140047
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 20)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113ce0: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x113ce4: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x113ce8: 0x54620043
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113cf0: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x113cf4: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x113cf8: 0x5462003f
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x113DF8; return;
    }
    // 0x113d00: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113d04: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x113d08: 0x10620003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_113d18;
    }
    // 0x113d10: 0x10000039
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x113DF8; return;
    }
label_113d18:
    // 0x113d18: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113d20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113d20
// Address: 0x113d20 - 0x113d2c

void entry_113d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d20: 0x27b20020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 32));
    // 0x113d24: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113d2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113d2c
// Address: 0x113d2c - 0x113d38

void entry_113d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d2c: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x113d30: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x113d38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113d38
// Address: 0x113d38 - 0x113d44

void entry_113d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d38: 0x8e050010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x113d3c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x113d44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_113d44
// Address: 0x113d44 - 0x113d50

void entry_113d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d44: 0x8e850010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x113d48: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x113d50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_113d50
// Address: 0x113d50 - 0x113d64

void entry_113d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d50: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x113d54: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113d58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113d5c: 0xc044ed8
    SET_GPR_U32(ctx, 31, 0x113d64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefEqualHelper__FP4CRefT0(rdram, ctx, runtime); return;
}


// Function: entry_113d64
// Address: 0x113d64 - 0x113d70

void entry_113d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d64: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113d68: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x113d70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113d70
// Address: 0x113d70 - 0x113d7c

void entry_113d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113d74: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113d7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113d7c
// Address: 0x113d7c - 0x113d8c

void entry_113d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113d80: 0x8fb40054
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x113d84: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113d8c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113d8c
// Address: 0x113d8c - 0x113d98

void entry_113d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113d8c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x113d90: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113d98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113d98
// Address: 0x113d98 - 0x113da4

void entry_113d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113d98) {
        switch (ctx->pc) {
            case 0x113d9c: ctx->pc = 0; goto label_113d9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113d98: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_113d9c:
    // 0x113d9c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113da4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113da4
// Address: 0x113da4 - 0x113e04

void entry_113da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x113da4) {
        switch (ctx->pc) {
            case 0x113df8: ctx->pc = 0; goto label_113df8;
            case 0x113dfc: ctx->pc = 0; goto label_113dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x113da4: 0x10000015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113dfc;
    }
    // 0x113dac: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113db0: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x113db4: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x113db8: 0x1000000f
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113df8;
    }
    // 0x113dc0: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x113dc4: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x113dc8: 0x10a6000b
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 6)) {
        goto label_113df8;
    }
    // 0x113dd0: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x113dd4: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x113dd8: 0x14620007
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_113df8;
    }
    // 0x113de0: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x113de4: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x113de8: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x113dec: 0x10000002
    SET_GPR_U32(ctx, 20, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_113df8;
    }
    // 0x113df4: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
label_113df8:
    // 0x113df8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_113dfc:
    // 0x113dfc: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113e04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113e04
// Address: 0x113e04 - 0x113e10

void entry_113e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113e04: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113e08: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113e10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113e10
// Address: 0x113e10 - 0x113e1c

void entry_113e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113e10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113e14: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113e1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113e1c
// Address: 0x113e1c - 0x113e48

void entry_113e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113e1c: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x113e20: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x113e24: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x113e28: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x113e2c: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x113e30: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x113e34: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x113e38: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x113e3c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x113e40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpEqual__FiP4CRefP6CFrame
// Address: 0x113e48 - 0x113e64

void entry_113e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113e64: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x113e68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113e6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x113e70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpIsBoolean__FiP4CRefP6CFrame
// Address: 0x113e78 - 0x113e98

void entry_113e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113e98: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113e9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113ea0: 0x38a5001b
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 27));
    // 0x113ea4: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113eac);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113eac
// Address: 0x113eac - 0x113eb8

void entry_113eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113eac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113eb0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113eb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113eb8
// Address: 0x113eb8 - 0x113ec4

void entry_113eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113eb8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113ebc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113ec4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113ec4
// Address: 0x113ec4 - 0x113ee0

void entry_113ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113ec4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113ec8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113ecc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113ed0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113ed4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x113edc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x113ee0; return;
}


// Function: RefOpIsNum__FiP4CRefP6CFrame
// Address: 0x113ee0 - 0x113f00

void entry_113f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f00: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113f04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f08: 0x24a5ffec
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967276));
    // 0x113f0c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113f14);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 2));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113f14
// Address: 0x113f14 - 0x113f20

void entry_113f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f14: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f18: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113f20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113f20
// Address: 0x113f20 - 0x113f2c

void entry_113f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f20: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f24: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113f2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113f2c
// Address: 0x113f2c - 0x113f48

void entry_113f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f2c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113f30: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113f34: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113f38: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113f3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x113f44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x113f48; return;
}


// Function: RefOpIsFloat__FiP4CRefP6CFrame
// Address: 0x113f48 - 0x113f68

void entry_113f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f68: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113f6c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f70: 0x38a50015
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 21));
    // 0x113f74: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113f7c);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113f7c
// Address: 0x113f7c - 0x113f88

void entry_113f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f7c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f80: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113f88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113f88
// Address: 0x113f88 - 0x113f94

void entry_113f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113f8c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113f94);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113f94
// Address: 0x113f94 - 0x113fb0

void entry_113f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113f94: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x113f98: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x113f9c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x113fa0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x113fa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x113fac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x113fb0; return;
}


// Function: RefOpIsInteger__FiP4CRefP6CFrame
// Address: 0x113fb0 - 0x113fd0

void entry_113fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113fd0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x113fd4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113fd8: 0x38a50014
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 20));
    // 0x113fdc: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x113fe4);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_113fe4
// Address: 0x113fe4 - 0x113ff0

void entry_113fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113fe4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113fe8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x113ff0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_113ff0
// Address: 0x113ff0 - 0x113ffc

void entry_113ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113ff0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x113ff4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x113ffc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_113ffc
// Address: 0x113ffc - 0x114018

void entry_113ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x113ffc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114000: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114004: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114008: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11400c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114018; return;
}


// Function: RefOpIsSymbol__FiP4CRefP6CFrame
// Address: 0x114018 - 0x114038

void entry_114038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114038: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11403c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114040: 0x38a5001c
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 28));
    // 0x114044: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x11404c);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11404c
// Address: 0x11404c - 0x114058

void entry_11404c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11404c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114050: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114058);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114058
// Address: 0x114058 - 0x114064

void entry_114058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114058: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11405c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114064);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114064
// Address: 0x114064 - 0x114080

void entry_114064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114064: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114068: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11406c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114070: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114074: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11407c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114080; return;
}


// Function: RefOpIsVector__FiP4CRefP6CFrame
// Address: 0x114080 - 0x1140a0

void entry_1140a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1140a0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1140a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1140a8: 0x38a50016
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 22));
    // 0x1140ac: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1140b4);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1140b4
// Address: 0x1140b4 - 0x1140c0

void entry_1140b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1140b4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1140b8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1140c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1140c0
// Address: 0x1140c0 - 0x1140cc

void entry_1140c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1140c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1140c4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1140cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1140cc
// Address: 0x1140cc - 0x1140e8

void entry_1140cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1140cc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1140d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1140d4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1140d8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1140dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1140e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1140e8; return;
}


// Function: RefOpIsMatrix__FiP4CRefP6CFrame
// Address: 0x1140e8 - 0x114108

void entry_114108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114108: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11410c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114110: 0x38a50017
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 23));
    // 0x114114: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x11411c);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11411c
// Address: 0x11411c - 0x114128

void entry_11411c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11411c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114120: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114128);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114128
// Address: 0x114128 - 0x114134

void entry_114128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114128: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11412c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114134);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114134
// Address: 0x114134 - 0x114150

void entry_114134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114134: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114138: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11413c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114140: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114144: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11414c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114150; return;
}


// Function: RefOpIsClq__FiP4CRefP6CFrame
// Address: 0x114150 - 0x114170

void entry_114170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114170: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114174: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114178: 0x38a50018
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 24));
    // 0x11417c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114184);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114184
// Address: 0x114184 - 0x114190

void entry_114184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114184: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114188: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114190
// Address: 0x114190 - 0x11419c

void entry_114190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114190: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114194: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11419c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11419c
// Address: 0x11419c - 0x1141b8

void entry_11419c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11419c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1141a0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1141a4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1141a8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1141ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1141b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1141b8; return;
}


// Function: RefOpIsLm__FiP4CRefP6CFrame
// Address: 0x1141b8 - 0x1141d8

void entry_1141d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1141d8: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1141dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1141e0: 0x38a50019
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 25));
    // 0x1141e4: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1141ec);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1141ec
// Address: 0x1141ec - 0x1141f8

void entry_1141ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1141ec: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1141f0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1141f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1141f8
// Address: 0x1141f8 - 0x114204

void entry_1141f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1141f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1141fc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114204);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114204
// Address: 0x114204 - 0x114220

void entry_114204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114204: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114208: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11420c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114210: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114214: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11421c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114220; return;
}


// Function: RefOpIsSmp__FiP4CRefP6CFrame
// Address: 0x114220 - 0x114240

void entry_114240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114240: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114244: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114248: 0x38a5001a
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 26));
    // 0x11424c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114254);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114254
// Address: 0x114254 - 0x114260

void entry_114254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114254: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114258: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114260);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114260
// Address: 0x114260 - 0x11426c

void entry_114260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114260: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114264: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11426c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11426c
// Address: 0x11426c - 0x114288

void entry_11426c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11426c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114270: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114274: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114278: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11427c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114284: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114288; return;
}


// Function: RefOpIsList__FiP4CRefP6CFrame
// Address: 0x114288 - 0x1142a8

void entry_1142a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1142a8) {
        switch (ctx->pc) {
            case 0x1142c0: ctx->pc = 0; goto label_1142c0;
            case 0x1142c4: ctx->pc = 0; goto label_1142c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1142a8: 0x8e100000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1142ac: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1142b0: 0x12020003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_1142c0;
    }
    // 0x1142b8: 0x16000002
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1142c4;
    }
label_1142c0:
    // 0x1142c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1142c4:
    // 0x1142c4: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1142cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1142cc
// Address: 0x1142cc - 0x1142d8

void entry_1142cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1142cc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1142d0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1142d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1142d8
// Address: 0x1142d8 - 0x1142e4

void entry_1142d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1142d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1142dc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1142e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1142e4
// Address: 0x1142e4 - 0x114300

void entry_1142e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1142e4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1142e8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1142ec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1142f0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1142f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1142fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114300; return;
}


// Function: RefOpIsNull__FiP4CRefP6CFrame
// Address: 0x114300 - 0x114320

void entry_114320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114320: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114324: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114328: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114330);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114330
// Address: 0x114330 - 0x11433c

void entry_114330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114330: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114334: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11433c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11433c
// Address: 0x11433c - 0x114348

void entry_11433c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11433c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114340: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114348);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114348
// Address: 0x114348 - 0x114360

void entry_114348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114348: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11434c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114350: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114354: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114358: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpIsObject__FiP4CRefP6CFrame
// Address: 0x114360 - 0x114380

void entry_114380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114380: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114384: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114388: 0x38a50020
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 32));
    // 0x11438c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114394);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114394
// Address: 0x114394 - 0x1143a0

void entry_114394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114394: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114398: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1143a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1143a0
// Address: 0x1143a0 - 0x1143ac

void entry_1143a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1143a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1143a4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1143ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1143ac
// Address: 0x1143ac - 0x1143c8

void entry_1143ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1143ac: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1143b0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1143b4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1143b8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1143bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1143c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1143c8; return;
}


// Function: RefOpIsNullObj__FiP4CRefP6CFrame
// Address: 0x1143c8 - 0x1143e8

void entry_1143e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1143e8) {
        switch (ctx->pc) {
            case 0x114400: ctx->pc = 0; goto label_114400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1143e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1143ec: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1143f0: 0x14620003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_114400;
    }
    // 0x1143f8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1143fc: 0x2c450001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 2), 1));
label_114400:
    // 0x114400: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114408);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114408
// Address: 0x114408 - 0x114414

void entry_114408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114408: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11440c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114414);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114414
// Address: 0x114414 - 0x114420

void entry_114414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114414: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114418: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114420);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114420
// Address: 0x114420 - 0x114438

void entry_114420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114420: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114424: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114428: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11442c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114430: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpIsMethod__FiP4CRefP6CFrame
// Address: 0x114438 - 0x114458

void entry_114458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114458: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11445c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114460: 0x38a50021
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 33));
    // 0x114464: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x11446c);
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 5), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11446c
// Address: 0x11446c - 0x114478

void entry_11446c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11446c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114470: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114478);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114478
// Address: 0x114478 - 0x114484

void entry_114478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114478: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11447c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114484);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114484
// Address: 0x114484 - 0x1144a0

void entry_114484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114484: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114488: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11448c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114490: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114494: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11449c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1144a0; return;
}


// Function: RefOpIsProcedure__FiP4CRefP6CFrame
// Address: 0x1144a0 - 0x1144c0

void entry_1144c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1144c0) {
        switch (ctx->pc) {
            case 0x1144dc: ctx->pc = 0; goto label_1144dc;
            case 0x1144e0: ctx->pc = 0; goto label_1144e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1144c0: 0x8e100000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1144c4: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x1144c8: 0x12020004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_1144dc;
    }
    // 0x1144d0: 0x2402001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    // 0x1144d4: 0x16020002
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1144e0;
    }
label_1144dc:
    // 0x1144dc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1144e0:
    // 0x1144e0: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1144e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1144e8
// Address: 0x1144e8 - 0x1144f4

void entry_1144e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1144e8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1144ec: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1144f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1144f4
// Address: 0x1144f4 - 0x114500

void entry_1144f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1144f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1144f8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114500);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114500
// Address: 0x114500 - 0x114518

void entry_114500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114500: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114504: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114508: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11450c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114510: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAreNear__FiP4CRefP6CFrame
// Address: 0x114518 - 0x114538

void entry_114538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114538) {
        switch (ctx->pc) {
            case 0x114548: ctx->pc = 0; goto label_114548;
            case 0x114564: ctx->pc = 0; goto label_114564;
            case 0x114568: ctx->pc = 0; goto label_114568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114538: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x11453c: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114540: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x114544: 0x0
    // NOP
label_114548:
    // 0x114548: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11454c: 0x54450005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
        goto label_114564;
    }
    // 0x114554: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x114558: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x11455c: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114568;
    }
label_114564:
    // 0x114564: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
label_114568:
    // 0x114568: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x11456c: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x114570: 0x481fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_114548;
    }
    // 0x114578: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x11457c: 0xc7ad0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    // 0x114580: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x114588);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[14] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_114588
// Address: 0x114588 - 0x114594

void entry_114588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114588: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11458c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114594);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114594
// Address: 0x114594 - 0x1145a0

void entry_114594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114594: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114598: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1145a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1145a0
// Address: 0x1145a0 - 0x1145ac

void entry_1145a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1145a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1145a4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1145ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1145ac
// Address: 0x1145ac - 0x1145c8

void entry_1145ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1145ac: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1145b0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1145b4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1145b8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1145bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1145c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1145c8; return;
}


// Function: RefOpNot__FiP4CRefP6CFrame
// Address: 0x1145c8 - 0x1145e8

void entry_1145e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1145e8) {
        switch (ctx->pc) {
            case 0x114600: ctx->pc = 0; goto label_114600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1145e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1145ec: 0x2402001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1145f0: 0x14620003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_114600;
    }
    // 0x1145f8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1145fc: 0x2c450001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 2), 1));
label_114600:
    // 0x114600: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114608);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114608
// Address: 0x114608 - 0x114614

void entry_114608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114608: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11460c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114614);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114614
// Address: 0x114614 - 0x114620

void entry_114614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114614: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114618: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114620);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114620
// Address: 0x114620 - 0x114638

void entry_114620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114620: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114624: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114628: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11462c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114630: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpCons__FiP4CRefP6CFrame
// Address: 0x114638 - 0x11465c

void entry_11465c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11465c: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114664);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114664
// Address: 0x114664 - 0x114674

void entry_114664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114664: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114668: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11466c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114674);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114674
// Address: 0x114674 - 0x1146a8

void entry_114674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114674) {
        switch (ctx->pc) {
            case 0x114688: ctx->pc = 0; goto label_114688;
            case 0x11469c: ctx->pc = 0; goto label_11469c;
            case 0x1146a0: ctx->pc = 0; goto label_1146a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114674: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x114678: 0x14600003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_114688;
    }
    // 0x114680: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11469c;
    }
label_114688:
    // 0x114688: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x11468c: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        goto label_1146a0;
    }
    // 0x114694: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x114698: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
label_11469c:
    // 0x11469c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1146a0:
    // 0x1146a0: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1146a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1146a8
// Address: 0x1146a8 - 0x1146b4

void entry_1146a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1146a8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1146ac: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1146b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1146b4
// Address: 0x1146b4 - 0x1146c0

void entry_1146b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1146b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1146b8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1146c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1146c0
// Address: 0x1146c0 - 0x1146e0

void entry_1146c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1146c0: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1146c4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1146c8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1146cc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1146d0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1146d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1146dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1146e0; return;
}


// Function: RefOpCar__FiP4CRefP6CFrame
// Address: 0x1146e0 - 0x114700

void entry_114700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114700: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x114704: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11470c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11470c
// Address: 0x11470c - 0x114718

void entry_11470c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11470c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114710: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114718);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114718
// Address: 0x114718 - 0x114724

void entry_114718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114718: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11471c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114724);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114724
// Address: 0x114724 - 0x114740

void entry_114724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114724: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114728: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11472c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114730: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11473c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114740; return;
}


// Function: RefOpCdr__FiP4CRefP6CFrame
// Address: 0x114740 - 0x114760

void entry_114760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114760: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x114764: 0x8c650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x114768: 0x10a00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114780; return;
    }
    // 0x114770: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114778);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114778
// Address: 0x114778 - 0x114788

void entry_114778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114778) {
        switch (ctx->pc) {
            case 0x114780: ctx->pc = 0; goto label_114780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114778: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11478C; return;
    }
label_114780:
    // 0x114780: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x114788);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_114788
// Address: 0x114788 - 0x114794

void entry_114788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114788) {
        switch (ctx->pc) {
            case 0x11478c: ctx->pc = 0; goto label_11478c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114788: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_11478c:
    // 0x11478c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114794);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114794
// Address: 0x114794 - 0x1147a0

void entry_114794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114794: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114798: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1147a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1147a0
// Address: 0x1147a0 - 0x1147b8

void entry_1147a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1147a0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1147a4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1147a8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1147ac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1147b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpSetCadr__FiP4CRefP6CFrame4BIFK
// Address: 0x1147b8 - 0x1147e0

void entry_1147e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1147e0: 0x24020023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 35));
    // 0x1147e4: 0x16020005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1147FC; return;
    }
    // 0x1147ec: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1147f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1147f4
// Address: 0x1147f4 - 0x114820

void entry_1147f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1147f4) {
        switch (ctx->pc) {
            case 0x1147fc: ctx->pc = 0; goto label_1147fc;
            case 0x114814: ctx->pc = 0; goto label_114814;
            case 0x114818: ctx->pc = 0; goto label_114818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1147f4: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114818;
    }
label_1147fc:
    // 0x1147fc: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x114800: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x114804: 0x54620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 0));
        goto label_114814;
    }
    // 0x11480c: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x114810: 0xac820008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 2));
label_114814:
    // 0x114814: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_114818:
    // 0x114818: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x114820);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_114820
// Address: 0x114820 - 0x11482c

void entry_114820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114820: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114824: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11482c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11482c
// Address: 0x11482c - 0x114838

void entry_11482c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11482c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114830: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114838);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114838
// Address: 0x114838 - 0x114858

void entry_114838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114838: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11483c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x114840: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114844: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114848: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11484c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114854: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114858; return;
}


// Function: RefOpSetCar__FiP4CRefP6CFrame
// Address: 0x114858 - 0x114870

void entry_114870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114870: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114874: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114878: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11487c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114888; return;
}


// Function: RefOpSetCdr__FiP4CRefP6CFrame
// Address: 0x114888 - 0x1148a0

void entry_1148a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1148a0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1148a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1148a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1148ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1148b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1148b8; return;
}


// Function: RefOpLength__FiP4CRefP6CFrame
// Address: 0x1148b8 - 0x1148d8

void entry_1148d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1148d8) {
        switch (ctx->pc) {
            case 0x1148f8: ctx->pc = 0; goto label_1148f8;
            case 0x114914: ctx->pc = 0; goto label_114914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1148d8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1148dc: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1148e0: 0x1462000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_114914;
    }
    // 0x1148e8: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1148ec: 0x10600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_114914;
    }
    // 0x1148f4: 0x0
    // NOP
label_1148f8:
    // 0x1148f8: 0x8c630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1148fc: 0x0
    // NOP
    // 0x114900: 0x0
    // NOP
    // 0x114904: 0x0
    // NOP
    // 0x114908: 0x0
    // NOP
    // 0x11490c: 0x1460fffa
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1148f8;
    }
label_114914:
    // 0x114914: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11491c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11491c
// Address: 0x11491c - 0x114928

void entry_11491c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11491c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114920: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114928);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114928
// Address: 0x114928 - 0x114934

void entry_114928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114928: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11492c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114934);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114934
// Address: 0x114934 - 0x114950

void entry_114934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114934: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114938: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11493c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114940: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11494c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114950; return;
}


// Function: RefOpNth__FiP4CRefP6CFrame
// Address: 0x114950 - 0x114970

void entry_114970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114970: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114974: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11497c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11497c
// Address: 0x11497c - 0x1149c0

void entry_11497c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11497c) {
        switch (ctx->pc) {
            case 0x1149a0: ctx->pc = 0; goto label_1149a0;
            case 0x1149a4: ctx->pc = 0; goto label_1149a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11497c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114980: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x114984: 0x1462000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1149C4; return;
    }
    // 0x11498c: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x114990: 0x26030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 8));
    // 0x114994: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1149a4;
    }
    // 0x11499c: 0x0
    // NOP
label_1149a0:
    // 0x1149a0: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1149a4:
    // 0x1149a4: 0x50a00007
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1149C4; return;
    }
    // 0x1149ac: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1149b0: 0x5482fffb
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
        goto label_1149a0;
    }
    // 0x1149b8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1149c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1149c0
// Address: 0x1149c0 - 0x1149cc

void entry_1149c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1149c0) {
        switch (ctx->pc) {
            case 0x1149c4: ctx->pc = 0; goto label_1149c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1149c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1149c4:
    // 0x1149c4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1149cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1149cc
// Address: 0x1149cc - 0x1149d8

void entry_1149cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1149cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1149d0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1149d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1149d8
// Address: 0x1149d8 - 0x1149f0

void entry_1149d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1149d8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1149dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1149e0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1149e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1149e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpIsMember__FiP4CRefP6CFrame
// Address: 0x1149f0 - 0x114a38

void entry_114a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114a38: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114a3c: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x114a44);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114a44
// Address: 0x114a44 - 0x114a5c

void entry_114a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114a44) {
        switch (ctx->pc) {
            case 0x114a50: ctx->pc = 0; goto label_114a50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114a44: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x114a48: 0x27b60030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 48));
    // 0x114a4c: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_114a50:
    // 0x114a50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114a54: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x114a5c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114a5c
// Address: 0x114a5c - 0x114a70

void entry_114a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114a5c: 0x1634fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 20)) {
        ctx->pc = 0x114A50; return;
    }
    // 0x114a64: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114a68: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114a70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114a70
// Address: 0x114a70 - 0x114a8c

void entry_114a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114a70: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x114a74: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x114a78: 0x14620022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x114B04; return;
    }
    // 0x114a80: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x114a84: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114a8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114a8c
// Address: 0x114a8c - 0x114ab4

void entry_114a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114a8c) {
        switch (ctx->pc) {
            case 0x114aa0: ctx->pc = 0; goto label_114aa0;
            case 0x114aa4: ctx->pc = 0; goto label_114aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114a8c: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x114a90: 0x8e50000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x114a94: 0x10000003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 27));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114aa4;
    }
    // 0x114a9c: 0x0
    // NOP
label_114aa0:
    // 0x114aa0: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_114aa4:
    // 0x114aa4: 0x12000016
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 40));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_114b00(rdram, ctx, runtime); return;
    }
    // 0x114aac: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114ab4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114ab4
// Address: 0x114ab4 - 0x114ac8

void entry_114ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114ab4: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x114ab8: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x114abc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114ac0: 0xc044f92
    SET_GPR_U32(ctx, 31, 0x114ac8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    RefOpEqual__FiP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_114ac8
// Address: 0x114ac8 - 0x114ad4

void entry_114ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114ac8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x114acc: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114ad4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114ad4
// Address: 0x114ad4 - 0x114ae0

void entry_114ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114ad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114ad8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114ae0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114ae0
// Address: 0x114ae0 - 0x114b00

void entry_114ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114ae0: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114ae4: 0x5452ffef
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x114AA4; return;
    }
    // 0x114aec: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x114af0: 0x1040ffeb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114AA0; return;
    }
    // 0x114af8: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x114b00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_114b00
// Address: 0x114b00 - 0x114b0c

void entry_114b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114b00) {
        switch (ctx->pc) {
            case 0x114b04: ctx->pc = 0; goto label_114b04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114b00: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_114b04:
    // 0x114b04: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114b0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114b0c
// Address: 0x114b0c - 0x114b2c

void entry_114b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114b0c) {
        switch (ctx->pc) {
            case 0x114b20: ctx->pc = 0; goto label_114b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114b0c: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x114b10: 0x12700009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x114B38; return;
    }
    // 0x114b18: 0x2610fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    // 0x114b1c: 0x0
    // NOP
label_114b20:
    // 0x114b20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x114b24: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114b2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114b2c
// Address: 0x114b2c - 0x114b40

void entry_114b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114b2c) {
        switch (ctx->pc) {
            case 0x114b38: ctx->pc = 0; goto label_114b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114b2c: 0x1670fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x114B20; return;
    }
    // 0x114b34: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_114b38:
    // 0x114b38: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114b40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114b40
// Address: 0x114b40 - 0x114b4c

void entry_114b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114b40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114b44: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114b4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114b4c
// Address: 0x114b4c - 0x114b80

void entry_114b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114b4c: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x114b50: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x114b54: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x114b58: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x114b5c: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x114b60: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x114b64: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x114b68: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x114b6c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x114b70: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x114b74: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x114b78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpList__FiP4CRefP6CFrame
// Address: 0x114b80 - 0x114b98

void entry_114b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114b98: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114b9c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114ba0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x114ba4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114bac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114bb0; return;
}


// Function: RefOpAppend__FiP4CRefP6CFrame
// Address: 0x114bb0 - 0x114be0

void entry_114be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114be0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114be4: 0x54600009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x114C0C; return;
    }
    // 0x114bec: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114bf0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114bf8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114bf8
// Address: 0x114bf8 - 0x114c04

void entry_114bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114bf8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114bfc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114c04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114c04
// Address: 0x114c04 - 0x114c38

void entry_114c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114c04) {
        switch (ctx->pc) {
            case 0x114c0c: ctx->pc = 0; goto label_114c0c;
            case 0x114c20: ctx->pc = 0; goto label_114c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114c04: 0x1000003a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114CF0; return;
    }
label_114c0c:
    // 0x114c0c: 0x1200002a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114CB8; return;
    }
    // 0x114c14: 0x2415001e
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 30));
    // 0x114c18: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x114c1c: 0x0
    // NOP
label_114c20:
    // 0x114c20: 0x14550022
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x114CAC; return;
    }
    // 0x114c28: 0x50600008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        entry_114c4c(rdram, ctx, runtime); return;
    }
    // 0x114c30: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114c38);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114c38
// Address: 0x114c38 - 0x114c4c

void entry_114c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114c38: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114c3c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x114c40: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114c44: 0xc046bae
    SET_GPR_U32(ctx, 31, 0x114c4c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CloneTo__5CPairP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_114c4c
// Address: 0x114c4c - 0x114c5c

void entry_114c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114c4c: 0x56600009
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 17));
        ctx->pc = 0x114C74; return;
    }
    // 0x114c54: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114c5c);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114c5c
// Address: 0x114c5c - 0x114c6c

void entry_114c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114c5c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114c60: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114c64: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114c6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114c6c
// Address: 0x114c6c - 0x114ccc

void entry_114c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114c6c) {
        switch (ctx->pc) {
            case 0x114c74: ctx->pc = 0; goto label_114c74;
            case 0x114c7c: ctx->pc = 0; goto label_114c7c;
            case 0x114c90: ctx->pc = 0; goto label_114c90;
            case 0x114cac: ctx->pc = 0; goto label_114cac;
            case 0x114cb0: ctx->pc = 0; goto label_114cb0;
            case 0x114cb8: ctx->pc = 0; goto label_114cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114c6c: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114c7c;
    }
label_114c74:
    // 0x114c74: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x114c78: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_114c7c:
    // 0x114c7c: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x114c80: 0x1040000b
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_114cb0;
    }
    // 0x114c88: 0x8e520008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x114c8c: 0x0
    // NOP
label_114c90:
    // 0x114c90: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x114c94: 0x0
    // NOP
    // 0x114c98: 0x0
    // NOP
    // 0x114c9c: 0x0
    // NOP
    // 0x114ca0: 0x0
    // NOP
    // 0x114ca4: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        goto label_114c90;
    }
label_114cac:
    // 0x114cac: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_114cb0:
    // 0x114cb0: 0x5600ffdb
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x114C20; return;
    }
label_114cb8:
    // 0x114cb8: 0x52600006
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
        ctx->pc = 0x114CD4; return;
    }
    // 0x114cc0: 0x8e650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x114cc4: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114ccc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114ccc
// Address: 0x114ccc - 0x114ce0

void entry_114ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114ccc) {
        switch (ctx->pc) {
            case 0x114cd4: ctx->pc = 0; goto label_114cd4;
            case 0x114cd8: ctx->pc = 0; goto label_114cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114ccc: 0x10000002
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114cd8;
    }
label_114cd4:
    // 0x114cd4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_114cd8:
    // 0x114cd8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114ce0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114ce0
// Address: 0x114ce0 - 0x114cec

void entry_114ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114ce0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x114ce4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114cec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114cec
// Address: 0x114cec - 0x114d18

void entry_114cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114cec) {
        switch (ctx->pc) {
            case 0x114cf0: ctx->pc = 0; goto label_114cf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114cec: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_114cf0:
    // 0x114cf0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x114cf4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x114cf8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x114cfc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x114d00: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x114d04: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x114d08: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x114d0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x114d14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x114d18; return;
}


// Function: RefOpMap__FiP4CRefP6CFrame
// Address: 0x114d18 - 0x114d60

void entry_114d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114d60) {
        switch (ctx->pc) {
            case 0x114d70: ctx->pc = 0; goto label_114d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114d60: 0x27a2004c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 76));
    // 0x114d64: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114d68: 0xafa2007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
    // 0x114d6c: 0x0
    // NOP
label_114d70:
    // 0x114d70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114d74: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x114d7c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114d7c
// Address: 0x114d7c - 0x114d9c

void entry_114d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114d7c: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x114d80: 0x1651fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x114D70; return;
    }
    // 0x114d88: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x114d8c: 0x14400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x114DA4; return;
    }
    // 0x114d94: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114d9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114d9c
// Address: 0x114d9c - 0x114dac

void entry_114d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114d9c) {
        switch (ctx->pc) {
            case 0x114da4: ctx->pc = 0; goto label_114da4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114d9c: 0x1000004d
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114ED4; return;
    }
label_114da4:
    // 0x114da4: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114dac);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114dac
// Address: 0x114dac - 0x114de0

void entry_114dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114dac) {
        switch (ctx->pc) {
            case 0x114dd8: ctx->pc = 0; goto label_114dd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114dac: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114db0: 0x27b2001c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 28));
    // 0x114db4: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x114db8: 0x27b60034
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 52));
    // 0x114dbc: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x114dc0: 0x27b50028
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 40));
    // 0x114dc4: 0x26820008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 8));
    // 0x114dc8: 0x27be0040
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 64));
    // 0x114dcc: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x114dd0: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x114dd4: 0x0
    // NOP
label_114dd8:
    // 0x114dd8: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114de0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114de0
// Address: 0x114de0 - 0x114dfc

void entry_114de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114de0: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x114de4: 0x2e220002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 2));
    // 0x114de8: 0x1440fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x114DD8; return;
    }
    // 0x114df0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114df4: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114dfc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114dfc
// Address: 0x114dfc - 0x114e10

void entry_114dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114dfc: 0x24100011
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 17));
    // 0x114e00: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x114e04: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x114e08: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114e10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114e10
// Address: 0x114e10 - 0x114e20

void entry_114e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e10: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x114e14: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x114e18: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114e20);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 21));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114e20
// Address: 0x114e20 - 0x114e3c

void entry_114e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e20: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x114e24: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x114e28: 0xafa00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
    // 0x114e2c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114e30: 0xafb00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 16));
    // 0x114e34: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114e3c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114e3c
// Address: 0x114e3c - 0x114e60

void entry_114e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114e3c) {
        switch (ctx->pc) {
            case 0x114e58: ctx->pc = 0; goto label_114e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114e3c: 0x8fa20078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x114e40: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x114e44: 0x8c510004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x114e48: 0xafb00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    // 0x114e4c: 0x1220001d
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x114EC4; return;
    }
    // 0x114e54: 0x27b20060
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 96));
label_114e58:
    // 0x114e58: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x114e60);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_114e60
// Address: 0x114e60 - 0x114e70

void entry_114e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e60: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x114e64: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x114e68: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114e70);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114e70
// Address: 0x114e70 - 0x114e80

void entry_114e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e70: 0x8fa60074
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x114e74: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114e78: 0xc046820
    SET_GPR_U32(ctx, 31, 0x114e80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_114e80
// Address: 0x114e80 - 0x114e8c

void entry_114e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e80: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114e84: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114e8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114e8c
// Address: 0x114e8c - 0x114e98

void entry_114e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e8c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x114e90: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114e98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114e98
// Address: 0x114e98 - 0x114eb0

void entry_114e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114e98: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x114e9c: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 23), 8), GPR_U32(ctx, 16));
        ctx->pc = 0x114EB8; return;
    }
    // 0x114ea4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x114ea8: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114eb0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114eb0
// Address: 0x114eb0 - 0x114ed0

void entry_114eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114eb0) {
        switch (ctx->pc) {
            case 0x114eb8: ctx->pc = 0; goto label_114eb8;
            case 0x114ebc: ctx->pc = 0; goto label_114ebc;
            case 0x114ec4: ctx->pc = 0; goto label_114ec4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114eb0: 0x10000002
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_114ebc;
    }
label_114eb8:
    // 0x114eb8: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_114ebc:
    // 0x114ebc: 0x1620ffe6
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x114E58; return;
    }
label_114ec4:
    // 0x114ec4: 0x8e650004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x114ec8: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x114ed0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_114ed0
// Address: 0x114ed0 - 0x114edc

void entry_114ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114ed0) {
        switch (ctx->pc) {
            case 0x114ed4: ctx->pc = 0; goto label_114ed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114ed0: 0x8fa40070
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 112)));
label_114ed4:
    // 0x114ed4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x114edc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114edc
// Address: 0x114edc - 0x114efc

void entry_114edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114edc) {
        switch (ctx->pc) {
            case 0x114ef0: ctx->pc = 0; goto label_114ef0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114edc: 0x8fb0007c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    // 0x114ee0: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114ee4: 0x10500009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x114F0C; return;
    }
    // 0x114eec: 0x2610fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
label_114ef0:
    // 0x114ef0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x114ef4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114efc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114efc
// Address: 0x114efc - 0x114f14

void entry_114efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114efc) {
        switch (ctx->pc) {
            case 0x114f0c: ctx->pc = 0; goto label_114f0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114efc: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x114f00: 0x1450fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x114EF0; return;
    }
    // 0x114f08: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_114f0c:
    // 0x114f0c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x114f14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_114f14
// Address: 0x114f14 - 0x114f48

void entry_114f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114f14: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x114f18: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x114f1c: 0x7bbe0100
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x114f20: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x114f24: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x114f28: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x114f2c: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x114f30: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x114f34: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x114f38: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x114f3c: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x114f40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFilter__FiP4CRefP6CFrame
// Address: 0x114f48 - 0x114f90

void entry_114f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114f90) {
        switch (ctx->pc) {
            case 0x114fa0: ctx->pc = 0; goto label_114fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114f90: 0x27a2004c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 76));
    // 0x114f94: 0x27be0060
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 96));
    // 0x114f98: 0xafa2008c
    WRITE32(ADD32(GPR_U32(ctx, 29), 140), GPR_U32(ctx, 2));
    // 0x114f9c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
label_114fa0:
    // 0x114fa0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x114fa4: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x114fac);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114fac
// Address: 0x114fac - 0x114fc0

void entry_114fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114fac: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x114fb0: 0x1651fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x114FA0; return;
    }
    // 0x114fb8: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x114fc0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114fc0
// Address: 0x114fc0 - 0x114fd8

void entry_114fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x114fc0: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x114fc4: 0x14600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 8));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x114FE0; return;
    }
    // 0x114fcc: 0x26650008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 8));
    // 0x114fd0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x114fd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_114fd8
// Address: 0x114fd8 - 0x115008

void entry_114fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x114fd8) {
        switch (ctx->pc) {
            case 0x114fe0: ctx->pc = 0; goto label_114fe0;
            case 0x115000: ctx->pc = 0; goto label_115000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x114fd8: 0x1000005a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115144; return;
    }
label_114fe0:
    // 0x114fe0: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x114fe4: 0xafa20090
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 2));
    // 0x114fe8: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x114fec: 0x27b2001c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 28));
    // 0x114ff0: 0x27b60034
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 52));
    // 0x114ff4: 0x27b50028
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 40));
    // 0x114ff8: 0x27b70040
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 64));
    // 0x114ffc: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
label_115000:
    // 0x115000: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x115008);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_115008
// Address: 0x115008 - 0x115024

void entry_115008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115008: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11500c: 0x2e220002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 2));
    // 0x115010: 0x1440fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115000; return;
    }
    // 0x115018: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11501c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115024);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115024
// Address: 0x115024 - 0x115038

void entry_115024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115024: 0x24100011
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 17));
    // 0x115028: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x11502c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x115030: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115038);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115038
// Address: 0x115038 - 0x115048

void entry_115038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115038: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11503c: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x115040: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115048);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 21));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115048
// Address: 0x115048 - 0x115064

void entry_115048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115048: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11504c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x115050: 0xafa00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
    // 0x115054: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115058: 0xafb00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 16));
    // 0x11505c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115064);
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115064
// Address: 0x115064 - 0x115090

void entry_115064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115064) {
        switch (ctx->pc) {
            case 0x115088: ctx->pc = 0; goto label_115088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115064: 0x8fa20090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x115068: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x11506c: 0x8c510004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x115070: 0xafb00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    // 0x115074: 0x1220002b
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115124; return;
    }
    // 0x11507c: 0x27b20070
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    // 0x115080: 0x2413001b
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 27));
    // 0x115084: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
label_115088:
    // 0x115088: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115090);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115090
// Address: 0x115090 - 0x1150a0

void entry_115090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115090: 0x8fa60084
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x115094: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115098: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1150a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1150a0
// Address: 0x1150a0 - 0x1150ac

void entry_1150a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150a0: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1150a4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1150ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1150ac
// Address: 0x1150ac - 0x1150b8

void entry_1150ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1150b0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1150b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1150b8
// Address: 0x1150b8 - 0x1150d8

void entry_1150b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150b8: 0x8fa20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1150bc: 0x54530017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x11511C; return;
    }
    // 0x1150c4: 0x8fa20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 100)));
    // 0x1150c8: 0x50400014
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x11511C; return;
    }
    // 0x1150d0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1150d8);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1150d8
// Address: 0x1150d8 - 0x1150e8

void entry_1150d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150d8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1150dc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1150e0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1150e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1150e8
// Address: 0x1150e8 - 0x1150f8

void entry_1150e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150e8: 0x16800009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 136)));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115110; return;
    }
    // 0x1150f0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1150f8);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1150f8
// Address: 0x1150f8 - 0x115108

void entry_1150f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1150f8: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1150fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115100: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115108
// Address: 0x115108 - 0x115138

void entry_115108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115108) {
        switch (ctx->pc) {
            case 0x115110: ctx->pc = 0; goto label_115110;
            case 0x115118: ctx->pc = 0; goto label_115118;
            case 0x11511c: ctx->pc = 0; goto label_11511c;
            case 0x115124: ctx->pc = 0; goto label_115124;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115108: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115118;
    }
label_115110:
    // 0x115110: 0xac500008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 16));
    // 0x115114: 0xafb00088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 16));
label_115118:
    // 0x115118: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_11511c:
    // 0x11511c: 0x1620ffda
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115088; return;
    }
label_115124:
    // 0x115124: 0x52800006
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
        ctx->pc = 0x115140; return;
    }
    // 0x11512c: 0x8e850004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x115130: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115138);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115138
// Address: 0x115138 - 0x11514c

void entry_115138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115138) {
        switch (ctx->pc) {
            case 0x115140: ctx->pc = 0; goto label_115140;
            case 0x115144: ctx->pc = 0; goto label_115144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115138: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115144;
    }
label_115140:
    // 0x115140: 0x8fa40080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
label_115144:
    // 0x115144: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11514c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11514c
// Address: 0x11514c - 0x115170

void entry_11514c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11514c) {
        switch (ctx->pc) {
            case 0x115160: ctx->pc = 0; goto label_115160;
            case 0x115168: ctx->pc = 0; goto label_115168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11514c: 0x8fb0008c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 140)));
    // 0x115150: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x115154: 0x10000004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115168;
    }
    // 0x11515c: 0x0
    // NOP
label_115160:
    // 0x115160: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x115164: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_115168:
    // 0x115168: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115170);
    ctx->pc = 0x11b060; return;
}


// Function: entry_115170
// Address: 0x115170 - 0x115188

void entry_115170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115170: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115174: 0x1450fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x115160; return;
    }
    // 0x11517c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115180: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115188);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115188
// Address: 0x115188 - 0x1151c0

void entry_115188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115188: 0x8fa20080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11518c: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x115190: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x115194: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x115198: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x11519c: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1151a0: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1151a4: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1151a8: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1151ac: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1151b0: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1151b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1151bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1151c0; return;
}


// Function: RefOpForEach__FiP4CRefP6CFrame
// Address: 0x1151c0 - 0x115208

void entry_115208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115208) {
        switch (ctx->pc) {
            case 0x115218: ctx->pc = 0; goto label_115218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115208: 0x27a2004c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 76));
    // 0x11520c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115210: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x115214: 0x200b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_115218:
    // 0x115218: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11521c: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x115224);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115224
// Address: 0x115224 - 0x115268

void entry_115224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115224) {
        switch (ctx->pc) {
            case 0x115260: ctx->pc = 0; goto label_115260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115224: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x115228: 0x1651fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x115218; return;
    }
    // 0x115230: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x115234: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x115238: 0x14620039
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x115320; return;
    }
    // 0x115240: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x115244: 0x27b2001c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 28));
    // 0x115248: 0x27b50034
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 52));
    // 0x11524c: 0x27b40028
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 40));
    // 0x115250: 0x27b60040
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 64));
    // 0x115254: 0x267e0008
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 8));
    // 0x115258: 0x27b00050
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    // 0x11525c: 0x0
    // NOP
label_115260:
    // 0x115260: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x115268);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_115268
// Address: 0x115268 - 0x115284

void entry_115268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115268: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11526c: 0x2e220002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 2));
    // 0x115270: 0x1440fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115260; return;
    }
    // 0x115278: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x11527c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115284);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115284
// Address: 0x115284 - 0x115298

void entry_115284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115284: 0x24100011
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 17));
    // 0x115288: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x11528c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x115290: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x115298);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_115298
// Address: 0x115298 - 0x1152a8

void entry_115298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115298: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11529c: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1152a0: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1152a8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 20));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1152a8
// Address: 0x1152a8 - 0x1152c4

void entry_1152a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1152a8: 0x8fa20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1152ac: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1152b0: 0xafa00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
    // 0x1152b4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1152b8: 0xafb00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 16));
    // 0x1152bc: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1152c4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 2));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1152c4
// Address: 0x1152c4 - 0x1152e8

void entry_1152c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1152c4) {
        switch (ctx->pc) {
            case 0x1152e0: ctx->pc = 0; goto label_1152e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1152c4: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x1152c8: 0x8fd10004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x1152cc: 0xafb00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 16));
    // 0x1152d0: 0x12200012
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11531C; return;
    }
    // 0x1152d8: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1152dc: 0x8fa40054
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
label_1152e0:
    // 0x1152e0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1152e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1152e8
// Address: 0x1152e8 - 0x1152f8

void entry_1152e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1152e8: 0x8fa60074
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x1152ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1152f0: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1152f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1152f8
// Address: 0x1152f8 - 0x115304

void entry_1152f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1152f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1152fc: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115304);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115304
// Address: 0x115304 - 0x115310

void entry_115304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115304: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115308: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115310);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115310
// Address: 0x115310 - 0x115330

void entry_115310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115310) {
        switch (ctx->pc) {
            case 0x11531c: ctx->pc = 0; goto label_11531c;
            case 0x115320: ctx->pc = 0; goto label_115320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115310: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x115314: 0x1620fff2
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1152E0; return;
    }
label_11531c:
    // 0x11531c: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
label_115320:
    // 0x115320: 0x8fa40070
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x115324: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x115328: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115330);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115330
// Address: 0x115330 - 0x11534c

void entry_115330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115330) {
        switch (ctx->pc) {
            case 0x115340: ctx->pc = 0; goto label_115340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115330: 0x8fb00078
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x115334: 0x12f00008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x115358; return;
    }
    // 0x11533c: 0x2610fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
label_115340:
    // 0x115340: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x115344: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11534c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11534c
// Address: 0x11534c - 0x115360

void entry_11534c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11534c) {
        switch (ctx->pc) {
            case 0x115358: ctx->pc = 0; goto label_115358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11534c: 0x16f0fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967284));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x115340; return;
    }
    // 0x115354: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_115358:
    // 0x115358: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115360);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115360
// Address: 0x115360 - 0x115398

void entry_115360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115360: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x115364: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x115368: 0x7bbe0100
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x11536c: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x115370: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x115374: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x115378: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x11537c: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x115380: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x115384: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x115388: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11538c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x115394: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x115398; return;
}


// Function: RefOpEval__FiP4CRefP6CFrame
// Address: 0x115398 - 0x1153c4

void entry_1153c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1153c4: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1153cc);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1153cc
// Address: 0x1153cc - 0x1153dc

void entry_1153cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1153cc: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1153d0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1153d4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1153dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1153dc
// Address: 0x1153dc - 0x1153f0

void entry_1153dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1153dc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1153e0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1153e4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1153e8: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1153f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1153f0
// Address: 0x1153f0 - 0x1153fc

void entry_1153f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1153f0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1153f4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1153fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1153fc
// Address: 0x1153fc - 0x115408

void entry_1153fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1153fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115400: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115408);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115408
// Address: 0x115408 - 0x115414

void entry_115408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115408: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11540c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115414);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115414
// Address: 0x115414 - 0x115420

void entry_115414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115414: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115418: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115420);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115420
// Address: 0x115420 - 0x115440

void entry_115420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115420: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x115424: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x115428: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11542c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x115430: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115434: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115438: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVector__FiP4CRefP6CFrame
// Address: 0x115440 - 0x115474

void entry_115474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115474: 0xc047142
    SET_GPR_U32(ctx, 31, 0x11547c);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11547c
// Address: 0x11547c - 0x115494

void entry_11547c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11547c) {
        switch (ctx->pc) {
            case 0x115488: ctx->pc = 0; goto label_115488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11547c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115480: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115484: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_115488:
    // 0x115488: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11548c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115494);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115494
// Address: 0x115494 - 0x1154a4

void entry_115494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115494: 0x26520008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    // 0x115498: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11549c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1154a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1154a4
// Address: 0x1154a4 - 0x1154b4

void entry_1154a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1154a4: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x1154a8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1154ac: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1154b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1154b4
// Address: 0x1154b4 - 0x1154d0

void entry_1154b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1154b4: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1154b8: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1154bc: 0x661fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x115488; return;
    }
    // 0x1154c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1154c8: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1154d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1154d0
// Address: 0x1154d0 - 0x1154dc

void entry_1154d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1154d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1154d4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1154dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1154dc
// Address: 0x1154dc - 0x1154e8

void entry_1154dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1154dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1154e0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1154e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1154e8
// Address: 0x1154e8 - 0x115510

void entry_1154e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1154e8: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1154ec: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1154f0: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1154f4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1154f8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1154fc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x115500: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115504: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMatrix__FiP4CRefP6CFrame
// Address: 0x115510 - 0x11554c

void entry_11554c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11554c: 0xc047186
    SET_GPR_U32(ctx, 31, 0x115554);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_115554
// Address: 0x115554 - 0x11559c

void entry_115554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115554) {
        switch (ctx->pc) {
            case 0x115584: ctx->pc = 0; goto label_115584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115554: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115558: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x11555c: 0x1222001d
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1155D4; return;
    }
    // 0x115564: 0x2a22000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 10));
    // 0x115568: 0x14400006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_115584;
    }
    // 0x115570: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x115574: 0x1222001a
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 17), 9));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1155E0; return;
    }
    // 0x11557c: 0x10000038
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115660; return;
    }
label_115584:
    // 0x115584: 0x10400035
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11565C; return;
    }
    // 0x11558c: 0x14400034
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115660; return;
    }
    // 0x115594: 0xc062130
    SET_GPR_U32(ctx, 31, 0x11559c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11559c
// Address: 0x11559c - 0x1155dc

void entry_11559c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11559c) {
        switch (ctx->pc) {
            case 0x1155b0: ctx->pc = 0; goto label_1155b0;
            case 0x1155d4: ctx->pc = 0; goto label_1155d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11559c: 0x1a200030
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x115660; return;
    }
    // 0x1155a4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1155a8: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1155ac: 0x0
    // NOP
label_1155b0:
    // 0x1155b0: 0x8e630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1155b4: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1155b8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1155bc: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x1155c0: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    // 0x1155c4: 0x14a0fffa
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1155b0;
    }
    // 0x1155cc: 0x10000024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115660; return;
    }
label_1155d4:
    // 0x1155d4: 0xc062130
    SET_GPR_U32(ctx, 31, 0x1155dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1155dc
// Address: 0x1155dc - 0x11561c

void entry_1155dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1155dc) {
        switch (ctx->pc) {
            case 0x1155e0: ctx->pc = 0; goto label_1155e0;
            case 0x1155f8: ctx->pc = 0; goto label_1155f8;
            case 0x115610: ctx->pc = 0; goto label_115610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1155dc: 0x3a230009
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 17), 9));
label_1155e0:
    // 0x1155e0: 0x24140004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1155e4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1155e8: 0x43a00a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 2));
    // 0x1155ec: 0x1280001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11565C; return;
    }
    // 0x1155f4: 0x0
    // NOP
label_1155f8:
    // 0x1155f8: 0x12800014
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11564C; return;
    }
    // 0x115600: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x115604: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115608: 0x568821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x11560c: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_115610:
    // 0x115610: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x115614: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x11561c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11561c
// Address: 0x11561c - 0x11562c

void entry_11561c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11561c: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x115620: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115624: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11562c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11562c
// Address: 0x11562c - 0x115638

void entry_11562c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11562c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x115630: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115638);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115638
// Address: 0x115638 - 0x115668

void entry_115638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115638) {
        switch (ctx->pc) {
            case 0x11564c: ctx->pc = 0; goto label_11564c;
            case 0x11565c: ctx->pc = 0; goto label_11565c;
            case 0x115660: ctx->pc = 0; goto label_115660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115638: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11563c: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x115640: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x115644: 0x1600fff2
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x115610; return;
    }
label_11564c:
    // 0x11564c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x115650: 0x94102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 20)));
    // 0x115654: 0x1440ffe8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1155F8; return;
    }
label_11565c:
    // 0x11565c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_115660:
    // 0x115660: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x115668);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_115668
// Address: 0x115668 - 0x115674

void entry_115668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115668: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11566c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115674);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115674
// Address: 0x115674 - 0x115680

void entry_115674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115674: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115678: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115680);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115680
// Address: 0x115680 - 0x1156b0

void entry_115680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115680: 0x2e0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x115684: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x115688: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11568c: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x115690: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x115694: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x115698: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11569c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1156a0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1156a4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1156a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpSetMusicRegister__FiP4CRefP6CFrame
// Address: 0x1156b0 - 0x1156cc

void entry_1156cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1156cc: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1156d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1156d4
// Address: 0x1156d4 - 0x1156e0

void entry_1156d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1156d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1156d8: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1156e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1156e0
// Address: 0x1156e0 - 0x1156ec

void entry_1156e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1156e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1156e4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1156ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1156ec
// Address: 0x1156ec - 0x1156f8

void entry_1156ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1156ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1156f0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1156f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1156f8
// Address: 0x1156f8 - 0x115710

void entry_1156f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1156f8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1156fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115700: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115704: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11570c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x115710; return;
}


// Function: RefOpClq__FiP4CRefP6CFrame
// Address: 0x115710 - 0x115744

void entry_115744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115744: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x11574c);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11574c
// Address: 0x11574c - 0x115764

void entry_11574c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11574c) {
        switch (ctx->pc) {
            case 0x115758: ctx->pc = 0; goto label_115758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11574c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115750: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115754: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_115758:
    // 0x115758: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11575c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115764);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115764
// Address: 0x115764 - 0x115774

void entry_115764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115764: 0x26520008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    // 0x115768: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11576c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115774);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115774
// Address: 0x115774 - 0x115784

void entry_115774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115774: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x115778: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11577c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115784);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115784
// Address: 0x115784 - 0x1157a0

void entry_115784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115784: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115788: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11578c: 0x661fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 19) >= 0) {
        ctx->pc = 0x115758; return;
    }
    // 0x115794: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115798: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x1157a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_1157a0
// Address: 0x1157a0 - 0x1157ac

void entry_1157a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1157a0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1157a4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1157ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1157ac
// Address: 0x1157ac - 0x1157b8

void entry_1157ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1157ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1157b0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1157b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1157b8
// Address: 0x1157b8 - 0x1157e0

void entry_1157b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1157b8: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1157bc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1157c0: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1157c4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1157c8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1157cc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1157d0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1157d4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1157d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpLm__FiP4CRefP6CFrame
// Address: 0x1157e0 - 0x115808

void entry_115808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115808: 0xc047216
    SET_GPR_U32(ctx, 31, 0x115810);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_115810
// Address: 0x115810 - 0x115824

void entry_115810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115810: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115814: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115818: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11581c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115824);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115824
// Address: 0x115824 - 0x115830

void entry_115824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115824: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115828: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115830);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115830
// Address: 0x115830 - 0x11583c

void entry_115830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115830: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115834: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11583c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11583c
// Address: 0x11583c - 0x115850

void entry_11583c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11583c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115840: 0x26450008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 8));
    // 0x115844: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115848: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115850);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115850
// Address: 0x115850 - 0x11585c

void entry_115850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115850: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115854: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11585c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11585c
// Address: 0x11585c - 0x115868

void entry_11585c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11585c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115860: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115868);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115868
// Address: 0x115868 - 0x11587c

void entry_115868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115868: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11586c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115870: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x115874: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x11587c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4), *(uint32_t*)&val); }
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11587c
// Address: 0x11587c - 0x115888

void entry_11587c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11587c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115880: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115888);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115888
// Address: 0x115888 - 0x115894

void entry_115888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115888: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11588c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115894);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115894
// Address: 0x115894 - 0x1158b8

void entry_115894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115894: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x115898: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11589c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1158a0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1158a4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1158a8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1158ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1158b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1158b8; return;
}


// Function: RefOpSmp__FiP4CRefP6CFrame
// Address: 0x1158b8 - 0x1158e0

void entry_1158e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1158e0: 0xc04725a
    SET_GPR_U32(ctx, 31, 0x1158e8);
    PsmpNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1158e8
// Address: 0x1158e8 - 0x1158fc

void entry_1158e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1158e8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1158ec: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1158f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1158f4: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1158fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1158fc
// Address: 0x1158fc - 0x115908

void entry_1158fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1158fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115900: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115908);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115908
// Address: 0x115908 - 0x115914

void entry_115908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115908: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11590c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115914);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115914
// Address: 0x115914 - 0x115928

void entry_115914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115914: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115918: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11591c: 0x26250008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    // 0x115920: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115928);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115928
// Address: 0x115928 - 0x115934

void entry_115928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115928: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11592c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115934);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115934
// Address: 0x115934 - 0x115940

void entry_115934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115934: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115938: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115940);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115940
// Address: 0x115940 - 0x115954

void entry_115940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115940: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115944: 0x26250010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 16));
    // 0x115948: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11594c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x115954);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4), *(uint32_t*)&val); }
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115954
// Address: 0x115954 - 0x115960

void entry_115954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115954: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115958: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x115960);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115960
// Address: 0x115960 - 0x11596c

void entry_115960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115960: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115964: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11596c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11596c
// Address: 0x11596c - 0x115980

void entry_11596c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11596c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115970: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115974: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x115978: 0xc046e18
    SET_GPR_U32(ctx, 31, 0x115980);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    SetSmp__4CRefP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_115980
// Address: 0x115980 - 0x11598c

void entry_115980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115980: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115984: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11598c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11598c
// Address: 0x11598c - 0x115998

void entry_11598c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11598c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115990: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115998);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115998
// Address: 0x115998 - 0x1159b8

void entry_115998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115998: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11599c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1159a0: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1159a4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1159a8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1159ac: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1159b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpGetElement__FiP4CRefP6CFrame
// Address: 0x1159b8 - 0x1159e4

void entry_1159e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1159e4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1159e8: 0x2463ffea
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967274));
    // 0x1159ec: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x1159f0: 0x10400053
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_115b40(rdram, ctx, runtime); return;
    }
    // 0x1159f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1159fc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x115a00: 0x244291e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294939104));
    // 0x115a04: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x115a08: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x115a0c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x115a14: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x115a18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115a1c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115a20: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x115a24: 0x10000039
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B0C; return;
    }
    // 0x115a2c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x115a30: 0x1642000e
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x115A6C; return;
    }
    // 0x115a38: 0xc047142
    SET_GPR_U32(ctx, 31, 0x115a40);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_115a40
// Address: 0x115a40 - 0x115a64

void entry_115a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115a40: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115a44: 0x111900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 4));
    // 0x115a48: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x115a4c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115a50: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x115a54: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x115a58: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x115a5c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x115a64);
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), GPR_VEC(ctx, 2));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_115a64
// Address: 0x115a64 - 0x115ac8

void entry_115a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115a64) {
        switch (ctx->pc) {
            case 0x115a6c: ctx->pc = 0; goto label_115a6c;
            case 0x115abc: ctx->pc = 0; goto label_115abc;
            case 0x115ac0: ctx->pc = 0; goto label_115ac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115a64: 0x10000037
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
label_115a6c:
    // 0x115a6c: 0x8ce70008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x115a70: 0x112900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 17), 4));
    // 0x115a74: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115a78: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115a7c: 0x8ce20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x115a80: 0x653021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x115a84: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x115a88: 0x10000020
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B0C; return;
    }
    // 0x115a90: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x115a94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115a98: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115a9c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x115aa0: 0x1000001a
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B0C; return;
    }
    // 0x115aa8: 0x8ce20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x115aac: 0x14400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_115abc;
    }
    // 0x115ab4: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115ac0;
    }
label_115abc:
    // 0x115abc: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
label_115ac0:
    // 0x115ac0: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115ac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115ac8
// Address: 0x115ac8 - 0x115b14

void entry_115ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115ac8) {
        switch (ctx->pc) {
            case 0x115af8: ctx->pc = 0; goto label_115af8;
            case 0x115b08: ctx->pc = 0; goto label_115b08;
            case 0x115b0c: ctx->pc = 0; goto label_115b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115ac8: 0x1000001e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
    // 0x115ad0: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x115ad4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x115ad8: 0x10620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x115B1C; return;
    }
    // 0x115ae0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_115af8;
    }
    // 0x115ae8: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_115b08;
    }
    // 0x115af0: 0x10000014
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
label_115af8:
    // 0x115af8: 0x5062000e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x115B34; return;
    }
    // 0x115b00: 0x10000010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
label_115b08:
    // 0x115b08: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_115b0c:
    // 0x115b0c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115b14);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115b14
// Address: 0x115b14 - 0x115b2c

void entry_115b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115b14) {
        switch (ctx->pc) {
            case 0x115b1c: ctx->pc = 0; goto label_115b1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115b14: 0x1000000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
label_115b1c:
    // 0x115b1c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115b20: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115b24: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115b2c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115b2c
// Address: 0x115b2c - 0x115b40

void entry_115b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115b2c) {
        switch (ctx->pc) {
            case 0x115b34: ctx->pc = 0; goto label_115b34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115b2c: 0x10000005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115B44; return;
    }
label_115b34:
    // 0x115b34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115b38: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115b40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115b40
// Address: 0x115b40 - 0x115b4c

void entry_115b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115b40) {
        switch (ctx->pc) {
            case 0x115b44: ctx->pc = 0; goto label_115b44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115b40: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_115b44:
    // 0x115b44: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115b4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115b4c
// Address: 0x115b4c - 0x115b58

void entry_115b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115b4c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115b50: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115b58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115b58
// Address: 0x115b58 - 0x115b78

void entry_115b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115b58: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x115b5c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x115b60: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x115b64: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115b68: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115b6c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115b70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpRandomSeed__FiP4CRefP6CFrame
// Address: 0x115b78 - 0x115b98

void entry_115b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115b98: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x115b9c: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x115ba0: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x115BB8; return;
    }
    // 0x115ba8: 0xc07d9be
    SET_GPR_U32(ctx, 31, 0x115bb0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    srand(rdram, ctx, runtime); return;
}


// Function: entry_115bb0
// Address: 0x115bb0 - 0x115bc8

void entry_115bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115bb0) {
        switch (ctx->pc) {
            case 0x115bb8: ctx->pc = 0; goto label_115bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115bb0: 0x10000006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x115BCC; return;
    }
label_115bb8:
    // 0x115bb8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x115bbc: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x115bc0: 0xc07d9be
    SET_GPR_U32(ctx, 31, 0x115bc8);
    srand(rdram, ctx, runtime); return;
}


// Function: entry_115bc8
// Address: 0x115bc8 - 0x115bdc

void entry_115bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115bc8) {
        switch (ctx->pc) {
            case 0x115bcc: ctx->pc = 0; goto label_115bcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115bc8: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
label_115bcc:
    // 0x115bcc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115bd0: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x115bd4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115bdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115bdc
// Address: 0x115bdc - 0x115be8

void entry_115bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115bdc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115be0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115be8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115be8
// Address: 0x115be8 - 0x115c00

void entry_115be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115be8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x115bec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115bf0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115bf4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115bf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpRandom__FiP4CRefP6CFrame
// Address: 0x115c00 - 0x115c20

void entry_115c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115c20) {
        switch (ctx->pc) {
            case 0x115c40: ctx->pc = 0; goto label_115c40;
            case 0x115c48: ctx->pc = 0; goto label_115c48;
            case 0x115c58: ctx->pc = 0; goto label_115c58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115c20: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x115c24: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x115c28: 0x54620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
        goto label_115c40;
    }
    // 0x115c30: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x115c34: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x115c38: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115c48;
    }
label_115c40:
    // 0x115c40: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x115c44: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
label_115c48:
    // 0x115c48: 0x54620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[13] = *(float*)&val; }
        goto label_115c58;
    }
    // 0x115c50: 0xc60d000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[13] = *(float*)&val; }
    // 0x115c54: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
label_115c58:
    // 0x115c58: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x115c60);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_115c60
// Address: 0x115c60 - 0x115c6c

void entry_115c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115c60: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115c64: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115c6c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115c6c
// Address: 0x115c6c - 0x115c78

void entry_115c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115c6c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115c70: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115c78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115c78
// Address: 0x115c78 - 0x115c84

void entry_115c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115c78: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115c7c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115c84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115c84
// Address: 0x115c84 - 0x115ca0

void entry_115c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115c84: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x115c88: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115c8c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115c90: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115c94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x115c9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x115ca0; return;
}


// Function: RefUfo__FP4CRef4UFOK
// Address: 0x115ca0 - 0x115cc8

void entry_115cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115cc8) {
        switch (ctx->pc) {
            case 0x115ce0: ctx->pc = 0; goto label_115ce0;
            case 0x115ce8: ctx->pc = 0; goto label_115ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115cc8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x115ccc: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x115cd0: 0x14620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_115ce0;
    }
    // 0x115cd8: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115ce8;
    }
label_115ce0:
    // 0x115ce0: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x115ce4: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
label_115ce8:
    // 0x115ce8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x115cec: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x115cf0: 0x24429938
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294940984));
    // 0x115cf4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x115cf8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x115cfc: 0x80f809
    SET_GPR_U32(ctx, 31, 0x115d04);
    ctx->pc = GPR_U32(ctx, 4); return;
}


// Function: entry_115d04
// Address: 0x115d04 - 0x115d10

void entry_115d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115d08: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115d10);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115d10
// Address: 0x115d10 - 0x115d1c

void entry_115d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d10: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115d14: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115d1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115d1c
// Address: 0x115d1c - 0x115d28

void entry_115d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d1c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115d20: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115d28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115d28
// Address: 0x115d28 - 0x115d48

void entry_115d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d28: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x115d2c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x115d30: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115d34: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115d38: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115d3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x115d44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x115d48; return;
}


// Function: RefOpSqrt__FiP4CRefP6CFrame
// Address: 0x115d48 - 0x115d64

void entry_115d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d64: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115d68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115d6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115d70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpSin__FiP4CRefP6CFrame
// Address: 0x115d78 - 0x115d94

void entry_115d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115d94: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115d98: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115d9c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115da0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpCos__FiP4CRefP6CFrame
// Address: 0x115da8 - 0x115dc4

void entry_115dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115dc4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115dc8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115dcc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115dd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpTan__FiP4CRefP6CFrame
// Address: 0x115dd8 - 0x115df4

void entry_115df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115df4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115df8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115dfc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115e00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAsin__FiP4CRefP6CFrame
// Address: 0x115e08 - 0x115e24

void entry_115e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115e24: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115e28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115e2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115e30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAcos__FiP4CRefP6CFrame
// Address: 0x115e38 - 0x115e54

void entry_115e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115e54: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115e58: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115e5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115e60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAtan__FiP4CRefP6CFrame
// Address: 0x115e68 - 0x115e84

void entry_115e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115e84: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115e88: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115e8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115e90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpRadNormalize__FiP4CRefP6CFrame
// Address: 0x115e98 - 0x115eb4

void entry_115eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115eb4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x115eb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115ebc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x115ec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAtan2__FiP4CRefP6CFrame
// Address: 0x115ec8 - 0x115ee8

void entry_115ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x115ee8) {
        switch (ctx->pc) {
            case 0x115ef8: ctx->pc = 0; goto label_115ef8;
            case 0x115f0c: ctx->pc = 0; goto label_115f0c;
            case 0x115f14: ctx->pc = 0; goto label_115f14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x115ee8: 0x24050015
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 21));
    // 0x115eec: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x115ef0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x115ef4: 0x0
    // NOP
label_115ef8:
    // 0x115ef8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x115efc: 0x14450003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_115f0c;
    }
    // 0x115f04: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_115f14;
    }
label_115f0c:
    // 0x115f0c: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x115f10: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
label_115f14:
    // 0x115f14: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x115f18: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x115f1c: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x115f20: 0x481fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_115ef8;
    }
    // 0x115f28: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x115f2c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x115f34);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_115f34
// Address: 0x115f34 - 0x115f40

void entry_115f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115f34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115f38: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115f40);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115f40
// Address: 0x115f40 - 0x115f4c

void entry_115f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115f40: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115f44: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115f4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115f4c
// Address: 0x115f4c - 0x115f58

void entry_115f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115f4c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115f50: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115f58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115f58
// Address: 0x115f58 - 0x115f70

void entry_115f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115f58: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x115f5c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x115f60: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115f64: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115f68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVectorDotProduct__FiP4CRefP6CFrame
// Address: 0x115f70 - 0x115f90

void entry_115f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115f90: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x115f94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115f98: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x115f9c: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x115fa0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x115fa4: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x115fa8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x115fac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x115fb0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x115fb4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x115fb8: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x115fbc: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x115fc4);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_115fc4
// Address: 0x115fc4 - 0x115fd0

void entry_115fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115fc4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115fc8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x115fd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_115fd0
// Address: 0x115fd0 - 0x115fdc

void entry_115fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115fd0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x115fd4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x115fdc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_115fdc
// Address: 0x115fdc - 0x115ff8

void entry_115fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x115fdc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x115fe0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x115fe4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x115fe8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x115fec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x115ff4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x115ff8; return;
}


// Function: RefOpVectorCrossProduct__FiP4CRefP6CFrame
// Address: 0x115ff8 - 0x116018

void entry_116018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116018: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116020);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116020
// Address: 0x116020 - 0x11604c

void entry_116020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116020: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x116024: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116028: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11602c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116030: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x116034: 0xd8c10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x116038: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x11603c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116040: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116044: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x11604c);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11604c
// Address: 0x11604c - 0x116058

void entry_11604c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11604c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116050: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116058);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116058
// Address: 0x116058 - 0x116064

void entry_116058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116058: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11605c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116064);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116064
// Address: 0x116064 - 0x116080

void entry_116064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116064: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x116068: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11606c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116070: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116074: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11607c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116080; return;
}


// Function: RefOpVectorLth__FiP4CRefP6CFrame
// Address: 0x116080 - 0x1160a0

void entry_1160a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1160a0: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1160a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1160a8: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1160ac: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1160b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1160b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1160b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1160bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1160c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1160c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1160c8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1160cc: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1160d0: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1160d8);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1160d8
// Address: 0x1160d8 - 0x1160e4

void entry_1160d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1160d8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1160dc: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1160e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1160e4
// Address: 0x1160e4 - 0x1160f0

void entry_1160e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1160e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1160e8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1160f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1160f0
// Address: 0x1160f0 - 0x116108

void entry_1160f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1160f0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1160f4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1160f8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1160fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVectorDistance__FiP4CRefP6CFrame
// Address: 0x116108 - 0x116128

void entry_116128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116128: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x11612c: 0x54600015
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x116184; return;
    }
    // 0x116134: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116138: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x11613c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x116140: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116144: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116148: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11614c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116150: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116154: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x116158: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11615c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116160: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116164: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x116168: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x11616c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x116170: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x116174: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11617c);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11617c
// Address: 0x11617c - 0x1161c8

void entry_11617c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11617c) {
        switch (ctx->pc) {
            case 0x116184: ctx->pc = 0; goto label_116184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11617c: 0x10000013
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1161CC; return;
    }
label_116184:
    // 0x116184: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116188: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11618c: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x116190: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116194: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x116198: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11619c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1161a0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1161a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1161a8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1161ac: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1161b0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1161b4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1161b8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1161bc: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1161c0: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1161c8);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1161c8
// Address: 0x1161c8 - 0x1161d4

void entry_1161c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1161c8) {
        switch (ctx->pc) {
            case 0x1161cc: ctx->pc = 0; goto label_1161cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1161c8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1161cc:
    // 0x1161cc: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1161d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1161d4
// Address: 0x1161d4 - 0x1161e0

void entry_1161d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1161d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1161d8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1161e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1161e0
// Address: 0x1161e0 - 0x1161f8

void entry_1161e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1161e0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1161e4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1161e8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1161ec: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1161f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVectorDistanceSquared__FiP4CRefP6CFrame
// Address: 0x1161f8 - 0x116218

void entry_116218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116218: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x11621c: 0x54600012
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x116268; return;
    }
    // 0x116224: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116228: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x11622c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x116230: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116234: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116238: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11623c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116240: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116244: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x116248: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11624c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116250: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x116254: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x116258: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x116260);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_116260
// Address: 0x116260 - 0x1162a0

void entry_116260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x116260) {
        switch (ctx->pc) {
            case 0x116268: ctx->pc = 0; goto label_116268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x116260: 0x10000010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1162A4; return;
    }
label_116268:
    // 0x116268: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11626c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116270: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x116274: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116278: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11627c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116280: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116284: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x116288: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11628c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116290: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x116294: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x116298: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1162a0);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1162a0
// Address: 0x1162a0 - 0x1162ac

void entry_1162a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1162a0) {
        switch (ctx->pc) {
            case 0x1162a4: ctx->pc = 0; goto label_1162a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1162a0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1162a4:
    // 0x1162a4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1162ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1162ac
// Address: 0x1162ac - 0x1162b8

void entry_1162ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1162ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1162b0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1162b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1162b8
// Address: 0x1162b8 - 0x1162d0

void entry_1162b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1162b8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1162bc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1162c0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1162c4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1162c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVectorNormalize__FiP4CRefP6CFrame
// Address: 0x1162d0 - 0x1162f0

void entry_1162f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1162f0: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1162f8);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1162f8
// Address: 0x1162f8 - 0x1163cc

void entry_1162f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1162f8) {
        switch (ctx->pc) {
            case 0x116364: ctx->pc = 0; goto label_116364;
            case 0x1163ac: ctx->pc = 0; goto label_1163ac;
            case 0x1163b4: ctx->pc = 0; goto label_1163b4;
            case 0x1163c4: ctx->pc = 0; goto label_1163c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1162f8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1162fc: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116300: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116304: 0xf8a30000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x116308: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x11630c: 0x14400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_116364;
    }
    // 0x116314: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x116318: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x11631c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116320: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116324: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x116328: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x11632c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x116330: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116334: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x116338: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x11633c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x116340: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x116344: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x116348: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x11634c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x116350: 0x0
    // NOP
    // 0x116354: 0x45030015
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
        goto label_1163ac;
    }
    // 0x11635c: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1163b4;
    }
label_116364:
    // 0x116364: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x116368: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x11636c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116370: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116374: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x116378: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x11637c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x116380: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116384: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x116388: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x11638c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x116390: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x116394: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x116398: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11639c: 0x0
    // NOP
    // 0x1163a0: 0x45000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1163b4;
    }
    // 0x1163a8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
label_1163ac:
    // 0x1163ac: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1163c4;
    }
label_1163b4:
    // 0x1163b4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1163b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1163bc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1163c0: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1163c4:
    // 0x1163c4: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1163cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1163cc
// Address: 0x1163cc - 0x1163d8

void entry_1163cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1163cc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1163d0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1163d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1163d8
// Address: 0x1163d8 - 0x1163e4

void entry_1163d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1163d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1163dc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1163e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1163e4
// Address: 0x1163e4 - 0x116400

void entry_1163e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1163e4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1163e8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1163ec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1163f0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1163f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1163fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116400; return;
}


// Function: RefOpVectorProjectNormal__FiP4CRefP6CFrame
// Address: 0x116400 - 0x116420

void entry_116420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116420: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116428);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116428
// Address: 0x116428 - 0x11645c

void entry_116428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116428: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x11642c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116430: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116434: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116438: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11643c: 0xd8c10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x116440: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116444: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x116448: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11644c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x116450: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x116454: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x11645c);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11645c
// Address: 0x11645c - 0x116468

void entry_11645c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11645c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116460: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116468);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116468
// Address: 0x116468 - 0x116474

void entry_116468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116468: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11646c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116474);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116474
// Address: 0x116474 - 0x116490

void entry_116474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116474: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x116478: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11647c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116480: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116484: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11648c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116490; return;
}


// Function: RefOpVectorProjectTangent__FiP4CRefP6CFrame
// Address: 0x116490 - 0x1164b0

void entry_1164b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1164b0: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1164b8);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1164b8
// Address: 0x1164b8 - 0x1164f0

void entry_1164b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1164b8: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1164bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1164c0: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1164c4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1164c8: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1164cc: 0xd8c20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1164d0: 0x4bc3106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1164d4: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1164d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1164dc: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1164e0: 0x4be11858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1164e4: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1164e8: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1164f0);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1164f0
// Address: 0x1164f0 - 0x1164fc

void entry_1164f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1164f0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1164f4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1164fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1164fc
// Address: 0x1164fc - 0x116508

void entry_1164fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1164fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116500: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116508);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116508
// Address: 0x116508 - 0x116520

void entry_116508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116508: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11650c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116510: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116514: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpVectorBallisticVelocity__FiP4CRefP6CFrame
// Address: 0x116520 - 0x116550

void entry_116550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116550: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116558);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116558
// Address: 0x116558 - 0x11658c

void entry_116558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x116558) {
        switch (ctx->pc) {
            case 0x116570: ctx->pc = 0; goto label_116570;
            case 0x116574: ctx->pc = 0; goto label_116574;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x116558: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11655c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x116560: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        goto label_116570;
    }
    // 0x116568: 0x10000002
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_116574;
    }
label_116570:
    // 0x116570: 0x8c530004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_116574:
    // 0x116574: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116578: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11657c: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x116580: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116584: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x11658c);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11658c
// Address: 0x11658c - 0x1165a4

void entry_11658c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11658c: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x116590: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116594: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116598: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11659c: 0xc07b7bc
    SET_GPR_U32(ctx, 31, 0x1165a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FCalculateMuzzleVelocity__FP6VECTORT0fT0P2SO(rdram, ctx, runtime); return;
}


// Function: entry_1165a4
// Address: 0x1165a4 - 0x1165b0

void entry_1165a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1165a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1165a8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1165b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1165b0
// Address: 0x1165b0 - 0x1165bc

void entry_1165b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1165b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1165b4: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1165bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1165bc
// Address: 0x1165bc - 0x1165c8

void entry_1165bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1165bc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1165c0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1165c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1165c8
// Address: 0x1165c8 - 0x1165d4

void entry_1165c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1165c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1165cc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1165d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1165d4
// Address: 0x1165d4 - 0x116600

void entry_1165d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1165d4: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1165d8: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1165dc: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1165e0: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1165e4: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1165e8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1165ec: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1165f0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1165f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1165fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116600; return;
}


// Function: RefOpVectorRadianNormal__FiP4CRefP6CFrame
// Address: 0x116600 - 0x11662c

void entry_11662c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11662c: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x116634);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116634
// Address: 0x116634 - 0x11663c

void entry_116634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116634: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x11663c);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11663c
// Address: 0x11663c - 0x116648

void entry_11663c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11663c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116640: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116648);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 16));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116648
// Address: 0x116648 - 0x116658

void entry_116648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116648: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11664c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116650: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x116658);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_116658
// Address: 0x116658 - 0x116668

void entry_116658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116658: 0x8e65000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x11665c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x116660: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x116668);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_116668
// Address: 0x116668 - 0x116674

void entry_116668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116668: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x11666c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x116674);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_116674
// Address: 0x116674 - 0x116680

void entry_116674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116674: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116678: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x116680);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_116680
// Address: 0x116680 - 0x11668c

void entry_116680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116680: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116684: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11668c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11668c
// Address: 0x11668c - 0x116698

void entry_11668c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11668c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116690: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116698);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116698
// Address: 0x116698 - 0x1166c0

void entry_116698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116698: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11669c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1166a0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1166a4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1166a8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1166ac: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1166b0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1166b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1166bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1166c0; return;
}


// Function: RefOpMatrixTranspose__FiP4CRefP6CFrame
// Address: 0x1166c0 - 0x1166e4

void entry_1166e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1166e4: 0xc047186
    SET_GPR_U32(ctx, 31, 0x1166ec);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1166ec
// Address: 0x1166ec - 0x1166fc

void entry_1166ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1166ec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1166f0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1166f4: 0xc0621dc
    SET_GPR_U32(ctx, 31, 0x1166fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    TransposeMatrix4__FP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1166fc
// Address: 0x1166fc - 0x116708

void entry_1166fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1166fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116700: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116708);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116708
// Address: 0x116708 - 0x116714

void entry_116708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116708: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11670c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116714);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116714
// Address: 0x116714 - 0x116720

void entry_116714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116714: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116718: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116720);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116720
// Address: 0x116720 - 0x116740

void entry_116720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116720: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116724: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116728: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11672c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116730: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11673c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116740; return;
}


// Function: RefOpMatrixInvert__FiP4CRefP6CFrame
// Address: 0x116740 - 0x116764

void entry_116764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116764: 0xc047186
    SET_GPR_U32(ctx, 31, 0x11676c);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11676c
// Address: 0x11676c - 0x11677c

void entry_11676c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11676c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116770: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x116774: 0xc0626bc
    SET_GPR_U32(ctx, 31, 0x11677c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FInvertMatrix4__FP7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_11677c
// Address: 0x11677c - 0x116788

void entry_11677c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11677c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116780: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116788);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116788
// Address: 0x116788 - 0x116794

void entry_116788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116788: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11678c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116794);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116794
// Address: 0x116794 - 0x1167a0

void entry_116794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116794: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116798: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1167a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1167a0
// Address: 0x1167a0 - 0x1167c0

void entry_1167a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1167a0: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1167a4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1167a8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1167ac: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1167b0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1167b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1167bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1167c0; return;
}


// Function: RefOpMatrixCalculateDmat__FiP4CRefP6CFrame
// Address: 0x1167c0 - 0x1167e4

void entry_1167e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1167e4: 0xc047186
    SET_GPR_U32(ctx, 31, 0x1167ec);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1167ec
// Address: 0x1167ec - 0x116800

void entry_1167ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1167ec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1167f0: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1167f4: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1167f8: 0xc062470
    SET_GPR_U32(ctx, 31, 0x116800);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat4__FP7MATRIX4N20(rdram, ctx, runtime); return;
}


// Function: entry_116800
// Address: 0x116800 - 0x11680c

void entry_116800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116800: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116804: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x11680c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11680c
// Address: 0x11680c - 0x116818

void entry_11680c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11680c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116810: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116818);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116818
// Address: 0x116818 - 0x116824

void entry_116818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116818: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11681c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116824);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116824
// Address: 0x116824 - 0x116840

void entry_116824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116824: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116828: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11682c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116830: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116834: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116838: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMatrixInterpolateRotate__FiP4CRefP6CFrame
// Address: 0x116840 - 0x11686c

void entry_11686c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11686c: 0xc047186
    SET_GPR_U32(ctx, 31, 0x116874);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116874
// Address: 0x116874 - 0x11688c

void entry_116874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116874: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116878: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11687c: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x116880: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116884: 0xc062454
    SET_GPR_U32(ctx, 31, 0x11688c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_11688c
// Address: 0x11688c - 0x1168a0

void entry_11688c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11688c: 0x27b20040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 64));
    // 0x116890: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x116894: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116898: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1168a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1168a0
// Address: 0x1168a0 - 0x1168b8

void entry_1168a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1168a0: 0xc7a000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    // 0x1168a4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1168a8: 0xc62c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1168ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1168b0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1168b8);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1168b8
// Address: 0x1168b8 - 0x11692c

void entry_1168b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1168b8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1168bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1168c0: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1168c4: 0xd8450000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1168c8: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1168cc: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1168d0: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1168d4: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1168d8: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1168dc: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1168e0: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1168e4: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1168e8: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1168ec: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1168f0: 0x4bc1204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1168f4: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1168f8: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1168fc: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x116900: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x116904: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x116908: 0x4bc220ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x11690c: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x116910: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x116914: 0xfa650000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x116918: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11691c: 0x7e620010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 2));
    // 0x116920: 0x7ba30070
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x116924: 0xc062130
    SET_GPR_U32(ctx, 31, 0x11692c);
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), GPR_VEC(ctx, 3));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11692c
// Address: 0x11692c - 0x116938

void entry_11692c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11692c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116930: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116938);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116938
// Address: 0x116938 - 0x116944

void entry_116938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116938: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11693c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116944);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116944
// Address: 0x116944 - 0x116950

void entry_116944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116944: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116948: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116950);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116950
// Address: 0x116950 - 0x116978

void entry_116950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116950: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116954: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x116958: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x11695c: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x116960: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x116964: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x116968: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x11696c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x116974: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116978; return;
}


// Function: RefOpMatrixDecomposeToTranslate__FiP4CRefP6CFrame
// Address: 0x116978 - 0x116998

void entry_116998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116998: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1169a0);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1169a0
// Address: 0x1169a0 - 0x1169b8

void entry_1169a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1169a0: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1169a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1169a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1169ac: 0x78c30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 6), 48)));
    // 0x1169b0: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1169b8);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1169b8
// Address: 0x1169b8 - 0x1169c4

void entry_1169b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1169b8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1169bc: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1169c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1169c4
// Address: 0x1169c4 - 0x1169d0

void entry_1169c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1169c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1169c8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1169d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1169d0
// Address: 0x1169d0 - 0x1169e8

void entry_1169d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1169d0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1169d4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1169d8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1169dc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1169e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMatrixDecomposeToRotate__FiP4CRefP6CFrame
// Address: 0x1169e8 - 0x116a0c

void entry_116a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a0c: 0xc047186
    SET_GPR_U32(ctx, 31, 0x116a14);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116a14
// Address: 0x116a14 - 0x116a44

void entry_116a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a14: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x116a18: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116a1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116a20: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x116a24: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x116a28: 0x78a30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x116a2c: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x116a30: 0x78a20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x116a34: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x116a38: 0x78a30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 48)));
    // 0x116a3c: 0xc062130
    SET_GPR_U32(ctx, 31, 0x116a44);
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116a44
// Address: 0x116a44 - 0x116a50

void entry_116a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a44: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116a48: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116a50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116a50
// Address: 0x116a50 - 0x116a5c

void entry_116a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a50: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116a54: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116a5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116a5c
// Address: 0x116a5c - 0x116a68

void entry_116a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116a60: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116a68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116a68
// Address: 0x116a68 - 0x116a88

void entry_116a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116a68: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116a6c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116a70: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116a74: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116a78: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116a7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x116a84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116a88; return;
}


// Function: RefOpMatrixDecomposeToEuler__FiP4CRefP6CFrame
// Address: 0x116a88 - 0x116aac

void entry_116aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116aac: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116ab4);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116ab4
// Address: 0x116ab4 - 0x116ac4

void entry_116ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ab4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116ab8: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x116abc: 0xc0623f6
    SET_GPR_U32(ctx, 31, 0x116ac4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixEuler__FP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_116ac4
// Address: 0x116ac4 - 0x116ad0

void entry_116ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ac4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116ac8: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x116ad0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_116ad0
// Address: 0x116ad0 - 0x116adc

void entry_116ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ad0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116ad4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116adc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116adc
// Address: 0x116adc - 0x116ae8

void entry_116adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116adc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116ae0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116ae8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116ae8
// Address: 0x116ae8 - 0x116b08

void entry_116ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ae8: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116aec: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116af0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116af4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116af8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x116afc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x116b04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116b08; return;
}


// Function: RefOpMatrixDecomposeToRadianNormal__FiP4CRefP6CFrame
// Address: 0x116b08 - 0x116b34

void entry_116b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b34: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x116b3c);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116b3c
// Address: 0x116b3c - 0x116b44

void entry_116b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b3c: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x116b44);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116b44
// Address: 0x116b44 - 0x116b4c

void entry_116b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b44: 0xc047142
    SET_GPR_U32(ctx, 31, 0x116b4c);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116b4c
// Address: 0x116b4c - 0x116b5c

void entry_116b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b4c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116b50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116b54: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x116b5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_116b5c
// Address: 0x116b5c - 0x116b70

void entry_116b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b5c: 0xae320008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 18));
    // 0x116b60: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116b64: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116b68: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x116b70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_116b70
// Address: 0x116b70 - 0x116b7c

void entry_116b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b70: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x116b74: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x116b7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_116b7c
// Address: 0x116b7c - 0x116b88

void entry_116b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b7c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116b80: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x116b88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_116b88
// Address: 0x116b88 - 0x116b94

void entry_116b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b88: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116b8c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116b94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116b94
// Address: 0x116b94 - 0x116ba0

void entry_116b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116b94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116b98: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116ba0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116ba0
// Address: 0x116ba0 - 0x116bc8

void entry_116ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ba0: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116ba4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x116ba8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x116bac: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116bb0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116bb4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116bb8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116bbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x116bc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116bc8; return;
}


// Function: RefOpMatrixLookAt__FiP4CRefP6CFrame
// Address: 0x116bc8 - 0x116bec

void entry_116bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x116bec) {
        switch (ctx->pc) {
            case 0x116c04: ctx->pc = 0; goto label_116c04;
            case 0x116c08: ctx->pc = 0; goto label_116c08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x116bec: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x116bf0: 0x54600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_116c04;
    }
    // 0x116bf8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x116bfc: 0x10000002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294937888));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_116c08;
    }
label_116c04:
    // 0x116c04: 0x8c510004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_116c08:
    // 0x116c08: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x116c0c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116c10: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x116c14: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x116c18: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x116c1c: 0xc047186
    SET_GPR_U32(ctx, 31, 0x116c24);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116c24
// Address: 0x116c24 - 0x116c38

void entry_116c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c24: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116c28: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116c2c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116c30: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x116c38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_116c38
// Address: 0x116c38 - 0x116c40

void entry_116c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c38: 0xc062130
    SET_GPR_U32(ctx, 31, 0x116c40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116c40
// Address: 0x116c40 - 0x116c4c

void entry_116c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116c44: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116c4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116c4c
// Address: 0x116c4c - 0x116c58

void entry_116c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c4c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116c50: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116c58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116c58
// Address: 0x116c58 - 0x116c64

void entry_116c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c58: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116c5c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116c64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116c64
// Address: 0x116c64 - 0x116c80

void entry_116c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116c64: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116c68: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116c6c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116c70: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116c74: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116c78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMatrixTiltUpright__FiP4CRefP6CFrame
// Address: 0x116c80 - 0x116ca8

void entry_116ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ca8: 0xc047186
    SET_GPR_U32(ctx, 31, 0x116cb0);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116cb0
// Address: 0x116cb0 - 0x116cc8

void entry_116cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116cb0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116cb4: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x116cb8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116cbc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116cc0: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x116cc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_116cc8
// Address: 0x116cc8 - 0x116cdc

void entry_116cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116cc8: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x116ccc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x116cd0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x116cd4: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x116cdc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 48));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116cdc
// Address: 0x116cdc - 0x116ce8

void entry_116cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116cdc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116ce0: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x116ce8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_116ce8
// Address: 0x116ce8 - 0x116cf4

void entry_116ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ce8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116cec: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116cf4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116cf4
// Address: 0x116cf4 - 0x116d00

void entry_116cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116cf4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116cf8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116d00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116d00
// Address: 0x116d00 - 0x116d20

void entry_116d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d00: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116d04: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x116d08: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x116d0c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x116d10: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116d14: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116d18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpClqEvaluate__FiP4CRefP6CFrame
// Address: 0x116d20 - 0x116d48

void entry_116d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d48: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116d4c: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x116d50: 0x26250008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    // 0x116d54: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116d5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116d5c
// Address: 0x116d5c - 0x116d84

void entry_116d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d5c: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x116d60: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116d64: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x116d68: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x116d6c: 0x46006002
    ctx->f[0] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x116d70: 0xc6020000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[2] = *(float*)&val; }
    // 0x116d74: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x116d78: 0x46016302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x116d7c: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x116d84);
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[12]);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_116d84
// Address: 0x116d84 - 0x116d90

void entry_116d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d84: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116d88: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116d90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116d90
// Address: 0x116d90 - 0x116d9c

void entry_116d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d90: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116d94: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116d9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116d9c
// Address: 0x116d9c - 0x116da8

void entry_116d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116d9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116da0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116da8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116da8
// Address: 0x116da8 - 0x116dc8

void entry_116da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116da8: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116dac: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x116db0: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116db4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116db8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116dbc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116dc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpClqEvaluateLm__FiP4CRefP6CFrame
// Address: 0x116dc8 - 0x116df4

void entry_116df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116df4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116df8: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x116dfc: 0x8e12000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x116e00: 0x26050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    // 0x116e04: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116e0c);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116e0c
// Address: 0x116e0c - 0x116e60

void entry_116e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x116e0c) {
        switch (ctx->pc) {
            case 0x116e48: ctx->pc = 0; goto label_116e48;
            case 0x116e58: ctx->pc = 0; goto label_116e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x116e0c: 0xc7a20014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[2] = *(float*)&val; }
    // 0x116e10: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x116e14: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x116e18: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x116e1c: 0xc6230000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[3] = *(float*)&val; }
    // 0x116e20: 0xc6440000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[4] = *(float*)&val; }
    // 0x116e24: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x116e28: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x116e2c: 0x46021b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x116e30: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x116e34: 0x0
    // NOP
    // 0x116e38: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_116e48;
    }
    // 0x116e40: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_116e58;
    }
label_116e48:
    // 0x116e48: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x116e4c: 0x0
    // NOP
    // 0x116e50: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[5]);
        goto label_116e58;
    }
label_116e58:
    // 0x116e58: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x116e60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_116e60
// Address: 0x116e60 - 0x116e6c

void entry_116e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116e60: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116e64: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116e6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116e6c
// Address: 0x116e6c - 0x116e78

void entry_116e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116e6c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116e70: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116e78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116e78
// Address: 0x116e78 - 0x116e84

void entry_116e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116e78: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116e7c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116e84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116e84
// Address: 0x116e84 - 0x116ea8

void entry_116e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116e84: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116e88: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x116e8c: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x116e90: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116e94: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x116e98: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x116e9c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x116ea0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpClqFit__FiP4CRefP6CFrame
// Address: 0x116ea8 - 0x116ee8

void entry_116ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ee8: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x116ef0);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_116ef0
// Address: 0x116ef0 - 0x116f04

void entry_116ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116ef0: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x116ef4: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x116ef8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116efc: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116f04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116f04
// Address: 0x116f04 - 0x116f18

void entry_116f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f04: 0x27b30020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 32));
    // 0x116f08: 0xc7b60014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[22] = *(float*)&val; }
    // 0x116f0c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116f10: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116f18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116f18
// Address: 0x116f18 - 0x116f2c

void entry_116f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f18: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x116f1c: 0xc7b50024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[21] = *(float*)&val; }
    // 0x116f20: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116f24: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116f2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116f2c
// Address: 0x116f2c - 0x116f40

void entry_116f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f2c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x116f30: 0xc7b40034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[20] = *(float*)&val; }
    // 0x116f34: 0x26050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 24));
    // 0x116f38: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x116f40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116f40
// Address: 0x116f40 - 0x116f58

void entry_116f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f40: 0xc7af0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[15] = *(float*)&val; }
    // 0x116f44: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x116f48: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x116f4c: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x116f50: 0xc07ac06
    SET_GPR_U32(ctx, 31, 0x116f58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FitClq__FffffP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_116f58
// Address: 0x116f58 - 0x116f64

void entry_116f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f58: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x116f5c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116f64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116f64
// Address: 0x116f64 - 0x116f70

void entry_116f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f64: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x116f68: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116f70);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116f70
// Address: 0x116f70 - 0x116f7c

void entry_116f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f70: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x116f74: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116f7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116f7c
// Address: 0x116f7c - 0x116f88

void entry_116f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f7c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x116f80: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116f88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116f88
// Address: 0x116f88 - 0x116f94

void entry_116f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116f8c: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x116f94);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_116f94
// Address: 0x116f94 - 0x116fa0

void entry_116f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116f94: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116f98: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x116fa0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_116fa0
// Address: 0x116fa0 - 0x116fac

void entry_116fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116fa0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x116fa4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x116fac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_116fac
// Address: 0x116fac - 0x116fe8

void entry_116fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x116fac: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x116fb0: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x116fb4: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x116fb8: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x116fbc: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x116fc0: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x116fc4: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x116fc8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x116fcc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x116fd0: 0xc7b600e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    // 0x116fd4: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x116fd8: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x116fdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x116fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x116fe8; return;
}


// Function: RefOpLmLimit__FiP4CRefP6CFrame
// Address: 0x116fe8 - 0x117010

void entry_117010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117010: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117014: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x117018: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11701c: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x117024);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117024
// Address: 0x117024 - 0x117030

void entry_117024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117024: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x117028: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x117030);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_117030
// Address: 0x117030 - 0x11703c

void entry_117030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117030: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117034: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11703c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11703c
// Address: 0x11703c - 0x117048

void entry_11703c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11703c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117040: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117048);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117048
// Address: 0x117048 - 0x117054

void entry_117048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117048: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11704c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117054);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117054
// Address: 0x117054 - 0x117060

void entry_117054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117054: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117058: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117060);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117060
// Address: 0x117060 - 0x117080

void entry_117060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117060: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x117064: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x117068: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11706c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117070: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117074: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117078: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpLmCheck__FiP4CRefP6CFrame
// Address: 0x117080 - 0x1170a8

void entry_1170a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170a8: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1170ac: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1170b0: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1170b4: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1170bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1170bc
// Address: 0x1170bc - 0x1170c8

void entry_1170bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170bc: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1170c0: 0xc07ac14
    SET_GPR_U32(ctx, 31, 0x1170c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1170c8
// Address: 0x1170c8 - 0x1170d4

void entry_1170c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1170cc: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1170d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1170d4
// Address: 0x1170d4 - 0x1170e0

void entry_1170d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1170d8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1170e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1170e0
// Address: 0x1170e0 - 0x1170ec

void entry_1170e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1170e4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1170ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1170ec
// Address: 0x1170ec - 0x1170f8

void entry_1170ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1170f0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1170f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1170f8
// Address: 0x1170f8 - 0x117118

void entry_1170f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1170f8: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1170fc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x117100: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x117104: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117108: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11710c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117110: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFloor__FiP4CRefP6CFrame
// Address: 0x117118 - 0x117138

void entry_117138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117138: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11713c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x117140: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x117144: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11714c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11714c
// Address: 0x11714c - 0x117158

void entry_11714c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11714c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117150: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117158);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117158
// Address: 0x117158 - 0x117164

void entry_117158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117158: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11715c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117164);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117164
// Address: 0x117164 - 0x117180

void entry_117164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117164: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117168: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11716c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117170: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117174: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11717c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117180; return;
}


// Function: RefOpCeiling__FiP4CRefP6CFrame
// Address: 0x117180 - 0x1171a0

void entry_1171a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1171a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1171a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1171a8: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1171ac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1171b0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1171b4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1171b8: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1171c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1171c0
// Address: 0x1171c0 - 0x1171cc

void entry_1171c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1171c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1171c4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1171cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1171cc
// Address: 0x1171cc - 0x1171d8

void entry_1171cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1171cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1171d0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1171d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1171d8
// Address: 0x1171d8 - 0x1171f0

void entry_1171d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1171d8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1171dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1171e0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1171e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1171e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpRound__FiP4CRefP6CFrame
// Address: 0x1171f0 - 0x117210

void entry_117210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117210: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x117214: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x117218: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11721c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x117220: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x117224: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x117228: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x117230);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_117230
// Address: 0x117230 - 0x11723c

void entry_117230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117230: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117234: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11723c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11723c
// Address: 0x11723c - 0x117248

void entry_11723c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11723c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117240: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117248);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117248
// Address: 0x117248 - 0x117260

void entry_117248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117248: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11724c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117250: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117254: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117258: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpTruncate__FiP4CRefP6CFrame
// Address: 0x117260 - 0x117280

void entry_117280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117280: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x117284: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x117288: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x11728c: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x117294);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_117294
// Address: 0x117294 - 0x1172a0

void entry_117294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117294: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117298: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1172a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1172a0
// Address: 0x1172a0 - 0x1172ac

void entry_1172a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1172a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1172a4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1172ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1172ac
// Address: 0x1172ac - 0x1172c8

void entry_1172ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1172ac: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1172b0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1172b4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1172b8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1172bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1172c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1172c8; return;
}


// Function: RefOpAbs__FiP4CRefP6CFrame
// Address: 0x1172c8 - 0x1172e8

void entry_1172e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1172e8) {
        switch (ctx->pc) {
            case 0x117304: ctx->pc = 0; goto label_117304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1172e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1172ec: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1172f0: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x117314; return;
    }
    // 0x1172f8: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1172fc: 0x4a20001
    if (GPR_S32(ctx, 5) < 0) {
        SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
        goto label_117304;
    }
label_117304:
    // 0x117304: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11730c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11730c
// Address: 0x11730c - 0x117330

void entry_11730c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11730c) {
        switch (ctx->pc) {
            case 0x117314: ctx->pc = 0; goto label_117314;
            case 0x117328: ctx->pc = 0; goto label_117328;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11730c: 0x10000009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117334; return;
    }
label_117314:
    // 0x117314: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x117318: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11731c: 0x0
    // NOP
    // 0x117320: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_NEG_S(ctx->f[12]);
        goto label_117328;
    }
label_117328:
    // 0x117328: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x117330);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_117330
// Address: 0x117330 - 0x11733c

void entry_117330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117330) {
        switch (ctx->pc) {
            case 0x117334: ctx->pc = 0; goto label_117334;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117330: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_117334:
    // 0x117334: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11733c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11733c
// Address: 0x11733c - 0x117348

void entry_11733c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11733c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117340: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117348);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117348
// Address: 0x117348 - 0x117360

void entry_117348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117348: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11734c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117350: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117354: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117358: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMaximum__FiP4CRefP6CFrame
// Address: 0x117360 - 0x117384

void entry_117384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117384: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117388: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117390);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117390
// Address: 0x117390 - 0x117414

void entry_117390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117390) {
        switch (ctx->pc) {
            case 0x1173a0: ctx->pc = 0; goto label_1173a0;
            case 0x1173b0: ctx->pc = 0; goto label_1173b0;
            case 0x1173d8: ctx->pc = 0; goto label_1173d8;
            case 0x1173e8: ctx->pc = 0; goto label_1173e8;
            case 0x1173fc: ctx->pc = 0; goto label_1173fc;
            case 0x11740c: ctx->pc = 0; goto label_11740c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117390: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x117394: 0x54600002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_1173a0;
    }
    // 0x11739c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1173a0:
    // 0x1173a0: 0x12000028
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117444; return;
    }
    // 0x1173a8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1173ac: 0x0
    // NOP
label_1173b0:
    // 0x1173b0: 0x1451000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_1173e8;
    }
    // 0x1173b8: 0x14510007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_1173d8;
    }
    // 0x1173c0: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1173c4: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1173c8: 0x1040001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_117438(rdram, ctx, runtime); return;
    }
    // 0x1173d0: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11740c;
    }
label_1173d8:
    // 0x1173d8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1173dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1173e0: 0x10000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1173fc;
    }
label_1173e8:
    // 0x1173e8: 0x5451000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x11741C; return;
    }
    // 0x1173f0: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1173f4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1173f8: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
label_1173fc:
    // 0x1173fc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x117400: 0x0
    // NOP
    // 0x117404: 0x4500000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_117438(rdram, ctx, runtime); return;
    }
label_11740c:
    // 0x11740c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117414);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117414
// Address: 0x117414 - 0x117438

void entry_117414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117414) {
        switch (ctx->pc) {
            case 0x11741c: ctx->pc = 0; goto label_11741c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117414: 0x10000009
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11743C; return;
    }
label_11741c:
    // 0x11741c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x117420: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x117424: 0x0
    // NOP
    // 0x117428: 0x45000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_117438(rdram, ctx, runtime); return;
    }
    // 0x117430: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117438);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117438
// Address: 0x117438 - 0x117450

void entry_117438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117438) {
        switch (ctx->pc) {
            case 0x11743c: ctx->pc = 0; goto label_11743c;
            case 0x117444: ctx->pc = 0; goto label_117444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117438: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_11743c:
    // 0x11743c: 0x1600ffdc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1173B0; return;
    }
label_117444:
    // 0x117444: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117448: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117450);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117450
// Address: 0x117450 - 0x11745c

void entry_117450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117450: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117454: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11745c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11745c
// Address: 0x11745c - 0x117478

void entry_11745c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11745c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117460: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117464: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117468: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11746c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117470: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpMinimum__FiP4CRefP6CFrame
// Address: 0x117478 - 0x11749c

void entry_11749c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11749c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1174a0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1174a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1174a8
// Address: 0x1174a8 - 0x117530

void entry_1174a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1174a8) {
        switch (ctx->pc) {
            case 0x1174b8: ctx->pc = 0; goto label_1174b8;
            case 0x1174c8: ctx->pc = 0; goto label_1174c8;
            case 0x1174f4: ctx->pc = 0; goto label_1174f4;
            case 0x117504: ctx->pc = 0; goto label_117504;
            case 0x117518: ctx->pc = 0; goto label_117518;
            case 0x117528: ctx->pc = 0; goto label_117528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1174a8: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1174ac: 0x54600002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        goto label_1174b8;
    }
    // 0x1174b4: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1174b8:
    // 0x1174b8: 0x12000029
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117560; return;
    }
    // 0x1174c0: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1174c4: 0x0
    // NOP
label_1174c8:
    // 0x1174c8: 0x1451000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_117504;
    }
    // 0x1174d0: 0x14510008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        goto label_1174f4;
    }
    // 0x1174d8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1174dc: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1174e0: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1174e4: 0x1040001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_117554(rdram, ctx, runtime); return;
    }
    // 0x1174ec: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_117528;
    }
label_1174f4:
    // 0x1174f4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1174f8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1174fc: 0x10000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_117518;
    }
label_117504:
    // 0x117504: 0x5451000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x117538; return;
    }
    // 0x11750c: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x117510: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x117514: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
label_117518:
    // 0x117518: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11751c: 0x0
    // NOP
    // 0x117520: 0x4500000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_117554(rdram, ctx, runtime); return;
    }
label_117528:
    // 0x117528: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117530);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117530
// Address: 0x117530 - 0x117554

void entry_117530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117530) {
        switch (ctx->pc) {
            case 0x117538: ctx->pc = 0; goto label_117538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117530: 0x10000009
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117558; return;
    }
label_117538:
    // 0x117538: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11753c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x117540: 0x0
    // NOP
    // 0x117544: 0x45000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_117554(rdram, ctx, runtime); return;
    }
    // 0x11754c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117554);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117554
// Address: 0x117554 - 0x11756c

void entry_117554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117554) {
        switch (ctx->pc) {
            case 0x117558: ctx->pc = 0; goto label_117558;
            case 0x117560: ctx->pc = 0; goto label_117560;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117554: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_117558:
    // 0x117558: 0x1600ffdb
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1174C8; return;
    }
label_117560:
    // 0x117560: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117564: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11756c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11756c
// Address: 0x11756c - 0x117578

void entry_11756c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11756c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117570: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117578);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117578
// Address: 0x117578 - 0x117598

void entry_117578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117578: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11757c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117580: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117584: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117588: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11758c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117594: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117598; return;
}


// Function: RefOpModulo__FiP4CRefP6CFrame
// Address: 0x117598 - 0x1175b8

void entry_1175b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1175b8) {
        switch (ctx->pc) {
            case 0x1175cc: ctx->pc = 0; goto label_1175cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1175b8: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1175bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1175c0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1175c4: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1175cc;
    }
label_1175cc:
    // 0x1175cc: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x1175d0: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x1175d4: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1175dc);
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1175dc
// Address: 0x1175dc - 0x1175e8

void entry_1175dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1175dc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1175e0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1175e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1175e8
// Address: 0x1175e8 - 0x1175f4

void entry_1175e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1175e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1175ec: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1175f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1175f4
// Address: 0x1175f4 - 0x117610

void entry_1175f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1175f4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1175f8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1175fc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117600: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117604: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11760c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117610; return;
}


// Function: RefOpCurrentTime__FiP4CRefP6CFrame
// Address: 0x117610 - 0x117628

void entry_117628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117628: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11762c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117630: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x117638);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[12] = *(float*)&val; }
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_117638
// Address: 0x117638 - 0x117644

void entry_117638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117638: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11763c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117644);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117644
// Address: 0x117644 - 0x117650

void entry_117644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117644: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117648: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117650);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117650
// Address: 0x117650 - 0x117668

void entry_117650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117650: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117654: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117658: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11765c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117664: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117668; return;
}


// Function: RefOpScheduleCallback__FiP4CRefP6CFrame
// Address: 0x117668 - 0x1176a8

void entry_1176a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176a8: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1176b0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1176b0
// Address: 0x1176b0 - 0x1176b8

void entry_1176b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176b0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176b8);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176b8
// Address: 0x1176b8 - 0x1176c0

void entry_1176b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176b8: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176c0);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176c0
// Address: 0x1176c0 - 0x1176c8

void entry_1176c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176c0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176c8);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176c8
// Address: 0x1176c8 - 0x1176d0

void entry_1176c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176c8: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176d0);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176d0
// Address: 0x1176d0 - 0x1176d8

void entry_1176d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176d0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176d8);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176d8
// Address: 0x1176d8 - 0x1176e0

void entry_1176d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176d8: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1176e0);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1176e0
// Address: 0x1176e0 - 0x1176f0

void entry_1176e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176e0: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1176e4: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1176e8: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1176f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1176f0
// Address: 0x1176f0 - 0x117700

void entry_1176f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1176f0: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1176f4: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1176f8: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x117700);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117700
// Address: 0x117700 - 0x11770c

void entry_117700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117700: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x117704: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11770c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11770c
// Address: 0x11770c - 0x117718

void entry_11770c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11770c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117710: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117718);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117718
// Address: 0x117718 - 0x117728

void entry_117718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117718: 0xae330008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 19));
    // 0x11771c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x117720: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x117728);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_117728
// Address: 0x117728 - 0x117734

void entry_117728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117728: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11772c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x117734);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_117734
// Address: 0x117734 - 0x117740

void entry_117734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117734: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x117738: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x117740);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 17));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_117740
// Address: 0x117740 - 0x117750

void entry_117740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117740: 0xaeb40008
    WRITE32(ADD32(GPR_U32(ctx, 21), 8), GPR_U32(ctx, 20));
    // 0x117744: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x117748: 0xc046dc0
    SET_GPR_U32(ctx, 31, 0x117750);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 23), 12)));
    SetProc__4CRefP5CProc(rdram, ctx, runtime); return;
}


// Function: entry_117750
// Address: 0x117750 - 0x117780

void entry_117750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117750) {
        switch (ctx->pc) {
            case 0x117778: ctx->pc = 0; goto label_117778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117750: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x117754: 0x8c429de8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294942184)));
    // 0x117758: 0x52902a
    SET_GPR_U32(ctx, 18, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 18)));
    // 0x11775c: 0x12400018
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1177C0; return;
    }
    // 0x117764: 0x571021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x117768: 0x8c520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x11776c: 0x12400014
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1177C0; return;
    }
    // 0x117774: 0x0
    // NOP
label_117778:
    // 0x117778: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x117780);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_117780
// Address: 0x117780 - 0x117788

void entry_117780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117780: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x117788);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_117788
// Address: 0x117788 - 0x117798

void entry_117788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117788: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11778c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x117790: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x117798);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_117798
// Address: 0x117798 - 0x1177a4

void entry_117798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117798: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11779c: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1177a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 17));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1177a4
// Address: 0x1177a4 - 0x1177dc

void entry_1177a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1177a4) {
        switch (ctx->pc) {
            case 0x1177c0: ctx->pc = 0; goto label_1177c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1177a4: 0xaeb20008
    WRITE32(ADD32(GPR_U32(ctx, 21), 8), GPR_U32(ctx, 18));
    // 0x1177a8: 0xae160008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 22));
    // 0x1177ac: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1177b0: 0xae400008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 0));
    // 0x1177b4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1177b8: 0x1640ffef
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x117778; return;
    }
label_1177c0:
    // 0x1177c0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1177c4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1177c8: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1177cc: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1177d0: 0x8c451ef8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 7928)));
    // 0x1177d4: 0xc046926
    SET_GPR_U32(ctx, 31, 0x1177dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1177dc
// Address: 0x1177dc - 0x1177fc

void entry_1177dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1177dc) {
        switch (ctx->pc) {
            case 0x1177f4: ctx->pc = 0; goto label_1177f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1177dc: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1177e0: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1177e4: 0x14620003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1177f4;
    }
    // 0x1177ec: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1177f0: 0xafc20008
    WRITE32(ADD32(GPR_U32(ctx, 30), 8), GPR_U32(ctx, 2));
label_1177f4:
    // 0x1177f4: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1177fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1177fc
// Address: 0x1177fc - 0x117818

void entry_1177fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1177fc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x117800: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x117804: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x117808: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11780c: 0x8c461ef8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 7928)));
    // 0x117810: 0xc046900
    SET_GPR_U32(ctx, 31, 0x117818);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    RefSetBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117818
// Address: 0x117818 - 0x117824

void entry_117818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117818: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x11781c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117824);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117824
// Address: 0x117824 - 0x117830

void entry_117824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117824: 0x8fa40030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117828: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117830);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117830
// Address: 0x117830 - 0x11783c

void entry_117830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117830: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117834: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11783c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11783c
// Address: 0x11783c - 0x117848

void entry_11783c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11783c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117840: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117848);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117848
// Address: 0x117848 - 0x117880

void entry_117848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117848: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11784c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x117850: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x117854: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x117858: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11785c: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x117860: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x117864: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x117868: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11786c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x117870: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117874: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11787c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117880; return;
}


// Function: RefOpDeferObjectUpdate__FiP4CRefP6CFrame
// Address: 0x117880 - 0x1178ac

void entry_1178ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1178ac: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1178b0: 0x8e120004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1178b4: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1178b8: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1178c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1178c0
// Address: 0x1178c0 - 0x1178d0

void entry_1178c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1178c0: 0xc7b40014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[20] = *(float*)&val; }
    // 0x1178c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1178c8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1178d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1178d0
// Address: 0x1178d0 - 0x1178e0

void entry_1178d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1178d0: 0xe654029c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 668), *(uint32_t*)&val); }
    // 0x1178d4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1178d8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1178e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1178e0
// Address: 0x1178e0 - 0x1178ec

void entry_1178e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1178e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1178e4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1178ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1178ec
// Address: 0x1178ec - 0x117910

void entry_1178ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1178ec: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1178f0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1178f4: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1178f8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1178fc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117900: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117904: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x117908: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpObjectOption__FiP4CRefP6CFrame4BIFK
// Address: 0x117910 - 0x117938

void entry_117938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117938) {
        switch (ctx->pc) {
            case 0x117964: ctx->pc = 0; goto label_117964;
            case 0x117980: ctx->pc = 0; goto label_117980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117938: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11793c: 0x24020064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 100));
    // 0x117940: 0x12020014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x117994; return;
    }
    // 0x117948: 0x2a020065
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 101));
    // 0x11794c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 99));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_117964;
    }
    // 0x117954: 0x1202000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_117980;
    }
    // 0x11795c: 0x10000028
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117A00; return;
    }
label_117964:
    // 0x117964: 0x24020065
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 101));
    // 0x117968: 0x12020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 102));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1179AC; return;
    }
    // 0x117970: 0x1202001a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1179DC; return;
    }
    // 0x117978: 0x10000021
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117A00; return;
    }
label_117980:
    // 0x117980: 0x26270010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 16));
    // 0x117984: 0xc0708ae
    SET_GPR_U32(ctx, 31, 0x11798c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefAddOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11798c
// Address: 0x11798c - 0x1179a4

void entry_11798c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11798c) {
        switch (ctx->pc) {
            case 0x117994: ctx->pc = 0; goto label_117994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11798c: 0x1000000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1179C0; return;
    }
label_117994:
    // 0x117994: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117998: 0x26270010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 16));
    // 0x11799c: 0xc0708c8
    SET_GPR_U32(ctx, 31, 0x1179a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEnsureOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1179a4
// Address: 0x1179a4 - 0x1179bc

void entry_1179a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1179a4) {
        switch (ctx->pc) {
            case 0x1179ac: ctx->pc = 0; goto label_1179ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1179a4: 0x10000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1179C0; return;
    }
label_1179ac:
    // 0x1179ac: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1179b0: 0x26270010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1179b4: 0xc07088e
    SET_GPR_U32(ctx, 31, 0x1179bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefSetOption__FP5BASICiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1179bc
// Address: 0x1179bc - 0x1179c8

void entry_1179bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1179bc) {
        switch (ctx->pc) {
            case 0x1179c0: ctx->pc = 0; goto label_1179c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1179bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1179c0:
    // 0x1179c0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1179c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1179c8
// Address: 0x1179c8 - 0x1179d4

void entry_1179c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1179c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1179cc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1179d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1179d4
// Address: 0x1179d4 - 0x1179e4

void entry_1179d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1179d4) {
        switch (ctx->pc) {
            case 0x1179dc: ctx->pc = 0; goto label_1179dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1179d4: 0x1000000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117A00; return;
    }
label_1179dc:
    // 0x1179dc: 0xc070868
    SET_GPR_U32(ctx, 31, 0x1179e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefGetOption__FP5BASICi(rdram, ctx, runtime); return;
}


// Function: entry_1179e4
// Address: 0x1179e4 - 0x1179f0

void entry_1179e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1179e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1179e8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1179f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1179f0
// Address: 0x1179f0 - 0x1179fc

void entry_1179f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1179f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1179f4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1179fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1179fc
// Address: 0x1179fc - 0x117a08

void entry_1179fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1179fc) {
        switch (ctx->pc) {
            case 0x117a00: ctx->pc = 0; goto label_117a00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1179fc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_117a00:
    // 0x117a00: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117a08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117a08
// Address: 0x117a08 - 0x117a14

void entry_117a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117a08: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117a0c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117a14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117a14
// Address: 0x117a14 - 0x117a30

void entry_117a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117a14: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117a18: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x117a1c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117a20: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117a24: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117a28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpAddO__FiP4CRefP6CFrame
// Address: 0x117a30 - 0x117a48

void entry_117a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117a48: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117a4c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117a50: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x117a54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117a5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117a60; return;
}


// Function: RefOpEnsureO__FiP4CRefP6CFrame
// Address: 0x117a60 - 0x117a78

void entry_117a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117a78: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117a7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117a80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x117a84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117a8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117a90; return;
}


// Function: RefOpSetO__FiP4CRefP6CFrame
// Address: 0x117a90 - 0x117aa8

void entry_117aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117aa8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117aac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117ab0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x117ab4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117abc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117ac0; return;
}


// Function: RefOpGetO__FiP4CRefP6CFrame
// Address: 0x117ac0 - 0x117ad8

void entry_117ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ad8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117adc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117ae0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x117ae4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117aec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117af0; return;
}


// Function: RefPairFromAplo__FiPP2LO
// Address: 0x117af0 - 0x117b20

void entry_117b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117b20) {
        switch (ctx->pc) {
            case 0x117b38: ctx->pc = 0; goto label_117b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117b20: 0x12000018
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117B84; return;
    }
    // 0x117b28: 0x1a000018
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        entry_117b8c(rdram, ctx, runtime); return;
    }
    // 0x117b30: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117b34: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_117b38:
    // 0x117b38: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x117b40);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_117b40
// Address: 0x117b40 - 0x117b5c

void entry_117b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117b40) {
        switch (ctx->pc) {
            case 0x117b50: ctx->pc = 0; goto label_117b50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117b40: 0x12600003
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_117b50;
    }
    // 0x117b48: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_117b5c(rdram, ctx, runtime); return;
    }
label_117b50:
    // 0x117b50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117b54: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x117b5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_117b5c
// Address: 0x117b5c - 0x117b70

void entry_117b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117b5c: 0x8e450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x117b60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117b64: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117b68: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117b70);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117b70
// Address: 0x117b70 - 0x117b8c

void entry_117b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117b70) {
        switch (ctx->pc) {
            case 0x117b84: ctx->pc = 0; goto label_117b84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117b70: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x117b74: 0x1620fff0
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x117B38; return;
    }
    // 0x117b7c: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x117B90; return;
    }
label_117b84:
    // 0x117b84: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x117b8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_117b8c
// Address: 0x117b8c - 0x117b98

void entry_117b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x117b8c) {
        switch (ctx->pc) {
            case 0x117b90: ctx->pc = 0; goto label_117b90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x117b8c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_117b90:
    // 0x117b90: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117b98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117b98
// Address: 0x117b98 - 0x117ba4

void entry_117b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117b98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117b9c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117ba4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117ba4
// Address: 0x117ba4 - 0x117bc8

void entry_117ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ba4: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x117ba8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x117bac: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x117bb0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x117bb4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117bb8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117bbc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117bc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFindObject__FiP4CRefP6CFrame
// Address: 0x117bc8 - 0x117be8

void entry_117be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117be8: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x117bec: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x117bf0: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x117bf4: 0x24080105
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 261));
    // 0x117bf8: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x117bfc: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x117c00: 0x103280a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 8));
    // 0x117c04: 0xc056906
    SET_GPR_U32(ctx, 31, 0x117c0c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117c0c
// Address: 0x117c0c - 0x117c18

void entry_117c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c0c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117c10: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117c18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117c18
// Address: 0x117c18 - 0x117c24

void entry_117c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c18: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117c1c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117c24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117c24
// Address: 0x117c24 - 0x117c30

void entry_117c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c24: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117c28: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117c30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117c30
// Address: 0x117c30 - 0x117c48

void entry_117c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c30: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117c34: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117c38: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117c3c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117c40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFindObjects__FiP4CRefP6CFrame
// Address: 0x117c48 - 0x117c6c

void entry_117c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c6c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x117c70: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x117c74: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x117c78: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117c7c: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x117c80: 0x24020105
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 261));
    // 0x117c84: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x117c88: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117c8c: 0x43280a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x117c90: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x117c94: 0xc056866
    SET_GPR_U32(ctx, 31, 0x117c9c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    CploFindSwObjects__FP2SWi3OIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117c9c
// Address: 0x117c9c - 0x117cb0

void entry_117c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117c9c: 0x27b00110
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 272));
    // 0x117ca0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117ca4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x117ca8: 0xc045ebc
    SET_GPR_U32(ctx, 31, 0x117cb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefPairFromAplo__FiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117cb0
// Address: 0x117cb0 - 0x117cbc

void entry_117cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117cb0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117cb4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117cbc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117cbc
// Address: 0x117cbc - 0x117cc8

void entry_117cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117cbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117cc0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117cc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117cc8
// Address: 0x117cc8 - 0x117cd4

void entry_117cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117cc8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117ccc: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117cd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117cd4
// Address: 0x117cd4 - 0x117ce0

void entry_117cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117cd4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117cd8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117ce0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117ce0
// Address: 0x117ce0 - 0x117d00

void entry_117ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ce0: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117ce4: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x117ce8: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x117cec: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x117cf0: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x117cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117d00; return;
}


// Function: RefOpFindNearestObject__FiP4CRefP6CFrame
// Address: 0x117d00 - 0x117d20

void entry_117d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d20: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x117d24: 0x8e07000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x117d28: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x117d2c: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x117d30: 0xc056906
    SET_GPR_U32(ctx, 31, 0x117d38);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117d38
// Address: 0x117d38 - 0x117d44

void entry_117d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d38: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117d3c: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117d44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117d44
// Address: 0x117d44 - 0x117d50

void entry_117d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d44: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117d48: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117d50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117d50
// Address: 0x117d50 - 0x117d5c

void entry_117d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117d54: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117d5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117d5c
// Address: 0x117d5c - 0x117d78

void entry_117d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d5c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117d60: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x117d64: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117d68: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117d6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117d74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117d78; return;
}


// Function: RefOpFindNearestObjects__FiP4CRefP6CFrame
// Address: 0x117d78 - 0x117d9c

void entry_117d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117d9c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x117da0: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117da4: 0x8e07000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x117da8: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117dac: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x117db0: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x117db4: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x117db8: 0xc056866
    SET_GPR_U32(ctx, 31, 0x117dc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    CploFindSwObjects__FP2SWi3OIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117dc0
// Address: 0x117dc0 - 0x117dd4

void entry_117dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117dc0: 0x27b00110
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 272));
    // 0x117dc4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117dc8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x117dcc: 0xc045ebc
    SET_GPR_U32(ctx, 31, 0x117dd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefPairFromAplo__FiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117dd4
// Address: 0x117dd4 - 0x117de0

void entry_117dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117dd4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117dd8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117de0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117de0
// Address: 0x117de0 - 0x117dec

void entry_117de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117de0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117de4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117dec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117dec
// Address: 0x117dec - 0x117df8

void entry_117dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117dec: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117df0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117df8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117df8
// Address: 0x117df8 - 0x117e04

void entry_117df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117df8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117dfc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117e04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117e04
// Address: 0x117e04 - 0x117e20

void entry_117e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e04: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117e08: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x117e0c: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x117e10: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x117e14: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x117e18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFindPlayerObject__FiP4CRefP6CFrame
// Address: 0x117e20 - 0x117e38

void entry_117e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e38: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x117e40);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_117e40
// Address: 0x117e40 - 0x117e4c

void entry_117e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e40: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117e44: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117e4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117e4c
// Address: 0x117e4c - 0x117e58

void entry_117e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e4c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117e50: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117e58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117e58
// Address: 0x117e58 - 0x117e64

void entry_117e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e58: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117e5c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117e64);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117e64
// Address: 0x117e64 - 0x117e78

void entry_117e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e64: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117e68: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117e6c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117e70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFindWorldObject__FiP4CRefP6CFrame
// Address: 0x117e78 - 0x117e90

void entry_117e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117e90: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x117e94: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117e98: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117ea0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117ea0
// Address: 0x117ea0 - 0x117eac

void entry_117ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ea0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117ea4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117eac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117eac
// Address: 0x117eac - 0x117eb8

void entry_117eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117eac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117eb0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117eb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117eb8
// Address: 0x117eb8 - 0x117ed0

void entry_117eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117eb8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117ebc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117ec0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117ec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117ecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117ed0; return;
}


// Function: RefOpFindCameraObject__FiP4CRefP6CFrame
// Address: 0x117ed0 - 0x117ee8

void entry_117ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ee8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x117eec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117ef0: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x117ef8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_117ef8
// Address: 0x117ef8 - 0x117f04

void entry_117ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117ef8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117efc: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117f04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117f04
// Address: 0x117f04 - 0x117f10

void entry_117f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f04: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117f08: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117f10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117f10
// Address: 0x117f10 - 0x117f28

void entry_117f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f10: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117f14: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x117f18: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x117f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117f28; return;
}


// Function: RefOpFindClassObjects__FiP4CRefP6CFrame
// Address: 0x117f28 - 0x117f4c

void entry_117f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f4c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x117f50: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x117f54: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x117f58: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x117f5c: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x117f60: 0x24020105
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 261));
    // 0x117f64: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x117f68: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117f6c: 0x43280a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x117f70: 0x24080100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 256));
    // 0x117f74: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x117f7c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117f7c
// Address: 0x117f7c - 0x117f90

void entry_117f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f7c: 0x27b00410
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 1040));
    // 0x117f80: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x117f84: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x117f88: 0xc045ebc
    SET_GPR_U32(ctx, 31, 0x117f90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefPairFromAplo__FiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_117f90
// Address: 0x117f90 - 0x117f9c

void entry_117f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117f94: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x117f9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117f9c
// Address: 0x117f9c - 0x117fa8

void entry_117f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117f9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x117fa0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117fa8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117fa8
// Address: 0x117fa8 - 0x117fb4

void entry_117fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117fa8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117fac: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x117fb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_117fb4
// Address: 0x117fb4 - 0x117fc0

void entry_117fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117fb4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x117fb8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x117fc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_117fc0
// Address: 0x117fc0 - 0x117fe0

void entry_117fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x117fc0: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x117fc4: 0x7bbf0450
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x117fc8: 0x7bb20440
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x117fcc: 0x7bb10430
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x117fd0: 0x7bb00420
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x117fd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1120));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x117fdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x117fe0; return;
}


// Function: RefOpFindObjectsInBoundingBox__FiP4CRefP6CFrame
// Address: 0x117fe0 - 0x118000

void entry_118000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118000: 0x26030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 8));
    // 0x118004: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118008: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x11800c: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x118010: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x118014: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x118018: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x11801c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x118020: 0xd8810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x118024: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x118028: 0x4bc2086b
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11802c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x118034);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118034
// Address: 0x118034 - 0x11805c

void entry_118034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118034: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x118038: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11803c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x118040: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x118044: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118048: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11804c: 0x27aa0040
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 64));
    // 0x118050: 0x27ab0044
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 68));
    // 0x118054: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x11805c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_11805c
// Address: 0x11805c - 0x118070

void entry_11805c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11805c: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x118060: 0x8fa50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118064: 0x8fa60044
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x118068: 0xc045ebc
    SET_GPR_U32(ctx, 31, 0x118070);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefPairFromAplo__FiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_118070
// Address: 0x118070 - 0x11807c

void entry_118070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118070: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118074: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11807c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11807c
// Address: 0x11807c - 0x118088

void entry_11807c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11807c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118080: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118088);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118088
// Address: 0x118088 - 0x118090

void entry_118088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118088: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x118090);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118090
// Address: 0x118090 - 0x11809c

void entry_118090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118090: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118094: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11809c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11809c
// Address: 0x11809c - 0x1180a8

void entry_11809c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11809c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1180a0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1180a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1180a8
// Address: 0x1180a8 - 0x1180c0

void entry_1180a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1180a8: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1180ac: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1180b0: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1180b4: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1180b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpFindObjectsInBoundingSphere__FiP4CRefP6CFrame
// Address: 0x1180c0 - 0x1180e4

void entry_1180e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1180e4) {
        switch (ctx->pc) {
            case 0x1180fc: ctx->pc = 0; goto label_1180fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1180e4: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1180e8: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1180ec: 0x54620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[20] = *(float*)&val; }
        goto label_1180fc;
    }
    // 0x1180f4: 0xc614000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[20] = *(float*)&val; }
    // 0x1180f8: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
label_1180fc:
    // 0x1180fc: 0xc063582
    SET_GPR_U32(ctx, 31, 0x118104);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118104
// Address: 0x118104 - 0x11812c

void entry_118104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118104: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x118108: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11810c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x118110: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x118114: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118118: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11811c: 0x27a90020
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    // 0x118120: 0x27aa0024
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 36));
    // 0x118124: 0xc077134
    SET_GPR_U32(ctx, 31, 0x11812c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_11812c
// Address: 0x11812c - 0x118140

void entry_11812c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11812c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118130: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118134: 0x8fa60024
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x118138: 0xc045ebc
    SET_GPR_U32(ctx, 31, 0x118140);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefPairFromAplo__FiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_118140
// Address: 0x118140 - 0x11814c

void entry_118140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118140: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118144: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11814c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11814c
// Address: 0x11814c - 0x118158

void entry_11814c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11814c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118150: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118158);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118158
// Address: 0x118158 - 0x118160

void entry_118158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118158: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x118160);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118160
// Address: 0x118160 - 0x11816c

void entry_118160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118160: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118164: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11816c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11816c
// Address: 0x11816c - 0x118178

void entry_11816c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11816c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118170: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118178);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118178
// Address: 0x118178 - 0x118198

void entry_118178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118178: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11817c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118180: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118184: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118188: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x11818c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118194: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118198; return;
}


// Function: RefOpHitTestObjectsImpl__F4BIFKiP4CRefP6CFrame
// Address: 0x118198 - 0x1181d8

void entry_1181d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1181d8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1181dc: 0x54600006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1181F8; return;
    }
    // 0x1181e4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1181e8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1181f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1181f0
// Address: 0x1181f0 - 0x118238

void entry_1181f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1181f0) {
        switch (ctx->pc) {
            case 0x1181f8: ctx->pc = 0; goto label_1181f8;
            case 0x118210: ctx->pc = 0; goto label_118210;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1181f0: 0x1000005e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11836C; return;
    }
label_1181f8:
    // 0x1181f8: 0x12800054
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11834C; return;
    }
    // 0x118200: 0x26020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 16));
    // 0x118204: 0x261e0008
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 16), 8));
    // 0x118208: 0xafa20088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 2));
    // 0x11820c: 0x8e930004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 4)));
label_118210:
    // 0x118210: 0x1260004b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 136)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118340; return;
    }
    // 0x118218: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11821c: 0x8fc50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 30), 4)));
    // 0x118220: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x118224: 0x8c660004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x118228: 0x27a80080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 128));
    // 0x11822c: 0xafb30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 19));
    // 0x118230: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x118238);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_118238
// Address: 0x118238 - 0x118254

void entry_118238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118238: 0x10400041
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118340; return;
    }
    // 0x118240: 0x24030071
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 113));
    // 0x118244: 0x14430024
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1182D8; return;
    }
    // 0x11824c: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x118254);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118254
// Address: 0x118254 - 0x11825c

void entry_118254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118254: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x11825c);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11825c
// Address: 0x11825c - 0x118264

void entry_11825c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11825c: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x118264);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118264
// Address: 0x118264 - 0x118274

void entry_118264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118264: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118268: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11826c: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x118274);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_118274
// Address: 0x118274 - 0x11827c

void entry_118274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118274: 0xc047142
    SET_GPR_U32(ctx, 31, 0x11827c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 17));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11827c
// Address: 0x11827c - 0x118290

void entry_11827c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11827c: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x118280: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118284: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118288: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x118290);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_118290
// Address: 0x118290 - 0x118298

void entry_118290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118290: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118298);
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 16));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118298
// Address: 0x118298 - 0x1182ac

void entry_118298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118298: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11829c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1182a0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1182a4: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1182ac);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1182ac
// Address: 0x1182ac - 0x1182b4

void entry_1182ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1182ac: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1182b4);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1182b4
// Address: 0x1182b4 - 0x1182c4

void entry_1182b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1182b4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1182b8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1182bc: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1182c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1182c4
// Address: 0x1182c4 - 0x1182e0

void entry_1182c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1182c4) {
        switch (ctx->pc) {
            case 0x1182d0: ctx->pc = 0; goto label_1182d0;
            case 0x1182d8: ctx->pc = 0; goto label_1182d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1182c4: 0x52c00002
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_1182d0;
    }
    // 0x1182cc: 0xaeb00008
    WRITE32(ADD32(GPR_U32(ctx, 21), 8), GPR_U32(ctx, 16));
label_1182d0:
    // 0x1182d0: 0x1000001b
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118340; return;
    }
label_1182d8:
    // 0x1182d8: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1182e0);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1182e0
// Address: 0x1182e0 - 0x1182e8

void entry_1182e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1182e0: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x1182e8);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1182e8
// Address: 0x1182e8 - 0x1182f8

void entry_1182e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1182e8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1182ec: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1182f0: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x1182f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_1182f8
// Address: 0x1182f8 - 0x118300

void entry_1182f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1182f8: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118300);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 17));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118300
// Address: 0x118300 - 0x118314

void entry_118300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118300: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118304: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118308: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11830c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x118314);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_118314
// Address: 0x118314 - 0x118320

void entry_118314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118314: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118318: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x118320);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_118320
// Address: 0x118320 - 0x11832c

void entry_118320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118320: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x118324: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11832c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11832c
// Address: 0x11832c - 0x118338

void entry_11832c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11832c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118330: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118338);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118338
// Address: 0x118338 - 0x11835c

void entry_118338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118338) {
        switch (ctx->pc) {
            case 0x118340: ctx->pc = 0; goto label_118340;
            case 0x11834c: ctx->pc = 0; goto label_11834c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118338: 0x10000012
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118384; return;
    }
label_118340:
    // 0x118340: 0x8e940008
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x118344: 0x5680ffb2
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 4)));
        ctx->pc = 0x118210; return;
    }
label_11834c:
    // 0x11834c: 0x12c00005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118364; return;
    }
    // 0x118354: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x11835c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11835c
// Address: 0x11835c - 0x118374

void entry_11835c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11835c) {
        switch (ctx->pc) {
            case 0x118364: ctx->pc = 0; goto label_118364;
            case 0x11836c: ctx->pc = 0; goto label_11836c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11835c: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11836c;
    }
label_118364:
    // 0x118364: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x118368: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_11836c:
    // 0x11836c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118374);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118374
// Address: 0x118374 - 0x118380

void entry_118374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118374: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118378: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118380);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118380
// Address: 0x118380 - 0x1183b8

void entry_118380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118380) {
        switch (ctx->pc) {
            case 0x118384: ctx->pc = 0; goto label_118384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118380: 0x2e0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_118384:
    // 0x118384: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x118388: 0x7bbe0110
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x11838c: 0x7bb70100
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x118390: 0x7bb600f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x118394: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x118398: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x11839c: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1183a0: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1183a4: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1183a8: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1183ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1183b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1183b8; return;
}


// Function: RefOpHitTestObjects__FiP4CRefP6CFrame
// Address: 0x1183b8 - 0x1183e8

void entry_1183e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1183e8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1183ec: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1183f0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1183f4: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1183f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1183fc: 0xc046066
    SET_GPR_U32(ctx, 31, 0x118404);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 113));
    RefOpHitTestObjectsImpl__F4BIFKiP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_118404
// Address: 0x118404 - 0x118410

void entry_118404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118404: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118408: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118410);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118410
// Address: 0x118410 - 0x11841c

void entry_118410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118410: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118414: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11841c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11841c
// Address: 0x11841c - 0x118428

void entry_11841c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11841c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118420: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118428
// Address: 0x118428 - 0x118434

void entry_118428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118428: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11842c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118434);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118434
// Address: 0x118434 - 0x118458

void entry_118434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118434: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x118438: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11843c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118440: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118444: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118448: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11844c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118458; return;
}


// Function: RefOpHitTestObjectsFirst__FiP4CRefP6CFrame
// Address: 0x118458 - 0x118488

void entry_118488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118488: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11848c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118490: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118494: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118498: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11849c: 0xc046066
    SET_GPR_U32(ctx, 31, 0x1184a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 114));
    RefOpHitTestObjectsImpl__F4BIFKiP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1184a4
// Address: 0x1184a4 - 0x1184b0

void entry_1184a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1184a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1184a8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1184b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1184b0
// Address: 0x1184b0 - 0x1184bc

void entry_1184b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1184b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1184b4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1184bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1184bc
// Address: 0x1184bc - 0x1184c8

void entry_1184bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1184bc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1184c0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1184c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1184c8
// Address: 0x1184c8 - 0x1184d4

void entry_1184c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1184c8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1184cc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1184d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1184d4
// Address: 0x1184d4 - 0x1184f8

void entry_1184d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1184d4: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1184d8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1184dc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1184e0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1184e4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1184e8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1184ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1184f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1184f8; return;
}


// Function: RefOpConvertObjectPosition__FiP4CRefP6CFrame
// Address: 0x1184f8 - 0x11851c

void entry_11851c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11851c: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118524);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118524
// Address: 0x118524 - 0x11853c

void entry_118524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118524: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x118528: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11852c: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118530: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118534: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x11853c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_11853c
// Address: 0x11853c - 0x118548

void entry_11853c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11853c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118540: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x118548);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_118548
// Address: 0x118548 - 0x118554

void entry_118548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118548: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11854c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118554);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118554
// Address: 0x118554 - 0x118560

void entry_118554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118554: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118558: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118560);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118560
// Address: 0x118560 - 0x118580

void entry_118560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118560: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118564: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118568: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11856c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118570: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x118574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11857c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118580; return;
}


// Function: RefOpConvertObjectVector__FiP4CRefP6CFrame
// Address: 0x118580 - 0x1185a4

void entry_1185a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185a4: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1185ac);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1185ac
// Address: 0x1185ac - 0x1185c4

void entry_1185ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185ac: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1185b0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1185b4: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1185b8: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1185bc: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1185c4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1185c4
// Address: 0x1185c4 - 0x1185d0

void entry_1185c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1185c8: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1185d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1185d0
// Address: 0x1185d0 - 0x1185dc

void entry_1185d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1185d4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1185dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1185dc
// Address: 0x1185dc - 0x1185e8

void entry_1185dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1185e0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1185e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1185e8
// Address: 0x1185e8 - 0x118608

void entry_1185e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1185e8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1185ec: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1185f0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1185f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1185f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1185fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118604: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118608; return;
}


// Function: RefOpConvertObjectMatrix__FiP4CRefP6CFrame
// Address: 0x118608 - 0x11862c

void entry_11862c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11862c: 0xc047186
    SET_GPR_U32(ctx, 31, 0x118634);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118634
// Address: 0x118634 - 0x11864c

void entry_118634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118634: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118638: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x11863c: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x118640: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118644: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x11864c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_11864c
// Address: 0x11864c - 0x118654

void entry_11864c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11864c: 0xc062130
    SET_GPR_U32(ctx, 31, 0x118654);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PostCopyMatrix3__7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_118654
// Address: 0x118654 - 0x118660

void entry_118654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118654: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118658: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x118660);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_118660
// Address: 0x118660 - 0x11866c

void entry_118660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118660: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118664: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11866c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11866c
// Address: 0x11866c - 0x118678

void entry_11866c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11866c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118670: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118678);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118678
// Address: 0x118678 - 0x118698

void entry_118678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118678: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11867c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118680: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118684: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118688: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11868c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118694: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118698; return;
}


// Function: RefOpNearClipCenter__FiP4CRefP6CFrame
// Address: 0x118698 - 0x1186b0

void entry_1186b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1186b0: 0xc047142
    SET_GPR_U32(ctx, 31, 0x1186b8);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1186b8
// Address: 0x1186b8 - 0x1186f0

void entry_1186b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1186b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1186bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1186c0: 0x8c661990
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x1186c4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1186c8: 0x8cc301e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 484)));
    // 0x1186cc: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1186d0: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1186d4: 0xd8c10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 128)));
    // 0x1186d8: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1186dc: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1186e0: 0xd8c10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 6), 64)));
    // 0x1186e4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1186e8: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x1186f0);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1186f0
// Address: 0x1186f0 - 0x1186fc

void entry_1186f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1186f0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1186f4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1186fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1186fc
// Address: 0x1186fc - 0x118708

void entry_1186fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1186fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118700: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118708);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118708
// Address: 0x118708 - 0x118720

void entry_118708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118708: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11870c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118710: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11871c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118720; return;
}


// Function: RefOpStartSound__FiP4CRefP6CFrame
// Address: 0x118720 - 0x118744

void entry_118744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118744: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x118748: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11874c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x118750: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118754: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118758: 0x222280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 17));
    // 0x11875c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x118760: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x118764: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x118768: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11876c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x118770: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x118774: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118778: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x11877c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x118780: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118784: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118788: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x11878c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x118794);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_118794
// Address: 0x118794 - 0x1187a0

void entry_118794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118794: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x118798: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x1187a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1187a0
// Address: 0x1187a0 - 0x1187b4

void entry_1187a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1187a0: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1187a4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x1187B8; return;
    }
    // 0x1187ac: 0xc06fdc6
    SET_GPR_U32(ctx, 31, 0x1187b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DropPamb__FPP3AMB(rdram, ctx, runtime); return;
}


// Function: entry_1187b4
// Address: 0x1187b4 - 0x1187c0

void entry_1187b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1187b4) {
        switch (ctx->pc) {
            case 0x1187b8: ctx->pc = 0; goto label_1187b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1187b4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1187b8:
    // 0x1187b8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1187c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1187c0
// Address: 0x1187c0 - 0x1187cc

void entry_1187c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1187c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1187c4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1187cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1187cc
// Address: 0x1187cc - 0x1187e8

void entry_1187cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1187cc: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1187d0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1187d4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1187d8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1187dc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1187e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpStopSound__FiP4CRefP6CFrame
// Address: 0x1187e8 - 0x118808

void entry_118808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118808: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11880c: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x118814);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_118814
// Address: 0x118814 - 0x118828

void entry_118814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118814: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    // 0x118818: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11881c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x118820: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118828);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118828
// Address: 0x118828 - 0x118834

void entry_118828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118828: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11882c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118834);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118834
// Address: 0x118834 - 0x118850

void entry_118834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118834: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118838: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11883c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118840: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x118844: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11884c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118850; return;
}


// Function: RefOpStartRumble__FiP4CRefP6CFrame
// Address: 0x118850 - 0x11887c

void entry_11887c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11887c: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118880: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x118884: 0x8e320004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118888: 0x26102c70
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 11376));
    // 0x11888c: 0x26250008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    // 0x118890: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x118898);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118898
// Address: 0x118898 - 0x1188a8

void entry_118898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118898: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x11889c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1188a0: 0xc05bb0e
    SET_GPR_U32(ctx, 31, 0x1188a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TriggerJoyRumbleRumk__FP3JOY4RUMKf(rdram, ctx, runtime); return;
}


// Function: entry_1188a8
// Address: 0x1188a8 - 0x1188b4

void entry_1188a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1188a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1188ac: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1188b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1188b4
// Address: 0x1188b4 - 0x1188c0

void entry_1188b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1188b4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1188b8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1188c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1188c0
// Address: 0x1188c0 - 0x1188cc

void entry_1188c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1188c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1188c4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1188cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1188cc
// Address: 0x1188cc - 0x1188f0

void entry_1188cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1188cc: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1188d0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1188d4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1188d8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1188dc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1188e0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1188e4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1188e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpEmitSmokeCloud__FiP4CRefP6CFrame
// Address: 0x1188f0 - 0x118918

void entry_118918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118918: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11891c: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x118920: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118924: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x11892c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11892c
// Address: 0x11892c - 0x118938

void entry_11892c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11892c: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x118930: 0xc0559b2
    SET_GPR_U32(ctx, 31, 0x118938);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    StandardSmokeCloud__FP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_118938
// Address: 0x118938 - 0x118944

void entry_118938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118938: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11893c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118944);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118944
// Address: 0x118944 - 0x118950

void entry_118944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118944: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118948: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x118950);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_118950
// Address: 0x118950 - 0x11895c

void entry_118950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118950: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118954: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11895c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11895c
// Address: 0x11895c - 0x118968

void entry_11895c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11895c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118960: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118968);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118968
// Address: 0x118968 - 0x118988

void entry_118968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118968: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11896c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x118970: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118974: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118978: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11897c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118980: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefOpPredictAnimationEffect__FiP4CRefP6CFrame
// Address: 0x118988 - 0x1189d0

void entry_1189d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1189d0: 0xafa00030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 0));
    // 0x1189d4: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1189d8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1189dc: 0x26050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1189e0: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x1189e8);
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1189e8
// Address: 0x1189e8 - 0x118a00

void entry_1189e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1189e8: 0xafa00034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 0));
    // 0x1189ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1189f0: 0xc7b50014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[21] = *(float*)&val; }
    // 0x1189f4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1189f8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118a00);
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118a00
// Address: 0x118a00 - 0x118a0c

void entry_118a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118a00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118a04: 0xc046e6a
    SET_GPR_U32(ctx, 31, 0x118a0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 16));
    RefCoerceF32__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118a0c
// Address: 0x118a0c - 0x118a1c

void entry_118a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118a0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118a10: 0xc7b40014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[20] = *(float*)&val; }
    // 0x118a14: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118a1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118a1c
// Address: 0x118a1c - 0x118a38

void entry_118a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118a1c: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x118a20: 0xafa20028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
    // 0x118a24: 0x8e11001c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x118a28: 0x8e120024
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x118a2c: 0x8e10002c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x118a30: 0xc063582
    SET_GPR_U32(ctx, 31, 0x118a38);
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 16));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118a38
// Address: 0x118a38 - 0x118a54

void entry_118a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118a38: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x118a3c: 0x30620001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 1));
    // 0x118a40: 0x10400007
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118A60; return;
    }
    // 0x118a48: 0x8fb00024
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x118a4c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x118a54);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_118a54
// Address: 0x118a54 - 0x118a74

void entry_118a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118a54) {
        switch (ctx->pc) {
            case 0x118a60: ctx->pc = 0; goto label_118a60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118a54: 0xafa2002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 2));
    // 0x118a58: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x118a5c: 0x30620002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2));
label_118a60:
    // 0x118a60: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118A78; return;
    }
    // 0x118a68: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x118a6c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x118a74);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_118a74
// Address: 0x118a74 - 0x118a90

void entry_118a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118a74) {
        switch (ctx->pc) {
            case 0x118a78: ctx->pc = 0; goto label_118a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118a74: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
label_118a78:
    // 0x118a78: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x118a7c: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x118a80: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118A98; return;
    }
    // 0x118a88: 0xc063596
    SET_GPR_U32(ctx, 31, 0x118a90);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_118a90
// Address: 0x118a90 - 0x118aac

void entry_118a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118a90) {
        switch (ctx->pc) {
            case 0x118a98: ctx->pc = 0; goto label_118a98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118a90: 0xafa20034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 2));
    // 0x118a94: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
label_118a98:
    // 0x118a98: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x118a9c: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118AB0; return;
    }
    // 0x118aa4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x118aac);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_118aac
// Address: 0x118aac - 0x118ae0

void entry_118aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118aac) {
        switch (ctx->pc) {
            case 0x118ab0: ctx->pc = 0; goto label_118ab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118aac: 0xafa20038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 2));
label_118ab0:
    // 0x118ab0: 0x8fa70024
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x118ab4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118ab8: 0x8fa8002c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x118abc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x118ac0: 0x8fa90030
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118ac4: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x118ac8: 0x8faa0034
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x118acc: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x118ad0: 0x8fab0038
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x118ad4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118ad8: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x118ae0);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_118ae0
// Address: 0x118ae0 - 0x118b08

void entry_118ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118ae0) {
        switch (ctx->pc) {
            case 0x118af0: ctx->pc = 0; goto label_118af0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118ae0: 0xafa0003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 0));
    // 0x118ae4: 0xafa00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 0));
    // 0x118ae8: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x118aec: 0x0
    // NOP
label_118af0:
    // 0x118af0: 0x721024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x118af4: 0x121840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 1));
    // 0x118af8: 0x10400058
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118C5C; return;
    }
    // 0x118b00: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x118b08);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118b08
// Address: 0x118b08 - 0x118b30

void entry_118b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118b08) {
        switch (ctx->pc) {
            case 0x118b1c: ctx->pc = 0; goto label_118b1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118b08: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118b0c: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118b10: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 60), GPR_U32(ctx, 17));
        goto label_118b1c;
    }
    // 0x118b18: 0xac510008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 17));
label_118b1c:
    // 0x118b1c: 0xafb10040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 17));
    // 0x118b20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118b24: 0xf02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x118b28: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x118b30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_118b30
// Address: 0x118b30 - 0x118b68

void entry_118b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118b30) {
        switch (ctx->pc) {
            case 0x118b60: ctx->pc = 0; goto label_118b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118b30: 0x121840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 1));
    // 0x118b34: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x118b38: 0x18400048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x118C5C; return;
    }
    // 0x118b40: 0x2a430003
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), 3));
    // 0x118b44: 0x8fb70038
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    // 0x118b48: 0xafa30044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 3));
    // 0x118b4c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118b50: 0x8fb60034
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x118b54: 0x8fb50030
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118b58: 0x8fb4002c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x118b5c: 0x0
    // NOP
label_118b60:
    // 0x118b60: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x118b68);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118b68
// Address: 0x118b68 - 0x118bb4

void entry_118b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118b68) {
        switch (ctx->pc) {
            case 0x118b90: ctx->pc = 0; goto label_118b90;
            case 0x118bac: ctx->pc = 0; goto label_118bac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118b68: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118b6c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x118b70: 0x12420012
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x118BBC; return;
    }
    // 0x118b78: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_118b90;
    }
    // 0x118b80: 0x1242000a
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_118bac;
    }
    // 0x118b88: 0x10000027
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_118c28(rdram, ctx, runtime); return;
    }
label_118b90:
    // 0x118b90: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x118b94: 0x12430014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x118BE8; return;
    }
    // 0x118b9c: 0x1242001b
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x118C0C; return;
    }
    // 0x118ba4: 0x10000020
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_118c28(rdram, ctx, runtime); return;
    }
label_118bac:
    // 0x118bac: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118bb4);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118bb4
// Address: 0x118bb4 - 0x118bc4

void entry_118bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118bb4) {
        switch (ctx->pc) {
            case 0x118bbc: ctx->pc = 0; goto label_118bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118bb4: 0x1000000f
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 20), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118BF4; return;
    }
label_118bbc:
    // 0x118bbc: 0xc047186
    SET_GPR_U32(ctx, 31, 0x118bc4);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118bc4
// Address: 0x118bc4 - 0x118bd4

void entry_118bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118bc4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118bc8: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x118bcc: 0xc062138
    SET_GPR_U32(ctx, 31, 0x118bd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__7MATRIX4RC7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_118bd4
// Address: 0x118bd4 - 0x118be0

void entry_118bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118bd4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118bd8: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x118be0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_118be0
// Address: 0x118be0 - 0x118bf0

void entry_118be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118be0) {
        switch (ctx->pc) {
            case 0x118be8: ctx->pc = 0; goto label_118be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118be0: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_118c28(rdram, ctx, runtime); return;
    }
label_118be8:
    // 0x118be8: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118bf0);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118bf0
// Address: 0x118bf0 - 0x118c04

void entry_118bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118bf0) {
        switch (ctx->pc) {
            case 0x118bf4: ctx->pc = 0; goto label_118bf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118bf0: 0x7ac30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 22), 0)));
label_118bf4:
    // 0x118bf4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118bf8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118bfc: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x118c04);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_118c04
// Address: 0x118c04 - 0x118c14

void entry_118c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118c04) {
        switch (ctx->pc) {
            case 0x118c0c: ctx->pc = 0; goto label_118c0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118c04: 0x10000008
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_118c28(rdram, ctx, runtime); return;
    }
label_118c0c:
    // 0x118c0c: 0xc047142
    SET_GPR_U32(ctx, 31, 0x118c14);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118c14
// Address: 0x118c14 - 0x118c28

void entry_118c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118c14: 0x7ae30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x118c18: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x118c1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118c20: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x118c28);
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 3));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_118c28
// Address: 0x118c28 - 0x118c40

void entry_118c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118c28) {
        switch (ctx->pc) {
            case 0x118c38: ctx->pc = 0; goto label_118c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118c28: 0x13c00003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_118c38;
    }
    // 0x118c30: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 30), 8), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_118c40(rdram, ctx, runtime); return;
    }
label_118c38:
    // 0x118c38: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x118c40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_118c40
// Address: 0x118c40 - 0x118c74

void entry_118c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118c40) {
        switch (ctx->pc) {
            case 0x118c5c: ctx->pc = 0; goto label_118c5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118c40: 0x220f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118c44: 0x26f70010
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 16));
    // 0x118c48: 0x26d60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 16));
    // 0x118c4c: 0x26b50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 48));
    // 0x118c50: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x118c54: 0x1660ffc2
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x118B60; return;
    }
label_118c5c:
    // 0x118c5c: 0x8fb20048
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x118c60: 0x2a420009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 9));
    // 0x118c64: 0x1440ffa2
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x118AF0; return;
    }
    // 0x118c6c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x118c74);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_118c74
// Address: 0x118c74 - 0x118c88

void entry_118c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118c74: 0x8fa3003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x118c78: 0x10600005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118C90; return;
    }
    // 0x118c80: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x118c88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_118c88
// Address: 0x118c88 - 0x118c9c

void entry_118c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118c88) {
        switch (ctx->pc) {
            case 0x118c90: ctx->pc = 0; goto label_118c90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118c88: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x118CA0; return;
    }
label_118c90:
    // 0x118c90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118c94: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x118c9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_118c9c
// Address: 0x118c9c - 0x118ca8

void entry_118c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118c9c) {
        switch (ctx->pc) {
            case 0x118ca0: ctx->pc = 0; goto label_118ca0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118c9c: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
label_118ca0:
    // 0x118ca0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118ca8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118ca8
// Address: 0x118ca8 - 0x118cb4

void entry_118ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ca8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118cac: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118cb4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118cb4
// Address: 0x118cb4 - 0x118cf0

void entry_118cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118cb4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118cb8: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x118cbc: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x118cc0: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x118cc4: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x118cc8: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x118ccc: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x118cd0: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x118cd4: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x118cd8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x118cdc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118ce0: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x118ce4: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x118ce8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___8VU_FLOATf
// Address: 0x118cf0 - 0x118d10

void entry_118d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118d70: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118d74: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x118d78: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118d7c: 0xc046926
    SET_GPR_U32(ctx, 31, 0x118d84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118d84
// Address: 0x118d84 - 0x118d90

void entry_118d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118d84: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118d88: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118d90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118d90
// Address: 0x118d90 - 0x118d9c

void entry_118d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118d90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118d94: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118d9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118d9c
// Address: 0x118d9c - 0x118db8

void entry_118d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118d9c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118da0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118da4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118da8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118dac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x118db0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalSet__FP5CPairP6CFrame
// Address: 0x118db8 - 0x118de4

void entry_118de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118de4: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118de8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118dec: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118df0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118df4: 0x8c710008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x118df8: 0xc046820
    SET_GPR_U32(ctx, 31, 0x118e00);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_118e00
// Address: 0x118e00 - 0x118e0c

void entry_118e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118e04: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118e0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118e0c
// Address: 0x118e0c - 0x118e18

void entry_118e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118e10: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118e18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118e18
// Address: 0x118e18 - 0x118e2c

void entry_118e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e18: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118e1c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118e20: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118e24: 0xc046900
    SET_GPR_U32(ctx, 31, 0x118e2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefSetBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118e2c
// Address: 0x118e2c - 0x118e38

void entry_118e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e2c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118e30: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118e38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118e38
// Address: 0x118e38 - 0x118e44

void entry_118e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118e3c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118e44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118e44
// Address: 0x118e44 - 0x118e50

void entry_118e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e44: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118e48: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118e50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118e50
// Address: 0x118e50 - 0x118e5c

void entry_118e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118e54: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118e5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118e5c
// Address: 0x118e5c - 0x118e80

void entry_118e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118e5c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x118e60: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x118e64: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118e68: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118e6c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118e70: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118e74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118e7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118e80; return;
}


// Function: RefEvalDefine__FP5CPairP6CFrame
// Address: 0x118e80 - 0x118eac

void entry_118eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118eac: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118eb0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118eb4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118eb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118ebc: 0x8c710008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x118ec0: 0xc046820
    SET_GPR_U32(ctx, 31, 0x118ec8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_118ec8
// Address: 0x118ec8 - 0x118ed4

void entry_118ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ec8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118ecc: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118ed4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118ed4
// Address: 0x118ed4 - 0x118ee0

void entry_118ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ed4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118ed8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118ee0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118ee0
// Address: 0x118ee0 - 0x118ef4

void entry_118ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ee0: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x118ee4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118ee8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118eec: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x118ef4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118ef4
// Address: 0x118ef4 - 0x118f00

void entry_118ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ef4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118ef8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118f00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118f00
// Address: 0x118f00 - 0x118f0c

void entry_118f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x118f04: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118f0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118f0c
// Address: 0x118f0c - 0x118f18

void entry_118f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f0c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118f10: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x118f18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118f18
// Address: 0x118f18 - 0x118f24

void entry_118f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118f1c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118f24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118f24
// Address: 0x118f24 - 0x118f48

void entry_118f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f24: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x118f28: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x118f2c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x118f30: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x118f34: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x118f38: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x118f3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x118f44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x118f48; return;
}


// Function: RefEvalAssert__FP5CPairP6CFrame
// Address: 0x118f48 - 0x118f74

void entry_118f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f74: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118f78: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x118f7c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118f80: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118f84: 0x8c450008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x118f88: 0xc046820
    SET_GPR_U32(ctx, 31, 0x118f90);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_118f90
// Address: 0x118f90 - 0x118f9c

void entry_118f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118f94: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x118f9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_118f9c
// Address: 0x118f9c - 0x118fa8

void entry_118f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118f9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118fa0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118fa8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118fa8
// Address: 0x118fa8 - 0x118fc8

void entry_118fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118fa8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x118fac: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x118FEC; return;
    }
    // 0x118fb4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x118fb8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x118fbc: 0x24849200
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939136));
    // 0x118fc0: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x118fc8);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_118fc8
// Address: 0x118fc8 - 0x118fdc

void entry_118fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118fc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118fcc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x118fd0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x118fd4: 0xc044dcc
    SET_GPR_U32(ctx, 31, 0x118fdc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefOpPrint__FiP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_118fdc
// Address: 0x118fdc - 0x118fe8

void entry_118fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118fdc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x118fe0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x118fe8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_118fe8
// Address: 0x118fe8 - 0x118ff4

void entry_118fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x118fe8) {
        switch (ctx->pc) {
            case 0x118fec: ctx->pc = 0; goto label_118fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x118fe8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_118fec:
    // 0x118fec: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x118ff4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_118ff4
// Address: 0x118ff4 - 0x119000

void entry_118ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x118ff4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x118ff8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119000);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119000
// Address: 0x119000 - 0x11900c

void entry_119000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119000: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119004: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11900c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11900c
// Address: 0x11900c - 0x119030

void entry_11900c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11900c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119010: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119014: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119018: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11901c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119020: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119024: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11902c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x119030; return;
}


// Function: RefEvalIf__FP5CPairP6CFrame
// Address: 0x119030 - 0x119060

void entry_119060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119060: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119064: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119068: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11906c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119070: 0x8c450008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x119074: 0x8cb30008
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x119078: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119080);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119080
// Address: 0x119080 - 0x11908c

void entry_119080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119080: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119084: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11908c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11908c
// Address: 0x11908c - 0x119098

void entry_11908c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11908c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119090: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119098);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119098
// Address: 0x119098 - 0x1190c0

void entry_119098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119098) {
        switch (ctx->pc) {
            case 0x1190b4: ctx->pc = 0; goto label_1190b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119098: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x11909c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1190a0: 0x10620004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1190b4;
    }
    // 0x1190a8: 0x1200000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1190E0; return;
    }
    // 0x1190b0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1190b4:
    // 0x1190b4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1190b8: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1190c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1190c0
// Address: 0x1190c0 - 0x1190cc

void entry_1190c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1190c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1190c4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1190cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1190cc
// Address: 0x1190cc - 0x1190d8

void entry_1190cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1190cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1190d0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1190d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1190d8
// Address: 0x1190d8 - 0x1190e8

void entry_1190d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1190d8) {
        switch (ctx->pc) {
            case 0x1190e0: ctx->pc = 0; goto label_1190e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1190d8: 0x10000004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1190EC; return;
    }
label_1190e0:
    // 0x1190e0: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1190e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1190e8
// Address: 0x1190e8 - 0x1190f4

void entry_1190e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1190e8) {
        switch (ctx->pc) {
            case 0x1190ec: ctx->pc = 0; goto label_1190ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1190e8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1190ec:
    // 0x1190ec: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1190f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1190f4
// Address: 0x1190f4 - 0x119100

void entry_1190f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1190f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1190f8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119100);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119100
// Address: 0x119100 - 0x119128

void entry_119100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119100: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x119104: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x119108: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11910c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119110: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119114: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119118: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11911c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x119124: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x119128; return;
}


// Function: RefEvalOr__FP5CPairP6CFrame
// Address: 0x119128 - 0x119158

void entry_119158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119158) {
        switch (ctx->pc) {
            case 0x119170: ctx->pc = 0; goto label_119170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119158: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11915c: 0x8c700008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x119160: 0x1200001b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1191D0; return;
    }
    // 0x119168: 0x2414001b
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 27));
    // 0x11916c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_119170:
    // 0x119170: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119174: 0xc046820
    SET_GPR_U32(ctx, 31, 0x11917c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11917c
// Address: 0x11917c - 0x119188

void entry_11917c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11917c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119180: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119188);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119188
// Address: 0x119188 - 0x119194

void entry_119188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119188: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11918c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119194);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119194
// Address: 0x119194 - 0x1191b4

void entry_119194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119194) {
        switch (ctx->pc) {
            case 0x1191ac: ctx->pc = 0; goto label_1191ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119194: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x119198: 0x14540004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        goto label_1191ac;
    }
    // 0x1191a0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1191a4: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x1191C8; return;
    }
label_1191ac:
    // 0x1191ac: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1191b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1191b4
// Address: 0x1191b4 - 0x1191c0

void entry_1191b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1191b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1191b8: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1191c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1191c0
// Address: 0x1191c0 - 0x1191dc

void entry_1191c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1191c0) {
        switch (ctx->pc) {
            case 0x1191c8: ctx->pc = 0; goto label_1191c8;
            case 0x1191d0: ctx->pc = 0; goto label_1191d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1191c0: 0x1000000d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1191F8; return;
    }
label_1191c8:
    // 0x1191c8: 0x1600ffe9
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119170; return;
    }
label_1191d0:
    // 0x1191d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1191d4: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x1191dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_1191dc
// Address: 0x1191dc - 0x1191e8

void entry_1191dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1191dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1191e0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1191e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1191e8
// Address: 0x1191e8 - 0x1191f4

void entry_1191e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1191e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1191ec: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1191f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1191f4
// Address: 0x1191f4 - 0x119218

void entry_1191f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1191f4) {
        switch (ctx->pc) {
            case 0x1191f8: ctx->pc = 0; goto label_1191f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1191f4: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1191f8:
    // 0x1191f8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1191fc: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119200: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119204: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119208: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11920c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119210: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalAnd__FP5CPairP6CFrame
// Address: 0x119218 - 0x119248

void entry_119248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119248: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11924c: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x119254);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_119254
// Address: 0x119254 - 0x11927c

void entry_119254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119254) {
        switch (ctx->pc) {
            case 0x119270: ctx->pc = 0; goto label_119270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119254: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119258: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x11925c: 0x1200001d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1192D4; return;
    }
    // 0x119264: 0x2414001b
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 27));
    // 0x119268: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11926c: 0x0
    // NOP
label_119270:
    // 0x119270: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119274: 0xc046820
    SET_GPR_U32(ctx, 31, 0x11927c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11927c
// Address: 0x11927c - 0x119288

void entry_11927c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11927c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119280: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119288);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119288
// Address: 0x119288 - 0x119294

void entry_119288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119288: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11928c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119294);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119294
// Address: 0x119294 - 0x1192b8

void entry_119294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119294: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x119298: 0x5454000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x1192CC; return;
    }
    // 0x1192a0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1192a4: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x1192CC; return;
    }
    // 0x1192ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1192b0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1192b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1192b8
// Address: 0x1192b8 - 0x1192c4

void entry_1192b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1192b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1192bc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1192c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1192c4
// Address: 0x1192c4 - 0x1192e0

void entry_1192c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1192c4) {
        switch (ctx->pc) {
            case 0x1192cc: ctx->pc = 0; goto label_1192cc;
            case 0x1192d4: ctx->pc = 0; goto label_1192d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1192c4: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1192F0; return;
    }
label_1192cc:
    // 0x1192cc: 0x1600ffe8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119270; return;
    }
label_1192d4:
    // 0x1192d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1192d8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x1192e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1192e0
// Address: 0x1192e0 - 0x1192ec

void entry_1192e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1192e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1192e4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1192ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1192ec
// Address: 0x1192ec - 0x119310

void entry_1192ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1192ec) {
        switch (ctx->pc) {
            case 0x1192f0: ctx->pc = 0; goto label_1192f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1192ec: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1192f0:
    // 0x1192f0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1192f4: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1192f8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1192fc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119300: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119304: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119308: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalCond__FP5CPairP6CFrame
// Address: 0x119310 - 0x119350

void entry_119350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119350: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119354: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11935c);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11935c
// Address: 0x11935c - 0x119368

void entry_11935c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11935c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119360: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x119368);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_119368
// Address: 0x119368 - 0x1193ac

void entry_119368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119368) {
        switch (ctx->pc) {
            case 0x119388: ctx->pc = 0; goto label_119388;
            case 0x11939c: ctx->pc = 0; goto label_11939c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119368: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11936c: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x119370: 0x12000036
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11944C; return;
    }
    // 0x119378: 0x27b30020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 32));
    // 0x11937c: 0x2417001b
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 27));
    // 0x119380: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119384: 0x0
    // NOP
label_119388:
    // 0x119388: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11938c: 0x145e0003
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 30)) {
        goto label_11939c;
    }
    // 0x119394: 0x10000018
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1193f8(rdram, ctx, runtime); return;
    }
label_11939c:
    // 0x11939c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1193a0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1193a4: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1193ac);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1193ac
// Address: 0x1193ac - 0x1193b8

void entry_1193ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1193ac: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1193b0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1193b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1193b8
// Address: 0x1193b8 - 0x1193c4

void entry_1193b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1193b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1193bc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1193c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1193c4
// Address: 0x1193c4 - 0x1193f8

void entry_1193c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1193c4) {
        switch (ctx->pc) {
            case 0x1193dc: ctx->pc = 0; goto label_1193dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1193c4: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1193c8: 0x54570004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1193dc;
    }
    // 0x1193d0: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1193d4: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1193dc;
    }
label_1193dc:
    // 0x1193dc: 0x52400019
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x119444; return;
    }
    // 0x1193e4: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1193e8: 0x14400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1193f8(rdram, ctx, runtime); return;
    }
    // 0x1193f0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1193f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1193f8
// Address: 0x1193f8 - 0x11941c

void entry_1193f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1193f8) {
        switch (ctx->pc) {
            case 0x119410: ctx->pc = 0; goto label_119410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1193f8: 0x52400012
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x119444; return;
    }
    // 0x119400: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x119404: 0x1220000e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119440; return;
    }
    // 0x11940c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_119410:
    // 0x119410: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x119414: 0xc046820
    SET_GPR_U32(ctx, 31, 0x11941c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11941c
// Address: 0x11941c - 0x119428

void entry_11941c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11941c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119420: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119428);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119428
// Address: 0x119428 - 0x119434

void entry_119428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119428: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11942c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119434);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119434
// Address: 0x119434 - 0x119458

void entry_119434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119434) {
        switch (ctx->pc) {
            case 0x119440: ctx->pc = 0; goto label_119440;
            case 0x119444: ctx->pc = 0; goto label_119444;
            case 0x11944c: ctx->pc = 0; goto label_11944c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119434: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x119438: 0x1620fff5
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119410; return;
    }
label_119440:
    // 0x119440: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_119444:
    // 0x119444: 0x5600ffd0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x119388; return;
    }
label_11944c:
    // 0x11944c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119450: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119458);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119458
// Address: 0x119458 - 0x119464

void entry_119458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119458: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11945c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119464);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119464
// Address: 0x119464 - 0x119470

void entry_119464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119464: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119468: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119470);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119470
// Address: 0x119470 - 0x1194a8

void entry_119470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119470: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x119474: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x119478: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x11947c: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x119480: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x119484: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x119488: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11948c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119490: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119494: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119498: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11949c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1194a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1194a8; return;
}


// Function: RefEvalCase__FP5CPairP6CFrame
// Address: 0x1194a8 - 0x1194f0

void entry_1194f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1194f0) {
        switch (ctx->pc) {
            case 0x119500: ctx->pc = 0; goto label_119500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1194f0: 0x27be0020
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1194f4: 0x27b50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1194f8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1194fc: 0x0
    // NOP
label_119500:
    // 0x119500: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119504: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11950c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11950c
// Address: 0x11950c - 0x11951c

void entry_11950c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11950c: 0x1632fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x119500; return;
    }
    // 0x119514: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11951c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11951c
// Address: 0x11951c - 0x119528

void entry_11951c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11951c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119520: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x119528);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_119528
// Address: 0x119528 - 0x119540

void entry_119528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119528: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x11952c: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x119530: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119534: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x119538: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119540);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119540
// Address: 0x119540 - 0x11954c

void entry_119540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119540: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119544: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11954c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11954c
// Address: 0x11954c - 0x119558

void entry_11954c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11954c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119550: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119558);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119558
// Address: 0x119558 - 0x119598

void entry_119558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119558) {
        switch (ctx->pc) {
            case 0x119568: ctx->pc = 0; goto label_119568;
            case 0x119590: ctx->pc = 0; goto label_119590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119558: 0x8e130008
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x11955c: 0x1260003a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119648; return;
    }
    // 0x119564: 0x8e710004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_119568:
    // 0x119568: 0x2403000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 10));
    // 0x11956c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x119570: 0x1043001e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1195EC; return;
    }
    // 0x119578: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11957c: 0x1200001b
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1195EC; return;
    }
    // 0x119584: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119588: 0x2417001b
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 27));
    // 0x11958c: 0x27a40018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 24));
label_119590:
    // 0x119590: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119598);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119598
// Address: 0x119598 - 0x1195ac

void entry_119598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119598: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11959c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1195a0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1195a4: 0xc044eaa
    SET_GPR_U32(ctx, 31, 0x1195ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    RefOpEqv__FiP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1195ac
// Address: 0x1195ac - 0x1195b8

void entry_1195ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1195ac: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1195b0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1195b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1195b8
// Address: 0x1195b8 - 0x1195c4

void entry_1195b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1195b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1195bc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1195c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1195c4
// Address: 0x1195c4 - 0x119614

void entry_1195c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1195c4) {
        switch (ctx->pc) {
            case 0x1195e4: ctx->pc = 0; goto label_1195e4;
            case 0x1195ec: ctx->pc = 0; goto label_1195ec;
            case 0x119608: ctx->pc = 0; goto label_119608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1195c4: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1195c8: 0x54570006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1195e4;
    }
    // 0x1195d0: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1195d4: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1195e4;
    }
    // 0x1195dc: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1195e0: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1195e4:
    // 0x1195e4: 0x1600ffea
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 24));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119590; return;
    }
label_1195ec:
    // 0x1195ec: 0x52800013
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 8)));
        ctx->pc = 0x11963C; return;
    }
    // 0x1195f4: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1195f8: 0x1220000f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119638; return;
    }
    // 0x119600: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119604: 0x0
    // NOP
label_119608:
    // 0x119608: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11960c: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119614);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119614
// Address: 0x119614 - 0x119620

void entry_119614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119614: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119618: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119620);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119620
// Address: 0x119620 - 0x11962c

void entry_119620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119620: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119624: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11962c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11962c
// Address: 0x11962c - 0x119654

void entry_11962c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11962c) {
        switch (ctx->pc) {
            case 0x119638: ctx->pc = 0; goto label_119638;
            case 0x11963c: ctx->pc = 0; goto label_11963c;
            case 0x119648: ctx->pc = 0; goto label_119648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11962c: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x119630: 0x1620fff5
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119608; return;
    }
label_119638:
    // 0x119638: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11963c:
    // 0x11963c: 0x5660ffca
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x119568; return;
    }
    // 0x119644: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
label_119648:
    // 0x119648: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11964c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119654);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119654
// Address: 0x119654 - 0x119660

void entry_119654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119654: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x119658: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119660);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119660
// Address: 0x119660 - 0x11967c

void entry_119660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119660) {
        switch (ctx->pc) {
            case 0x119670: ctx->pc = 0; goto label_119670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119660: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119664: 0x10500009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x11968C; return;
    }
    // 0x11966c: 0x2610fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
label_119670:
    // 0x119670: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x119674: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11967c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11967c
// Address: 0x11967c - 0x119694

void entry_11967c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11967c) {
        switch (ctx->pc) {
            case 0x11968c: ctx->pc = 0; goto label_11968c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11967c: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119680: 0x1470fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x119670; return;
    }
    // 0x119688: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_11968c:
    // 0x11968c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119694);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119694
// Address: 0x119694 - 0x1196c8

void entry_119694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119694: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119698: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x11969c: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1196a0: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1196a4: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1196a8: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1196ac: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1196b0: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1196b4: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1196b8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1196bc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1196c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalLet__FP5CPairP6CFrame
// Address: 0x1196c8 - 0x119708

void entry_119708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119708: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x119710);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119710
// Address: 0x119710 - 0x11971c

void entry_119710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119710: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x119714: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11971c);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11971c
// Address: 0x11971c - 0x11973c

void entry_11971c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11971c: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119720: 0x2404001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 30));
    // 0x119724: 0x8c750008
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x119728: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x11972c: 0x14440027
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1197CC; return;
    }
    // 0x119734: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x11973c);
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11973c
// Address: 0x11973c - 0x119768

void entry_11973c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11973c) {
        switch (ctx->pc) {
            case 0x119758: ctx->pc = 0; goto label_119758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11973c: 0x8eb20004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x119740: 0x1240001d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1197B8; return;
    }
    // 0x119748: 0x27b60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11974c: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x119750: 0x8e500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x119754: 0x0
    // NOP
label_119758:
    // 0x119758: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11975c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119760: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119768);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119768
// Address: 0x119768 - 0x119774

void entry_119768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119768: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11976c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119774);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119774
// Address: 0x119774 - 0x119780

void entry_119774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119774: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119778: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119780);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119780
// Address: 0x119780 - 0x119794

void entry_119780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119780: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119784: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x119788: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11978c: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x119794);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119794
// Address: 0x119794 - 0x1197a0

void entry_119794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119794: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x119798: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1197a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1197a0
// Address: 0x1197a0 - 0x1197ac

void entry_1197a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1197a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1197a4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1197ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1197ac
// Address: 0x1197ac - 0x1197c4

void entry_1197ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1197ac) {
        switch (ctx->pc) {
            case 0x1197b8: ctx->pc = 0; goto label_1197b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1197ac: 0x8e520008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1197b0: 0x5640ffe9
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x119758; return;
    }
label_1197b8:
    // 0x1197b8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1197bc: 0xc0468ca
    SET_GPR_U32(ctx, 31, 0x1197c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSingleParent__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1197c4
// Address: 0x1197c4 - 0x1197ec

void entry_1197c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1197c4) {
        switch (ctx->pc) {
            case 0x1197cc: ctx->pc = 0; goto label_1197cc;
            case 0x1197d0: ctx->pc = 0; goto label_1197d0;
            case 0x1197e0: ctx->pc = 0; goto label_1197e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1197c4: 0x10000002
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1197d0;
    }
label_1197cc:
    // 0x1197cc: 0x8eb00008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 21), 8)));
label_1197d0:
    // 0x1197d0: 0x1200000f
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119810; return;
    }
    // 0x1197d8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1197dc: 0x0
    // NOP
label_1197e0:
    // 0x1197e0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1197e4: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1197ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1197ec
// Address: 0x1197ec - 0x1197f8

void entry_1197ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1197ec: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1197f0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1197f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1197f8
// Address: 0x1197f8 - 0x119804

void entry_1197f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1197f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1197fc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119804);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119804
// Address: 0x119804 - 0x11981c

void entry_119804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119804) {
        switch (ctx->pc) {
            case 0x119810: ctx->pc = 0; goto label_119810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119804: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x119808: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1197E0; return;
    }
label_119810:
    // 0x119810: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119814: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11981c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11981c
// Address: 0x11981c - 0x119828

void entry_11981c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11981c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x119820: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119828);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119828
// Address: 0x119828 - 0x119834

void entry_119828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119828: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11982c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119834);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119834
// Address: 0x119834 - 0x119840

void entry_119834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119834: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119838: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119840);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119840
// Address: 0x119840 - 0x119878

void entry_119840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119840: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x119844: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x119848: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x11984c: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x119850: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x119854: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x119858: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11985c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x119860: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119864: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119868: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11986c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x119874: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x119878; return;
}


// Function: RefEvalWhile__FP5CPairP6CFrame
// Address: 0x119878 - 0x1198a8

void entry_1198a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1198a8) {
        switch (ctx->pc) {
            case 0x1198c0: ctx->pc = 0; goto label_1198c0;
            case 0x1198c4: ctx->pc = 0; goto label_1198c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1198a8: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1198ac: 0x8c720008
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1198b0: 0x8e530008
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1198b4: 0x1000000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1198e4(rdram, ctx, runtime); return;
    }
    // 0x1198bc: 0x0
    // NOP
label_1198c0:
    // 0x1198c0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1198c4:
    // 0x1198c4: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1198cc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1198cc
// Address: 0x1198cc - 0x1198d8

void entry_1198cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1198cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1198d0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1198d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1198d8
// Address: 0x1198d8 - 0x1198e4

void entry_1198d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1198d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1198dc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1198e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1198e4
// Address: 0x1198e4 - 0x1198f4

void entry_1198e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1198e4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1198e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1198ec: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1198f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1198f4
// Address: 0x1198f4 - 0x119900

void entry_1198f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1198f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1198f8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119900);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119900
// Address: 0x119900 - 0x11990c

void entry_119900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119900: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119904: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11990c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11990c
// Address: 0x11990c - 0x119934

void entry_11990c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11990c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x119910: 0x2402001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    // 0x119914: 0x1462ffea
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1198C0; return;
    }
    // 0x11991c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x119920: 0x5440ffe8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
        ctx->pc = 0x1198C4; return;
    }
    // 0x119928: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11992c: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x119934);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_119934
// Address: 0x119934 - 0x119940

void entry_119934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119934: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119938: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119940);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119940
// Address: 0x119940 - 0x11994c

void entry_119940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119940: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119944: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11994c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11994c
// Address: 0x11994c - 0x119970

void entry_11994c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11994c: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x119950: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x119954: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119958: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11995c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119960: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119964: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119968: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalLambda__FP5CPairP6CFrame
// Address: 0x119970 - 0x11999c

void entry_11999c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11999c: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1199a0: 0x8c700008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1199a4: 0xc046bf2
    SET_GPR_U32(ctx, 31, 0x1199ac);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    PprocNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1199ac
// Address: 0x1199ac - 0x119a1c

void entry_1199ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1199ac) {
        switch (ctx->pc) {
            case 0x1199c8: ctx->pc = 0; goto label_1199c8;
            case 0x1199cc: ctx->pc = 0; goto label_1199cc;
            case 0x1199e8: ctx->pc = 0; goto label_1199e8;
            case 0x1199fc: ctx->pc = 0; goto label_1199fc;
            case 0x119a00: ctx->pc = 0; goto label_119a00;
            case 0x119a08: ctx->pc = 0; goto label_119a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1199ac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1199b0: 0xac910000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 17));
    // 0x1199b4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1199b8: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_1199c8;
    }
    // 0x1199c0: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1199cc;
    }
label_1199c8:
    // 0x1199c8: 0xac820004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 2));
label_1199cc:
    // 0x1199cc: 0x8c830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1199d0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1199d4: 0xac920010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 18));
    // 0x1199d8: 0x1060000b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_119a08;
    }
    // 0x1199e0: 0x24050013
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1199e4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
label_1199e8:
    // 0x1199e8: 0x54450004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8)));
        goto label_1199fc;
    }
    // 0x1199f0: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1199f4: 0x10000002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_119a00;
    }
label_1199fc:
    // 0x1199fc: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_119a00:
    // 0x119a00: 0x5460fff9
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
        goto label_1199e8;
    }
label_119a08:
    // 0x119a08: 0xac860008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 6));
    // 0x119a0c: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x119a10: 0xac87000c
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 7));
    // 0x119a14: 0xc046dc0
    SET_GPR_U32(ctx, 31, 0x119a1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetProc__4CRefP5CProc(rdram, ctx, runtime); return;
}


// Function: entry_119a1c
// Address: 0x119a1c - 0x119a28

void entry_119a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119a1c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119a20: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119a28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119a28
// Address: 0x119a28 - 0x119a34

void entry_119a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119a28: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119a2c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119a34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119a34
// Address: 0x119a34 - 0x119a58

void entry_119a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119a34: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119a38: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119a3c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119a40: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119a44: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119a48: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x119a4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x119a54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x119a58; return;
}


// Function: RefEvalLambdaBody__FP5CPairP6CFrame
// Address: 0x119a58 - 0x119a84

void entry_119a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119a84) {
        switch (ctx->pc) {
            case 0x119a90: ctx->pc = 0; goto label_119a90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119a84: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119a88: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119a8c: 0x0
    // NOP
label_119a90:
    // 0x119a90: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x119a94: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119a9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119a9c
// Address: 0x119a9c - 0x119aa8

void entry_119a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119a9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119aa0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119aa8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119aa8
// Address: 0x119aa8 - 0x119ab4

void entry_119aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119aa8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119aac: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119ab4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119ab4
// Address: 0x119ab4 - 0x119acc

void entry_119ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119ab4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x119ab8: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x119A90; return;
    }
    // 0x119ac0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119ac4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119acc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119acc
// Address: 0x119acc - 0x119ad8

void entry_119acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119acc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119ad0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119ad8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119ad8
// Address: 0x119ad8 - 0x119af8

void entry_119ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119ad8: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119adc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119ae0: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119ae4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119ae8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119aec: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119af0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalBegin__FP5CPairP6CFrame
// Address: 0x119af8 - 0x119b24

void entry_119b24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119b24: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119b28: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x119b30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_119b30
// Address: 0x119b30 - 0x119b54

void entry_119b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119b30) {
        switch (ctx->pc) {
            case 0x119b48: ctx->pc = 0; goto label_119b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119b30: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119b34: 0x8c500008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x119b38: 0x1200000f
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119B78; return;
    }
    // 0x119b40: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119b44: 0x0
    // NOP
label_119b48:
    // 0x119b48: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x119b4c: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119b54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119b54
// Address: 0x119b54 - 0x119b60

void entry_119b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119b54: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119b58: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119b60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119b60
// Address: 0x119b60 - 0x119b6c

void entry_119b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119b60: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119b64: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119b6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119b6c
// Address: 0x119b6c - 0x119b84

void entry_119b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119b6c) {
        switch (ctx->pc) {
            case 0x119b78: ctx->pc = 0; goto label_119b78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119b6c: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x119b70: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x119B48; return;
    }
label_119b78:
    // 0x119b78: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119b7c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119b84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119b84
// Address: 0x119b84 - 0x119b90

void entry_119b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119b84: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119b88: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119b90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119b90
// Address: 0x119b90 - 0x119bb0

void entry_119b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119b90: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119b94: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x119b98: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x119b9c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x119ba0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x119ba4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x119ba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEvalApply__FP5CPairP6CFrame
// Address: 0x119bb0 - 0x119bf8

void entry_119bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119bf8: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x119c00);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119c00
// Address: 0x119c00 - 0x119c14

void entry_119c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119c00) {
        switch (ctx->pc) {
            case 0x119c08: ctx->pc = 0; goto label_119c08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119c00: 0x27b50120
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 288));
    // 0x119c04: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
label_119c08:
    // 0x119c08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119c0c: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x119c14);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119c14
// Address: 0x119c14 - 0x119c30

void entry_119c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119c14: 0x1632fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x119C08; return;
    }
    // 0x119c1c: 0x8e700004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x119c20: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119c24: 0x8fa60144
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x119c28: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119c30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119c30
// Address: 0x119c30 - 0x119c3c

void entry_119c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119c30: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119c34: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119c3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119c3c
// Address: 0x119c3c - 0x119c48

void entry_119c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119c3c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119c40: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119c48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119c48
// Address: 0x119c48 - 0x119ce4

void entry_119c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119c48) {
        switch (ctx->pc) {
            case 0x119c80: ctx->pc = 0; goto label_119c80;
            case 0x119c9c: ctx->pc = 0; goto label_119c9c;
            case 0x119ca4: ctx->pc = 0; goto label_119ca4;
            case 0x119cd0: ctx->pc = 0; goto label_119cd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119c48: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x119c4c: 0x2402001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    // 0x119c50: 0x1462000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_119c80;
    }
    // 0x119c58: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x119c5c: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x119c60: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x119c64: 0x641818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x119c68: 0x24429958
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941016));
    // 0x119c6c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x119c70: 0xafa3014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 3));
    // 0x119c74: 0x8c760004
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x119c78: 0x1000000a
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_119ca4;
    }
label_119c80:
    // 0x119c80: 0x14620006
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_119c9c;
    }
    // 0x119c88: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x119c8c: 0xf02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x119c90: 0xafa20150
    WRITE32(ADD32(GPR_U32(ctx, 29), 336), GPR_U32(ctx, 2));
    // 0x119c94: 0x10000003
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_119ca4;
    }
label_119c9c:
    // 0x119c9c: 0x8e9e000c
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x119ca0: 0x8e960008
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 20), 8)));
label_119ca4:
    // 0x119ca4: 0x1e102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 30)));
    // 0x119ca8: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x119cac: 0x2c21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x119cb0: 0x2c0b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x119cb4: 0xafa20148
    WRITE32(ADD32(GPR_U32(ctx, 29), 328), GPR_U32(ctx, 2));
    // 0x119cb8: 0x1ae00017
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x119D18; return;
    }
    // 0x119cc0: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119cc4: 0x2a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119cc8: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x119ccc: 0x0
    // NOP
label_119cd0:
    // 0x119cd0: 0x8fa60144
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x119cd4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119cd8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119cdc: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119ce4);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119ce4
// Address: 0x119ce4 - 0x119cf0

void entry_119ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119ce4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x119ce8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119cf0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119cf0
// Address: 0x119cf0 - 0x119cfc

void entry_119cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119cf0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119cf4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119cfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119cfc
// Address: 0x119cfc - 0x119d08

void entry_119cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119cfc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119d00: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119d08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119d08
// Address: 0x119d08 - 0x119d40

void entry_119d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119d08) {
        switch (ctx->pc) {
            case 0x119d18: ctx->pc = 0; goto label_119d18;
            case 0x119d38: ctx->pc = 0; goto label_119d38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119d08: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x119d0c: 0x256102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 22)));
    // 0x119d10: 0x1440ffef
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119CD0; return;
    }
label_119d18:
    // 0x119d18: 0x13c00028
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_119dbc(rdram, ctx, runtime); return;
    }
    // 0x119d20: 0x12b0c0
    SET_GPR_U32(ctx, 22, SLL32(GPR_U32(ctx, 18), 3));
    // 0x119d24: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x119d28: 0x12200019
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119D90; return;
    }
    // 0x119d30: 0x2a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119d34: 0x0
    // NOP
label_119d38:
    // 0x119d38: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x119d40);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_119d40
// Address: 0x119d40 - 0x119d54

void entry_119d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119d40: 0x8fa60144
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x119d44: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x119d48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119d4c: 0xc046820
    SET_GPR_U32(ctx, 31, 0x119d54);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119d54
// Address: 0x119d54 - 0x119d60

void entry_119d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119d54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x119d58: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119d60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119d60
// Address: 0x119d60 - 0x119d6c

void entry_119d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119d60: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119d64: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119d6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119d6c
// Address: 0x119d6c - 0x119da4

void entry_119d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119d6c) {
        switch (ctx->pc) {
            case 0x119d80: ctx->pc = 0; goto label_119d80;
            case 0x119d84: ctx->pc = 0; goto label_119d84;
            case 0x119d90: ctx->pc = 0; goto label_119d90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119d6c: 0x52400004
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_119d80;
    }
    // 0x119d74: 0xae500008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 16));
    // 0x119d78: 0x10000002
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_119d84;
    }
label_119d80:
    // 0x119d80: 0x240a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_119d84:
    // 0x119d84: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x119d88: 0x1620ffeb
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119D38; return;
    }
label_119d90:
    // 0x119d90: 0x12800006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119DAC; return;
    }
    // 0x119d98: 0x2ddb021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 29)));
    // 0x119d9c: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x119da4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 32));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_119da4
// Address: 0x119da4 - 0x119dbc

void entry_119da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119da4) {
        switch (ctx->pc) {
            case 0x119dac: ctx->pc = 0; goto label_119dac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119da4: 0x10000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119DC0; return;
    }
label_119dac:
    // 0x119dac: 0x2ddb021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 29)));
    // 0x119db0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x119db4: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x119dbc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 32));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_119dbc
// Address: 0x119dbc - 0x119e14

void entry_119dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119dbc) {
        switch (ctx->pc) {
            case 0x119dc0: ctx->pc = 0; goto label_119dc0;
            case 0x119de4: ctx->pc = 0; goto label_119de4;
            case 0x119df8: ctx->pc = 0; goto label_119df8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119dbc: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_119dc0:
    // 0x119dc0: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x119dc4: 0x10620015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x119E1C; return;
    }
    // 0x119dcc: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_119de4;
    }
    // 0x119dd4: 0x10620008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_119df8;
    }
    // 0x119ddc: 0x1000004f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119F1C; return;
    }
label_119de4:
    // 0x119de4: 0x24020021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    // 0x119de8: 0x1062003d
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x119EE0; return;
    }
    // 0x119df0: 0x1000004a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119F1C; return;
    }
label_119df8:
    // 0x119df8: 0x8fa3014c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x119dfc: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x119e00: 0x8fa70144
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x119e04: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119e08: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x119e0c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x119e14);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_119e14
// Address: 0x119e14 - 0x119e24

void entry_119e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119e14) {
        switch (ctx->pc) {
            case 0x119e1c: ctx->pc = 0; goto label_119e1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119e14: 0x1000002b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119EC4; return;
    }
label_119e1c:
    // 0x119e1c: 0xc04698c
    SET_GPR_U32(ctx, 31, 0x119e24);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    PframeNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_119e24
// Address: 0x119e24 - 0x119e34

void entry_119e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119e24: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x119e28: 0x8e850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x119e2c: 0xc0468ca
    SET_GPR_U32(ctx, 31, 0x119e34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SetSingleParent__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119e34
// Address: 0x119e34 - 0x119e58

void entry_119e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119e34) {
        switch (ctx->pc) {
            case 0x119e50: ctx->pc = 0; goto label_119e50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119e34: 0x8fa20148
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 328)));
    // 0x119e38: 0x1840001d
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x119EB0; return;
    }
    // 0x119e40: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x119e44: 0x24170013
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 19));
    // 0x119e48: 0x27b30130
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 304));
    // 0x119e4c: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
label_119e50:
    // 0x119e50: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x119e58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119e58
// Address: 0x119e58 - 0x119e78

void entry_119e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119e58) {
        switch (ctx->pc) {
            case 0x119e64: ctx->pc = 0; goto label_119e64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119e58: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x119e5c: 0x50770001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 23)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_119e64;
    }
label_119e64:
    // 0x119e64: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119e68: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x119e6c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119e70: 0xc0468d6
    SET_GPR_U32(ctx, 31, 0x119e78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    RefAddBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119e78
// Address: 0x119e78 - 0x119e88

void entry_119e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119e78: 0x26310008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 8));
    // 0x119e7c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119e80: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119e88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119e88
// Address: 0x119e88 - 0x119e98

void entry_119e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119e88: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x119e8c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x119e90: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119e98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119e98
// Address: 0x119e98 - 0x119ea8

void entry_119e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119e98: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x119e9c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119ea0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119ea8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119ea8
// Address: 0x119ea8 - 0x119ec0

void entry_119ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119ea8) {
        switch (ctx->pc) {
            case 0x119eb0: ctx->pc = 0; goto label_119eb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119ea8: 0x1640ffe9
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x119E50; return;
    }
label_119eb0:
    // 0x119eb0: 0x8e850010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x119eb4: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x119eb8: 0xc046696
    SET_GPR_U32(ctx, 31, 0x119ec0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    RefEvalLambdaBody__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_119ec0
// Address: 0x119ec0 - 0x119ecc

void entry_119ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119ec0) {
        switch (ctx->pc) {
            case 0x119ec4: ctx->pc = 0; goto label_119ec4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119ec0: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
label_119ec4:
    // 0x119ec4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119ecc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119ecc
// Address: 0x119ecc - 0x119ed8

void entry_119ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119ecc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119ed0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119ed8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119ed8
// Address: 0x119ed8 - 0x119efc

void entry_119ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119ed8) {
        switch (ctx->pc) {
            case 0x119ee0: ctx->pc = 0; goto label_119ee0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119ed8: 0x1000000f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x119F18; return;
    }
label_119ee0:
    // 0x119ee0: 0x8fa30150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x119ee4: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x119ee8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119eec: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x119ef0: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x119ef4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x119efc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_119efc
// Address: 0x119efc - 0x119f08

void entry_119efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119efc: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119f00: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x119f08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119f08
// Address: 0x119f08 - 0x119f14

void entry_119f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119f08: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x119f0c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119f14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119f14
// Address: 0x119f14 - 0x119f24

void entry_119f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119f14) {
        switch (ctx->pc) {
            case 0x119f18: ctx->pc = 0; goto label_119f18;
            case 0x119f1c: ctx->pc = 0; goto label_119f1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119f14: 0x8fa40140
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 320)));
label_119f18:
    // 0x119f18: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
label_119f1c:
    // 0x119f1c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x119f24);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_119f24
// Address: 0x119f24 - 0x119f44

void entry_119f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119f24) {
        switch (ctx->pc) {
            case 0x119f38: ctx->pc = 0; goto label_119f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119f24: 0x27a20020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 32));
    // 0x119f28: 0x1050000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x119F54; return;
    }
    // 0x119f30: 0x2610fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    // 0x119f34: 0x0
    // NOP
label_119f38:
    // 0x119f38: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x119f3c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119f44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119f44
// Address: 0x119f44 - 0x119f5c

void entry_119f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x119f44) {
        switch (ctx->pc) {
            case 0x119f54: ctx->pc = 0; goto label_119f54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x119f44: 0x27a30020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 32));
    // 0x119f48: 0x1470fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x119F38; return;
    }
    // 0x119f50: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
label_119f54:
    // 0x119f54: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119f5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119f5c
// Address: 0x119f5c - 0x119f68

void entry_119f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119f5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x119f60: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x119f68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_119f68
// Address: 0x119f68 - 0x119fa0

void entry_119f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119f68: 0x8fa20140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x119f6c: 0x7bbf01f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x119f70: 0x7bbe01e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x119f74: 0x7bb701d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x119f78: 0x7bb601c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x119f7c: 0x7bb501b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x119f80: 0x7bb401a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x119f84: 0x7bb30190
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x119f88: 0x7bb20180
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x119f8c: 0x7bb10170
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x119f90: 0x7bb00160
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x119f94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 512));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x119f9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x119fa0; return;
}


// Function: RefEvalImport__FP5CPairP6CFrame
// Address: 0x119fa0 - 0x119fd4

void entry_119fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119fd4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x119fd8: 0x8e455710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x119fdc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x119fe0: 0x8c510004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x119fe4: 0xc0704e4
    SET_GPR_U32(ctx, 31, 0x119fec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PframeFromIsplice__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_119fec
// Address: 0x119fec - 0x11a008

void entry_119fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x119fec: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
        ctx->pc = 0x11A030; return;
    }
    // 0x119ff4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x119ff8: 0x8e465710
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x119ffc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a000: 0xc0704fa
    SET_GPR_U32(ctx, 31, 0x11a008);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEvalModule__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_11a008
// Address: 0x11a008 - 0x11a014

void entry_11a008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a008: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a00c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a014);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a014
// Address: 0x11a014 - 0x11a020

void entry_11a014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a014: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a018: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a020);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a020
// Address: 0x11a020 - 0x11a02c

void entry_11a020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a020: 0x8e455710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x11a024: 0xc0704e4
    SET_GPR_U32(ctx, 31, 0x11a02c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PframeFromIsplice__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_11a02c
// Address: 0x11a02c - 0x11a038

void entry_11a02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a02c) {
        switch (ctx->pc) {
            case 0x11a030: ctx->pc = 0; goto label_11a030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a02c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_11a030:
    // 0x11a030: 0xc0468ce
    SET_GPR_U32(ctx, 31, 0x11a038);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AddParent__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a038
// Address: 0x11a038 - 0x11a044

void entry_11a038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a038: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a03c: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11a044);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11a044
// Address: 0x11a044 - 0x11a050

void entry_11a044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a044: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a048: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11a050);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a050
// Address: 0x11a050 - 0x11a05c

void entry_11a050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a050: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a054: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a05c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a05c
// Address: 0x11a05c - 0x11a080

void entry_11a05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a05c: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11a060: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11a064: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11a068: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11a06c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11a070: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11a074: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a078: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefEval__FP5CPairP6CFrame
// Address: 0x11a080 - 0x11a0ac

void entry_11a0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a0ac: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11a0b0: 0x2c620022
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 34));
    // 0x11a0b4: 0x1040008d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11a2ec(rdram, ctx, runtime); return;
    }
    // 0x11a0bc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11a0c0: 0x24429210
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294939152));
    // 0x11a0c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11a0c8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11a0cc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11a0d4: 0x10000069
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A27C; return;
    }
    // 0x11a0dc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a0e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a0e4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a0e8: 0xc046352
    SET_GPR_U32(ctx, 31, 0x11a0f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalSymbol__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a0f0
// Address: 0x11a0f0 - 0x11a13c

void entry_11a0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a0f0: 0x1000006c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a0f8: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11a0fc: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x11a100: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x11a104: 0x2c830011
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 17));
    // 0x11a108: 0x1060006d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2C0; return;
    }
    // 0x11a110: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x11a114: 0x244292a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294939296));
    // 0x11a118: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11a11c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11a120: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11a128: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a12c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a130: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a134: 0xc04636e
    SET_GPR_U32(ctx, 31, 0x11a13c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalSet__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a13c
// Address: 0x11a13c - 0x11a158

void entry_11a13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a13c: 0x10000059
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a144: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a148: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a14c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a150: 0xc0463a0
    SET_GPR_U32(ctx, 31, 0x11a158);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalDefine__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a158
// Address: 0x11a158 - 0x11a174

void entry_11a158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a158: 0x10000052
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a160: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a164: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a168: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a16c: 0xc0463d2
    SET_GPR_U32(ctx, 31, 0x11a174);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalAssert__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a174
// Address: 0x11a174 - 0x11a190

void entry_11a174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a174: 0x1000004b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a17c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a180: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a184: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a188: 0xc04640c
    SET_GPR_U32(ctx, 31, 0x11a190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalIf__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a190
// Address: 0x11a190 - 0x11a1ac

void entry_11a190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a190: 0x10000044
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a198: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a19c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a1a0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a1a4: 0xc04644a
    SET_GPR_U32(ctx, 31, 0x11a1ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalOr__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a1ac
// Address: 0x11a1ac - 0x11a1c8

void entry_11a1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a1ac: 0x1000003d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a1b4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a1b8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a1bc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a1c0: 0xc046486
    SET_GPR_U32(ctx, 31, 0x11a1c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalAnd__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a1c8
// Address: 0x11a1c8 - 0x11a1e4

void entry_11a1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a1c8: 0x10000036
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a1d0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a1d4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a1d8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a1dc: 0xc0464c4
    SET_GPR_U32(ctx, 31, 0x11a1e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalCond__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a1e4
// Address: 0x11a1e4 - 0x11a200

void entry_11a1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a1e4: 0x1000002f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a1ec: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a1f0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a1f4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a1f8: 0xc04652a
    SET_GPR_U32(ctx, 31, 0x11a200);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalCase__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a200
// Address: 0x11a200 - 0x11a21c

void entry_11a200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a200: 0x10000028
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a208: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a20c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a210: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a214: 0xc0465b2
    SET_GPR_U32(ctx, 31, 0x11a21c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalLet__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a21c
// Address: 0x11a21c - 0x11a238

void entry_11a21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a21c: 0x10000021
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a224: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a228: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a22c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a230: 0xc04661e
    SET_GPR_U32(ctx, 31, 0x11a238);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalWhile__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a238
// Address: 0x11a238 - 0x11a254

void entry_11a238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a238: 0x1000001a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a240: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a244: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a248: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a24c: 0xc0466be
    SET_GPR_U32(ctx, 31, 0x11a254);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalBegin__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a254
// Address: 0x11a254 - 0x11a270

void entry_11a254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a254: 0x10000013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a25c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a260: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a264: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a268: 0xc04665c
    SET_GPR_U32(ctx, 31, 0x11a270);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalLambda__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a270
// Address: 0x11a270 - 0x11a284

void entry_11a270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a270) {
        switch (ctx->pc) {
            case 0x11a27c: ctx->pc = 0; goto label_11a27c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a270: 0x1000000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2A4; return;
    }
    // 0x11a278: 0x8ca50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
label_11a27c:
    // 0x11a27c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a284);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a284
// Address: 0x11a284 - 0x11a2a0

void entry_11a284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a284: 0x1000001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2F0; return;
    }
    // 0x11a28c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a290: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a294: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a298: 0xc0467e8
    SET_GPR_U32(ctx, 31, 0x11a2a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalImport__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a2a0
// Address: 0x11a2a0 - 0x11a2ac

void entry_11a2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a2a0) {
        switch (ctx->pc) {
            case 0x11a2a4: ctx->pc = 0; goto label_11a2a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a2a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_11a2a4:
    // 0x11a2a4: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a2ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a2ac
// Address: 0x11a2ac - 0x11a2b8

void entry_11a2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a2ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a2b0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a2b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a2b8
// Address: 0x11a2b8 - 0x11a2d4

void entry_11a2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a2b8) {
        switch (ctx->pc) {
            case 0x11a2c0: ctx->pc = 0; goto label_11a2c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a2b8: 0x1000000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A2F0; return;
    }
label_11a2c0:
    // 0x11a2c0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11a2c4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a2c8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11a2cc: 0xc0466ec
    SET_GPR_U32(ctx, 31, 0x11a2d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RefEvalApply__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a2d4
// Address: 0x11a2d4 - 0x11a2e0

void entry_11a2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a2d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a2d8: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a2e0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a2e0
// Address: 0x11a2e0 - 0x11a2ec

void entry_11a2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a2e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a2e4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a2ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a2ec
// Address: 0x11a2ec - 0x11a2f8

void entry_11a2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a2ec) {
        switch (ctx->pc) {
            case 0x11a2f0: ctx->pc = 0; goto label_11a2f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a2ec: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_11a2f0:
    // 0x11a2f0: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11a2f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a2f8
// Address: 0x11a2f8 - 0x11a304

void entry_11a2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a2f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a2fc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a304);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a304
// Address: 0x11a304 - 0x11a328

void entry_11a304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a304: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11a308: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11a30c: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11a310: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11a314: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11a318: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a31c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11a324: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11a328; return;
}


// Function: SetSingleParent__6CFrameP6CFrame
// Address: 0x11a328 - 0x11a338

void entry_11a38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a38c: 0xc047126
    SET_GPR_U32(ctx, 31, 0x11a394);
    FUN_0011C498(rdram, ctx, runtime); return;
}


// Function: entry_11a394
// Address: 0x11a394 - 0x11a3a8

void entry_11a394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a394: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a398: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a39c: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x11a3a0: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a3a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a3a8
// Address: 0x11a3a8 - 0x11a3c0

void entry_11a3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a3a8: 0x8e630014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x11a3ac: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a3b0: 0x24050022
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    // 0x11a3b4: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x11a3b8: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11a3c0);
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 16));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11a3c0
// Address: 0x11a3c0 - 0x11a3cc

void entry_11a3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a3c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a3c4: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11a3cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a3cc
// Address: 0x11a3cc - 0x11a3d8

void entry_11a3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a3cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a3d0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a3d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a3d8
// Address: 0x11a3d8 - 0x11a400

void entry_11a3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a3d8: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11a3dc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11a3e0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11a3e4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11a3e8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11a3ec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a3f0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a3f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11a3fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11a400; return;
}


// Function: RefSetBinding__6CFrameUiP4CRef
// Address: 0x11a400 - 0x11a430

void entry_11a430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a430: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a434: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a438: 0xc046936
    SET_GPR_U32(ctx, 31, 0x11a440);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    PrefFindBinding__6CFrameUii(rdram, ctx, runtime); return;
}


// Function: entry_11a440
// Address: 0x11a440 - 0x11a454

void entry_11a440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a440: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
        ctx->pc = 0x11A458; return;
    }
    // 0x11a448: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a44c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a454);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a454
// Address: 0x11a454 - 0x11a460

void entry_11a454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a454) {
        switch (ctx->pc) {
            case 0x11a458: ctx->pc = 0; goto label_11a458;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a454: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_11a458:
    // 0x11a458: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11a460);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11a460
// Address: 0x11a460 - 0x11a46c

void entry_11a460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a460: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a464: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11a46c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a46c
// Address: 0x11a46c - 0x11a478

void entry_11a46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a46c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11a470: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11a478);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11a478
// Address: 0x11a478 - 0x11a498

void entry_11a478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a478: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11a47c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11a480: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11a484: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11a488: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a48c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a490: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFindBinding__6CFrameUiiP4CRef
// Address: 0x11a498 - 0x11a4ac

void entry_11a4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a4ac: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x11A4C8; return;
    }
    // 0x11a4b4: 0x12000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_11a4c4(rdram, ctx, runtime); return;
    }
    // 0x11a4bc: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11a4c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11a4c4
// Address: 0x11a4c4 - 0x11a4d8

void entry_11a4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a4c4) {
        switch (ctx->pc) {
            case 0x11a4c8: ctx->pc = 0; goto label_11a4c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a4c4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_11a4c8:
    // 0x11a4c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a4cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a4d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PrefFindBinding__6CFrameUii
// Address: 0x11a4d8 - 0x11a564

void entry_11a564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a564) {
        switch (ctx->pc) {
            case 0x11a574: ctx->pc = 0; goto label_11a574;
            case 0x11a584: ctx->pc = 0; goto label_11a584;
            case 0x11a588: ctx->pc = 0; goto label_11a588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a564: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a568: 0x54a00007
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 0));
        goto label_11a588;
    }
    // 0x11a570: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_11a574:
    // 0x11a574: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x11a578: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x11a57c: 0x1440fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A548; return;
    }
label_11a584:
    // 0x11a584: 0xae400018
    WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 0));
label_11a588:
    // 0x11a588: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x11a58c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11a590: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11a594: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11a598: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a59c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a5a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a5a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11a5ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11a5b0; return;
}


// Function: CloneTo__6CFrameP6CFrame
// Address: 0x11a5b0 - 0x11a5e8

void entry_11a5e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a5e8: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x11a5ec: 0x1040000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A618; return;
    }
    // 0x11a5f4: 0xc047126
    SET_GPR_U32(ctx, 31, 0x11a5fc);
    FUN_0011C498(rdram, ctx, runtime); return;
}


// Function: entry_11a5fc
// Address: 0x11a5fc - 0x11a610

void entry_11a5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a5fc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a600: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x11a604: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a608: 0xc047106
    SET_GPR_U32(ctx, 31, 0x11a610);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0011C418(rdram, ctx, runtime); return;
}


// Function: entry_11a610
// Address: 0x11a610 - 0x11a630

void entry_11a610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a610) {
        switch (ctx->pc) {
            case 0x11a618: ctx->pc = 0; goto label_11a618;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a610: 0xae500014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 16));
    // 0x11a614: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_11a618:
    // 0x11a618: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11a61c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a620: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11a62c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11a630; return;
}


// Function: PframeNew__Fv
// Address: 0x11a630 - 0x11a648

void entry_11a648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a648: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a64c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11a650: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a654: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11a65c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11a65c
// Address: 0x11a65c - 0x11a670

void entry_11a65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a65c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a660: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11a664: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a668: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DeleteFrame__FP6CFrame
// Address: 0x11a670 - 0x11a678

void entry_11a698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a698: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a69c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11a6a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11a6a8; return;
}


// Function: Startup__3CGc
// Address: 0x11a6a8 - 0x11a6b8

void entry_11a814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a814: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11a818: 0xc0470a8
    SET_GPR_U32(ctx, 31, 0x11a820);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951536));
    UpdateRecyclable__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11a820
// Address: 0x11a820 - 0x11a82c

void entry_11a820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a820: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11a824: 0xc0470a8
    SET_GPR_U32(ctx, 31, 0x11a82c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951568));
    UpdateRecyclable__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11a82c
// Address: 0x11a82c - 0x11a838

void entry_11a82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a82c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11a830: 0xc0470a8
    SET_GPR_U32(ctx, 31, 0x11a838);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951600));
    UpdateRecyclable__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11a838
// Address: 0x11a838 - 0x11a844

void entry_11a838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a838: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11a83c: 0xc0470a8
    SET_GPR_U32(ctx, 31, 0x11a844);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951632));
    UpdateRecyclable__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11a844
// Address: 0x11a844 - 0x11a850

void entry_11a844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a844: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11a848: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MarkLiveObjects__3CGc
// Address: 0x11a850 - 0x11a888

void entry_11a888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a888) {
        switch (ctx->pc) {
            case 0x11a8b0: ctx->pc = 0; goto label_11a8b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a888: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a88c: 0x12600049
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A9B4; return;
    }
    // 0x11a894: 0x8e720014
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x11a898: 0x52400032
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x11A964; return;
    }
    // 0x11a8a0: 0x2417001f
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 31));
    // 0x11a8a4: 0x2416001e
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 30));
    // 0x11a8a8: 0x24150021
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 33));
    // 0x11a8ac: 0x0
    // NOP
label_11a8b0:
    // 0x11a8b0: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a8b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a8b8
// Address: 0x11a8b8 - 0x11a8f8

void entry_11a8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a8b8) {
        switch (ctx->pc) {
            case 0x11a8e0: ctx->pc = 0; goto label_11a8e0;
            case 0x11a8f0: ctx->pc = 0; goto label_11a8f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a8b8: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x11a8bc: 0x10770017
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 23)) {
        ctx->pc = 0x11A91C; return;
    }
    // 0x11a8c4: 0x28620020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 32));
    // 0x11a8c8: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11a8e0;
    }
    // 0x11a8d0: 0x50760007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        goto label_11a8f0;
    }
    // 0x11a8d8: 0x1000001f
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A958; return;
    }
label_11a8e0:
    // 0x11a8e0: 0x1075001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x11A94C; return;
    }
    // 0x11a8e8: 0x1000001b
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A958; return;
    }
label_11a8f0:
    // 0x11a8f0: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11a8f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a8f8
// Address: 0x11a8f8 - 0x11a908

void entry_11a8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a8f8: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x11A958; return;
    }
    // 0x11a900: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a908);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a908
// Address: 0x11a908 - 0x11a914

void entry_11a908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a908: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a90c: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11a914);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11a914
// Address: 0x11a914 - 0x11a928

void entry_11a914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a914) {
        switch (ctx->pc) {
            case 0x11a91c: ctx->pc = 0; goto label_11a91c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a914: 0x10000010
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A958; return;
    }
label_11a91c:
    // 0x11a91c: 0x8c910004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x11a920: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11a928);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a928
// Address: 0x11a928 - 0x11a938

void entry_11a928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a928: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x11A958; return;
    }
    // 0x11a930: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a938);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a938
// Address: 0x11a938 - 0x11a944

void entry_11a938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a938: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11a93c: 0xc0469ee
    SET_GPR_U32(ctx, 31, 0x11a944);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushProc__3CGcP5CProc(rdram, ctx, runtime); return;
}


// Function: entry_11a944
// Address: 0x11a944 - 0x11a954

void entry_11a944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a944) {
        switch (ctx->pc) {
            case 0x11a94c: ctx->pc = 0; goto label_11a94c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a944: 0x10000004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A958; return;
    }
label_11a94c:
    // 0x11a94c: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a954);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a954
// Address: 0x11a954 - 0x11a97c

void entry_11a954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a954) {
        switch (ctx->pc) {
            case 0x11a958: ctx->pc = 0; goto label_11a958;
            case 0x11a964: ctx->pc = 0; goto label_11a964;
            case 0x11a970: ctx->pc = 0; goto label_11a970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a954: 0x8e52000c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_11a958:
    // 0x11a958: 0x1640ffd5
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A8B0; return;
    }
    // 0x11a960: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_11a964:
    // 0x11a964: 0x1840ffc6
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x11A880; return;
    }
    // 0x11a96c: 0x26710004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 4));
label_11a970:
    // 0x11a970: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11a974: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11a97c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a97c
// Address: 0x11a97c - 0x11a98c

void entry_11a97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a97c: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x11A99C; return;
    }
    // 0x11a984: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a98c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a98c
// Address: 0x11a98c - 0x11a998

void entry_11a98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a98c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11a990: 0xc0469ca
    SET_GPR_U32(ctx, 31, 0x11a998);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushFrame__3CGcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11a998
// Address: 0x11a998 - 0x11a9bc

void entry_11a998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a998) {
        switch (ctx->pc) {
            case 0x11a99c: ctx->pc = 0; goto label_11a99c;
            case 0x11a9b4: ctx->pc = 0; goto label_11a9b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a998: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_11a99c:
    // 0x11a99c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x11a9a0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x11a9a4: 0x1440fff2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A970; return;
    }
    // 0x11a9ac: 0x1000ffb4
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
label_11a9b4:
    // 0x11a9b4: 0xc0469f6
    SET_GPR_U32(ctx, 31, 0x11a9bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PprocPop__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11a9bc
// Address: 0x11a9bc - 0x11a9e0

void entry_11a9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a9bc) {
        switch (ctx->pc) {
            case 0x11a9d8: ctx->pc = 0; goto label_11a9d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a9bc: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11a9c0: 0x12200020
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AA44; return;
    }
    // 0x11a9c8: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11a9cc: 0x52000008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x11A9F0; return;
    }
    // 0x11a9d4: 0x0
    // NOP
label_11a9d8:
    // 0x11a9d8: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11a9e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a9e0
// Address: 0x11a9e0 - 0x11a9f8

void entry_11a9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11a9e0) {
        switch (ctx->pc) {
            case 0x11a9f0: ctx->pc = 0; goto label_11a9f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11a9e0: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x11a9e4: 0x1600fffc
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A9D8; return;
    }
    // 0x11a9ec: 0x8e300010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_11a9f0:
    // 0x11a9f0: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11a9f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11a9f8
// Address: 0x11a9f8 - 0x11aa08

void entry_11a9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11a9f8: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x11AA18; return;
    }
    // 0x11aa00: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11aa08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aa08
// Address: 0x11aa08 - 0x11aa14

void entry_11aa08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aa08: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11aa0c: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11aa14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11aa14
// Address: 0x11aa14 - 0x11aa20

void entry_11aa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aa14) {
        switch (ctx->pc) {
            case 0x11aa18: ctx->pc = 0; goto label_11aa18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aa14: 0x8e330000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_11aa18:
    // 0x11aa18: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11aa20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aa20
// Address: 0x11aa20 - 0x11aa30

void entry_11aa20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aa20: 0x1040ff97
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
    // 0x11aa28: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11aa30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aa30
// Address: 0x11aa30 - 0x11aa3c

void entry_11aa30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aa30: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11aa34: 0xc0469ca
    SET_GPR_U32(ctx, 31, 0x11aa3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushFrame__3CGcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11aa3c
// Address: 0x11aa3c - 0x11aa4c

void entry_11aa3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aa3c) {
        switch (ctx->pc) {
            case 0x11aa44: ctx->pc = 0; goto label_11aa44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aa3c: 0x1000ff90
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
label_11aa44:
    // 0x11aa44: 0xc0469e4
    SET_GPR_U32(ctx, 31, 0x11aa4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PpairPop__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11aa4c
// Address: 0x11aa4c - 0x11aa98

void entry_11aa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aa4c) {
        switch (ctx->pc) {
            case 0x11aa7c: ctx->pc = 0; goto label_11aa7c;
            case 0x11aa90: ctx->pc = 0; goto label_11aa90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aa4c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11aa50: 0x12000036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AB2C; return;
    }
    // 0x11aa58: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11aa5c: 0x10620017
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 32));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x11AABC; return;
    }
    // 0x11aa64: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11aa7c;
    }
    // 0x11aa6c: 0x50620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_11aa90;
    }
    // 0x11aa74: 0x10000020
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AAF8; return;
    }
label_11aa7c:
    // 0x11aa7c: 0x24020021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    // 0x11aa80: 0x1062001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x11AAEC; return;
    }
    // 0x11aa88: 0x1000001b
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AAF8; return;
    }
label_11aa90:
    // 0x11aa90: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11aa98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aa98
// Address: 0x11aa98 - 0x11aaa8

void entry_11aa98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aa98: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x11AAF8; return;
    }
    // 0x11aaa0: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11aaa8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aaa8
// Address: 0x11aaa8 - 0x11aab4

void entry_11aaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aaa8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11aaac: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11aab4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11aab4
// Address: 0x11aab4 - 0x11aac8

void entry_11aab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aab4) {
        switch (ctx->pc) {
            case 0x11aabc: ctx->pc = 0; goto label_11aabc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aab4: 0x10000010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AAF8; return;
    }
label_11aabc:
    // 0x11aabc: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11aac0: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11aac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aac8
// Address: 0x11aac8 - 0x11aad8

void entry_11aac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aac8: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x11AAF8; return;
    }
    // 0x11aad0: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11aad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aad8
// Address: 0x11aad8 - 0x11aae4

void entry_11aad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aad8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11aadc: 0xc0469ee
    SET_GPR_U32(ctx, 31, 0x11aae4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushProc__3CGcP5CProc(rdram, ctx, runtime); return;
}


// Function: entry_11aae4
// Address: 0x11aae4 - 0x11aaf4

void entry_11aae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aae4) {
        switch (ctx->pc) {
            case 0x11aaec: ctx->pc = 0; goto label_11aaec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aae4: 0x10000004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AAF8; return;
    }
label_11aaec:
    // 0x11aaec: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11aaf4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11aaf4
// Address: 0x11aaf4 - 0x11ab08

void entry_11aaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11aaf4) {
        switch (ctx->pc) {
            case 0x11aaf8: ctx->pc = 0; goto label_11aaf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11aaf4: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_11aaf8:
    // 0x11aaf8: 0x1200ff61
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
    // 0x11ab00: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11ab08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ab08
// Address: 0x11ab08 - 0x11ab18

void entry_11ab08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ab08: 0x1040ff5d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
    // 0x11ab10: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11ab18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ab18
// Address: 0x11ab18 - 0x11ab24

void entry_11ab18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ab18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ab1c: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11ab24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11ab24
// Address: 0x11ab24 - 0x11ab58

void entry_11ab24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ab24) {
        switch (ctx->pc) {
            case 0x11ab2c: ctx->pc = 0; goto label_11ab2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ab24: 0x1000ff56
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11A880; return;
    }
label_11ab2c:
    // 0x11ab2c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11ab30: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11ab34: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ab38: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11ab3c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11ab40: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ab44: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ab48: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ab4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ab50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Collect__3CGc
// Address: 0x11ab58 - 0x11ab94

void entry_11ab94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ab94: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11ab98: 0xc0470ac
    SET_GPR_U32(ctx, 31, 0x11aba0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951536));
    UnmarkAll__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11aba0
// Address: 0x11aba0 - 0x11abac

void entry_11aba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aba0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11aba4: 0xc0470ac
    SET_GPR_U32(ctx, 31, 0x11abac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951568));
    UnmarkAll__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11abac
// Address: 0x11abac - 0x11abb8

void entry_11abac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11abac: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11abb0: 0xc0470ac
    SET_GPR_U32(ctx, 31, 0x11abb8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951600));
    UnmarkAll__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11abb8
// Address: 0x11abb8 - 0x11abc8

void entry_11abb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11abb8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11abbc: 0x80f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11abc0: 0xc0470ac
    SET_GPR_U32(ctx, 31, 0x11abc8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951632));
    UnmarkAll__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11abc8
// Address: 0x11abc8 - 0x11abfc

void entry_11abc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11abc8) {
        switch (ctx->pc) {
            case 0x11abf0: ctx->pc = 0; goto label_11abf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11abc8: 0x8e710000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11abcc: 0xae600708
    WRITE32(ADD32(GPR_U32(ctx, 19), 1800), GPR_U32(ctx, 0));
    // 0x11abd0: 0xae600f0c
    WRITE32(ADD32(GPR_U32(ctx, 19), 3852), GPR_U32(ctx, 0));
    // 0x11abd4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x11abd8: 0x6200012
    WRITE32(ADD32(GPR_U32(ctx, 19), 4880), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x11AC24; return;
    }
    // 0x11abe0: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x11abe4: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x11abe8: 0x539021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x11abec: 0x0
    // NOP
label_11abf0:
    // 0x11abf0: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x11abf4: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11abfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11abfc
// Address: 0x11abfc - 0x11ac0c

void entry_11abfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11abfc: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x11AC1C; return;
    }
    // 0x11ac04: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11ac0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ac0c
// Address: 0x11ac0c - 0x11ac18

void entry_11ac0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ac0c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ac10: 0xc0469ca
    SET_GPR_U32(ctx, 31, 0x11ac18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PushFrame__3CGcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11ac18
// Address: 0x11ac18 - 0x11ac70

void entry_11ac18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ac18) {
        switch (ctx->pc) {
            case 0x11ac1c: ctx->pc = 0; goto label_11ac1c;
            case 0x11ac24: ctx->pc = 0; goto label_11ac24;
            case 0x11ac40: ctx->pc = 0; goto label_11ac40;
            case 0x11ac68: ctx->pc = 0; goto label_11ac68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ac18: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_11ac1c:
    // 0x11ac1c: 0x621fff4
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967292));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x11ABF0; return;
    }
label_11ac24:
    // 0x11ac24: 0x8e630504
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1284)));
    // 0x11ac28: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x11ac2c: 0x460003d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x11AD24; return;
    }
    // 0x11ac34: 0x26770508
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 19), 1288));
    // 0x11ac38: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11ac3c: 0x0
    // NOP
label_11ac40:
    // 0x11ac40: 0x2472ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x11ac44: 0x2e21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 23), GPR_U32(ctx, 2)));
    // 0x11ac48: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11ac4c: 0x8c710000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11ac50: 0x12200031
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD18; return;
    }
    // 0x11ac58: 0x2416001f
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 31));
    // 0x11ac5c: 0x2415001e
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 30));
    // 0x11ac60: 0x24140021
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 33));
    // 0x11ac64: 0x0
    // NOP
label_11ac68:
    // 0x11ac68: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11ac70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ac70
// Address: 0x11ac70 - 0x11acb0

void entry_11ac70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ac70) {
        switch (ctx->pc) {
            case 0x11ac98: ctx->pc = 0; goto label_11ac98;
            case 0x11aca8: ctx->pc = 0; goto label_11aca8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ac70: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11ac74: 0x10760017
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 22)) {
        ctx->pc = 0x11ACD4; return;
    }
    // 0x11ac7c: 0x28620020
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 32));
    // 0x11ac80: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11ac98;
    }
    // 0x11ac88: 0x50750007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        goto label_11aca8;
    }
    // 0x11ac90: 0x1000001f
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD10; return;
    }
label_11ac98:
    // 0x11ac98: 0x1074001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x11AD04; return;
    }
    // 0x11aca0: 0x1000001b
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD10; return;
    }
label_11aca8:
    // 0x11aca8: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11acb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11acb0
// Address: 0x11acb0 - 0x11acc0

void entry_11acb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11acb0: 0x50400017
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x11AD10; return;
    }
    // 0x11acb8: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11acc0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11acc0
// Address: 0x11acc0 - 0x11accc

void entry_11acc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11acc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11acc4: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11accc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11accc
// Address: 0x11accc - 0x11ace0

void entry_11accc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11accc) {
        switch (ctx->pc) {
            case 0x11acd4: ctx->pc = 0; goto label_11acd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11accc: 0x10000010
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD10; return;
    }
label_11acd4:
    // 0x11acd4: 0x8c900004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x11acd8: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11ace0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ace0
// Address: 0x11ace0 - 0x11acf0

void entry_11ace0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ace0: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x11AD10; return;
    }
    // 0x11ace8: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11acf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11acf0
// Address: 0x11acf0 - 0x11acfc

void entry_11acf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11acf0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11acf4: 0xc0469ee
    SET_GPR_U32(ctx, 31, 0x11acfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PushProc__3CGcP5CProc(rdram, ctx, runtime); return;
}


// Function: entry_11acfc
// Address: 0x11acfc - 0x11ad0c

void entry_11acfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11acfc) {
        switch (ctx->pc) {
            case 0x11ad04: ctx->pc = 0; goto label_11ad04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11acfc: 0x10000004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD10; return;
    }
label_11ad04:
    // 0x11ad04: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11ad0c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ad0c
// Address: 0x11ad0c - 0x11ad5c

void entry_11ad0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ad0c) {
        switch (ctx->pc) {
            case 0x11ad10: ctx->pc = 0; goto label_11ad10;
            case 0x11ad18: ctx->pc = 0; goto label_11ad18;
            case 0x11ad24: ctx->pc = 0; goto label_11ad24;
            case 0x11ad40: ctx->pc = 0; goto label_11ad40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ad0c: 0x8e31000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_11ad10:
    // 0x11ad10: 0x1620ffd5
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AC68; return;
    }
label_11ad18:
    // 0x11ad18: 0x461ffc9
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_S32(ctx, 3) >= 0) {
        ctx->pc = 0x11AC40; return;
    }
    // 0x11ad20: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_11ad24:
    // 0x11ad24: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x11ad28: 0x8c711ec8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 7880)));
    // 0x11ad2c: 0x12200015
    SET_GPR_U32(ctx, 2, ((uint32_t)24 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AD84; return;
    }
    // 0x11ad34: 0x245234a0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 13472));
    // 0x11ad38: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11ad3c: 0x0
    // NOP
label_11ad40:
    // 0x11ad40: 0x5452000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x11AD7C; return;
    }
    // 0x11ad48: 0x8e30000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x11ad4c: 0x5200000b
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x11AD7C; return;
    }
    // 0x11ad54: 0xc0470f2
    SET_GPR_U32(ctx, 31, 0x11ad5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsPvGarbage__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ad5c
// Address: 0x11ad5c - 0x11ad6c

void entry_11ad5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ad5c: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x11AD7C; return;
    }
    // 0x11ad64: 0xc0470fc
    SET_GPR_U32(ctx, 31, 0x11ad6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MarkPvAlive__FPv(rdram, ctx, runtime); return;
}


// Function: entry_11ad6c
// Address: 0x11ad6c - 0x11ad78

void entry_11ad6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ad6c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ad70: 0xc0469dc
    SET_GPR_U32(ctx, 31, 0x11ad78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PushPair__3CGcP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11ad78
// Address: 0x11ad78 - 0x11ad8c

void entry_11ad78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ad78) {
        switch (ctx->pc) {
            case 0x11ad7c: ctx->pc = 0; goto label_11ad7c;
            case 0x11ad84: ctx->pc = 0; goto label_11ad84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ad78: 0x8e310010
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_11ad7c:
    // 0x11ad7c: 0x5620fff0
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x11AD40; return;
    }
label_11ad84:
    // 0x11ad84: 0xc046a14
    SET_GPR_U32(ctx, 31, 0x11ad8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    MarkLiveObjects__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11ad8c
// Address: 0x11ad8c - 0x11ad98

void entry_11ad8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ad8c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11ad90: 0xc0470ba
    SET_GPR_U32(ctx, 31, 0x11ad98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294951504));
    FreeGarbage__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11ad98
// Address: 0x11ad98 - 0x11ada4

void entry_11ad98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ad98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11ad9c: 0xc0470ba
    SET_GPR_U32(ctx, 31, 0x11ada4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294951536));
    FreeGarbage__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11ada4
// Address: 0x11ada4 - 0x11adb0

void entry_11ada4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ada4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11ada8: 0xc0470ba
    SET_GPR_U32(ctx, 31, 0x11adb0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294951568));
    FreeGarbage__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11adb0
// Address: 0x11adb0 - 0x11adbc

void entry_11adb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11adb0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11adb4: 0xc0470ba
    SET_GPR_U32(ctx, 31, 0x11adbc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294951600));
    FreeGarbage__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11adbc
// Address: 0x11adbc - 0x11adc4

void entry_11adbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11adbc: 0xc0470ba
    SET_GPR_U32(ctx, 31, 0x11adc4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294951632));
    FreeGarbage__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11adc4
// Address: 0x11adc4 - 0x11adf8

void entry_11adc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11adc4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11adc8: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11adcc: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11add0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11add4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11add8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11addc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ade0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ade4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ade8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11adec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11adf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11adf8; return;
}


// Function: gc__static_initialization_and_destruction_0
// Address: 0x11adf8 - 0x11ae18

void entry_11ae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ae18) {
        switch (ctx->pc) {
            case 0x11ae20: ctx->pc = 0; goto label_11ae20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ae18: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AE30; return;
    }
label_11ae20:
    // 0x11ae20: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x11ae24: 0xc0469a0
    SET_GPR_U32(ctx, 31, 0x11ae2c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    ctx->pc = 0x11a680; return;
}


// Function: entry_11ae2c
// Address: 0x11ae2c - 0x11ae38

void entry_11ae2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ae2c) {
        switch (ctx->pc) {
            case 0x11ae30: ctx->pc = 0; goto label_11ae30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ae2c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11ae30:
    // 0x11ae30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0011ae38
// Address: 0x11ae38 - 0x11ae4c

void FUN_0011ae38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ae38: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x11ae3c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11ae40: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x11ae44: 0xc046b7e
    SET_GPR_U32(ctx, 31, 0x11ae4c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    gc__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_11ae4c
// Address: 0x11ae4c - 0x11ae58

void entry_11ae4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ae4c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ae50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0011ae58
// Address: 0x11ae58 - 0x11ae6c

void FUN_0011ae58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ae58: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x11ae5c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11ae60: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x11ae64: 0xc046b7e
    SET_GPR_U32(ctx, 31, 0x11ae6c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    gc__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_11ae6c
// Address: 0x11ae6c - 0x11ae78

void entry_11ae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ae6c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ae70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PmethodNew__Fv
// Address: 0x11ae78 - 0x11ae90

void entry_11ae90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ae90: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ae94: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11ae98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ae9c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11aea4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11aea4
// Address: 0x11aea4 - 0x11aeb8

void entry_11aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aea4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11aea8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11aeac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11aeb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneTo__5CPairP5CPairP6CFrame
// Address: 0x11aeb8 - 0x11aee0

void entry_11aee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aee0: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x11aee4: 0x1040000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11AF10; return;
    }
    // 0x11aeec: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x11aef4);
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11aef4
// Address: 0x11aef4 - 0x11af08

void entry_11aef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aef4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11aef8: 0x8e240008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x11aefc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11af00: 0xc046bae
    SET_GPR_U32(ctx, 31, 0x11af08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneTo__5CPairP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11af08
// Address: 0x11af08 - 0x11af28

void entry_11af08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11af08) {
        switch (ctx->pc) {
            case 0x11af10: ctx->pc = 0; goto label_11af10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11af08: 0xae700008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 16));
    // 0x11af0c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_11af10:
    // 0x11af10: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11af14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11af18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11af1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11af20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PpairNew__Fv
// Address: 0x11af28 - 0x11af40

void entry_11af40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11af40: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11af44: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11af48: 0x2406000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11af4c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11af54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11af54
// Address: 0x11af54 - 0x11af5c

void entry_11af54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11af54: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11af5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11af5c
// Address: 0x11af5c - 0x11af78

void entry_11af5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11af5c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11af60: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11af64: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x11af68: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11af6c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11af70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DeletePair__FP5CPair
// Address: 0x11af78 - 0x11af88

void entry_11af88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11af88: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11af8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11af94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11af98; return;
}


// Function: CloneTo__5CProcP5CProcP6CFrame
// Address: 0x11af98 - 0x11afc8

void entry_11afe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11afe0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11afe4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11afe8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11afec: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11aff4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11aff4
// Address: 0x11aff4 - 0x11b008

void entry_11aff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11aff4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11aff8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11affc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b000: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___4CRef
// Address: 0x11b008 - 0x11b018

void entry_11b038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b038) {
        switch (ctx->pc) {
            case 0x11b060: ctx->pc = 0; goto label_11b060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b038: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11b03c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11b040: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b044: 0xae240000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 4));
    // 0x11b048: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x11b04c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b050: 0xae230004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
    // 0x11b054: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b058: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
label_11b060:
    // 0x11b060: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x11b064: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x11b068: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x11b06c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11b070: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x11b074: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b07c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b07c
// Address: 0x11b07c - 0x11b090

void entry_11b07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b07c: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x11b080: 0x12000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B094; return;
    }
    // 0x11b088: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x11b090);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_11b090
// Address: 0x11b090 - 0x11b0a8

void entry_11b090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b090) {
        switch (ctx->pc) {
            case 0x11b094: ctx->pc = 0; goto label_11b094;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b090: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_11b094:
    // 0x11b094: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b098: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b09c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b0a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b0a8; return;
}


// Function: fn___as__4CRefRC4CRef
// Address: 0x11b0a8 - 0x11b0c8

void entry_11b0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b0c8: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b0d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b0d0
// Address: 0x11b0d0 - 0x11b0f8

void entry_11b0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b0d0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11b0d4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b0d8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b0dc: 0xae040000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 4));
    // 0x11b0e0: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b0e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b0e8: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x11b0ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b0f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___eq__4CRefRC4CRef
// Address: 0x11b0f8 - 0x11b1a0

void entry_11b1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b1a0) {
        switch (ctx->pc) {
            case 0x11b214: ctx->pc = 0; goto label_11b214;
            case 0x11b224: ctx->pc = 0; goto label_11b224;
            case 0x11b228: ctx->pc = 0; goto label_11b228;
            case 0x11b244: ctx->pc = 0; goto label_11b244;
            case 0x11b248: ctx->pc = 0; goto label_11b248;
            case 0x11b24c: ctx->pc = 0; goto label_11b24c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b1a0: 0x10000029
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b248;
    }
    // 0x11b1a8: 0x8cc40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x11b1ac: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x11b1b0: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11b1b4: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11b1b8: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11b1bc: 0x0
    // NOP
    // 0x11b1c0: 0x45000019
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_11b228;
    }
    // 0x11b1c8: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11b1cc: 0x10000011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b214;
    }
    // 0x11b1d4: 0x8cc40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x11b1d8: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x11b1dc: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11b1e0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11b1e4: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11b1e8: 0x0
    // NOP
    // 0x11b1ec: 0x4500000e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_11b228;
    }
    // 0x11b1f4: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11b1f8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11b1fc: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11b200: 0x0
    // NOP
    // 0x11b204: 0x45020010
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_11b248;
    }
    // 0x11b20c: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x11b210: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
label_11b214:
    // 0x11b214: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11b218: 0x0
    // NOP
    // 0x11b21c: 0x4500000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_11b248;
    }
label_11b224:
    // 0x11b224: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_11b228:
    // 0x11b228: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b248;
    }
    // 0x11b230: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x11b234: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x11b238: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11b23c: 0x10000002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b248;
    }
label_11b244:
    // 0x11b244: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_11b248:
    // 0x11b248: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11b24c:
    // 0x11b24c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b254: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b258; return;
}


// Function: CloneTo__4CRefP4CRefP6CFrame
// Address: 0x11b258 - 0x11b2b8

void entry_11b2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b2b8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b2bc: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b2c0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11b2c4: 0xc046bae
    SET_GPR_U32(ctx, 31, 0x11b2cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneTo__5CPairP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11b2cc
// Address: 0x11b2cc - 0x11b2dc

void entry_11b2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b2cc: 0x1000004a
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b2d4: 0xc047142
    SET_GPR_U32(ctx, 31, 0x11b2dc);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b2dc
// Address: 0x11b2dc - 0x11b2f4

void entry_11b2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b2dc: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b2e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b2e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b2e8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11b2ec: 0xc047160
    SET_GPR_U32(ctx, 31, 0x11b2f4);
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    IncrefVector__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11b2f4
// Address: 0x11b2f4 - 0x11b304

void entry_11b2f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b2f4: 0x10000040
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b2fc: 0xc047186
    SET_GPR_U32(ctx, 31, 0x11b304);
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b304
// Address: 0x11b304 - 0x11b334

void entry_11b304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b304: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b308: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b30c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b310: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x11b314: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x11b318: 0x78a30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x11b31c: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x11b320: 0x78a20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x11b324: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x11b328: 0x78a30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 48)));
    // 0x11b32c: 0xc0471a4
    SET_GPR_U32(ctx, 31, 0x11b334);
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 3));
    IncrefMatrix__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11b334
// Address: 0x11b334 - 0x11b344

void entry_11b334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b334: 0x10000030
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b33c: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x11b344);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b344
// Address: 0x11b344 - 0x11b35c

void entry_11b344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b344: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b348: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b34c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b350: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11b354: 0xc0471f0
    SET_GPR_U32(ctx, 31, 0x11b35c);
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    IncrefClq__FP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_11b35c
// Address: 0x11b35c - 0x11b36c

void entry_11b35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b35c: 0x10000026
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b364: 0xc047216
    SET_GPR_U32(ctx, 31, 0x11b36c);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b36c
// Address: 0x11b36c - 0x11b38c

void entry_11b36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b36c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b370: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b374: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b378: 0x68620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x11b37c: 0x6c620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x11b380: 0xb2020007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x11b384: 0xc047234
    SET_GPR_U32(ctx, 31, 0x11b38c);
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    IncrefLm__FP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11b38c
// Address: 0x11b38c - 0x11b39c

void entry_11b38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b38c: 0x1000001a
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b394: 0xc04725a
    SET_GPR_U32(ctx, 31, 0x11b39c);
    PsmpNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b39c
// Address: 0x11b39c - 0x11b3c4

void entry_11b39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b39c: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b3a0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b3a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11b3a8: 0x68620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x11b3ac: 0x6c620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x11b3b0: 0x8c650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x11b3b4: 0xb2020007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x11b3b8: 0xb6020000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x11b3bc: 0xc047278
    SET_GPR_U32(ctx, 31, 0x11b3c4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 5));
    IncrefSmp__FP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_11b3c4
// Address: 0x11b3c4 - 0x11b3d4

void entry_11b3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b3c4: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B3F8; return;
    }
    // 0x11b3cc: 0xc046bf2
    SET_GPR_U32(ctx, 31, 0x11b3d4);
    PprocNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11b3d4
// Address: 0x11b3d4 - 0x11b3e8

void entry_11b3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b3d4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11b3d8: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b3dc: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11b3e0: 0xc046be6
    SET_GPR_U32(ctx, 31, 0x11b3e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CloneTo__5CProcP5CProcP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11b3e8
// Address: 0x11b3e8 - 0x11b418

void entry_11b3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b3e8) {
        switch (ctx->pc) {
            case 0x11b3f0: ctx->pc = 0; goto label_11b3f0;
            case 0x11b3f8: ctx->pc = 0; goto label_11b3f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b3e8: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b3f8;
    }
label_11b3f0:
    // 0x11b3f0: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x11b3f4: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
label_11b3f8:
    // 0x11b3f8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11b3fc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11b400: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b404: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b408: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b40c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b418; return;
}


// Function: Decref__4CRef
// Address: 0x11b418 - 0x11b458

void entry_11b458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b458: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B49C; return;
    }
    // 0x11b460: 0xc0471b0
    SET_GPR_U32(ctx, 31, 0x11b468);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    DecrefMatrix__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11b468
// Address: 0x11b468 - 0x11b478

void entry_11b468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b468: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B49C; return;
    }
    // 0x11b470: 0xc0471fc
    SET_GPR_U32(ctx, 31, 0x11b478);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    DecrefClq__FP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_11b478
// Address: 0x11b478 - 0x11b488

void entry_11b478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b478: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B49C; return;
    }
    // 0x11b480: 0xc047240
    SET_GPR_U32(ctx, 31, 0x11b488);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    DecrefLm__FP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11b488
// Address: 0x11b488 - 0x11b498

void entry_11b488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b488: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B49C; return;
    }
    // 0x11b490: 0xc047288
    SET_GPR_U32(ctx, 31, 0x11b498);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    DecrefSmp__FP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_11b498
// Address: 0x11b498 - 0x11b4a8

void entry_11b498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b498) {
        switch (ctx->pc) {
            case 0x11b49c: ctx->pc = 0; goto label_11b49c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b498: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11b49c:
    // 0x11b49c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b4a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b4a8; return;
}


// Function: Incref__4CRef
// Address: 0x11b4a8 - 0x11b4e8

void entry_11b4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b4e8: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B52C; return;
    }
    // 0x11b4f0: 0xc0471a4
    SET_GPR_U32(ctx, 31, 0x11b4f8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    IncrefMatrix__FP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11b4f8
// Address: 0x11b4f8 - 0x11b508

void entry_11b4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b4f8: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B52C; return;
    }
    // 0x11b500: 0xc0471f0
    SET_GPR_U32(ctx, 31, 0x11b508);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    IncrefClq__FP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_11b508
// Address: 0x11b508 - 0x11b518

void entry_11b508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b508: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B52C; return;
    }
    // 0x11b510: 0xc047234
    SET_GPR_U32(ctx, 31, 0x11b518);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    IncrefLm__FP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11b518
// Address: 0x11b518 - 0x11b528

void entry_11b518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b518: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B52C; return;
    }
    // 0x11b520: 0xc047278
    SET_GPR_U32(ctx, 31, 0x11b528);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    IncrefSmp__FP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_11b528
// Address: 0x11b528 - 0x11b538

void entry_11b528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b528) {
        switch (ctx->pc) {
            case 0x11b52c: ctx->pc = 0; goto label_11b52c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b528: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11b52c:
    // 0x11b52c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b534: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b538; return;
}


// Function: SetTag__4CRef4TAGK
// Address: 0x11b538 - 0x11b554

void entry_11b554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b554: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x11b558: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b55c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b560: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b56c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b570; return;
}


// Function: SetS32__4CRefi
// Address: 0x11b570 - 0x11b58c

void entry_11b58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b58c: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x11b590: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b594: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b598: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b59c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b5a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b5a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b5ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b5b0; return;
}


// Function: SetF32__4CReff
// Address: 0x11b5b0 - 0x11b5cc

void entry_11b5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b5cc: 0x24020015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 21));
    // 0x11b5d0: 0xe6140004
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11b5d4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b5d8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b5dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b5e0: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x11b5e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b5ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b5f0; return;
}


// Function: SetBool__4CRefi
// Address: 0x11b5f0 - 0x11b60c

void entry_11b60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b60c) {
        switch (ctx->pc) {
            case 0x11b61c: ctx->pc = 0; goto label_11b61c;
            case 0x11b620: ctx->pc = 0; goto label_11b620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b60c: 0x12000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_11b61c;
    }
    // 0x11b614: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11b620;
    }
label_11b61c:
    // 0x11b61c: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
label_11b620:
    // 0x11b620: 0x2402001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    // 0x11b624: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b628: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x11b62c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b630: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b634: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b63c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b640; return;
}


// Function: SetSymid__4CRefUi
// Address: 0x11b640 - 0x11b65c

void entry_11b65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b65c: 0x2402001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 28));
    // 0x11b660: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b664: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b668: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b66c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b670: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b674: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b67c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b680; return;
}


// Function: SetBifk__4CRef4BIFK
// Address: 0x11b680 - 0x11b69c

void entry_11b69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b69c: 0x2402001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 29));
    // 0x11b6a0: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b6a4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b6a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b6ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b6b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b6b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b6bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b6c0; return;
}


// Function: SetPair__4CRefP5CPair
// Address: 0x11b6c0 - 0x11b6dc

void entry_11b6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b6dc: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x11b6e0: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b6e4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b6e8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b6ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b6f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b6f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b6fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b700; return;
}


// Function: SetProc__4CRefP5CProc
// Address: 0x11b700 - 0x11b71c

void entry_11b71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b71c: 0x2402001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 31));
    // 0x11b720: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b724: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b728: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b72c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b730: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b734: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b73c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b740; return;
}


// Function: SetVector__4CRefP6VECTOR
// Address: 0x11b740 - 0x11b760

void entry_11b760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b760: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b768);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b768
// Address: 0x11b768 - 0x11b788

void entry_11b768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b768: 0x24020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 22));
    // 0x11b76c: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b770: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b774: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b778: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b77c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b780: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetMatrix__4CRefP7MATRIX4
// Address: 0x11b788 - 0x11b7a8

void entry_11b7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b7a8: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b7b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b7b0
// Address: 0x11b7b0 - 0x11b7d0

void entry_11b7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b7b0: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x11b7b4: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b7b8: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b7bc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b7c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b7c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b7c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetClq__4CRefP3CLQ
// Address: 0x11b7d0 - 0x11b7f0

void entry_11b7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b7f0: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b7f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b7f8
// Address: 0x11b7f8 - 0x11b818

void entry_11b7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b7f8: 0x24020018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    // 0x11b7fc: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b800: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b804: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b808: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b80c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b810: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLm__4CRefP2LM
// Address: 0x11b818 - 0x11b838

void entry_11b838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b838: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b840);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b840
// Address: 0x11b840 - 0x11b860

void entry_11b840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b840: 0x24020019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 25));
    // 0x11b844: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b848: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b84c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b850: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b854: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b858: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSmp__4CRefP3SMP
// Address: 0x11b860 - 0x11b880

void entry_11b880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b880: 0xc046d06
    SET_GPR_U32(ctx, 31, 0x11b888);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Decref__4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b888
// Address: 0x11b888 - 0x11b8a8

void entry_11b888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b888: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x11b88c: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b890: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b894: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b898: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b89c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b8a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetBasic__4CRefP5BASIC
// Address: 0x11b8a8 - 0x11b8c4

void entry_11b8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b8c4: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x11b8c8: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b8cc: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b8d0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b8d4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b8d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b8dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b8e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b8e8; return;
}


// Function: SetMethod__4CRefP7CMethod
// Address: 0x11b8e8 - 0x11b904

void entry_11b904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b904: 0x24020021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    // 0x11b908: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x11b90c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11b910: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b914: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b918: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11b91c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11b924: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11b928; return;
}


// Function: RefCoerceS32__4CRef
// Address: 0x11b928 - 0x11b954

void entry_11b954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b954) {
        switch (ctx->pc) {
            case 0x11b95c: ctx->pc = 0; goto label_11b95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b954: 0x1000000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11B994; return;
    }
label_11b95c:
    // 0x11b95c: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11b964);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b964
// Address: 0x11b964 - 0x11b978

void entry_11b964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b964: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11b968: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x11b96c: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x11b970: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11b978);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11b978
// Address: 0x11b978 - 0x11b984

void entry_11b978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b978: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11b97c: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11b984);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b984
// Address: 0x11b984 - 0x11b990

void entry_11b984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b984: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11b988: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11b990);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11b990
// Address: 0x11b990 - 0x11b9a8

void entry_11b990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b990) {
        switch (ctx->pc) {
            case 0x11b994: ctx->pc = 0; goto label_11b994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b990: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_11b994:
    // 0x11b994: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11b998: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11b99c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11b9a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefCoerceF32__4CRef
// Address: 0x11b9a8 - 0x11b9d4

void entry_11b9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11b9d4) {
        switch (ctx->pc) {
            case 0x11b9dc: ctx->pc = 0; goto label_11b9dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11b9d4: 0x1000000e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11BA10; return;
    }
label_11b9dc:
    // 0x11b9dc: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11b9e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11b9e4
// Address: 0x11b9e4 - 0x11b9f4

void entry_11b9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b9e4: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x11b9e8: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x11b9ec: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11b9f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11b9f4
// Address: 0x11b9f4 - 0x11ba00

void entry_11b9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11b9f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11b9f8: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11ba00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11ba00
// Address: 0x11ba00 - 0x11ba0c

void entry_11ba00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11ba04: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11ba0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11ba0c
// Address: 0x11ba0c - 0x11ba28

void entry_11ba0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ba0c) {
        switch (ctx->pc) {
            case 0x11ba10: ctx->pc = 0; goto label_11ba10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ba0c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_11ba10:
    // 0x11ba10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ba14: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ba18: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ba1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11ba24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11ba28; return;
}


// Function: PpairSerializeIn__FP18CBinaryInputStream
// Address: 0x11ba28 - 0x11ba50

void entry_11ba50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba50: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ba54: 0x240200ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 255));
    // 0x11ba58: 0x120200aa
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x11BD04; return;
    }
    // 0x11ba60: 0xc046bca
    SET_GPR_U32(ctx, 31, 0x11ba68);
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 16), 128));
    PpairNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11ba68
// Address: 0x11ba68 - 0x11ba88

void entry_11ba68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba68: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ba6c: 0x3203007f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 16), 127));
    // 0x11ba70: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x11ba74: 0x8c445714
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22292)));
    // 0x11ba78: 0x1080000b
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_11baa8(rdram, ctx, runtime); return;
    }
    // 0x11ba80: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x11ba88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ba88
// Address: 0x11ba88 - 0x11ba90

void entry_11ba88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba88: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x11ba90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ba90
// Address: 0x11ba90 - 0x11ba98

void entry_11ba90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba90: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x11ba98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ba98
// Address: 0x11ba98 - 0x11baa0

void entry_11ba98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ba98: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x11baa0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11baa0
// Address: 0x11baa0 - 0x11baa8

void entry_11baa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11baa0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x11baa8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11baa8
// Address: 0x11baa8 - 0x11bad8

void entry_11baa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11baa8: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11baac: 0x2c620021
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 33));
    // 0x11bab0: 0x1040008e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bab8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11babc: 0x244293a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294939552));
    // 0x11bac0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11bac4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11bac8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11bad0: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x11bad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bad8
// Address: 0x11bad8 - 0x11bae4

void entry_11bad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bad8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11badc: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11bae4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11bae4
// Address: 0x11bae4 - 0x11baf4

void entry_11bae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bae4: 0x10000081
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11baec: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11baf4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11baf4
// Address: 0x11baf4 - 0x11bb00

void entry_11baf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11baf4: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x11baf8: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11bb00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11bb00
// Address: 0x11bb00 - 0x11bb10

void entry_11bb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb00: 0x1000007a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bb08: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11bb10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bb10
// Address: 0x11bb10 - 0x11bb1c

void entry_11bb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb10: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bb14: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x11bb1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11bb1c
// Address: 0x11bb1c - 0x11bb2c

void entry_11bb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb1c: 0x10000073
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bb24: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11bb2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bb2c
// Address: 0x11bb2c - 0x11bb38

void entry_11bb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb2c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bb30: 0xc046e2a
    SET_GPR_U32(ctx, 31, 0x11bb38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetBasic__4CRefP5BASIC(rdram, ctx, runtime); return;
}


// Function: entry_11bb38
// Address: 0x11bb38 - 0x11bb48

void entry_11bb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb38: 0x1000006c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bb40: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11bb48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bb48
// Address: 0x11bb48 - 0x11bb54

void entry_11bb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb48: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bb4c: 0xc046d90
    SET_GPR_U32(ctx, 31, 0x11bb54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSymid__4CRefUi(rdram, ctx, runtime); return;
}


// Function: entry_11bb54
// Address: 0x11bb54 - 0x11bb64

void entry_11bb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb54: 0x10000065
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bb5c: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11bb64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bb64
// Address: 0x11bb64 - 0x11bb70

void entry_11bb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb64: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bb68: 0xc046da0
    SET_GPR_U32(ctx, 31, 0x11bb70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetBifk__4CRef4BIFK(rdram, ctx, runtime); return;
}


// Function: entry_11bb70
// Address: 0x11bb70 - 0x11bb80

void entry_11bb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb70: 0x1000005e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bb78: 0xc047142
    SET_GPR_U32(ctx, 31, 0x11bb80);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11bb80
// Address: 0x11bb80 - 0x11bb94

void entry_11bb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11bb80) {
        switch (ctx->pc) {
            case 0x11bb88: ctx->pc = 0; goto label_11bb88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11bb80: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bb84: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_11bb88:
    // 0x11bb88: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bb8c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bb94);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bb94
// Address: 0x11bb94 - 0x11bbb4

void entry_11bb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bb94: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11bb98: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x11BB88; return;
    }
    // 0x11bba0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11bba4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bba8: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x11bbac: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x11bbb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11bbb4
// Address: 0x11bbb4 - 0x11bbc4

void entry_11bbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bbb4: 0x1000004d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bbbc: 0xc047186
    SET_GPR_U32(ctx, 31, 0x11bbc4);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 15));
    PmatrixNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11bbc4
// Address: 0x11bbc4 - 0x11bbdc

void entry_11bbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11bbc4) {
        switch (ctx->pc) {
            case 0x11bbd0: ctx->pc = 0; goto label_11bbd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11bbc4: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bbc8: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bbcc: 0x0
    // NOP
label_11bbd0:
    // 0x11bbd0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bbd4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bbdc);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bbdc
// Address: 0x11bbdc - 0x11bbfc

void entry_11bbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bbdc: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11bbe0: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x11BBD0; return;
    }
    // 0x11bbe8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11bbec: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bbf0: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x11bbf4: 0xc046de2
    SET_GPR_U32(ctx, 31, 0x11bbfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetMatrix__4CRefP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_11bbfc
// Address: 0x11bbfc - 0x11bc0c

void entry_11bbfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bbfc: 0x1000003b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bc04: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x11bc0c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11bc0c
// Address: 0x11bc0c - 0x11bc24

void entry_11bc0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11bc0c) {
        switch (ctx->pc) {
            case 0x11bc18: ctx->pc = 0; goto label_11bc18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11bc0c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bc10: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bc14: 0x0
    // NOP
label_11bc18:
    // 0x11bc18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bc1c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bc24);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bc24
// Address: 0x11bc24 - 0x11bc44

void entry_11bc24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc24: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11bc28: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x11BC18; return;
    }
    // 0x11bc30: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11bc34: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bc38: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x11bc3c: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x11bc44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_11bc44
// Address: 0x11bc44 - 0x11bc54

void entry_11bc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc44: 0x10000029
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bc4c: 0xc047216
    SET_GPR_U32(ctx, 31, 0x11bc54);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11bc54
// Address: 0x11bc54 - 0x11bc60

void entry_11bc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc54: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bc58: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bc60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bc60
// Address: 0x11bc60 - 0x11bc6c

void entry_11bc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc60: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bc64: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bc6c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bc6c
// Address: 0x11bc6c - 0x11bc84

void entry_11bc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc6c: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11bc70: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11bc74: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x11bc78: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11bc7c: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x11bc84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11bc84
// Address: 0x11bc84 - 0x11bc94

void entry_11bc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc84: 0x10000019
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bc8c: 0xc04725a
    SET_GPR_U32(ctx, 31, 0x11bc94);
    PsmpNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11bc94
// Address: 0x11bc94 - 0x11bca0

void entry_11bc94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bc94: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bc98: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bca0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bca0
// Address: 0x11bca0 - 0x11bcac

void entry_11bca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bca0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bca4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bcac);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bcac
// Address: 0x11bcac - 0x11bcb8

void entry_11bcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bcac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bcb0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11bcb8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bcb8
// Address: 0x11bcb8 - 0x11bcd0

void entry_11bcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bcb8: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x11bcbc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11bcc0: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x11bcc4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11bcc8: 0xc046e18
    SET_GPR_U32(ctx, 31, 0x11bcd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetSmp__4CRefP3SMP(rdram, ctx, runtime); return;
}


// Function: entry_11bcd0
// Address: 0x11bcd0 - 0x11bce0

void entry_11bcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bcd0: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11bcec(rdram, ctx, runtime); return;
    }
    // 0x11bcd8: 0xc046e8a
    SET_GPR_U32(ctx, 31, 0x11bce0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PpairSerializeIn__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bce0
// Address: 0x11bce0 - 0x11bcec

void entry_11bce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bce0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bce4: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x11bcec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_11bcec
// Address: 0x11bcec - 0x11bcfc

void entry_11bcec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bcec: 0x52a00004
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 0));
        ctx->pc = 0x11BD00; return;
    }
    // 0x11bcf4: 0xc046e8a
    SET_GPR_U32(ctx, 31, 0x11bcfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PpairSerializeIn__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11bcfc
// Address: 0x11bcfc - 0x11bd28

void entry_11bcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11bcfc) {
        switch (ctx->pc) {
            case 0x11bd00: ctx->pc = 0; goto label_11bd00;
            case 0x11bd04: ctx->pc = 0; goto label_11bd04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11bcfc: 0xae620008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 2));
label_11bd00:
    // 0x11bd00: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_11bd04:
    // 0x11bd04: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11bd08: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11bd0c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11bd10: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11bd14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11bd18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11bd1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11bd20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RefAddBinding__8CSidebagiP4CRef
// Address: 0x11bd28 - 0x11bd5c

void entry_11bd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bd5c: 0xc047126
    SET_GPR_U32(ctx, 31, 0x11bd64);
    FUN_0011C498(rdram, ctx, runtime); return;
}


// Function: entry_11bd64
// Address: 0x11bd64 - 0x11bd78

void entry_11bd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bd64: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bd68: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11bd6c: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x11bd70: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11bd78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11bd78
// Address: 0x11bd78 - 0x11bd90

void entry_11bd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bd78: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11bd7c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11bd80: 0x24050022
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    // 0x11bd84: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x11bd88: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11bd90);
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11bd90
// Address: 0x11bd90 - 0x11bd9c

void entry_11bd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bd90: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11bd94: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11bd9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11bd9c
// Address: 0x11bd9c - 0x11bda8

void entry_11bd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bd9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11bda0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11bda8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11bda8
// Address: 0x11bda8 - 0x11bdd0

void entry_11bda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bda8: 0x280102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11bdac: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11bdb0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11bdb4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11bdb8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11bdbc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11bdc0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11bdc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11bdcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11bdd0; return;
}


// Function: RefSetBinding__8CSidebagiP4CRef
// Address: 0x11bdd0 - 0x11be08

void entry_11be08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be08: 0x26040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4));
    // 0x11be0c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x11be14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11be14
// Address: 0x11be14 - 0x11be20

void entry_11be14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11be18: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11be20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11be20
// Address: 0x11be20 - 0x11be2c

void entry_11be20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be20: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11be24: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11be2c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11be2c
// Address: 0x11be2c - 0x11be38

void entry_11be2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be2c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11be30: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11be38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11be38
// Address: 0x11be38 - 0x11be50

void entry_11be38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11be38) {
        switch (ctx->pc) {
            case 0x11be40: ctx->pc = 0; goto label_11be40;
            case 0x11be48: ctx->pc = 0; goto label_11be48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11be38: 0x1000000f
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11BE78; return;
    }
label_11be40:
    // 0x11be40: 0x5600ffed
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x11BDF8; return;
    }
label_11be48:
    // 0x11be48: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11be50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11be50
// Address: 0x11be50 - 0x11be5c

void entry_11be50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11be54: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x11be5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_11be5c
// Address: 0x11be5c - 0x11be68

void entry_11be5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be5c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11be60: 0xc046c06
    SET_GPR_U32(ctx, 31, 0x11be68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11be68
// Address: 0x11be68 - 0x11be74

void entry_11be68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11be68: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11be6c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11be74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11be74
// Address: 0x11be74 - 0x11be90

void entry_11be74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11be74) {
        switch (ctx->pc) {
            case 0x11be78: ctx->pc = 0; goto label_11be78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11be74: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_11be78:
    // 0x11be78: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11be7c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11be80: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11be84: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11be88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFindBinding__8CSidebagiP4CRef
// Address: 0x11be90 - 0x11bec0

void entry_11bec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11bec0) {
        switch (ctx->pc) {
            case 0x11bec8: ctx->pc = 0; goto label_11bec8;
            case 0x11bed0: ctx->pc = 0; goto label_11bed0;
            case 0x11bed4: ctx->pc = 0; goto label_11bed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11bec0: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11bed4;
    }
label_11bec8:
    // 0x11bec8: 0x5460fff7
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
        ctx->pc = 0x11BEA8; return;
    }
label_11bed0:
    // 0x11bed0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11bed4:
    // 0x11bed4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11bed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneTo__8CSidebagP8CSidebag
// Address: 0x11bee0 - 0x11bf00

void entry_11bf00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bf00: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bf04: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11bf08: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11bf0c: 0xc047106
    SET_GPR_U32(ctx, 31, 0x11bf14);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0011C418(rdram, ctx, runtime); return;
}


// Function: entry_11bf14
// Address: 0x11bf14 - 0x11bf30

void entry_11bf14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bf14: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x11bf18: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11bf1c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11bf20: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11bf24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11bf28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsidebagNew__Fv
// Address: 0x11bf30 - 0x11bf44

void entry_11bf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bf44: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11bf48: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11bf4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11bf50: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11bf58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11bf58
// Address: 0x11bf58 - 0x11bf70

void entry_11bf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bf58: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11bf5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11bf60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11bf64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11bf6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11bf70; return;
}


// Function: StartupSplice__Fv
// Address: 0x11bf70 - 0x11bf8c

void entry_11bf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bf8c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x11bf90: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11bf94: 0x2610c250
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294951504));
    // 0x11bf98: 0x24062000
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8192));
    // 0x11bf9c: 0xc04704a
    SET_GPR_U32(ctx, 31, 0x11bfa4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Startup__10CSplotheapii(rdram, ctx, runtime); return;
}


// Function: entry_11bfa4
// Address: 0x11bfa4 - 0x11bfc8

void entry_11bfa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bfa4: 0x3c020012
    SET_GPR_U32(ctx, 2, ((uint32_t)18 << 16));
    // 0x11bfa8: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x11bfac: 0x2631c270
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294951536));
    // 0x11bfb0: 0x2442af78
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946680));
    // 0x11bfb4: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x11bfb8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11bfbc: 0x2405001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 28));
    // 0x11bfc0: 0xc04704a
    SET_GPR_U32(ctx, 31, 0x11bfc8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 400));
    Startup__10CSplotheapii(rdram, ctx, runtime); return;
}


// Function: entry_11bfc8
// Address: 0x11bfc8 - 0x11bfec

void entry_11bfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bfc8: 0x3c020012
    SET_GPR_U32(ctx, 2, ((uint32_t)18 << 16));
    // 0x11bfcc: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x11bfd0: 0x2610c290
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294951568));
    // 0x11bfd4: 0x2442a670
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944368));
    // 0x11bfd8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11bfdc: 0xae220018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 2));
    // 0x11bfe0: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x11bfe4: 0xc04704a
    SET_GPR_U32(ctx, 31, 0x11bfec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2048));
    Startup__10CSplotheapii(rdram, ctx, runtime); return;
}


// Function: entry_11bfec
// Address: 0x11bfec - 0x11c00c

void entry_11bfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11bfec: 0x3c020012
    SET_GPR_U32(ctx, 2, ((uint32_t)18 << 16));
    // 0x11bff0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11bff4: 0x2442c4e8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952168));
    // 0x11bff8: 0x2484c2b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951600));
    // 0x11bffc: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x11c000: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x11c004: 0xc04704a
    SET_GPR_U32(ctx, 31, 0x11c00c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2048));
    Startup__10CSplotheapii(rdram, ctx, runtime); return;
}


// Function: entry_11c00c
// Address: 0x11c00c - 0x11c014

void entry_11c00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c00c: 0xc0472a4
    SET_GPR_U32(ctx, 31, 0x11c014);
    StartupSpliceStructuredTypeFactories__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11c014
// Address: 0x11c014 - 0x11c028

void entry_11c014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c014: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c018: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11c01c: 0x2484c2d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951632));
    // 0x11c020: 0xc04704a
    SET_GPR_U32(ctx, 31, 0x11c028);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    Startup__10CSplotheapii(rdram, ctx, runtime); return;
}


// Function: entry_11c028
// Address: 0x11c028 - 0x11c040

void entry_11c028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c028: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c02c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c030: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c040; return;
}


// Function: ShutdownSplice__Fv
// Address: 0x11c040 - 0x11c054

void entry_11c054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c054: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c058: 0xc047074
    SET_GPR_U32(ctx, 31, 0x11c060);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951536));
    Shutdown__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11c060
// Address: 0x11c060 - 0x11c06c

void entry_11c060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c060: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c064: 0xc047074
    SET_GPR_U32(ctx, 31, 0x11c06c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951568));
    Shutdown__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11c06c
// Address: 0x11c06c - 0x11c078

void entry_11c06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c06c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c070: 0xc047074
    SET_GPR_U32(ctx, 31, 0x11c078);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951600));
    Shutdown__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11c078
// Address: 0x11c078 - 0x11c080

void entry_11c078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c078: 0xc0472ec
    SET_GPR_U32(ctx, 31, 0x11c080);
    ShutdownSpliceStructuredTypeFactories__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11c080
// Address: 0x11c080 - 0x11c08c

void entry_11c080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c080: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c084: 0xc047074
    SET_GPR_U32(ctx, 31, 0x11c08c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951632));
    Shutdown__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11c08c
// Address: 0x11c08c - 0x11c098

void entry_11c08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c08c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c090: 0xc0469ae
    SET_GPR_U32(ctx, 31, 0x11c098);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Shutdown__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c098
// Address: 0x11c098 - 0x11c0a8

void entry_11c098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c098: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c09c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c0a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c0a8; return;
}


// Function: spliceutils__static_initialization_and_destruction_0
// Address: 0x11c0a8 - 0x11c0e8

void FUN_0011c0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c0e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x11c0ec: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11c0f0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x11c0f4: 0xc04702a
    SET_GPR_U32(ctx, 31, 0x11c0fc);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    spliceutils__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_11c0fc
// Address: 0x11c0fc - 0x11c108

void entry_11c0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c0fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c100: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0011c108
// Address: 0x11c108 - 0x11c11c

void FUN_0011c108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c108: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x11c10c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11c110: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x11c114: 0xc04702a
    SET_GPR_U32(ctx, 31, 0x11c11c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    spliceutils__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_11c11c
// Address: 0x11c11c - 0x11c128

void entry_11c11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c11c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Startup__10CSplotheapii
// Address: 0x11c128 - 0x11c160

void entry_11c160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c160: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x11c164: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11c168: 0xc0470a2
    SET_GPR_U32(ctx, 31, 0x11c170);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsplotLookup__10CSplotheapi(rdram, ctx, runtime); return;
}


// Function: entry_11c170
// Address: 0x11c170 - 0x11c194

void entry_11c170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c170) {
        switch (ctx->pc) {
            case 0x11c180: ctx->pc = 0; goto label_11c180;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c170: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c174: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x11c178: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C1A4; return;
    }
label_11c180:
    // 0x11c180: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x11c184: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11c188: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11c18c: 0xc0470a2
    SET_GPR_U32(ctx, 31, 0x11c194);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    PsplotLookup__10CSplotheapi(rdram, ctx, runtime); return;
}


// Function: entry_11c194
// Address: 0x11c194 - 0x11c1d0

void entry_11c194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c194) {
        switch (ctx->pc) {
            case 0x11c1a4: ctx->pc = 0; goto label_11c1a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c194: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c198: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x11c19c: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C180; return;
    }
label_11c1a4:
    // 0x11c1a4: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
    // 0x11c1a8: 0xae200014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 0));
    // 0x11c1ac: 0xae200010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 0));
    // 0x11c1b0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11c1b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c1b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c1bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c1c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c1c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c1cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c1d0; return;
}


// Function: Shutdown__10CSplotheap
// Address: 0x11c1d0 - 0x11c1d8

void entry_11c200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c200) {
        switch (ctx->pc) {
            case 0x11c204: ctx->pc = 0; goto label_11c204;
            case 0x11c214: ctx->pc = 0; goto label_11c214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c200: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_11c204:
    // 0x11c204: 0x54a00003
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
        goto label_11c214;
    }
    // 0x11c20c: 0x10000007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11c22c(rdram, ctx, runtime); return;
    }
label_11c214:
    // 0x11c214: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x11c218: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x11c21c: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x11c220: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x11c224: 0xc0470ee
    SET_GPR_U32(ctx, 31, 0x11c22c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 5));
    PvFromPsplot__FP5SPLOT(rdram, ctx, runtime); return;
}


// Function: entry_11c22c
// Address: 0x11c22c - 0x11c240

void entry_11c22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c22c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c230: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c234: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c23c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c240; return;
}


// Function: PvAllocClear__10CSplotheap
// Address: 0x11c240 - 0x11c258

void entry_11c258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c258: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11c25c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c260: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11c264: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11c268: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c270);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967288));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c270
// Address: 0x11c270 - 0x11c288

void entry_11c270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c270: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11c274: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c278: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c27c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c280: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsplotLookup__10CSplotheapi
// Address: 0x11c288 - 0x11c2a0

void entry_11c37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c37c: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x11c380: 0x60f809
    SET_GPR_U32(ctx, 31, 0x11c388);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_11c388
// Address: 0x11c388 - 0x11c3b8

void entry_11c388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c388) {
        switch (ctx->pc) {
            case 0x11c38c: ctx->pc = 0; goto label_11c38c;
            case 0x11c398: ctx->pc = 0; goto label_11c398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c388: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_11c38c:
    // 0x11c38c: 0x5480ffee
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        ctx->pc = 0x11C348; return;
    }
    // 0x11c394: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_11c398:
    // 0x11c398: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c39c: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x11c3a0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c3a4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c3a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c3ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c3b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c3b8; return;
}


// Function: PvFromPsplot__FP5SPLOT
// Address: 0x11c3b8 - 0x11c3c0

void entry_11c3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c3d8: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x11c3dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c3e0: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x11c3e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c3ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c3f0; return;
}


// Function: MarkPvAlive__FPv
// Address: 0x11c3f0 - 0x11c400

void entry_11c400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c400: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11c404: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c408: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x11c40c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c414: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c418; return;
}


// Function: FUN_0011C418
// Address: 0x11c418 - 0x11c450

void FUN_0011C418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c418: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x11c41c: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x11c420: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x11c424: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x11c428: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x11c42c: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x11c430: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x11c434: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11c438: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x11c43c: 0x26240004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4));
    // 0x11c440: 0x26450004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 4));
    // 0x11c444: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11c448: 0xc046c96
    SET_GPR_U32(ctx, 31, 0x11c450);
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 2));
    CloneTo__4CRefP4CRefP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_11c450
// Address: 0x11c450 - 0x11c464

void entry_11c450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c450: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x11c454: 0x1040000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C480; return;
    }
    // 0x11c45c: 0xc047126
    SET_GPR_U32(ctx, 31, 0x11c464);
    FUN_0011C498(rdram, ctx, runtime); return;
}


// Function: entry_11c464
// Address: 0x11c464 - 0x11c478

void entry_11c464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c464: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c468: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x11c46c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11c470: 0xc047106
    SET_GPR_U32(ctx, 31, 0x11c478);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0011C418(rdram, ctx, runtime); return;
}


// Function: entry_11c478
// Address: 0x11c478 - 0x11c498

void entry_11c478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c478) {
        switch (ctx->pc) {
            case 0x11c480: ctx->pc = 0; goto label_11c480;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c478: 0xae50000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 16));
    // 0x11c47c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_11c480:
    // 0x11c480: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c484: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c488: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c48c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c490: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0011C498
// Address: 0x11c498 - 0x11c4b0

void FUN_0011C498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c498: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x11c49c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c4a0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x11c4a4: 0x2484c290
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951568));
    // 0x11c4a8: 0xc047090
    SET_GPR_U32(ctx, 31, 0x11c4b0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    PvAllocClear__10CSplotheap(rdram, ctx, runtime); return;
}


// Function: entry_11c4b0
// Address: 0x11c4b0 - 0x11c4c4

void entry_11c4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c4b0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c4b4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11c4b8: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x11c4bc: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c4c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c4c4
// Address: 0x11c4c4 - 0x11c4cc

void entry_11c4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c4c4: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x11c4cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_11c4cc
// Address: 0x11c4cc - 0x11c4e8

void entry_11c4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c4cc: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11c4d0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c4d4: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
    // 0x11c4d8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c4dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c4e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0011C4E8
// Address: 0x11c4e8 - 0x11c4fc

void FUN_0011C4E8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c4e8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x11c4ec: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x11c4f0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x11c4f4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11c4fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11c4fc
// Address: 0x11c4fc - 0x11c508

void entry_11c4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c4fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c500: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PvectorNew__Fv
// Address: 0x11c508 - 0x11c52c

void entry_11c52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c52c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c530: 0x12000006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294952280)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C54C; return;
    }
    // 0x11c538: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c53c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c544);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c544
// Address: 0x11c544 - 0x11c558

void entry_11c544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c544) {
        switch (ctx->pc) {
            case 0x11c54c: ctx->pc = 0; goto label_11c54c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c544: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C568; return;
    }
label_11c54c:
    // 0x11c54c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c550: 0xc046ad6
    SET_GPR_U32(ctx, 31, 0x11c558);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Collect__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c558
// Address: 0x11c558 - 0x11c560

void entry_11c558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c558: 0xc06d7b8
    SET_GPR_U32(ctx, 31, 0x11c560);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocSlotheapClearImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_11c560
// Address: 0x11c560 - 0x11c580

void entry_11c560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c560) {
        switch (ctx->pc) {
            case 0x11c568: ctx->pc = 0; goto label_11c568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c560: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c564: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11c568:
    // 0x11c568: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c56c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c570: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c574: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c578: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IncrefVector__FP6VECTOR
// Address: 0x11c580 - 0x11c5b0

void entry_11c600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c600) {
        switch (ctx->pc) {
            case 0x11c604: ctx->pc = 0; goto label_11c604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c600: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11c604:
    // 0x11c604: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c60c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c610; return;
}


// Function: junk_0011C610
// Address: 0x11c610 - 0x11c618

void entry_11c63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c63c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c640: 0x12000006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294952296)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C65C; return;
    }
    // 0x11c648: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c64c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c654);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c654
// Address: 0x11c654 - 0x11c668

void entry_11c654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c654) {
        switch (ctx->pc) {
            case 0x11c65c: ctx->pc = 0; goto label_11c65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c654: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C678; return;
    }
label_11c65c:
    // 0x11c65c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c660: 0xc046ad6
    SET_GPR_U32(ctx, 31, 0x11c668);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Collect__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c668
// Address: 0x11c668 - 0x11c670

void entry_11c668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c668: 0xc06d7b8
    SET_GPR_U32(ctx, 31, 0x11c670);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocSlotheapClearImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_11c670
// Address: 0x11c670 - 0x11c690

void entry_11c670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c670) {
        switch (ctx->pc) {
            case 0x11c678: ctx->pc = 0; goto label_11c678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c670: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c674: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11c678:
    // 0x11c678: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c67c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c680: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c684: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c688: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IncrefMatrix__FP7MATRIX4
// Address: 0x11c690 - 0x11c6c0

void entry_11c710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c710) {
        switch (ctx->pc) {
            case 0x11c714: ctx->pc = 0; goto label_11c714;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c710: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11c714:
    // 0x11c714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c71c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c720; return;
}


// Function: DeleteMatrix__FP7MATRIX4
// Address: 0x11c720 - 0x11c738

void entry_11c738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c738: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c73c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c744: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c748; return;
}


// Function: PclqNew__Fv
// Address: 0x11c748 - 0x11c76c

void entry_11c76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c76c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c770: 0x12000006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294952312)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C78C; return;
    }
    // 0x11c778: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c77c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c784);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c784
// Address: 0x11c784 - 0x11c798

void entry_11c784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c784) {
        switch (ctx->pc) {
            case 0x11c78c: ctx->pc = 0; goto label_11c78c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c784: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C7A8; return;
    }
label_11c78c:
    // 0x11c78c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c790: 0xc046ad6
    SET_GPR_U32(ctx, 31, 0x11c798);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Collect__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c798
// Address: 0x11c798 - 0x11c7a0

void entry_11c798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c798: 0xc06d7b8
    SET_GPR_U32(ctx, 31, 0x11c7a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocSlotheapClearImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_11c7a0
// Address: 0x11c7a0 - 0x11c7c0

void entry_11c7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c7a0) {
        switch (ctx->pc) {
            case 0x11c7a8: ctx->pc = 0; goto label_11c7a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c7a0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c7a4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11c7a8:
    // 0x11c7a8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c7ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c7b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c7b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c7b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IncrefClq__FP3CLQ
// Address: 0x11c7c0 - 0x11c7f0

void entry_11c840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c840) {
        switch (ctx->pc) {
            case 0x11c844: ctx->pc = 0; goto label_11c844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c840: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11c844:
    // 0x11c844: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c84c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c850; return;
}


// Function: junk_0011C850
// Address: 0x11c850 - 0x11c858

void entry_11c87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c87c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c880: 0x12000006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294952328)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C89C; return;
    }
    // 0x11c888: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c88c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c894);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c894
// Address: 0x11c894 - 0x11c8a8

void entry_11c894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c894) {
        switch (ctx->pc) {
            case 0x11c89c: ctx->pc = 0; goto label_11c89c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c894: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C8B8; return;
    }
label_11c89c:
    // 0x11c89c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c8a0: 0xc046ad6
    SET_GPR_U32(ctx, 31, 0x11c8a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Collect__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c8a8
// Address: 0x11c8a8 - 0x11c8b0

void entry_11c8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c8a8: 0xc06d7b8
    SET_GPR_U32(ctx, 31, 0x11c8b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocSlotheapClearImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_11c8b0
// Address: 0x11c8b0 - 0x11c8d0

void entry_11c8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c8b0) {
        switch (ctx->pc) {
            case 0x11c8b8: ctx->pc = 0; goto label_11c8b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c8b0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c8b4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11c8b8:
    // 0x11c8b8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c8bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c8c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c8c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c8c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IncrefLm__FP2LM
// Address: 0x11c8d0 - 0x11c900

void entry_11c950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c950) {
        switch (ctx->pc) {
            case 0x11c954: ctx->pc = 0; goto label_11c954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c950: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11c954:
    // 0x11c954: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11c95c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11c960; return;
}


// Function: junk_0011C960
// Address: 0x11c960 - 0x11c968

void entry_11c98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c98c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c990: 0x12000006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294952344)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C9AC; return;
    }
    // 0x11c998: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11c99c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x11c9a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_11c9a4
// Address: 0x11c9a4 - 0x11c9b8

void entry_11c9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c9a4) {
        switch (ctx->pc) {
            case 0x11c9ac: ctx->pc = 0; goto label_11c9ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c9a4: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11C9C8; return;
    }
label_11c9ac:
    // 0x11c9ac: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11c9b0: 0xc046ad6
    SET_GPR_U32(ctx, 31, 0x11c9b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    Collect__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_11c9b8
// Address: 0x11c9b8 - 0x11c9c0

void entry_11c9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11c9b8: 0xc06d7b8
    SET_GPR_U32(ctx, 31, 0x11c9c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocSlotheapClearImpl__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_11c9c0
// Address: 0x11c9c0 - 0x11c9e0

void entry_11c9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11c9c0) {
        switch (ctx->pc) {
            case 0x11c9c8: ctx->pc = 0; goto label_11c9c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11c9c0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11c9c4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11c9c8:
    // 0x11c9c8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11c9cc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11c9d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11c9d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11c9d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IncrefSmp__FP3SMP
// Address: 0x11c9e0 - 0x11ca20

void entry_11ca80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ca80) {
        switch (ctx->pc) {
            case 0x11ca84: ctx->pc = 0; goto label_11ca84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ca80: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11ca84:
    // 0x11ca84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11ca8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11ca90; return;
}


// Function: StartupSpliceStructuredTypeFactories__Fv
// Address: 0x11ca90 - 0x11cae8

void entry_11cae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cae8: 0x3c110028
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    // 0x11caec: 0x8e04c2f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294951664)));
    // 0x11caf0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x11caf8);
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11caf8
// Address: 0x11caf8 - 0x11cb14

void entry_11caf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11caf8: 0x8e46c2f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4294951668)));
    // 0x11cafc: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x11cb00: 0xae22b300
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947584), GPR_U32(ctx, 2));
    // 0x11cb04: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x11cb08: 0x2484c568
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952296));
    // 0x11cb0c: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x11cb14);
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_11cb14
// Address: 0x11cb14 - 0x11cb1c

void entry_11cb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb14: 0xc063570
    SET_GPR_U32(ctx, 31, 0x11cb1c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4294951668)));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11cb1c
// Address: 0x11cb1c - 0x11cb34

void entry_11cb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb1c: 0x8e66c2f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 4294951672)));
    // 0x11cb20: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x11cb24: 0xae02b304
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947588), GPR_U32(ctx, 2));
    // 0x11cb28: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x11cb2c: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x11cb34);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952312));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_11cb34
// Address: 0x11cb34 - 0x11cb3c

void entry_11cb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb34: 0xc063570
    SET_GPR_U32(ctx, 31, 0x11cb3c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4294951672)));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11cb3c
// Address: 0x11cb3c - 0x11cb54

void entry_11cb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb3c: 0x8e86c2fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 4294951676)));
    // 0x11cb40: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x11cb44: 0xaea2b308
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294947592), GPR_U32(ctx, 2));
    // 0x11cb48: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x11cb4c: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x11cb54);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952328));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_11cb54
// Address: 0x11cb54 - 0x11cb5c

void entry_11cb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb54: 0xc063570
    SET_GPR_U32(ctx, 31, 0x11cb5c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4294951676)));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11cb5c
// Address: 0x11cb5c - 0x11cb74

void entry_11cb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb5c: 0x8e26c300
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294951680)));
    // 0x11cb60: 0x3c040063
    SET_GPR_U32(ctx, 4, ((uint32_t)99 << 16));
    // 0x11cb64: 0xaec2b30c
    WRITE32(ADD32(GPR_U32(ctx, 22), 4294947596), GPR_U32(ctx, 2));
    // 0x11cb68: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11cb6c: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x11cb74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952344));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_11cb74
// Address: 0x11cb74 - 0x11cb7c

void entry_11cb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb74: 0xc063570
    SET_GPR_U32(ctx, 31, 0x11cb7c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294951680)));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11cb7c
// Address: 0x11cb7c - 0x11cbb0

void entry_11cb7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cb7c: 0xaee2b310
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294947600), GPR_U32(ctx, 2));
    // 0x11cb80: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11cb84: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11cb88: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11cb8c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11cb90: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11cb94: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11cb98: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11cb9c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11cba0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11cba4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11cbac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11cbb0; return;
}


// Function: ShutdownSpliceStructuredTypeFactories__Fv
// Address: 0x11cbb0 - 0x11cbb8

void entry_11cc58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cc58) {
        switch (ctx->pc) {
            case 0x11cc78: ctx->pc = 0; goto label_11cc78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11cc58: 0x3c170028
    SET_GPR_U32(ctx, 23, ((uint32_t)40 << 16));
    // 0x11cc5c: 0x3c1e0026
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    // 0x11cc60: 0x3c130025
    SET_GPR_U32(ctx, 19, ((uint32_t)37 << 16));
    // 0x11cc64: 0x3c140025
    SET_GPR_U32(ctx, 20, ((uint32_t)37 << 16));
    // 0x11cc68: 0x24122710
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 10000));
    // 0x11cc6c: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11cc70: 0x3c050012
    SET_GPR_U32(ctx, 5, ((uint32_t)18 << 16));
    // 0x11cc74: 0x0
    // NOP
label_11cc78:
    // 0x11cc78: 0x2604b4c8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294948040));
    // 0x11cc7c: 0x34a53456
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 13398));
    // 0x11cc80: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x11cc88);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_11cc88
// Address: 0x11cc88 - 0x11cca0

void entry_11cc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cc88: 0x441000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x11CCBC; return;
    }
    // 0x11cc90: 0x26649428
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294939688));
    // 0x11cc94: 0x26859450
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 4294939728));
    // 0x11cc98: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11cca0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 110));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11cca0
// Address: 0x11cca0 - 0x11cd40

void entry_11cca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cca0) {
        switch (ctx->pc) {
            case 0x11ccbc: ctx->pc = 0; goto label_11ccbc;
            case 0x11ccd0: ctx->pc = 0; goto label_11ccd0;
            case 0x11ccf0: ctx->pc = 0; goto label_11ccf0;
            case 0x11cd30: ctx->pc = 0; goto label_11cd30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

label_11cca0:
    // 0x11cca0: 0x0
    // NOP
    // 0x11cca4: 0x0
    // NOP
    // 0x11cca8: 0x0
    // NOP
    // 0x11ccac: 0x0
    // NOP
    // 0x11ccb0: 0x0
    // NOP
    // 0x11ccb4: 0x1000fffa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11cca0(rdram, ctx, runtime); return;
    }
label_11ccbc:
    // 0x11ccbc: 0x1051000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_11ccf0;
    }
    // 0x11ccc4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11ccc8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x11cccc: 0x0
    // NOP
label_11ccd0:
    // 0x11ccd0: 0x0
    // NOP
    // 0x11ccd4: 0x0
    // NOP
    // 0x11ccd8: 0x0
    // NOP
    // 0x11ccdc: 0x0
    // NOP
    // 0x11cce0: 0x0
    // NOP
    // 0x11cce4: 0x5443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
        goto label_11ccd0;
    }
    // 0x11ccec: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_11ccf0:
    // 0x11ccf0: 0x8ec20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 36)));
    // 0x11ccf4: 0x1040ffe0
    SET_GPR_U32(ctx, 5, ((uint32_t)18 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CC78; return;
    }
    // 0x11ccfc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11cd00: 0x26a4c390
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 4294951824));
    // 0x11cd04: 0xac40c388
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294951816), GPR_U32(ctx, 0));
    // 0x11cd08: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x11cd0c: 0xaea0c390
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294951824), GPR_U32(ctx, 0));
    // 0x11cd10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11cd14: 0xfc800008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 0));
    // 0x11cd18: 0x2474b4f0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 3), 4294948080));
    // 0x11cd1c: 0xac400e00
    WRITE32(ADD32(GPR_U32(ctx, 2), 3584), GPR_U32(ctx, 0));
    // 0x11cd20: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x11cd24: 0x3c130025
    SET_GPR_U32(ctx, 19, ((uint32_t)37 << 16));
    // 0x11cd28: 0x24112710
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 10000));
    // 0x11cd2c: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
label_11cd30:
    // 0x11cd30: 0x26e4b4f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 23), 4294948080));
    // 0x11cd34: 0x34a53457
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 13399));
    // 0x11cd38: 0xc07e030
    SET_GPR_U32(ctx, 31, 0x11cd40);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifBindRpc(rdram, ctx, runtime); return;
}


// Function: entry_11cd40
// Address: 0x11cd40 - 0x11cd58

void entry_11cd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cd40: 0x441000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x11CD74; return;
    }
    // 0x11cd48: 0x26449428
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294939688));
    // 0x11cd4c: 0x26659450
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 4294939728));
    // 0x11cd50: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11cd58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 131));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11cd58
// Address: 0x11cd58 - 0x11ce00

void entry_11cd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cd58) {
        switch (ctx->pc) {
            case 0x11cd74: ctx->pc = 0; goto label_11cd74;
            case 0x11cd88: ctx->pc = 0; goto label_11cd88;
            case 0x11cda8: ctx->pc = 0; goto label_11cda8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

label_11cd58:
    // 0x11cd58: 0x0
    // NOP
    // 0x11cd5c: 0x0
    // NOP
    // 0x11cd60: 0x0
    // NOP
    // 0x11cd64: 0x0
    // NOP
    // 0x11cd68: 0x0
    // NOP
    // 0x11cd6c: 0x1000fffa
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11cd58(rdram, ctx, runtime); return;
    }
label_11cd74:
    // 0x11cd74: 0x1050000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        goto label_11cda8;
    }
    // 0x11cd7c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11cd80: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x11cd84: 0x0
    // NOP
label_11cd88:
    // 0x11cd88: 0x0
    // NOP
    // 0x11cd8c: 0x0
    // NOP
    // 0x11cd90: 0x0
    // NOP
    // 0x11cd94: 0x0
    // NOP
    // 0x11cd98: 0x0
    // NOP
    // 0x11cd9c: 0x5443fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
        goto label_11cd88;
    }
    // 0x11cda4: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_11cda8:
    // 0x11cda8: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x11cdac: 0x1040ffe0
    SET_GPR_U32(ctx, 5, ((uint32_t)18 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CD30; return;
    }
    // 0x11cdb4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11cdb8: 0xafc00dc0
    WRITE32(ADD32(GPR_U32(ctx, 30), 3520), GPR_U32(ctx, 0));
    // 0x11cdbc: 0x24030ffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4092));
    // 0x11cdc0: 0x2482c368
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294951784));
    // 0x11cdc4: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x11cdc8: 0x27c70dc0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 30), 3520));
    // 0x11cdcc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11cdd0: 0xafa70000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 7));
    // 0x11cdd4: 0xac40c540
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294952256), GPR_U32(ctx, 0));
    // 0x11cdd8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11cddc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11cde0: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x11cde4: 0xac40d540
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294956352), GPR_U32(ctx, 0));
    // 0x11cde8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11cdec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11cdf0: 0xac43c368
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294951784), GPR_U32(ctx, 3));
    // 0x11cdf4: 0xace00010
    WRITE32(ADD32(GPR_U32(ctx, 7), 16), GPR_U32(ctx, 0));
    // 0x11cdf8: 0xc04765a
    SET_GPR_U32(ctx, 31, 0x11ce00);
    snd_SendIOPCommandAndWait__FiiPc(rdram, ctx, runtime); return;
}


// Function: entry_11ce00
// Address: 0x11ce00 - 0x11ce30

void entry_11ce00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ce00: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11ce04: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11ce08: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11ce0c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11ce10: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ce14: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11ce18: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11ce1c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ce20: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ce24: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ce28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_FlushSoundCommands
// Address: 0x11ce30 - 0x11ce74

void entry_11ce74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ce74: 0x10400035
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4294951816)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CF4C; return;
    }
    // 0x11ce7c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x11ce80: 0x8e22c35c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294951772)));
    // 0x11ce84: 0x1040000b
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CEB4; return;
    }
    // 0x11ce8c: 0x8e06c3a0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4294951840)));
    // 0x11ce90: 0x10c00005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_11cea8(rdram, ctx, runtime); return;
    }
    // 0x11ce98: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11ce9c: 0x8c44c3c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294951876)));
    // 0x11cea0: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x11cea8);
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 3), 4294951848)));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_11cea8
// Address: 0x11cea8 - 0x11cf30

void entry_11cea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cea8) {
        switch (ctx->pc) {
            case 0x11ceb4: ctx->pc = 0; goto label_11ceb4;
            case 0x11cf08: ctx->pc = 0; goto label_11cf08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11cea8: 0xae00c3a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294951840), GPR_U32(ctx, 0));
    // 0x11ceac: 0x10000026
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294951772), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CF48; return;
    }
label_11ceb4:
    // 0x11ceb4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11ceb8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11cebc: 0x8c62c380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294951808)));
    // 0x11cec0: 0x2484c360
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294951776));
    // 0x11cec4: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x11cec8: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x11cecc: 0x22880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), 2));
    // 0x11ced0: 0xa42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x11ced4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11ced8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11cedc: 0x1860001a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x11CF48; return;
    }
    // 0x11cee4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11cee8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11ceec: 0x2463c370
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294951792));
    // 0x11cef0: 0x2442c378
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294951800));
    // 0x11cef4: 0xa29821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x11cef8: 0xa39021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x11cefc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11cf00: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x11cf04: 0x0
    // NOP
label_11cf08:
    // 0x11cf08: 0x101100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 4));
    // 0x11cf0c: 0x432021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11cf10: 0x8c860000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11cf14: 0x10c00006
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        entry_11cf30(rdram, ctx, runtime); return;
    }
    // 0x11cf1c: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11cf20: 0xdc850008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x11cf24: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11cf28: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x11cf30);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_11cf30
// Address: 0x11cf30 - 0x11cf5c

void entry_11cf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cf30) {
        switch (ctx->pc) {
            case 0x11cf48: ctx->pc = 0; goto label_11cf48;
            case 0x11cf4c: ctx->pc = 0; goto label_11cf4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11cf30: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11cf34: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x11cf38: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11cf3c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x11cf40: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x11CF08; return;
    }
label_11cf48:
    // 0x11cf48: 0x8ea2c388
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4294951816)));
label_11cf4c:
    // 0x11cf4c: 0x10400011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CF94; return;
    }
    // 0x11cf54: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11cf5c);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11cf5c
// Address: 0x11cf5c - 0x11cf8c

void entry_11cf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cf5c: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x11cf60: 0x8e040e00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3584)));
    // 0x11cf64: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11cf68: 0x1082000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x11CF94; return;
    }
    // 0x11cf70: 0x8c43c390
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294951824)));
    // 0x11cf74: 0x10600005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294951824));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_11cf8c(rdram, ctx, runtime); return;
    }
    // 0x11cf7c: 0xdcc50008
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x11cf80: 0xac40c390
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294951824), GPR_U32(ctx, 0));
    // 0x11cf84: 0x60f809
    SET_GPR_U32(ctx, 31, 0x11cf8c);
    WRITE64(ADD32(GPR_U32(ctx, 6), 8), GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_11cf8c
// Address: 0x11cf8c - 0x11cfdc

void entry_11cf8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cf8c) {
        switch (ctx->pc) {
            case 0x11cf94: ctx->pc = 0; goto label_11cf94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11cf8c: 0xae000e00
    WRITE32(ADD32(GPR_U32(ctx, 16), 3584), GPR_U32(ctx, 0));
    // 0x11cf90: 0xaea0c388
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294951816), GPR_U32(ctx, 0));
label_11cf94:
    // 0x11cf94: 0x8ec2c340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4294951744)));
    // 0x11cf98: 0x14400011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294951764)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CFE0; return;
    }
    // 0x11cfa0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11cfa4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11cfa8: 0x8c82c380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294951808)));
    // 0x11cfac: 0x2463c360
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294951776));
    // 0x11cfb0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x11cfb4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11cfb8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11cfbc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11cfc0: 0x10600006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_11cfdc(rdram, ctx, runtime); return;
    }
    // 0x11cfc8: 0x8c43c384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294951812)));
    // 0x11cfcc: 0x14600004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294951764)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11CFE0; return;
    }
    // 0x11cfd4: 0xc047786
    SET_GPR_U32(ctx, 31, 0x11cfdc);
    snd_SendCurrentBatch__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11cfdc
// Address: 0x11cfdc - 0x11cff0

void entry_11cfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11cfdc) {
        switch (ctx->pc) {
            case 0x11cfe0: ctx->pc = 0; goto label_11cfe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11cfdc: 0x8e82c354
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294951764)));
label_11cfe0:
    // 0x11cfe0: 0x1040000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4294951744)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D01C; return;
    }
    // 0x11cfe8: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x11cff0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_11cff0
// Address: 0x11cff0 - 0x11d018

void entry_11cff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11cff0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11cff4: 0x8c62c358
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294951768)));
    // 0x11cff8: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11d018(rdram, ctx, runtime); return;
    }
    // 0x11d000: 0xae80c354
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294951764), GPR_U32(ctx, 0));
    // 0x11d004: 0x8c42c350
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294951760)));
    // 0x11d008: 0x10400003
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294951768), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11d018(rdram, ctx, runtime); return;
    }
    // 0x11d010: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11d018);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11d018
// Address: 0x11d018 - 0x11d060

void entry_11d018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d018) {
        switch (ctx->pc) {
            case 0x11d01c: ctx->pc = 0; goto label_11d01c;
            case 0x11d034: ctx->pc = 0; goto label_11d034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d018: 0x8ec2c340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 4294951744)));
label_11d01c:
    // 0x11d01c: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11d034;
    }
    // 0x11d024: 0x8ea2c388
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4294951816)));
    // 0x11d028: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11d034;
    }
    // 0x11d030: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11d034:
    // 0x11d034: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11d038: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11d03c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11d040: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11d044: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11d048: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11d04c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d050: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11d054: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d05c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d060; return;
}


// Function: junk_0x0011d060
// Address: 0x11d060 - 0x11d078

void entry_11d090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d090) {
        switch (ctx->pc) {
            case 0x11d0a4: ctx->pc = 0; goto label_11d0a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d090: 0x8e02c340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294951744)));
    // 0x11d094: 0x14400003
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11d0a4;
    }
    // 0x11d09c: 0x10000018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D100; return;
    }
label_11d0a4:
    // 0x11d0a4: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11d0ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294948040));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11d0ac
// Address: 0x11d0ac - 0x11d0fc

void entry_11d0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d0ac) {
        switch (ctx->pc) {
            case 0x11d0f4: ctx->pc = 0; goto label_11d0f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d0ac: 0x14400014
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D100; return;
    }
    // 0x11d0b4: 0x8e05c340
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4294951744)));
    // 0x11d0b8: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x11d0bc: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11d0c0: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x11d0c4: 0x5482000b
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
        goto label_11d0f4;
    }
    // 0x11d0cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11d0d0: 0x8c43c344
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294951748)));
    // 0x11d0d4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11d0d8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x11d0dc: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x11d0e0: 0x14440004
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_11d0f4;
    }
    // 0x11d0e8: 0xae00c340
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294951744), GPR_U32(ctx, 0));
    // 0x11d0ec: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D100; return;
    }
label_11d0f4:
    // 0x11d0f4: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d0fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939744));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d0fc
// Address: 0x11d0fc - 0x11d110

void entry_11d0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d0fc) {
        switch (ctx->pc) {
            case 0x11d100: ctx->pc = 0; goto label_11d100;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d0fc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11d100:
    // 0x11d100: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d104: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11d108: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_PrepareReturnBuffer__FPUii
// Address: 0x11d110 - 0x11d138

void entry_11d190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d190) {
        switch (ctx->pc) {
            case 0x11d1a4: ctx->pc = 0; goto label_11d1a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d190: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11d194: 0x14430007
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x11D1B4; return;
    }
    // 0x11d19c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x11d1a0: 0x248495a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940064));
label_11d1a4:
    // 0x11d1a4: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d1ac);
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d1ac
// Address: 0x11d1ac - 0x11d1e8

void entry_11d1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d1ac) {
        switch (ctx->pc) {
            case 0x11d1b4: ctx->pc = 0; goto label_11d1b4;
            case 0x11d1e0: ctx->pc = 0; goto label_11d1e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d1ac: 0x10000035
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D284; return;
    }
label_11d1b4:
    // 0x11d1b4: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x11d1b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11d1bc: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11d1c0: 0x24850e40
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 3648));
    // 0x11d1c4: 0xac620e00
    WRITE32(ADD32(GPR_U32(ctx, 3), 3584), GPR_U32(ctx, 2));
    // 0x11d1c8: 0xacb00004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 16));
    // 0x11d1cc: 0xac910e40
    WRITE32(ADD32(GPR_U32(ctx, 4), 3648), GPR_U32(ctx, 17));
    // 0x11d1d0: 0x60902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x11d1d4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11d1d8: 0x10000007
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11d1f8(rdram, ctx, runtime); return;
    }
label_11d1e0:
    // 0x11d1e0: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d1e8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939880));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d1e8
// Address: 0x11d1e8 - 0x11d1f0

void entry_11d1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d1e8: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11d1f0);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11d1f0
// Address: 0x11d1f0 - 0x11d1f8

void entry_11d1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d1f0: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11d1f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11d1f8
// Address: 0x11d1f8 - 0x11d204

void entry_11d1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d1f8: 0x2630b4f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294948080));
    // 0x11d1fc: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11d204);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11d204
// Address: 0x11d204 - 0x11d234

void entry_11d204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d204: 0x1440fff6
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D1E0; return;
    }
    // 0x11d20c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11d210: 0x26670e40
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 3648));
    // 0x11d214: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11d218: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x11d21c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11d220: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x11d224: 0x26490e00
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 3584));
    // 0x11d228: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x11d22c: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11d234);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11d234
// Address: 0x11d234 - 0x11d248

void entry_11d234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d234: 0x4410008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 3584)));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x11D258; return;
    }
    // 0x11d23c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x11d240: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d248);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940096));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d248
// Address: 0x11d248 - 0x11d278

void entry_11d248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d248) {
        switch (ctx->pc) {
            case 0x11d258: ctx->pc = 0; goto label_11d258;
            case 0x11d270: ctx->pc = 0; goto label_11d270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d248: 0x24030106
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 262));
    // 0x11d24c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11d250: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294951752), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D284; return;
    }
label_11d258:
    // 0x11d258: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x11d25c: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11d260: 0x14620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3584)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x11D284; return;
    }
    // 0x11d268: 0x3c10ffff
    SET_GPR_U32(ctx, 16, ((uint32_t)65535 << 16));
    // 0x11d26c: 0x3610ffff
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 65535));
label_11d270:
    // 0x11d270: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11d278);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11d278
// Address: 0x11d278 - 0x11d2a8

void entry_11d278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d278) {
        switch (ctx->pc) {
            case 0x11d284: ctx->pc = 0; goto label_11d284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d278: 0x8e420e00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3584)));
    // 0x11d27c: 0x1050fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x11D270; return;
    }
label_11d284:
    // 0x11d284: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11d288: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11d28c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11d290: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11d294: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11d298: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d29c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d2a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d2a8; return;
}


// Function: snd_BankLoadByLoc_CB
// Address: 0x11d2a8 - 0x11d2f8

void entry_11d2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d2f8) {
        switch (ctx->pc) {
            case 0x11d300: ctx->pc = 0; goto label_11d300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d2f8: 0x10000033
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D3C8; return;
    }
label_11d300:
    // 0x11d300: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x11d308);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_11d308
// Address: 0x11d308 - 0x11d320

void entry_11d308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d308: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11d30c: 0x14430006
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x11D328; return;
    }
    // 0x11d314: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x11d318: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d320);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940064));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d320
// Address: 0x11d320 - 0x11d370

void entry_11d320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d320) {
        switch (ctx->pc) {
            case 0x11d328: ctx->pc = 0; goto label_11d328;
            case 0x11d368: ctx->pc = 0; goto label_11d368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d320: 0x10000029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D3C8; return;
    }
label_11d328:
    // 0x11d328: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x11d32c: 0x24a30e40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 3648));
    // 0x11d330: 0x24e6c390
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 7), 4294951824));
    // 0x11d334: 0xac700004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 16));
    // 0x11d338: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x11d33c: 0xacf1c390
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294951824), GPR_U32(ctx, 17));
    // 0x11d340: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x11d344: 0xfcd20008
    WRITE64(ADD32(GPR_U32(ctx, 6), 8), GPR_U64(ctx, 18));
    // 0x11d348: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11d34c: 0xac820e00
    WRITE32(ADD32(GPR_U32(ctx, 4), 3584), GPR_U32(ctx, 2));
    // 0x11d350: 0xacb30e40
    WRITE32(ADD32(GPR_U32(ctx, 5), 3648), GPR_U32(ctx, 19));
    // 0x11d354: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x11d358: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x11d35c: 0x10000008
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11d380(rdram, ctx, runtime); return;
    }
    // 0x11d364: 0x0
    // NOP
label_11d368:
    // 0x11d368: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11d370);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939880));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11d370
// Address: 0x11d370 - 0x11d378

void entry_11d370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d370: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11d378);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11d378
// Address: 0x11d378 - 0x11d380

void entry_11d378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d378: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11d380);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11d380
// Address: 0x11d380 - 0x11d38c

void entry_11d380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d380: 0x2630b4f0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294948080));
    // 0x11d384: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11d38c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11d38c
// Address: 0x11d38c - 0x11d3c4

void entry_11d38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d38c: 0x1440fff6
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D368; return;
    }
    // 0x11d394: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11d398: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11d39c: 0xae82c388
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294951816), GPR_U32(ctx, 2));
    // 0x11d3a0: 0x26470e40
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 3648));
    // 0x11d3a4: 0x26690e00
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 3584));
    // 0x11d3a8: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11d3ac: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x11d3b0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11d3b4: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x11d3b8: 0x240a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4));
    // 0x11d3bc: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11d3c4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11d3c4
// Address: 0x11d3c4 - 0x11d3e8

void entry_11d3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d3c4) {
        switch (ctx->pc) {
            case 0x11d3c8: ctx->pc = 0; goto label_11d3c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d3c4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_11d3c8:
    // 0x11d3c8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11d3cc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11d3d0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11d3d4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11d3d8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d3dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d3e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d3e8; return;
}


// Function: junk_0x0011d3e8
// Address: 0x11d3e8 - 0x11d420

void entry_11d440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d440: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11d444: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d44c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d450; return;
}


// Function: snd_UnloadBank
// Address: 0x11d450 - 0x11d474

void entry_11d474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d474: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d478: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_SetMasterVolume
// Address: 0x11d480 - 0x11d4a8

void entry_11d4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d4a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d4ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d4b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d4b8; return;
}


// Function: snd_GetMasterVolume
// Address: 0x11d4b8 - 0x11d4d4

void entry_11d4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d4d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d4d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_SetPlaybackMode
// Address: 0x11d4e0 - 0x11d504

void entry_11d504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d504: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0x0011d510
// Address: 0x11d510 - 0x11d520

void entry_11d548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d548: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d54c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d554: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d558; return;
}


// Function: snd_SetGroupVoiceRange
// Address: 0x11d558 - 0x11d588

void entry_11d588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d588: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d58c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d594: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d598; return;
}


// Function: snd_PlaySoundVolPanPMPB
// Address: 0x11d598 - 0x11d5c8

void entry_11d5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d5c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11d5cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d5d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d5d8; return;
}


// Function: junk_0x0011d5d8
// Address: 0x11d5d8 - 0x11d600

void entry_11d624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d624: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d628: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0x0011d630
// Address: 0x11d630 - 0x11d640

void entry_11d664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d664: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d668: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_ContinueSound
// Address: 0x11d670 - 0x11d694

void entry_11d694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d694: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d698: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0x0011d6a0
// Address: 0x11d6a0 - 0x11d6a8

void entry_11d6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d6cc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d6d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_ContinueAllSoundsInGroup
// Address: 0x11d6d8 - 0x11d6fc

void entry_11d6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d6fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d700: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_SoundIsStillPlaying
// Address: 0x11d708 - 0x11d724

void entry_11d724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d724: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d728: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_SoundIsStillPlaying_CB
// Address: 0x11d730 - 0x11d754

void entry_11d754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d754: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d758: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_IsSoundALooper
// Address: 0x11d760 - 0x11d780

void entry_11d780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d780: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d784: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d78c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d790; return;
}


// Function: junk_0x0011d790
// Address: 0x11d790 - 0x11d798

void entry_11d7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d7c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d7cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d7d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d7d8; return;
}


// Function: snd_GetSoundOriginalPitch
// Address: 0x11d7d8 - 0x11d7f8

void entry_11d7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d7f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d7fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d808; return;
}


// Function: junk_0x0011d808
// Address: 0x11d808 - 0x11d810

void entry_11d838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d838: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d83c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d848; return;
}


// Function: junk_0x0011d848
// Address: 0x11d848 - 0x11d860

void entry_11d890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d890: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d894: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d89c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d8a0; return;
}


// Function: junk_0x0011d8a0
// Address: 0x11d8a0 - 0x11d8b0

void entry_11d8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d8e0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d8e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d8ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d8f0; return;
}


// Function: snd_GetMIDIRegister
// Address: 0x11d8f0 - 0x11d910

void entry_11d910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d910: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11d91c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11d920; return;
}


// Function: junk_0x0011d920
// Address: 0x11d920 - 0x11d928

void entry_11d94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d94c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11d950: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0x0011d958
// Address: 0x11d958 - 0x11d968

void entry_11d9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11d9d8: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11d9e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11d9e0
// Address: 0x11d9e0 - 0x11d9f4

void entry_11d9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d9e0) {
        switch (ctx->pc) {
            case 0x11d9e4: ctx->pc = 0; goto label_11d9e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d9e0: 0x8e22c340
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294951744)));
label_11d9e4:
    // 0x11d9e4: 0x1440fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294951872));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11D9D0; return;
    }
    // 0x11d9ec: 0xc047444
    SET_GPR_U32(ctx, 31, 0x11d9f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    snd_PrepareReturnBuffer__FPUii(rdram, ctx, runtime); return;
}


// Function: entry_11d9f4
// Address: 0x11d9f4 - 0x11da08

void entry_11d9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11d9f4) {
        switch (ctx->pc) {
            case 0x11da00: ctx->pc = 0; goto label_11da00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11d9f4: 0x10000008
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11da18(rdram, ctx, runtime); return;
    }
    // 0x11d9fc: 0x0
    // NOP
label_11da00:
    // 0x11da00: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11da08);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294939880));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11da08
// Address: 0x11da08 - 0x11da10

void entry_11da08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da08: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11da10);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11da10
// Address: 0x11da10 - 0x11da18

void entry_11da10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da10: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11da18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11da18
// Address: 0x11da18 - 0x11da20

void entry_11da18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da18: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11da20);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294948040));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11da20
// Address: 0x11da20 - 0x11da58

void entry_11da20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da20: 0x1440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DA00; return;
    }
    // 0x11da28: 0x1200000d
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DA60; return;
    }
    // 0x11da30: 0x2644b4c8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294948040));
    // 0x11da34: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11da38: 0x24e7c400
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294951936));
    // 0x11da3c: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11da40: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11da44: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11da48: 0x2669c3c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 4294951872));
    // 0x11da4c: 0x240a000c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11da50: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11da58);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11da58
// Address: 0x11da58 - 0x11da88

void entry_11da58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11da58) {
        switch (ctx->pc) {
            case 0x11da60: ctx->pc = 0; goto label_11da60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11da58: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11da88(rdram, ctx, runtime); return;
    }
label_11da60:
    // 0x11da60: 0x2644b4c8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294948040));
    // 0x11da64: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11da68: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11da6c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11da70: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11da74: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11da78: 0x2669c3c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 4294951872));
    // 0x11da7c: 0x240a000c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11da80: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11da88);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11da88
// Address: 0x11da88 - 0x11da90

void entry_11da88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da88: 0xc04741e
    SET_GPR_U32(ctx, 31, 0x11da90);
    snd_GotReturns__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11da90
// Address: 0x11da90 - 0x11dad8

void entry_11da90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11da90: 0x1040fffd
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11da88(rdram, ctx, runtime); return;
    }
    // 0x11da98: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11da9c: 0x8c44c380
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294951808)));
    // 0x11daa0: 0x2463c360
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294951776));
    // 0x11daa4: 0x2662c3c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 4294951872));
    // 0x11daa8: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x11daac: 0x8c500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x11dab0: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x11dab4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11dab8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11dabc: 0x10600006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_11dad8(rdram, ctx, runtime); return;
    }
    // 0x11dac4: 0x8c43c384
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294951812)));
    // 0x11dac8: 0x14600004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DADC; return;
    }
    // 0x11dad0: 0xc047786
    SET_GPR_U32(ctx, 31, 0x11dad8);
    snd_SendCurrentBatch__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11dad8
// Address: 0x11dad8 - 0x11db00

void entry_11dad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dad8) {
        switch (ctx->pc) {
            case 0x11dadc: ctx->pc = 0; goto label_11dadc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dad8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_11dadc:
    // 0x11dadc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11dae0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11dae4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11dae8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11daec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11daf0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11daf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11dafc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11db00; return;
}


// Function: snd_SendIOPCommandNoWait__FiiPcPFiUl_vUl
// Address: 0x11db00 - 0x11db80

void entry_11db80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11db80) {
        switch (ctx->pc) {
            case 0x11db90: ctx->pc = 0; goto label_11db90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11db80: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11db84: 0x10000008
    SET_GPR_U32(ctx, 17, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11dba8(rdram, ctx, runtime); return;
    }
    // 0x11db8c: 0x0
    // NOP
label_11db90:
    // 0x11db90: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11db98);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939880));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11db98
// Address: 0x11db98 - 0x11dba0

void entry_11db98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11db98: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11dba0);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11dba0
// Address: 0x11dba0 - 0x11dba8

void entry_11dba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dba0: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11dba8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11dba8
// Address: 0x11dba8 - 0x11dbb4

void entry_11dba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dba8: 0x2630b4c8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294948040));
    // 0x11dbac: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11dbb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11dbb4
// Address: 0x11dbb4 - 0x11dbe4

void entry_11dbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dbb4: 0x1440fff6
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DB90; return;
    }
    // 0x11dbbc: 0x8fa50010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11dbc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11dbc4: 0x2649c3c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 4294951872));
    // 0x11dbc8: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11dbcc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11dbd0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11dbd4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11dbd8: 0x240a000c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11dbdc: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11dbe4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11dbe4
// Address: 0x11dbe4 - 0x11dc4c

void entry_11dbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dbe4) {
        switch (ctx->pc) {
            case 0x11dbec: ctx->pc = 0; goto label_11dbec;
            case 0x11dbf0: ctx->pc = 0; goto label_11dbf0;
            case 0x11dbf4: ctx->pc = 0; goto label_11dbf4;
            case 0x11dc20: ctx->pc = 0; goto label_11dc20;
            case 0x11dc30: ctx->pc = 0; goto label_11dc30;
            case 0x11dc34: ctx->pc = 0; goto label_11dc34;
            case 0x11dc44: ctx->pc = 0; goto label_11dc44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dbe4: 0x10000070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DDA8; return;
    }
label_11dbec:
    // 0x11dbec: 0x26110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4));
label_11dbf0:
    // 0x11dbf0: 0x32220003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 17), 3));
label_11dbf4:
    // 0x11dbf4: 0x1040000a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11dc20;
    }
    // 0x11dbfc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x11dc00: 0x26030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 7));
    // 0x11dc04: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x11dc08: 0x26040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8));
    // 0x11dc0c: 0x222180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 17));
    // 0x11dc10: 0x31883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 2));
    // 0x11dc14: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11dc18: 0x2231823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x11dc1c: 0x838823
    SET_GPR_U32(ctx, 17, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
label_11dc20:
    // 0x11dc20: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x11dc24: 0x3c160026
    SET_GPR_U32(ctx, 22, ((uint32_t)38 << 16));
    // 0x11dc28: 0x10000015
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DC80; return;
    }
label_11dc30:
    // 0x11dc30: 0x8ee2c384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 4294951812)));
label_11dc34:
    // 0x11dc34: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11dc44;
    }
    // 0x11dc3c: 0xaee0c384
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294951812), GPR_U32(ctx, 0));
    // 0x11dc40: 0xafa20028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
label_11dc44:
    // 0x11dc44: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11dc4c);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11dc4c
// Address: 0x11dc4c - 0x11dc7c

void entry_11dc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dc4c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11dc50: 0x5663000b
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x11DC80; return;
    }
    // 0x11dc58: 0x8ea5c380
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 4294951808)));
    // 0x11dc5c: 0x26c2c360
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 4294951776));
    // 0x11dc60: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x11dc64: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x11dc68: 0x248497d8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940632));
    // 0x11dc6c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11dc70: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11dc74: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11dc7c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11dc7c
// Address: 0x11dc7c - 0x11dccc

void entry_11dc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dc7c) {
        switch (ctx->pc) {
            case 0x11dc80: ctx->pc = 0; goto label_11dc80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dc7c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_11dc80:
    // 0x11dc80: 0x8ea3c380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 4294951808)));
    // 0x11dc84: 0x26d4c360
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 22), 4294951776));
    // 0x11dc88: 0x24050100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 256));
    // 0x11dc8c: 0x33080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11dc90: 0xd41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 20)));
    // 0x11dc94: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11dc98: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11dc9c: 0x1085ffe4
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 30), 4294951784));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 5)) {
        ctx->pc = 0x11DC30; return;
    }
    // 0x11dca4: 0xd21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    // 0x11dca8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11dcac: 0x51102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 17)));
    // 0x11dcb0: 0x1440ffe0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 4294951812)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DC34; return;
    }
    // 0x11dcb8: 0x12600004
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_11dccc(rdram, ctx, runtime); return;
    }
    // 0x11dcc0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11dcc4: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11dccc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294940728));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11dccc
// Address: 0x11dccc - 0x11dda4

void entry_11dccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dccc) {
        switch (ctx->pc) {
            case 0x11dcdc: ctx->pc = 0; goto label_11dcdc;
            case 0x11dd18: ctx->pc = 0; goto label_11dd18;
            case 0x11dd38: ctx->pc = 0; goto label_11dd38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dccc: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x11dcd0: 0x10600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_11dcdc;
    }
    // 0x11dcd8: 0xaee2c384
    WRITE32(ADD32(GPR_U32(ctx, 23), 4294951812), GPR_U32(ctx, 2));
label_11dcdc:
    // 0x11dcdc: 0x8ea3c380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 4294951808)));
    // 0x11dce0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11dce4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11dce8: 0x722021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x11dcec: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11dcf0: 0x741821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x11dcf4: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11dcf8: 0x2442f000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294963200));
    // 0x11dcfc: 0xa22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x11dd00: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11dd04: 0xa4a20000
    WRITE16(ADD32(GPR_U32(ctx, 5), 0), (uint16_t)GPR_U32(ctx, 2));
    // 0x11dd08: 0x24a50002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2));
    // 0x11dd0c: 0xa4b00000
    WRITE16(ADD32(GPR_U32(ctx, 5), 0), (uint16_t)GPR_U32(ctx, 16));
    // 0x11dd10: 0x1a000009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 2));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_11dd38;
    }
label_11dd18:
    // 0x11dd18: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x11dd1c: 0xa62021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x11dd20: 0x661021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x11dd24: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11dd28: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x11dd2c: 0xd0102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 16)));
    // 0x11dd30: 0x1440fff9
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11dd18;
    }
label_11dd38:
    // 0x11dd38: 0x8ea4c380
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4294951808)));
    // 0x11dd3c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11dd40: 0x27c5c368
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4294951784));
    // 0x11dd44: 0x2462c370
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294951792));
    // 0x11dd48: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x11dd4c: 0x26c6c360
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 22), 4294951776));
    // 0x11dd50: 0x852821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x11dd54: 0x863021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x11dd58: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x11dd5c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x11dd60: 0x8cc70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x11dd64: 0x8c880000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11dd68: 0x711823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x11dd6c: 0xaca30000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 3));
    // 0x11dd70: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x11dd74: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x11dd78: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x11dd7c: 0x481021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x11dd80: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x11dd84: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x11dd88: 0x8c850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11dd8c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11dd90: 0xdfa30020
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11dd94: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x11dd98: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x11dd9c: 0xc047776
    SET_GPR_U32(ctx, 31, 0x11dda4);
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 3));
    snd_PostMessage__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11dda4
// Address: 0x11dda4 - 0x11ddd8

void entry_11dda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dda4) {
        switch (ctx->pc) {
            case 0x11dda8: ctx->pc = 0; goto label_11dda8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dda4: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_11dda8:
    // 0x11dda8: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x11ddac: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11ddb0: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11ddb4: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11ddb8: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11ddbc: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ddc0: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11ddc4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11ddc8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ddcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11ddd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11ddd8; return;
}


// Function: snd_PostMessage__Fv
// Address: 0x11ddd8 - 0x11de0c

void entry_11de0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11de0c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11de10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_SendCurrentBatch__Fv
// Address: 0x11de18 - 0x11de6c

void entry_11de6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11de6c) {
        switch (ctx->pc) {
            case 0x11de88: ctx->pc = 0; goto label_11de88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11de6c: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11de70: 0x220982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11de74: 0x240a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11de78: 0x3c100028
    SET_GPR_U32(ctx, 16, ((uint32_t)40 << 16));
    // 0x11de7c: 0x10000006
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11de98(rdram, ctx, runtime); return;
    }
    // 0x11de84: 0x0
    // NOP
label_11de88:
    // 0x11de88: 0xc0787c4
    SET_GPR_U32(ctx, 31, 0x11de90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294939880));
    printf(rdram, ctx, runtime); return;
}


// Function: entry_11de90
// Address: 0x11de90 - 0x11de98

void entry_11de90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11de90: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11de98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11de98
// Address: 0x11de98 - 0x11dea4

void entry_11de98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11de98: 0x2612b4c8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 4294948040));
    // 0x11de9c: 0xc07e120
    SET_GPR_U32(ctx, 31, 0x11dea4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    sceSifCheckStatRpc(rdram, ctx, runtime); return;
}


// Function: entry_11dea4
// Address: 0x11dea4 - 0x11df04

void entry_11dea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dea4: 0x1440fff8
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DE88; return;
    }
    // 0x11deac: 0x8e62c380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4294951808)));
    // 0x11deb0: 0x2690c360
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 4294951776));
    // 0x11deb4: 0x2631c368
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294951784));
    // 0x11deb8: 0x26a5c378
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 21), 4294951800));
    // 0x11debc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x11dec0: 0x24061000
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4096));
    // 0x11dec4: 0x501821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x11dec8: 0x512021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x11decc: 0x8c670000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11ded0: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x11ded4: 0x8c880000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x11ded8: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x11dedc: 0x8cea0000
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x11dee0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11dee4: 0x8c490000
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11dee8: 0xc84023
    SET_GPR_U32(ctx, 8, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x11deec: 0xa5080
    SET_GPR_U32(ctx, 10, SLL32(GPR_U32(ctx, 10), 2));
    // 0x11def0: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x11def4: 0x254a0008
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 8));
    // 0x11def8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11defc: 0xc07e0a4
    SET_GPR_U32(ctx, 31, 0x11df04);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceSifCallRpc(rdram, ctx, runtime); return;
}


// Function: entry_11df04
// Address: 0x11df04 - 0x11df58

void entry_11df04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11df04: 0x8e63c380
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4294951808)));
    // 0x11df08: 0x24050ffc
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4092));
    // 0x11df0c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11df10: 0x38630001
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 1));
    // 0x11df14: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11df18: 0x3182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x11df1c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11df20: 0x32080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11df24: 0xae63c380
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294951808), GPR_U32(ctx, 3));
    // 0x11df28: 0x908021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x11df2c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11df30: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11df34: 0x912021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 17)));
    // 0x11df38: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11df3c: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x11df40: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11df44: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11df48: 0xac850000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 5));
    // 0x11df4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11df54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11df58; return;
}


// Function: snd_InitVAGStreamingEx
// Address: 0x11df58 - 0x11dfb8

void entry_11dfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dfb8) {
        switch (ctx->pc) {
            case 0x11dfc0: ctx->pc = 0; goto label_11dfc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dfb8: 0x1440fffd
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11DFB0; return;
    }
label_11dfc0:
    // 0x11dfc0: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x11dfc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_11dfc8
// Address: 0x11dfc8 - 0x11dfe8

void entry_11dfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11dfc8: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x11dfcc: 0x2404002a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 42));
    // 0x11dfd0: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x11dfd4: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x11dfd8: 0xafb20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 18));
    // 0x11dfdc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11dfe0: 0xc04765a
    SET_GPR_U32(ctx, 31, 0x11dfe8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 19));
    snd_SendIOPCommandAndWait__FiiPc(rdram, ctx, runtime); return;
}


// Function: entry_11dfe8
// Address: 0x11dfe8 - 0x11e010

void entry_11dfe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11dfe8) {
        switch (ctx->pc) {
            case 0x11dfec: ctx->pc = 0; goto label_11dfec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11dfe8: 0xae82c34c
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294951756), GPR_U32(ctx, 2));
label_11dfec:
    // 0x11dfec: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11dff0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11dff4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11dff8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11dffc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e000: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e004: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e00c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e010; return;
}


// Function: snd_StopAllStreams
// Address: 0x11e010 - 0x11e030

void entry_11e030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e030: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e040; return;
}


// Function: junk_0x0011e040
// Address: 0x11e040 - 0x11e048

void entry_11e09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e09c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e0a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_0x0011e0a8
// Address: 0x11e0a8 - 0x11e0b0

void entry_11e0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e0d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e0d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_IsVAGStreamBuffered_CB
// Address: 0x11e0e0 - 0x11e104

void entry_11e104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e104: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e108: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_StreamSafeCheckCDIdle
// Address: 0x11e110 - 0x11e12c

void entry_11e12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e12c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e130: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_StreamSafeCdRead
// Address: 0x11e138 - 0x11e170

void entry_11e170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e170) {
        switch (ctx->pc) {
            case 0x11e178: ctx->pc = 0; goto label_11e178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e170: 0x1000001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E1DC; return;
    }
label_11e178:
    // 0x11e178: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11e17c: 0xc04787e
    SET_GPR_U32(ctx, 31, 0x11e184);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    snd_StreamSafeCdSync(rdram, ctx, runtime); return;
}


// Function: entry_11e184
// Address: 0x11e184 - 0x11e1bc

void entry_11e184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e184: 0x10510013
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x11E1D4; return;
    }
    // 0x11e18c: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x11e190: 0xac510dc0
    WRITE32(ADD32(GPR_U32(ctx, 2), 3520), GPR_U32(ctx, 17));
    // 0x11e194: 0x24040038
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 56));
    // 0x11e198: 0x24420dc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3520));
    // 0x11e19c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x11e1a0: 0xac400010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
    // 0x11e1a4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11e1a8: 0xafb20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 18));
    // 0x11e1ac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11e1b0: 0xafb30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 19));
    // 0x11e1b4: 0xc0476c0
    SET_GPR_U32(ctx, 31, 0x11e1bc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    snd_SendIOPCommandNoWait__FiiPcPFiUl_vUl(rdram, ctx, runtime); return;
}


// Function: entry_11e1bc
// Address: 0x11e1bc - 0x11e1f8

void entry_11e1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e1bc) {
        switch (ctx->pc) {
            case 0x11e1d4: ctx->pc = 0; goto label_11e1d4;
            case 0x11e1d8: ctx->pc = 0; goto label_11e1d8;
            case 0x11e1dc: ctx->pc = 0; goto label_11e1dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e1bc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11e1c0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x11e1c4: 0xac51c354
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294951764), GPR_U32(ctx, 17));
    // 0x11e1c8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11e1cc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294951768), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11e1d8;
    }
label_11e1d4:
    // 0x11e1d4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11e1d8:
    // 0x11e1d8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_11e1dc:
    // 0x11e1dc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11e1e0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11e1e4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e1e8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e1ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e1f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e1f8; return;
}


// Function: snd_StreamSafeCdSync
// Address: 0x11e1f8 - 0x11e220

void entry_11e220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e220) {
        switch (ctx->pc) {
            case 0x11e228: ctx->pc = 0; goto label_11e228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e220: 0x1000001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E290; return;
    }
label_11e228:
    // 0x11e228: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11e230);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11e230
// Address: 0x11e230 - 0x11e270

void entry_11e230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e230) {
        switch (ctx->pc) {
            case 0x11e268: ctx->pc = 0; goto label_11e268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e230: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x11e234: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x11e238: 0x8ca30dc0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 3520)));
    // 0x11e23c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11e240: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e244: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x11e248: 0x1064000f
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294951768), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x11E288; return;
    }
    // 0x11e250: 0x1204000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x11E28C; return;
    }
    // 0x11e258: 0x1460000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E28C; return;
    }
    // 0x11e260: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x11e264: 0x0
    // NOP
label_11e268:
    // 0x11e268: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x11e270);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_11e270
// Address: 0x11e270 - 0x11e278

void entry_11e270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e270: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x11e278);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_11e278
// Address: 0x11e278 - 0x11e2a0

void entry_11e278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e278) {
        switch (ctx->pc) {
            case 0x11e288: ctx->pc = 0; goto label_11e288;
            case 0x11e28c: ctx->pc = 0; goto label_11e28c;
            case 0x11e290: ctx->pc = 0; goto label_11e290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e278: 0x8e020dc0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3520)));
    // 0x11e27c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x11e280: 0x1040fff9
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294951768), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E268; return;
    }
label_11e288:
    // 0x11e288: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11e28c:
    // 0x11e28c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_11e290:
    // 0x11e290: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e294: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e298: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_StreamSafeCdBreak
// Address: 0x11e2a0 - 0x11e2cc

void entry_11e2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e2cc) {
        switch (ctx->pc) {
            case 0x11e2d4: ctx->pc = 0; goto label_11e2d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e2cc: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11e2dc(rdram, ctx, runtime); return;
    }
label_11e2d4:
    // 0x11e2d4: 0xc080f8a
    SET_GPR_U32(ctx, 31, 0x11e2dc);
    sceCdBreak(rdram, ctx, runtime); return;
}


// Function: entry_11e2dc
// Address: 0x11e2dc - 0x11e2e8

void entry_11e2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e2dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e2e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_StreamSafeCdGetError
// Address: 0x11e2e8 - 0x11e318

void entry_11e318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e318) {
        switch (ctx->pc) {
            case 0x11e31c: ctx->pc = 0; goto label_11e31c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e318: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_11e31c:
    // 0x11e31c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e324: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e328; return;
}


// Function: snd_SetReverbType
// Address: 0x11e328 - 0x11e350

void entry_11e350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e350: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e354: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e35c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e360; return;
}


// Function: snd_SetReverbDepth
// Address: 0x11e360 - 0x11e390

void entry_11e390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e390: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e394: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e39c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e3a0; return;
}


// Function: snd_PreAllocReverbWorkArea
// Address: 0x11e3a0 - 0x11e3c8

void entry_11e3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e3c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e3cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e3d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e3d8; return;
}


// Function: junk_0x0011e3d8
// Address: 0x11e3d8 - 0x11e428

void entry_11e454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e454: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e458: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_ResetMovieSound
// Address: 0x11e460 - 0x11e478

void entry_11e478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e478: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e47c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e484: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e488; return;
}


// Function: junk_0x0011e488
// Address: 0x11e488 - 0x11e498

void entry_11e4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e4b0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e4b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e4bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e4c0; return;
}


// Function: snd_StartMovieSound
// Address: 0x11e4c0 - 0x11e4ec

void entry_11e4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e4ec: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e4f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: snd_GetTransStatus
// Address: 0x11e4f8 - 0x11e510

void entry_11e510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e510: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e514: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e51c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e520; return;
}


// Function: junk_0x0011e520
// Address: 0x11e520 - 0x11e538

void entry_11e570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e570: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11e57c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11e580; return;
}


// Function: PloNew__F3CIDP2SWP3ALO3OIDi
// Address: 0x11e580 - 0x11e5d8

void entry_11e5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e5d8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e5dc: 0x2402006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 108));
    // 0x11e5e0: 0xae700000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
    // 0x11e5e4: 0x16420004
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        entry_11e5f8(rdram, ctx, runtime); return;
    }
    // 0x11e5ec: 0x260a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11e5f0: 0xc076d20
    SET_GPR_U32(ctx, 31, 0x11e5f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    InitSwDlHash__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_11e5f8
// Address: 0x11e5f8 - 0x11e60c

void entry_11e5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e5f8: 0xae750018
    WRITE32(ADD32(GPR_U32(ctx, 19), 24), GPR_U32(ctx, 21));
    // 0x11e5fc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11e600: 0xae740014
    WRITE32(ADD32(GPR_U32(ctx, 19), 20), GPR_U32(ctx, 20));
    // 0x11e604: 0xc0704e4
    SET_GPR_U32(ctx, 31, 0x11e60c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PframeFromIsplice__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_11e60c
// Address: 0x11e60c - 0x11e61c

void entry_11e60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e60c: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x11e610: 0x8e650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x11e614: 0xc0567c8
    SET_GPR_U32(ctx, 31, 0x11e61c);
    WRITE32(ADD32(GPR_U32(ctx, 19), 44), GPR_U32(ctx, 2));
    PdlFromSwOid__FP2SW3OID(rdram, ctx, runtime); return;
}


// Function: entry_11e61c
// Address: 0x11e61c - 0x11e628

void entry_11e61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e61c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e620: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x11e628);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_11e628
// Address: 0x11e628 - 0x11e650

void entry_11e628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e628: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x11e62c: 0x24421884
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6276));
    // 0x11e630: 0x571021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x11e634: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x11e638: 0xae630024
    WRITE32(ADD32(GPR_U32(ctx, 19), 36), GPR_U32(ctx, 3));
    // 0x11e63c: 0xac530000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 19));
    // 0x11e640: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11e644: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x11e648: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11e650);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11e650
// Address: 0x11e650 - 0x11e680

void entry_11e650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e650: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11e654: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11e658: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11e65c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11e660: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11e664: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11e668: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11e66c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11e670: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11e674: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11e678: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadOptionFromBrx__FPvP5EOPIDP18CBinaryInputStream
// Address: 0x11e680 - 0x11e6dc

void entry_11e6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e6dc) {
        switch (ctx->pc) {
            case 0x11e6f0: ctx->pc = 0; goto label_11e6f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e6dc: 0x1653fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 19)) {
        ctx->pc = 0x11E6D0; return;
    }
    // 0x11e6e4: 0x8e930014
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x11e6e8: 0x1a60006d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x11E8A0; return;
    }
label_11e6f0:
    // 0x11e6f0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11e6f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e6f8
// Address: 0x11e6f8 - 0x11e728

void entry_11e6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e6f8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e6fc: 0x2ca20015
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 21));
    // 0x11e700: 0x10400056
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E85C; return;
    }
    // 0x11e708: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x11e70c: 0x24429870
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294940784));
    // 0x11e710: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11e714: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11e718: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11e720: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x11e728);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e728
// Address: 0x11e728 - 0x11e738

void entry_11e728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e728: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e72c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e730: 0xc046d7c
    SET_GPR_U32(ctx, 31, 0x11e738);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    SetBool__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11e738
// Address: 0x11e738 - 0x11e748

void entry_11e738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e738: 0x10000056
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
    // 0x11e740: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x11e748);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e748
// Address: 0x11e748 - 0x11e758

void entry_11e748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e748: 0x1000000c
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E77C; return;
    }
    // 0x11e750: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e758);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e758
// Address: 0x11e758 - 0x11e768

void entry_11e758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e758: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e75c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x11e760: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x11e768);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_11e768
// Address: 0x11e768 - 0x11e778

void entry_11e768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e768: 0x1000004a
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
    // 0x11e770: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11e778);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e778
// Address: 0x11e778 - 0x11e788

void entry_11e778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e778) {
        switch (ctx->pc) {
            case 0x11e77c: ctx->pc = 0; goto label_11e77c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e778: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
label_11e77c:
    // 0x11e77c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e780: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11e788);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11e788
// Address: 0x11e788 - 0x11e798

void entry_11e788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e788: 0x10000042
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
    // 0x11e790: 0xc0471d2
    SET_GPR_U32(ctx, 31, 0x11e798);
    PclqNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11e798
// Address: 0x11e798 - 0x11e7a4

void entry_11e798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e798: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e79c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e7a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e7a4
// Address: 0x11e7a4 - 0x11e7b0

void entry_11e7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e7a8: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e7b0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e7b0
// Address: 0x11e7b0 - 0x11e7bc

void entry_11e7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e7b4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e7bc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e7bc
// Address: 0x11e7bc - 0x11e7d0

void entry_11e7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7bc: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e7c0: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x11e7c4: 0x3a42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    // 0x11e7c8: 0xc046df4
    SET_GPR_U32(ctx, 31, 0x11e7d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetClq__4CRefP3CLQ(rdram, ctx, runtime); return;
}


// Function: entry_11e7d0
// Address: 0x11e7d0 - 0x11e7e0

void entry_11e7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7d0: 0x10000030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
    // 0x11e7d8: 0xc047216
    SET_GPR_U32(ctx, 31, 0x11e7e0);
    PlmNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11e7e0
// Address: 0x11e7e0 - 0x11e7ec

void entry_11e7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e7e4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e7ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e7ec
// Address: 0x11e7ec - 0x11e7f8

void entry_11e7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e7f0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e7f8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e7f8
// Address: 0x11e7f8 - 0x11e80c

void entry_11e7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e7f8: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e7fc: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11e800: 0x3a42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    // 0x11e804: 0xc046e06
    SET_GPR_U32(ctx, 31, 0x11e80c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLm__4CRefP2LM(rdram, ctx, runtime); return;
}


// Function: entry_11e80c
// Address: 0x11e80c - 0x11e81c

void entry_11e80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e80c: 0x10000021
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
    // 0x11e814: 0xc047142
    SET_GPR_U32(ctx, 31, 0x11e81c);
    PvectorNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11e81c
// Address: 0x11e81c - 0x11e828

void entry_11e81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e81c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e820: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e828);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e828
// Address: 0x11e828 - 0x11e834

void entry_11e828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e828: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e82c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e834);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e834
// Address: 0x11e834 - 0x11e840

void entry_11e834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e834: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e838: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e840);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e840
// Address: 0x11e840 - 0x11e854

void entry_11e840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e840: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e844: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x11e848: 0x3a42021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    // 0x11e84c: 0xc046dd0
    SET_GPR_U32(ctx, 31, 0x11e854);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetVector__4CRefP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11e854
// Address: 0x11e854 - 0x11e880

void entry_11e854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e854) {
        switch (ctx->pc) {
            case 0x11e85c: ctx->pc = 0; goto label_11e85c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e854: 0x1000000f
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E894; return;
    }
label_11e85c:
    // 0x11e85c: 0x3c027fff
    SET_GPR_U32(ctx, 2, ((uint32_t)32767 << 16));
    // 0x11e860: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11e864: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x11e868: 0xa21024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x11e86c: 0x21302
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 12));
    // 0x11e870: 0x54430008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x11E894; return;
    }
    // 0x11e878: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11e880);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e880
// Address: 0x11e880 - 0x11e890

void entry_11e880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e880: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x11e884: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11e888: 0xc046d5c
    SET_GPR_U32(ctx, 31, 0x11e890);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 4)));
    SetS32__4CRefi(rdram, ctx, runtime); return;
}


// Function: entry_11e890
// Address: 0x11e890 - 0x11e8bc

void entry_11e890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e890) {
        switch (ctx->pc) {
            case 0x11e894: ctx->pc = 0; goto label_11e894;
            case 0x11e8a0: ctx->pc = 0; goto label_11e8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e890: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_11e894:
    // 0x11e894: 0x253102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 19)));
    // 0x11e898: 0x1440ff95
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E6F0; return;
    }
label_11e8a0:
    // 0x11e8a0: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x11e8a4: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11e8a8: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11e8ac: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11e8b0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11e8b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11e8bc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11e8bc
// Address: 0x11e8bc - 0x11e8c8

void entry_11e8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e8bc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11e8c0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11e8c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11e8c8
// Address: 0x11e8c8 - 0x11e8e4

void entry_11e8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e8c8) {
        switch (ctx->pc) {
            case 0x11e8d8: ctx->pc = 0; goto label_11e8d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e8c8: 0x13b000d4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 29) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x11EC1C; return;
    }
    // 0x11e8d0: 0x2610fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    // 0x11e8d4: 0x0
    // NOP
label_11e8d8:
    // 0x11e8d8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11e8dc: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x11e8e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = 0x11b060; return;
}


// Function: entry_11e8e4
// Address: 0x11e8e4 - 0x11e914

void entry_11e8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e8e4) {
        switch (ctx->pc) {
            case 0x11e8f4: ctx->pc = 0; goto label_11e8f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e8e4: 0x17b0fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967288));
    if (GPR_U32(ctx, 29) != GPR_U32(ctx, 16)) {
        ctx->pc = 0x11E8D8; return;
    }
    // 0x11e8ec: 0x100000cb
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
label_11e8f4:
    // 0x11e8f4: 0x30620080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 128));
    // 0x11e8f8: 0x10400055
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4096));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EA50; return;
    }
    // 0x11e900: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11E920; return;
    }
    // 0x11e908: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x11e90c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11e914);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11e914
// Address: 0x11e914 - 0x11e958

void entry_11e914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11e914) {
        switch (ctx->pc) {
            case 0x11e920: ctx->pc = 0; goto label_11e920;
            case 0x11e928: ctx->pc = 0; goto label_11e928;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11e914: 0x8e830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x11e918: 0x10000003
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11e928;
    }
label_11e920:
    // 0x11e920: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x11e924: 0x2a28021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
label_11e928:
    // 0x11e928: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x11e92c: 0x2c620014
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 20));
    // 0x11e930: 0x10400043
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EA40; return;
    }
    // 0x11e938: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11e93c: 0x244298d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294940880));
    // 0x11e940: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11e944: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11e948: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11e950: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x11e958);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e958
// Address: 0x11e958 - 0x11e968

void entry_11e958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e958: 0x100000af
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e960: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x11e968);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e968
// Address: 0x11e968 - 0x11e978

void entry_11e968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e968: 0x100000ab
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e970: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e978);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e978
// Address: 0x11e978 - 0x11e988

void entry_11e978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e978: 0x100000a7
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e980: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e988);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e988
// Address: 0x11e988 - 0x11e994

void entry_11e988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e988: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11e98c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e994);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e994
// Address: 0x11e994 - 0x11e9a4

void entry_11e994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e994: 0x100000a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e99c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9a4
// Address: 0x11e9a4 - 0x11e9b0

void entry_11e9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e9a8: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9b0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9b0
// Address: 0x11e9b0 - 0x11e9bc

void entry_11e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9b0: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11e9b4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9bc
// Address: 0x11e9bc - 0x11e9cc

void entry_11e9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9bc: 0x10000096
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e9c4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9cc
// Address: 0x11e9cc - 0x11e9d8

void entry_11e9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e9d0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9d8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9d8
// Address: 0x11e9d8 - 0x11e9e4

void entry_11e9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9d8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11e9dc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9e4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9e4
// Address: 0x11e9e4 - 0x11e9f0

void entry_11e9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9e4: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x11e9e8: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11e9f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11e9f0
// Address: 0x11e9f0 - 0x11ea00

void entry_11e9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11e9f0: 0x10000089
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11e9f8: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11ea00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ea00
// Address: 0x11ea00 - 0x11ea10

void entry_11ea00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ea00: 0x10000085
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
    // 0x11ea08: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11ea10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ea10
// Address: 0x11ea10 - 0x11ea1c

void entry_11ea10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ea10: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x11ea14: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11ea1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ea1c
// Address: 0x11ea1c - 0x11ea28

void entry_11ea1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ea1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11ea20: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11ea28);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ea28
// Address: 0x11ea28 - 0x11ea38

void entry_11ea28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ea28: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ea2c: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x11ea30: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x11ea38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_11ea38
// Address: 0x11ea38 - 0x11ea48

void entry_11ea38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ea38) {
        switch (ctx->pc) {
            case 0x11ea40: ctx->pc = 0; goto label_11ea40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ea38: 0x10000078
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
label_11ea40:
    // 0x11ea40: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ea48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ea48
// Address: 0x11ea48 - 0x11ea74

void entry_11ea48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ea48) {
        switch (ctx->pc) {
            case 0x11ea50: ctx->pc = 0; goto label_11ea50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ea48: 0x10000073
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_11ec18(rdram, ctx, runtime); return;
    }
label_11ea50:
    // 0x11ea50: 0x30620100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 256));
    // 0x11ea54: 0x1040000b
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4096));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EA84; return;
    }
    // 0x11ea5c: 0x10400007
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EA7C; return;
    }
    // 0x11ea64: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x11ea68: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11ea6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11ea74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11ea74
// Address: 0x11ea74 - 0x11eac8

void entry_11ea74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ea74) {
        switch (ctx->pc) {
            case 0x11ea7c: ctx->pc = 0; goto label_11ea7c;
            case 0x11ea84: ctx->pc = 0; goto label_11ea84;
            case 0x11ea98: ctx->pc = 0; goto label_11ea98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ea74: 0x10000008
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11ea98;
    }
label_11ea7c:
    // 0x11ea7c: 0x10000006
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11ea98;
    }
label_11ea84:
    // 0x11ea84: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x11ea88: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11ea8c: 0x8e830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x11ea90: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11ea94: 0x8c530000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_11ea98:
    // 0x11ea98: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x11ea9c: 0x2c620012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 18));
    // 0x11eaa0: 0x10400058
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC04; return;
    }
    // 0x11eaa8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x11eaac: 0x24429920
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294940960));
    // 0x11eab0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11eab4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11eab8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x11eac0: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x11eac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eac8
// Address: 0x11eac8 - 0x11ead8

void entry_11eac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eac8: 0x1000004a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EBF4; return;
    }
    // 0x11ead0: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x11ead8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ead8
// Address: 0x11ead8 - 0x11eae8

void entry_11ead8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ead8: 0x10000046
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EBF4; return;
    }
    // 0x11eae0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eae8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eae8
// Address: 0x11eae8 - 0x11eaf4

void entry_11eae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eae8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11eaec: 0x260f809
    SET_GPR_U32(ctx, 31, 0x11eaf4);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_11eaf4
// Address: 0x11eaf4 - 0x11eb04

void entry_11eaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eaf4: 0x10000049
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
    // 0x11eafc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb04
// Address: 0x11eb04 - 0x11eb10

void entry_11eb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11eb08: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb10);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb10
// Address: 0x11eb10 - 0x11eb24

void entry_11eb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb10: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11eb14: 0x1000001e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EB90; return;
    }
    // 0x11eb1c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb24
// Address: 0x11eb24 - 0x11eb30

void entry_11eb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb24: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x11eb28: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb30
// Address: 0x11eb30 - 0x11eb3c

void entry_11eb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11eb34: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb3c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb3c
// Address: 0x11eb3c - 0x11eb50

void entry_11eb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb3c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11eb40: 0x10000013
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EB90; return;
    }
    // 0x11eb48: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb50
// Address: 0x11eb50 - 0x11eb5c

void entry_11eb50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb50: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x11eb54: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb5c
// Address: 0x11eb5c - 0x11eb68

void entry_11eb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11eb60: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb68);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb68
// Address: 0x11eb68 - 0x11eb74

void entry_11eb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11eb6c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eb74);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb74
// Address: 0x11eb74 - 0x11eb88

void entry_11eb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb74: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11eb78: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EB90; return;
    }
    // 0x11eb80: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x11eb88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eb88
// Address: 0x11eb88 - 0x11eb98

void entry_11eb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11eb88) {
        switch (ctx->pc) {
            case 0x11eb90: ctx->pc = 0; goto label_11eb90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11eb88: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x11eb8c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_11eb90:
    // 0x11eb90: 0x260f809
    SET_GPR_U32(ctx, 31, 0x11eb98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_11eb98
// Address: 0x11eb98 - 0x11eba8

void entry_11eb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eb98: 0x10000020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
    // 0x11eba0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11eba8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11eba8
// Address: 0x11eba8 - 0x11ebb4

void entry_11eba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11eba8: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x11ebac: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11ebb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ebb4
// Address: 0x11ebb4 - 0x11ebc0

void entry_11ebb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ebb4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11ebb8: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11ebc0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ebc0
// Address: 0x11ebc0 - 0x11ebd4

void entry_11ebc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ebc0: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11ebc4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11ebc8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ebcc: 0xc06225e
    SET_GPR_U32(ctx, 31, 0x11ebd4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    LoadRotateMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_11ebd4
// Address: 0x11ebd4 - 0x11ebe0

void entry_11ebd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ebd4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11ebd8: 0x260f809
    SET_GPR_U32(ctx, 31, 0x11ebe0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_11ebe0
// Address: 0x11ebe0 - 0x11ebf0

void entry_11ebe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ebe0: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
    // 0x11ebe8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ebf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ebf0
// Address: 0x11ebf0 - 0x11ebfc

void entry_11ebf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ebf0) {
        switch (ctx->pc) {
            case 0x11ebf4: ctx->pc = 0; goto label_11ebf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ebf0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_11ebf4:
    // 0x11ebf4: 0x260f809
    SET_GPR_U32(ctx, 31, 0x11ebfc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_11ebfc
// Address: 0x11ebfc - 0x11ec0c

void entry_11ebfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ebfc) {
        switch (ctx->pc) {
            case 0x11ec04: ctx->pc = 0; goto label_11ec04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ebfc: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EC1C; return;
    }
label_11ec04:
    // 0x11ec04: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ec0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ec0c
// Address: 0x11ec0c - 0x11ec18

void entry_11ec0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ec0c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11ec10: 0x260f809
    SET_GPR_U32(ctx, 31, 0x11ec18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 19); return;
}


// Function: entry_11ec18
// Address: 0x11ec18 - 0x11ec40

void entry_11ec18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ec18) {
        switch (ctx->pc) {
            case 0x11ec1c: ctx->pc = 0; goto label_11ec1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ec18: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
label_11ec1c:
    // 0x11ec1c: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x11ec20: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x11ec24: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x11ec28: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x11ec2c: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x11ec30: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x11ec34: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x11ec38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadOptionsFromBrx__FPvP18CBinaryInputStream
// Address: 0x11ec40 - 0x11ec70

void entry_11ec70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ec70: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ec78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ec78
// Address: 0x11ec78 - 0x11eca0

void entry_11ec78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ec78: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11ec7c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ec80: 0x441fff9
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), 5));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x11EC68; return;
    }
    // 0x11ec88: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ec8c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ec90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ec94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ec98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IploFromStockOid__Fi
// Address: 0x11eca0 - 0x11ecb8

void entry_11ecf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ecf0) {
        switch (ctx->pc) {
            case 0x11ed00: ctx->pc = 0; goto label_11ed00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ecf0: 0x18400022
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x11ED7C; return;
    }
    // 0x11ecf8: 0x26951ce8
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 20), 7400));
    // 0x11ecfc: 0x0
    // NOP
label_11ed00:
    // 0x11ed00: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ed08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ed08
// Address: 0x11ed08 - 0x11ed14

void entry_11ed08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed08: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ed0c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ed14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ed14
// Address: 0x11ed14 - 0x11ed20

void entry_11ed14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed14: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ed18: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11ed20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ed20
// Address: 0x11ed20 - 0x11ed38

void entry_11ed20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed20: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ed24: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ed28: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11ed2c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11ed30: 0xc047960
    SET_GPR_U32(ctx, 31, 0x11ed38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_11ed38
// Address: 0x11ed38 - 0x11ed50

void entry_11ed38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed38: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11ed3c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11ed40: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11ed44: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x11ed48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11ed50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11ed50
// Address: 0x11ed50 - 0x11ed58

void entry_11ed50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed50: 0xc047b28
    SET_GPR_U32(ctx, 31, 0x11ed58);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    IploFromStockOid__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11ed58
// Address: 0x11ed58 - 0x11ed70

void entry_11ed58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ed58: 0x4400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    if (GPR_S32(ctx, 2) < 0) {
        entry_11ed70(rdram, ctx, runtime); return;
    }
    // 0x11ed60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ed64: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x11ed68: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x11ed70);
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_11ed70
// Address: 0x11ed70 - 0x11eda8

void entry_11ed70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ed70) {
        switch (ctx->pc) {
            case 0x11ed7c: ctx->pc = 0; goto label_11ed7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ed70: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x11ed74: 0x1660ffe2
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11ED00; return;
    }
label_11ed7c:
    // 0x11ed7c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11ed80: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ed84: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11ed88: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11ed8c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ed90: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ed94: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11ed98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ed9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11eda4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11eda8; return;
}


// Function: SetLoDefaults__FP2LO
// Address: 0x11eda8 - 0x11ee1c

void entry_11ee1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ee1c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11ee20: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x11ee24: 0xc04dce6
    SET_GPR_U32(ctx, 31, 0x11ee2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 8));
    OpenMemory__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_11ee2c
// Address: 0x11ee2c - 0x11ee3c

void entry_11ee2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ee2c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11ee30: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11ee34: 0xc0479a0
    SET_GPR_U32(ctx, 31, 0x11ee3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadOptionFromBrx__FPvP5EOPIDP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11ee3c
// Address: 0x11ee3c - 0x11ee48

void entry_11ee3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ee3c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11ee40: 0xc04dcb8
    SET_GPR_U32(ctx, 31, 0x11ee48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x1372e0; return;
}


// Function: entry_11ee48
// Address: 0x11ee48 - 0x11ee70

void entry_11ee48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11ee48) {
        switch (ctx->pc) {
            case 0x11ee54: ctx->pc = 0; goto label_11ee54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11ee48: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x11ee4c: 0x1620ffea
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11EDF8; return;
    }
label_11ee54:
    // 0x11ee54: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11ee58: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11ee5c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11ee60: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11ee64: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ee68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FindKey__FfiiiPcPfT5PPv
// Address: 0x11ee70 - 0x11ef40

void entry_11effc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11effc: 0x24040018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    // 0x11f000: 0xae420008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    // 0x11f004: 0xc063540
    SET_GPR_U32(ctx, 31, 0x11f00c);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11f00c
// Address: 0x11f00c - 0x11f040

void entry_11f00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f00c) {
        switch (ctx->pc) {
            case 0x11f030: ctx->pc = 0; goto label_11f030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f00c: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x11f010: 0x18600023
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x11F0A0; return;
    }
    // 0x11f018: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x11f01c: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x11f020: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x11f024: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11f028: 0x8e50000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x11f02c: 0x0
    // NOP
label_11f030:
    // 0x11f030: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f034: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x11f038: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11f040);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f040
// Address: 0x11f040 - 0x11f05c

void entry_11f040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f040: 0x26940018
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 24));
    // 0x11f044: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x11f048: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x11f04c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f050: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x11f054: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f05c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f05c
// Address: 0x11f05c - 0x11f068

void entry_11f05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f05c: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11f060: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x11f068);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f068
// Address: 0x11f068 - 0x11f074

void entry_11f068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f068: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f06c: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x11f074);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f074
// Address: 0x11f074 - 0x11f080

void entry_11f074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f074: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x11f078: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f080);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f080
// Address: 0x11f080 - 0x11f08c

void entry_11f080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f080: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x11f084: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f08c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f08c
// Address: 0x11f08c - 0x11f0c8

void entry_11f08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f08c) {
        switch (ctx->pc) {
            case 0x11f0a0: ctx->pc = 0; goto label_11f0a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f08c: 0xe6000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x11f090: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x11f094: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x11f098: 0x5440ffe5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x11F030; return;
    }
label_11f0a0:
    // 0x11f0a0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11f0a4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f0a8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f0ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f0b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f0b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f0b8: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x11f0bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11f0c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11f0c8; return;
}


// Function: EvaluateAcgb__FP4ACGBP3ALOffiPfT5
// Address: 0x11f0c8 - 0x11f10c

void entry_11f10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f10c) {
        switch (ctx->pc) {
            case 0x11f130: ctx->pc = 0; goto label_11f130;
            case 0x11f140: ctx->pc = 0; goto label_11f140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f10c: 0x8fa70008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x11f110: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x11f114: 0x8ce20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x11f118: 0x14430009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_11f140;
    }
    // 0x11f120: 0x12000003
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_11f130;
    }
    // 0x11f128: 0xc4e00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11f12c: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_11f130:
    // 0x11f130: 0x5620000d
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        entry_11f168(rdram, ctx, runtime); return;
    }
    // 0x11f138: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F16C; return;
    }
label_11f140:
    // 0x11f140: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x11f144: 0xc4f20024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 36)); ctx->f[18] = *(float*)&val; }
    // 0x11f148: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11f14c: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    // 0x11f150: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f154: 0xc4ef0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[15] = *(float*)&val; }
    // 0x11f158: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11f15c: 0xc4f00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[16] = *(float*)&val; }
    // 0x11f160: 0xc04c0fc
    SET_GPR_U32(ctx, 31, 0x11f168);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 28)); ctx->f[17] = *(float*)&val; }
    EvaluateBezierFloat__FfffffffPfN27(rdram, ctx, runtime); return;
}


// Function: entry_11f168
// Address: 0x11f168 - 0x11f180

void entry_11f168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f168) {
        switch (ctx->pc) {
            case 0x11f16c: ctx->pc = 0; goto label_11f16c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f168: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_11f16c:
    // 0x11f16c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f170: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f174: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x11f178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAcgbTimes__FP4ACGBPiPPf
// Address: 0x11f180 - 0x11f1b4

void entry_11f1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f1b4) {
        switch (ctx->pc) {
            case 0x11f1c8: ctx->pc = 0; goto label_11f1c8;
            case 0x11f1f8: ctx->pc = 0; goto label_11f1f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f1b4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11f1b8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f1bc: 0x1840000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_11f1f8;
    }
    // 0x11f1c4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_11f1c8:
    // 0x11f1c8: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x11f1cc: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x11f1d0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11f1d4: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x11f1d8: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x11f1dc: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11f1e0: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x11f1e4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x11f1e8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f1ec: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x11f1f0: 0x1440fff5
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 24));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11f1c8;
    }
label_11f1f8:
    // 0x11f1f8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f1fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f200: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f204: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAcgbwFromBrx__FP5ACGBWP18CBinaryInputStream
// Address: 0x11f210 - 0x11f240

void entry_11f240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f240: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x11f244: 0xc063540
    SET_GPR_U32(ctx, 31, 0x11f24c);
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11f24c
// Address: 0x11f24c - 0x11f27c

void entry_11f24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f24c) {
        switch (ctx->pc) {
            case 0x11f268: ctx->pc = 0; goto label_11f268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f24c: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x11f250: 0x1860002b
    WRITE32(ADD32(GPR_U32(ctx, 19), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x11F300; return;
    }
    // 0x11f258: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x11f25c: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x11f260: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x11f264: 0x8e70000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 12)));
label_11f268:
    // 0x11f268: 0x121140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 5));
    // 0x11f26c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f270: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x11f274: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11f27c);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f27c
// Address: 0x11f27c - 0x11f294

void entry_11f27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f27c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x11f280: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x11f284: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f288: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x11f28c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f294);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f294
// Address: 0x11f294 - 0x11f2a0

void entry_11f294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f294: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11f298: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x11f2a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2a0
// Address: 0x11f2a0 - 0x11f2ac

void entry_11f2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f2a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f2a4: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x11f2ac);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2ac
// Address: 0x11f2ac - 0x11f2b8

void entry_11f2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f2ac: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x11f2b0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f2b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2b8
// Address: 0x11f2b8 - 0x11f2c4

void entry_11f2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f2b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f2bc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f2c4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2c4
// Address: 0x11f2c4 - 0x11f2d8

void entry_11f2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f2c4: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11f2c8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f2cc: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x11f2d0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f2d8);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2d8
// Address: 0x11f2d8 - 0x11f2e4

void entry_11f2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f2d8: 0xe6000018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    // 0x11f2dc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f2e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f2e4
// Address: 0x11f2e4 - 0x11f320

void entry_11f2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f2e4) {
        switch (ctx->pc) {
            case 0x11f300: ctx->pc = 0; goto label_11f300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f2e4: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11f2e8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x11f2ec: 0xe601001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x11f2f0: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x11f2f4: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x11f2f8: 0x5440ffdb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 12)));
        ctx->pc = 0x11F268; return;
    }
label_11f300:
    // 0x11f300: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f304: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f308: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f30c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f310: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f314: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x11f318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcgbw__FP5ACGBWP3ALOffiPfT5
// Address: 0x11f320 - 0x11f364

void entry_11f364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f364) {
        switch (ctx->pc) {
            case 0x11f388: ctx->pc = 0; goto label_11f388;
            case 0x11f398: ctx->pc = 0; goto label_11f398;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f364: 0x8fa70018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x11f368: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x11f36c: 0x8ce20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 20)));
    // 0x11f370: 0x54430009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 48)); ctx->f[0] = *(float*)&val; }
        goto label_11f398;
    }
    // 0x11f378: 0x12000003
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_11f388;
    }
    // 0x11f380: 0xc4e00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11f384: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_11f388:
    // 0x11f388: 0x56200010
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        entry_11f3cc(rdram, ctx, runtime); return;
    }
    // 0x11f390: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F3D0; return;
    }
label_11f398:
    // 0x11f398: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x11f39c: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x11f3a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11f3a4: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x11f3a8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f3ac: 0xc7ad0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    // 0x11f3b0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11f3b4: 0xc4f3002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 44)); ctx->f[19] = *(float*)&val; }
    // 0x11f3b8: 0xc4ef0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[15] = *(float*)&val; }
    // 0x11f3bc: 0xc4f00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[16] = *(float*)&val; }
    // 0x11f3c0: 0xc4f1001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 28)); ctx->f[17] = *(float*)&val; }
    // 0x11f3c4: 0xc04c05a
    SET_GPR_U32(ctx, 31, 0x11f3cc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 36)); ctx->f[18] = *(float*)&val; }
    EvaluateBezierWeightedFloat__FfffffffffPfN29(rdram, ctx, runtime); return;
}


// Function: entry_11f3cc
// Address: 0x11f3cc - 0x11f3e8

void entry_11f3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f3cc) {
        switch (ctx->pc) {
            case 0x11f3d0: ctx->pc = 0; goto label_11f3d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f3cc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_11f3d0:
    // 0x11f3d0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f3d4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f3d8: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x11f3dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11f3e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11f3e8; return;
}


// Function: GetAcgbwTimes__FP5ACGBWPiPPf
// Address: 0x11f3e8 - 0x11f41c

void entry_11f41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f41c) {
        switch (ctx->pc) {
            case 0x11f430: ctx->pc = 0; goto label_11f430;
            case 0x11f460: ctx->pc = 0; goto label_11f460;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f41c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11f420: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f424: 0x1840000e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_11f460;
    }
    // 0x11f42c: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_11f430:
    // 0x11f430: 0x61140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 5));
    // 0x11f434: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11f438: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x11f43c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x11f440: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x11f444: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11f448: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x11f44c: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x11f450: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f454: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x11f458: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_11f430;
    }
label_11f460:
    // 0x11f460: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f464: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f468: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f46c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f470: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcgl__FP4ACGLP3ALOffiPfT5
// Address: 0x11f478 - 0x11f4bc

void entry_11f4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f4bc) {
        switch (ctx->pc) {
            case 0x11f4e8: ctx->pc = 0; goto label_11f4e8;
            case 0x11f4f8: ctx->pc = 0; goto label_11f4f8;
            case 0x11f52c: ctx->pc = 0; goto label_11f52c;
            case 0x11f550: ctx->pc = 0; goto label_11f550;
            case 0x11f554: ctx->pc = 0; goto label_11f554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f4bc: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x11f4c0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x11f4c4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x11f4c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x11f4cc: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11f4d0: 0x45000009
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_11f4f8;
    }
    // 0x11f4d8: 0x12000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_11f4e8;
    }
    // 0x11f4e0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x11f4e4: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_11f4e8:
    // 0x11f4e8: 0x56200019
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        goto label_11f550;
    }
    // 0x11f4f0: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11f554;
    }
label_11f4f8:
    // 0x11f4f8: 0x1200000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_11f52c;
    }
    // 0x11f500: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x11f504: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x11f508: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x11f50c: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x11f510: 0xc442000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[2] = *(float*)&val; }
    // 0x11f514: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x11f518: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x11f51c: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x11f520: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x11f524: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x11f528: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
label_11f52c:
    // 0x11f52c: 0x12200008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_11f550;
    }
    // 0x11f534: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x11f538: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x11f53c: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x11f540: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x11f544: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x11f548: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x11f54c: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_11f550:
    // 0x11f550: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_11f554:
    // 0x11f554: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f558: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f55c: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x11f560: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAcglFromBrx__FP4ACGLP18CBinaryInputStream
// Address: 0x11f568 - 0x11f598

void entry_11f598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f598: 0x220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 3));
    // 0x11f59c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x11f5a4);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11f5a4
// Address: 0x11f5a4 - 0x11f5d4

void entry_11f5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f5a4) {
        switch (ctx->pc) {
            case 0x11f5c0: ctx->pc = 0; goto label_11f5c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f5a4: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x11f5a8: 0x18600015
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x11F600; return;
    }
    // 0x11f5b0: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x11f5b4: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x11f5b8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x11f5bc: 0x8e50000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_11f5c0:
    // 0x11f5c0: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x11f5c4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11f5c8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x11f5cc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11f5d4);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f5d4
// Address: 0x11f5d4 - 0x11f5ec

void entry_11f5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f5d4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x11f5d8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x11f5dc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11f5e0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x11f5e4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x11f5ec);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f5ec
// Address: 0x11f5ec - 0x11f620

void entry_11f5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f5ec) {
        switch (ctx->pc) {
            case 0x11f600: ctx->pc = 0; goto label_11f600;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f5ec: 0xe6000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x11f5f0: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x11f5f4: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x11f5f8: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        ctx->pc = 0x11F5C0; return;
    }
label_11f600:
    // 0x11f600: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f604: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f608: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f60c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f610: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f614: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x11f618: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAcglTimes__FP4ACGLPiPPf
// Address: 0x11f620 - 0x11f654

void entry_11f654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f654) {
        switch (ctx->pc) {
            case 0x11f668: ctx->pc = 0; goto label_11f668;
            case 0x11f698: ctx->pc = 0; goto label_11f698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f654: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11f658: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f65c: 0x1840000e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_11f698;
    }
    // 0x11f664: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_11f668:
    // 0x11f668: 0x610c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 3));
    // 0x11f66c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11f670: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x11f674: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x11f678: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x11f67c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11f680: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x11f684: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x11f688: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f68c: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x11f690: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_11f668;
    }
label_11f698:
    // 0x11f698: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f69c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f6a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f6a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f6a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25
// Address: 0x11f6b0 - 0x11f754

void entry_11f754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f754: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x11f758: 0x214102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 20)));
    // 0x11f75c: 0x1440fff0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F720; return;
    }
    // 0x11f764: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11f768: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11f76c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11f770: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f774: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f778: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f77c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f780: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f784: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x11f788: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x11f78c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11f794: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11f798; return;
}


// Function: LoadApacgFromBrx__FPP3ACGP6VECTORP18CBinaryInputStream
// Address: 0x11f798 - 0x11f7cc

void entry_11f7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f7cc: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x11f7d0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11f7d4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11f7d8: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x11f7e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11f7e0
// Address: 0x11f7e0 - 0x11f7fc

void entry_11f7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f7e0: 0x32020001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 1));
    // 0x11f7e4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11f7e8: 0x108043
    SET_GPR_S32(ctx, 16, SRA32(GPR_S32(ctx, 16), 1));
    // 0x11f7ec: 0x1040000e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F828; return;
    }
    // 0x11f7f4: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x11f7fc);
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11f7fc
// Address: 0x11f7fc - 0x11f804

void entry_11f7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f7fc: 0xc048458
    SET_GPR_U32(ctx, 31, 0x11f804);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PacgNew__F4ACGK(rdram, ctx, runtime); return;
}


// Function: entry_11f804
// Address: 0x11f804 - 0x11f824

void entry_11f804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f804: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11f808: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11f80c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f810: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x11f814: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_11f824(rdram, ctx, runtime); return;
    }
    // 0x11f81c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11f824);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11f824
// Address: 0x11f824 - 0x11f850

void entry_11f824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f824) {
        switch (ctx->pc) {
            case 0x11f828: ctx->pc = 0; goto label_11f828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f824: 0xae510000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 17));
label_11f828:
    // 0x11f828: 0x681ffed
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_S32(ctx, 20) >= 0) {
        entry_11f7e0(rdram, ctx, runtime); return;
    }
    // 0x11f830: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11f834: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f838: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f83c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f840: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11f844: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f848: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetApacgTimes__FPP3ACGPiPPf
// Address: 0x11f850 - 0x11f8bc

void entry_11f8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f8bc) {
        switch (ctx->pc) {
            case 0x11f8c4: ctx->pc = 0; goto label_11f8c4;
            case 0x11f8d0: ctx->pc = 0; goto label_11f8d0;
            case 0x11f914: ctx->pc = 0; goto label_11f914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f8bc: 0x10000004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11f8d0;
    }
label_11f8c4:
    // 0x11f8c4: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x11f8c8: 0xaea00000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 0));
    // 0x11f8cc: 0x26b50004
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4));
label_11f8d0:
    // 0x11f8d0: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x11f8d4: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x11f8d8: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x11f8dc: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x11f8e0: 0x681ffef
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x11F8A0; return;
    }
    // 0x11f8e8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11f8ec: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x11f8f0: 0x8fa40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x11f8f4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11f8f8: 0x449021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x11f8fc: 0x56400005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 2));
        goto label_11f914;
    }
    // 0x11f904: 0x12e0002f
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F9C4; return;
    }
    // 0x11f90c: 0x1000002d
    WRITE32(ADD32(GPR_U32(ctx, 23), 0), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11F9C4; return;
    }
label_11f914:
    // 0x11f914: 0xc063596
    SET_GPR_U32(ctx, 31, 0x11f91c);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11f91c
// Address: 0x11f91c - 0x11f94c

void entry_11f91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f91c) {
        switch (ctx->pc) {
            case 0x11f930: ctx->pc = 0; goto label_11f930;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f91c: 0x2656ffff
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x11f920: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11f924: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11f928: 0x2a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11f92c: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
label_11f930:
    // 0x11f930: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f934: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11f938: 0x8e650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x11f93c: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x11f940: 0x63080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    // 0x11f944: 0xc063600
    SET_GPR_U32(ctx, 31, 0x11f94c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_11f94c
// Address: 0x11f94c - 0x11f97c

void entry_11f94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11f94c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11f950: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x11f954: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x11f958: 0x681fff5
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_S32(ctx, 20) >= 0) {
        ctx->pc = 0x11F930; return;
    }
    // 0x11f960: 0x3c07001f
    SET_GPR_U32(ctx, 7, ((uint32_t)31 << 16));
    // 0x11f964: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11f968: 0x24e7b128
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294947112));
    // 0x11f96c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11f970: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x11f974: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x11f97c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_11f97c
// Address: 0x11f97c - 0x11f9f8

void entry_11f97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11f97c) {
        switch (ctx->pc) {
            case 0x11f988: ctx->pc = 0; goto label_11f988;
            case 0x11f9a8: ctx->pc = 0; goto label_11f9a8;
            case 0x11f9b0: ctx->pc = 0; goto label_11f9b0;
            case 0x11f9c4: ctx->pc = 0; goto label_11f9c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11f97c: 0x26d2ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x11f980: 0x640000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) < 0) {
        goto label_11f9b0;
    }
label_11f988:
    // 0x11f988: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x11f98c: 0xc600fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x11f990: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11f994: 0x0
    // NOP
    // 0x11f998: 0x45010003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_11f9a8;
    }
    // 0x11f9a0: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x11f9a4: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
label_11f9a8:
    // 0x11f9a8: 0x641fff7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_11f988;
    }
label_11f9b0:
    // 0x11f9b0: 0x2151023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 21)));
    // 0x11f9b4: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x11f9b8: 0x12e00002
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_11f9c4;
    }
    // 0x11f9c0: 0xaef50000
    WRITE32(ADD32(GPR_U32(ctx, 23), 0), GPR_U32(ctx, 21));
label_11f9c4:
    // 0x11f9c4: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x11f9c8: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11f9cc: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11f9d0: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11f9d4: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11f9d8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11f9dc: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11f9e0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11f9e4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11f9e8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11f9ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11f9f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11f9f8; return;
}


// Function: EvaluateAkvb__FiP3KVBffiP6VECTORT5
// Address: 0x11f9f8 - 0x11fa3c

void entry_11fa3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fa3c: 0x8fa60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x11fa40: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x11fa44: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x11fa48: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fa4c: 0x24c70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 96));
    // 0x11fa50: 0x24c40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 16));
    // 0x11fa54: 0x24c50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 48));
    // 0x11fa58: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    // 0x11fa5c: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11fa60: 0x24c60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 80));
    // 0x11fa64: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x11fa6c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_11fa6c
// Address: 0x11fa6c - 0x11fa88

void entry_11fa6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fa6c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11fa70: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fa74: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fa78: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x11fa7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11fa84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11fa88; return;
}


// Function: LoadAkvbFromBrx__FPiPP3KVBP18CBinaryInputStream
// Address: 0x11fa88 - 0x11facc

void entry_11facc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11facc: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x11fad0: 0xc063540
    SET_GPR_U32(ctx, 31, 0x11fad8);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 23), 6));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_11fad8
// Address: 0x11fad8 - 0x11fb0c

void entry_11fad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fad8) {
        switch (ctx->pc) {
            case 0x11fb00: ctx->pc = 0; goto label_11fb00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fad8: 0x1ae0001e
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x11FB54; return;
    }
    // 0x11fae0: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x11fae4: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x11fae8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x11faec: 0x26d50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 22), 48));
    // 0x11faf0: 0x26d40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 22), 32));
    // 0x11faf4: 0x26d30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 22), 16));
    // 0x11faf8: 0x2c0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x11fafc: 0x2e0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_11fb00:
    // 0x11fb00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fb04: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x11fb0c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_11fb0c
// Address: 0x11fb0c - 0x11fb2c

void entry_11fb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fb0c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x11fb10: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x11fb14: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x11fb18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fb1c: 0x26730040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 64));
    // 0x11fb20: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x11fb24: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x11fb2c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11fb2c
// Address: 0x11fb2c - 0x11fb3c

void entry_11fb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fb2c: 0x26520040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 64));
    // 0x11fb30: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x11fb34: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x11fb3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11fb3c
// Address: 0x11fb3c - 0x11fb4c

void entry_11fb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fb3c: 0x26940040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 64));
    // 0x11fb40: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x11fb44: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x11fb4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_11fb4c
// Address: 0x11fb4c - 0x11fb98

void entry_11fb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fb4c) {
        switch (ctx->pc) {
            case 0x11fb54: ctx->pc = 0; goto label_11fb54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fb4c: 0x1620ffec
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 64));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FB00; return;
    }
label_11fb54:
    // 0x11fb54: 0xafd70000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 23));
    // 0x11fb58: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x11fb5c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fb60: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x11fb64: 0xac560000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 22));
    // 0x11fb68: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x11fb6c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x11fb70: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11fb74: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11fb78: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11fb7c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11fb80: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fb84: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fb88: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x11fb8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11fb94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11fb98; return;
}


// Function: GetAkvbTimes__FiP3KVBPiPPf
// Address: 0x11fb98 - 0x11fbc8

void entry_11fbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fbc8) {
        switch (ctx->pc) {
            case 0x11fbe0: ctx->pc = 0; goto label_11fbe0;
            case 0x11fc08: ctx->pc = 0; goto label_11fc08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fbc8: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x11fbcc: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11fbd0: 0x1840000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_11fc08;
    }
    // 0x11fbd8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11fbdc: 0x0
    // NOP
label_11fbe0:
    // 0x11fbe0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fbe4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x11fbe8: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x11fbec: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x11fbf0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x11fbf4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x11fbf8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x11fbfc: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x11fc00: 0x1440fff7
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_11fbe0;
    }
label_11fc08:
    // 0x11fc08: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11fc0c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fc10: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fc14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fc18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcpc__FP4ACPCP3ALOffiP6VECTORT5
// Address: 0x11fc20 - 0x11fc54

void entry_11fc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fc54: 0x12000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FC7C; return;
    }
    // 0x11fc5c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fc60: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x11fc64: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FC7C; return;
    }
    // 0x11fc6c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11fc70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11fc78);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11fc78
// Address: 0x11fc78 - 0x11fc90

void entry_11fc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fc78) {
        switch (ctx->pc) {
            case 0x11fc7c: ctx->pc = 0; goto label_11fc7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fc78: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_11fc7c:
    // 0x11fc7c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fc80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fc84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fc88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAcpcFromBrx__FP4ACPCP18CBinaryInputStream
// Address: 0x11fc90 - 0x11fcb4

void entry_11fcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fcb4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x11fcbc);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11fcbc
// Address: 0x11fcbc - 0x11fcd4

void entry_11fcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fcbc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fcc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fcc4: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x11fcc8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x11fccc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11fcd4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 36));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11fcd4
// Address: 0x11fcd4 - 0x11fd10

void entry_11fcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fcd4: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fcd8: 0x1060002e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FD94; return;
    }
    // 0x11fce0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11fce4: 0x8e080000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fce8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11fcec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x11fcf0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x11fcf4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fcf8: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x11fcfc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11fd00: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x11fd04: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x11fd08: 0x60f809
    SET_GPR_U32(ctx, 31, 0x11fd10);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_11fd10
// Address: 0x11fd10 - 0x11fd48

void entry_11fd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fd10: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fd14: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x11fd18: 0x8fa60024
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x11fd1c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11fd20: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fd24: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x11fd28: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x11fd2c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x11fd30: 0x8c690000
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x11fd34: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x11fd38: 0xc44cfffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[12] = *(float*)&val; }
    // 0x11fd3c: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x11fd40: 0x120f809
    SET_GPR_U32(ctx, 31, 0x11fd48);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 9); return;
}


// Function: entry_11fd48
// Address: 0x11fd48 - 0x11fda0

void entry_11fd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fd48) {
        switch (ctx->pc) {
            case 0x11fd94: ctx->pc = 0; goto label_11fd94;
            case 0x11fd98: ctx->pc = 0; goto label_11fd98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fd48: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fd4c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11fd50: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fd54: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fd58: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fd5c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x11fd60: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fd64: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x11fd68: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fd6c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x11fd70: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x11fd74: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x11fd78: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x11fd7c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11fd80: 0x0
    // NOP
    // 0x11fd84: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_11fd98;
    }
    // 0x11fd8c: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11fd98;
    }
label_11fd94:
    // 0x11fd94: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_11fd98:
    // 0x11fd98: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x11fda0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_11fda0
// Address: 0x11fda0 - 0x11fdb8

void entry_11fda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fda0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11fda4: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11fda8: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x11fdac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11fdb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11fdb8; return;
}


// Function: GetAcpcTimes__FP4ACPCPiPPf
// Address: 0x11fdb8 - 0x11fdc8

void entry_11fdc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fdc8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fdcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11fdd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11fdd8; return;
}


// Function: EvaluateAcpb__FP4ACPBP3ALOffiP6VECTORT5
// Address: 0x11fdd8 - 0x11fe04

void entry_11fe04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fe04: 0x12000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FE2C; return;
    }
    // 0x11fe0c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11fe10: 0x8c4200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 176)));
    // 0x11fe14: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x11FE2C; return;
    }
    // 0x11fe1c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x11fe20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11fe28);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11fe28
// Address: 0x11fe28 - 0x11fe40

void entry_11fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fe28) {
        switch (ctx->pc) {
            case 0x11fe2c: ctx->pc = 0; goto label_11fe2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fe28: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_11fe2c:
    // 0x11fe2c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11fe30: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fe34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fe38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadAcpbFromBrx__FP4ACPBP18CBinaryInputStream
// Address: 0x11fe40 - 0x11fe60

void entry_11fe60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x11fe60) {
        switch (ctx->pc) {
            case 0x11fe78: ctx->pc = 0; goto label_11fe78;
            case 0x11fec4: ctx->pc = 0; goto label_11fec4;
            case 0x11fec8: ctx->pc = 0; goto label_11fec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x11fe60: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x11fe64: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x11fe68: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_11fe78;
    }
    // 0x11fe70: 0x10000015
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_11fec8;
    }
label_11fe78:
    // 0x11fe78: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x11fe7c: 0x41180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 6));
    // 0x11fe80: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x11fe84: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x11fe88: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x11fe8c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x11fe90: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x11fe94: 0xd842ffd0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 4294967248)));
    // 0x11fe98: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fe9c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fea0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x11fea4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x11fea8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x11feac: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x11feb0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x11feb4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x11feb8: 0x0
    // NOP
    // 0x11febc: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_11fec4;
    }
label_11fec4:
    // 0x11fec4: 0xae040008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 4));
label_11fec8:
    // 0x11fec8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x11fecc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fed0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetAcpbTimes__FP4ACPBPiPPf
// Address: 0x11fed8 - 0x11fef8

void entry_11fef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11fef8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11fefc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11ff04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11ff08; return;
}


// Function: EvaluateAcrc__FP4ACRCP3ALOffiP7MATRIX3P6VECTOR
// Address: 0x11ff08 - 0x11ff4c

void entry_11ff4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ff4c: 0x12400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_11ff5c(rdram, ctx, runtime); return;
    }
    // 0x11ff54: 0xc062288
    SET_GPR_U32(ctx, 31, 0x11ff5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_11ff5c
// Address: 0x11ff5c - 0x11ff70

void entry_11ff5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ff5c: 0x12200004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_11ff70(rdram, ctx, runtime); return;
    }
    // 0x11ff64: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x11ff68: 0xc07b78e
    SET_GPR_U32(ctx, 31, 0x11ff70);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertDeulToW__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_11ff70
// Address: 0x11ff70 - 0x11ff8c

void entry_11ff70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ff70: 0x12000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_11ff8c(rdram, ctx, runtime); return;
    }
    // 0x11ff78: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x11ff7c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x11ff80: 0x8c6200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 180)));
    // 0x11ff84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x11ff8c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_11ff8c
// Address: 0x11ff8c - 0x11ffa8

void entry_11ff8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ff8c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x11ff90: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x11ff94: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x11ff98: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x11ff9c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x11ffa0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EvaluateAcrcEul__FP4ACRCP3ALOffiP6VECTORT5
// Address: 0x11ffa8 - 0x11ffc8

void entry_11ffc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x11ffc8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x11ffcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x11ffd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x11ffd8; return;
}


// Function: LoadAcrcFromBrx__FP4ACRCP18CBinaryInputStream
// Address: 0x11ffd8 - 0x120004

void entry_1126d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1126d0 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x1126d0;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_1126f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1126f8 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x1126f8;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_11271c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11271c inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x11271c;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_112720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112720 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x112720;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_112730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112730 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x112730;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_112748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112748 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x112748;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_112750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112750 inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x112750;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_11275c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11275c inside entry_1126bc (0x1126bc - 0x112774)
    ctx->pc = 0x11275c;
    entry_1126bc(rdram, ctx, runtime);
}

void entry_11277c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11277c inside entry_112774 (0x112774 - 0x112784)
    ctx->pc = 0x11277c;
    entry_112774(rdram, ctx, runtime);
}

void entry_11278c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11278c inside entry_112784 (0x112784 - 0x112794)
    ctx->pc = 0x11278c;
    entry_112784(rdram, ctx, runtime);
}

void entry_1127b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1127b0 inside entry_112794 (0x112794 - 0x1127d4)
    ctx->pc = 0x1127b0;
    entry_112794(rdram, ctx, runtime);
}

void entry_1127cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1127cc inside entry_112794 (0x112794 - 0x1127d4)
    ctx->pc = 0x1127cc;
    entry_112794(rdram, ctx, runtime);
}

void entry_1127dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1127dc inside entry_1127d4 (0x1127d4 - 0x1127e4)
    ctx->pc = 0x1127dc;
    entry_1127d4(rdram, ctx, runtime);
}

void entry_112818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112818 inside entry_1127e4 (0x1127e4 - 0x112930)
    ctx->pc = 0x112818;
    entry_1127e4(rdram, ctx, runtime);
}

void entry_112924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112924 inside entry_1127e4 (0x1127e4 - 0x112930)
    ctx->pc = 0x112924;
    entry_1127e4(rdram, ctx, runtime);
}

void entry_112934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112934 inside entry_112930 (0x112930 - 0x11293c)
    ctx->pc = 0x112934;
    entry_112930(rdram, ctx, runtime);
}

void entry_1129a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1129a0 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x1129a0;
    entry_11298c(rdram, ctx, runtime);
}

void entry_1129c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1129c8 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x1129c8;
    entry_11298c(rdram, ctx, runtime);
}

void entry_1129ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1129ec inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x1129ec;
    entry_11298c(rdram, ctx, runtime);
}

void entry_1129f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1129f0 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x1129f0;
    entry_11298c(rdram, ctx, runtime);
}

void entry_112a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a00 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x112a00;
    entry_11298c(rdram, ctx, runtime);
}

void entry_112a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a18 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x112a18;
    entry_11298c(rdram, ctx, runtime);
}

void entry_112a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a20 inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x112a20;
    entry_11298c(rdram, ctx, runtime);
}

void entry_112a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a2c inside entry_11298c (0x11298c - 0x112a44)
    ctx->pc = 0x112a2c;
    entry_11298c(rdram, ctx, runtime);
}

void entry_112a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a4c inside entry_112a44 (0x112a44 - 0x112a54)
    ctx->pc = 0x112a4c;
    entry_112a44(rdram, ctx, runtime);
}

void entry_112a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a5c inside entry_112a54 (0x112a54 - 0x112a64)
    ctx->pc = 0x112a5c;
    entry_112a54(rdram, ctx, runtime);
}

void entry_112a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a80 inside entry_112a64 (0x112a64 - 0x112aa4)
    ctx->pc = 0x112a80;
    entry_112a64(rdram, ctx, runtime);
}

void entry_112a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112a9c inside entry_112a64 (0x112a64 - 0x112aa4)
    ctx->pc = 0x112a9c;
    entry_112a64(rdram, ctx, runtime);
}

void entry_112aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112aac inside entry_112aa4 (0x112aa4 - 0x112ab4)
    ctx->pc = 0x112aac;
    entry_112aa4(rdram, ctx, runtime);
}

void entry_112ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112ae8 inside entry_112ab4 (0x112ab4 - 0x112c00)
    ctx->pc = 0x112ae8;
    entry_112ab4(rdram, ctx, runtime);
}

void entry_112bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112bf4 inside entry_112ab4 (0x112ab4 - 0x112c00)
    ctx->pc = 0x112bf4;
    entry_112ab4(rdram, ctx, runtime);
}

void entry_112c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112c04 inside entry_112c00 (0x112c00 - 0x112c0c)
    ctx->pc = 0x112c04;
    entry_112c00(rdram, ctx, runtime);
}

void entry_112d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112d6c inside entry_112d54 (0x112d54 - 0x112e00)
    ctx->pc = 0x112d6c;
    entry_112d54(rdram, ctx, runtime);
}

void entry_112d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112d7c inside entry_112d54 (0x112d54 - 0x112e00)
    ctx->pc = 0x112d7c;
    entry_112d54(rdram, ctx, runtime);
}

void entry_112d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112d88 inside entry_112d54 (0x112d54 - 0x112e00)
    ctx->pc = 0x112d88;
    entry_112d54(rdram, ctx, runtime);
}

void entry_112f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f00 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f00;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f18 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f18;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f20 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f20;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f58 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f58;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f74 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f74;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112f90 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112f90;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112fa4 inside entry_112ebc (0x112ebc - 0x112fac)
    ctx->pc = 0x112fa4;
    entry_112ebc(rdram, ctx, runtime);
}

void entry_112fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x112fe0 inside entry_112fbc (0x112fbc - 0x112fe8)
    ctx->pc = 0x112fe0;
    entry_112fbc(rdram, ctx, runtime);
}

void entry_11300c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11300c inside entry_113004 (0x113004 - 0x113018)
    ctx->pc = 0x11300c;
    entry_113004(rdram, ctx, runtime);
}

void entry_113078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113078 inside entry_113018 (0x113018 - 0x113088)
    ctx->pc = 0x113078;
    entry_113018(rdram, ctx, runtime);
}

void entry_1130a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1130a0 inside entry_113098 (0x113098 - 0x1130a8)
    ctx->pc = 0x1130a0;
    entry_113098(rdram, ctx, runtime);
}

void entry_1130bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1130bc inside entry_1130b8 (0x1130b8 - 0x1130c8)
    ctx->pc = 0x1130bc;
    entry_1130b8(rdram, ctx, runtime);
}

void entry_1130c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1130c0 inside entry_1130b8 (0x1130b8 - 0x1130c8)
    ctx->pc = 0x1130c0;
    entry_1130b8(rdram, ctx, runtime);
}

void entry_1130fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1130fc inside entry_1130d4 (0x1130d4 - 0x113180)
    ctx->pc = 0x1130fc;
    entry_1130d4(rdram, ctx, runtime);
}

void entry_113120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113120 inside entry_1130d4 (0x1130d4 - 0x113180)
    ctx->pc = 0x113120;
    entry_1130d4(rdram, ctx, runtime);
}

void entry_113138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113138 inside entry_1130d4 (0x1130d4 - 0x113180)
    ctx->pc = 0x113138;
    entry_1130d4(rdram, ctx, runtime);
}

void entry_11313c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11313c inside entry_1130d4 (0x1130d4 - 0x113180)
    ctx->pc = 0x11313c;
    entry_1130d4(rdram, ctx, runtime);
}

void entry_113144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113144 inside entry_1130d4 (0x1130d4 - 0x113180)
    ctx->pc = 0x113144;
    entry_1130d4(rdram, ctx, runtime);
}

void entry_113188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113188 inside entry_113180 (0x113180 - 0x113190)
    ctx->pc = 0x113188;
    entry_113180(rdram, ctx, runtime);
}

void entry_1131f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1131f4 inside entry_1131f0 (0x1131f0 - 0x1131fc)
    ctx->pc = 0x1131f4;
    entry_1131f0(rdram, ctx, runtime);
}

void entry_113370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113370 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113370;
    entry_113358(rdram, ctx, runtime);
}

void entry_113380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113380 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113380;
    entry_113358(rdram, ctx, runtime);
}

void entry_113390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113390 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113390;
    entry_113358(rdram, ctx, runtime);
}

void entry_1133d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1133d8 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x1133d8;
    entry_113358(rdram, ctx, runtime);
}

void entry_113408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113408 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113408;
    entry_113358(rdram, ctx, runtime);
}

void entry_11342c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11342c inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x11342c;
    entry_113358(rdram, ctx, runtime);
}

void entry_113444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113444 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113444;
    entry_113358(rdram, ctx, runtime);
}

void entry_113474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113474 inside entry_113358 (0x113358 - 0x1134a0)
    ctx->pc = 0x113474;
    entry_113358(rdram, ctx, runtime);
}

void entry_1134d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1134d4 inside entry_1134b0 (0x1134b0 - 0x1134f8)
    ctx->pc = 0x1134d4;
    entry_1134b0(rdram, ctx, runtime);
}

void entry_11354c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11354c inside entry_113508 (0x113508 - 0x113568)
    ctx->pc = 0x11354c;
    entry_113508(rdram, ctx, runtime);
}

void entry_113580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113580 inside entry_113578 (0x113578 - 0x113594)
    ctx->pc = 0x113580;
    entry_113578(rdram, ctx, runtime);
}

void entry_1135a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1135a8 inside entry_1135a4 (0x1135a4 - 0x1135b0)
    ctx->pc = 0x1135a8;
    entry_1135a4(rdram, ctx, runtime);
}

void entry_1135e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1135e4 inside entry_1135bc (0x1135bc - 0x113680)
    ctx->pc = 0x1135e4;
    entry_1135bc(rdram, ctx, runtime);
}

void entry_113614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113614 inside entry_1135bc (0x1135bc - 0x113680)
    ctx->pc = 0x113614;
    entry_1135bc(rdram, ctx, runtime);
}

void entry_113638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113638 inside entry_1135bc (0x1135bc - 0x113680)
    ctx->pc = 0x113638;
    entry_1135bc(rdram, ctx, runtime);
}

void entry_11363c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11363c inside entry_1135bc (0x1135bc - 0x113680)
    ctx->pc = 0x11363c;
    entry_1135bc(rdram, ctx, runtime);
}

void entry_113644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113644 inside entry_1135bc (0x1135bc - 0x113680)
    ctx->pc = 0x113644;
    entry_1135bc(rdram, ctx, runtime);
}

void entry_113688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113688 inside entry_113680 (0x113680 - 0x113690)
    ctx->pc = 0x113688;
    entry_113680(rdram, ctx, runtime);
}

void entry_1136e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1136e4 inside entry_1136e0 (0x1136e0 - 0x1136ec)
    ctx->pc = 0x1136e4;
    entry_1136e0(rdram, ctx, runtime);
}

void entry_1138c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1138c8 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x1138c8;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_1138dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1138dc inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x1138dc;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_1138e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1138e4 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x1138e4;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_11391c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11391c inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x11391c;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_113934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113934 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x113934;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_113948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113948 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x113948;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_11395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11395c inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x11395c;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_113970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113970 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x113970;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_113978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113978 inside entry_1138b8 (0x1138b8 - 0x113980)
    ctx->pc = 0x113978;
    entry_1138b8(rdram, ctx, runtime);
}

void entry_113988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113988 inside entry_113980 (0x113980 - 0x1139ac)
    ctx->pc = 0x113988;
    entry_113980(rdram, ctx, runtime);
}

void entry_1139a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1139a4 inside entry_113980 (0x113980 - 0x1139ac)
    ctx->pc = 0x1139a4;
    entry_113980(rdram, ctx, runtime);
}

void entry_1139b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1139b0 inside entry_1139ac (0x1139ac - 0x1139b8)
    ctx->pc = 0x1139b0;
    entry_1139ac(rdram, ctx, runtime);
}

void entry_113ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113ae4 inside entry_113acc (0x113acc - 0x113b2c)
    ctx->pc = 0x113ae4;
    entry_113acc(rdram, ctx, runtime);
}

void entry_113b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113b20 inside entry_113acc (0x113acc - 0x113b2c)
    ctx->pc = 0x113b20;
    entry_113acc(rdram, ctx, runtime);
}

void entry_113c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113c44 inside entry_113c30 (0x113c30 - 0x113c5c)
    ctx->pc = 0x113c44;
    entry_113c30(rdram, ctx, runtime);
}

void entry_113c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113c54 inside entry_113c30 (0x113c30 - 0x113c5c)
    ctx->pc = 0x113c54;
    entry_113c30(rdram, ctx, runtime);
}

void entry_113d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113d18 inside entry_113cc8 (0x113cc8 - 0x113d20)
    ctx->pc = 0x113d18;
    entry_113cc8(rdram, ctx, runtime);
}

void entry_113d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113d9c inside entry_113d98 (0x113d98 - 0x113da4)
    ctx->pc = 0x113d9c;
    entry_113d98(rdram, ctx, runtime);
}

void entry_113df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113df8 inside entry_113da4 (0x113da4 - 0x113e04)
    ctx->pc = 0x113df8;
    entry_113da4(rdram, ctx, runtime);
}

void entry_113dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x113dfc inside entry_113da4 (0x113da4 - 0x113e04)
    ctx->pc = 0x113dfc;
    entry_113da4(rdram, ctx, runtime);
}

void entry_1142c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1142c0 inside entry_1142a8 (0x1142a8 - 0x1142cc)
    ctx->pc = 0x1142c0;
    entry_1142a8(rdram, ctx, runtime);
}

void entry_1142c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1142c4 inside entry_1142a8 (0x1142a8 - 0x1142cc)
    ctx->pc = 0x1142c4;
    entry_1142a8(rdram, ctx, runtime);
}

void entry_114400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114400 inside entry_1143e8 (0x1143e8 - 0x114408)
    ctx->pc = 0x114400;
    entry_1143e8(rdram, ctx, runtime);
}

void entry_1144dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1144dc inside entry_1144c0 (0x1144c0 - 0x1144e8)
    ctx->pc = 0x1144dc;
    entry_1144c0(rdram, ctx, runtime);
}

void entry_1144e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1144e0 inside entry_1144c0 (0x1144c0 - 0x1144e8)
    ctx->pc = 0x1144e0;
    entry_1144c0(rdram, ctx, runtime);
}

void entry_114548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114548 inside entry_114538 (0x114538 - 0x114588)
    ctx->pc = 0x114548;
    entry_114538(rdram, ctx, runtime);
}

void entry_114564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114564 inside entry_114538 (0x114538 - 0x114588)
    ctx->pc = 0x114564;
    entry_114538(rdram, ctx, runtime);
}

void entry_114568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114568 inside entry_114538 (0x114538 - 0x114588)
    ctx->pc = 0x114568;
    entry_114538(rdram, ctx, runtime);
}

void entry_114600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114600 inside entry_1145e8 (0x1145e8 - 0x114608)
    ctx->pc = 0x114600;
    entry_1145e8(rdram, ctx, runtime);
}

void entry_114688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114688 inside entry_114674 (0x114674 - 0x1146a8)
    ctx->pc = 0x114688;
    entry_114674(rdram, ctx, runtime);
}

void entry_11469c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11469c inside entry_114674 (0x114674 - 0x1146a8)
    ctx->pc = 0x11469c;
    entry_114674(rdram, ctx, runtime);
}

void entry_1146a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1146a0 inside entry_114674 (0x114674 - 0x1146a8)
    ctx->pc = 0x1146a0;
    entry_114674(rdram, ctx, runtime);
}

void entry_114780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114780 inside entry_114778 (0x114778 - 0x114788)
    ctx->pc = 0x114780;
    entry_114778(rdram, ctx, runtime);
}

void entry_11478c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11478c inside entry_114788 (0x114788 - 0x114794)
    ctx->pc = 0x11478c;
    entry_114788(rdram, ctx, runtime);
}

void entry_1147fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1147fc inside entry_1147f4 (0x1147f4 - 0x114820)
    ctx->pc = 0x1147fc;
    entry_1147f4(rdram, ctx, runtime);
}

void entry_114814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114814 inside entry_1147f4 (0x1147f4 - 0x114820)
    ctx->pc = 0x114814;
    entry_1147f4(rdram, ctx, runtime);
}

void entry_114818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114818 inside entry_1147f4 (0x1147f4 - 0x114820)
    ctx->pc = 0x114818;
    entry_1147f4(rdram, ctx, runtime);
}

void entry_1148f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1148f8 inside entry_1148d8 (0x1148d8 - 0x11491c)
    ctx->pc = 0x1148f8;
    entry_1148d8(rdram, ctx, runtime);
}

void entry_114914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114914 inside entry_1148d8 (0x1148d8 - 0x11491c)
    ctx->pc = 0x114914;
    entry_1148d8(rdram, ctx, runtime);
}

void entry_1149a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1149a0 inside entry_11497c (0x11497c - 0x1149c0)
    ctx->pc = 0x1149a0;
    entry_11497c(rdram, ctx, runtime);
}

void entry_1149a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1149a4 inside entry_11497c (0x11497c - 0x1149c0)
    ctx->pc = 0x1149a4;
    entry_11497c(rdram, ctx, runtime);
}

void entry_1149c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1149c4 inside entry_1149c0 (0x1149c0 - 0x1149cc)
    ctx->pc = 0x1149c4;
    entry_1149c0(rdram, ctx, runtime);
}

void entry_114a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114a50 inside entry_114a44 (0x114a44 - 0x114a5c)
    ctx->pc = 0x114a50;
    entry_114a44(rdram, ctx, runtime);
}

void entry_114aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114aa0 inside entry_114a8c (0x114a8c - 0x114ab4)
    ctx->pc = 0x114aa0;
    entry_114a8c(rdram, ctx, runtime);
}

void entry_114aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114aa4 inside entry_114a8c (0x114a8c - 0x114ab4)
    ctx->pc = 0x114aa4;
    entry_114a8c(rdram, ctx, runtime);
}

void entry_114b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114b04 inside entry_114b00 (0x114b00 - 0x114b0c)
    ctx->pc = 0x114b04;
    entry_114b00(rdram, ctx, runtime);
}

void entry_114b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114b20 inside entry_114b0c (0x114b0c - 0x114b2c)
    ctx->pc = 0x114b20;
    entry_114b0c(rdram, ctx, runtime);
}

void entry_114b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114b38 inside entry_114b2c (0x114b2c - 0x114b40)
    ctx->pc = 0x114b38;
    entry_114b2c(rdram, ctx, runtime);
}

void entry_114c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114c0c inside entry_114c04 (0x114c04 - 0x114c38)
    ctx->pc = 0x114c0c;
    entry_114c04(rdram, ctx, runtime);
}

void entry_114c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114c20 inside entry_114c04 (0x114c04 - 0x114c38)
    ctx->pc = 0x114c20;
    entry_114c04(rdram, ctx, runtime);
}

void entry_114c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114c74 inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114c74;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114c7c inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114c7c;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114c90 inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114c90;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cac inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114cac;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cb0 inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114cb0;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cb8 inside entry_114c6c (0x114c6c - 0x114ccc)
    ctx->pc = 0x114cb8;
    entry_114c6c(rdram, ctx, runtime);
}

void entry_114cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cd4 inside entry_114ccc (0x114ccc - 0x114ce0)
    ctx->pc = 0x114cd4;
    entry_114ccc(rdram, ctx, runtime);
}

void entry_114cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cd8 inside entry_114ccc (0x114ccc - 0x114ce0)
    ctx->pc = 0x114cd8;
    entry_114ccc(rdram, ctx, runtime);
}

void entry_114cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114cf0 inside entry_114cec (0x114cec - 0x114d18)
    ctx->pc = 0x114cf0;
    entry_114cec(rdram, ctx, runtime);
}

void entry_114d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114d70 inside entry_114d60 (0x114d60 - 0x114d7c)
    ctx->pc = 0x114d70;
    entry_114d60(rdram, ctx, runtime);
}

void entry_114da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114da4 inside entry_114d9c (0x114d9c - 0x114dac)
    ctx->pc = 0x114da4;
    entry_114d9c(rdram, ctx, runtime);
}

void entry_114dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114dd8 inside entry_114dac (0x114dac - 0x114de0)
    ctx->pc = 0x114dd8;
    entry_114dac(rdram, ctx, runtime);
}

void entry_114e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114e58 inside entry_114e3c (0x114e3c - 0x114e60)
    ctx->pc = 0x114e58;
    entry_114e3c(rdram, ctx, runtime);
}

void entry_114eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114eb8 inside entry_114eb0 (0x114eb0 - 0x114ed0)
    ctx->pc = 0x114eb8;
    entry_114eb0(rdram, ctx, runtime);
}

void entry_114ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114ebc inside entry_114eb0 (0x114eb0 - 0x114ed0)
    ctx->pc = 0x114ebc;
    entry_114eb0(rdram, ctx, runtime);
}

void entry_114ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114ec4 inside entry_114eb0 (0x114eb0 - 0x114ed0)
    ctx->pc = 0x114ec4;
    entry_114eb0(rdram, ctx, runtime);
}

void entry_114ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114ed4 inside entry_114ed0 (0x114ed0 - 0x114edc)
    ctx->pc = 0x114ed4;
    entry_114ed0(rdram, ctx, runtime);
}

void entry_114ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114ef0 inside entry_114edc (0x114edc - 0x114efc)
    ctx->pc = 0x114ef0;
    entry_114edc(rdram, ctx, runtime);
}

void entry_114f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114f0c inside entry_114efc (0x114efc - 0x114f14)
    ctx->pc = 0x114f0c;
    entry_114efc(rdram, ctx, runtime);
}

void entry_114fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114fa0 inside entry_114f90 (0x114f90 - 0x114fac)
    ctx->pc = 0x114fa0;
    entry_114f90(rdram, ctx, runtime);
}

void entry_114fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x114fe0 inside entry_114fd8 (0x114fd8 - 0x115008)
    ctx->pc = 0x114fe0;
    entry_114fd8(rdram, ctx, runtime);
}

void entry_115000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115000 inside entry_114fd8 (0x114fd8 - 0x115008)
    ctx->pc = 0x115000;
    entry_114fd8(rdram, ctx, runtime);
}

void entry_115088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115088 inside entry_115064 (0x115064 - 0x115090)
    ctx->pc = 0x115088;
    entry_115064(rdram, ctx, runtime);
}

void entry_115110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115110 inside entry_115108 (0x115108 - 0x115138)
    ctx->pc = 0x115110;
    entry_115108(rdram, ctx, runtime);
}

void entry_115118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115118 inside entry_115108 (0x115108 - 0x115138)
    ctx->pc = 0x115118;
    entry_115108(rdram, ctx, runtime);
}

void entry_11511c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11511c inside entry_115108 (0x115108 - 0x115138)
    ctx->pc = 0x11511c;
    entry_115108(rdram, ctx, runtime);
}

void entry_115124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115124 inside entry_115108 (0x115108 - 0x115138)
    ctx->pc = 0x115124;
    entry_115108(rdram, ctx, runtime);
}

void entry_115140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115140 inside entry_115138 (0x115138 - 0x11514c)
    ctx->pc = 0x115140;
    entry_115138(rdram, ctx, runtime);
}

void entry_115144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115144 inside entry_115138 (0x115138 - 0x11514c)
    ctx->pc = 0x115144;
    entry_115138(rdram, ctx, runtime);
}

void entry_115160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115160 inside entry_11514c (0x11514c - 0x115170)
    ctx->pc = 0x115160;
    entry_11514c(rdram, ctx, runtime);
}

void entry_115168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115168 inside entry_11514c (0x11514c - 0x115170)
    ctx->pc = 0x115168;
    entry_11514c(rdram, ctx, runtime);
}

void entry_115218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115218 inside entry_115208 (0x115208 - 0x115224)
    ctx->pc = 0x115218;
    entry_115208(rdram, ctx, runtime);
}

void entry_115260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115260 inside entry_115224 (0x115224 - 0x115268)
    ctx->pc = 0x115260;
    entry_115224(rdram, ctx, runtime);
}

void entry_1152e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1152e0 inside entry_1152c4 (0x1152c4 - 0x1152e8)
    ctx->pc = 0x1152e0;
    entry_1152c4(rdram, ctx, runtime);
}

void entry_11531c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11531c inside entry_115310 (0x115310 - 0x115330)
    ctx->pc = 0x11531c;
    entry_115310(rdram, ctx, runtime);
}

void entry_115320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115320 inside entry_115310 (0x115310 - 0x115330)
    ctx->pc = 0x115320;
    entry_115310(rdram, ctx, runtime);
}

void entry_115340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115340 inside entry_115330 (0x115330 - 0x11534c)
    ctx->pc = 0x115340;
    entry_115330(rdram, ctx, runtime);
}

void entry_115358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115358 inside entry_11534c (0x11534c - 0x115360)
    ctx->pc = 0x115358;
    entry_11534c(rdram, ctx, runtime);
}

void entry_115488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115488 inside entry_11547c (0x11547c - 0x115494)
    ctx->pc = 0x115488;
    entry_11547c(rdram, ctx, runtime);
}

void entry_115584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115584 inside entry_115554 (0x115554 - 0x11559c)
    ctx->pc = 0x115584;
    entry_115554(rdram, ctx, runtime);
}

void entry_1155b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1155b0 inside entry_11559c (0x11559c - 0x1155dc)
    ctx->pc = 0x1155b0;
    entry_11559c(rdram, ctx, runtime);
}

void entry_1155d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1155d4 inside entry_11559c (0x11559c - 0x1155dc)
    ctx->pc = 0x1155d4;
    entry_11559c(rdram, ctx, runtime);
}

void entry_1155e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1155e0 inside entry_1155dc (0x1155dc - 0x11561c)
    ctx->pc = 0x1155e0;
    entry_1155dc(rdram, ctx, runtime);
}

void entry_1155f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1155f8 inside entry_1155dc (0x1155dc - 0x11561c)
    ctx->pc = 0x1155f8;
    entry_1155dc(rdram, ctx, runtime);
}

void entry_115610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115610 inside entry_1155dc (0x1155dc - 0x11561c)
    ctx->pc = 0x115610;
    entry_1155dc(rdram, ctx, runtime);
}

void entry_11564c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11564c inside entry_115638 (0x115638 - 0x115668)
    ctx->pc = 0x11564c;
    entry_115638(rdram, ctx, runtime);
}

void entry_11565c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11565c inside entry_115638 (0x115638 - 0x115668)
    ctx->pc = 0x11565c;
    entry_115638(rdram, ctx, runtime);
}

void entry_115660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115660 inside entry_115638 (0x115638 - 0x115668)
    ctx->pc = 0x115660;
    entry_115638(rdram, ctx, runtime);
}

void entry_115758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115758 inside entry_11574c (0x11574c - 0x115764)
    ctx->pc = 0x115758;
    entry_11574c(rdram, ctx, runtime);
}

void entry_115a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115a6c inside entry_115a64 (0x115a64 - 0x115ac8)
    ctx->pc = 0x115a6c;
    entry_115a64(rdram, ctx, runtime);
}

void entry_115abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115abc inside entry_115a64 (0x115a64 - 0x115ac8)
    ctx->pc = 0x115abc;
    entry_115a64(rdram, ctx, runtime);
}

void entry_115ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115ac0 inside entry_115a64 (0x115a64 - 0x115ac8)
    ctx->pc = 0x115ac0;
    entry_115a64(rdram, ctx, runtime);
}

void entry_115af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115af8 inside entry_115ac8 (0x115ac8 - 0x115b14)
    ctx->pc = 0x115af8;
    entry_115ac8(rdram, ctx, runtime);
}

void entry_115b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115b08 inside entry_115ac8 (0x115ac8 - 0x115b14)
    ctx->pc = 0x115b08;
    entry_115ac8(rdram, ctx, runtime);
}

void entry_115b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115b0c inside entry_115ac8 (0x115ac8 - 0x115b14)
    ctx->pc = 0x115b0c;
    entry_115ac8(rdram, ctx, runtime);
}

void entry_115b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115b1c inside entry_115b14 (0x115b14 - 0x115b2c)
    ctx->pc = 0x115b1c;
    entry_115b14(rdram, ctx, runtime);
}

void entry_115b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115b34 inside entry_115b2c (0x115b2c - 0x115b40)
    ctx->pc = 0x115b34;
    entry_115b2c(rdram, ctx, runtime);
}

void entry_115b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115b44 inside entry_115b40 (0x115b40 - 0x115b4c)
    ctx->pc = 0x115b44;
    entry_115b40(rdram, ctx, runtime);
}

void entry_115bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115bb8 inside entry_115bb0 (0x115bb0 - 0x115bc8)
    ctx->pc = 0x115bb8;
    entry_115bb0(rdram, ctx, runtime);
}

void entry_115bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115bcc inside entry_115bc8 (0x115bc8 - 0x115bdc)
    ctx->pc = 0x115bcc;
    entry_115bc8(rdram, ctx, runtime);
}

void entry_115c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115c40 inside entry_115c20 (0x115c20 - 0x115c60)
    ctx->pc = 0x115c40;
    entry_115c20(rdram, ctx, runtime);
}

void entry_115c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115c48 inside entry_115c20 (0x115c20 - 0x115c60)
    ctx->pc = 0x115c48;
    entry_115c20(rdram, ctx, runtime);
}

void entry_115c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115c58 inside entry_115c20 (0x115c20 - 0x115c60)
    ctx->pc = 0x115c58;
    entry_115c20(rdram, ctx, runtime);
}

void entry_115ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115ce0 inside entry_115cc8 (0x115cc8 - 0x115d04)
    ctx->pc = 0x115ce0;
    entry_115cc8(rdram, ctx, runtime);
}

void entry_115ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115ce8 inside entry_115cc8 (0x115cc8 - 0x115d04)
    ctx->pc = 0x115ce8;
    entry_115cc8(rdram, ctx, runtime);
}

void entry_115ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115ef8 inside entry_115ee8 (0x115ee8 - 0x115f34)
    ctx->pc = 0x115ef8;
    entry_115ee8(rdram, ctx, runtime);
}

void entry_115f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115f0c inside entry_115ee8 (0x115ee8 - 0x115f34)
    ctx->pc = 0x115f0c;
    entry_115ee8(rdram, ctx, runtime);
}

void entry_115f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x115f14 inside entry_115ee8 (0x115ee8 - 0x115f34)
    ctx->pc = 0x115f14;
    entry_115ee8(rdram, ctx, runtime);
}

void entry_116184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116184 inside entry_11617c (0x11617c - 0x1161c8)
    ctx->pc = 0x116184;
    entry_11617c(rdram, ctx, runtime);
}

void entry_1161cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1161cc inside entry_1161c8 (0x1161c8 - 0x1161d4)
    ctx->pc = 0x1161cc;
    entry_1161c8(rdram, ctx, runtime);
}

void entry_116268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116268 inside entry_116260 (0x116260 - 0x1162a0)
    ctx->pc = 0x116268;
    entry_116260(rdram, ctx, runtime);
}

void entry_1162a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1162a4 inside entry_1162a0 (0x1162a0 - 0x1162ac)
    ctx->pc = 0x1162a4;
    entry_1162a0(rdram, ctx, runtime);
}

void entry_116364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116364 inside entry_1162f8 (0x1162f8 - 0x1163cc)
    ctx->pc = 0x116364;
    entry_1162f8(rdram, ctx, runtime);
}

void entry_1163ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1163ac inside entry_1162f8 (0x1162f8 - 0x1163cc)
    ctx->pc = 0x1163ac;
    entry_1162f8(rdram, ctx, runtime);
}

void entry_1163b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1163b4 inside entry_1162f8 (0x1162f8 - 0x1163cc)
    ctx->pc = 0x1163b4;
    entry_1162f8(rdram, ctx, runtime);
}

void entry_1163c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1163c4 inside entry_1162f8 (0x1162f8 - 0x1163cc)
    ctx->pc = 0x1163c4;
    entry_1162f8(rdram, ctx, runtime);
}

void entry_116570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116570 inside entry_116558 (0x116558 - 0x11658c)
    ctx->pc = 0x116570;
    entry_116558(rdram, ctx, runtime);
}

void entry_116574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116574 inside entry_116558 (0x116558 - 0x11658c)
    ctx->pc = 0x116574;
    entry_116558(rdram, ctx, runtime);
}

void entry_116c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116c04 inside entry_116bec (0x116bec - 0x116c24)
    ctx->pc = 0x116c04;
    entry_116bec(rdram, ctx, runtime);
}

void entry_116c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116c08 inside entry_116bec (0x116bec - 0x116c24)
    ctx->pc = 0x116c08;
    entry_116bec(rdram, ctx, runtime);
}

void entry_116e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116e48 inside entry_116e0c (0x116e0c - 0x116e60)
    ctx->pc = 0x116e48;
    entry_116e0c(rdram, ctx, runtime);
}

void entry_116e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x116e58 inside entry_116e0c (0x116e0c - 0x116e60)
    ctx->pc = 0x116e58;
    entry_116e0c(rdram, ctx, runtime);
}

void entry_117304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117304 inside entry_1172e8 (0x1172e8 - 0x11730c)
    ctx->pc = 0x117304;
    entry_1172e8(rdram, ctx, runtime);
}

void entry_117314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117314 inside entry_11730c (0x11730c - 0x117330)
    ctx->pc = 0x117314;
    entry_11730c(rdram, ctx, runtime);
}

void entry_117328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117328 inside entry_11730c (0x11730c - 0x117330)
    ctx->pc = 0x117328;
    entry_11730c(rdram, ctx, runtime);
}

void entry_117334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117334 inside entry_117330 (0x117330 - 0x11733c)
    ctx->pc = 0x117334;
    entry_117330(rdram, ctx, runtime);
}

void entry_1173a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1173a0 inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x1173a0;
    entry_117390(rdram, ctx, runtime);
}

void entry_1173b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1173b0 inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x1173b0;
    entry_117390(rdram, ctx, runtime);
}

void entry_1173d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1173d8 inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x1173d8;
    entry_117390(rdram, ctx, runtime);
}

void entry_1173e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1173e8 inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x1173e8;
    entry_117390(rdram, ctx, runtime);
}

void entry_1173fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1173fc inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x1173fc;
    entry_117390(rdram, ctx, runtime);
}

void entry_11740c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11740c inside entry_117390 (0x117390 - 0x117414)
    ctx->pc = 0x11740c;
    entry_117390(rdram, ctx, runtime);
}

void entry_11741c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11741c inside entry_117414 (0x117414 - 0x117438)
    ctx->pc = 0x11741c;
    entry_117414(rdram, ctx, runtime);
}

void entry_11743c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11743c inside entry_117438 (0x117438 - 0x117450)
    ctx->pc = 0x11743c;
    entry_117438(rdram, ctx, runtime);
}

void entry_117444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117444 inside entry_117438 (0x117438 - 0x117450)
    ctx->pc = 0x117444;
    entry_117438(rdram, ctx, runtime);
}

void entry_1174b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1174b8 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x1174b8;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_1174c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1174c8 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x1174c8;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_1174f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1174f4 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x1174f4;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_117504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117504 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x117504;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_117518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117518 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x117518;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_117528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117528 inside entry_1174a8 (0x1174a8 - 0x117530)
    ctx->pc = 0x117528;
    entry_1174a8(rdram, ctx, runtime);
}

void entry_117538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117538 inside entry_117530 (0x117530 - 0x117554)
    ctx->pc = 0x117538;
    entry_117530(rdram, ctx, runtime);
}

void entry_117558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117558 inside entry_117554 (0x117554 - 0x11756c)
    ctx->pc = 0x117558;
    entry_117554(rdram, ctx, runtime);
}

void entry_117560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117560 inside entry_117554 (0x117554 - 0x11756c)
    ctx->pc = 0x117560;
    entry_117554(rdram, ctx, runtime);
}

void entry_1175cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1175cc inside entry_1175b8 (0x1175b8 - 0x1175dc)
    ctx->pc = 0x1175cc;
    entry_1175b8(rdram, ctx, runtime);
}

void entry_117778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117778 inside entry_117750 (0x117750 - 0x117780)
    ctx->pc = 0x117778;
    entry_117750(rdram, ctx, runtime);
}

void entry_1177c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1177c0 inside entry_1177a4 (0x1177a4 - 0x1177dc)
    ctx->pc = 0x1177c0;
    entry_1177a4(rdram, ctx, runtime);
}

void entry_1177f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1177f4 inside entry_1177dc (0x1177dc - 0x1177fc)
    ctx->pc = 0x1177f4;
    entry_1177dc(rdram, ctx, runtime);
}

void entry_117964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117964 inside entry_117938 (0x117938 - 0x11798c)
    ctx->pc = 0x117964;
    entry_117938(rdram, ctx, runtime);
}

void entry_117980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117980 inside entry_117938 (0x117938 - 0x11798c)
    ctx->pc = 0x117980;
    entry_117938(rdram, ctx, runtime);
}

void entry_117994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117994 inside entry_11798c (0x11798c - 0x1179a4)
    ctx->pc = 0x117994;
    entry_11798c(rdram, ctx, runtime);
}

void entry_1179ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1179ac inside entry_1179a4 (0x1179a4 - 0x1179bc)
    ctx->pc = 0x1179ac;
    entry_1179a4(rdram, ctx, runtime);
}

void entry_1179c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1179c0 inside entry_1179bc (0x1179bc - 0x1179c8)
    ctx->pc = 0x1179c0;
    entry_1179bc(rdram, ctx, runtime);
}

void entry_1179dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1179dc inside entry_1179d4 (0x1179d4 - 0x1179e4)
    ctx->pc = 0x1179dc;
    entry_1179d4(rdram, ctx, runtime);
}

void entry_117a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117a00 inside entry_1179fc (0x1179fc - 0x117a08)
    ctx->pc = 0x117a00;
    entry_1179fc(rdram, ctx, runtime);
}

void entry_117b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117b38 inside entry_117b20 (0x117b20 - 0x117b40)
    ctx->pc = 0x117b38;
    entry_117b20(rdram, ctx, runtime);
}

void entry_117b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117b50 inside entry_117b40 (0x117b40 - 0x117b5c)
    ctx->pc = 0x117b50;
    entry_117b40(rdram, ctx, runtime);
}

void entry_117b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117b84 inside entry_117b70 (0x117b70 - 0x117b8c)
    ctx->pc = 0x117b84;
    entry_117b70(rdram, ctx, runtime);
}

void entry_117b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x117b90 inside entry_117b8c (0x117b8c - 0x117b98)
    ctx->pc = 0x117b90;
    entry_117b8c(rdram, ctx, runtime);
}

void entry_1180fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1180fc inside entry_1180e4 (0x1180e4 - 0x118104)
    ctx->pc = 0x1180fc;
    entry_1180e4(rdram, ctx, runtime);
}

void entry_1181f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1181f8 inside entry_1181f0 (0x1181f0 - 0x118238)
    ctx->pc = 0x1181f8;
    entry_1181f0(rdram, ctx, runtime);
}

void entry_118210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118210 inside entry_1181f0 (0x1181f0 - 0x118238)
    ctx->pc = 0x118210;
    entry_1181f0(rdram, ctx, runtime);
}

void entry_1182d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1182d0 inside entry_1182c4 (0x1182c4 - 0x1182e0)
    ctx->pc = 0x1182d0;
    entry_1182c4(rdram, ctx, runtime);
}

void entry_1182d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1182d8 inside entry_1182c4 (0x1182c4 - 0x1182e0)
    ctx->pc = 0x1182d8;
    entry_1182c4(rdram, ctx, runtime);
}

void entry_118340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118340 inside entry_118338 (0x118338 - 0x11835c)
    ctx->pc = 0x118340;
    entry_118338(rdram, ctx, runtime);
}

void entry_11834c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11834c inside entry_118338 (0x118338 - 0x11835c)
    ctx->pc = 0x11834c;
    entry_118338(rdram, ctx, runtime);
}

void entry_118364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118364 inside entry_11835c (0x11835c - 0x118374)
    ctx->pc = 0x118364;
    entry_11835c(rdram, ctx, runtime);
}

void entry_11836c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11836c inside entry_11835c (0x11835c - 0x118374)
    ctx->pc = 0x11836c;
    entry_11835c(rdram, ctx, runtime);
}

void entry_118384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118384 inside entry_118380 (0x118380 - 0x1183b8)
    ctx->pc = 0x118384;
    entry_118380(rdram, ctx, runtime);
}

void entry_1187b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1187b8 inside entry_1187b4 (0x1187b4 - 0x1187c0)
    ctx->pc = 0x1187b8;
    entry_1187b4(rdram, ctx, runtime);
}

void entry_118a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118a60 inside entry_118a54 (0x118a54 - 0x118a74)
    ctx->pc = 0x118a60;
    entry_118a54(rdram, ctx, runtime);
}

void entry_118a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118a78 inside entry_118a74 (0x118a74 - 0x118a90)
    ctx->pc = 0x118a78;
    entry_118a74(rdram, ctx, runtime);
}

void entry_118a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118a98 inside entry_118a90 (0x118a90 - 0x118aac)
    ctx->pc = 0x118a98;
    entry_118a90(rdram, ctx, runtime);
}

void entry_118ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118ab0 inside entry_118aac (0x118aac - 0x118ae0)
    ctx->pc = 0x118ab0;
    entry_118aac(rdram, ctx, runtime);
}

void entry_118af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118af0 inside entry_118ae0 (0x118ae0 - 0x118b08)
    ctx->pc = 0x118af0;
    entry_118ae0(rdram, ctx, runtime);
}

void entry_118b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118b1c inside entry_118b08 (0x118b08 - 0x118b30)
    ctx->pc = 0x118b1c;
    entry_118b08(rdram, ctx, runtime);
}

void entry_118b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118b60 inside entry_118b30 (0x118b30 - 0x118b68)
    ctx->pc = 0x118b60;
    entry_118b30(rdram, ctx, runtime);
}

void entry_118b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118b90 inside entry_118b68 (0x118b68 - 0x118bb4)
    ctx->pc = 0x118b90;
    entry_118b68(rdram, ctx, runtime);
}

void entry_118bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118bac inside entry_118b68 (0x118b68 - 0x118bb4)
    ctx->pc = 0x118bac;
    entry_118b68(rdram, ctx, runtime);
}

void entry_118bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118bbc inside entry_118bb4 (0x118bb4 - 0x118bc4)
    ctx->pc = 0x118bbc;
    entry_118bb4(rdram, ctx, runtime);
}

void entry_118be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118be8 inside entry_118be0 (0x118be0 - 0x118bf0)
    ctx->pc = 0x118be8;
    entry_118be0(rdram, ctx, runtime);
}

void entry_118bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118bf4 inside entry_118bf0 (0x118bf0 - 0x118c04)
    ctx->pc = 0x118bf4;
    entry_118bf0(rdram, ctx, runtime);
}

void entry_118c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118c0c inside entry_118c04 (0x118c04 - 0x118c14)
    ctx->pc = 0x118c0c;
    entry_118c04(rdram, ctx, runtime);
}

void entry_118c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118c38 inside entry_118c28 (0x118c28 - 0x118c40)
    ctx->pc = 0x118c38;
    entry_118c28(rdram, ctx, runtime);
}

void entry_118c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118c5c inside entry_118c40 (0x118c40 - 0x118c74)
    ctx->pc = 0x118c5c;
    entry_118c40(rdram, ctx, runtime);
}

void entry_118c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118c90 inside entry_118c88 (0x118c88 - 0x118c9c)
    ctx->pc = 0x118c90;
    entry_118c88(rdram, ctx, runtime);
}

void entry_118ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118ca0 inside entry_118c9c (0x118c9c - 0x118ca8)
    ctx->pc = 0x118ca0;
    entry_118c9c(rdram, ctx, runtime);
}

void entry_118fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x118fec inside entry_118fe8 (0x118fe8 - 0x118ff4)
    ctx->pc = 0x118fec;
    entry_118fe8(rdram, ctx, runtime);
}

void entry_1190b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1190b4 inside entry_119098 (0x119098 - 0x1190c0)
    ctx->pc = 0x1190b4;
    entry_119098(rdram, ctx, runtime);
}

void entry_1190e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1190e0 inside entry_1190d8 (0x1190d8 - 0x1190e8)
    ctx->pc = 0x1190e0;
    entry_1190d8(rdram, ctx, runtime);
}

void entry_1190ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1190ec inside entry_1190e8 (0x1190e8 - 0x1190f4)
    ctx->pc = 0x1190ec;
    entry_1190e8(rdram, ctx, runtime);
}

void entry_119170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119170 inside entry_119158 (0x119158 - 0x11917c)
    ctx->pc = 0x119170;
    entry_119158(rdram, ctx, runtime);
}

void entry_1191ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1191ac inside entry_119194 (0x119194 - 0x1191b4)
    ctx->pc = 0x1191ac;
    entry_119194(rdram, ctx, runtime);
}

void entry_1191c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1191c8 inside entry_1191c0 (0x1191c0 - 0x1191dc)
    ctx->pc = 0x1191c8;
    entry_1191c0(rdram, ctx, runtime);
}

void entry_1191d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1191d0 inside entry_1191c0 (0x1191c0 - 0x1191dc)
    ctx->pc = 0x1191d0;
    entry_1191c0(rdram, ctx, runtime);
}

void entry_1191f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1191f8 inside entry_1191f4 (0x1191f4 - 0x119218)
    ctx->pc = 0x1191f8;
    entry_1191f4(rdram, ctx, runtime);
}

void entry_119270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119270 inside entry_119254 (0x119254 - 0x11927c)
    ctx->pc = 0x119270;
    entry_119254(rdram, ctx, runtime);
}

void entry_1192cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1192cc inside entry_1192c4 (0x1192c4 - 0x1192e0)
    ctx->pc = 0x1192cc;
    entry_1192c4(rdram, ctx, runtime);
}

void entry_1192d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1192d4 inside entry_1192c4 (0x1192c4 - 0x1192e0)
    ctx->pc = 0x1192d4;
    entry_1192c4(rdram, ctx, runtime);
}

void entry_1192f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1192f0 inside entry_1192ec (0x1192ec - 0x119310)
    ctx->pc = 0x1192f0;
    entry_1192ec(rdram, ctx, runtime);
}

void entry_119388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119388 inside entry_119368 (0x119368 - 0x1193ac)
    ctx->pc = 0x119388;
    entry_119368(rdram, ctx, runtime);
}

void entry_11939c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11939c inside entry_119368 (0x119368 - 0x1193ac)
    ctx->pc = 0x11939c;
    entry_119368(rdram, ctx, runtime);
}

void entry_1193dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1193dc inside entry_1193c4 (0x1193c4 - 0x1193f8)
    ctx->pc = 0x1193dc;
    entry_1193c4(rdram, ctx, runtime);
}

void entry_119410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119410 inside entry_1193f8 (0x1193f8 - 0x11941c)
    ctx->pc = 0x119410;
    entry_1193f8(rdram, ctx, runtime);
}

void entry_119440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119440 inside entry_119434 (0x119434 - 0x119458)
    ctx->pc = 0x119440;
    entry_119434(rdram, ctx, runtime);
}

void entry_119444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119444 inside entry_119434 (0x119434 - 0x119458)
    ctx->pc = 0x119444;
    entry_119434(rdram, ctx, runtime);
}

void entry_11944c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11944c inside entry_119434 (0x119434 - 0x119458)
    ctx->pc = 0x11944c;
    entry_119434(rdram, ctx, runtime);
}

void entry_119500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119500 inside entry_1194f0 (0x1194f0 - 0x11950c)
    ctx->pc = 0x119500;
    entry_1194f0(rdram, ctx, runtime);
}

void entry_119568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119568 inside entry_119558 (0x119558 - 0x119598)
    ctx->pc = 0x119568;
    entry_119558(rdram, ctx, runtime);
}

void entry_119590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119590 inside entry_119558 (0x119558 - 0x119598)
    ctx->pc = 0x119590;
    entry_119558(rdram, ctx, runtime);
}

void entry_1195e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1195e4 inside entry_1195c4 (0x1195c4 - 0x119614)
    ctx->pc = 0x1195e4;
    entry_1195c4(rdram, ctx, runtime);
}

void entry_1195ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1195ec inside entry_1195c4 (0x1195c4 - 0x119614)
    ctx->pc = 0x1195ec;
    entry_1195c4(rdram, ctx, runtime);
}

void entry_119608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119608 inside entry_1195c4 (0x1195c4 - 0x119614)
    ctx->pc = 0x119608;
    entry_1195c4(rdram, ctx, runtime);
}

void entry_119638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119638 inside entry_11962c (0x11962c - 0x119654)
    ctx->pc = 0x119638;
    entry_11962c(rdram, ctx, runtime);
}

void entry_11963c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11963c inside entry_11962c (0x11962c - 0x119654)
    ctx->pc = 0x11963c;
    entry_11962c(rdram, ctx, runtime);
}

void entry_119648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119648 inside entry_11962c (0x11962c - 0x119654)
    ctx->pc = 0x119648;
    entry_11962c(rdram, ctx, runtime);
}

void entry_119670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119670 inside entry_119660 (0x119660 - 0x11967c)
    ctx->pc = 0x119670;
    entry_119660(rdram, ctx, runtime);
}

void entry_11968c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11968c inside entry_11967c (0x11967c - 0x119694)
    ctx->pc = 0x11968c;
    entry_11967c(rdram, ctx, runtime);
}

void entry_119758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119758 inside entry_11973c (0x11973c - 0x119768)
    ctx->pc = 0x119758;
    entry_11973c(rdram, ctx, runtime);
}

void entry_1197b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1197b8 inside entry_1197ac (0x1197ac - 0x1197c4)
    ctx->pc = 0x1197b8;
    entry_1197ac(rdram, ctx, runtime);
}

void entry_1197cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1197cc inside entry_1197c4 (0x1197c4 - 0x1197ec)
    ctx->pc = 0x1197cc;
    entry_1197c4(rdram, ctx, runtime);
}

void entry_1197d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1197d0 inside entry_1197c4 (0x1197c4 - 0x1197ec)
    ctx->pc = 0x1197d0;
    entry_1197c4(rdram, ctx, runtime);
}

void entry_1197e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1197e0 inside entry_1197c4 (0x1197c4 - 0x1197ec)
    ctx->pc = 0x1197e0;
    entry_1197c4(rdram, ctx, runtime);
}

void entry_119810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119810 inside entry_119804 (0x119804 - 0x11981c)
    ctx->pc = 0x119810;
    entry_119804(rdram, ctx, runtime);
}

void entry_1198c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1198c0 inside entry_1198a8 (0x1198a8 - 0x1198cc)
    ctx->pc = 0x1198c0;
    entry_1198a8(rdram, ctx, runtime);
}

void entry_1198c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1198c4 inside entry_1198a8 (0x1198a8 - 0x1198cc)
    ctx->pc = 0x1198c4;
    entry_1198a8(rdram, ctx, runtime);
}

void entry_1199c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1199c8 inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x1199c8;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_1199cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1199cc inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x1199cc;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_1199e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1199e8 inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x1199e8;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_1199fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1199fc inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x1199fc;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_119a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119a00 inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x119a00;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_119a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119a08 inside entry_1199ac (0x1199ac - 0x119a1c)
    ctx->pc = 0x119a08;
    entry_1199ac(rdram, ctx, runtime);
}

void entry_119a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119a90 inside entry_119a84 (0x119a84 - 0x119a9c)
    ctx->pc = 0x119a90;
    entry_119a84(rdram, ctx, runtime);
}

void entry_119b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119b48 inside entry_119b30 (0x119b30 - 0x119b54)
    ctx->pc = 0x119b48;
    entry_119b30(rdram, ctx, runtime);
}

void entry_119b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119b78 inside entry_119b6c (0x119b6c - 0x119b84)
    ctx->pc = 0x119b78;
    entry_119b6c(rdram, ctx, runtime);
}

void entry_119c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119c08 inside entry_119c00 (0x119c00 - 0x119c14)
    ctx->pc = 0x119c08;
    entry_119c00(rdram, ctx, runtime);
}

void entry_119c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119c80 inside entry_119c48 (0x119c48 - 0x119ce4)
    ctx->pc = 0x119c80;
    entry_119c48(rdram, ctx, runtime);
}

void entry_119c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119c9c inside entry_119c48 (0x119c48 - 0x119ce4)
    ctx->pc = 0x119c9c;
    entry_119c48(rdram, ctx, runtime);
}

void entry_119ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119ca4 inside entry_119c48 (0x119c48 - 0x119ce4)
    ctx->pc = 0x119ca4;
    entry_119c48(rdram, ctx, runtime);
}

void entry_119cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119cd0 inside entry_119c48 (0x119c48 - 0x119ce4)
    ctx->pc = 0x119cd0;
    entry_119c48(rdram, ctx, runtime);
}

void entry_119d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119d18 inside entry_119d08 (0x119d08 - 0x119d40)
    ctx->pc = 0x119d18;
    entry_119d08(rdram, ctx, runtime);
}

void entry_119d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119d38 inside entry_119d08 (0x119d08 - 0x119d40)
    ctx->pc = 0x119d38;
    entry_119d08(rdram, ctx, runtime);
}

void entry_119d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119d80 inside entry_119d6c (0x119d6c - 0x119da4)
    ctx->pc = 0x119d80;
    entry_119d6c(rdram, ctx, runtime);
}

void entry_119d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119d84 inside entry_119d6c (0x119d6c - 0x119da4)
    ctx->pc = 0x119d84;
    entry_119d6c(rdram, ctx, runtime);
}

void entry_119d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119d90 inside entry_119d6c (0x119d6c - 0x119da4)
    ctx->pc = 0x119d90;
    entry_119d6c(rdram, ctx, runtime);
}

void entry_119dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119dac inside entry_119da4 (0x119da4 - 0x119dbc)
    ctx->pc = 0x119dac;
    entry_119da4(rdram, ctx, runtime);
}

void entry_119dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119dc0 inside entry_119dbc (0x119dbc - 0x119e14)
    ctx->pc = 0x119dc0;
    entry_119dbc(rdram, ctx, runtime);
}

void entry_119de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119de4 inside entry_119dbc (0x119dbc - 0x119e14)
    ctx->pc = 0x119de4;
    entry_119dbc(rdram, ctx, runtime);
}

void entry_119df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119df8 inside entry_119dbc (0x119dbc - 0x119e14)
    ctx->pc = 0x119df8;
    entry_119dbc(rdram, ctx, runtime);
}

void entry_119e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119e1c inside entry_119e14 (0x119e14 - 0x119e24)
    ctx->pc = 0x119e1c;
    entry_119e14(rdram, ctx, runtime);
}

void entry_119e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119e50 inside entry_119e34 (0x119e34 - 0x119e58)
    ctx->pc = 0x119e50;
    entry_119e34(rdram, ctx, runtime);
}

void entry_119e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119e64 inside entry_119e58 (0x119e58 - 0x119e78)
    ctx->pc = 0x119e64;
    entry_119e58(rdram, ctx, runtime);
}

void entry_119eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119eb0 inside entry_119ea8 (0x119ea8 - 0x119ec0)
    ctx->pc = 0x119eb0;
    entry_119ea8(rdram, ctx, runtime);
}

void entry_119ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119ec4 inside entry_119ec0 (0x119ec0 - 0x119ecc)
    ctx->pc = 0x119ec4;
    entry_119ec0(rdram, ctx, runtime);
}

void entry_119ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119ee0 inside entry_119ed8 (0x119ed8 - 0x119efc)
    ctx->pc = 0x119ee0;
    entry_119ed8(rdram, ctx, runtime);
}

void entry_119f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119f18 inside entry_119f14 (0x119f14 - 0x119f24)
    ctx->pc = 0x119f18;
    entry_119f14(rdram, ctx, runtime);
}

void entry_119f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119f1c inside entry_119f14 (0x119f14 - 0x119f24)
    ctx->pc = 0x119f1c;
    entry_119f14(rdram, ctx, runtime);
}

void entry_119f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119f38 inside entry_119f24 (0x119f24 - 0x119f44)
    ctx->pc = 0x119f38;
    entry_119f24(rdram, ctx, runtime);
}

void entry_119f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x119f54 inside entry_119f44 (0x119f44 - 0x119f5c)
    ctx->pc = 0x119f54;
    entry_119f44(rdram, ctx, runtime);
}

void entry_11a030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a030 inside entry_11a02c (0x11a02c - 0x11a038)
    ctx->pc = 0x11a030;
    entry_11a02c(rdram, ctx, runtime);
}

void entry_11a27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a27c inside entry_11a270 (0x11a270 - 0x11a284)
    ctx->pc = 0x11a27c;
    entry_11a270(rdram, ctx, runtime);
}

void entry_11a2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a2a4 inside entry_11a2a0 (0x11a2a0 - 0x11a2ac)
    ctx->pc = 0x11a2a4;
    entry_11a2a0(rdram, ctx, runtime);
}

void entry_11a2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a2c0 inside entry_11a2b8 (0x11a2b8 - 0x11a2d4)
    ctx->pc = 0x11a2c0;
    entry_11a2b8(rdram, ctx, runtime);
}

void entry_11a2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a2f0 inside entry_11a2ec (0x11a2ec - 0x11a2f8)
    ctx->pc = 0x11a2f0;
    entry_11a2ec(rdram, ctx, runtime);
}

void entry_11a458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a458 inside entry_11a454 (0x11a454 - 0x11a460)
    ctx->pc = 0x11a458;
    entry_11a454(rdram, ctx, runtime);
}

void entry_11a4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a4c8 inside entry_11a4c4 (0x11a4c4 - 0x11a4d8)
    ctx->pc = 0x11a4c8;
    entry_11a4c4(rdram, ctx, runtime);
}

void entry_11a518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a518 inside PrefFindBinding__6CFrameUii (0x11a4d8 - 0x11a564)
    ctx->pc = 0x11a518;
    PrefFindBinding__6CFrameUii(rdram, ctx, runtime);
}

void entry_11a528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a528 inside PrefFindBinding__6CFrameUii (0x11a4d8 - 0x11a564)
    ctx->pc = 0x11a528;
    PrefFindBinding__6CFrameUii(rdram, ctx, runtime);
}

void entry_11a530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a530 inside PrefFindBinding__6CFrameUii (0x11a4d8 - 0x11a564)
    ctx->pc = 0x11a530;
    PrefFindBinding__6CFrameUii(rdram, ctx, runtime);
}

void entry_11a548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a548 inside PrefFindBinding__6CFrameUii (0x11a4d8 - 0x11a564)
    ctx->pc = 0x11a548;
    PrefFindBinding__6CFrameUii(rdram, ctx, runtime);
}

void entry_11a574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a574 inside entry_11a564 (0x11a564 - 0x11a5b0)
    ctx->pc = 0x11a574;
    entry_11a564(rdram, ctx, runtime);
}

void entry_11a584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a584 inside entry_11a564 (0x11a564 - 0x11a5b0)
    ctx->pc = 0x11a584;
    entry_11a564(rdram, ctx, runtime);
}

void entry_11a588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a588 inside entry_11a564 (0x11a564 - 0x11a5b0)
    ctx->pc = 0x11a588;
    entry_11a564(rdram, ctx, runtime);
}

void entry_11a618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a618 inside entry_11a610 (0x11a610 - 0x11a630)
    ctx->pc = 0x11a618;
    entry_11a610(rdram, ctx, runtime);
}

void entry_11a680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a680 inside __3CGc (0x11a678 - 0x11a698)
    ctx->pc = 0x11a680;
    fn___3CGc(rdram, ctx, runtime);
}

void entry_11a6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a6d0 inside AddRootFrame__3CGcP6CFrame (0x11a6c0 - 0x11a708)
    ctx->pc = 0x11a6d0;
    AddRootFrame__3CGcP6CFrame(rdram, ctx, runtime);
}

void entry_11a6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a6e8 inside AddRootFrame__3CGcP6CFrame (0x11a6c0 - 0x11a708)
    ctx->pc = 0x11a6e8;
    AddRootFrame__3CGcP6CFrame(rdram, ctx, runtime);
}

void entry_11a700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a700 inside AddRootFrame__3CGcP6CFrame (0x11a6c0 - 0x11a708)
    ctx->pc = 0x11a700;
    AddRootFrame__3CGcP6CFrame(rdram, ctx, runtime);
}

void entry_11a75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a75c inside PframePop__3CGc (0x11a748 - 0x11a770)
    ctx->pc = 0x11a75c;
    PframePop__3CGc(rdram, ctx, runtime);
}

void entry_11a7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a7a4 inside PpairPop__3CGc (0x11a790 - 0x11a7b8)
    ctx->pc = 0x11a7a4;
    PpairPop__3CGc(rdram, ctx, runtime);
}

void entry_11a7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a7ec inside PprocPop__3CGc (0x11a7d8 - 0x11a800)
    ctx->pc = 0x11a7ec;
    PprocPop__3CGc(rdram, ctx, runtime);
}

void entry_11a880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a880 inside MarkLiveObjects__3CGc (0x11a850 - 0x11a888)
    ctx->pc = 0x11a880;
    MarkLiveObjects__3CGc(rdram, ctx, runtime);
}

void entry_11a8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a8b0 inside entry_11a888 (0x11a888 - 0x11a8b8)
    ctx->pc = 0x11a8b0;
    entry_11a888(rdram, ctx, runtime);
}

void entry_11a8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a8e0 inside entry_11a8b8 (0x11a8b8 - 0x11a8f8)
    ctx->pc = 0x11a8e0;
    entry_11a8b8(rdram, ctx, runtime);
}

void entry_11a8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a8f0 inside entry_11a8b8 (0x11a8b8 - 0x11a8f8)
    ctx->pc = 0x11a8f0;
    entry_11a8b8(rdram, ctx, runtime);
}

void entry_11a91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a91c inside entry_11a914 (0x11a914 - 0x11a928)
    ctx->pc = 0x11a91c;
    entry_11a914(rdram, ctx, runtime);
}

void entry_11a94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a94c inside entry_11a944 (0x11a944 - 0x11a954)
    ctx->pc = 0x11a94c;
    entry_11a944(rdram, ctx, runtime);
}

void entry_11a958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a958 inside entry_11a954 (0x11a954 - 0x11a97c)
    ctx->pc = 0x11a958;
    entry_11a954(rdram, ctx, runtime);
}

void entry_11a964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a964 inside entry_11a954 (0x11a954 - 0x11a97c)
    ctx->pc = 0x11a964;
    entry_11a954(rdram, ctx, runtime);
}

void entry_11a970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a970 inside entry_11a954 (0x11a954 - 0x11a97c)
    ctx->pc = 0x11a970;
    entry_11a954(rdram, ctx, runtime);
}

void entry_11a99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a99c inside entry_11a998 (0x11a998 - 0x11a9bc)
    ctx->pc = 0x11a99c;
    entry_11a998(rdram, ctx, runtime);
}

void entry_11a9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a9b4 inside entry_11a998 (0x11a998 - 0x11a9bc)
    ctx->pc = 0x11a9b4;
    entry_11a998(rdram, ctx, runtime);
}

void entry_11a9d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a9d8 inside entry_11a9bc (0x11a9bc - 0x11a9e0)
    ctx->pc = 0x11a9d8;
    entry_11a9bc(rdram, ctx, runtime);
}

void entry_11a9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11a9f0 inside entry_11a9e0 (0x11a9e0 - 0x11a9f8)
    ctx->pc = 0x11a9f0;
    entry_11a9e0(rdram, ctx, runtime);
}

void entry_11aa18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aa18 inside entry_11aa14 (0x11aa14 - 0x11aa20)
    ctx->pc = 0x11aa18;
    entry_11aa14(rdram, ctx, runtime);
}

void entry_11aa44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aa44 inside entry_11aa3c (0x11aa3c - 0x11aa4c)
    ctx->pc = 0x11aa44;
    entry_11aa3c(rdram, ctx, runtime);
}

void entry_11aa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aa7c inside entry_11aa4c (0x11aa4c - 0x11aa98)
    ctx->pc = 0x11aa7c;
    entry_11aa4c(rdram, ctx, runtime);
}

void entry_11aa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aa90 inside entry_11aa4c (0x11aa4c - 0x11aa98)
    ctx->pc = 0x11aa90;
    entry_11aa4c(rdram, ctx, runtime);
}

void entry_11aabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aabc inside entry_11aab4 (0x11aab4 - 0x11aac8)
    ctx->pc = 0x11aabc;
    entry_11aab4(rdram, ctx, runtime);
}

void entry_11aaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aaec inside entry_11aae4 (0x11aae4 - 0x11aaf4)
    ctx->pc = 0x11aaec;
    entry_11aae4(rdram, ctx, runtime);
}

void entry_11aaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aaf8 inside entry_11aaf4 (0x11aaf4 - 0x11ab08)
    ctx->pc = 0x11aaf8;
    entry_11aaf4(rdram, ctx, runtime);
}

void entry_11ab2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ab2c inside entry_11ab24 (0x11ab24 - 0x11ab58)
    ctx->pc = 0x11ab2c;
    entry_11ab24(rdram, ctx, runtime);
}

void entry_11abf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11abf0 inside entry_11abc8 (0x11abc8 - 0x11abfc)
    ctx->pc = 0x11abf0;
    entry_11abc8(rdram, ctx, runtime);
}

void entry_11ac1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ac1c inside entry_11ac18 (0x11ac18 - 0x11ac70)
    ctx->pc = 0x11ac1c;
    entry_11ac18(rdram, ctx, runtime);
}

void entry_11ac24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ac24 inside entry_11ac18 (0x11ac18 - 0x11ac70)
    ctx->pc = 0x11ac24;
    entry_11ac18(rdram, ctx, runtime);
}

void entry_11ac40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ac40 inside entry_11ac18 (0x11ac18 - 0x11ac70)
    ctx->pc = 0x11ac40;
    entry_11ac18(rdram, ctx, runtime);
}

void entry_11ac68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ac68 inside entry_11ac18 (0x11ac18 - 0x11ac70)
    ctx->pc = 0x11ac68;
    entry_11ac18(rdram, ctx, runtime);
}

void entry_11ac98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ac98 inside entry_11ac70 (0x11ac70 - 0x11acb0)
    ctx->pc = 0x11ac98;
    entry_11ac70(rdram, ctx, runtime);
}

void entry_11aca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11aca8 inside entry_11ac70 (0x11ac70 - 0x11acb0)
    ctx->pc = 0x11aca8;
    entry_11ac70(rdram, ctx, runtime);
}

void entry_11acd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11acd4 inside entry_11accc (0x11accc - 0x11ace0)
    ctx->pc = 0x11acd4;
    entry_11accc(rdram, ctx, runtime);
}

void entry_11ad04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad04 inside entry_11acfc (0x11acfc - 0x11ad0c)
    ctx->pc = 0x11ad04;
    entry_11acfc(rdram, ctx, runtime);
}

void entry_11ad10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad10 inside entry_11ad0c (0x11ad0c - 0x11ad5c)
    ctx->pc = 0x11ad10;
    entry_11ad0c(rdram, ctx, runtime);
}

void entry_11ad18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad18 inside entry_11ad0c (0x11ad0c - 0x11ad5c)
    ctx->pc = 0x11ad18;
    entry_11ad0c(rdram, ctx, runtime);
}

void entry_11ad24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad24 inside entry_11ad0c (0x11ad0c - 0x11ad5c)
    ctx->pc = 0x11ad24;
    entry_11ad0c(rdram, ctx, runtime);
}

void entry_11ad40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad40 inside entry_11ad0c (0x11ad0c - 0x11ad5c)
    ctx->pc = 0x11ad40;
    entry_11ad0c(rdram, ctx, runtime);
}

void entry_11ad7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad7c inside entry_11ad78 (0x11ad78 - 0x11ad8c)
    ctx->pc = 0x11ad7c;
    entry_11ad78(rdram, ctx, runtime);
}

void entry_11ad84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ad84 inside entry_11ad78 (0x11ad78 - 0x11ad8c)
    ctx->pc = 0x11ad84;
    entry_11ad78(rdram, ctx, runtime);
}

void entry_11ae20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ae20 inside entry_11ae18 (0x11ae18 - 0x11ae2c)
    ctx->pc = 0x11ae20;
    entry_11ae18(rdram, ctx, runtime);
}

void entry_11ae30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ae30 inside entry_11ae2c (0x11ae2c - 0x11ae38)
    ctx->pc = 0x11ae30;
    entry_11ae2c(rdram, ctx, runtime);
}

void entry_11af10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11af10 inside entry_11af08 (0x11af08 - 0x11af28)
    ctx->pc = 0x11af10;
    entry_11af08(rdram, ctx, runtime);
}

void entry_11afa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11afa0 inside CloneTo__5CProcP5CProcP6CFrame (0x11af98 - 0x11afc8)
    ctx->pc = 0x11afa0;
    CloneTo__5CProcP5CProcP6CFrame(rdram, ctx, runtime);
}

void entry_11b060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b060 inside entry_11b038 (0x11b038 - 0x11b07c)
    ctx->pc = 0x11b060;
    entry_11b038(rdram, ctx, runtime);
}

void entry_11b094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b094 inside entry_11b090 (0x11b090 - 0x11b0a8)
    ctx->pc = 0x11b094;
    entry_11b090(rdram, ctx, runtime);
}

void entry_11b17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b17c inside __eq__4CRefRC4CRef (0x11b0f8 - 0x11b1a0)
    ctx->pc = 0x11b17c;
    fn___eq__4CRefRC4CRef(rdram, ctx, runtime);
}

void entry_11b214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b214 inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b214;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b224 inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b224;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b228 inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b228;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b244 inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b244;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b248 inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b248;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b24c inside entry_11b1a0 (0x11b1a0 - 0x11b258)
    ctx->pc = 0x11b24c;
    entry_11b1a0(rdram, ctx, runtime);
}

void entry_11b3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b3f0 inside entry_11b3e8 (0x11b3e8 - 0x11b418)
    ctx->pc = 0x11b3f0;
    entry_11b3e8(rdram, ctx, runtime);
}

void entry_11b3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b3f8 inside entry_11b3e8 (0x11b3e8 - 0x11b418)
    ctx->pc = 0x11b3f8;
    entry_11b3e8(rdram, ctx, runtime);
}

void entry_11b49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b49c inside entry_11b498 (0x11b498 - 0x11b4a8)
    ctx->pc = 0x11b49c;
    entry_11b498(rdram, ctx, runtime);
}

void entry_11b52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b52c inside entry_11b528 (0x11b528 - 0x11b538)
    ctx->pc = 0x11b52c;
    entry_11b528(rdram, ctx, runtime);
}

void entry_11b61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b61c inside entry_11b60c (0x11b60c - 0x11b640)
    ctx->pc = 0x11b61c;
    entry_11b60c(rdram, ctx, runtime);
}

void entry_11b620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b620 inside entry_11b60c (0x11b60c - 0x11b640)
    ctx->pc = 0x11b620;
    entry_11b60c(rdram, ctx, runtime);
}

void entry_11b95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b95c inside entry_11b954 (0x11b954 - 0x11b964)
    ctx->pc = 0x11b95c;
    entry_11b954(rdram, ctx, runtime);
}

void entry_11b994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b994 inside entry_11b990 (0x11b990 - 0x11b9a8)
    ctx->pc = 0x11b994;
    entry_11b990(rdram, ctx, runtime);
}

void entry_11b9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11b9dc inside entry_11b9d4 (0x11b9d4 - 0x11b9e4)
    ctx->pc = 0x11b9dc;
    entry_11b9d4(rdram, ctx, runtime);
}

void entry_11ba10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ba10 inside entry_11ba0c (0x11ba0c - 0x11ba28)
    ctx->pc = 0x11ba10;
    entry_11ba0c(rdram, ctx, runtime);
}

void entry_11bb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bb88 inside entry_11bb80 (0x11bb80 - 0x11bb94)
    ctx->pc = 0x11bb88;
    entry_11bb80(rdram, ctx, runtime);
}

void entry_11bbd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bbd0 inside entry_11bbc4 (0x11bbc4 - 0x11bbdc)
    ctx->pc = 0x11bbd0;
    entry_11bbc4(rdram, ctx, runtime);
}

void entry_11bc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bc18 inside entry_11bc0c (0x11bc0c - 0x11bc24)
    ctx->pc = 0x11bc18;
    entry_11bc0c(rdram, ctx, runtime);
}

void entry_11bd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bd00 inside entry_11bcfc (0x11bcfc - 0x11bd28)
    ctx->pc = 0x11bd00;
    entry_11bcfc(rdram, ctx, runtime);
}

void entry_11bd04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bd04 inside entry_11bcfc (0x11bcfc - 0x11bd28)
    ctx->pc = 0x11bd04;
    entry_11bcfc(rdram, ctx, runtime);
}

void entry_11bdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bdf8 inside RefSetBinding__8CSidebagiP4CRef (0x11bdd0 - 0x11be08)
    ctx->pc = 0x11bdf8;
    RefSetBinding__8CSidebagiP4CRef(rdram, ctx, runtime);
}

void entry_11be40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11be40 inside entry_11be38 (0x11be38 - 0x11be50)
    ctx->pc = 0x11be40;
    entry_11be38(rdram, ctx, runtime);
}

void entry_11be48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11be48 inside entry_11be38 (0x11be38 - 0x11be50)
    ctx->pc = 0x11be48;
    entry_11be38(rdram, ctx, runtime);
}

void entry_11be78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11be78 inside entry_11be74 (0x11be74 - 0x11be90)
    ctx->pc = 0x11be78;
    entry_11be74(rdram, ctx, runtime);
}

void entry_11bea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bea8 inside FFindBinding__8CSidebagiP4CRef (0x11be90 - 0x11bec0)
    ctx->pc = 0x11bea8;
    FFindBinding__8CSidebagiP4CRef(rdram, ctx, runtime);
}

void entry_11bec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bec8 inside entry_11bec0 (0x11bec0 - 0x11bee0)
    ctx->pc = 0x11bec8;
    entry_11bec0(rdram, ctx, runtime);
}

void entry_11bed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bed0 inside entry_11bec0 (0x11bec0 - 0x11bee0)
    ctx->pc = 0x11bed0;
    entry_11bec0(rdram, ctx, runtime);
}

void entry_11bed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11bed4 inside entry_11bec0 (0x11bec0 - 0x11bee0)
    ctx->pc = 0x11bed4;
    entry_11bec0(rdram, ctx, runtime);
}

void entry_11c0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c0e0 inside spliceutils__static_initialization_and_destruction_0 (0x11c0a8 - 0x11c0e8)
    ctx->pc = 0x11c0e0;
    spliceutils__static_initialization_and_destruction_0(rdram, ctx, runtime);
}

void entry_11c180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c180 inside entry_11c170 (0x11c170 - 0x11c194)
    ctx->pc = 0x11c180;
    entry_11c170(rdram, ctx, runtime);
}

void entry_11c1a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c1a4 inside entry_11c194 (0x11c194 - 0x11c1d0)
    ctx->pc = 0x11c1a4;
    entry_11c194(rdram, ctx, runtime);
}

void entry_11c204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c204 inside entry_11c200 (0x11c200 - 0x11c22c)
    ctx->pc = 0x11c204;
    entry_11c200(rdram, ctx, runtime);
}

void entry_11c214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c214 inside entry_11c200 (0x11c200 - 0x11c22c)
    ctx->pc = 0x11c214;
    entry_11c200(rdram, ctx, runtime);
}

void entry_11c2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c2c0 inside UnmarkAll__10CSplotheap (0x11c2b0 - 0x11c2e8)
    ctx->pc = 0x11c2c0;
    UnmarkAll__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c2dc inside UnmarkAll__10CSplotheap (0x11c2b0 - 0x11c2e8)
    ctx->pc = 0x11c2dc;
    UnmarkAll__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c320 inside FreeGarbage__10CSplotheap (0x11c2e8 - 0x11c37c)
    ctx->pc = 0x11c320;
    FreeGarbage__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c334 inside FreeGarbage__10CSplotheap (0x11c2e8 - 0x11c37c)
    ctx->pc = 0x11c334;
    FreeGarbage__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c338 inside FreeGarbage__10CSplotheap (0x11c2e8 - 0x11c37c)
    ctx->pc = 0x11c338;
    FreeGarbage__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c348 inside FreeGarbage__10CSplotheap (0x11c2e8 - 0x11c37c)
    ctx->pc = 0x11c348;
    FreeGarbage__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c358 inside FreeGarbage__10CSplotheap (0x11c2e8 - 0x11c37c)
    ctx->pc = 0x11c358;
    FreeGarbage__10CSplotheap(rdram, ctx, runtime);
}

void entry_11c38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c38c inside entry_11c388 (0x11c388 - 0x11c3b8)
    ctx->pc = 0x11c38c;
    entry_11c388(rdram, ctx, runtime);
}

void entry_11c398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c398 inside entry_11c388 (0x11c388 - 0x11c3b8)
    ctx->pc = 0x11c398;
    entry_11c388(rdram, ctx, runtime);
}

void entry_11c480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c480 inside entry_11c478 (0x11c478 - 0x11c498)
    ctx->pc = 0x11c480;
    entry_11c478(rdram, ctx, runtime);
}

void entry_11c54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c54c inside entry_11c544 (0x11c544 - 0x11c558)
    ctx->pc = 0x11c54c;
    entry_11c544(rdram, ctx, runtime);
}

void entry_11c568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c568 inside entry_11c560 (0x11c560 - 0x11c580)
    ctx->pc = 0x11c568;
    entry_11c560(rdram, ctx, runtime);
}

void entry_11c604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c604 inside entry_11c600 (0x11c600 - 0x11c610)
    ctx->pc = 0x11c604;
    entry_11c600(rdram, ctx, runtime);
}

void entry_11c65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c65c inside entry_11c654 (0x11c654 - 0x11c668)
    ctx->pc = 0x11c65c;
    entry_11c654(rdram, ctx, runtime);
}

void entry_11c678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c678 inside entry_11c670 (0x11c670 - 0x11c690)
    ctx->pc = 0x11c678;
    entry_11c670(rdram, ctx, runtime);
}

void entry_11c714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c714 inside entry_11c710 (0x11c710 - 0x11c720)
    ctx->pc = 0x11c714;
    entry_11c710(rdram, ctx, runtime);
}

void entry_11c78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c78c inside entry_11c784 (0x11c784 - 0x11c798)
    ctx->pc = 0x11c78c;
    entry_11c784(rdram, ctx, runtime);
}

void entry_11c7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c7a8 inside entry_11c7a0 (0x11c7a0 - 0x11c7c0)
    ctx->pc = 0x11c7a8;
    entry_11c7a0(rdram, ctx, runtime);
}

void entry_11c844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c844 inside entry_11c840 (0x11c840 - 0x11c850)
    ctx->pc = 0x11c844;
    entry_11c840(rdram, ctx, runtime);
}

void entry_11c89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c89c inside entry_11c894 (0x11c894 - 0x11c8a8)
    ctx->pc = 0x11c89c;
    entry_11c894(rdram, ctx, runtime);
}

void entry_11c8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c8b8 inside entry_11c8b0 (0x11c8b0 - 0x11c8d0)
    ctx->pc = 0x11c8b8;
    entry_11c8b0(rdram, ctx, runtime);
}

void entry_11c954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c954 inside entry_11c950 (0x11c950 - 0x11c960)
    ctx->pc = 0x11c954;
    entry_11c950(rdram, ctx, runtime);
}

void entry_11c9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c9ac inside entry_11c9a4 (0x11c9a4 - 0x11c9b8)
    ctx->pc = 0x11c9ac;
    entry_11c9a4(rdram, ctx, runtime);
}

void entry_11c9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c9c8 inside entry_11c9c0 (0x11c9c0 - 0x11c9e0)
    ctx->pc = 0x11c9c8;
    entry_11c9c0(rdram, ctx, runtime);
}

void entry_11c9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11c9f4 inside IncrefSmp__FP3SMP (0x11c9e0 - 0x11ca20)
    ctx->pc = 0x11c9f4;
    IncrefSmp__FP3SMP(rdram, ctx, runtime);
}

void entry_11ca44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ca44 inside DecrefSmp__FP3SMP (0x11ca20 - 0x11ca80)
    ctx->pc = 0x11ca44;
    DecrefSmp__FP3SMP(rdram, ctx, runtime);
}

void entry_11ca84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ca84 inside entry_11ca80 (0x11ca80 - 0x11ca90)
    ctx->pc = 0x11ca84;
    entry_11ca80(rdram, ctx, runtime);
}

void entry_11cc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cc78 inside entry_11cc58 (0x11cc58 - 0x11cc88)
    ctx->pc = 0x11cc78;
    entry_11cc58(rdram, ctx, runtime);
}

void entry_11ccbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ccbc inside entry_11cca0 (0x11cca0 - 0x11cd40)
    ctx->pc = 0x11ccbc;
    entry_11cca0(rdram, ctx, runtime);
}

void entry_11ccd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ccd0 inside entry_11cca0 (0x11cca0 - 0x11cd40)
    ctx->pc = 0x11ccd0;
    entry_11cca0(rdram, ctx, runtime);
}

void entry_11ccf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ccf0 inside entry_11cca0 (0x11cca0 - 0x11cd40)
    ctx->pc = 0x11ccf0;
    entry_11cca0(rdram, ctx, runtime);
}

void entry_11cd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cd30 inside entry_11cca0 (0x11cca0 - 0x11cd40)
    ctx->pc = 0x11cd30;
    entry_11cca0(rdram, ctx, runtime);
}

void entry_11cd74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cd74 inside entry_11cd58 (0x11cd58 - 0x11ce00)
    ctx->pc = 0x11cd74;
    entry_11cd58(rdram, ctx, runtime);
}

void entry_11cd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cd88 inside entry_11cd58 (0x11cd58 - 0x11ce00)
    ctx->pc = 0x11cd88;
    entry_11cd58(rdram, ctx, runtime);
}

void entry_11cda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cda8 inside entry_11cd58 (0x11cd58 - 0x11ce00)
    ctx->pc = 0x11cda8;
    entry_11cd58(rdram, ctx, runtime);
}

void entry_11ceb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ceb4 inside entry_11cea8 (0x11cea8 - 0x11cf30)
    ctx->pc = 0x11ceb4;
    entry_11cea8(rdram, ctx, runtime);
}

void entry_11cf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cf08 inside entry_11cea8 (0x11cea8 - 0x11cf30)
    ctx->pc = 0x11cf08;
    entry_11cea8(rdram, ctx, runtime);
}

void entry_11cf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cf48 inside entry_11cf30 (0x11cf30 - 0x11cf5c)
    ctx->pc = 0x11cf48;
    entry_11cf30(rdram, ctx, runtime);
}

void entry_11cf4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cf4c inside entry_11cf30 (0x11cf30 - 0x11cf5c)
    ctx->pc = 0x11cf4c;
    entry_11cf30(rdram, ctx, runtime);
}

void entry_11cf94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cf94 inside entry_11cf8c (0x11cf8c - 0x11cfdc)
    ctx->pc = 0x11cf94;
    entry_11cf8c(rdram, ctx, runtime);
}

void entry_11cfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11cfe0 inside entry_11cfdc (0x11cfdc - 0x11cff0)
    ctx->pc = 0x11cfe0;
    entry_11cfdc(rdram, ctx, runtime);
}

void entry_11d01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d01c inside entry_11d018 (0x11d018 - 0x11d060)
    ctx->pc = 0x11d01c;
    entry_11d018(rdram, ctx, runtime);
}

void entry_11d034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d034 inside entry_11d018 (0x11d018 - 0x11d060)
    ctx->pc = 0x11d034;
    entry_11d018(rdram, ctx, runtime);
}

void entry_11d0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d0a4 inside entry_11d090 (0x11d090 - 0x11d0ac)
    ctx->pc = 0x11d0a4;
    entry_11d090(rdram, ctx, runtime);
}

void entry_11d0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d0f4 inside entry_11d0ac (0x11d0ac - 0x11d0fc)
    ctx->pc = 0x11d0f4;
    entry_11d0ac(rdram, ctx, runtime);
}

void entry_11d100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d100 inside entry_11d0fc (0x11d0fc - 0x11d110)
    ctx->pc = 0x11d100;
    entry_11d0fc(rdram, ctx, runtime);
}

void entry_11d188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d188 inside snd_BankLoadByLoc (0x11d140 - 0x11d190)
    ctx->pc = 0x11d188;
    snd_BankLoadByLoc(rdram, ctx, runtime);
}

void entry_11d1a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d1a4 inside entry_11d190 (0x11d190 - 0x11d1ac)
    ctx->pc = 0x11d1a4;
    entry_11d190(rdram, ctx, runtime);
}

void entry_11d1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d1b4 inside entry_11d1ac (0x11d1ac - 0x11d1e8)
    ctx->pc = 0x11d1b4;
    entry_11d1ac(rdram, ctx, runtime);
}

void entry_11d1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d1e0 inside entry_11d1ac (0x11d1ac - 0x11d1e8)
    ctx->pc = 0x11d1e0;
    entry_11d1ac(rdram, ctx, runtime);
}

void entry_11d258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d258 inside entry_11d248 (0x11d248 - 0x11d278)
    ctx->pc = 0x11d258;
    entry_11d248(rdram, ctx, runtime);
}

void entry_11d270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d270 inside entry_11d248 (0x11d248 - 0x11d278)
    ctx->pc = 0x11d270;
    entry_11d248(rdram, ctx, runtime);
}

void entry_11d284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d284 inside entry_11d278 (0x11d278 - 0x11d2a8)
    ctx->pc = 0x11d284;
    entry_11d278(rdram, ctx, runtime);
}

void entry_11d300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d300 inside entry_11d2f8 (0x11d2f8 - 0x11d308)
    ctx->pc = 0x11d300;
    entry_11d2f8(rdram, ctx, runtime);
}

void entry_11d328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d328 inside entry_11d320 (0x11d320 - 0x11d370)
    ctx->pc = 0x11d328;
    entry_11d320(rdram, ctx, runtime);
}

void entry_11d368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d368 inside entry_11d320 (0x11d320 - 0x11d370)
    ctx->pc = 0x11d368;
    entry_11d320(rdram, ctx, runtime);
}

void entry_11d3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d3c8 inside entry_11d3c4 (0x11d3c4 - 0x11d3e8)
    ctx->pc = 0x11d3c8;
    entry_11d3c4(rdram, ctx, runtime);
}

void entry_11d9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d9a8 inside snd_SendIOPCommandAndWait__FiiPc (0x11d968 - 0x11d9d8)
    ctx->pc = 0x11d9a8;
    snd_SendIOPCommandAndWait__FiiPc(rdram, ctx, runtime);
}

void entry_11d9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d9d0 inside snd_SendIOPCommandAndWait__FiiPc (0x11d968 - 0x11d9d8)
    ctx->pc = 0x11d9d0;
    snd_SendIOPCommandAndWait__FiiPc(rdram, ctx, runtime);
}

void entry_11d9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11d9e4 inside entry_11d9e0 (0x11d9e0 - 0x11d9f4)
    ctx->pc = 0x11d9e4;
    entry_11d9e0(rdram, ctx, runtime);
}

void entry_11da00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11da00 inside entry_11d9f4 (0x11d9f4 - 0x11da08)
    ctx->pc = 0x11da00;
    entry_11d9f4(rdram, ctx, runtime);
}

void entry_11da60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11da60 inside entry_11da58 (0x11da58 - 0x11da88)
    ctx->pc = 0x11da60;
    entry_11da58(rdram, ctx, runtime);
}

void entry_11dadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dadc inside entry_11dad8 (0x11dad8 - 0x11db00)
    ctx->pc = 0x11dadc;
    entry_11dad8(rdram, ctx, runtime);
}

void entry_11db90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11db90 inside entry_11db80 (0x11db80 - 0x11db98)
    ctx->pc = 0x11db90;
    entry_11db80(rdram, ctx, runtime);
}

void entry_11dbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dbec inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dbec;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dbf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dbf0 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dbf0;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dbf4 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dbf4;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dc20 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dc20;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dc30 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dc30;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dc34 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dc34;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dc44 inside entry_11dbe4 (0x11dbe4 - 0x11dc4c)
    ctx->pc = 0x11dc44;
    entry_11dbe4(rdram, ctx, runtime);
}

void entry_11dc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dc80 inside entry_11dc7c (0x11dc7c - 0x11dccc)
    ctx->pc = 0x11dc80;
    entry_11dc7c(rdram, ctx, runtime);
}

void entry_11dcdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dcdc inside entry_11dccc (0x11dccc - 0x11dda4)
    ctx->pc = 0x11dcdc;
    entry_11dccc(rdram, ctx, runtime);
}

void entry_11dd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dd18 inside entry_11dccc (0x11dccc - 0x11dda4)
    ctx->pc = 0x11dd18;
    entry_11dccc(rdram, ctx, runtime);
}

void entry_11dd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dd38 inside entry_11dccc (0x11dccc - 0x11dda4)
    ctx->pc = 0x11dd38;
    entry_11dccc(rdram, ctx, runtime);
}

void entry_11dda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dda8 inside entry_11dda4 (0x11dda4 - 0x11ddd8)
    ctx->pc = 0x11dda8;
    entry_11dda4(rdram, ctx, runtime);
}

void entry_11de88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11de88 inside entry_11de6c (0x11de6c - 0x11de90)
    ctx->pc = 0x11de88;
    entry_11de6c(rdram, ctx, runtime);
}

void entry_11dfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dfa0 inside snd_InitVAGStreamingEx (0x11df58 - 0x11dfb8)
    ctx->pc = 0x11dfa0;
    snd_InitVAGStreamingEx(rdram, ctx, runtime);
}

void entry_11dfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dfb0 inside snd_InitVAGStreamingEx (0x11df58 - 0x11dfb8)
    ctx->pc = 0x11dfb0;
    snd_InitVAGStreamingEx(rdram, ctx, runtime);
}

void entry_11dfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dfc0 inside entry_11dfb8 (0x11dfb8 - 0x11dfc8)
    ctx->pc = 0x11dfc0;
    entry_11dfb8(rdram, ctx, runtime);
}

void entry_11dfec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11dfec inside entry_11dfe8 (0x11dfe8 - 0x11e010)
    ctx->pc = 0x11dfec;
    entry_11dfe8(rdram, ctx, runtime);
}

void entry_11e178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e178 inside entry_11e170 (0x11e170 - 0x11e184)
    ctx->pc = 0x11e178;
    entry_11e170(rdram, ctx, runtime);
}

void entry_11e1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e1d4 inside entry_11e1bc (0x11e1bc - 0x11e1f8)
    ctx->pc = 0x11e1d4;
    entry_11e1bc(rdram, ctx, runtime);
}

void entry_11e1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e1d8 inside entry_11e1bc (0x11e1bc - 0x11e1f8)
    ctx->pc = 0x11e1d8;
    entry_11e1bc(rdram, ctx, runtime);
}

void entry_11e1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e1dc inside entry_11e1bc (0x11e1bc - 0x11e1f8)
    ctx->pc = 0x11e1dc;
    entry_11e1bc(rdram, ctx, runtime);
}

void entry_11e228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e228 inside entry_11e220 (0x11e220 - 0x11e230)
    ctx->pc = 0x11e228;
    entry_11e220(rdram, ctx, runtime);
}

void entry_11e268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e268 inside entry_11e230 (0x11e230 - 0x11e270)
    ctx->pc = 0x11e268;
    entry_11e230(rdram, ctx, runtime);
}

void entry_11e288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e288 inside entry_11e278 (0x11e278 - 0x11e2a0)
    ctx->pc = 0x11e288;
    entry_11e278(rdram, ctx, runtime);
}

void entry_11e28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e28c inside entry_11e278 (0x11e278 - 0x11e2a0)
    ctx->pc = 0x11e28c;
    entry_11e278(rdram, ctx, runtime);
}

void entry_11e290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e290 inside entry_11e278 (0x11e278 - 0x11e2a0)
    ctx->pc = 0x11e290;
    entry_11e278(rdram, ctx, runtime);
}

void entry_11e2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e2d4 inside entry_11e2cc (0x11e2cc - 0x11e2dc)
    ctx->pc = 0x11e2d4;
    entry_11e2cc(rdram, ctx, runtime);
}

void entry_11e310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e310 inside snd_StreamSafeCdGetError (0x11e2e8 - 0x11e318)
    ctx->pc = 0x11e310;
    snd_StreamSafeCdGetError(rdram, ctx, runtime);
}

void entry_11e31c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e31c inside entry_11e318 (0x11e318 - 0x11e328)
    ctx->pc = 0x11e31c;
    entry_11e318(rdram, ctx, runtime);
}

void entry_11e54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e54c inside snd_GetDopplerPitchMod (0x11e538 - 0x11e560)
    ctx->pc = 0x11e54c;
    snd_GetDopplerPitchMod(rdram, ctx, runtime);
}

void entry_11e6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e6d0 inside LoadOptionFromBrx__FPvP5EOPIDP18CBinaryInputStream (0x11e680 - 0x11e6dc)
    ctx->pc = 0x11e6d0;
    LoadOptionFromBrx__FPvP5EOPIDP18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_11e6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e6f0 inside entry_11e6dc (0x11e6dc - 0x11e6f8)
    ctx->pc = 0x11e6f0;
    entry_11e6dc(rdram, ctx, runtime);
}

void entry_11e77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e77c inside entry_11e778 (0x11e778 - 0x11e788)
    ctx->pc = 0x11e77c;
    entry_11e778(rdram, ctx, runtime);
}

void entry_11e85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e85c inside entry_11e854 (0x11e854 - 0x11e880)
    ctx->pc = 0x11e85c;
    entry_11e854(rdram, ctx, runtime);
}

void entry_11e894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e894 inside entry_11e890 (0x11e890 - 0x11e8bc)
    ctx->pc = 0x11e894;
    entry_11e890(rdram, ctx, runtime);
}

void entry_11e8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e8a0 inside entry_11e890 (0x11e890 - 0x11e8bc)
    ctx->pc = 0x11e8a0;
    entry_11e890(rdram, ctx, runtime);
}

void entry_11e8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e8d8 inside entry_11e8c8 (0x11e8c8 - 0x11e8e4)
    ctx->pc = 0x11e8d8;
    entry_11e8c8(rdram, ctx, runtime);
}

void entry_11e8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e8f4 inside entry_11e8e4 (0x11e8e4 - 0x11e914)
    ctx->pc = 0x11e8f4;
    entry_11e8e4(rdram, ctx, runtime);
}

void entry_11e920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e920 inside entry_11e914 (0x11e914 - 0x11e958)
    ctx->pc = 0x11e920;
    entry_11e914(rdram, ctx, runtime);
}

void entry_11e928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11e928 inside entry_11e914 (0x11e914 - 0x11e958)
    ctx->pc = 0x11e928;
    entry_11e914(rdram, ctx, runtime);
}

void entry_11ea40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ea40 inside entry_11ea38 (0x11ea38 - 0x11ea48)
    ctx->pc = 0x11ea40;
    entry_11ea38(rdram, ctx, runtime);
}

void entry_11ea50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ea50 inside entry_11ea48 (0x11ea48 - 0x11ea74)
    ctx->pc = 0x11ea50;
    entry_11ea48(rdram, ctx, runtime);
}

void entry_11ea7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ea7c inside entry_11ea74 (0x11ea74 - 0x11eac8)
    ctx->pc = 0x11ea7c;
    entry_11ea74(rdram, ctx, runtime);
}

void entry_11ea84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ea84 inside entry_11ea74 (0x11ea74 - 0x11eac8)
    ctx->pc = 0x11ea84;
    entry_11ea74(rdram, ctx, runtime);
}

void entry_11ea98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ea98 inside entry_11ea74 (0x11ea74 - 0x11eac8)
    ctx->pc = 0x11ea98;
    entry_11ea74(rdram, ctx, runtime);
}

void entry_11eb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11eb90 inside entry_11eb88 (0x11eb88 - 0x11eb98)
    ctx->pc = 0x11eb90;
    entry_11eb88(rdram, ctx, runtime);
}

void entry_11ebf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ebf4 inside entry_11ebf0 (0x11ebf0 - 0x11ebfc)
    ctx->pc = 0x11ebf4;
    entry_11ebf0(rdram, ctx, runtime);
}

void entry_11ec04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ec04 inside entry_11ebfc (0x11ebfc - 0x11ec0c)
    ctx->pc = 0x11ec04;
    entry_11ebfc(rdram, ctx, runtime);
}

void entry_11ec1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ec1c inside entry_11ec18 (0x11ec18 - 0x11ec40)
    ctx->pc = 0x11ec1c;
    entry_11ec18(rdram, ctx, runtime);
}

void entry_11ec68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ec68 inside LoadOptionsFromBrx__FPvP18CBinaryInputStream (0x11ec40 - 0x11ec70)
    ctx->pc = 0x11ec68;
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_11ed00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ed00 inside entry_11ecf0 (0x11ecf0 - 0x11ed08)
    ctx->pc = 0x11ed00;
    entry_11ecf0(rdram, ctx, runtime);
}

void entry_11ed7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ed7c inside entry_11ed70 (0x11ed70 - 0x11eda8)
    ctx->pc = 0x11ed7c;
    entry_11ed70(rdram, ctx, runtime);
}

void entry_11edf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11edf8 inside SetLoDefaults__FP2LO (0x11eda8 - 0x11ee1c)
    ctx->pc = 0x11edf8;
    SetLoDefaults__FP2LO(rdram, ctx, runtime);
}

void entry_11ee54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ee54 inside entry_11ee48 (0x11ee48 - 0x11ee70)
    ctx->pc = 0x11ee54;
    entry_11ee48(rdram, ctx, runtime);
}

void entry_11ee88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ee88 inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11ee88;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11eeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11eeb4 inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11eeb4;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11eebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11eebc inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11eebc;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11ef08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef08 inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11ef08;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11ef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef1c inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11ef1c;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11ef34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef34 inside FindKey__FfiiiPcPfT5PPv (0x11ee70 - 0x11ef40)
    ctx->pc = 0x11ef34;
    FindKey__FfiiiPcPfT5PPv(rdram, ctx, runtime);
}

void entry_11ef54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef54 inside GetAcpTimes__FP3ACPPiPPf (0x11ef48 - 0x11ef60)
    ctx->pc = 0x11ef54;
    GetAcpTimes__FP3ACPPiPPf(rdram, ctx, runtime);
}

void entry_11ef7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef7c inside GetAcrTimes__FP3ACRPiPPf (0x11ef70 - 0x11ef88)
    ctx->pc = 0x11ef7c;
    GetAcrTimes__FP3ACRPiPPf(rdram, ctx, runtime);
}

void entry_11ef9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11ef9c inside GetAcsTimes__FP3ACSPiPPf (0x11ef90 - 0x11efa8)
    ctx->pc = 0x11ef9c;
    GetAcsTimes__FP3ACSPiPPf(rdram, ctx, runtime);
}

void entry_11efbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11efbc inside GetAcgTimes__FP3ACGPiPPf (0x11efb0 - 0x11efc8)
    ctx->pc = 0x11efbc;
    GetAcgTimes__FP3ACGPiPPf(rdram, ctx, runtime);
}

void entry_11f030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f030 inside entry_11f00c (0x11f00c - 0x11f040)
    ctx->pc = 0x11f030;
    entry_11f00c(rdram, ctx, runtime);
}

void entry_11f0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f0a0 inside entry_11f08c (0x11f08c - 0x11f0c8)
    ctx->pc = 0x11f0a0;
    entry_11f08c(rdram, ctx, runtime);
}

void entry_11f130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f130 inside entry_11f10c (0x11f10c - 0x11f168)
    ctx->pc = 0x11f130;
    entry_11f10c(rdram, ctx, runtime);
}

void entry_11f140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f140 inside entry_11f10c (0x11f10c - 0x11f168)
    ctx->pc = 0x11f140;
    entry_11f10c(rdram, ctx, runtime);
}

void entry_11f16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f16c inside entry_11f168 (0x11f168 - 0x11f180)
    ctx->pc = 0x11f16c;
    entry_11f168(rdram, ctx, runtime);
}

void entry_11f1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f1c8 inside entry_11f1b4 (0x11f1b4 - 0x11f210)
    ctx->pc = 0x11f1c8;
    entry_11f1b4(rdram, ctx, runtime);
}

void entry_11f1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f1f8 inside entry_11f1b4 (0x11f1b4 - 0x11f210)
    ctx->pc = 0x11f1f8;
    entry_11f1b4(rdram, ctx, runtime);
}

void entry_11f268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f268 inside entry_11f24c (0x11f24c - 0x11f27c)
    ctx->pc = 0x11f268;
    entry_11f24c(rdram, ctx, runtime);
}

void entry_11f300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f300 inside entry_11f2e4 (0x11f2e4 - 0x11f320)
    ctx->pc = 0x11f300;
    entry_11f2e4(rdram, ctx, runtime);
}

void entry_11f388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f388 inside entry_11f364 (0x11f364 - 0x11f3cc)
    ctx->pc = 0x11f388;
    entry_11f364(rdram, ctx, runtime);
}

void entry_11f398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f398 inside entry_11f364 (0x11f364 - 0x11f3cc)
    ctx->pc = 0x11f398;
    entry_11f364(rdram, ctx, runtime);
}

void entry_11f3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f3d0 inside entry_11f3cc (0x11f3cc - 0x11f3e8)
    ctx->pc = 0x11f3d0;
    entry_11f3cc(rdram, ctx, runtime);
}

void entry_11f430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f430 inside entry_11f41c (0x11f41c - 0x11f478)
    ctx->pc = 0x11f430;
    entry_11f41c(rdram, ctx, runtime);
}

void entry_11f460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f460 inside entry_11f41c (0x11f41c - 0x11f478)
    ctx->pc = 0x11f460;
    entry_11f41c(rdram, ctx, runtime);
}

void entry_11f4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f4e8 inside entry_11f4bc (0x11f4bc - 0x11f568)
    ctx->pc = 0x11f4e8;
    entry_11f4bc(rdram, ctx, runtime);
}

void entry_11f4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f4f8 inside entry_11f4bc (0x11f4bc - 0x11f568)
    ctx->pc = 0x11f4f8;
    entry_11f4bc(rdram, ctx, runtime);
}

void entry_11f52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f52c inside entry_11f4bc (0x11f4bc - 0x11f568)
    ctx->pc = 0x11f52c;
    entry_11f4bc(rdram, ctx, runtime);
}

void entry_11f550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f550 inside entry_11f4bc (0x11f4bc - 0x11f568)
    ctx->pc = 0x11f550;
    entry_11f4bc(rdram, ctx, runtime);
}

void entry_11f554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f554 inside entry_11f4bc (0x11f4bc - 0x11f568)
    ctx->pc = 0x11f554;
    entry_11f4bc(rdram, ctx, runtime);
}

void entry_11f5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f5c0 inside entry_11f5a4 (0x11f5a4 - 0x11f5d4)
    ctx->pc = 0x11f5c0;
    entry_11f5a4(rdram, ctx, runtime);
}

void entry_11f600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f600 inside entry_11f5ec (0x11f5ec - 0x11f620)
    ctx->pc = 0x11f600;
    entry_11f5ec(rdram, ctx, runtime);
}

void entry_11f668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f668 inside entry_11f654 (0x11f654 - 0x11f6b0)
    ctx->pc = 0x11f668;
    entry_11f654(rdram, ctx, runtime);
}

void entry_11f698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f698 inside entry_11f654 (0x11f654 - 0x11f6b0)
    ctx->pc = 0x11f698;
    entry_11f654(rdram, ctx, runtime);
}

void entry_11f700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f700 inside EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25 (0x11f6b0 - 0x11f754)
    ctx->pc = 0x11f700;
    EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25(rdram, ctx, runtime);
}

void entry_11f714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f714 inside EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25 (0x11f6b0 - 0x11f754)
    ctx->pc = 0x11f714;
    EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25(rdram, ctx, runtime);
}

void entry_11f720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f720 inside EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25 (0x11f6b0 - 0x11f754)
    ctx->pc = 0x11f720;
    EvaluateApacg__FPP3ACGP3ALOffiP6VECTORN25(rdram, ctx, runtime);
}

void entry_11f828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f828 inside entry_11f824 (0x11f824 - 0x11f850)
    ctx->pc = 0x11f828;
    entry_11f824(rdram, ctx, runtime);
}

void entry_11f8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f8a0 inside GetApacgTimes__FPP3ACGPiPPf (0x11f850 - 0x11f8bc)
    ctx->pc = 0x11f8a0;
    GetApacgTimes__FPP3ACGPiPPf(rdram, ctx, runtime);
}

void entry_11f8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f8c4 inside entry_11f8bc (0x11f8bc - 0x11f91c)
    ctx->pc = 0x11f8c4;
    entry_11f8bc(rdram, ctx, runtime);
}

void entry_11f8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f8d0 inside entry_11f8bc (0x11f8bc - 0x11f91c)
    ctx->pc = 0x11f8d0;
    entry_11f8bc(rdram, ctx, runtime);
}

void entry_11f914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f914 inside entry_11f8bc (0x11f8bc - 0x11f91c)
    ctx->pc = 0x11f914;
    entry_11f8bc(rdram, ctx, runtime);
}

void entry_11f930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f930 inside entry_11f91c (0x11f91c - 0x11f94c)
    ctx->pc = 0x11f930;
    entry_11f91c(rdram, ctx, runtime);
}

void entry_11f988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f988 inside entry_11f97c (0x11f97c - 0x11f9f8)
    ctx->pc = 0x11f988;
    entry_11f97c(rdram, ctx, runtime);
}

void entry_11f9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f9a8 inside entry_11f97c (0x11f97c - 0x11f9f8)
    ctx->pc = 0x11f9a8;
    entry_11f97c(rdram, ctx, runtime);
}

void entry_11f9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f9b0 inside entry_11f97c (0x11f97c - 0x11f9f8)
    ctx->pc = 0x11f9b0;
    entry_11f97c(rdram, ctx, runtime);
}

void entry_11f9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11f9c4 inside entry_11f97c (0x11f97c - 0x11f9f8)
    ctx->pc = 0x11f9c4;
    entry_11f97c(rdram, ctx, runtime);
}

void entry_11fb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fb00 inside entry_11fad8 (0x11fad8 - 0x11fb0c)
    ctx->pc = 0x11fb00;
    entry_11fad8(rdram, ctx, runtime);
}

void entry_11fb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fb54 inside entry_11fb4c (0x11fb4c - 0x11fb98)
    ctx->pc = 0x11fb54;
    entry_11fb4c(rdram, ctx, runtime);
}

void entry_11fbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fbe0 inside entry_11fbc8 (0x11fbc8 - 0x11fc20)
    ctx->pc = 0x11fbe0;
    entry_11fbc8(rdram, ctx, runtime);
}

void entry_11fc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fc08 inside entry_11fbc8 (0x11fbc8 - 0x11fc20)
    ctx->pc = 0x11fc08;
    entry_11fbc8(rdram, ctx, runtime);
}

void entry_11fc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fc7c inside entry_11fc78 (0x11fc78 - 0x11fc90)
    ctx->pc = 0x11fc7c;
    entry_11fc78(rdram, ctx, runtime);
}

void entry_11fd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fd94 inside entry_11fd48 (0x11fd48 - 0x11fda0)
    ctx->pc = 0x11fd94;
    entry_11fd48(rdram, ctx, runtime);
}

void entry_11fd98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fd98 inside entry_11fd48 (0x11fd48 - 0x11fda0)
    ctx->pc = 0x11fd98;
    entry_11fd48(rdram, ctx, runtime);
}

void entry_11fe2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fe2c inside entry_11fe28 (0x11fe28 - 0x11fe40)
    ctx->pc = 0x11fe2c;
    entry_11fe28(rdram, ctx, runtime);
}

void entry_11fe78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fe78 inside entry_11fe60 (0x11fe60 - 0x11fed8)
    ctx->pc = 0x11fe78;
    entry_11fe60(rdram, ctx, runtime);
}

void entry_11fec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fec4 inside entry_11fe60 (0x11fe60 - 0x11fed8)
    ctx->pc = 0x11fec4;
    entry_11fe60(rdram, ctx, runtime);
}

void entry_11fec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x11fec8 inside entry_11fe60 (0x11fe60 - 0x11fed8)
    ctx->pc = 0x11fec8;
    entry_11fe60(rdram, ctx, runtime);
}

